<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.0"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GL" version="1.0"/>
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <package name="gobject-2.0"/>
  <c:include name="cogl/cogl.h"/>
  <namespace name="Cogl" version="1.0" shared-library="libclutter-glx-1.0.so.0" c:prefix="Cogl">
    <alias name="Angle" target="int32" c:type="CoglAngle"/>
    <alias name="Fixed" target="int32" c:type="CoglFixed"/>
    <alias name="Handle" target="any" c:type="CoglHandle"/>
    <constant name="AFIRST_BIT" value="64">
      <type name="int"/>
    </constant>
    <constant name="A_BIT" value="16">
      <type name="int"/>
    </constant>
    <enumeration name="AttributeType"
                 doc="Data types for the components of cogl_vertex_buffer_add()"
                 version="1.0"
                 glib:type-name="CoglAttributeType"
                 glib:get-type="cogl_attribute_type_get_type"
                 c:type="CoglAttributeType">
      <member name="byte"
              value="5120"
              c:identifier="COGL_ATTRIBUTE_TYPE_BYTE"
              glib:nick="byte"/>
      <member name="unsigned_byte"
              value="5121"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE"
              glib:nick="unsigned-byte"/>
      <member name="short"
              value="5122"
              c:identifier="COGL_ATTRIBUTE_TYPE_SHORT"
              glib:nick="short"/>
      <member name="unsigned_short"
              value="5123"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_SHORT"
              glib:nick="unsigned-short"/>
      <member name="float"
              value="5126"
              c:identifier="COGL_ATTRIBUTE_TYPE_FLOAT"
              glib:nick="float"/>
    </enumeration>
    <constant name="BGR_BIT" value="32">
      <type name="int"/>
    </constant>
    <enumeration name="BlendStringError"
                 doc="Error enumeration for the blend strings parser"
                 version="1.0"
                 glib:type-name="CoglBlendStringError"
                 glib:get-type="cogl_blend_string_error_get_type"
                 c:type="CoglBlendStringError"
                 glib:error-quark="cogl_blend_string_error_quark">
      <member name="parse_error"
              value="0"
              c:identifier="COGL_BLEND_STRING_ERROR_PARSE_ERROR"
              glib:nick="parse-error"/>
      <member name="argument_parse_error"
              value="1"
              c:identifier="COGL_BLEND_STRING_ERROR_ARGUMENT_PARSE_ERROR"
              glib:nick="argument-parse-error"/>
      <member name="invalid_error"
              value="2"
              c:identifier="COGL_BLEND_STRING_ERROR_INVALID_ERROR"
              glib:nick="invalid-error"/>
      <member name="gpu_unsupported_error"
              value="3"
              c:identifier="COGL_BLEND_STRING_ERROR_GPU_UNSUPPORTED_ERROR"
              glib:nick="gpu-unsupported-error"/>
    </enumeration>
    <bitfield name="BufferAccess"
              doc="The access hints for cogl_buffer_set_update_hint()"
              version="1.2"
              glib:type-name="CoglBufferAccess"
              glib:get-type="cogl_buffer_access_get_type"
              c:type="CoglBufferAccess">
      <member name="read"
              value="1"
              c:identifier="COGL_BUFFER_ACCESS_READ"
              glib:nick="read"/>
      <member name="write"
              value="2"
              c:identifier="COGL_BUFFER_ACCESS_WRITE"
              glib:nick="write"/>
      <member name="read_write"
              value="3"
              c:identifier="COGL_BUFFER_ACCESS_READ_WRITE"
              glib:nick="read-write"/>
    </bitfield>
    <bitfield name="BufferBit"
              doc="Types of auxiliary buffers"
              version="1.0"
              glib:type-name="CoglBufferBit"
              glib:get-type="cogl_buffer_bit_get_type"
              c:type="CoglBufferBit">
      <member name="color"
              value="1"
              c:identifier="COGL_BUFFER_BIT_COLOR"
              glib:nick="color"/>
      <member name="depth"
              value="2"
              c:identifier="COGL_BUFFER_BIT_DEPTH"
              glib:nick="depth"/>
      <member name="stencil"
              value="4"
              c:identifier="COGL_BUFFER_BIT_STENCIL"
              glib:nick="stencil"/>
    </bitfield>
    <bitfield name="BufferTarget"
              doc="Target flags for FBOs."
              version="0.8"
              glib:type-name="CoglBufferTarget"
              glib:get-type="cogl_buffer_target_get_type"
              c:type="CoglBufferTarget">
      <member name="window_buffer"
              value="2"
              c:identifier="COGL_WINDOW_BUFFER"
              glib:nick="window-buffer"/>
      <member name="offscreen_buffer"
              value="4"
              c:identifier="COGL_OFFSCREEN_BUFFER"
              glib:nick="offscreen-buffer"/>
    </bitfield>
    <enumeration name="BufferUpdateHint"
                 doc="The update hint on a buffer allows the user to give some detail on how often
the buffer data is going to be updated."
                 version="1.2"
                 glib:type-name="CoglBufferUpdateHint"
                 glib:get-type="cogl_buffer_update_hint_get_type"
                 c:type="CoglBufferUpdateHint">
      <member name="static"
              value="0"
              c:identifier="COGL_BUFFER_UPDATE_HINT_STATIC"
              glib:nick="static"/>
      <member name="dynamic"
              value="1"
              c:identifier="COGL_BUFFER_UPDATE_HINT_DYNAMIC"
              glib:nick="dynamic"/>
      <member name="stream"
              value="2"
              c:identifier="COGL_BUFFER_UPDATE_HINT_STREAM"
              glib:nick="stream"/>
    </enumeration>
    <enumeration name="BufferUsageHint"
                 doc="The usage hint on a buffer allows the user to give some clue on how the
buffer will be used."
                 version="1.2"
                 glib:type-name="CoglBufferUsageHint"
                 glib:get-type="cogl_buffer_usage_hint_get_type"
                 c:type="CoglBufferUsageHint">
      <member name="texture"
              value="0"
              c:identifier="COGL_BUFFER_USAGE_HINT_TEXTURE"
              glib:nick="texture"/>
    </enumeration>
    <record name="Color"
            c:type="CoglColor"
            doc="A structure for holding a color definition. The contents of
the CoglColor structure are private and should never by accessed
directly."
            version="1.0">
      <field name="red" writable="1">
        <type name="uint8" c:type="guint8"/>
      </field>
      <field name="green" writable="1">
        <type name="uint8" c:type="guint8"/>
      </field>
      <field name="blue" writable="1">
        <type name="uint8" c:type="guint8"/>
      </field>
      <field name="alpha" writable="1">
        <type name="uint8" c:type="guint8"/>
      </field>
      <field name="padding0" writable="1">
        <type name="uint32" c:type="guint32"/>
      </field>
      <field name="padding1" writable="1">
        <type name="uint32" c:type="guint32"/>
      </field>
      <field name="padding2" writable="1">
        <type name="uint32" c:type="guint32"/>
      </field>
      <constructor name="new"
                   c:identifier="cogl_color_new"
                   doc="Creates a new (empty) color
to free the allocated resources"
                   version="1.0">
        <return-value transfer-ownership="full">
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
      </constructor>
      <method name="copy"
              c:identifier="cogl_color_copy"
              doc="Creates a copy of @color
to free the allocate resources"
              version="1.0">
        <return-value transfer-ownership="full">
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
      </method>
      <method name="free"
              c:identifier="cogl_color_free"
              doc="Frees the resources allocated by cogl_color_new() and cogl_color_copy()"
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_from_4ub"
              c:identifier="cogl_color_set_from_4ub"
              doc="Sets the values of the passed channels into a #CoglColor."
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="red" transfer-ownership="none">
            <type name="uint8" c:type="guint8"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <type name="uint8" c:type="guint8"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <type name="uint8" c:type="guint8"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <type name="uint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_4f"
              c:identifier="cogl_color_set_from_4f"
              doc="Sets the values of the passed channels into a #CoglColor"
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="red" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_red_byte"
              c:identifier="cogl_color_get_red_byte"
              doc="Retrieves the red channel of @color as a byte value
between 0 and 255"
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="uint8" c:type="unsigned char"/>
        </return-value>
      </method>
      <method name="get_green_byte"
              c:identifier="cogl_color_get_green_byte"
              doc="Retrieves the green channel of @color as a byte value
between 0 and 255"
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="uint8" c:type="unsigned char"/>
        </return-value>
      </method>
      <method name="get_blue_byte"
              c:identifier="cogl_color_get_blue_byte"
              doc="Retrieves the blue channel of @color as a byte value
between 0 and 255"
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="uint8" c:type="unsigned char"/>
        </return-value>
      </method>
      <method name="get_alpha_byte"
              c:identifier="cogl_color_get_alpha_byte"
              doc="Retrieves the alpha channel of @color as a byte value
between 0 and 255"
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="uint8" c:type="unsigned char"/>
        </return-value>
      </method>
      <method name="get_red_float"
              c:identifier="cogl_color_get_red_float"
              doc="Retrieves the red channel of @color as a floating point
value between 0.0 and 1.0"
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="float" c:type="float"/>
        </return-value>
      </method>
      <method name="get_green_float"
              c:identifier="cogl_color_get_green_float"
              doc="Retrieves the green channel of @color as a floating point
value between 0.0 and 1.0"
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="float" c:type="float"/>
        </return-value>
      </method>
      <method name="get_blue_float"
              c:identifier="cogl_color_get_blue_float"
              doc="Retrieves the blue channel of @color as a floating point
value between 0.0 and 1.0"
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="float" c:type="float"/>
        </return-value>
      </method>
      <method name="get_alpha_float"
              c:identifier="cogl_color_get_alpha_float"
              doc="Retrieves the alpha channel of @color as a floating point
value between 0.0 and 1.0"
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="float" c:type="float"/>
        </return-value>
      </method>
      <method name="get_red"
              c:identifier="cogl_color_get_red"
              doc="Retrieves the red channel of @color as a fixed point
value between 0 and %1.0."
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="float" c:type="float"/>
        </return-value>
      </method>
      <method name="get_green"
              c:identifier="cogl_color_get_green"
              doc="Retrieves the green channel of @color as a fixed point
value between 0 and %1.0."
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="float" c:type="float"/>
        </return-value>
      </method>
      <method name="get_blue"
              c:identifier="cogl_color_get_blue"
              doc="Retrieves the blue channel of @color as a fixed point
value between 0 and %1.0."
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="float" c:type="float"/>
        </return-value>
      </method>
      <method name="get_alpha"
              c:identifier="cogl_color_get_alpha"
              doc="Retrieves the alpha channel of @color as a fixed point
value between 0 and %1.0."
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="float" c:type="float"/>
        </return-value>
      </method>
      <method name="premultiply"
              c:identifier="cogl_color_premultiply"
              doc="Converts a non-premultiplied color to a pre-multiplied color. For
example, semi-transparent red is (1.0, 0, 0, 0.5) when non-premultiplied
and (0.5, 0, 0, 0.5) when premultiplied."
              version="1.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <bitfield name="DebugFlags"
              glib:type-name="CoglDebugFlags"
              glib:get-type="cogl_debug_flags_get_type"
              c:type="CoglDebugFlags">
      <member name="slicing"
              value="2"
              c:identifier="COGL_DEBUG_SLICING"
              glib:nick="slicing"/>
      <member name="offscreen"
              value="4"
              c:identifier="COGL_DEBUG_OFFSCREEN"
              glib:nick="offscreen"/>
      <member name="draw"
              value="8"
              c:identifier="COGL_DEBUG_DRAW"
              glib:nick="draw"/>
      <member name="pango"
              value="16"
              c:identifier="COGL_DEBUG_PANGO"
              glib:nick="pango"/>
      <member name="rectangles"
              value="32"
              c:identifier="COGL_DEBUG_RECTANGLES"
              glib:nick="rectangles"/>
      <member name="handle"
              value="64"
              c:identifier="COGL_DEBUG_HANDLE"
              glib:nick="handle"/>
      <member name="blend_strings"
              value="128"
              c:identifier="COGL_DEBUG_BLEND_STRINGS"
              glib:nick="blend-strings"/>
      <member name="disable_batching"
              value="256"
              c:identifier="COGL_DEBUG_DISABLE_BATCHING"
              glib:nick="disable-batching"/>
      <member name="disable_vbos"
              value="512"
              c:identifier="COGL_DEBUG_DISABLE_VBOS"
              glib:nick="disable-vbos"/>
      <member name="journal"
              value="1024"
              c:identifier="COGL_DEBUG_JOURNAL"
              glib:nick="journal"/>
      <member name="batching"
              value="2048"
              c:identifier="COGL_DEBUG_BATCHING"
              glib:nick="batching"/>
      <member name="disable_software_transform"
              value="4096"
              c:identifier="COGL_DEBUG_DISABLE_SOFTWARE_TRANSFORM"
              glib:nick="disable-software-transform"/>
      <member name="matrices"
              value="8192"
              c:identifier="COGL_DEBUG_MATRICES"
              glib:nick="matrices"/>
      <member name="force_scanline_paths"
              value="16384"
              c:identifier="COGL_DEBUG_FORCE_SCANLINE_PATHS"
              glib:nick="force-scanline-paths"/>
      <member name="atlas"
              value="32768"
              c:identifier="COGL_DEBUG_ATLAS"
              glib:nick="atlas"/>
      <member name="dump_atlas_image"
              value="65536"
              c:identifier="COGL_DEBUG_DUMP_ATLAS_IMAGE"
              glib:nick="dump-atlas-image"/>
      <member name="disable_atlas"
              value="131072"
              c:identifier="COGL_DEBUG_DISABLE_ATLAS"
              glib:nick="disable-atlas"/>
      <member name="opengl"
              value="262144"
              c:identifier="COGL_DEBUG_OPENGL"
              glib:nick="opengl"/>
    </bitfield>
    <enumeration name="DriverError"
                 glib:type-name="CoglDriverError"
                 glib:get-type="cogl_driver_error_get_type"
                 c:type="CoglDriverError">
      <member name="unknown_version"
              value="0"
              c:identifier="COGL_DRIVER_ERROR_UNKNOWN_VERSION"
              glib:nick="unknown-version"/>
      <member name="invalid_version"
              value="1"
              c:identifier="COGL_DRIVER_ERROR_INVALID_VERSION"
              glib:nick="invalid-version"/>
    </enumeration>
    <constant name="FIXED_0_5" value="32768">
      <type name="int"/>
    </constant>
    <constant name="FIXED_1" value="1">
      <type name="int"/>
    </constant>
    <constant name="FIXED_2_PI" value="411775">
      <type name="int"/>
    </constant>
    <constant name="FIXED_BITS" value="32">
      <type name="int"/>
    </constant>
    <constant name="FIXED_EPSILON" value="1">
      <type name="int"/>
    </constant>
    <constant name="FIXED_MAX" value="2147483647">
      <type name="int"/>
    </constant>
    <constant name="FIXED_MIN" value="-2147483648">
      <type name="int"/>
    </constant>
    <constant name="FIXED_PI" value="205887">
      <type name="int"/>
    </constant>
    <constant name="FIXED_PI_2" value="102944">
      <type name="int"/>
    </constant>
    <constant name="FIXED_PI_4" value="51472">
      <type name="int"/>
    </constant>
    <constant name="FIXED_Q" value="-16">
      <type name="int"/>
    </constant>
    <bitfield name="FeatureFlags"
              doc="Flags for the supported features."
              version="0.8"
              glib:type-name="CoglFeatureFlags"
              glib:get-type="cogl_feature_flags_get_type"
              c:type="CoglFeatureFlags">
      <member name="texture_rectangle"
              value="2"
              c:identifier="COGL_FEATURE_TEXTURE_RECTANGLE"
              glib:nick="texture-rectangle"/>
      <member name="texture_npot"
              value="4"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT"
              glib:nick="texture-npot"/>
      <member name="texture_yuv"
              value="8"
              c:identifier="COGL_FEATURE_TEXTURE_YUV"
              glib:nick="texture-yuv"/>
      <member name="texture_read_pixels"
              value="16"
              c:identifier="COGL_FEATURE_TEXTURE_READ_PIXELS"
              glib:nick="texture-read-pixels"/>
      <member name="shaders_glsl"
              value="32"
              c:identifier="COGL_FEATURE_SHADERS_GLSL"
              glib:nick="shaders-glsl"/>
      <member name="offscreen"
              value="64"
              c:identifier="COGL_FEATURE_OFFSCREEN"
              glib:nick="offscreen"/>
      <member name="offscreen_multisample"
              value="128"
              c:identifier="COGL_FEATURE_OFFSCREEN_MULTISAMPLE"
              glib:nick="offscreen-multisample"/>
      <member name="offscreen_blit"
              value="256"
              c:identifier="COGL_FEATURE_OFFSCREEN_BLIT"
              glib:nick="offscreen-blit"/>
      <member name="four_clip_planes"
              value="512"
              c:identifier="COGL_FEATURE_FOUR_CLIP_PLANES"
              glib:nick="four-clip-planes"/>
      <member name="stencil_buffer"
              value="1024"
              c:identifier="COGL_FEATURE_STENCIL_BUFFER"
              glib:nick="stencil-buffer"/>
      <member name="vbos"
              value="2048"
              c:identifier="COGL_FEATURE_VBOS"
              glib:nick="vbos"/>
      <member name="pbos"
              value="4096"
              c:identifier="COGL_FEATURE_PBOS"
              glib:nick="pbos"/>
      <member name="unsigned_int_indices"
              value="8192"
              c:identifier="COGL_FEATURE_UNSIGNED_INT_INDICES"
              glib:nick="unsigned-int-indices"/>
    </bitfield>
    <enumeration name="FogMode"
                 doc="The fog mode determines the equation used to calculate the fogging blend
factor while fogging is enabled. The simplest %COGL_FOG_MODE_LINEAR mode
determines f as:
|[
f = end - eye_distance / end - start
]|
Where eye_distance is the distance of the current fragment in eye
coordinates from the origin."
                 version="1.0"
                 glib:type-name="CoglFogMode"
                 glib:get-type="cogl_fog_mode_get_type"
                 c:type="CoglFogMode">
      <member name="linear"
              value="0"
              c:identifier="COGL_FOG_MODE_LINEAR"
              glib:nick="linear"/>
      <member name="exponential"
              value="1"
              c:identifier="COGL_FOG_MODE_EXPONENTIAL"
              glib:nick="exponential"/>
      <member name="exponential_squared"
              value="2"
              c:identifier="COGL_FOG_MODE_EXPONENTIAL_SQUARED"
              glib:nick="exponential-squared"/>
    </enumeration>
    <callback name="FuncPtr"
              c:type="CoglFuncPtr"
              doc="The type used by cogl for function pointers, note that this type
is used as a generic catch-all cast for function pointers and the
actual arguments and return type may be different.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </callback>
    <glib:boxed c:type="CoglHandle"
                glib:name="Handle"
                glib:type-name="CoglHandle"
                glib:get-type="cogl_handle_get_type">
      <method name="ref"
              c:identifier="cogl_handle_ref"
              doc="Increases the reference count of @handle by 1">
        <return-value transfer-ownership="full">
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
      </method>
      <method name="unref"
              c:identifier="cogl_handle_unref"
              doc="Drecreases the reference count of @handle by 1; if the reference
count reaches 0, the resources allocated by @handle will be freed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </glib:boxed>
    <enumeration name="IndicesType"
                 doc="You should aim to use the smallest data type that gives you enough
range, since it reduces the size of your index array and can help
reduce the demand on memory bandwidth.
Note that %COGL_INDICES_TYPE_UNSIGNED_INT is only supported if the
%COGL_FEATURE_UNSIGNED_INT_INDICES feature is available. This
should always be available on OpenGL but on OpenGL ES it will only
be available if the GL_OES_element_index_uint extension is
advertized."
                 glib:type-name="CoglIndicesType"
                 glib:get-type="cogl_indices_type_get_type"
                 c:type="CoglIndicesType">
      <member name="byte"
              value="0"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_BYTE"
              glib:nick="byte"/>
      <member name="short"
              value="1"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_SHORT"
              glib:nick="short"/>
      <member name="int"
              value="2"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_INT"
              glib:nick="int"/>
    </enumeration>
    <enumeration name="MaterialAlphaFunc"
                 doc="Alpha testing happens before blending primitives with the framebuffer and
gives an opportunity to discard fragments based on a comparison with the
incoming alpha value and a reference alpha value. The #CoglMaterialAlphaFunc
determines how the comparison is done."
                 glib:type-name="CoglMaterialAlphaFunc"
                 glib:get-type="cogl_material_alpha_func_get_type"
                 c:type="CoglMaterialAlphaFunc">
      <member name="never"
              value="512"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_NEVER"
              glib:nick="never"/>
      <member name="less"
              value="513"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_LESS"
              glib:nick="less"/>
      <member name="equal"
              value="514"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_EQUAL"
              glib:nick="equal"/>
      <member name="lequal"
              value="515"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_LEQUAL"
              glib:nick="lequal"/>
      <member name="greater"
              value="516"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_GREATER"
              glib:nick="greater"/>
      <member name="notequal"
              value="517"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_NOTEQUAL"
              glib:nick="notequal"/>
      <member name="gequal"
              value="518"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_GEQUAL"
              glib:nick="gequal"/>
      <member name="always"
              value="519"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_ALWAYS"
              glib:nick="always"/>
    </enumeration>
    <enumeration name="MaterialFilter"
                 doc="Texture filtering is used whenever the current pixel maps either to more
than one texture element (texel) or less than one. These filter enums
correspond to different strategies used to come up with a pixel color, by
possibly referring to multiple neighbouring texels and taking a weighted
average or simply using the nearest texel."
                 glib:type-name="CoglMaterialFilter"
                 glib:get-type="cogl_material_filter_get_type"
                 c:type="CoglMaterialFilter">
      <member name="nearest"
              value="9728"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST"
              glib:nick="nearest"/>
      <member name="linear"
              value="9729"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR"
              glib:nick="linear"/>
      <member name="nearest_mipmap_nearest"
              value="9984"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST"
              glib:nick="nearest-mipmap-nearest"/>
      <member name="linear_mipmap_nearest"
              value="9985"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_NEAREST"
              glib:nick="linear-mipmap-nearest"/>
      <member name="nearest_mipmap_linear"
              value="9986"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_LINEAR"
              glib:nick="nearest-mipmap-linear"/>
      <member name="linear_mipmap_linear"
              value="9987"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_LINEAR"
              glib:nick="linear-mipmap-linear"/>
    </enumeration>
    <enumeration name="MaterialLayerType"
                 doc="Available types of layers for a #CoglMaterial. This enumeration
might be expanded in later versions."
                 version="1.0"
                 glib:type-name="CoglMaterialLayerType"
                 glib:get-type="cogl_material_layer_type_get_type"
                 c:type="CoglMaterialLayerType">
      <member name="texture"
              value="0"
              c:identifier="COGL_MATERIAL_LAYER_TYPE_TEXTURE"
              glib:nick="texture"/>
    </enumeration>
    <record name="Matrix"
            c:type="CoglMatrix"
            doc="A CoglMatrix holds a 4x4 transform matrix. This is a single precision,
column-major matrix which means it is compatible with what OpenGL expects.
A CoglMatrix can represent transforms such as, rotations, scaling,
translation, sheering, and linear projections. You can combine these
transforms by multiplying multiple matrices in the order you want them
applied.
The transformation of a vertex (x, y, z, w) by a CoglMatrix is given by:
|[
x_new = xx * x + xy * y + xz * z + xw * w
y_new = yx * x + yy * y + yz * z + yw * w
z_new = zx * x + zy * y + zz * z + zw * w
w_new = wx * x + wy * y + wz * z + ww * w
]|
Where w is normally 1
&lt;note&gt;You must consider the members of the CoglMatrix structure read only,
and all matrix modifications must be done via the cogl_matrix API. This
allows Cogl to annotate the matrices internally. Violation of this will give
undefined results. If you need to initialize a matrix with a constant other
than the identity matrix you can use cogl_matrix_init_from_array().&lt;/note&gt;">
      <field name="xx" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="yx" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="zx" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="wx" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="xy" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="yy" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="zy" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="wy" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="xz" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="yz" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="zz" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="wz" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="xw" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="yw" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="zw" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="ww" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="inv" writable="1">
        <array zero-terminated="0" c:type="float" fixed-size="16">
          <type name="float"/>
        </array>
      </field>
      <field name="type" writable="1">
        <type name="uint" c:type="unsigned"/>
      </field>
      <field name="flags" writable="1">
        <type name="uint" c:type="unsigned"/>
      </field>
      <field name="_padding3" writable="1">
        <type name="uint" c:type="unsigned"/>
      </field>
      <method name="init_identity"
              c:identifier="cogl_matrix_init_identity"
              doc="Resets matrix to the identity matrix:
|[
.xx=1; .xy=0; .xz=0; .xw=0;
.yx=0; .yy=1; .yz=0; .yw=0;
.zx=0; .zy=0; .zz=1; .zw=0;
.wx=0; .wy=0; .wz=0; .ww=1;
]|">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="multiply"
              c:identifier="cogl_matrix_multiply"
              doc="Multiplies the two supplied matrices together and stores
the resulting matrix inside @result">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="a" transfer-ownership="none">
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate"
              c:identifier="cogl_matrix_rotate"
              doc="Multiplies @matrix with a rotation matrix that applies a rotation
of @angle degrees around the specified 3D vector.">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="angle" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate"
              c:identifier="cogl_matrix_translate"
              doc="Multiplies @matrix with a transform matrix that translates along
the X, Y and Z axis.">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale"
              c:identifier="cogl_matrix_scale"
              doc="Multiplies @matrix with a transform matrix that scales along the X,
Y and Z axis.">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="sx" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="sy" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="sz" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="frustum"
              c:identifier="cogl_matrix_frustum"
              doc="Multiplies @matrix by the given frustum perspective matrix.">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="left" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective"
              c:identifier="cogl_matrix_perspective"
              doc="Multiplies @matrix by the described perspective matrix
&lt;note&gt;You should be careful not to have to great a @z_far / @z_near ratio
since that will reduce the effectiveness of depth testing since there wont
be enough precision to identify the depth of objects near to each
other.&lt;/note&gt;">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fov_y" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="aspect"
                     transfer-ownership="none"
                     doc=" for the x axis.">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="z_near"
                     transfer-ownership="none"
                     doc=" a positive number.">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="ortho"
              c:identifier="cogl_matrix_ortho"
              doc="Multiplies @matrix by a parallel projection matrix.">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="left" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="z_near"
                     transfer-ownership="none"
                     doc=" the plane is behind the viewer)">
            <type name="float" c:type="float"/>
          </parameter>
          <parameter name="z_far"
                     transfer-ownership="none"
                     doc=" the plane is behind the viewer)">
            <type name="float" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_array"
              c:identifier="cogl_matrix_init_from_array"
              doc="Initializes @matrix with the contents of @array">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <type name="float" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_array"
              c:identifier="cogl_matrix_get_array"
              doc="Casts @matrix to a float array which can be directly passed to OpenGL.">
        <return-value transfer-ownership="none">
          <type name="float" c:type="float*"/>
        </return-value>
      </method>
      <method name="get_inverse"
              c:identifier="cogl_matrix_get_inverse"
              doc="Gets the inverse transform of a given matrix and uses it to initialize
a new #CoglMatrix.
&lt;note&gt;Although the first parameter is annotated as const to indicate
that the transform it represents isn&apos;t modified this function may
technically save a copy of the inverse transform within the given
#CoglMatrix so that subsequent requests for the inverse transform may
avoid costly inversion calculations.&lt;/note&gt;
for degenerate transformations that can&apos;t be inverted (in this case the"
              version="1.2">
        <return-value transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="inverse"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     doc="The destination for a 4x4 inverse transformation matrix">
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_point"
              c:identifier="cogl_matrix_transform_point"
              doc="Transforms a point whos position is given and returned as four float
components.">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full"
                     doc="The X component of your points position">
            <type name="float" c:type="float*"/>
          </parameter>
          <parameter name="y"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full"
                     doc="The Y component of your points position">
            <type name="float" c:type="float*"/>
          </parameter>
          <parameter name="z"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full"
                     doc="The Z component of your points position">
            <type name="float" c:type="float*"/>
          </parameter>
          <parameter name="w"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full"
                     doc="The W component of your points position">
            <type name="float" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <constant name="PIXEL_FORMAT_24" value="2">
      <type name="int"/>
    </constant>
    <constant name="PIXEL_FORMAT_32" value="3">
      <type name="int"/>
    </constant>
    <constant name="PREMULT_BIT" value="128">
      <type name="int"/>
    </constant>
    <enumeration name="PixelFormat"
                 doc="Pixel formats used by COGL. For the formats with a byte per
component, the order of the components specify the order in
increasing memory addresses. So for example
%COGL_PIXEL_FORMAT_RGB_888 would have the red component in the
lowest address, green in the next address and blue after that
regardless of the endinanness of the system.
For the 16-bit formats the component order specifies the order
within a 16-bit number from most significant bit to least
significant. So for %COGL_PIXEL_FORMAT_RGB_565, the red component
would be in bits 11-15, the green component would be in 6-11 and
the blue component would be in 1-5. Therefore the order in memory
depends on the endianness of the system.
When uploading a texture %COGL_PIXEL_FORMAT_ANY can be used as the
internal format. Cogl will try to pick the best format to use
internally and convert the texture data if necessary."
                 version="0.8"
                 glib:type-name="CoglPixelFormat"
                 glib:get-type="cogl_pixel_format_get_type"
                 c:type="CoglPixelFormat">
      <member name="any"
              value="0"
              c:identifier="COGL_PIXEL_FORMAT_ANY"
              glib:nick="any"/>
      <member name="a_8"
              value="17"
              c:identifier="COGL_PIXEL_FORMAT_A_8"
              glib:nick="a-8"/>
      <member name="rgb_565"
              value="4"
              c:identifier="COGL_PIXEL_FORMAT_RGB_565"
              glib:nick="rgb-565"/>
      <member name="rgba_4444"
              value="21"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444"
              glib:nick="rgba-4444"/>
      <member name="rgba_5551"
              value="22"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551"
              glib:nick="rgba-5551"/>
      <member name="yuv"
              value="7"
              c:identifier="COGL_PIXEL_FORMAT_YUV"
              glib:nick="yuv"/>
      <member name="g_8"
              value="8"
              c:identifier="COGL_PIXEL_FORMAT_G_8"
              glib:nick="g-8"/>
      <member name="rgb_888"
              value="2"
              c:identifier="COGL_PIXEL_FORMAT_RGB_888"
              glib:nick="rgb-888"/>
      <member name="bgr_888"
              value="34"
              c:identifier="COGL_PIXEL_FORMAT_BGR_888"
              glib:nick="bgr-888"/>
      <member name="rgba_8888"
              value="19"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888"
              glib:nick="rgba-8888"/>
      <member name="bgra_8888"
              value="51"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888"
              glib:nick="bgra-8888"/>
      <member name="argb_8888"
              value="83"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888"
              glib:nick="argb-8888"/>
      <member name="abgr_8888"
              value="115"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888"
              glib:nick="abgr-8888"/>
      <member name="rgba_8888_pre"
              value="147"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888_PRE"
              glib:nick="rgba-8888-pre"/>
      <member name="bgra_8888_pre"
              value="179"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888_PRE"
              glib:nick="bgra-8888-pre"/>
      <member name="argb_8888_pre"
              value="211"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888_PRE"
              glib:nick="argb-8888-pre"/>
      <member name="abgr_8888_pre"
              value="243"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888_PRE"
              glib:nick="abgr-8888-pre"/>
      <member name="rgba_4444_pre"
              value="149"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444_PRE"
              glib:nick="rgba-4444-pre"/>
      <member name="rgba_5551_pre"
              value="150"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551_PRE"
              glib:nick="rgba-5551-pre"/>
    </enumeration>
    <constant name="RADIANS_TO_DEGREES" value="3754936">
      <type name="int"/>
    </constant>
    <bitfield name="ReadPixelsFlags"
              doc="Flags for cogl_read_pixels()"
              version="1.0"
              glib:type-name="CoglReadPixelsFlags"
              glib:get-type="cogl_read_pixels_flags_get_type"
              c:type="CoglReadPixelsFlags">
      <member name="color_buffer"
              value="1"
              c:identifier="COGL_READ_PIXELS_COLOR_BUFFER"
              glib:nick="color-buffer"/>
    </bitfield>
    <constant name="SQRTI_ARG_10_PERCENT" value="5590">
      <type name="int"/>
    </constant>
    <constant name="SQRTI_ARG_5_PERCENT" value="210">
      <type name="int"/>
    </constant>
    <constant name="SQRTI_ARG_MAX" value="4194303">
      <type name="int"/>
    </constant>
    <enumeration name="ShaderType"
                 doc="Types of shaders"
                 version="1.0"
                 glib:type-name="CoglShaderType"
                 glib:get-type="cogl_shader_type_get_type"
                 c:type="CoglShaderType">
      <member name="vertex"
              value="0"
              c:identifier="COGL_SHADER_TYPE_VERTEX"
              glib:nick="vertex"/>
      <member name="fragment"
              value="1"
              c:identifier="COGL_SHADER_TYPE_FRAGMENT"
              glib:nick="fragment"/>
    </enumeration>
    <constant name="TEXTURE_MAX_WASTE" value="127">
      <type name="int"/>
    </constant>
    <bitfield name="TextureFlags"
              doc="Flags to pass to the cogl_texture_new_* family of functions."
              version="1.0"
              glib:type-name="CoglTextureFlags"
              glib:get-type="cogl_texture_flags_get_type"
              c:type="CoglTextureFlags">
      <member name="none"
              value="0"
              c:identifier="COGL_TEXTURE_NONE"
              glib:nick="none"/>
      <member name="no_auto_mipmap"
              value="1"
              c:identifier="COGL_TEXTURE_NO_AUTO_MIPMAP"
              glib:nick="no-auto-mipmap"/>
      <member name="no_slicing"
              value="2"
              c:identifier="COGL_TEXTURE_NO_SLICING"
              glib:nick="no-slicing"/>
      <member name="no_atlas"
              value="4"
              c:identifier="COGL_TEXTURE_NO_ATLAS"
              glib:nick="no-atlas"/>
    </bitfield>
    <record name="TextureVertex"
            c:type="CoglTextureVertex"
            doc="Used to specify vertex information when calling cogl_polygon()">
      <field name="x" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="tx" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="ty" writable="1">
        <type name="float" c:type="float"/>
      </field>
      <field name="color" writable="1">
        <type name="Color" c:type="CoglColor"/>
      </field>
    </record>
    <constant name="UNORDERED_MASK" value="15">
      <type name="int"/>
    </constant>
    <constant name="UNPREMULT_MASK" value="127">
      <type name="int"/>
    </constant>
    <enumeration name="VerticesMode"
                 doc="How vertices passed to cogl_vertex_buffer_draw() and
cogl_vertex_buffer_draw_elements() should be interpreted"
                 version="1.0"
                 glib:type-name="CoglVerticesMode"
                 glib:get-type="cogl_vertices_mode_get_type"
                 c:type="CoglVerticesMode">
      <member name="points"
              value="0"
              c:identifier="COGL_VERTICES_MODE_POINTS"
              glib:nick="points"/>
      <member name="line_strip"
              value="3"
              c:identifier="COGL_VERTICES_MODE_LINE_STRIP"
              glib:nick="line-strip"/>
      <member name="line_loop"
              value="2"
              c:identifier="COGL_VERTICES_MODE_LINE_LOOP"
              glib:nick="line-loop"/>
      <member name="lines"
              value="1"
              c:identifier="COGL_VERTICES_MODE_LINES"
              glib:nick="lines"/>
      <member name="triangle_strip"
              value="5"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_STRIP"
              glib:nick="triangle-strip"/>
      <member name="triangle_fan"
              value="6"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_FAN"
              glib:nick="triangle-fan"/>
      <member name="triangles"
              value="4"
              c:identifier="COGL_VERTICES_MODE_TRIANGLES"
              glib:nick="triangles"/>
    </enumeration>
    <function name="angle_cos"
              c:identifier="cogl_angle_cos"
              doc="Computes the cosine of @angle"
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <type name="Angle" c:type="CoglAngle"/>
        </parameter>
      </parameters>
    </function>
    <function name="angle_sin"
              c:identifier="cogl_angle_sin"
              doc="Computes the sine of @angle"
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <type name="Angle" c:type="CoglAngle"/>
        </parameter>
      </parameters>
    </function>
    <function name="angle_tan"
              c:identifier="cogl_angle_tan"
              doc="Computes the tangent of @angle"
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <type name="Angle" c:type="CoglAngle"/>
        </parameter>
      </parameters>
    </function>
    <function name="begin_gl"
              c:identifier="cogl_begin_gl"
              doc="We do not advise nor reliably support the interleaving of raw GL drawing and
Cogl drawing functions, but if you insist, cogl_begin_gl() and cogl_end_gl()
provide a simple mechanism that may at least give you a fighting chance of
succeeding.
through the modification of GL state; that will never be reliably supported,
but if you are trying to do something like:
|[
{
- setup some OpenGL state.
- draw using OpenGL (e.g. glDrawArrays() )
- reset modified OpenGL state.
- continue using Cogl to draw
}
]|
You should surround blocks of drawing using raw GL with cogl_begin_gl()
and cogl_end_gl():
|[
{
cogl_begin_gl ();
- setup some OpenGL state.
- draw using OpenGL (e.g. glDrawArrays() )
- reset modified OpenGL state.
cogl_end_gl ();
- continue using Cogl to draw
}
]|
Don&apos;t ever try and do:
|[
{
- setup some OpenGL state.
- use Cogl to draw
- reset modified OpenGL state.
}
]|
When the internals of Cogl evolves, this is very liable to break.
This function will flush all batched primitives, and subsequently flush
all internal Cogl state to OpenGL as if it were going to draw something
itself.
The result is that the OpenGL modelview matrix will be setup; the state
corresponding to the current source material will be set up and other world
state such as backface culling, depth and fogging enabledness will be sent
to OpenGL.
&lt;note&gt;No special material state is flushed, so if you want Cogl to setup a
simplified material state it is your responsibility to set a simple source
material before calling cogl_begin_gl(). E.g. by calling
cogl_set_source_color4ub().&lt;/note&gt;
&lt;note&gt;It is your responsibility to restore any OpenGL state that you modify
to how it was after calling cogl_begin_gl() if you don&apos;t do this then the
result of further Cogl calls is undefined.&lt;/note&gt;
&lt;note&gt;You can not nest begin/end blocks.&lt;/note&gt;
Again we would like to stress, we do not advise the use of this API and if
possible we would prefer to improve Cogl than have developers require raw
OpenGL."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="bitmap_get_size_from_file"
              c:identifier="cogl_bitmap_get_size_from_file"
              doc="Parses an image file enough to extract the width and height
of the bitmap."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="width"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   doc="return location for the bitmap width, or %NULL">
          <type name="int" c:type="int*"/>
        </parameter>
        <parameter name="height"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   doc="return location for the bitmap height, or %NULL">
          <type name="int" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bitmap_new_from_file"
              c:identifier="cogl_bitmap_new_from_file"
              doc="Loads an image file from disk. This function can be safely called from
within a thread.
%COGL_INVALID_HANDLE if loading the image failed."
              version="1.0"
              throws="1">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_get_size"
              c:identifier="cogl_buffer_get_size"
              doc="Retrieves the size of buffer"
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="uint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_get_size_EXP"
              c:identifier="cogl_buffer_get_size_EXP">
      <return-value transfer-ownership="none">
        <type name="uint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_get_update_hint"
              c:identifier="cogl_buffer_get_update_hint"
              doc="Retrieves the update hints set using cogl_buffer_set_update_hint()"
              version="1.2">
      <return-value transfer-ownership="full">
        <type name="BufferUpdateHint" c:type="CoglBufferUpdateHint"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_get_update_hint_EXP"
              c:identifier="cogl_buffer_get_update_hint_EXP">
      <return-value transfer-ownership="full">
        <type name="BufferUpdateHint" c:type="CoglBufferUpdateHint"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_get_usage_hint"
              c:identifier="cogl_buffer_get_usage_hint"
              doc="Retrieves the usage hint set using cogl_buffer_set_usage_hint()"
              version="1.2">
      <return-value transfer-ownership="full">
        <type name="BufferUsageHint" c:type="CoglBufferUsageHint"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_get_usage_hint_EXP"
              c:identifier="cogl_buffer_get_usage_hint_EXP">
      <return-value transfer-ownership="full">
        <type name="BufferUsageHint" c:type="CoglBufferUsageHint"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_map"
              c:identifier="cogl_buffer_map"
              doc="Maps the buffer into the application address space for direct access."
              version="1.2">
      <return-value transfer-ownership="full">
        <array c:type="guint8*">
          <type name="uint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="access" transfer-ownership="none">
          <type name="BufferAccess" c:type="CoglBufferAccess"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_map_EXP" c:identifier="cogl_buffer_map_EXP">
      <return-value transfer-ownership="full">
        <array c:type="guint8*">
          <type name="uint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="access" transfer-ownership="none">
          <type name="BufferAccess" c:type="CoglBufferAccess"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_set_data"
              c:identifier="cogl_buffer_set_data"
              doc="Updates part of the buffer with new data from @data. Where to put this new
data is controlled by @offset and @offset + @data should be less than the
buffer size."
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none" doc="in the buffer">
          <type name="size_t" c:type="gsize"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <array c:type="guint8*">
            <type name="uint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <type name="size_t" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_set_data_EXP"
              c:identifier="cogl_buffer_set_data_EXP">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <type name="size_t" c:type="gsize"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <array c:type="guint8*">
            <type name="uint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <type name="size_t" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_set_update_hint"
              c:identifier="cogl_buffer_set_update_hint"
              doc="Sets the update hint on a buffer. See #CoglBufferUpdateHint for a description
of the available hints."
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="hint" transfer-ownership="none">
          <type name="BufferUpdateHint" c:type="CoglBufferUpdateHint"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_set_update_hint_EXP"
              c:identifier="cogl_buffer_set_update_hint_EXP">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="hint" transfer-ownership="none">
          <type name="BufferUpdateHint" c:type="CoglBufferUpdateHint"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_set_usage_hint"
              c:identifier="cogl_buffer_set_usage_hint"
              doc="Sets the usage hint on a buffer. See #CoglBufferUsageHint for a description
of the available hints."
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="hint" transfer-ownership="none">
          <type name="BufferUsageHint" c:type="CoglBufferUsageHint"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_set_usage_hint_EXP"
              c:identifier="cogl_buffer_set_usage_hint_EXP">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="hint" transfer-ownership="none">
          <type name="BufferUsageHint" c:type="CoglBufferUsageHint"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_unmap"
              c:identifier="cogl_buffer_unmap"
              doc="Unmaps a buffer previously mapped by cogl_buffer_map()."
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_unmap_EXP" c:identifier="cogl_buffer_unmap_EXP">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_extension"
              c:identifier="cogl_check_extension"
              doc="Check whether @name occurs in list of extensions in @ext.
not appropriate to expose OpenGL extensions through the Cogl API. This
function can be replaced by the following equivalent code:
|[
]|"
              deprecated="OpenGL is an implementation detail for Cogl and so it&apos;s"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="ext" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clear"
              c:identifier="cogl_clear"
              doc="Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
        <parameter name="buffers"
                   transfer-ownership="none"
                   doc=" buffers to clear">
          <type name="ulong" c:type="unsigned long"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_ensure"
              c:identifier="cogl_clip_ensure"
              doc="Ensures that the current clipping region has been set in GL. This
will automatically be called before any Cogl primitives but it
maybe be neccessary to call if you are using raw GL calls with
clipping."
              version="1.0"
              deprecated="Calling this function has no effect"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_pop"
              c:identifier="cogl_clip_pop"
              doc="Reverts the clipping region to the state before the last call to
cogl_clip_push().">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_push"
              c:identifier="cogl_clip_push"
              doc="Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are transformed by the
current model-view matrix.
The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop().
with other API that specify rectangles in model space, and when used
with a coordinate space that puts the origin at the center and y+
extending up, it&apos;s awkward to use. Please use cogl_clip_push_rectangle()
instead"
              deprecated="The x, y, width, height arguments are inconsistent"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_offset" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_offset" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_push_from_path"
              c:identifier="cogl_clip_push_from_path"
              doc="Sets a new clipping area using the current path. The current path
is then cleared. The clipping area is intersected with the previous
clipping area. To restore the previous clipping area, call
cogl_clip_pop()."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_push_from_path_preserve"
              c:identifier="cogl_clip_push_from_path_preserve"
              doc="Sets a new clipping area using the current path. The current path
is then cleared. The clipping area is intersected with the previous
clipping area. To restore the previous clipping area, call
cogl_clip_pop()."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_push_rectangle"
              c:identifier="cogl_clip_push_rectangle"
              doc="Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are transformed by the
current model-view matrix.
The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop()."
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x0" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y0" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_push_window_rect"
              c:identifier="cogl_clip_push_window_rect"
              doc="Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are not transformed by the
current model-view matrix.
The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop()."
              deprecated="Use cogl_clip_push_window_rectangle() instead"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_offset" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_offset" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_push_window_rectangle"
              c:identifier="cogl_clip_push_window_rectangle"
              doc="Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are not transformed by the
current model-view matrix.
The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop()."
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_offset" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="y_offset" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_stack_restore"
              c:identifier="cogl_clip_stack_restore"
              doc="Restore the state of the clipping stack that was previously saved
by cogl_clip_stack_save().
the clip stack when switching back from an offscreen framebuffer,
but it&apos;s not necessary anymore given that framebuffers now own
separate clip stacks which will be automatically switched between
when a new buffer is set. Calling this function has no effect"
              version="0.8.2"
              deprecated="This was originally added to allow us to restore"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_stack_save"
              c:identifier="cogl_clip_stack_save"
              doc="Save the entire state of the clipping stack and then clear all
clipping. The previous state can be returned to with
cogl_clip_stack_restore(). Each call to cogl_clip_push() after this
must be matched by a call to cogl_clip_pop() before calling
cogl_clip_stack_restore().
clip stack when switching to an offscreen framebuffer, but it&apos;s
not necessary anymore given that framebuffers now own separate
clip stacks which will be automatically switched between when a
new buffer is set. Calling this function has no effect"
              version="0.8.2"
              deprecated="This was originally added to allow us to save the"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="color_equal"
              c:identifier="cogl_color_equal"
              doc="Compares two #CoglColor&lt;!-- --&gt;s and checks if they are the same.
This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using #CoglColor&lt;!-- --&gt;s as keys in a #GHashTable."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <type name="any" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <type name="any" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="create_program"
              c:identifier="cogl_create_program"
              doc="Create a new cogl program object that can be used to replace parts of the GL
rendering pipeline with custom code.">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
    </function>
    <function name="create_shader"
              c:identifier="cogl_create_shader"
              doc="Create a new shader handle, use #cogl_shader_source to set the source code
to be used on it.">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="shader_type" transfer-ownership="none">
          <type name="ShaderType" c:type="CoglShaderType"/>
        </parameter>
      </parameters>
    </function>
    <function name="disable_fog"
              c:identifier="cogl_disable_fog"
              doc="This function disables fogging, so primitives drawn afterwards will not be
blended with any previously set fog color.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="double_to_fixed" c:identifier="cogl_double_to_fixed">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="double" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="double_to_int" c:identifier="cogl_double_to_int">
      <return-value transfer-ownership="none">
        <type name="int" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="double" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="double_to_unit" c:identifier="cogl_double_to_unit">
      <return-value transfer-ownership="none">
        <type name="uint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="double" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="end_gl"
              c:identifier="cogl_end_gl"
              doc="This is the counterpart to cogl_begin_gl() used to delimit blocks of drawing
code using raw OpenGL. Please refer to cogl_begin_gl() for full details."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="features_available"
              c:identifier="cogl_features_available"
              doc="Checks whether the given COGL features are available. Multiple
features can be checked for by or-ing them together with the &apos;|&apos;
operator. %TRUE is only returned if all of the requested features
are available.">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="features" transfer-ownership="none">
          <type name="FeatureFlags" c:type="CoglFeatureFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_atan2"
              c:identifier="cogl_fixed_atan2"
              doc="Computes the arc tangent of @a / @b but uses the sign of both
arguments to return the angle in right quadrant.
notation"
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_atani"
              c:identifier="cogl_fixed_atani"
              doc="Computes the arc tangent of @a."
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_cos"
              c:identifier="cogl_fixed_cos"
              doc="Computes the cosine of @angle."
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_div" c:identifier="cogl_fixed_div">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_log2"
              c:identifier="cogl_fixed_log2"
              doc="Calculates base 2 logarithm.
This function is some 2.5 times faster on x86, and over 12 times faster on
fpu-less arm, than using libc log()."
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_mul" c:identifier="cogl_fixed_mul">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_mul_div" c:identifier="cogl_fixed_mul_div">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_pow"
              c:identifier="cogl_fixed_pow"
              doc="Calculates @x to the @y power."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="uint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_pow2"
              c:identifier="cogl_fixed_pow2"
              doc="Calculates 2 to the @x power.
This function is around 11 times faster on x86, and around 22 times faster
on fpu-less arm than libc pow(2, x)."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="uint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_sin"
              c:identifier="cogl_fixed_sin"
              doc="Computes the sine of @angle."
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_sqrt"
              c:identifier="cogl_fixed_sqrt"
              doc="Computes the square root of @x.
notation"
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
      </parameters>
    </function>
    <function name="fixed_tan"
              c:identifier="cogl_fixed_tan"
              doc="Computes the tangent of @angle."
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <type name="Fixed" c:type="CoglFixed"/>
        </parameter>
      </parameters>
    </function>
    <function name="flush"
              c:identifier="cogl_flush"
              doc="This function should only need to be called in exceptional circumstances.
As an optimization Cogl drawing functions may batch up primitives
internally, so if you are trying to use raw GL outside of Cogl you stand a
better chance of being successful if you ask Cogl to flush any batched
geometry before making your state changes.
It only ensure that the underlying driver is issued all the commands
necessary to draw the batched primitives. It provides no guarantees about
when the driver will complete the rendering.
This provides no guarantees about the GL state upon returning and to avoid
confusing Cogl you should aim to restore any changes you make before
resuming use of Cogl.
If you are making state changes with the intention of affecting Cogl drawing
primitives you are 100% on your own since you stand a good chance of
conflicting with Cogl internals. For example clutter-gst which currently
uses direct GL calls to bind ARBfp programs will very likely break when Cogl
starts to use ARBfb programs itself for the material API."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="frustum"
              c:identifier="cogl_frustum"
              doc="Replaces the current projection matrix with a perspective matrix
for the given viewing frustum."
              version="0.8.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="bottom" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_backface_culling_enabled"
              c:identifier="cogl_get_backface_culling_enabled"
              doc="Queries if backface culling has been enabled via
cogl_set_backface_culling_enabled()">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="get_bitmasks"
              c:identifier="cogl_get_bitmasks"
              doc="Gets the number of bitplanes used for each of the color components
in the color buffer. Pass %NULL for any of the arguments if the
value is not required.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   doc="Return location for the number of red bits or %NULL">
          <type name="int" c:type="int*"/>
        </parameter>
        <parameter name="green"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   doc="Return location for the number of green bits or %NULL">
          <type name="int" c:type="int*"/>
        </parameter>
        <parameter name="blue"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   doc="Return location for the number of blue bits or %NULL">
          <type name="int" c:type="int*"/>
        </parameter>
        <parameter name="alpha"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   doc="Return location for the number of alpha bits or %NULL">
          <type name="int" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_depth_test_enabled"
              c:identifier="cogl_get_depth_test_enabled"
              doc="Queries if depth testing has been enabled via cogl_set_depth_test_enable()">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="get_features"
              c:identifier="cogl_get_features"
              doc="Returns all of the features supported by COGL."
              version="0.8">
      <return-value transfer-ownership="full">
        <type name="FeatureFlags" c:type="CoglFeatureFlags"/>
      </return-value>
    </function>
    <function name="get_modelview_matrix"
              c:identifier="cogl_get_modelview_matrix"
              doc="Stores the current model-view matrix in @matrix.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none"
                   doc="return location for the model-view matrix">
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_option_group"
              c:identifier="cogl_get_option_group"
              doc="Retrieves the #GOptionGroup used by COGL to parse the command
line options. Clutter uses this to handle the COGL command line
options during its initialization process."
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
      </return-value>
    </function>
    <function name="get_proc_address"
              c:identifier="cogl_get_proc_address"
              doc="Gets a pointer to a given GL or GL ES extension function. This acts
as a wrapper around glXGetProcAddress() or whatever is the
appropriate function for the current backend.
function is not available.">
      <return-value transfer-ownership="full">
        <type name="FuncPtr" c:type="CoglFuncPtr"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_projection_matrix"
              c:identifier="cogl_get_projection_matrix"
              doc="Stores the current projection matrix in @matrix.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none"
                   doc="return location for the projection matrix">
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_viewport"
              c:identifier="cogl_get_viewport"
              doc="Stores the current viewport in @v. @v[0] and @v[1] get the x and y
position of the viewport and @v[2] and @v[3] get the width and
height.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="v"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   doc="pointer to a 4 element array of #float&lt;!-- --&gt;s to receive the viewport dimensions.">
          <array c:type="float" fixed-size="4">
            <type name="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="is_bitmap"
              c:identifier="cogl_is_bitmap"
              doc="Checks whether @handle is a #CoglHandle for a bitmap
and %FALSE otherwise"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_buffer"
              c:identifier="cogl_is_buffer"
              doc="Checks whether @handle is a buffer handle."
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_buffer_EXP" c:identifier="cogl_is_buffer_EXP">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_material"
              c:identifier="cogl_is_material"
              doc="Gets whether the given handle references an existing material object.
%FALSE otherwise">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_offscreen"
              c:identifier="cogl_is_offscreen"
              doc="Determines whether the given #CoglHandle references an offscreen buffer
object.
%FALSE otherwise">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_pixel_buffer"
              c:identifier="cogl_is_pixel_buffer"
              doc="Checks whether @handle is a pixel buffer.
otherwise"
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_pixel_buffer_EXP"
              c:identifier="cogl_is_pixel_buffer_EXP">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_program"
              c:identifier="cogl_is_program"
              doc="Gets whether the given handle references an existing program object.
%FALSE otherwise">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_shader"
              c:identifier="cogl_is_shader"
              doc="Gets whether the given handle references an existing shader object.
%FALSE otherwise">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture"
              c:identifier="cogl_is_texture"
              doc="Gets whether the given handle references an existing texture object.
%FALSE otherwise">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_vertex_buffer"
              c:identifier="cogl_is_vertex_buffer"
              doc="Checks whether @handle is a Vertex Buffer Object
otherwise"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_copy"
              c:identifier="cogl_material_copy"
              doc="Creates a new material handle with the configuration copied from the
source material.
We would strongly advise developers to always aim to use
cogl_material_copy() instead of cogl_material_new() whenever there will
be any similarity between two materials. Copying a material helps Cogl
keep track of a materials ancestry which we may use to help minimize GPU
state changes."
              version="1.2">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_get_ambient"
              c:identifier="cogl_material_get_ambient"
              doc="Retrieves the current ambient color for @material"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="ambient" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_get_color"
              c:identifier="cogl_material_get_color"
              doc="Retrieves the current material color."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="color"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none"
                   doc="The location to store the color">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_get_diffuse"
              c:identifier="cogl_material_get_diffuse"
              doc="Retrieves the current diffuse color for @material"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="diffuse" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_get_emission"
              c:identifier="cogl_material_get_emission"
              doc="Retrieves the materials current emission color."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="emission" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_get_layers"
              c:identifier="cogl_material_get_layers"
              doc="This function lets you access a materials internal list of layers
for iteration.
#CoglHandle&lt;!-- --&gt;&apos;s that can be passed to the  cogl_material_layer_*
functions. The list is owned by COGL and it  should not be modified or
freed">
      <return-value transfer-ownership="none" doc="A list of">
        <type name="GLib.List" c:type="GList*">
          <type name="Handle"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_get_n_layers"
              c:identifier="cogl_material_get_n_layers"
              doc="Retrieves the number of layers defined for the given @material"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="int" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_get_shininess"
              c:identifier="cogl_material_get_shininess"
              doc="Retrieves the materials current emission color."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="float" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_get_specular"
              c:identifier="cogl_material_get_specular"
              doc="Retrieves the materials current specular color."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="specular" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_layer_get_mag_filter"
              c:identifier="cogl_material_layer_get_mag_filter"
              doc="Queries the currently set downscaling filter for a material later">
      <return-value transfer-ownership="full">
        <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
      </return-value>
      <parameters>
        <parameter name="layer" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_layer_get_min_filter"
              c:identifier="cogl_material_layer_get_min_filter"
              doc="Queries the currently set downscaling filter for a material layer">
      <return-value transfer-ownership="full">
        <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
      </return-value>
      <parameters>
        <parameter name="layer" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_layer_get_texture"
              c:identifier="cogl_material_layer_get_texture"
              doc="Extracts a texture handle for a specific layer.
&lt;note&gt;In the future Cogl may support purely GLSL based layers; for those
layers this function which will likely return %COGL_INVALID_HANDLE if you
try to get the texture handle from them. Considering this scenario, you
should call cogl_material_layer_get_type() first in order check it is of
type %COGL_MATERIAL_LAYER_TYPE_TEXTURE before calling this function.&lt;/note&gt;">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="layer" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_layer_get_type"
              c:identifier="cogl_material_layer_get_type"
              doc="Retrieves the type of the layer
Currently there is only one type of layer defined:
%COGL_MATERIAL_LAYER_TYPE_TEXTURE, but considering we may add purely GLSL
based layers in the future, you should write code that checks the type
first.">
      <return-value transfer-ownership="full">
        <type name="MaterialLayerType" c:type="CoglMaterialLayerType"/>
      </return-value>
      <parameters>
        <parameter name="layer" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_new"
              c:identifier="cogl_material_new"
              doc="Allocates and initializes a blank white material">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
    </function>
    <function name="material_ref"
              c:identifier="cogl_material_ref"
              doc="Increment the reference count for a cogl material."
              version="1.0"
              deprecated="Use cogl_handle_ref() instead"
              deprecated-version="1.2">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_remove_layer"
              c:identifier="cogl_material_remove_layer"
              doc="This function removes a layer from your material">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="layer_index" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_alpha_test_function"
              c:identifier="cogl_material_set_alpha_test_function"
              doc="Before a primitive is blended with the framebuffer, it goes through an
alpha test stage which lets you discard fragments based on the current
alpha value. This function lets you change the function used to evaluate
the alpha channel, and thus determine which fragments are discarded
and which continue on to the blending stage.
The default is %COGL_MATERIAL_ALPHA_FUNC_ALWAYS"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="alpha_func" transfer-ownership="none">
          <type name="MaterialAlphaFunc" c:type="CoglMaterialAlphaFunc"/>
        </parameter>
        <parameter name="alpha_reference"
                   transfer-ownership="none"
                   doc=" to compare incoming fragments to.">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_ambient"
              c:identifier="cogl_material_set_ambient"
              doc="Sets the material&apos;s ambient color, in the standard OpenGL lighting
model. The ambient color affects the overall color of the object.
Since the diffuse color will be intense when the light hits the surface
directly, the ambient will be most apparent where the light hits at a
slant.
The default value is (0.2, 0.2, 0.2, 1.0)"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="ambient" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_ambient_and_diffuse"
              c:identifier="cogl_material_set_ambient_and_diffuse"
              doc="Conveniently sets the diffuse and ambient color of @material at the same
time. See cogl_material_set_ambient() and cogl_material_set_diffuse().
The default ambient color is (0.2, 0.2, 0.2, 1.0)
The default diffuse color is (0.8, 0.8, 0.8, 1.0)"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="color" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_blend"
              c:identifier="cogl_material_set_blend"
              doc="If not already familiar; please refer &lt;link linkend=&quot;cogl-Blend-Strings&quot;&gt;here&lt;/link&gt;
for an overview of what blend strings are, and their syntax.
Blending occurs after the alpha test function, and combines fragments with
the framebuffer.
Currently the only blend function Cogl exposes is ADD(). So any valid
blend statements will be of the form:
|[
&amp;lt;channel-mask&amp;gt;=ADD(SRC_COLOR*(&amp;lt;factor&amp;gt;), DST_COLOR*(&amp;lt;factor&amp;gt;))
]|
&lt;warning&gt;The brackets around blend factors are currently not
optional!&lt;/warning&gt;
This is the list of source-names usable as blend factors:
&lt;itemizedlist&gt;
&lt;/itemizedlist&gt;
The source names can be used according to the
&lt;link linkend=&quot;cogl-Blend-String-syntax&quot;&gt;color-source and factor syntax&lt;/link&gt;,
so for example &quot;(1-SRC_COLOR[A])&quot; would be a valid factor, as would
&quot;(CONSTANT[RGB])&quot;
These can also be used as factors:
&lt;itemizedlist&gt;
&lt;/itemizedlist&gt;
&lt;note&gt;Remember; all color components are normalized to the range [0, 1]
before computing the result of blending.&lt;/note&gt;
&lt;example id=&quot;cogl-Blend-Strings-blend-unpremul&quot;&gt;
&lt;title&gt;Blend Strings/1&lt;/title&gt;
&lt;para&gt;Blend a non-premultiplied source over a destination with
premultiplied alpha:&lt;/para&gt;
&lt;programlisting&gt;
&quot;RGB = ADD(SRC_COLOR*(SRC_COLOR[A]), DST_COLOR*(1-SRC_COLOR[A]))&quot;
&quot;A   = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))&quot;
&lt;/programlisting&gt;
&lt;/example&gt;
&lt;example id=&quot;cogl-Blend-Strings-blend-premul&quot;&gt;
&lt;title&gt;Blend Strings/2&lt;/title&gt;
&lt;para&gt;Blend a premultiplied source over a destination with
premultiplied alpha&lt;/para&gt;
&lt;programlisting&gt;
&quot;RGBA = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))&quot;
&lt;/programlisting&gt;
&lt;/example&gt;
The default blend string is:
|[
RGBA = ADD (SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))
]|
That gives normal alpha-blending when the calculated color for the material
is in premultiplied form.
described blending is supported by the underlying driver/hardware. If
there was an error, %FALSE is returned and @error is set accordingly (if
present)."
              version="1.0"
              throws="1">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="blend_string"
                   transfer-ownership="none"
                   doc=" describing the desired blend function.">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_blend_constant"
              c:identifier="cogl_material_set_blend_constant"
              doc="When blending is setup to reference a CONSTANT blend factor then
blending will depend on the constant set with this function."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="constant_color" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_color"
              c:identifier="cogl_material_set_color"
              doc="Sets the basic color of the material, used when no lighting is enabled.
Note that if you don&apos;t add any layers to the material then the color
will be blended unmodified with the destination; the default blend
semi-transparent red. See cogl_color_premultiply().
The default value is (1.0, 1.0, 1.0, 1.0)"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="color" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_color4f"
              c:identifier="cogl_material_set_color4f"
              doc="Sets the basic color of the material, used when no lighting is enabled.
The default value is (1.0, 1.0, 1.0, 1.0)"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="red" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_color4ub"
              c:identifier="cogl_material_set_color4ub"
              doc="Sets the basic color of the material, used when no lighting is enabled.
The default value is (0xff, 0xff, 0xff, 0xff)"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="red" transfer-ownership="none">
          <type name="uint8" c:type="guint8"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <type name="uint8" c:type="guint8"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <type name="uint8" c:type="guint8"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <type name="uint8" c:type="guint8"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_diffuse"
              c:identifier="cogl_material_set_diffuse"
              doc="Sets the material&apos;s diffuse color, in the standard OpenGL lighting
model. The diffuse color is most intense where the light hits the
surface directly - perpendicular to the surface.
The default value is (0.8, 0.8, 0.8, 1.0)"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="diffuse" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_emission"
              c:identifier="cogl_material_set_emission"
              doc="Sets the material&apos;s emissive color, in the standard OpenGL lighting
model. It will look like the surface is a light source emitting this
color.
The default value is (0.0, 0.0, 0.0, 1.0)"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="emission" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_layer"
              c:identifier="cogl_material_set_layer"
              doc="In addition to the standard OpenGL lighting model a Cogl material may have
one or more layers comprised of textures that can be blended together in
order, with a number of different texture combine modes. This function
defines a new texture layer.
The index values of multiple layers do not have to be consecutive; it is
only their relative order that is important.
&lt;note&gt;In the future, we may define other types of material layers, such
as purely GLSL based layers.&lt;/note&gt;"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="layer_index" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="texture" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_layer_combine"
              c:identifier="cogl_material_set_layer_combine"
              doc="If not already familiar; you can refer
&lt;link linkend=&quot;cogl-Blend-Strings&quot;&gt;here&lt;/link&gt; for an overview of what blend
strings are and there syntax.
These are all the functions available for texture combining:
&lt;itemizedlist&gt;
&lt;listitem&gt;REPLACE(arg0) = arg0&lt;/listitem&gt;
&lt;listitem&gt;MODULATE(arg0, arg1) = arg0 x arg1&lt;/listitem&gt;
&lt;listitem&gt;ADD(arg0, arg1) = arg0 + arg1&lt;/listitem&gt;
&lt;listitem&gt;ADD_SIGNED(arg0, arg1) = arg0 + arg1 - 0.5&lt;/listitem&gt;
&lt;listitem&gt;INTERPOLATE(arg0, arg1, arg2) = arg0 x arg2 + arg1 x (1 - arg2)&lt;/listitem&gt;
&lt;listitem&gt;SUBTRACT(arg0, arg1) = arg0 - arg1&lt;/listitem&gt;
&lt;listitem&gt;
&lt;programlisting&gt;
DOT3_RGB(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
(arg0[G] - 0.5)) * (arg1[G] - 0.5) +
(arg0[B] - 0.5)) * (arg1[B] - 0.5))
&lt;/programlisting&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;programlisting&gt;
DOT3_RGBA(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
(arg0[G] - 0.5)) * (arg1[G] - 0.5) +
(arg0[B] - 0.5)) * (arg1[B] - 0.5))
&lt;/programlisting&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;
Refer to the
&lt;link linkend=&quot;cogl-Blend-String-syntax&quot;&gt;color-source syntax&lt;/link&gt; for
describing the arguments. The valid source names for texture combining
are:
&lt;variablelist&gt;
&lt;varlistentry&gt;
&lt;term&gt;TEXTURE&lt;/term&gt;
&lt;listitem&gt;Use the color from the current texture layer&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;TEXTURE_0, TEXTURE_1, etc&lt;/term&gt;
&lt;listitem&gt;Use the color from the specified texture layer&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;CONSTANT&lt;/term&gt;
&lt;listitem&gt;Use the color from the constant given with
cogl_material_set_layer_constant()&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;PRIMARY&lt;/term&gt;
&lt;listitem&gt;Use the color of the material as set with
cogl_material_set_color()&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;PREVIOUS&lt;/term&gt;
&lt;listitem&gt;Either use the texture color from the previous layer, or
if this is layer 0, use the color of the material as set with
cogl_material_set_color()&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;/variablelist&gt;
&lt;refsect2 id=&quot;cogl-Layer-Combine-Examples&quot;&gt;
&lt;title&gt;Layer Combine Examples&lt;/title&gt;
&lt;para&gt;This is effectively what the default blending is:&lt;/para&gt;
&lt;informalexample&gt;&lt;programlisting&gt;
RGBA = MODULATE (PREVIOUS, TEXTURE)
&lt;/programlisting&gt;&lt;/informalexample&gt;
&lt;para&gt;This could be used to cross-fade between two images, using
the alpha component of a constant as the interpolator. The constant
color is given by calling cogl_material_set_layer_constant.&lt;/para&gt;
&lt;informalexample&gt;&lt;programlisting&gt;
RGBA = INTERPOLATE (PREVIOUS, TEXTURE, CONSTANT[A])
&lt;/programlisting&gt;&lt;/informalexample&gt;
&lt;/refsect2&gt;
&lt;note&gt;You can&apos;t give a multiplication factor for arguments as you can
with blending.&lt;/note&gt;
described texture combining is supported by the underlying driver and
or hardware. On failure, %FALSE is returned and @error is set"
              version="1.0"
              throws="1">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="layer_index" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="blend_string"
                   transfer-ownership="none"
                   doc=" describing the desired texture combine function.">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_layer_combine_constant"
              c:identifier="cogl_material_set_layer_combine_constant"
              doc="When you are using the &apos;CONSTANT&apos; color source in a layer combine
description then you can use this function to define its value."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="layer_index"
                   transfer-ownership="none"
                   doc=" for texture combining">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="constant" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_layer_filters"
              c:identifier="cogl_material_set_layer_filters"
              doc="Changes the decimation and interpolation filters used when a texture is
drawn at other scales than 100%.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="layer_index" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="min_filter" transfer-ownership="none">
          <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
        </parameter>
        <parameter name="mag_filter" transfer-ownership="none">
          <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_layer_matrix"
              c:identifier="cogl_material_set_layer_matrix"
              doc="This function lets you set a matrix that can be used to e.g. translate
and rotate a single layer of a material used to fill your geometry.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="layer_index" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="matrix" transfer-ownership="none">
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_shininess"
              c:identifier="cogl_material_set_shininess"
              doc="Sets the materials shininess, in the standard OpenGL lighting model,
which determines how specular highlights are calculated. A higher
The default value is 0.0"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="shininess" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_set_specular"
              c:identifier="cogl_material_set_specular"
              doc="Sets the material&apos;s specular color, in the standard OpenGL lighting
model. The intensity of the specular color depends on the viewport
position, and is brightest along the lines of reflection.
The default value is (0.0, 0.0, 0.0, 1.0)"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="specular" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_unref"
              c:identifier="cogl_material_unref"
              doc="Decrement the reference count for a cogl material."
              version="1.0"
              deprecated="Use cogl_handle_unref() instead"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="offscreen_new_to_texture"
              c:identifier="cogl_offscreen_new_to_texture"
              doc="This creates an offscreen buffer object using the given texture as the
primary color buffer. It doesn&apos;t just initialize the contents of the
offscreen buffer with the texture; they are tightly bound so that
drawing to the offscreen buffer effectivly updates the contents of the
given texture. You don&apos;t need to destroy the offscreen buffer before
you can use the texture again.
if it wasn&apos;t possible to create the buffer.">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="offscreen_ref"
              c:identifier="cogl_offscreen_ref"
              doc="Increments the reference count on the offscreen buffer."
              deprecated="cogl_handle_ref should be used in new code."
              deprecated-version="1.2">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="offscreen_unref"
              c:identifier="cogl_offscreen_unref"
              doc="Decreases the reference count for the offscreen buffer and frees it when
the count reaches 0."
              deprecated="cogl_handle_unref should be used in new code."
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="ortho"
              c:identifier="cogl_ortho"
              doc="Replaces the current projection matrix with a parallel projection
matrix."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="bottom" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="near"
                   transfer-ownership="none"
                   doc=" the plane is behind the viewer)">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="far"
                   transfer-ownership="none"
                   doc=" the plane is behind the viewer)">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_arc"
              c:identifier="cogl_path_arc"
              doc="Adds an elliptical arc segment to the current path. A straight line
segment will link the current pen location with the first vertex
of the arc. If you perform a move_to to the arcs start just before
drawing it you create a free standing arc.
The angles are measured in degrees where 0 is in the direction of
the positive X axis and 90 is in the direction of the positive Y
axis. The angle of the arc begins at @angle_1 and heads towards
otherwise it will increase).">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="center_x" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="center_y" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="radius_x" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="radius_y" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="angle_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="angle_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_close"
              c:identifier="cogl_path_close"
              doc="Closes the path being constructed by adding a straight line segment
to it that ends at the first vertex of the path.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="path_curve_to"
              c:identifier="cogl_path_curve_to"
              doc="Adds a cubic bezier curve segment to the current path with the given
second, third and fourth control points and using current pen location
as the first control point.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x_3" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_3" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_ellipse"
              c:identifier="cogl_path_ellipse"
              doc="Constructs an ellipse shape. If there is an existing path this will
start a new disjoint sub-path.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="center_x" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="center_y" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="radius_x" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="radius_y" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_fill"
              c:identifier="cogl_path_fill"
              doc="Fills the interior of the constructed shape using the current
drawing color. The current path is then cleared. To use the path
again, call cogl_path_fill_preserve() instead.
The interior of the shape is determined using the &apos;even-odd&apos;
rule. Any open sub-paths are treated as if there is an extra line
joining the last point and first point. You can work out whether
any point in the stage will be filled if you imagine drawing an
infinitely long line in any direction from that point and then
counting the number times it crosses a line in the path. If the
number is odd it will be filled, otherwise it will not.
See &lt;xref linkend=&quot;fill-rule&quot;/&gt; for a demonstration of the fill
rule.
&lt;figure id=&quot;fill-rule&quot;&gt;
&lt;title&gt;Example of filling various paths&lt;/title&gt;
&lt;graphic fileref=&quot;fill-rule.png&quot; format=&quot;PNG&quot;/&gt;
&lt;/figure&gt;">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="path_fill_preserve"
              c:identifier="cogl_path_fill_preserve"
              doc="Fills the interior of the constructed shape using the current
drawing color and preserves the path to be used again. See
cogl_path_fill() for a description what is considered the interior
of the shape."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="path_line"
              c:identifier="cogl_path_line"
              doc="Constructs a straight line shape starting and ending at the given
coordinates. If there is an existing path this will start a new
disjoint sub-path.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_line_to"
              c:identifier="cogl_path_line_to"
              doc="Adds a straight line segment to the current path that ends at the
given coordinates.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_move_to"
              c:identifier="cogl_path_move_to"
              doc="Moves the pen to the given location. If there is an existing path
this will start a new disjoint subpath.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_new"
              c:identifier="cogl_path_new"
              doc="Clears the current path and starts a new one."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="path_polygon"
              c:identifier="cogl_path_polygon"
              doc="Constructs a polygonal shape of the given number of vertices. If
there is an existing path this will start a new disjoint sub-path.
The coords array must contain 2 * num_points values. The first value
represents the X coordinate of the first vertex, the second value
represents the Y coordinate of the first vertex, continuing in the same
fashion for the rest of the vertices.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="coords"
                   transfer-ownership="none"
                   doc="A pointer to the first element of an array of fixed-point values that specify the vertex coordinates.">
          <array c:type="float*">
            <type name="float"/>
          </array>
        </parameter>
        <parameter name="num_points" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_polyline"
              c:identifier="cogl_path_polyline"
              doc="Constructs a series of straight line segments, starting from the
first given vertex coordinate. If there is an existing path this
will start a new disjoint sub-path. Each subsequent segment starts
where the previous one ended and ends at the next given vertex
coordinate.
The coords array must contain 2 * num_points values. The first value
represents the X coordinate of the first vertex, the second value
represents the Y coordinate of the first vertex, continuing in the same
fashion for the rest of the vertices. (num_points - 1) segments will
be constructed.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="coords"
                   transfer-ownership="none"
                   doc="A pointer to the first element of an array of fixed-point values that specify the vertex coordinates.">
          <array c:type="float*">
            <type name="float"/>
          </array>
        </parameter>
        <parameter name="num_points" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_rectangle"
              c:identifier="cogl_path_rectangle"
              doc="Constructs a rectangular shape at the given coordinates. If there
is an existing path this will start a new disjoint sub-path.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_rel_curve_to"
              c:identifier="cogl_path_rel_curve_to"
              doc="Adds a cubic bezier curve segment to the current path with the given
second, third and fourth control points and using current pen location
as the first control point. The given coordinates are relative to the
current pen location.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x_3" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_3" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_rel_line_to"
              c:identifier="cogl_path_rel_line_to"
              doc="Adds a straight line segment to the current path that ends at the
given coordinates relative to the current pen location.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_rel_move_to"
              c:identifier="cogl_path_rel_move_to"
              doc="Moves the pen to the given offset relative to the current pen
location. If there is an existing path this will start a new
disjoint subpath.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_round_rectangle"
              c:identifier="cogl_path_round_rectangle"
              doc="Constructs a rectangular shape with rounded corners. If there is an
existing path this will start a new disjoint sub-path.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="radius" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="arc_step"
                   transfer-ownership="none"
                   doc=" the corner arcs.">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_stroke"
              c:identifier="cogl_path_stroke"
              doc="Strokes the constructed shape using the current drawing color and a
width of 1 pixel (regardless of the current transformation
matrix). To current path is then cleared. To use the path again,
call cogl_path_stroke_preserve() instead.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="path_stroke_preserve"
              c:identifier="cogl_path_stroke_preserve"
              doc="Strokes the constructed shape using the current drawing color and
preserves the path to be used again."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="perspective"
              c:identifier="cogl_perspective"
              doc="Replaces the current projection matrix with a perspective matrix
based on the provided values.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fovy" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="aspect" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="pixel_buffer_new"
              c:identifier="cogl_pixel_buffer_new"
              doc="Creates a new buffer to store pixel data. You can create a new texture from
this buffer using cogl_texture_new_from_buffer().
%COGL_INVALID_HANDLE on failure"
              version="1.2">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="pixel_buffer_new_EXP"
              c:identifier="cogl_pixel_buffer_new_EXP">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="pixel_buffer_new_for_size"
              c:identifier="cogl_pixel_buffer_new_for_size"
              doc="Creates a new buffer to store pixel data.
&lt;note&gt;COGL will try its best to provide a hardware buffer you can map,
write into and effectively do a zero copy upload when creating a texture
from it with cogl_texture_new_from_buffer(). For various reasons, such
buffers are likely to have a stride larger than width * bytes_per_pixel. The
user must take the stride into account when writing into it.&lt;/note&gt;
%COGL_INVALID_HANDLE on failure"
              version="1.2">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="stride"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   doc=" in bytes">
          <type name="uint" c:type="unsigned int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pixel_buffer_new_for_size_EXP"
              c:identifier="cogl_pixel_buffer_new_for_size_EXP">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="stride"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <type name="uint" c:type="unsigned int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="polygon"
              c:identifier="cogl_polygon"
              doc="Draws a convex polygon using the current source material to fill / texture
with according to the texture coordinates passed.
If @use_color is %TRUE then the color will be changed for each vertex using
the value specified in the color member of #CoglTextureVertex. This can be
used for example to make the texture fade out by setting the alpha value of
the color.
All of the texture coordinates must be in the range [0,1] and repeating the
texture is not supported.
Because of the way this function is implemented it will currently
only work if either the texture is not sliced or the backend is not
OpenGL ES and the minifying and magnifying functions are both set
to COGL_MATERIAL_FILTER_NEAREST."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vertices" transfer-ownership="none">
          <type name="TextureVertex" c:type="CoglTextureVertex*"/>
        </parameter>
        <parameter name="n_vertices" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="use_color" transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="pop_draw_buffer"
              c:identifier="cogl_pop_draw_buffer"
              doc="Restore cogl_set_draw_buffer() state."
              deprecated="The draw buffer API was replaced with a framebuffer API"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pop_framebuffer"
              c:identifier="cogl_pop_framebuffer"
              doc="Restores the framebuffer that was previously at the top of the stack.
All subsequent drawing will be redirected to this framebuffer."
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pop_matrix"
              c:identifier="cogl_pop_matrix"
              doc="Restores the current model-view matrix from the matrix stack.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="program_attach_shader"
              c:identifier="cogl_program_attach_shader"
              doc="Attaches a shader to a program object, a program can have one vertex shader
and one fragment shader attached.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program_handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="shader_handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_get_uniform_location"
              c:identifier="cogl_program_get_uniform_location"
              doc="Retrieve the location (offset) of a uniform variable in a shader program,
a uniform is a variable that is constant for all vertices/fragments for a
shader object and is possible to modify as an external parameter.
This uniform can be set using cogl_program_uniform_1f() when the
program is in use.">
      <return-value transfer-ownership="none">
        <type name="int" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_name" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_link"
              c:identifier="cogl_program_link"
              doc="Links a program making it ready for use.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_ref"
              c:identifier="cogl_program_ref"
              doc="Add an extra reference to a program.">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_1f"
              c:identifier="cogl_program_uniform_1f"
              doc="Changes the value of a floating point uniform in the currently
used (see cogl_program_use()) shader program.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_1i"
              c:identifier="cogl_program_uniform_1i"
              doc="Changes the value of an integer uniform in the currently
used (see cogl_program_use()) shader program.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_float"
              c:identifier="cogl_program_uniform_float"
              doc="Changes the value of a float vector uniform, or uniform array in the
currently used (see cogl_program_use()) shader program.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="value"
                   transfer-ownership="none"
                   doc="the new value of the uniform.">
          <array length="2" c:type="GLfloat*">
            <type name="GL.float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_int"
              c:identifier="cogl_program_uniform_int"
              doc="Changes the value of a int vector uniform, or uniform array in the
currently used (see cogl_program_use()) shader program.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="value"
                   transfer-ownership="none"
                   doc="the new value of the uniform.">
          <array length="2" c:type="int*">
            <type name="int"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_matrix"
              c:identifier="cogl_program_uniform_matrix"
              doc="Changes the value of a matrix uniform, or uniform array in the
currently used (see cogl_program_use()) shader program. The @size
parameter is used to determine the square size of the matrix.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="transpose" transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </parameter>
        <parameter name="value"
                   transfer-ownership="none"
                   doc="the new value of the uniform.">
          <array length="2" c:type="float*">
            <type name="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_unref"
              c:identifier="cogl_program_unref"
              doc="Removes a reference to a program. If it was the last reference the
program object will be destroyed.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_use"
              c:identifier="cogl_program_use"
              doc="Activate a specific shader program replacing that part of the GL
rendering pipeline, if passed in %COGL_INVALID_HANDLE the default
behavior of GL is reinstated.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="push_draw_buffer"
              c:identifier="cogl_push_draw_buffer"
              doc="Save cogl_set_draw_buffer() state."
              deprecated="The draw buffer API was replaced with a framebuffer API"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="push_framebuffer"
              c:identifier="cogl_push_framebuffer"
              doc="Redirects all subsequent drawing to the specified framebuffer. This can
either be an offscreen buffer created with cogl_offscreen_new_to_texture ()
or in the future it may be an onscreen framebuffer too.
You should understand that a framebuffer owns the following state:
&lt;itemizedlist&gt;
&lt;li&gt;The projection matrix&lt;/li&gt;
&lt;li&gt;The modelview matrix stack&lt;/li&gt;
&lt;li&gt;The viewport&lt;/li&gt;
&lt;li&gt;The clip stack&lt;/li&gt;
&lt;/itemizedlist&gt;
So these items will automatically be saved and restored when you
push and pop between different framebuffers.
Also remember a newly allocated framebuffer will have an identity matrix for
the projection and modelview matrices which gives you a coordinate space
like OpenGL with (-1, -1) corresponding to the top left of the viewport,
(1, 1) corresponding to the bottom right and +z coming out towards the
viewer.
If you want to set up a coordinate space like Clutter does with (0, 0)
corresponding to the top left and (framebuffer_width, framebuffer_height)
corresponding to the bottom right you can do so like this:
|[
static void
setup_viewport (unsigned int width,
unsigned int height,
float fovy,
float aspect,
float z_near,
float z_far)
{
float z_camera;
CoglMatrix projection_matrix;
CoglMatrix mv_matrix;
cogl_set_viewport (0, 0, width, height);
cogl_perspective (fovy, aspect, z_near, z_far);
cogl_get_projection_matrix (&amp;projection_matrix);
z_camera = 0.5 * projection_matrix.xx;
cogl_matrix_init_identity (&amp;mv_matrix);
cogl_matrix_translate (&amp;mv_matrix, -0.5f, -0.5f, -z_camera);
cogl_matrix_scale (&amp;mv_matrix, 1.0f / width, -1.0f / height, 1.0f / width);
cogl_matrix_translate (&amp;mv_matrix, 0.0f, -1.0 * height, 0.0f);
cogl_set_modelview_matrix (&amp;mv_matrix);
}
static void
my_init_framebuffer (CoglHandle framebuffer,
unsigned int framebuffer_width,
unsigned int framebuffer_height)
{
ClutterActor *stage = clutter_stage_get_default ();
ClutterPerspective perspective;
clutter_stage_get_perspective (CLUTTER_STAGE (stage), &amp;perspective);
cogl_push_framebuffer (framebuffer);
setup_viewport (framebuffer_width,
framebuffer_height,
perspective-&gt;fovy,
perspective.aspect,
perspective.z_near,
perspective.z_far);
cogl_pop_framebuffer ();
}
]|
The previous framebuffer can be restored by calling cogl_pop_framebuffer()"
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none" doc=" offscreen.">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="push_matrix"
              c:identifier="cogl_push_matrix"
              doc="Stores the current model-view matrix on the matrix stack. The matrix
can later be restored with cogl_pop_matrix().">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="read_pixels"
              c:identifier="cogl_read_pixels"
              doc="This reads a rectangle of pixels from the current framebuffer where
position (0, 0) is the top left. The pixel at (x, y) is the first
read, and the data is returned with a rowstride of (width * 4).
Currently Cogl assumes that the framebuffer is in a premultiplied
format so if @format is non-premultiplied it will convert it. To
read the pixel values without any conversion you should either
specify a format that doesn&apos;t use an alpha channel or use one of
the formats ending in PRE.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="source"
                   transfer-ownership="none"
                   doc=" (only COGL_READ_PIXELS_COLOR_BUFFER supported currently)">
          <type name="ReadPixelsFlags" c:type="CoglReadPixelsFlags"/>
        </parameter>
        <parameter name="format"
                   transfer-ownership="none"
                   doc=" (only COGL_PIXEL_FORMAT_RGBA_8888 supported currently)">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="pixels" transfer-ownership="none">
          <array c:type="guint8*">
            <type name="uint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle"
              c:identifier="cogl_rectangle"
              doc="Fills a rectangle at the given coordinates with the current source material">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle_with_multitexture_coords"
              c:identifier="cogl_rectangle_with_multitexture_coords"
              doc="This function draws a rectangle using the current source material to
texture or fill with. As a material may contain multiple texture layers
this interface lets you supply texture coordinates for each layer of the
material.
The first pair of coordinates are for the first layer (with the smallest
layer index) and if you supply less texture coordinates than there are
layers in the current source material then default texture coordinates
(0.0, 0.0, 1.0, 1.0) are generated."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="tex_coords"
                   transfer-ownership="none"
                   doc="An array containing groups of">
          <array c:type="float*">
            <type name="float"/>
          </array>
        </parameter>
        <parameter name="tex_coords_len"
                   transfer-ownership="none"
                   doc=" and one group of texture coordinates, this would be 4)">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle_with_texture_coords"
              c:identifier="cogl_rectangle_with_texture_coords"
              doc="Draw a rectangle using the current material and supply texture coordinates
to be used for the first texture layer of the material. To draw the entire
texture pass in @tx1=0.0 @ty1=0.0 @tx2=1.0 @ty2=1.0."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="tx1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="ty1" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="tx2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="ty2" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangles"
              c:identifier="cogl_rectangles"
              doc="Draws a series of rectangles in the same way that
cogl_rectangle() does. In some situations it can give a
significant performance boost to use this function rather than
calling cogl_rectangle() separately for each rectangle.
parameters x1, y1, x2, and y2, and have the same
meaning as in cogl_rectangle()."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="verts"
                   transfer-ownership="none"
                   doc="an array of vertices">
          <array c:type="float*">
            <type name="float"/>
          </array>
        </parameter>
        <parameter name="n_rects" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangles_with_texture_coords"
              c:identifier="cogl_rectangles_with_texture_coords"
              doc="Draws a series of rectangles in the same way that
cogl_rectangle_with_texture_coords() does. In some situations it can give a
significant performance boost to use this function rather than
calling cogl_rectangle_with_texture_coords() separately for each rectangle.
parameters x1, y1, x2, y2, tx1, ty1, tx2 and ty2 and have the same
meaning as in cogl_rectangle_with_texture_coords()."
              version="0.8.6">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="verts"
                   transfer-ownership="none"
                   doc="an array of vertices">
          <array c:type="float*">
            <type name="float"/>
          </array>
        </parameter>
        <parameter name="n_rects" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rotate"
              c:identifier="cogl_rotate"
              doc="Multiplies the current model-view matrix by one that rotates the
model around the vertex specified by @x, @y and @z. The rotation
follows the right-hand thumb rule so for example rotating by 10
degrees about the vertex (0, 0, 1) causes a small counter-clockwise
rotation.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="scale"
              c:identifier="cogl_scale"
              doc="Multiplies the current model-view matrix by one that scales the x,
y and z axes by the given values.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_backface_culling_enabled"
              c:identifier="cogl_set_backface_culling_enabled"
              doc="Sets whether textures positioned so that their backface is showing
should be hidden. This can be used to efficiently draw two-sided
textures or fully closed cubes without enabling depth testing. This
only affects calls to the cogl_rectangle* family of functions and
cogl_vertex_buffer_draw*. Backface culling is disabled by default.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_depth_test_enabled"
              c:identifier="cogl_set_depth_test_enabled"
              doc="Sets whether depth testing is enabled. If it is disabled then the
order that actors are layered on the screen depends solely on the
order specified using clutter_actor_raise() and
clutter_actor_lower(), otherwise it will also take into account the
actor&apos;s depth. Depth testing is disabled by default.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <type name="boolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_draw_buffer"
              c:identifier="cogl_set_draw_buffer"
              doc="Redirects all subsequent drawing to the specified framebuffer. This
can either be an offscreen buffer created with
cogl_offscreen_new_to_texture () or you can revert to your original
on screen window buffer.
the type of CoglHandle given instead."
              deprecated="The target argument was redundant since we could look at"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="target"
                   transfer-ownership="none"
                   doc=" are setting as the render target.">
          <type name="BufferTarget" c:type="CoglBufferTarget"/>
        </parameter>
        <parameter name="offscreen"
                   transfer-ownership="none"
                   doc=" then this is a CoglHandle for the offscreen buffer.">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_fog"
              c:identifier="cogl_set_fog"
              doc="Enables fogging. Fogging causes vertices that are further away from the eye
to be rendered with a different color. The color is determined according to
the chosen fog mode; at it&apos;s simplest the color is linearly interpolated so
that vertices at @z_near are drawn fully with their original color and
vertices at @z_far are drawn fully with @fog_color. Fogging will remain
enabled until you call cogl_disable_fog().
&lt;note&gt;The fogging functions only work correctly when primitives use
unmultiplied alpha colors. By default Cogl will premultiply textures
and cogl_set_source_color() will premultiply colors, so unless you
explicitly load your textures requesting an unmultiplied internal format
and use cogl_material_set_color() you can only use fogging with fully
opaque primitives. This might improve in the future when we can depend
on fragment shaders.&lt;/note&gt;">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fog_color" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
        <parameter name="mode"
                   transfer-ownership="none"
                   doc=" fogging blend factor.">
          <type name="FogMode" c:type="CoglFogMode"/>
        </parameter>
        <parameter name="density"
                   transfer-ownership="none"
                   doc=" %COGL_FOG_MODE_EXPONENTIAL_SQUARED equations.">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_framebuffer"
              c:identifier="cogl_set_framebuffer"
              doc="This redirects all subsequent drawing to the specified framebuffer. This can
either be an offscreen buffer created with cogl_offscreen_new_to_texture ()
or in the future it may be an onscreen framebuffers too."
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none" doc=" offscreen.">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_modelview_matrix"
              c:identifier="cogl_set_modelview_matrix"
              doc="Loads @matrix as the new model-view matrix.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_projection_matrix"
              c:identifier="cogl_set_projection_matrix"
              doc="Loads matrix as the new projection matrix.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source"
              c:identifier="cogl_set_source"
              doc="This function sets the source material that will be used to fill subsequent
geometry emitted via the cogl API.
&lt;note&gt;In the future we may add the ability to set a front facing material,
and a back facing material, in which case this function will set both to the
same.&lt;/note&gt;"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color"
              c:identifier="cogl_set_source_color"
              doc="This is a convenience function for creating a solid fill source material
from the given color. This color will be used for any subsequent drawing
operation.
The color will be premultiplied by Cogl, so the color should be
semi-transparent red.
See also cogl_set_source_color4ub() and cogl_set_source_color4f()
if you already have the color components."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color" transfer-ownership="none">
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color4f"
              c:identifier="cogl_set_source_color4f"
              doc="This is a convenience function for creating a solid fill source material
from the given color using normalized values for each component. This color
will be used for any subsequent drawing operation.
The value for each component is a fixed point number in the range
between 0 and %1.0. If the values passed in are outside that
range, they will be clamped."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color4ub"
              c:identifier="cogl_set_source_color4ub"
              doc="This is a convenience function for creating a solid fill source material
from the given color using unsigned bytes for each component. This
color will be used for any subsequent drawing operation.
The value for each component is an unsigned byte in the range
between 0 and 255."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red" transfer-ownership="none">
          <type name="uint8" c:type="guint8"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <type name="uint8" c:type="guint8"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <type name="uint8" c:type="guint8"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <type name="uint8" c:type="guint8"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_texture"
              c:identifier="cogl_set_source_texture"
              doc="This is a convenience function for creating a material with the first
layer set to #texture_handle and setting that material as the source with
cogl_set_source.
and cogl_set_source_texture. If you need to blend a texture with a color then
you can create a simple material like this:
&lt;programlisting&gt;
material = cogl_material_new ();
cogl_material_set_color4ub (material, 0xff, 0x00, 0x00, 0x80);
cogl_material_set_layer (material, 0, tex_handle);
cogl_set_source (material);
&lt;/programlisting&gt;"
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="texture_handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_viewport"
              c:identifier="cogl_set_viewport"
              doc="Replaces the current viewport with the given values."
              version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_compile"
              c:identifier="cogl_shader_compile"
              doc="Compiles the shader, no return value, but the shader is now ready for
linking into a program.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_get_info_log"
              c:identifier="cogl_shader_get_info_log"
              doc="Retrieves the information log for a coglobject, can be used in conjunction
with cogl_shader_get_parameteriv() to retrieve the compiler warnings/error
messages that caused a shader to not compile correctly, mainly useful for
debugging purposes.
g_free() to free it">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_get_type"
              c:identifier="cogl_shader_get_type"
              doc="Retrieves the type of a shader #CoglHandle
or %COGL_SHADER_TYPE_FRAGMENT if the shader is a frament processor">
      <return-value transfer-ownership="full">
        <type name="ShaderType" c:type="CoglShaderType"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_is_compiled"
              c:identifier="cogl_shader_is_compiled"
              doc="Retrieves whether a shader #CoglHandle has been compiled">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_ref"
              c:identifier="cogl_shader_ref"
              doc="Add an extra reference to a shader.">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_source"
              c:identifier="cogl_shader_source"
              doc="Replaces the current GLSL source associated with a shader with a new
one.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="shader" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_unref"
              c:identifier="cogl_shader_unref"
              doc="Removes a reference to a shader. If it was the last reference the
shader object will be destroyed.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="sqrti"
              c:identifier="cogl_sqrti"
              doc="Very fast fixed point implementation of square root for integers.
This function is at least 6x faster than clib sqrt() on x86, and (this is
not a typo!) about 500x faster on ARM without FPU. It&apos;s error is less than
5% for arguments smaller than %COGL_SQRTI_ARG_5_PERCENT and less than 10%
for narguments smaller than %COGL_SQRTI_ARG_10_PERCENT. The maximum
argument that can be passed to this function is %COGL_SQRTI_ARG_MAX."
              version="1.0">
      <return-value transfer-ownership="none">
        <type name="int" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_get_data"
              c:identifier="cogl_texture_get_data"
              doc="Copies the pixel data from a cogl texture to system memory.
is not valid">
      <return-value transfer-ownership="none">
        <type name="int" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="rowstride"
                   transfer-ownership="none"
                   doc=" specified.">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   doc=" only querying the data size through the return value.">
          <array c:type="guint8*">
            <type name="uint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="texture_get_format"
              c:identifier="cogl_texture_get_format"
              doc="Queries the #CoglPixelFormat of a cogl texture.">
      <return-value transfer-ownership="full">
        <type name="PixelFormat" c:type="CoglPixelFormat"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_get_gl_texture"
              c:identifier="cogl_texture_get_gl_texture"
              doc="Queries the GL handles for a GPU side texture through its #CoglHandle.
If the texture is spliced the data for the first sub texture will be
queried.
if the handle was invalid">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="out_gl_handle"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none"
                   allow-none="1"
                   doc="pointer to return location for the textures GL handle, or %NULL.">
          <type name="GL.uint" c:type="GLuint*"/>
        </parameter>
        <parameter name="out_gl_target"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none"
                   allow-none="1"
                   doc="pointer to return location for the GL target type, or %NULL.">
          <type name="GL.enum" c:type="GLenum*"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_get_height"
              c:identifier="cogl_texture_get_height"
              doc="Queries the height of a cogl texture.">
      <return-value transfer-ownership="none">
        <type name="uint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_get_max_waste"
              c:identifier="cogl_texture_get_max_waste"
              doc="Queries the maximum wasted (unused) pixels in one dimension of a GPU side
texture.">
      <return-value transfer-ownership="none">
        <type name="int" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_get_rowstride"
              c:identifier="cogl_texture_get_rowstride"
              doc="Queries the rowstride of a cogl texture.">
      <return-value transfer-ownership="none">
        <type name="uint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_get_width"
              c:identifier="cogl_texture_get_width"
              doc="Queries the width of a cogl texture.">
      <return-value transfer-ownership="none">
        <type name="uint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_is_sliced"
              c:identifier="cogl_texture_is_sliced"
              doc="Queries if a texture is sliced (stored as multiple GPU side tecture
objects).
is stored as a single GPU texture">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_new_from_bitmap"
              c:identifier="cogl_texture_new_from_bitmap"
              doc="Creates a COGL texture from a CoglBitmap.
%COGL_INVALID_HANDLE on failure"
              version="1.0">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="bmp_handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <type name="TextureFlags" c:type="CoglTextureFlags"/>
        </parameter>
        <parameter name="internal_format"
                   transfer-ownership="none"
                   doc=" texture">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_new_from_data"
              c:identifier="cogl_texture_new_from_data"
              doc="Creates a new COGL texture based on data residing in memory.
%COGL_INVALID_HANDLE on failure"
              version="0.8">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <type name="TextureFlags" c:type="CoglTextureFlags"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="internal_format"
                   transfer-ownership="none"
                   doc=" the buffer on the GPU. If COGL_PIXEL_FORMAT_ANY is given then a premultiplied format similar to the format of the source data will be used. The default blending equations of Cogl expect premultiplied color data; the main use of passing a non-premultiplied format here is if you have non-premultiplied source data and are going to adjust the blend mode (see cogl_material_set_blend()) or use the data for something other than straight blending.">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="rowstride"
                   transfer-ownership="none"
                   doc=" scanlines in @data">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <array c:type="guint8*">
            <type name="uint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="texture_new_from_file"
              c:identifier="cogl_texture_new_from_file"
              doc="Creates a COGL texture from an image file.
%COGL_INVALID_HANDLE on failure"
              version="0.8"
              throws="1">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <type name="TextureFlags" c:type="CoglTextureFlags"/>
        </parameter>
        <parameter name="internal_format"
                   transfer-ownership="none"
                   doc=" texture. If %COGL_PIXEL_FORMAT_ANY is given then a premultiplied format similar to the format of the source data will be used. The default blending equations of Cogl expect premultiplied color data; the main use of passing a non-premultiplied format here is if you have non-premultiplied source data and are going to adjust the blend mode (see cogl_material_set_blend()) or use the data for something other than straight blending.">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_new_from_foreign"
              c:identifier="cogl_texture_new_from_foreign"
              doc="Creates a COGL texture based on an existing OpenGL texture; the
width, height and format are passed along since it is not always
possible to query these from OpenGL.
The waste arguments allow you to create a Cogl texture that maps to
a region smaller than the real OpenGL texture. For instance if your
hardware only supports power-of-two textures you may load a
non-power-of-two image into a larger power-of-two texture and use
the waste arguments to tell Cogl which region should be mapped to
the texture coordinate range [0:1].
%COGL_INVALID_HANDLE on failure"
              version="0.8">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="gl_handle" transfer-ownership="none">
          <type name="GL.uint" c:type="GLuint"/>
        </parameter>
        <parameter name="gl_target" transfer-ownership="none">
          <type name="GL.enum" c:type="GLenum"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <type name="GL.uint" c:type="GLuint"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="GL.uint" c:type="GLuint"/>
        </parameter>
        <parameter name="x_pot_waste" transfer-ownership="none">
          <type name="GL.uint" c:type="GLuint"/>
        </parameter>
        <parameter name="y_pot_waste" transfer-ownership="none">
          <type name="GL.uint" c:type="GLuint"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_new_from_sub_texture"
              c:identifier="cogl_texture_new_from_sub_texture"
              doc="Creates a new texture which represents a subregion of another
texture. The GL resources will be shared so that no new texture
data is actually allocated.
Sub textures have undefined behaviour texture coordinates outside
of the range [0,1] are used. They also do not work with
CoglVertexBuffers.
The sub texture will keep a reference to the full texture so you do
not need to keep one separately if you only want to use the sub
texture."
              version="1.2">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="full_texture" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="sub_x" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="sub_y" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="sub_width" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="sub_height" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_new_with_size"
              c:identifier="cogl_texture_new_with_size"
              doc="Creates a new COGL texture with the specified dimensions and pixel format.
%COGL_INVALID_HANDLE on failure"
              version="0.8">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <type name="TextureFlags" c:type="CoglTextureFlags"/>
        </parameter>
        <parameter name="internal_format"
                   transfer-ownership="none"
                   doc=" texture.">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_ref"
              c:identifier="cogl_texture_ref"
              doc="Increment the reference count for a cogl texture."
              deprecated="Use cogl_handle_ref() instead"
              deprecated-version="1.2">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_set_region"
              c:identifier="cogl_texture_set_region"
              doc="Sets the pixels in a rectangular subregion of @handle from an in-memory
buffer containing pixel data.
%FALSE otherwise">
      <return-value transfer-ownership="none">
        <type name="boolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="src_x" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="src_y" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="dst_x" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="dst_y" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="dst_width" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="dst_height" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="rowstride"
                   transfer-ownership="none"
                   doc=" specified)">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <array c:type="guint8*">
            <type name="uint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="texture_unref"
              c:identifier="cogl_texture_unref"
              doc="Decrement the reference count for a cogl texture."
              deprecated="Use cogl_handle_unref() instead"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="translate"
              c:identifier="cogl_translate"
              doc="Multiplies the current model-view matrix by one that translates the
model along all three axes according to the given values.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <type name="float" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_add"
              c:identifier="cogl_vertex_buffer_add"
              doc="Adds an attribute to a buffer.
You either can use one of the built-in names such as &quot;gl_Vertex&quot;, or
&quot;gl_MultiTexCoord0&quot; to add standard attributes, like positions, colors
and normals, or you can add custom attributes for use in shaders.
The number of vertices declared when calling cogl_vertex_buffer_new()
determines how many attribute values will be read from the supplied
The data for your attribute isn&apos;t copied anywhere until you call
cogl_vertex_buffer_submit(), or issue a draw call which automatically
submits pending attribute changes. so the supplied pointer must remain
valid until then. If you are updating an existing attribute (done by
re-adding it) then you still need to re-call cogl_vertex_buffer_submit()
to commit the changes to the GPU. Be carefull to minimize the number
of calls to cogl_vertex_buffer_submit(), though.
&lt;note&gt;If you are interleving attributes it is assumed that each interleaved
attribute starts no farther than +- stride bytes from the other attributes
it is interleved with. I.e. this is ok:
&lt;programlisting&gt;
|-0-0-0-0-0-0-0-0-0-0|
&lt;/programlisting&gt;
This is not ok:
&lt;programlisting&gt;
|- - - - -0-0-0-0-0-0 0 0 0 0|
&lt;/programlisting&gt;
(Though you can have multiple groups of interleved attributes)&lt;/note&gt;">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name"
                   transfer-ownership="none"
                   doc=" variable name and standard attribute types must use one of following">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none" doc=" 3 or 4">
          <type name="uint8" c:type="guint8"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <type name="AttributeType" c:type="CoglAttributeType"/>
        </parameter>
        <parameter name="normalized"
                   transfer-ownership="none"
                   doc=" format should be mapped into the range [-1.0, 1.0] or [0.0, 1.0] for unsigned values. If %FALSE they are converted to floats directly.">
          <type name="boolean" c:type="gboolean"/>
        </parameter>
        <parameter name="stride"
                   transfer-ownership="none"
                   doc=" value to the start of the next value (for the same attribute). So, for example, with a position interleved with color like this: XYRGBAXYRGBAXYRGBA, then if each letter represents a byte, the stride for both attributes is 6. The special value 0 means the values are stored sequentially in memory.">
          <type name="uint16" c:type="guint16"/>
        </parameter>
        <parameter name="pointer"
                   transfer-ownership="none"
                   doc=" must remain valid until you either call cogl_vertex_buffer_submit() or issue a draw call.">
          <type name="any" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_delete"
              c:identifier="cogl_vertex_buffer_delete"
              doc="Deletes an attribute from a buffer. You will need to call
cogl_vertex_buffer_submit() or issue a draw call to commit this
change to the GPU.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_disable"
              c:identifier="cogl_vertex_buffer_disable"
              doc="Disables a previosuly added attribute.
Since it can be costly to add and remove new attributes to buffers; to make
individual buffers more reuseable it is possible to enable and disable
attributes before using a buffer for drawing.
You don&apos;t need to call cogl_vertex_buffer_submit() after using this
function.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_draw"
              c:identifier="cogl_vertex_buffer_draw"
              doc="Allows you to draw geometry using all or a subset of the
vertices in a vertex buffer.
Any un-submitted attribute changes are automatically submitted before
drawing.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none" doc=" interpreted.">
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="first" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_draw_elements"
              c:identifier="cogl_vertex_buffer_draw_elements"
              doc="This function lets you use an array of indices to specify the vertices
within your vertex buffer that you want to draw. The indices themselves
are created by calling cogl_vertex_buffer_indices_new ()
Any un-submitted attribute changes are automatically submitted before
drawing.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none" doc=" interpreted.">
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="indices"
                   transfer-ownership="none"
                   doc=" cogl_vertex_buffer_indices_new ()">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="min_index" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="max_index" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="indices_offset"
                   transfer-ownership="none"
                   doc=" index to use for drawing.">
          <type name="int" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_enable"
              c:identifier="cogl_vertex_buffer_enable"
              doc="Enables a previosuly disabled attribute.
Since it can be costly to add and remove new attributes to buffers; to make
individual buffers more reuseable it is possible to enable and disable
attributes before using a buffer for drawing.
You don&apos;t need to call cogl_vertex_buffer_submit() after using this function">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_get_n_vertices"
              c:identifier="cogl_vertex_buffer_get_n_vertices"
              doc="Retrieves the number of vertices that @handle represents">
      <return-value transfer-ownership="none">
        <type name="uint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_get_for_quads"
              c:identifier="cogl_vertex_buffer_indices_get_for_quads"
              doc="Creates a vertex buffer containing the indices needed to draw pairs
of triangles from a list of vertices grouped as quads. There will
be at least @n_indices entries in the buffer (but there may be
more).
The indices will follow this pattern:
0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7 ... etc
For example, if you submit vertices for a quad like this:
|[
0        3
########
#      #
#      #
########
1        2
]|
Then you can request 6 indices to render two triangles like this:
|[
0           0        3
##          ########
# ##          ##   #
#   ##          ## #
########          ##
1        2           2
]|
owned by Cogl and should not be modified or unref&apos;d.">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="n_indices" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_get_type"
              c:identifier="cogl_vertex_buffer_indices_get_type"
              doc="Queries back the data type used for the given indices">
      <return-value transfer-ownership="full">
        <type name="IndicesType" c:type="CoglIndicesType"/>
      </return-value>
      <parameters>
        <parameter name="indices" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_new"
              c:identifier="cogl_vertex_buffer_indices_new"
              doc="Depending on how much geometry you are submitting it can be worthwhile
optimizing the number of redundant vertices you submit. Using an index
array allows you to reference vertices multiple times, for example
during triangle strips.
cogl_vertex_buffer_draw_elements().">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="indices_type"
                   transfer-ownership="none"
                   doc=" the indices.">
          <type name="IndicesType" c:type="CoglIndicesType"/>
        </parameter>
        <parameter name="indices_array"
                   transfer-ownership="none"
                   doc="Specifies the address of your array of indices">
          <array length="2" c:type="void*">
            <type name="any"/>
          </array>
        </parameter>
        <parameter name="indices_len" transfer-ownership="none">
          <type name="int" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_new"
              c:identifier="cogl_vertex_buffer_new"
              doc="Creates a new vertex buffer that you can use to add attributes.">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="n_vertices" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_ref"
              c:identifier="cogl_vertex_buffer_ref"
              doc="Increment the reference count for a vertex buffer"
              deprecated="Use cogl_handle_ref() instead"
              deprecated-version="1.2">
      <return-value transfer-ownership="full">
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_submit"
              c:identifier="cogl_vertex_buffer_submit"
              doc="Submits all the user added attributes to the GPU; once submitted, the
attributes can be used for drawing.
You should aim to minimize calls to this function since it implies
validating your data; it potentially incurs a transport cost (especially if
you are using GLX indirect rendering) and potentially a format conversion
cost if the GPU doesn&apos;t natively support any of the given attribute formats.">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_unref"
              c:identifier="cogl_vertex_buffer_unref"
              doc="Decrement the reference count for a vertex buffer"
              deprecated="Use cogl_handle_unref() instead"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="viewport"
              c:identifier="cogl_viewport"
              doc="Replace the current viewport with the given values."
              version="0.8.2"
              deprecated="Use cogl_set_viewport() instead"
              deprecated-version="1.2">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="uint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
