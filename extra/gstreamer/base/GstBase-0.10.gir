<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gst" version="0.10"/>
  <include name="libxml2" version="2.0"/>
  <package name="gstreamer-base-0.10"/>
  <c:include name="gst/base/gstadapter.h"/>
  <c:include name="gst/base/gstbasesink.h"/>
  <c:include name="gst/base/gstbasesrc.h"/>
  <c:include name="gst/base/gstbasetransform.h"/>
  <c:include name="gst/base/gstbitreader.h"/>
  <c:include name="gst/base/gstbytereader.h"/>
  <c:include name="gst/base/gstbytewriter.h"/>
  <c:include name="gst/base/gstcollectpads.h"/>
  <c:include name="gst/base/gstdataqueue.h"/>
  <c:include name="gst/base/gstpushsrc.h"/>
  <c:include name="gst/base/gsttypefindhelper.h"/>
  <namespace name="GstBase"
             version="0.10"
             shared-library="libgstreamer-0.10.so.0,libgstbase-0.10.so.0"
             c:identifier-prefixes="Gst"
             c:symbol-prefixes="gst">
    <class name="Adapter"
           c:symbol-prefix="adapter"
           c:type="GstAdapter"
           parent="GObject.Object"
           glib:type-name="GstAdapter"
           glib:get-type="gst_adapter_get_type"
           glib:type-struct="AdapterClass">
      <doc xml:whitespace="preserve">The opaque #GstAdapter data structure.</doc>
      <constructor name="new" c:identifier="gst_adapter_new">
        <doc xml:whitespace="preserve">Creates a new #GstAdapter. Free with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstAdapter</doc>
          <type name="Adapter" c:type="GstAdapter*"/>
        </return-value>
      </constructor>
      <method name="available" c:identifier="gst_adapter_available">
        <doc xml:whitespace="preserve">Gets the maximum amount of bytes available, that is it returns the maximum
value that can be supplied to gst_adapter_peek() without that function
returning NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">number of bytes available in @adapter</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="available_fast" c:identifier="gst_adapter_available_fast">
        <doc xml:whitespace="preserve">Gets the maximum number of bytes that are immediately available without
requiring any expensive operations (like copying the data into a
temporary buffer).
operations</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">number of bytes that are available in @adapter without expensive</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="clear" c:identifier="gst_adapter_clear">
        <doc xml:whitespace="preserve">Removes all buffers from @adapter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="copy" c:identifier="gst_adapter_copy" version="0.10.12">
        <doc xml:whitespace="preserve">Copies @size bytes of data starting at @offset out of the buffers
contained in @GstAdapter into an array @dest provided by the caller.
The array @dest should be large enough to contain @size bytes.
The user should check that the adapter has (@offset + @size) bytes
available before calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">the memory to copy into</doc>
            <array length="2" c:type="guint8*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the bytes offset in the adapter to start from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the number of bytes to copy</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="gst_adapter_flush">
        <doc xml:whitespace="preserve">Flushes the first @flush bytes in the @adapter. The caller must ensure that
at least this many bytes are available.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flush" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to flush</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="masked_scan_uint32"
              c:identifier="gst_adapter_masked_scan_uint32"
              version="0.10.24">
        <doc xml:whitespace="preserve">Scan for pattern @pattern with applied mask @mask in the adapter data,
starting from offset @offset.
The bytes in @pattern and @mask are interpreted left-to-right, regardless
of endianness.  All four bytes of the pattern must be present in the
adapter for it to match, even if the first or last bytes are masked out.
It is an error to call this function without making sure that there is
enough data (offset+size bytes) in the adapter.
This function calls gst_adapter_masked_scan_uint32_peek() passing NULL
for value.
Example:
&lt;programlisting&gt;
// Assume the adapter contains 0x00 0x01 0x02 ... 0xfe 0xff
gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x00010203, 0, 256);
// -&gt; returns 0
gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x00010203, 1, 255);
// -&gt; returns -1
gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x01020304, 1, 255);
// -&gt; returns 1
gst_adapter_masked_scan_uint32 (adapter, 0xffff, 0x0001, 0, 256);
// -&gt; returns -1
gst_adapter_masked_scan_uint32 (adapter, 0xffff, 0x0203, 0, 256);
// -&gt; returns 0
gst_adapter_masked_scan_uint32 (adapter, 0xffff0000, 0x02030000, 0, 256);
// -&gt; returns 2
gst_adapter_masked_scan_uint32 (adapter, 0xffff0000, 0x02030000, 0, 4);
// -&gt; returns -1
&lt;/programlisting&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">offset of the first match, or -1 if no match was found.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:whitespace="preserve">mask to apply to data before matching against @pattern</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:whitespace="preserve">pattern to match (after mask is applied)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">offset into the adapter data from which to start scanning, returns the last scanned position.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bytes to scan from offset</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="masked_scan_uint32_peek"
              c:identifier="gst_adapter_masked_scan_uint32_peek"
              version="0.10.30">
        <doc xml:whitespace="preserve">Scan for pattern @pattern with applied mask @mask in the adapter data,
starting from offset @offset.  If a match is found, the value that matched
is returned through @value, otherwise @value is left untouched.
The bytes in @pattern and @mask are interpreted left-to-right, regardless
of endianness.  All four bytes of the pattern must be present in the
adapter for it to match, even if the first or last bytes are masked out.
It is an error to call this function without making sure that there is
enough data (offset+size bytes) in the adapter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">offset of the first match, or -1 if no match was found.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:whitespace="preserve">mask to apply to data before matching against @pattern</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:whitespace="preserve">pattern to match (after mask is applied)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">offset into the adapter data from which to start scanning, returns the last scanned position.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bytes to scan from offset</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to uint32 to return matching data</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="gst_adapter_peek">
        <doc xml:whitespace="preserve">Gets the first @size bytes stored in the @adapter. The returned pointer is
valid until the next function is called on the adapter.
Note that setting the returned pointer as the data of a #GstBuffer is
incorrect for general-purpose plugins. The reason is that if a downstream
element stores the buffer so that it has access to it outside of the bounds
of its chain function, the buffer will have an invalid data pointer after
your element flushes the bytes. In that case you should use
gst_adapter_take(), which returns a freshly-allocated buffer that you can set
as #GstBuffer malloc_data or the potentially more performant
gst_adapter_take_buffer().
Returns #NULL if @size bytes are not available.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to the first</doc>
          <array length="0" c:type="guint8*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the number of bytes to peek</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="prev_timestamp"
              c:identifier="gst_adapter_prev_timestamp"
              version="0.10.24">
        <doc xml:whitespace="preserve">Get the timestamp that was before the current byte in the adapter. When
position is returned.
The timestamp is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
the adapter is first created or when it is cleared. This also means that before
the first byte with a timestamp is removed from the adapter, the timestamp
and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The previously seen timestamp.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="distance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">pointer to location for distance, or NULL</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="gst_adapter_push">
        <doc xml:whitespace="preserve">Adds the data from @buf to the data stored inside @adapter and takes
ownership of the buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstBuffer to add to queue in the adapter</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take" c:identifier="gst_adapter_take">
        <doc xml:whitespace="preserve">Returns a freshly allocated buffer containing the first @nbytes bytes of the
Caller owns returned value. g_free after usage.
#NULL if @nbytes bytes are not available</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">oven-fresh hot data, or</doc>
          <array length="0" c:type="guint8*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="nbytes"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the number of bytes to take</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_buffer"
              c:identifier="gst_adapter_take_buffer"
              version="0.10.6">
        <doc xml:whitespace="preserve">Returns a #GstBuffer containing the first @nbytes bytes of the
This function is potentially more performant than gst_adapter_take()
since it can reuse the memory in pushed buffers by subbuffering
or merging.
Caller owns returned value. gst_buffer_unref() after usage.
the adapter, or #NULL if @nbytes bytes are not available</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstBuffer containing the first @nbytes of</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to take</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_list"
              c:identifier="gst_adapter_take_list"
              version="0.10.31">
        <doc xml:whitespace="preserve">Returns a #GList of buffers containing the first @nbytes bytes of the
When the caller can deal with individual buffers, this function is more
performant because no memory should be copied.
Caller owns returned list and contained buffers. gst_buffer_unref() each
buffer in the list before freeing the list after usage.
containing the first @nbytes of the adapter, or #NULL if @nbytes bytes
are not available</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of buffers</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Gst.Buffer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to take</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="buflist">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="size">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="skip">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="assembled_data">
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="assembled_size">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="assembled_len">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="buflist_end">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="priv">
        <type name="AdapterPrivate" c:type="GstAdapterPrivate*"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AdapterClass"
            c:type="GstAdapterClass"
            glib:is-gtype-struct-for="Adapter">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AdapterPrivate" c:type="GstAdapterPrivate" disguised="1">
    </record>
    <constant name="BASE_TRANSFORM_SINK_NAME" value="sink">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="BASE_TRANSFORM_SRC_NAME" value="src">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="BaseSink"
           c:symbol-prefix="base_sink"
           c:type="GstBaseSink"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstBaseSink"
           glib:get-type="gst_base_sink_get_type"
           glib:type-struct="BaseSinkClass">
      <doc xml:whitespace="preserve">The opaque #GstBaseSink data structure.</doc>
      <virtual-method name="activate_pull">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="active" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="async_play">
        <return-value transfer-ownership="none">
          <type name="Gst.StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
      </virtual-method>
      <virtual-method name="buffer_alloc">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fixate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_caps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_times">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="preroll">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="render">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="render_list">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer_list" transfer-ownership="none">
            <type name="Gst.BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_caps">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unlock">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unlock_stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="do_preroll"
              c:identifier="gst_base_sink_do_preroll"
              version="0.10.22">
        <doc xml:whitespace="preserve">If the @sink spawns its own thread for pulling buffers from upstream it
should call this method after it has pulled a buffer. If the element needed
to preroll, this function will perform the preroll and will then block
until the element state is changed.
This function should be called with the PREROLL_LOCK held.
continue. Any other return value should be returned from the render vmethod.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GST_FLOW_OK if the preroll completed and processing can</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mini object that caused the preroll</doc>
            <type name="Gst.MiniObject" c:type="GstMiniObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_blocksize"
              c:identifier="gst_base_sink_get_blocksize"
              version="0.10.22">
        <doc xml:whitespace="preserve">Get the number of bytes that the sink will pull when it is operating in pull
mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes @sink will pull in pull mode.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_last_buffer"
              c:identifier="gst_base_sink_get_last_buffer"
              version="0.10.15">
        <doc xml:whitespace="preserve">Get the last buffer that arrived in the sink and was used for preroll or for
rendering. This property can be used to generate thumbnails.
The #GstCaps on the buffer can be used to determine the type of the buffer.
This function returns NULL when no buffer has arrived in the sink yet
or when the sink is not in PAUSED or PLAYING.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstBuffer. gst_buffer_unref() after usage.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="get_latency"
              c:identifier="gst_base_sink_get_latency"
              version="0.10.12">
        <doc xml:whitespace="preserve">Get the currently configured latency.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The configured latency.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_max_lateness"
              c:identifier="gst_base_sink_get_max_lateness"
              version="0.10.4">
        <doc xml:whitespace="preserve">Gets the max lateness value. See gst_base_sink_set_max_lateness for
more details.
before it is dropped and not rendered. A value of -1 means an
unlimited time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The maximum time in nanoseconds that a buffer can be late</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_render_delay"
              c:identifier="gst_base_sink_get_render_delay"
              version="0.10.21">
        <doc xml:whitespace="preserve">Get the render delay of @sink. see gst_base_sink_set_render_delay() for more
information about the render delay.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the render delay of @sink.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_sync"
              c:identifier="gst_base_sink_get_sync"
              version="0.10.4">
        <doc xml:whitespace="preserve">Checks if @sink is currently configured to synchronize against the
clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the sink is configured to synchronize against the clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_ts_offset"
              c:identifier="gst_base_sink_get_ts_offset"
              version="0.10.15">
        <doc xml:whitespace="preserve">Get the synchronisation offset of @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The synchronisation offset.</doc>
          <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
        </return-value>
      </method>
      <method name="is_async_enabled"
              c:identifier="gst_base_sink_is_async_enabled"
              version="0.10.15">
        <doc xml:whitespace="preserve">Checks if @sink is currently configured to perform asynchronous state
changes to PAUSED.
changes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the sink is configured to perform asynchronous state</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_last_buffer_enabled"
              c:identifier="gst_base_sink_is_last_buffer_enabled"
              version="0.10.30">
        <doc xml:whitespace="preserve">Checks if @sink is currently configured to store the last received buffer in
the last-buffer property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the sink is configured to store the last received buffer.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_qos_enabled"
              c:identifier="gst_base_sink_is_qos_enabled"
              version="0.10.5">
        <doc xml:whitespace="preserve">Checks if @sink is currently configured to send Quality-of-Service events
upstream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the sink is configured to perform Quality-of-Service.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="query_latency"
              c:identifier="gst_base_sink_query_latency"
              version="0.10.12">
        <doc xml:whitespace="preserve">Query the sink for the latency parameters. The latency will be queried from
the upstream elements. @live will be TRUE if @sink is configured to
synchronize against the clock. @upstream_live will be TRUE if an upstream
element is live.
If both @live and @upstream_live are TRUE, the sink will want to compensate
for the latency introduced by the upstream elements by setting the
This function is mostly used by subclasses.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">if the sink is live</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="upstream_live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">if an upstream element is live</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="min_latency"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the min latency of the upstream elements</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max_latency"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the max latency of the upstream elements</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_async_enabled"
              c:identifier="gst_base_sink_set_async_enabled"
              version="0.10.15">
        <doc xml:whitespace="preserve">Configures @sink to perform all state changes asynchronusly. When async is
disabled, the sink will immediatly go to PAUSED instead of waiting for a
preroll buffer. This feature is usefull if the sink does not synchronize
against the clock or when it is dealing with sparse streams.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new async value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blocksize"
              c:identifier="gst_base_sink_set_blocksize"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the number of bytes that the sink will pull when it is operating in pull
mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="blocksize" transfer-ownership="none">
            <doc xml:whitespace="preserve">the blocksize in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_last_buffer_enabled"
              c:identifier="gst_base_sink_set_last_buffer_enabled"
              version="0.10.30">
        <doc xml:whitespace="preserve">Configures @sink to store the last received buffer in the last-buffer
property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new enable-last-buffer value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_lateness"
              c:identifier="gst_base_sink_set_max_lateness"
              version="0.10.4">
        <doc xml:whitespace="preserve">Sets the new max lateness value to @max_lateness. This value is
used to decide if a buffer should be dropped or not based on the
buffer timestamp and the current clock time. A value of -1 means
an unlimited time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="max_lateness" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new max lateness value.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qos_enabled"
              c:identifier="gst_base_sink_set_qos_enabled"
              version="0.10.5">
        <doc xml:whitespace="preserve">Configures @sink to send Quality-of-Service events upstream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new qos value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_render_delay"
              c:identifier="gst_base_sink_set_render_delay"
              version="0.10.21">
        <doc xml:whitespace="preserve">Set the render delay in @sink to @delay. The render delay is the time
between actual rendering of a buffer and its synchronisation time. Some
devices might delay media rendering which can be compensated for with this
function.
After calling this function, this sink will report additional latency and
other sinks will adjust their latency to delay the rendering of their media.
This function is usually called by subclasses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="delay" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new delay</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sync"
              c:identifier="gst_base_sink_set_sync"
              version="0.10.4">
        <doc xml:whitespace="preserve">Configures @sink to synchronize on the clock or not. When
possible. If @sync is TRUE, the timestamps of the incomming
buffers will be used to schedule the exact render time of its
contents.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="sync" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new sync value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ts_offset"
              c:identifier="gst_base_sink_set_ts_offset"
              version="0.10.15">
        <doc xml:whitespace="preserve">Adjust the synchronisation of @sink with @offset. A negative value will
render buffers earlier than their timestamp. A positive value will delay
rendering. This function can be used to fix playback of badly timestamped
buffers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new offset</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_clock"
              c:identifier="gst_base_sink_wait_clock"
              version="0.10.20">
        <doc xml:whitespace="preserve">This function will block until @time is reached. It is usually called by
subclasses that use their own internal synchronisation.
If @time is not valid, no sycnhronisation is done and #GST_CLOCK_BADTIME is
returned. Likewise, if synchronisation is disabled in the element or there
is no clock, no synchronisation is done and #GST_CLOCK_BADTIME is returned.
This function should only be called with the PREROLL_LOCK held, like when
receiving an EOS event in the #GstBaseSinkClass.event() vmethod or when
receiving a buffer in
the #GstBaseSinkClass.render() vmethod.
The @time argument should be the running_time of when this method should
return and is not adjusted with any latency or offset configured in the
sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstClockReturn</doc>
          <type name="Gst.ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the running_time to be reached</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="jitter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the jitter to be filled with time diff, or NULL</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_eos"
              c:identifier="gst_base_sink_wait_eos"
              version="0.10.15">
        <doc xml:whitespace="preserve">This function will block until @time is reached. It is usually called by
subclasses that use their own internal synchronisation but want to let the
EOS be handled by the base class.
This function should only be called with the PREROLL_LOCK held, like when
receiving an EOS event in the ::event vmethod.
The @time argument should be the running_time of when the EOS should happen
and will be adjusted with any latency and offset configured in the sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstFlowReturn</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the running_time to be reached</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="jitter"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the jitter to be filled with time diff, or NULL</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_preroll"
              c:identifier="gst_base_sink_wait_preroll"
              version="0.10.11">
        <doc xml:whitespace="preserve">If the #GstBaseSinkClass.render() method performs its own synchronisation
against the clock it must unblock when going from PLAYING to the PAUSED state
and call this method before continuing to render the remaining data.
This function will block until a state change to PLAYING happens (in which
case this function returns #GST_FLOW_OK) or the processing must be stopped due
to a state change to READY or a FLUSH event (in which case this function
returns #GST_FLOW_WRONG_STATE).
This function should only be called with the PREROLL_LOCK held, like in the
render function.
continue. Any other return value should be returned from the render vmethod.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GST_FLOW_OK if the preroll completed and processing can</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
      </method>
      <property name="async" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="blocksize" writable="1" transfer-ownership="none">
        <type name="guint"/>
      </property>
      <property name="enable-last-buffer"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="last-buffer" transfer-ownership="none">
        <type name="Gst.Buffer"/>
      </property>
      <property name="max-lateness" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="preroll-queue-len"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint"/>
      </property>
      <property name="qos" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="render-delay" writable="1" transfer-ownership="none">
        <type name="guint64"/>
      </property>
      <property name="sync" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="ts-offset" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="pad_mode">
        <type name="Gst.ActivateMode" c:type="GstActivateMode"/>
      </field>
      <field name="offset">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="can_activate_pull">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="can_activate_push">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="preroll_queue">
        <type name="GLib.Queue" c:type="GQueue*"/>
      </field>
      <field name="preroll_queue_max_len">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="preroll_queued">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="buffers_queued">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="events_queued">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="eos">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="eos_queued">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="need_preroll">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="have_preroll">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="playing_async">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="have_newsegment">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="clock_id">
        <type name="Gst.ClockID" c:type="GstClockID"/>
      </field>
      <field name="end_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="sync">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="flushing">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="clip_segment" writable="1">
            <type name="Gst.Segment" c:type="GstSegment*"/>
          </field>
          <field name="max_lateness" writable="1">
            <type name="gint64" c:type="gint64"/>
          </field>
          <field name="running" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="19">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
      <field name="priv">
        <type name="BaseSinkPrivate" c:type="GstBaseSinkPrivate*"/>
      </field>
    </class>
    <record name="BaseSinkClass"
            c:type="GstBaseSinkClass"
            glib:is-gtype-struct-for="BaseSink">
      <doc xml:whitespace="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At the minimum, the @render method should be overridden to
output/present buffers.</doc>
      <field name="parent_class">
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="get_caps">
        <callback name="get_caps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_caps">
        <callback name="set_caps">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="buffer_alloc">
        <callback name="buffer_alloc">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_times">
        <callback name="get_times">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="start" transfer-ownership="none">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
            <parameter name="end" transfer-ownership="none">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock">
        <callback name="unlock">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="preroll">
        <callback name="preroll">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="render">
        <callback name="render">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="async_play">
        <callback name="async_play">
          <return-value transfer-ownership="none">
            <type name="Gst.StateChangeReturn" c:type="GstStateChangeReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate_pull">
        <callback name="activate_pull">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="active" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fixate">
        <callback name="fixate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock_stop">
        <callback name="unlock_stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="render_list">
        <callback name="render_list">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer_list" transfer-ownership="none">
              <type name="Gst.BufferList" c:type="GstBufferList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="15">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseSinkPrivate" c:type="GstBaseSinkPrivate" disguised="1">
    </record>
    <class name="BaseSrc"
           c:symbol-prefix="base_src"
           c:type="GstBaseSrc"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstBaseSrc"
           glib:get-type="gst_base_src_get_type"
           glib:type-struct="BaseSrcClass">
      <doc xml:whitespace="preserve">The opaque #GstBaseSrc data structure.</doc>
      <virtual-method name="check_get_range">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="create">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="do_seek">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="segment" transfer-ownership="none">
            <type name="Gst.Segment" c:type="GstSegment*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fixate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_caps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_size">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_times">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_seekable">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="negotiate">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="newsegment">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="prepare_seek_segment">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="seek" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
          <parameter name="segment" transfer-ownership="none">
            <type name="Gst.Segment" c:type="GstSegment*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_caps">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unlock">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unlock_stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="get_blocksize"
              c:identifier="gst_base_src_get_blocksize"
              version="0.10.22">
        <doc xml:whitespace="preserve">Get the number of bytes that @src will push out with each buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes pushed with each buffer.</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
      </method>
      <method name="get_do_timestamp"
              c:identifier="gst_base_src_get_do_timestamp"
              version="0.10.15">
        <doc xml:whitespace="preserve">Query if @src timestamps outgoing buffers based on the current running_time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the base class will automatically timestamp outgoing buffers.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_live" c:identifier="gst_base_src_is_live">
        <doc xml:whitespace="preserve">Check if an element is in live mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if element is in live mode.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="new_seamless_segment"
              c:identifier="gst_base_src_new_seamless_segment"
              version="0.10.26">
        <doc xml:whitespace="preserve">Prepare a new seamless segment for emission downstream. This function must
only be called by derived sub-classes, and only from the create() function,
as the stream-lock needs to be held.
The format for the new segment will be the current format of the source, as
configured with gst_base_src_set_format()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if preparation of the seamless segment succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new start value for the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">Stop value for the new segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">The position value for the new segent</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_latency"
              c:identifier="gst_base_src_query_latency"
              version="0.10.13">
        <doc xml:whitespace="preserve">Query the source for the latency parameters. @live will be TRUE when @src is
configured as a live source. @min_latency will be set to the difference
between the running time and the timestamp of the first buffer.
This function is mostly used by subclasses.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">if the source is live</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="min_latency"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the min latency of the source</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max_latency"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the max latency of the source</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blocksize"
              c:identifier="gst_base_src_set_blocksize"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the number of bytes that @src will push out with each buffer. When</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="blocksize" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new blocksize in bytes</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_do_timestamp"
              c:identifier="gst_base_src_set_do_timestamp"
              version="0.10.15">
        <doc xml:whitespace="preserve">Configure @src to automatically timestamp outgoing buffers based on the
current running_time of the pipeline. This property is mostly useful for live
sources.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">enable or disable timestamping</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_format"
              c:identifier="gst_base_src_set_format"
              version="0.10.1">
        <doc xml:whitespace="preserve">Sets the default format of the source. This will be the format used
for sending NEW_SEGMENT events and for performing seeks.
If a format of GST_FORMAT_BYTES is set, the element will be able to
operate in pull mode if the #GstBaseSrc.is_seekable() returns TRUE.
This function must only be called in states &lt; %GST_STATE_PAUSED.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format to use</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_live" c:identifier="gst_base_src_set_live">
        <doc xml:whitespace="preserve">If the element listens to a live source, @live should
be set to %TRUE.
A live source will not produce data in the PAUSED state and
will therefore not be able to participate in the PREROLL phase
of a pipeline. To signal this fact to the application and the
pipeline, the state change return value of the live source will
be GST_STATE_CHANGE_NO_PREROLL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="live" transfer-ownership="none">
            <doc xml:whitespace="preserve">new live-mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_playing"
              c:identifier="gst_base_src_wait_playing"
              version="0.10.12">
        <doc xml:whitespace="preserve">If the #GstBaseSrcClass.create() method performs its own synchronisation
against the clock it must unblock when going from PLAYING to the PAUSED state
and call this method before continuing to produce the remaining data.
This function will block until a state change to PLAYING happens (in which
case this function returns #GST_FLOW_OK) or the processing must be stopped due
to a state change to READY or a FLUSH event (in which case this function
returns #GST_FLOW_WRONG_STATE).
continue. Any other return value should be returned from the create vmethod.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GST_FLOW_OK if @src is PLAYING and processing can</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
      </method>
      <property name="blocksize" writable="1" transfer-ownership="none">
        <type name="gulong"/>
      </property>
      <property name="do-timestamp" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="num-buffers" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <property name="typefind" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="live_lock">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="live_cond">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="is_live">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="live_running">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="blocksize">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="can_activate_push">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="pad_mode">
        <type name="Gst.ActivateMode" c:type="GstActivateMode"/>
      </field>
      <field name="seekable">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="random_access">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="clock_id">
        <type name="Gst.ClockID" c:type="GstClockID"/>
      </field>
      <field name="end_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="need_newsegment">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="offset">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="size">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="num_buffers">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="num_buffers_left">
        <type name="gint" c:type="gint"/>
      </field>
      <union name="data" c:type="data">
        <record name="ABI" c:type="ABI">
          <field name="typefind" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="running" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="pending_seek" writable="1">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="19">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
      <field name="priv">
        <type name="BaseSrcPrivate" c:type="GstBaseSrcPrivate*"/>
      </field>
    </class>
    <record name="BaseSrcClass"
            c:type="GstBaseSrcClass"
            glib:is-gtype-struct-for="BaseSrc">
      <doc xml:whitespace="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At the minimum, the @create method should be overridden to produce
buffers.</doc>
      <field name="parent_class">
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="get_caps">
        <callback name="get_caps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_caps">
        <callback name="set_caps">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="negotiate">
        <callback name="negotiate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="newsegment">
        <callback name="newsegment">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_times">
        <callback name="get_times">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="start" transfer-ownership="none">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
            <parameter name="end" transfer-ownership="none">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_size">
        <callback name="get_size">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint64" c:type="guint64*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_seekable">
        <callback name="is_seekable">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock">
        <callback name="unlock">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create">
        <callback name="create">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="do_seek">
        <callback name="do_seek">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="segment" transfer-ownership="none">
              <type name="Gst.Segment" c:type="GstSegment*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query">
        <callback name="query">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="check_get_range">
        <callback name="check_get_range">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fixate">
        <callback name="fixate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock_stop">
        <callback name="unlock_stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare_seek_segment">
        <callback name="prepare_seek_segment">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="seek" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
            <parameter name="segment" transfer-ownership="none">
              <type name="Gst.Segment" c:type="GstSegment*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="14">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="BaseSrcFlags" c:type="GstBaseSrcFlags">
      <doc xml:whitespace="preserve">The #GstElement flags that a basesrc element may have.</doc>
      <member name="started"
              value="1048576"
              c:identifier="GST_BASE_SRC_STARTED"/>
      <member name="flag_last"
              value="4194304"
              c:identifier="GST_BASE_SRC_FLAG_LAST"/>
    </bitfield>
    <record name="BaseSrcPrivate" c:type="GstBaseSrcPrivate" disguised="1">
    </record>
    <class name="BaseTransform"
           c:symbol-prefix="base_transform"
           c:type="GstBaseTransform"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstBaseTransform"
           glib:get-type="gst_base_transform_get_type"
           glib:type-struct="BaseTransformClass">
      <doc xml:whitespace="preserve">The opaque #GstBaseTransform data structure.</doc>
      <virtual-method name="accept_caps">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="before_transform">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fixate_caps">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="othercaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_unit_size">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare_output_buffer">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="input" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_caps">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="incaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="outcaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="transform">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="inbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_caps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_ip">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_size">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="othercaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="othersize" transfer-ownership="none">
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="is_in_place" c:identifier="gst_base_transform_is_in_place">
        <doc xml:whitespace="preserve">See if @trans is configured as a in_place transform.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE is the transform is configured in in_place mode.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_passthrough"
              c:identifier="gst_base_transform_is_passthrough">
        <doc xml:whitespace="preserve">See if @trans is configured as a passthrough transform.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE is the transform is configured in passthrough mode.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_qos_enabled"
              c:identifier="gst_base_transform_is_qos_enabled"
              version="0.10.5">
        <doc xml:whitespace="preserve">Queries if the transform will handle QoS.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if QoS is enabled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="reconfigure"
              c:identifier="gst_base_transform_reconfigure"
              version="0.10.21">
        <doc xml:whitespace="preserve">Instructs @trans to renegotiate a new downstream transform on the next
buffer. This function is typically called after properties on the transform
were set that influence the output format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_gap_aware"
              c:identifier="gst_base_transform_set_gap_aware"
              version="0.10.16">
        <doc xml:whitespace="preserve">If @gap_aware is %FALSE (the default), output buffers will have the
%GST_BUFFER_FLAG_GAP flag unset.
If set to %TRUE, the element must handle output buffers with this flag set
correctly, i.e. it can assume that the buffer contains neutral data but must
unset the flag if the output is no neutral data.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gap_aware" transfer-ownership="none">
            <doc xml:whitespace="preserve">New state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_in_place"
              c:identifier="gst_base_transform_set_in_place">
        <doc xml:whitespace="preserve">Determines whether a non-writable buffer will be copied before passing
to the transform_ip function.
&lt;itemizedlist&gt;
&lt;listitem&gt;Always TRUE if no transform function is implemented.&lt;/listitem&gt;
&lt;listitem&gt;Always FALSE if ONLY transform function is implemented.&lt;/listitem&gt;
&lt;/itemizedlist&gt;
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="in_place" transfer-ownership="none">
            <doc xml:whitespace="preserve">Boolean value indicating that we would like to operate on in_place buffers.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_passthrough"
              c:identifier="gst_base_transform_set_passthrough">
        <doc xml:whitespace="preserve">Set passthrough mode for this filter by default. This is mostly
useful for filters that do not care about negotiation.
Always TRUE for filters which don't implement either a transform
or transform_ip method.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="passthrough" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean indicating passthrough mode.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qos_enabled"
              c:identifier="gst_base_transform_set_qos_enabled"
              version="0.10.5">
        <doc xml:whitespace="preserve">Enable or disable QoS handling in the transform.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="suggest"
              c:identifier="gst_base_transform_suggest"
              version="0.10.21">
        <doc xml:whitespace="preserve">Instructs @trans to suggest new @caps upstream. A copy of @caps will be
taken.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">caps to suggest</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">buffer size to suggest</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_qos"
              c:identifier="gst_base_transform_update_qos"
              version="0.10.5">
        <doc xml:whitespace="preserve">Set the QoS parameters in the transform. This function is called internally
when a QOS event is received but subclasses can provide custom information
when needed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="proportion" transfer-ownership="none">
            <doc xml:whitespace="preserve">the proportion</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="diff" transfer-ownership="none">
            <doc xml:whitespace="preserve">the diff against the clock</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timestamp of the buffer generating the QoS expressed in running_time.</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <property name="qos" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="passthrough">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="always_in_place">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="cache_caps1">
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="cache_caps1_size">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="cache_caps2">
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="cache_caps2_size">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="have_same_caps">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="delay_configure">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="pending_configure">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="negotiated">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="have_newsegment">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="transform_lock">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="priv">
        <type name="BaseTransformPrivate" c:type="GstBaseTransformPrivate*"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="19">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="BaseTransformClass"
            c:type="GstBaseTransformClass"
            glib:is-gtype-struct-for="BaseTransform">
      <doc xml:whitespace="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At minimum either @transform or @transform_ip need to be overridden.
If the element can overwrite the input data with the results (data is of the
same type and quantity) it should provide @transform_ip.</doc>
      <field name="parent_class">
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="transform_caps">
        <callback name="transform_caps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fixate_caps">
        <callback name="fixate_caps">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="othercaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_size">
        <callback name="transform_size">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="othercaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="othersize" transfer-ownership="none">
              <type name="guint" c:type="guint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_unit_size">
        <callback name="get_unit_size">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_caps">
        <callback name="set_caps">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="incaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="outcaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform">
        <callback name="transform">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="inbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="outbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_ip">
        <callback name="transform_ip">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="passthrough_on_same_caps">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="prepare_output_buffer">
        <callback name="prepare_output_buffer">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="input" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_event">
        <callback name="src_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="before_transform">
        <callback name="before_transform">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="accept_caps">
        <callback name="accept_caps">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="17">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseTransformPrivate"
            c:type="GstBaseTransformPrivate"
            disguised="1">
    </record>
    <record name="BitReader" c:type="GstBitReader">
      <doc xml:whitespace="preserve">A bit reader instance.</doc>
      <field name="data" writable="1">
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="byte" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="bit" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="free" c:identifier="gst_bit_reader_free" version="0.10.22">
        <doc xml:whitespace="preserve">Frees a #GstBitReader instance, which was previously allocated by
gst_bit_reader_new() or gst_bit_reader_new_from_buffer().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_bits_uint16"
              c:identifier="gst_bit_reader_get_bits_uint16"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bits_uint32"
              c:identifier="gst_bit_reader_get_bits_uint32"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bits_uint64"
              c:identifier="gst_bit_reader_get_bits_uint64"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bits_uint8"
              c:identifier="gst_bit_reader_get_bits_uint8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pos"
              c:identifier="gst_bit_reader_get_pos"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns the current position of a #GstBitReader instance in bits.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current position of @reader in bits.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_remaining"
              c:identifier="gst_bit_reader_get_remaining"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns the remaining number of bits of a #GstBitReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The remaining number of bits of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_size"
              c:identifier="gst_bit_reader_get_size"
              version="0.10.26">
        <doc xml:whitespace="preserve">Returns the total number of bits of a #GstBitReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The total number of bits of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="init" c:identifier="gst_bit_reader_init" version="0.10.22">
        <doc xml:whitespace="preserve">Initializes a #GstBitReader instance to read from @data. This function
can be called on already initialized instances.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data from which the bit reader should read</doc>
            <array length="1" c:type="guint8*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_buffer"
              c:identifier="gst_bit_reader_init_from_buffer"
              version="0.10.22">
        <doc xml:whitespace="preserve">Initializes a #GstBitReader instance to read from @buffer. This function
can be called on already initialized instances.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">Buffer from which the #GstBitReader should read</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint16"
              c:identifier="gst_bit_reader_peek_bits_uint16"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint32"
              c:identifier="gst_bit_reader_peek_bits_uint32"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint64"
              c:identifier="gst_bit_reader_peek_bits_uint64"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint8"
              c:identifier="gst_bit_reader_peek_bits_uint8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos"
              c:identifier="gst_bit_reader_set_pos"
              version="0.10.22">
        <doc xml:whitespace="preserve">Sets the new position of a #GstBitReader instance to @pos in bits.
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the position could be set successfully, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new position in bits</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip" c:identifier="gst_bit_reader_skip" version="0.10.22">
        <doc xml:whitespace="preserve">Skips @nbits bits of the #GstBitReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @nbits bits could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bits to skip</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip_to_byte"
              c:identifier="gst_bit_reader_skip_to_byte"
              version="0.10.22">
        <doc xml:whitespace="preserve">Skips until the next byte.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </record>
    <record name="ByteReader" c:type="GstByteReader">
      <doc xml:whitespace="preserve">A byte reader instance.</doc>
      <field name="data" writable="1">
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="byte" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="dup_data"
              c:identifier="gst_byte_reader_dup_data"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns a newly-allocated copy of the current data
position if at least @size bytes are left and
updates the current position. Free with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Size in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a #guint8 pointer variable in which to store the result</doc>
            <array length="0" c:type="guint8**">
              <type name="guint8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="dup_string_utf16"
              c:identifier="gst_byte_reader_dup_string_utf16"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns a newly-allocated copy of the current data position if there is
a NUL-terminated UTF-16 string in the data (this could be an empty string
as well), and advances the current position.
No input checking for valid UTF-16 is done. This function is endianness
agnostic - you should not assume the UTF-16 characters are in host
endianness.
This function will fail if no NUL-terminator was found in in the data.
byte alignment of the UTF-16 string.
string put into @str must be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be read, %FALSE otherwise. The</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a #guint16 pointer varieble in which to store the result</doc>
            <array c:type="guint16**">
              <type name="guint16"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="dup_string_utf32"
              c:identifier="gst_byte_reader_dup_string_utf32"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns a newly-allocated copy of the current data position if there is
a NUL-terminated UTF-32 string in the data (this could be an empty string
as well), and advances the current position.
No input checking for valid UTF-32 is done. This function is endianness
agnostic - you should not assume the UTF-32 characters are in host
endianness.
This function will fail if no NUL-terminator was found in in the data.
byte alignment of the UTF-32 string.
string put into @str must be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be read, %FALSE otherwise. The</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a #guint32 pointer varieble in which to store the result</doc>
            <array c:type="guint32**">
              <type name="guint32"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="dup_string_utf8"
              c:identifier="gst_byte_reader_dup_string_utf8"
              version="0.10.24">
        <doc xml:whitespace="preserve">FIXME:Reads (copies) a NUL-terminated string in the #GstByteReader instance,
advancing the current position to the byte after the string. This will work
for any NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc. No input checking for valid UTF-8 is done.
This function will fail if no NUL-terminator was found in in the data.
string put into @str must be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be read into @str, %FALSE otherwise. The</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a #gchar pointer varieble in which to store the result</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="gst_byte_reader_free"
              version="0.10.22">
        <doc xml:whitespace="preserve">Frees a #GstByteReader instance, which was previously allocated by
gst_byte_reader_new() or gst_byte_reader_new_from_buffer().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_data"
              c:identifier="gst_byte_reader_get_data"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns a constant pointer to the current data
position if at least @size bytes are left and
updates the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Size in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">address of a #guint8 pointer variable in which to store the result</doc>
            <array length="0" c:type="guint8**">
              <type name="guint8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_float32_be"
              c:identifier="gst_byte_reader_get_float32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 32 bit big endian floating point value into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float32_le"
              c:identifier="gst_byte_reader_get_float32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 32 bit little endian floating point value into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float64_be"
              c:identifier="gst_byte_reader_get_float64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 64 bit big endian floating point value into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float64_le"
              c:identifier="gst_byte_reader_get_float64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 64 bit little endian floating point value into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int16_be"
              c:identifier="gst_byte_reader_get_int16_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 16 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int16_le"
              c:identifier="gst_byte_reader_get_int16_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 16 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int24_be"
              c:identifier="gst_byte_reader_get_int24_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 24 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int24_le"
              c:identifier="gst_byte_reader_get_int24_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 24 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int32_be"
              c:identifier="gst_byte_reader_get_int32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 32 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int32_le"
              c:identifier="gst_byte_reader_get_int32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 32 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64_be"
              c:identifier="gst_byte_reader_get_int64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 64 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64_le"
              c:identifier="gst_byte_reader_get_int64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 64 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int8"
              c:identifier="gst_byte_reader_get_int8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 8 bit integer into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint8 to store the result</doc>
            <type name="gint8" c:type="gint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pos"
              c:identifier="gst_byte_reader_get_pos"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns the current position of a #GstByteReader instance in bytes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current position of @reader in bytes.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_remaining"
              c:identifier="gst_byte_reader_get_remaining"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns the remaining number of bytes of a #GstByteReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The remaining number of bytes of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_size"
              c:identifier="gst_byte_reader_get_size"
              version="0.10.26">
        <doc xml:whitespace="preserve">Returns the total number of bytes of a #GstByteReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The total number of bytes of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_string_utf8"
              c:identifier="gst_byte_reader_get_string_utf8"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns a constant pointer to the current data position if there is
a NUL-terminated string in the data (this could be just a NUL terminator),
advancing the current position to the byte after the string. This will work
for any NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc.
No input checking for valid UTF-8 is done.
This function will fail if no NUL-terminator was found in in the data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be found, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">address of a #gchar pointer varieble in which to store the result</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint16_be"
              c:identifier="gst_byte_reader_get_uint16_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 16 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint16_le"
              c:identifier="gst_byte_reader_get_uint16_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 16 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint24_be"
              c:identifier="gst_byte_reader_get_uint24_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 24 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint24_le"
              c:identifier="gst_byte_reader_get_uint24_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 24 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint32_be"
              c:identifier="gst_byte_reader_get_uint32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 32 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint32_le"
              c:identifier="gst_byte_reader_get_uint32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 32 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64_be"
              c:identifier="gst_byte_reader_get_uint64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 64 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64_le"
              c:identifier="gst_byte_reader_get_uint64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 64 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint8"
              c:identifier="gst_byte_reader_get_uint8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 8 bit integer into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init"
              c:identifier="gst_byte_reader_init"
              version="0.10.22">
        <doc xml:whitespace="preserve">Initializes a #GstByteReader instance to read from @data. This function
can be called on already initialized instances.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data from which the #GstByteReader should read</doc>
            <array length="1" c:type="guint8*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_buffer"
              c:identifier="gst_byte_reader_init_from_buffer"
              version="0.10.22">
        <doc xml:whitespace="preserve">Initializes a #GstByteReader instance to read from @buffer. This function
can be called on already initialized instances.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">Buffer from which the #GstByteReader should read</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="masked_scan_uint32"
              c:identifier="gst_byte_reader_masked_scan_uint32"
              version="0.10.24">
        <doc xml:whitespace="preserve">Scan for pattern @pattern with applied mask @mask in the byte reader data,
starting from offset @offset relative to the current position.
The bytes in @pattern and @mask are interpreted left-to-right, regardless
of endianness.  All four bytes of the pattern must be present in the
byte reader data for it to match, even if the first or last bytes are masked
out.
It is an error to call this function without making sure that there is
enough data (offset+size bytes) in the byte reader.
Example:
&lt;programlisting&gt;
// Assume the reader contains 0x00 0x01 0x02 ... 0xfe 0xff
gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x00010203, 0, 256);
// -&gt; returns 0
gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x00010203, 1, 255);
// -&gt; returns -1
gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x01020304, 1, 255);
// -&gt; returns 1
gst_byte_reader_masked_scan_uint32 (reader, 0xffff, 0x0001, 0, 256);
// -&gt; returns -1
gst_byte_reader_masked_scan_uint32 (reader, 0xffff, 0x0203, 0, 256);
// -&gt; returns 0
gst_byte_reader_masked_scan_uint32 (reader, 0xffff0000, 0x02030000, 0, 256);
// -&gt; returns 2
gst_byte_reader_masked_scan_uint32 (reader, 0xffff0000, 0x02030000, 0, 4);
// -&gt; returns -1
&lt;/programlisting&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">offset of the first match, or -1 if no match was found.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:whitespace="preserve">mask to apply to data before matching against @pattern</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:whitespace="preserve">pattern to match (after mask is applied)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">offset from which to start scanning, relative to the current position</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bytes to scan from offset</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_data"
              c:identifier="gst_byte_reader_peek_data"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns a constant pointer to the current data
position if at least @size bytes are left and
keeps the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Size in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">address of a #guint8 pointer variable in which to store the result</doc>
            <array length="0" c:type="guint8**">
              <type name="guint8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float32_be"
              c:identifier="gst_byte_reader_peek_float32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 32 bit big endian floating point value into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float32_le"
              c:identifier="gst_byte_reader_peek_float32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 32 bit little endian floating point value into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float64_be"
              c:identifier="gst_byte_reader_peek_float64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 64 bit big endian floating point value into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float64_le"
              c:identifier="gst_byte_reader_peek_float64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 64 bit little endian floating point value into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int16_be"
              c:identifier="gst_byte_reader_peek_int16_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 16 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int16_le"
              c:identifier="gst_byte_reader_peek_int16_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 16 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int24_be"
              c:identifier="gst_byte_reader_peek_int24_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 24 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int24_le"
              c:identifier="gst_byte_reader_peek_int24_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 24 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int32_be"
              c:identifier="gst_byte_reader_peek_int32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 32 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int32_le"
              c:identifier="gst_byte_reader_peek_int32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 32 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int64_be"
              c:identifier="gst_byte_reader_peek_int64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 64 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int64_le"
              c:identifier="gst_byte_reader_peek_int64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 64 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int8"
              c:identifier="gst_byte_reader_peek_int8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 8 bit integer into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint8 to store the result</doc>
            <type name="gint8" c:type="gint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_string_utf8"
              c:identifier="gst_byte_reader_peek_string_utf8"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns a constant pointer to the current data position if there is
a NUL-terminated string in the data (this could be just a NUL terminator).
The current position will be maintained. This will work for any
NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc.
No input checking for valid UTF-8 is done.
This function will fail if no NUL-terminator was found in in the data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">address of a #gchar pointer varieble in which to store the result</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint16_be"
              c:identifier="gst_byte_reader_peek_uint16_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 16 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint16_le"
              c:identifier="gst_byte_reader_peek_uint16_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 16 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint24_be"
              c:identifier="gst_byte_reader_peek_uint24_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 24 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint24_le"
              c:identifier="gst_byte_reader_peek_uint24_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 24 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint32_be"
              c:identifier="gst_byte_reader_peek_uint32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 32 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint32_le"
              c:identifier="gst_byte_reader_peek_uint32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 32 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint64_be"
              c:identifier="gst_byte_reader_peek_uint64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 64 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint64_le"
              c:identifier="gst_byte_reader_peek_uint64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 64 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint8"
              c:identifier="gst_byte_reader_peek_uint8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 8 bit integer into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos"
              c:identifier="gst_byte_reader_set_pos"
              version="0.10.22">
        <doc xml:whitespace="preserve">Sets the new position of a #GstByteReader instance to @pos in bytes.
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the position could be set successfully, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new position in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip"
              c:identifier="gst_byte_reader_skip"
              version="0.10.22">
        <doc xml:whitespace="preserve">Skips @nbytes bytes of the #GstByteReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @nbytes bytes could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to skip</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip_string_utf16"
              c:identifier="gst_byte_reader_skip_string_utf16"
              version="0.10.24">
        <doc xml:whitespace="preserve">Skips a NUL-terminated UTF-16 string in the #GstByteReader instance,
advancing the current position to the byte after the string.
No input checking for valid UTF-16 is done.
This function will fail if no NUL-terminator was found in in the data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="skip_string_utf32"
              c:identifier="gst_byte_reader_skip_string_utf32"
              version="0.10.24">
        <doc xml:whitespace="preserve">Skips a NUL-terminated UTF-32 string in the #GstByteReader instance,
advancing the current position to the byte after the string.
No input checking for valid UTF-32 is done.
This function will fail if no NUL-terminator was found in in the data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="skip_string_utf8"
              c:identifier="gst_byte_reader_skip_string_utf8"
              version="0.10.24">
        <doc xml:whitespace="preserve">Skips a NUL-terminated string in the #GstByteReader instance, advancing
the current position to the byte after the string. This will work for
any NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc. No input checking for valid UTF-8 is done.
This function will fail if no NUL-terminator was found in in the data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </record>
    <record name="ByteWriter" c:type="GstByteWriter">
      <doc xml:whitespace="preserve">A byte writer instance.</doc>
      <field name="parent" writable="1">
        <type name="ByteReader" c:type="GstByteReader"/>
      </field>
      <field name="alloc_size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="fixed" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="owned" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <method name="ensure_free_space"
              c:identifier="gst_byte_writer_ensure_free_space"
              version="0.10.26">
        <doc xml:whitespace="preserve">Checks if enough free space from the current write cursor is
available and reallocates if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if at least @size bytes are still available</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Number of bytes that should be available</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="fill"
              c:identifier="gst_byte_writer_fill"
              version="0.10.27">
        <doc xml:whitespace="preserve">Writes @size bytes containing @value to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to be writen</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Number of bytes to be writen</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="gst_byte_writer_free"
              version="0.10.26">
        <doc xml:whitespace="preserve">Frees @writer and all memory allocated by it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="free_and_get_buffer"
              c:identifier="gst_byte_writer_free_and_get_buffer"
              version="0.10.26">
        <doc xml:whitespace="preserve">Frees @writer and all memory allocated by it except
the current data, which is returned as #GstBuffer.
after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current data as buffer. gst_buffer_unref()</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="free_and_get_data"
              c:identifier="gst_byte_writer_free_and_get_data"
              version="0.10.26">
        <doc xml:whitespace="preserve">Frees @writer and all memory allocated by it except
the current data, which is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current data. g_free() after usage.</doc>
          <type name="guint8" c:type="guint8*"/>
        </return-value>
      </method>
      <method name="get_remaining"
              c:identifier="gst_byte_writer_get_remaining"
              version="0.10.26">
        <doc xml:whitespace="preserve">Returns the remaining size of data that can still be written. If
-1 is returned the remaining size is only limited by system resources.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the remaining size of data that can still be written</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="init"
              c:identifier="gst_byte_writer_init"
              version="0.10.26">
        <doc xml:whitespace="preserve">Initializes @writer to an empty instance</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="init_with_buffer"
              c:identifier="gst_byte_writer_init_with_buffer"
              version="0.10.26">
        <doc xml:whitespace="preserve">Initializes @writer with the given
buffer. If @initialized is %TRUE it is possible to
read the complete buffer from the #GstByteWriter from the beginning.
&lt;note&gt;@buffer must be writable&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">Buffer used for writing</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="initialized" transfer-ownership="none">
            <doc xml:whitespace="preserve">If %TRUE the complete data can be read from the beginning</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_with_data"
              c:identifier="gst_byte_writer_init_with_data"
              version="0.10.26">
        <doc xml:whitespace="preserve">Initializes @writer with the given
memory area. If @initialized is %TRUE it is possible to
read @size bytes from the #GstByteWriter from the beginning.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Memory area for writing</doc>
            <array length="1" c:type="guint8*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="initialized" transfer-ownership="none">
            <doc xml:whitespace="preserve">If %TRUE the complete data can be read from the beginning</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_with_size"
              c:identifier="gst_byte_writer_init_with_size"
              version="0.10.26">
        <doc xml:whitespace="preserve">Initializes @writer with the given initial data size.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Initial size of data</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="fixed" transfer-ownership="none">
            <doc xml:whitespace="preserve">If %TRUE the data can't be reallocated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_data"
              c:identifier="gst_byte_writer_put_data"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes @size bytes of @data to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to write</doc>
            <array length="1" c:type="guint8*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float32_be"
              c:identifier="gst_byte_writer_put_float32_be"
              version="0.10.27">
        <doc xml:whitespace="preserve">Writes a big endian 32 bit float to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float32_le"
              c:identifier="gst_byte_writer_put_float32_le"
              version="0.10.27">
        <doc xml:whitespace="preserve">Writes a little endian 32 bit float to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float64_be"
              c:identifier="gst_byte_writer_put_float64_be"
              version="0.10.27">
        <doc xml:whitespace="preserve">Writes a big endian 64 bit float to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float64_le"
              c:identifier="gst_byte_writer_put_float64_le"
              version="0.10.27">
        <doc xml:whitespace="preserve">Writes a little endian 64 bit float to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int16_be"
              c:identifier="gst_byte_writer_put_int16_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed big endian 16 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint16" c:type="gint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int16_le"
              c:identifier="gst_byte_writer_put_int16_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed little endian 16 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint16" c:type="gint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int24_be"
              c:identifier="gst_byte_writer_put_int24_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed big endian 24 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int24_le"
              c:identifier="gst_byte_writer_put_int24_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed little endian 24 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int32_be"
              c:identifier="gst_byte_writer_put_int32_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed big endian 32 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int32_le"
              c:identifier="gst_byte_writer_put_int32_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed little endian 32 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int64_be"
              c:identifier="gst_byte_writer_put_int64_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed big endian 64 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int64_le"
              c:identifier="gst_byte_writer_put_int64_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed little endian 64 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int8"
              c:identifier="gst_byte_writer_put_int8"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed 8 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint8" c:type="gint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_string_utf16"
              c:identifier="gst_byte_writer_put_string_utf16"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a NUL-terminated UTF16 string to @writer (including the terminator).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">UTF16 string to write</doc>
            <array c:type="guint16*">
              <type name="guint16"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="put_string_utf32"
              c:identifier="gst_byte_writer_put_string_utf32"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a NUL-terminated UTF32 string to @writer (including the terminator).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">UTF32 string to write</doc>
            <array c:type="guint32*">
              <type name="guint32"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="put_string_utf8"
              c:identifier="gst_byte_writer_put_string_utf8"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a NUL-terminated UTF8 string to @writer (including the terminator).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">UTF8 string to write</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint16_be"
              c:identifier="gst_byte_writer_put_uint16_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned big endian 16 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint16_le"
              c:identifier="gst_byte_writer_put_uint16_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned little endian 16 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint24_be"
              c:identifier="gst_byte_writer_put_uint24_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned big endian 24 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint24_le"
              c:identifier="gst_byte_writer_put_uint24_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned little endian 24 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint32_be"
              c:identifier="gst_byte_writer_put_uint32_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned big endian 32 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint32_le"
              c:identifier="gst_byte_writer_put_uint32_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned little endian 32 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint64_be"
              c:identifier="gst_byte_writer_put_uint64_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned big endian 64 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint64_le"
              c:identifier="gst_byte_writer_put_uint64_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned little endian 64 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint8"
              c:identifier="gst_byte_writer_put_uint8"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned 8 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset"
              c:identifier="gst_byte_writer_reset"
              version="0.10.26">
        <doc xml:whitespace="preserve">Resets @writer and frees the data if it's
owned by @writer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="reset_and_get_buffer"
              c:identifier="gst_byte_writer_reset_and_get_buffer"
              version="0.10.26">
        <doc xml:whitespace="preserve">Resets @writer and returns the current data as buffer.
after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current data as buffer. gst_buffer_unref()</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="reset_and_get_data"
              c:identifier="gst_byte_writer_reset_and_get_data"
              version="0.10.26">
        <doc xml:whitespace="preserve">Resets @writer and returns the current data.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current data. g_free() after usage.</doc>
          <type name="guint8" c:type="guint8*"/>
        </return-value>
      </method>
    </record>
    <record name="CollectData" c:type="GstCollectData">
      <doc xml:whitespace="preserve">Structure used by the collect_pads.</doc>
      <field name="collect" writable="1">
        <type name="CollectPads" c:type="GstCollectPads*"/>
      </field>
      <field name="pad" writable="1">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="buffer" writable="1">
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="pos" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="segment" writable="1">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="flushing" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="new_segment" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="eos" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="refcount" writable="1">
            <type name="gint" c:type="gint"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="4">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
    </record>
    <callback name="CollectDataDestroyNotify"
              c:type="GstCollectDataDestroyNotify"
              version="0.10.12">
      <doc xml:whitespace="preserve">A function that will be called when the #GstCollectData will be freed.
It is passed the pointer to the structure and should free any custom
memory and resources allocated for it.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstCollectData that will be freed</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="CollectPads"
           c:symbol-prefix="collect_pads"
           c:type="GstCollectPads"
           parent="Gst.Object"
           glib:type-name="GstCollectPads"
           glib:get-type="gst_collect_pads_get_type"
           glib:type-struct="CollectPadsClass">
      <doc xml:whitespace="preserve">Collectpads object.
Note that @data is only reliable for iterating the list of #GstCollectData
when inside the #GstCollectPadsFunction callback.</doc>
      <constructor name="new" c:identifier="gst_collect_pads_new">
        <doc xml:whitespace="preserve">Create a new instance of #GstCollectPads.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstCollectPads, or NULL in case of an error.</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </return-value>
      </constructor>
      <method name="add_pad"
              c:identifier="gst_collect_pads_add_pad"
              introspectable="0">
        <doc xml:whitespace="preserve">Add a pad to the collection of collect pads. The pad has to be
a sinkpad. The refcount of the pad is incremented. Use
gst_collect_pads_remove_pad() to remove the pad from the collection
again.
This function will override the chain and event functions of the pad
along with the element_private data, which is used to store private
information for the collectpads.
You specify a size for the returned #GstCollectData structure
so that you can use it to store additional information.
The pad will be automatically activated in push mode when @pads is
started.
This function calls gst_collect_pads_add_pad_full() passing a value of NULL
for destroy_notify.
if wrong parameters are supplied.
MT safe.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #GstCollectData to identify the new pad. Or NULL</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to add</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the returned #GstCollectData structure</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_pad_full"
              c:identifier="gst_collect_pads_add_pad_full"
              version="0.10.12"
              introspectable="0">
        <doc xml:whitespace="preserve">Add a pad to the collection of collect pads. The pad has to be
a sinkpad. The refcount of the pad is incremented. Use
gst_collect_pads_remove_pad() to remove the pad from the collection
again.
You specify a size for the returned #GstCollectData structure
so that you can use it to store additional information.
You can also specify a #GstCollectDataDestroyNotify that will be called
just before the #GstCollectData structure is freed. It is passed the
pointer to the structure and should free any custom memory and resources
allocated for it.
The pad will be automatically activated in push mode when @pads is
started.
if wrong parameters are supplied.
MT safe.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #GstCollectData to identify the new pad. Or NULL</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to add</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the returned #GstCollectData structure</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="destroy_notify" transfer-ownership="none">
            <doc xml:whitespace="preserve">function to be called before the returned #GstCollectData structure is freed</doc>
            <type name="CollectDataDestroyNotify"
                  c:type="GstCollectDataDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="available" c:identifier="gst_collect_pads_available">
        <doc xml:whitespace="preserve">Query how much bytes can be read from each queued buffer. This means
that the result of this call is the maximum number of bytes that can
be read from each of the pads.
This function should be called with @pads LOCK held, such as
in the callback.
returns 0 if a pad has no queued buffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The maximum number of bytes queued on all pads. This function</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="collect" c:identifier="gst_collect_pads_collect">
        <doc xml:whitespace="preserve">Collect data on all pads. This function is usually called
from a #GstTask function in an element. 
This function is currently not implemented.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstFlowReturn of the operation.</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
      </method>
      <method name="collect_range"
              c:identifier="gst_collect_pads_collect_range">
        <doc xml:whitespace="preserve">Collect data with @offset and @length on all pads. This function
is typically called in the getrange function of an element. 
This function is currently not implemented.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstFlowReturn of the operation.</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset to collect</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length to collect</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="gst_collect_pads_flush">
        <doc xml:whitespace="preserve">Flush @size bytes from the pad @data.
This function should be called with @pads LOCK held, such as
in the callback.
is 0 if the pad was end-of-stream.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of bytes flushed. This can be less than @size and</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to flush</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_active" c:identifier="gst_collect_pads_is_active">
        <doc xml:whitespace="preserve">Check if a pad is active.
This function is currently not implemented.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the pad is active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to check</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="gst_collect_pads_peek">
        <doc xml:whitespace="preserve">Peek at the buffer currently queued in @data. This function
should be called with the @pads LOCK held, such as in the callback
handler.
should unref the buffer after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The buffer in @data or NULL if no buffer is queued.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="gst_collect_pads_pop">
        <doc xml:whitespace="preserve">Pop the buffer currently queued in @data. This function
should be called with the @pads LOCK held, such as in the callback
handler.
queued. You should unref the buffer after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The buffer in @data or NULL if no buffer was</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="gst_collect_pads_read">
        <doc xml:whitespace="preserve">Get a pointer in @bytes where @size bytes can be read from the
given pad @data.
This function should be called with @pads LOCK held, such as
in the callback.
memory pointed to by @bytes. This can be less than @size and
is 0 if the pad is end-of-stream.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of bytes available for consumption in the</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="bytes"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a byte array</doc>
            <array length="2" c:type="guint8**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the number of bytes to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_buffer"
              c:identifier="gst_collect_pads_read_buffer"
              version="0.10.18">
        <doc xml:whitespace="preserve">Get a buffer of @size bytes from the given pad @data.
This function should be called with @pads LOCK held, such as in the callback.
that requested. A return of NULL signals that the pad is end-of-stream.
Unref the buffer with gst_buffer_unref() after use.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstBuffer. The size of the buffer can be less</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_pad" c:identifier="gst_collect_pads_remove_pad">
        <doc xml:whitespace="preserve">Remove a pad from the collection of collect pads. This function will also
free the #GstCollectData and all the resources that were allocated with 
gst_collect_pads_add_pad().
The pad will be deactivated automatically when @pads is stopped.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the pad could be removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to remove</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_clip_function"
              c:identifier="gst_collect_pads_set_clip_function"
              version="0.10.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Install a clipping function that is called right after a buffer is received
on a pad managed by @pads. See #GstCollectDataClipFunction for more info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clipfunc" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">clip function to install</doc>
            <type name="CollectPadsClipFunction"
                  c:type="GstCollectPadsClipFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @clip_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing"
              c:identifier="gst_collect_pads_set_flushing"
              version="0.10.7.">
        <doc xml:whitespace="preserve">Change the flushing state of all the pads in the collection. No pad
is able to accept anymore data when @flushing is %TRUE. Calling this
function with @flushing %FALSE makes @pads accept data again.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:whitespace="preserve">desired state of the pads</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_function"
              c:identifier="gst_collect_pads_set_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Set the callback function and user data that will be called when
all the pads added to the collection have buffers queued.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the function to set</doc>
            <type name="CollectPadsFunction" c:type="GstCollectPadsFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="gst_collect_pads_start">
        <doc xml:whitespace="preserve">Starts the processing of data in the collect_pads.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="stop" c:identifier="gst_collect_pads_stop">
        <doc xml:whitespace="preserve">Stops the processing of data in the collect_pads. this function
will also unblock any blocking operations.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="take_buffer"
              c:identifier="gst_collect_pads_take_buffer"
              version="0.10.18">
        <doc xml:whitespace="preserve">Get a buffer of @size bytes from the given pad @data. Flushes the amount
of read bytes.
This function should be called with @pads LOCK held, such as in the callback.
that requested. A return of NULL signals that the pad is end-of-stream.
Unref the buffer after use.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstBuffer. The size of the buffer can be less</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="data">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="cookie">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="cond">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="func">
        <type name="CollectPadsFunction" c:type="GstCollectPadsFunction"/>
      </field>
      <field name="user_data">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="numpads">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="queuedpads">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="eospads">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="started">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="pad_lock" writable="1">
            <type name="GLib.Mutex" c:type="GMutex*"/>
          </field>
          <field name="pad_list" writable="1">
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </field>
          <field name="pad_cookie" writable="1">
            <type name="guint32" c:type="guint32"/>
          </field>
          <field name="priv" writable="1">
            <type name="CollectPadsPrivate" c:type="GstCollectPadsPrivate*"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="4">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
    </class>
    <record name="CollectPadsClass"
            c:type="GstCollectPadsClass"
            glib:is-gtype-struct-for="CollectPads">
      <field name="parent_class">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="CollectPadsClipFunction"
              c:type="GstCollectPadsClipFunction"
              version="0.10.26"
              introspectable="0">
      <doc xml:whitespace="preserve">A function that will be called when @buffer is received on the pad managed
by @data in the collecpad object @pads.
The function should use the segment of @data and the negotiated media type on
the pad to perform clipping of @buffer. 
This function takes ownership of @buffer.
the buffer has been clipped completely.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a #GstBuffer that contains the clipped data of @buffer or NULL when</doc>
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="pads" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstCollectPads</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstCollectData</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CollectPadsFunction" c:type="GstCollectPadsFunction">
      <doc xml:whitespace="preserve">A function that will be called when all pads have received data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GST_FLOW_OK for success</doc>
        <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pads" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstCollectPads that triggered the callback</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">user data passed to gst_collect_pads_set_function()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="CollectPadsPrivate"
            c:type="GstCollectPadsPrivate"
            disguised="1">
    </record>
    <class name="DataQueue"
           c:symbol-prefix="data_queue"
           c:type="GstDataQueue"
           version="0.10.11"
           parent="GObject.Object"
           glib:type-name="GstDataQueue"
           glib:get-type="gst_data_queue_get_type"
           glib:type-struct="DataQueueClass">
      <doc xml:whitespace="preserve">Opaque #GstDataQueue structure.</doc>
      <constructor name="new"
                   c:identifier="gst_data_queue_new"
                   introspectable="0">
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstDataQueue.</doc>
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </return-value>
        <parameters>
          <parameter name="checkfull" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the callback used to tell if the element considers the queue full or not.</doc>
            <type name="DataQueueCheckFullFunction"
                  c:type="GstDataQueueCheckFullFunction"/>
          </parameter>
          <parameter name="checkdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gpointer that will be given in the @checkfull callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full"
                   c:identifier="gst_data_queue_new_full"
                   version="0.10.26"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstDataQueue. The difference with @gst_data_queue_new is that it will
not emit the 'full' and 'empty' signals, but instead calling directly @fullcallback
or @emptycallback.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstDataQueue.</doc>
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </return-value>
        <parameters>
          <parameter name="checkfull" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback used to tell if the element considers the queue full or not.</doc>
            <type name="DataQueueCheckFullFunction"
                  c:type="GstDataQueueCheckFullFunction"/>
          </parameter>
          <parameter name="fullcallback" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback which will be called when the queue is considered full.</doc>
            <type name="DataQueueFullCallback"
                  c:type="GstDataQueueFullCallback"/>
          </parameter>
          <parameter name="emptycallback"
                     transfer-ownership="none"
                     closure="3">
            <doc xml:whitespace="preserve">the callback which will be called when the queue is considered empty.</doc>
            <type name="DataQueueEmptyCallback"
                  c:type="GstDataQueueEmptyCallback"/>
          </parameter>
          <parameter name="checkdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gpointer that will be given in the @checkfull callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="drop_head"
              c:identifier="gst_data_queue_drop_head"
              version="0.10.11">
        <doc xml:whitespace="preserve">Pop and unref the head-most #GstMiniObject with the given #GType.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if an element was removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GType of the item to drop.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush"
              c:identifier="gst_data_queue_flush"
              version="0.10.11">
        <doc xml:whitespace="preserve">Flushes all the contents of the @queue. Any call to #gst_data_queue_push and
#gst_data_queue_pop will be released.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_level"
              c:identifier="gst_data_queue_get_level"
              version="0.10.11">
        <doc xml:whitespace="preserve">Get the current level of the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="level" transfer-ownership="none">
            <doc xml:whitespace="preserve">the location to store the result</doc>
            <type name="DataQueueSize" c:type="GstDataQueueSize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="gst_data_queue_is_empty"
              version="0.10.11">
        <doc xml:whitespace="preserve">Queries if there are any items in the @queue.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if @queue is empty.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_full"
              c:identifier="gst_data_queue_is_full"
              version="0.10.11">
        <doc xml:whitespace="preserve">Queries if @queue is full. This check will be done using the
#GstDataQueueCheckFullFunction registered with @queue.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if @queue is full.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="limits_changed"
              c:identifier="gst_data_queue_limits_changed"
              version="0.10.11">
        <doc xml:whitespace="preserve">Inform the queue that the limits for the fullness check have changed and that
any blocking gst_data_queue_push() should be unblocked to recheck the limts.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="pop" c:identifier="gst_data_queue_pop" version="0.10.11">
        <doc xml:whitespace="preserve">Retrieves the first @item available on the @queue. If the queue is currently
empty, the call will block until at least one item is available, OR the
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if an @item was successfully retrieved from the @queue.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="item" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to store the returned #GstDataQueueItem.</doc>
            <type name="DataQueueItem" c:type="GstDataQueueItem**"/>
          </parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="gst_data_queue_push" version="0.10.11">
        <doc xml:whitespace="preserve">Pushes a #GstDataQueueItem (or a structure that begins with the same fields)
on the @queue. If the @queue is full, the call will block until space is
available, OR the @queue is set to flushing state.
MT safe.
Note that this function has slightly different semantics than gst_pad_push()
the #GstMiniObject contained in @item if the push was successful. If FALSE
is returned, the caller is responsible for freeing @item and its contents.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if the @item was successfully pushed on the @queue.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="item" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstDataQueueItem.</doc>
            <type name="DataQueueItem" c:type="GstDataQueueItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing"
              c:identifier="gst_data_queue_set_flushing"
              version="0.10.11">
        <doc xml:whitespace="preserve">Sets the queue to flushing state if @flushing is #TRUE. If set to flushing
state, any incoming data on the @queue will be discarded. Any call currently
blocking on #gst_data_queue_push or #gst_data_queue_pop will return straight
away with a return value of #FALSE. While the @queue is in flushing state, 
all calls to those two functions will return #FALSE.
MT Safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gboolean stating if the queue will be flushing or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="current-level-bytes" transfer-ownership="none">
        <type name="guint"/>
      </property>
      <property name="current-level-time" transfer-ownership="none">
        <type name="guint64"/>
      </property>
      <property name="current-level-visible" transfer-ownership="none">
        <type name="guint"/>
      </property>
      <field name="object">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="queue">
        <type name="GLib.Queue" c:type="GQueue*"/>
      </field>
      <field name="cur_level">
        <type name="DataQueueSize" c:type="GstDataQueueSize"/>
      </field>
      <field name="checkfull">
        <type name="DataQueueCheckFullFunction"
              c:type="GstDataQueueCheckFullFunction"/>
      </field>
      <field name="checkdata">
        <type name="gpointer" c:type="gpointer*"/>
      </field>
      <field name="qlock">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="item_add">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="item_del">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="flushing">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="fullcallback">
        <type name="DataQueueFullCallback" c:type="GstDataQueueFullCallback"/>
      </field>
      <field name="emptycallback">
        <type name="DataQueueEmptyCallback"
              c:type="GstDataQueueEmptyCallback"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="waiting_add" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="waiting_del" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="2">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
      <glib:signal name="empty">
        <doc xml:whitespace="preserve">Reports that the queue became empty (empty).
A queue is empty if the total amount of visible items inside it (num-visible, time,
size) is lower than the boundary values which can be set through the GObject
properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="full">
        <doc xml:whitespace="preserve">Reports that the queue became full (full).
A queue is full if the total amount of data inside it (num-visible, time,
size) is higher than the boundary values which can be set through the GObject
properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </class>
    <callback name="DataQueueCheckFullFunction"
              c:type="GstDataQueueCheckFullFunction"
              version="0.10.11">
      <doc xml:whitespace="preserve">The prototype of the function used to inform the queue that it should be
considered as full.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#TRUE if the queue should be considered full.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="queue" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstDataQueue.</doc>
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </parameter>
        <parameter name="visible" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of visible items currently in the queue.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:whitespace="preserve">The amount of bytes currently in the queue.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="time" transfer-ownership="none">
          <doc xml:whitespace="preserve">The accumulated duration of the items currently in the queue.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="checkdata" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #gpointer registered when the #GstDataQueue was created.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DataQueueClass"
            c:type="GstDataQueueClass"
            glib:is-gtype-struct-for="DataQueue">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="empty">
        <callback name="empty">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="queue" transfer-ownership="none">
              <type name="DataQueue" c:type="GstDataQueue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="full">
        <callback name="full">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="queue" transfer-ownership="none">
              <type name="DataQueue" c:type="GstDataQueue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="DataQueueEmptyCallback" c:type="GstDataQueueEmptyCallback">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="queue" transfer-ownership="none">
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </parameter>
        <parameter name="checkdata" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DataQueueFullCallback" c:type="GstDataQueueFullCallback">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="queue" transfer-ownership="none">
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </parameter>
        <parameter name="checkdata" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DataQueueItem" c:type="GstDataQueueItem" version="0.10.11">
      <doc xml:whitespace="preserve">Structure used by #GstDataQueue. You can supply a different structure, as
long as the top of the structure is identical to this structure.</doc>
      <field name="object" writable="1">
        <type name="Gst.MiniObject" c:type="GstMiniObject*"/>
      </field>
      <field name="size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="duration" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="visible" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="destroy" writable="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
    </record>
    <record name="DataQueueSize" c:type="GstDataQueueSize" version="0.10.11">
      <doc xml:whitespace="preserve">Structure describing the size of a queue.</doc>
      <field name="visible" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="bytes" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="time" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
    </record>
    <class name="PushSrc"
           c:symbol-prefix="push_src"
           c:type="GstPushSrc"
           parent="BaseSrc"
           glib:type-name="GstPushSrc"
           glib:get-type="gst_push_src_get_type"
           glib:type-struct="PushSrcClass">
      <doc xml:whitespace="preserve">The opaque #GstPushSrc data structure.</doc>
      <virtual-method name="create">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="parent">
        <type name="BaseSrc" c:type="GstBaseSrc"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="PushSrcClass"
            c:type="GstPushSrcClass"
            glib:is-gtype-struct-for="PushSrc">
      <field name="parent_class">
        <type name="BaseSrcClass" c:type="GstBaseSrcClass"/>
      </field>
      <field name="create">
        <callback name="create">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="PushSrc" c:type="GstPushSrc*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="TypeFindHelperGetRangeFunction"
              c:type="GstTypeFindHelperGetRangeFunction">
      <doc xml:whitespace="preserve">This function will be called by gst_type_find_helper_get_range() when
typefinding functions request to peek at the data of a stream at certain
offsets. If this function returns GST_FLOW_OK, the result buffer will be
stored in @buffer. The  contents of @buffer is invalid for any other
return value.
This function is supposed to behave exactly like a #GstPadGetRangeFunction.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">GST_FLOW_OK for success</doc>
        <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstObject that will handle the getrange request</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset of the range</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of the range</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a memory location to hold the result buffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer**"/>
        </parameter>
      </parameters>
    </callback>
    <function name="bit_reader_new"
              c:identifier="gst_bit_reader_new"
              version="0.10.22"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new #GstBitReader instance, which will read from @data.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstBitReader instance</doc>
        <type name="BitReader" c:type="GstBitReader*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Data from which the #GstBitReader should read</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of @data in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_reader_new_from_buffer"
              c:identifier="gst_bit_reader_new_from_buffer"
              version="0.10.22"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new #GstBitReader instance, which will read from the
#GstBuffer @buffer.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstBitReader instance</doc>
        <type name="BitReader" c:type="GstBitReader*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">Buffer from which the #GstBitReader should read</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_reader_new"
              c:identifier="gst_byte_reader_new"
              version="0.10.22"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new #GstByteReader instance, which will read from @data.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstByteReader instance</doc>
        <type name="ByteReader" c:type="GstByteReader*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data from which the #GstByteReader should read</doc>
          <array length="1" c:type="guint8*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of @data in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_reader_new_from_buffer"
              c:identifier="gst_byte_reader_new_from_buffer"
              version="0.10.22"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new #GstByteReader instance, which will read from the
#GstBuffer @buffer.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstByteReader instance</doc>
        <type name="ByteReader" c:type="GstByteReader*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">Buffer from which the #GstByteReader should read</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_writer_new"
              c:identifier="gst_byte_writer_new"
              version="0.10.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new, empty #GstByteWriter instance</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new, empty #GstByteWriter instance</doc>
        <type name="ByteWriter" c:type="GstByteWriter*"/>
      </return-value>
    </function>
    <function name="byte_writer_new_with_buffer"
              c:identifier="gst_byte_writer_new_with_buffer"
              version="0.10.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GstByteWriter instance with the given
buffer. If @initialized is %TRUE it is possible to
read the complete buffer from the #GstByteWriter from the beginning.
&lt;note&gt;@buffer must be writable&lt;/note&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstByteWriter instance</doc>
        <type name="ByteWriter" c:type="GstByteWriter*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">Buffer used for writing</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="initialized" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE the complete data can be read from the beginning</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_writer_new_with_data"
              c:identifier="gst_byte_writer_new_with_data"
              version="0.10.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GstByteWriter instance with the given
memory area. If @initialized is %TRUE it is possible to
read @size bytes from the #GstByteWriter from the beginning.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstByteWriter instance</doc>
        <type name="ByteWriter" c:type="GstByteWriter*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Memory area for writing</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of @data in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="initialized" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE the complete data can be read from the beginning</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_writer_new_with_size"
              c:identifier="gst_byte_writer_new_with_size"
              version="0.10.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GstByteWriter instance with the given
initial data size.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstByteWriter instance</doc>
        <type name="ByteWriter" c:type="GstByteWriter*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Initial size of data</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="fixed" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE the data can't be reallocated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper" c:identifier="gst_type_find_helper">
      <doc xml:whitespace="preserve">Tries to find what type of data is flowing from the given source #GstPad.
Returns #NULL if no #GstCaps matches the data stream.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the #GstCaps corresponding to the data stream.</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">A source #GstPad</doc>
          <type name="Gst.Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">The length in bytes</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_for_buffer"
              c:identifier="gst_type_find_helper_for_buffer">
      <doc xml:whitespace="preserve">Tries to find what type of data is contained in the given #GstBuffer, the
assumption being that the buffer represents the beginning of the stream or
file.
All available typefinders will be called on the data in order of rank. If
a typefinding function returns a probability of #GST_TYPE_FIND_MAXIMUM,
typefinding is stopped immediately and the found caps will be returned
right away. Otherwise, all available typefind functions will the tried,
and the caps with the highest probability will be returned, or #NULL if
the content of the buffer could not be identified.
if no type could be found. The caller should free the caps returned
with gst_caps_unref().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the #GstCaps corresponding to the data, or #NULL</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">object doing the typefinding, or NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstBuffer with data to typefind</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">location to store the probability of the found caps, or #NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_for_extension"
              c:identifier="gst_type_find_helper_for_extension"
              version="0.10.23">
      <doc xml:whitespace="preserve">Tries to find the best #GstCaps associated with @extension.
All available typefinders will be checked against the extension in order
of rank. The caps of the first typefinder that can handle @extension will be
returned.
#NULL if no type could be found. The caller should free the caps
returned with gst_caps_unref().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the #GstCaps corresponding to @extension, or</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">object doing the typefinding, or NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="extension" transfer-ownership="none">
          <doc xml:whitespace="preserve">an extension</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_get_range"
              c:identifier="gst_type_find_helper_get_range">
      <doc xml:whitespace="preserve">Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
however, this function will use the specified function @func to obtain the
data needed by the typefind functions, rather than operating on a given
source pad. This is useful mostly for elements like tag demuxers which
strip off data at the beginning and/or end of a file and want to typefind
the stripped data stream before adding their own source pad (the specified
callback can then call the upstream peer pad with offsets adjusted for the
tag size, for example).
Returns #NULL if no #GstCaps matches the data stream.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the #GstCaps corresponding to the data stream.</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstObject that will be passed as first argument to @func</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">A generic #GstTypeFindHelperGetRangeFunction that will be used to access data at random offsets when doing the typefinding</doc>
          <type name="TypeFindHelperGetRangeFunction"
                c:type="GstTypeFindHelperGetRangeFunction"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">The length in bytes</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">location to store the probability of the found caps, or #NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_get_range_ext"
              c:identifier="gst_type_find_helper_get_range_ext"
              version="0.10.26">
      <doc xml:whitespace="preserve">Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
however, this function will use the specified function @func to obtain the
data needed by the typefind functions, rather than operating on a given
source pad. This is useful mostly for elements like tag demuxers which
strip off data at the beginning and/or end of a file and want to typefind
the stripped data stream before adding their own source pad (the specified
callback can then call the upstream peer pad with offsets adjusted for the
tag size, for example).
When @extension is not NULL, this function will first try the typefind
functions for the given extension, which might speed up the typefinding
in many cases.
Returns #NULL if no #GstCaps matches the data stream.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the #GstCaps corresponding to the data stream.</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstObject that will be passed as first argument to @func</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">A generic #GstTypeFindHelperGetRangeFunction that will be used to access data at random offsets when doing the typefinding</doc>
          <type name="TypeFindHelperGetRangeFunction"
                c:type="GstTypeFindHelperGetRangeFunction"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">The length in bytes</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="extension" transfer-ownership="none">
          <doc xml:whitespace="preserve">extension of the media</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">location to store the probability of the found caps, or #NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
