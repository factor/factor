<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gst" version="0.10"/>
  <include name="libxml2" version="2.0"/>
  <package name="gstreamer-base-0.10"/>
  <c:include name="gst/base/gstadapter.h"/>
  <c:include name="gst/base/gstbaseparse.h"/>
  <c:include name="gst/base/gstbasesink.h"/>
  <c:include name="gst/base/gstbasesrc.h"/>
  <c:include name="gst/base/gstbasetransform.h"/>
  <c:include name="gst/base/gstbitreader.h"/>
  <c:include name="gst/base/gstbytereader.h"/>
  <c:include name="gst/base/gstbytewriter.h"/>
  <c:include name="gst/base/gstcollectpads.h"/>
  <c:include name="gst/base/gstdataqueue.h"/>
  <c:include name="gst/base/gstpushsrc.h"/>
  <c:include name="gst/base/gsttypefindhelper.h"/>
  <namespace name="GstBase"
             version="0.10"
             shared-library="libgstreamer-0.10.so.0,libgstbase-0.10.so.0"
             c:identifier-prefixes="Gst"
             c:symbol-prefixes="gst">
    <class name="Adapter"
           c:symbol-prefix="adapter"
           c:type="GstAdapter"
           parent="GObject.Object"
           glib:type-name="GstAdapter"
           glib:get-type="gst_adapter_get_type"
           glib:type-struct="AdapterClass">
      <doc xml:whitespace="preserve">This class is for elements that receive buffers in an undesired size.
While for example raw video contains one image per buffer, the same is not
true for a lot of other formats, especially those that come directly from
a file. So if you have undefined buffer sizes and require a specific size,
this object is for you.
An adapter is created with gst_adapter_new(). It can be freed again with
g_object_unref().
into the adapter using gst_adapter_push() and the data is then read back
in chunks of the desired size using gst_adapter_peek(). After the data is
processed, it is freed using gst_adapter_flush().
Other methods such as gst_adapter_take() and gst_adapter_take_buffer()
combine gst_adapter_peek() and gst_adapter_flush() in one method and are
potentially more convenient for some use cases.
For example, a sink pad's chain function that needs to pass data to a library
in 512-byte chunks could be implemented like this:
|[
static GstFlowReturn
sink_pad_chain (GstPad *pad, GstBuffer *buffer)
{
MyElement *this;
GstAdapter *adapter;
GstFlowReturn ret = GST_FLOW_OK;
// will give the element an extra ref; remember to drop it
this = MY_ELEMENT (gst_pad_get_parent (pad));
adapter = this-&gt;adapter;
// put buffer into adapter
gst_adapter_push (adapter, buffer);
// while we can read out 512 bytes, process them
while (gst_adapter_available (adapter) &gt;= 512 &amp;&amp; ret == GST_FLOW_OK) {
// use flowreturn as an error value
ret = my_library_foo (gst_adapter_peek (adapter, 512));
gst_adapter_flush (adapter, 512);
}
gst_object_unref (this);
return ret;
}
]|
For another example, a simple element inside GStreamer that uses GstAdapter
is the libvisual element.
An element using GstAdapter in its sink pad chain function should ensure that
when the FLUSH_STOP event is received, that any queued data is cleared using
gst_adapter_clear(). Data should also be cleared or processed on EOS and
when changing state from #GST_STATE_PAUSED to #GST_STATE_READY.
Also check the GST_BUFFER_FLAG_DISCONT flag on the buffer. Some elements might
need to clear the adapter after a discontinuity.
Since 0.10.24, the adapter will keep track of the timestamps of the buffers
that were pushed. The last seen timestamp before the current position
can be queried with gst_adapter_prev_timestamp(). This function can
optionally return the amount of bytes between the start of the buffer that
carried the timestamp and the current adapter position. The distance is
useful when dealing with, for example, raw audio samples because it allows
you to calculate the timestamp of the current adapter position by using the
last seen timestamp and the amount of bytes since.
A last thing to note is that while GstAdapter is pretty optimized,
merging buffers still might be an operation that requires a malloc() and
memcpy() operation, and these operations are not the fastest. Because of
this, some functions like gst_adapter_available_fast() are provided to help
speed up such cases should you want to. To avoid repeated memory allocations,
gst_adapter_copy() can be used to copy data into a (statically allocated)
user provided buffer.
GstAdapter is not MT safe. All operations on an adapter must be serialized by
the caller. This is not normally a problem, however, as the normal use case
of GstAdapter is inside one pad's chain function, in which case access is
serialized via the pad's STREAM_LOCK.
Note that gst_adapter_push() takes ownership of the buffer passed. Use
gst_buffer_ref() before pushing it into the adapter if you still want to
access the buffer later. The adapter will never modify the data in the
buffer pushed in it.
Last reviewed on 2009-05-13 (0.10.24).</doc>
      <constructor name="new" c:identifier="gst_adapter_new">
        <doc xml:whitespace="preserve">Creates a new #GstAdapter. Free with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstAdapter</doc>
          <type name="Adapter" c:type="GstAdapter*"/>
        </return-value>
      </constructor>
      <method name="available" c:identifier="gst_adapter_available">
        <doc xml:whitespace="preserve">Gets the maximum amount of bytes available, that is it returns the maximum
value that can be supplied to gst_adapter_peek() without that function
returning NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">number of bytes available in @adapter</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="available_fast" c:identifier="gst_adapter_available_fast">
        <doc xml:whitespace="preserve">Gets the maximum number of bytes that are immediately available without
requiring any expensive operations (like copying the data into a
temporary buffer).
operations</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">number of bytes that are available in @adapter without expensive</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="clear" c:identifier="gst_adapter_clear">
        <doc xml:whitespace="preserve">Removes all buffers from @adapter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="copy" c:identifier="gst_adapter_copy" version="0.10.12">
        <doc xml:whitespace="preserve">Copies @size bytes of data starting at @offset out of the buffers
contained in @GstAdapter into an array @dest provided by the caller.
The array @dest should be large enough to contain @size bytes.
The user should check that the adapter has (@offset + @size) bytes
available before calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">the memory to copy into</doc>
            <array length="2" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the bytes offset in the adapter to start from</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the number of bytes to copy</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="gst_adapter_flush">
        <doc xml:whitespace="preserve">Flushes the first @flush bytes in the @adapter. The caller must ensure that
at least this many bytes are available.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flush" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to flush</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="masked_scan_uint32"
              c:identifier="gst_adapter_masked_scan_uint32"
              version="0.10.24">
        <doc xml:whitespace="preserve">Scan for pattern @pattern with applied mask @mask in the adapter data,
starting from offset @offset.
The bytes in @pattern and @mask are interpreted left-to-right, regardless
of endianness.  All four bytes of the pattern must be present in the
adapter for it to match, even if the first or last bytes are masked out.
It is an error to call this function without making sure that there is
enough data (offset+size bytes) in the adapter.
This function calls gst_adapter_masked_scan_uint32_peek() passing NULL
for value.
Example:
&lt;programlisting&gt;
// Assume the adapter contains 0x00 0x01 0x02 ... 0xfe 0xff
gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x00010203, 0, 256);
// -&gt; returns 0
gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x00010203, 1, 255);
// -&gt; returns -1
gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x01020304, 1, 255);
// -&gt; returns 1
gst_adapter_masked_scan_uint32 (adapter, 0xffff, 0x0001, 0, 256);
// -&gt; returns -1
gst_adapter_masked_scan_uint32 (adapter, 0xffff, 0x0203, 0, 256);
// -&gt; returns 0
gst_adapter_masked_scan_uint32 (adapter, 0xffff0000, 0x02030000, 0, 256);
// -&gt; returns 2
gst_adapter_masked_scan_uint32 (adapter, 0xffff0000, 0x02030000, 0, 4);
// -&gt; returns -1
&lt;/programlisting&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">offset of the first match, or -1 if no match was found.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:whitespace="preserve">mask to apply to data before matching against @pattern</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:whitespace="preserve">pattern to match (after mask is applied)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">offset into the adapter data from which to start scanning, returns the last scanned position.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bytes to scan from offset</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="masked_scan_uint32_peek"
              c:identifier="gst_adapter_masked_scan_uint32_peek"
              version="0.10.30">
        <doc xml:whitespace="preserve">Scan for pattern @pattern with applied mask @mask in the adapter data,
starting from offset @offset.  If a match is found, the value that matched
is returned through @value, otherwise @value is left untouched.
The bytes in @pattern and @mask are interpreted left-to-right, regardless
of endianness.  All four bytes of the pattern must be present in the
adapter for it to match, even if the first or last bytes are masked out.
It is an error to call this function without making sure that there is
enough data (offset+size bytes) in the adapter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">offset of the first match, or -1 if no match was found.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:whitespace="preserve">mask to apply to data before matching against @pattern</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:whitespace="preserve">pattern to match (after mask is applied)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">offset into the adapter data from which to start scanning, returns the last scanned position.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bytes to scan from offset</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to uint32 to return matching data</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="gst_adapter_peek">
        <doc xml:whitespace="preserve">Gets the first @size bytes stored in the @adapter. The returned pointer is
valid until the next function is called on the adapter.
Note that setting the returned pointer as the data of a #GstBuffer is
incorrect for general-purpose plugins. The reason is that if a downstream
element stores the buffer so that it has access to it outside of the bounds
of its chain function, the buffer will have an invalid data pointer after
your element flushes the bytes. In that case you should use
gst_adapter_take(), which returns a freshly-allocated buffer that you can set
as #GstBuffer malloc_data or the potentially more performant
gst_adapter_take_buffer().
Returns #NULL if @size bytes are not available.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to the first</doc>
          <array length="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the number of bytes to peek</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="prev_timestamp"
              c:identifier="gst_adapter_prev_timestamp"
              version="0.10.24">
        <doc xml:whitespace="preserve">Get the timestamp that was before the current byte in the adapter. When
position is returned.
The timestamp is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
the adapter is first created or when it is cleared. This also means that before
the first byte with a timestamp is removed from the adapter, the timestamp
and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The previously seen timestamp.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="distance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">pointer to location for distance, or NULL</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="gst_adapter_push">
        <doc xml:whitespace="preserve">Adds the data from @buf to the data stored inside @adapter and takes
ownership of the buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstBuffer to add to queue in the adapter</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take" c:identifier="gst_adapter_take">
        <doc xml:whitespace="preserve">Returns a freshly allocated buffer containing the first @nbytes bytes of the
Caller owns returned value. g_free after usage.
#NULL if @nbytes bytes are not available</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">oven-fresh hot data, or</doc>
          <array length="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="nbytes"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the number of bytes to take</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_buffer"
              c:identifier="gst_adapter_take_buffer"
              version="0.10.6">
        <doc xml:whitespace="preserve">Returns a #GstBuffer containing the first @nbytes bytes of the
This function is potentially more performant than gst_adapter_take()
since it can reuse the memory in pushed buffers by subbuffering
or merging.
Caller owns returned value. gst_buffer_unref() after usage.
the adapter, or #NULL if @nbytes bytes are not available</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstBuffer containing the first @nbytes of</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to take</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_list"
              c:identifier="gst_adapter_take_list"
              version="0.10.31">
        <doc xml:whitespace="preserve">Returns a #GList of buffers containing the first @nbytes bytes of the
When the caller can deal with individual buffers, this function is more
performant because no memory should be copied.
Caller owns returned list and contained buffers. gst_buffer_unref() each
buffer in the list before freeing the list after usage.
containing the first @nbytes of the adapter, or #NULL if @nbytes bytes
are not available</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of buffers</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Gst.Buffer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to take</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="buflist" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="size" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="skip" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="assembled_data" readable="0" private="1">
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="assembled_size" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="assembled_len" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="buflist_end" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AdapterPrivate" c:type="GstAdapterPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AdapterClass"
            c:type="GstAdapterClass"
            glib:is-gtype-struct-for="Adapter">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AdapterPrivate" c:type="GstAdapterPrivate" disguised="1">
    </record>
    <constant name="BASE_PARSE_FLAG_DRAINING" value="2">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="BASE_PARSE_FLAG_LOST_SYNC" value="1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="BASE_TRANSFORM_SINK_NAME" value="sink">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="BASE_TRANSFORM_SRC_NAME" value="src">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="BaseParse"
           c:symbol-prefix="base_parse"
           c:type="GstBaseParse"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstBaseParse"
           glib:get-type="gst_base_parse_get_type"
           glib:type-struct="BaseParseClass">
      <doc xml:whitespace="preserve">This base class is for parser elements that process data and splits it
into separate audio/video/whatever frames.
It provides for:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;provides one sink pad and one source pad&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;handles state changes&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;can operate in pull mode or push mode&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;handles seeking in both modes&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;handles events (NEWSEGMENT/EOS/FLUSH)&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
handles queries (POSITION/DURATION/SEEKING/FORMAT/CONVERT)
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;handles flushing&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
The purpose of this base class is to provide the basic functionality of
a parser and share a lot of rather complex code.
Description of the parsing mechanism:
&lt;orderedlist&gt;
&lt;listitem&gt;
&lt;itemizedlist&gt;&lt;title&gt;Set-up phase&lt;/title&gt;
&lt;listitem&gt;&lt;para&gt;
GstBaseParse class calls @set_sink_caps to inform the subclass about
incoming sinkpad caps. Subclass should set the srcpad caps accordingly.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
GstBaseParse calls @start to inform subclass that data processing is
about to start now.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
At least at this point subclass needs to tell the GstBaseParse class
how big data chunks it wants to receive (min_frame_size). It can do
this with gst_base_parse_set_min_frame_size().
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
GstBaseParse class sets up appropriate data passing mode (pull/push)
and starts to process the data.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;itemizedlist&gt;
&lt;title&gt;Parsing phase&lt;/title&gt;
&lt;listitem&gt;&lt;para&gt;
GstBaseParse gathers at least min_frame_size bytes of data either
by pulling it from upstream or collecting buffers in an internal
#GstAdapter.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
A buffer of (at least) min_frame_size bytes is passed to subclass with
if the buffer contains a valid frame. It also needs to set the
contain a valid frame, this call must return FALSE and optionally
set the @skipsize value to inform base class that how many bytes
it needs to skip in order to find a valid frame. @framesize can always
indicate a new minimum for current frame parsing.  The passed buffer
is read-only.  Note that @check_valid_frame might receive any small
amount of input data when leftover data is being drained (e.g. at EOS).
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
After valid frame is found, it will be passed again to subclass with
frame contents and setting the caps, and buffer metadata (e.g.
buffer timestamp and duration, or keyframe if applicable).
(although the latter can also be done by GstBaseParse if it is
appropriately configured, see below).  Frame is provided with
timestamp derived from upstream (as much as generally possible),
duration obtained from configuration (see below), and offset
if meaningful (in pull mode).
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Finally the buffer can be pushed downstream and the parsing loop starts
over again.  Just prior to actually pushing the buffer in question,
it is passed to @pre_push_buffer which gives subclass yet one
last chance to examine buffer metadata, or to send some custom (tag)
events, or to perform custom (segment) filtering.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
During the parsing process GstBaseParseClass will handle both srcpad
and sinkpad events. They will be passed to subclass if @event or
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;itemizedlist&gt;&lt;title&gt;Shutdown phase&lt;/title&gt;
&lt;listitem&gt;&lt;para&gt;
GstBaseParse class calls @stop to inform the subclass that data
parsing will be stopped.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;/orderedlist&gt;
Subclass is responsible for providing pad template caps for
source and sink pads. The pads need to be named "sink" and "src". It also
needs to set the fixed caps on srcpad, when the format is ensured (e.g.
when base class calls subclass' @set_sink_caps function).
This base class uses #GST_FORMAT_DEFAULT as a meaning of frames. So,
subclass conversion routine needs to know that conversion from
#GST_FORMAT_TIME to #GST_FORMAT_DEFAULT must return the
frame number that can be found from the given byte position.
GstBaseParse uses subclasses conversion methods also for seeking (or
otherwise uses its own default one, see also below).
Subclass @start and @stop functions will be called to inform the beginning
and end of data processing.
Things that subclass need to take care of:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;Provide pad templates&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Fixate the source pad caps when appropriate
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Inform base class how big data chunks should be retrieved. This is
done with gst_base_parse_set_min_frame_size() function.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Examine data chunks passed to subclass with @check_valid_frame
and tell if they contain a valid frame
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Set the caps and timestamp to frame that is passed to subclass with
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;Provide conversion functions&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Update the duration information with gst_base_parse_set_duration()
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Optionally passthrough using gst_base_parse_set_passthrough()
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Configure various baseparse parameters using
gst_base_parse_set_average_bitrate(), gst_base_parse_set_syncable()
and gst_base_parse_set_frame_rate().
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
In particular, if subclass is unable to determine a duration, but
parsing (or specs) yields a frames per seconds rate, then this can be
provided to GstBaseParse to enable it to cater for
buffer time metadata (which will be taken from upstream as much as
possible). Internally keeping track of frame durations and respective
sizes that have been pushed provides GstBaseParse with an estimated
bitrate. A default @convert (used if not overriden) will then use these
rates to perform obvious conversions.  These rates are also used to
update (estimated) duration at regular frame intervals.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
      <virtual-method name="check_valid_frame">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="frame" transfer-ownership="none">
            <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
          </parameter>
          <parameter name="framesize" transfer-ownership="none">
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="skipsize" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="convert">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_format" transfer-ownership="none">
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_value" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format" transfer-ownership="none">
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_value" transfer-ownership="none">
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parse_frame">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="frame" transfer-ownership="none">
            <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pre_push_frame">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="frame" transfer-ownership="none">
            <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_sink_caps">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="add_index_entry"
              c:identifier="gst_base_parse_add_index_entry"
              version="0.10.33">
        <doc xml:whitespace="preserve">Adds an entry to the index associating @offset to @ts.  It is recommended
to only add keyframe entries.  @force allows to bypass checks, such as
whether the stream is (upstream) seekable, another entry is already "close"
to the new entry, etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#gboolean indicating whether entry was added</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">offset of entry</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="ts" transfer-ownership="none">
            <doc xml:whitespace="preserve">timestamp associated with offset</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether entry refers to keyframe</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="force" transfer-ownership="none">
            <doc xml:whitespace="preserve">add entry disregarding sanity checks</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="convert_default"
              c:identifier="gst_base_parse_convert_default"
              version="0.10.33">
        <doc xml:whitespace="preserve">Default implementation of "convert" vmethod in #GstBaseParse class.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if conversion was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstFormat describing the source format.</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">Source value to be converted.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstFormat defining the converted format.</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer where the conversion result will be put.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_frame"
              c:identifier="gst_base_parse_push_frame"
              version="0.10.33">
        <doc xml:whitespace="preserve">Pushes the frame downstream, sends any pending events and
does some timestamp and segment handling. Takes ownership
of @frame and will clear it (if it was initialised with
gst_base_parse_frame_init()) or free it.
This must be called with sinkpad STREAM_LOCK held.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstFlowReturn</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="frame" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstBaseParseFrame</doc>
            <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_average_bitrate"
              c:identifier="gst_base_parse_set_average_bitrate"
              version="0.10.33">
        <doc xml:whitespace="preserve">Optionally sets the average bitrate detected in media (if non-zero),
e.g. based on metadata, as it will be posted to the application.
By default, announced average bitrate is estimated. The average bitrate
is used to estimate the total duration of the stream and to estimate
a seek position, if there's no index and the format is syncable
(see gst_base_parse_set_syncable()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bitrate" transfer-ownership="none">
            <doc xml:whitespace="preserve">average bitrate in bits/second</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_duration"
              c:identifier="gst_base_parse_set_duration"
              version="0.10.33">
        <doc xml:whitespace="preserve">Sets the duration of the currently playing media. Subclass can use this
when it is able to determine duration and/or notices a change in the media
duration.  Alternatively, if @interval is non-zero (default), then stream
duration is determined based on estimated bitrate, and updated every @interval
frames.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fmt" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstFormat.</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:whitespace="preserve">duration value.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">how often to update the duration estimate based on bitrate, or 0.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_rate"
              c:identifier="gst_base_parse_set_frame_rate"
              version="0.10.33">
        <doc xml:whitespace="preserve">If frames per second is configured, parser can take care of buffer duration
and timestamping.  When performing segment clipping, or seeking to a specific
location, a corresponding decoder might need an initial @lead_in and a
following @lead_out number of frames to ensure the desired segment is
entirely filled upon decoding.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fps_num" transfer-ownership="none">
            <doc xml:whitespace="preserve">frames per second (numerator).</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="fps_den" transfer-ownership="none">
            <doc xml:whitespace="preserve">frames per second (denominator).</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="lead_in" transfer-ownership="none">
            <doc xml:whitespace="preserve">frames needed before a segment for subsequent decode</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="lead_out" transfer-ownership="none">
            <doc xml:whitespace="preserve">frames needed after a segment</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_has_timing_info"
              c:identifier="gst_base_parse_set_has_timing_info"
              version="0.10.33">
        <doc xml:whitespace="preserve">Set if frames carry timing information which the subclass can (generally)
parse and provide.  In particular, intrinsic (rather than estimated) time
can be obtained following a seek.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="has_timing" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether frames carry timing information</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_min_frame_size"
              c:identifier="gst_base_parse_set_min_frame_size"
              version="0.10.33">
        <doc xml:whitespace="preserve">Subclass can use this function to tell the base class that it needs to
give at least #min_size buffers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="min_size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Minimum size of the data that this base class should give to subclass.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_passthrough"
              c:identifier="gst_base_parse_set_passthrough"
              version="0.10.33">
        <doc xml:whitespace="preserve">Set if the nature of the format or configuration does not allow (much)
parsing, and the parser should operate in passthrough mode (which only
applies when operating in push mode). That is, incoming buffers are
pushed through unmodified, i.e. no @check_valid_frame or @parse_frame
callbacks will be invoked, but @pre_push_buffer will still be invoked,
so subclass can perform as much or as little is appropriate for
passthrough semantics in @pre_push_buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="passthrough" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if parser should run in passthrough mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_syncable"
              c:identifier="gst_base_parse_set_syncable"
              version="0.10.33">
        <doc xml:whitespace="preserve">Set if frame starts can be identified. This is set by default and
determines whether seeking based on bitrate averages
is possible for a format/stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="syncable" transfer-ownership="none">
            <doc xml:whitespace="preserve">set if frame starts can be identified</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="flags">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseParsePrivate" c:type="GstBaseParsePrivate*"/>
      </field>
    </class>
    <record name="BaseParseClass"
            c:type="GstBaseParseClass"
            glib:is-gtype-struct-for="BaseParse">
      <doc xml:whitespace="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At minimum @check_valid_frame and @parse_frame needs to be
overridden.</doc>
      <field name="parent_class">
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_sink_caps">
        <callback name="set_sink_caps">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="check_valid_frame">
        <callback name="check_valid_frame">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="frame" transfer-ownership="none">
              <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
            </parameter>
            <parameter name="framesize" transfer-ownership="none">
              <type name="guint" c:type="guint*"/>
            </parameter>
            <parameter name="skipsize" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parse_frame">
        <callback name="parse_frame">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="frame" transfer-ownership="none">
              <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pre_push_frame">
        <callback name="pre_push_frame">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="frame" transfer-ownership="none">
              <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="convert">
        <callback name="convert">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="src_format" transfer-ownership="none">
              <type name="Gst.Format" c:type="GstFormat"/>
            </parameter>
            <parameter name="src_value" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="dest_format" transfer-ownership="none">
              <type name="Gst.Format" c:type="GstFormat"/>
            </parameter>
            <parameter name="dest_value" transfer-ownership="none">
              <type name="gint64" c:type="gint64*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_event">
        <callback name="src_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseParseFrame"
            c:type="GstBaseParseFrame"
            version="0.10.33"
            glib:type-name="GstBaseParseFrame"
            glib:get-type="gst_base_parse_frame_get_type"
            c:symbol-prefix="base_parse_frame">
      <doc xml:whitespace="preserve">Frame (context) data passed to each frame parsing virtual methods.  In
addition to providing the data to be checked for a valid frame or an already
identified frame, it conveys additional metadata or control information
from and to the subclass w.r.t. the particular frame in question (rather
than global parameters).  Some of these may apply to each parsing stage, others
only to some a particular one.  These parameters are effectively zeroed at start
of each frame's processing, i.e. parsing virtual method invocation sequence.</doc>
      <field name="buffer" writable="1">
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="flags" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="overhead" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="_gst_reserved_i" readable="0" private="1">
        <array zero-terminated="0" c:type="guint" fixed-size="2">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <field name="_gst_reserved_p" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="_private_flags" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <constructor name="new"
                   c:identifier="gst_base_parse_frame_new"
                   version="0.10.33">
        <doc xml:whitespace="preserve">Allocates a new #GstBaseParseFrame. This function is mainly for bindings,
elements written in C should usually allocate the frame on the stack and
then use gst_base_parse_frame_init() to initialise it.
gst_base_parse_frame_free() when no longer needed, unless you gave
away ownership to gst_base_parse_push_frame().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly-allocated #GstBaseParseFrame. Free with</doc>
          <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstBuffer</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the flags</doc>
            <type name="BaseParseFrameFlags" c:type="GstBaseParseFrameFlags"/>
          </parameter>
          <parameter name="overhead" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bytes in this frame which should be counted as metadata overhead, ie. not used to calculate the average bitrate. Set to -1 to mark the entire frame as metadata. If in doubt, set to 0.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="free" c:identifier="gst_base_parse_frame_free">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="init"
              c:identifier="gst_base_parse_frame_init"
              version="0.10.33">
        <doc xml:whitespace="preserve">Sets a #GstBaseParseFrame to initial state.  Currently this means
all public fields are zero-ed and a private flag is set to make
sure gst_base_parse_frame_free() only frees the contents but not
the actual frame. Use this function to initialise a #GstBaseParseFrame
allocated on the stack.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <bitfield name="BaseParseFrameFlags"
              version="0.10.33"
              c:type="GstBaseParseFrameFlags">
      <doc xml:whitespace="preserve">Flags to be used in a #GstBaseParseFrame.</doc>
      <member name="none"
              value="0"
              c:identifier="GST_BASE_PARSE_FRAME_FLAG_NONE"/>
      <member name="no_frame"
              value="1"
              c:identifier="GST_BASE_PARSE_FRAME_FLAG_NO_FRAME"/>
      <member name="clip"
              value="2"
              c:identifier="GST_BASE_PARSE_FRAME_FLAG_CLIP"/>
    </bitfield>
    <record name="BaseParsePrivate" c:type="GstBaseParsePrivate" disguised="1">
    </record>
    <class name="BaseSink"
           c:symbol-prefix="base_sink"
           c:type="GstBaseSink"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstBaseSink"
           glib:get-type="gst_base_sink_get_type"
           glib:type-struct="BaseSinkClass">
      <doc xml:whitespace="preserve">#GstBaseSink is the base class for sink elements in GStreamer, such as
xvimagesink or filesink. It is a layer on top of #GstElement that provides a
simplified interface to plugin writers. #GstBaseSink handles many details
activation in push or pull mode, and queries.
In most cases, when writing sink elements, there is no need to implement
class methods from #GstElement or to set functions on pads, because the
#GstBaseSink infrastructure should be sufficient.
#GstBaseSink provides support for exactly one sink pad, which should be
named "sink". A sink implementation (subclass of #GstBaseSink) should
install a pad template in its base_init function, like so:
|[
static void
my_element_base_init (gpointer g_class)
{
GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
// sinktemplate should be a #GstStaticPadTemplate with direction
// #GST_PAD_SINK and name "sink"
gst_element_class_add_pad_template (gstelement_class,
gst_static_pad_template_get (&amp;amp;sinktemplate));
// see #GstElementDetails
gst_element_class_set_details (gstelement_class, &amp;amp;details);
}
]|
#GstBaseSink will handle the prerolling correctly. This means that it will
return #GST_STATE_CHANGE_ASYNC from a state change to PAUSED until the first
buffer arrives in this element. The base class will call the
#GstBaseSinkClass.preroll() vmethod with this preroll buffer and will then
commit the state change to the next asynchronously pending state.
When the element is set to PLAYING, #GstBaseSink will synchronise on the
clock using the times returned from #GstBaseSinkClass.get_times(). If this
function returns #GST_CLOCK_TIME_NONE for the start time, no synchronisation
will be done. Synchronisation can be disabled entirely by setting the object
#GstBaseSink:sync property to %FALSE.
After synchronisation the virtual method #GstBaseSinkClass.render() will be
called. Subclasses should minimally implement this method.
Since 0.10.3 subclasses that synchronise on the clock in the
#GstBaseSinkClass.render() method are supported as well. These classes
typically receive a buffer in the render method and can then potentially
block on the clock while rendering. A typical example is an audiosink.
Since 0.10.11 these subclasses can use gst_base_sink_wait_preroll() to
perform the blocking wait.
Upon receiving the EOS event in the PLAYING state, #GstBaseSink will wait
for the clock to reach the time indicated by the stop time of the last
#GstBaseSinkClass.get_times() call before posting an EOS message. When the
element receives EOS in PAUSED, preroll completes, the event is queued and an
EOS message is posted when going to PLAYING.
#GstBaseSink will internally use the #GST_EVENT_NEWSEGMENT events to schedule
synchronisation and clipping of buffers. Buffers that fall completely outside
of the current segment are dropped. Buffers that fall partially in the
segment are rendered (and prerolled). Subclasses should do any subbuffer
clipping themselves when needed.
#GstBaseSink will by default report the current playback position in
#GST_FORMAT_TIME based on the current clock time and segment information.
If no clock has been set on the element, the query will be forwarded
upstream.
The #GstBaseSinkClass.set_caps() function will be called when the subclass
should configure itself to process a specific media type.
The #GstBaseSinkClass.start() and #GstBaseSinkClass.stop() virtual methods
will be called when resources should be allocated. Any 
#GstBaseSinkClass.preroll(), #GstBaseSinkClass.render() and
#GstBaseSinkClass.set_caps() function will be called between the
#GstBaseSinkClass.start() and #GstBaseSinkClass.stop() calls.
The #GstBaseSinkClass.event() virtual method will be called when an event is
received by #GstBaseSink. Normally this method should only be overriden by
very specific elements (such as file sinks) which need to handle the
newsegment event specially.
#GstBaseSink provides an overridable #GstBaseSinkClass.buffer_alloc()
function that can be used by sinks that want to do reverse negotiation or to
provide custom buffers (hardware buffers for example) to upstream elements.
The #GstBaseSinkClass.unlock() method is called when the elements should
unblock any blocking operations they perform in the
#GstBaseSinkClass.render() method. This is mostly useful when the
#GstBaseSinkClass.render() method performs a blocking write on a file
descriptor, for example.
The #GstBaseSink:max-lateness property affects how the sink deals with
buffers that arrive too late in the sink. A buffer arrives too late in the
sink when the presentation time (as a combination of the last segment, buffer
timestamp and element base_time) plus the duration is before the current
time of the clock.
If the frame is later than max-lateness, the sink will drop the buffer
without calling the render method.
This feature is disabled if sync is disabled, the
#GstBaseSinkClass.get_times() method does not return a valid start time or
max-lateness is set to -1 (the default).
Subclasses can use gst_base_sink_set_max_lateness() to configure the
max-lateness value.
The #GstBaseSink:qos property will enable the quality-of-service features of
the basesink which gather statistics about the real-time performance of the
clock synchronisation. For each buffer received in the sink, statistics are
gathered and a QOS event is sent upstream with these numbers. This
information can then be used by upstream elements to reduce their processing
rate, for example.
Since 0.10.15 the #GstBaseSink:async property can be used to instruct the
sink to never perform an ASYNC state change. This feature is mostly usable
when dealing with non-synchronized streams or sparse streams.
Last reviewed on 2007-08-29 (0.10.15)</doc>
      <virtual-method name="activate_pull">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="active" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="async_play">
        <return-value transfer-ownership="none">
          <type name="Gst.StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
      </virtual-method>
      <virtual-method name="buffer_alloc">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fixate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_caps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_times">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="preroll">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="render">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="render_list">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer_list" transfer-ownership="none">
            <type name="Gst.BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_caps">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unlock">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unlock_stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="do_preroll"
              c:identifier="gst_base_sink_do_preroll"
              version="0.10.22">
        <doc xml:whitespace="preserve">If the @sink spawns its own thread for pulling buffers from upstream it
should call this method after it has pulled a buffer. If the element needed
to preroll, this function will perform the preroll and will then block
until the element state is changed.
This function should be called with the PREROLL_LOCK held.
continue. Any other return value should be returned from the render vmethod.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GST_FLOW_OK if the preroll completed and processing can</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mini object that caused the preroll</doc>
            <type name="Gst.MiniObject" c:type="GstMiniObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_blocksize"
              c:identifier="gst_base_sink_get_blocksize"
              version="0.10.22">
        <doc xml:whitespace="preserve">Get the number of bytes that the sink will pull when it is operating in pull
mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes @sink will pull in pull mode.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_last_buffer"
              c:identifier="gst_base_sink_get_last_buffer"
              version="0.10.15">
        <doc xml:whitespace="preserve">Get the last buffer that arrived in the sink and was used for preroll or for
rendering. This property can be used to generate thumbnails.
The #GstCaps on the buffer can be used to determine the type of the buffer.
This function returns NULL when no buffer has arrived in the sink yet
or when the sink is not in PAUSED or PLAYING.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstBuffer. gst_buffer_unref() after usage.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="get_latency"
              c:identifier="gst_base_sink_get_latency"
              version="0.10.12">
        <doc xml:whitespace="preserve">Get the currently configured latency.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The configured latency.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_max_lateness"
              c:identifier="gst_base_sink_get_max_lateness"
              version="0.10.4">
        <doc xml:whitespace="preserve">Gets the max lateness value. See gst_base_sink_set_max_lateness for
more details.
before it is dropped and not rendered. A value of -1 means an
unlimited time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The maximum time in nanoseconds that a buffer can be late</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_render_delay"
              c:identifier="gst_base_sink_get_render_delay"
              version="0.10.21">
        <doc xml:whitespace="preserve">Get the render delay of @sink. see gst_base_sink_set_render_delay() for more
information about the render delay.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the render delay of @sink.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_sync"
              c:identifier="gst_base_sink_get_sync"
              version="0.10.4">
        <doc xml:whitespace="preserve">Checks if @sink is currently configured to synchronize against the
clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the sink is configured to synchronize against the clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_throttle_time"
              c:identifier="gst_base_sink_get_throttle_time"
              version="0.10.33">
        <doc xml:whitespace="preserve">Get the time that will be inserted between frames to control the 
maximum buffers per second.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of nanoseconds @sink will put between frames.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="get_ts_offset"
              c:identifier="gst_base_sink_get_ts_offset"
              version="0.10.15">
        <doc xml:whitespace="preserve">Get the synchronisation offset of @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The synchronisation offset.</doc>
          <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
        </return-value>
      </method>
      <method name="is_async_enabled"
              c:identifier="gst_base_sink_is_async_enabled"
              version="0.10.15">
        <doc xml:whitespace="preserve">Checks if @sink is currently configured to perform asynchronous state
changes to PAUSED.
changes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the sink is configured to perform asynchronous state</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_last_buffer_enabled"
              c:identifier="gst_base_sink_is_last_buffer_enabled"
              version="0.10.30">
        <doc xml:whitespace="preserve">Checks if @sink is currently configured to store the last received buffer in
the last-buffer property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the sink is configured to store the last received buffer.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_qos_enabled"
              c:identifier="gst_base_sink_is_qos_enabled"
              version="0.10.5">
        <doc xml:whitespace="preserve">Checks if @sink is currently configured to send Quality-of-Service events
upstream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the sink is configured to perform Quality-of-Service.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="query_latency"
              c:identifier="gst_base_sink_query_latency"
              version="0.10.12">
        <doc xml:whitespace="preserve">Query the sink for the latency parameters. The latency will be queried from
the upstream elements. @live will be TRUE if @sink is configured to
synchronize against the clock. @upstream_live will be TRUE if an upstream
element is live.
If both @live and @upstream_live are TRUE, the sink will want to compensate
for the latency introduced by the upstream elements by setting the
This function is mostly used by subclasses.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">if the sink is live</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="upstream_live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">if an upstream element is live</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="min_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the min latency of the upstream elements</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the max latency of the upstream elements</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_async_enabled"
              c:identifier="gst_base_sink_set_async_enabled"
              version="0.10.15">
        <doc xml:whitespace="preserve">Configures @sink to perform all state changes asynchronusly. When async is
disabled, the sink will immediatly go to PAUSED instead of waiting for a
preroll buffer. This feature is usefull if the sink does not synchronize
against the clock or when it is dealing with sparse streams.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new async value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blocksize"
              c:identifier="gst_base_sink_set_blocksize"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the number of bytes that the sink will pull when it is operating in pull
mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="blocksize" transfer-ownership="none">
            <doc xml:whitespace="preserve">the blocksize in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_last_buffer_enabled"
              c:identifier="gst_base_sink_set_last_buffer_enabled"
              version="0.10.30">
        <doc xml:whitespace="preserve">Configures @sink to store the last received buffer in the last-buffer
property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new enable-last-buffer value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_lateness"
              c:identifier="gst_base_sink_set_max_lateness"
              version="0.10.4">
        <doc xml:whitespace="preserve">Sets the new max lateness value to @max_lateness. This value is
used to decide if a buffer should be dropped or not based on the
buffer timestamp and the current clock time. A value of -1 means
an unlimited time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="max_lateness" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new max lateness value.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qos_enabled"
              c:identifier="gst_base_sink_set_qos_enabled"
              version="0.10.5">
        <doc xml:whitespace="preserve">Configures @sink to send Quality-of-Service events upstream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new qos value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_render_delay"
              c:identifier="gst_base_sink_set_render_delay"
              version="0.10.21">
        <doc xml:whitespace="preserve">Set the render delay in @sink to @delay. The render delay is the time
between actual rendering of a buffer and its synchronisation time. Some
devices might delay media rendering which can be compensated for with this
function.
After calling this function, this sink will report additional latency and
other sinks will adjust their latency to delay the rendering of their media.
This function is usually called by subclasses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="delay" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new delay</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sync"
              c:identifier="gst_base_sink_set_sync"
              version="0.10.4">
        <doc xml:whitespace="preserve">Configures @sink to synchronize on the clock or not. When
possible. If @sync is TRUE, the timestamps of the incomming
buffers will be used to schedule the exact render time of its
contents.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="sync" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new sync value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_throttle_time"
              c:identifier="gst_base_sink_set_throttle_time"
              version="0.10.33">
        <doc xml:whitespace="preserve">Set the time that will be inserted between rendered buffers. This
can be used to control the maximum buffers per second that the sink
will render.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="throttle" transfer-ownership="none">
            <doc xml:whitespace="preserve">the throttle time in nanoseconds</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ts_offset"
              c:identifier="gst_base_sink_set_ts_offset"
              version="0.10.15">
        <doc xml:whitespace="preserve">Adjust the synchronisation of @sink with @offset. A negative value will
render buffers earlier than their timestamp. A positive value will delay
rendering. This function can be used to fix playback of badly timestamped
buffers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new offset</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_clock"
              c:identifier="gst_base_sink_wait_clock"
              version="0.10.20">
        <doc xml:whitespace="preserve">This function will block until @time is reached. It is usually called by
subclasses that use their own internal synchronisation.
If @time is not valid, no sycnhronisation is done and #GST_CLOCK_BADTIME is
returned. Likewise, if synchronisation is disabled in the element or there
is no clock, no synchronisation is done and #GST_CLOCK_BADTIME is returned.
This function should only be called with the PREROLL_LOCK held, like when
receiving an EOS event in the #GstBaseSinkClass.event() vmethod or when
receiving a buffer in
the #GstBaseSinkClass.render() vmethod.
The @time argument should be the running_time of when this method should
return and is not adjusted with any latency or offset configured in the
sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstClockReturn</doc>
          <type name="Gst.ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the running_time to be reached</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="jitter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the jitter to be filled with time diff, or NULL</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_eos"
              c:identifier="gst_base_sink_wait_eos"
              version="0.10.15">
        <doc xml:whitespace="preserve">This function will block until @time is reached. It is usually called by
subclasses that use their own internal synchronisation but want to let the
EOS be handled by the base class.
This function should only be called with the PREROLL_LOCK held, like when
receiving an EOS event in the ::event vmethod.
The @time argument should be the running_time of when the EOS should happen
and will be adjusted with any latency and offset configured in the sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstFlowReturn</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the running_time to be reached</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="jitter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the jitter to be filled with time diff, or NULL</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_preroll"
              c:identifier="gst_base_sink_wait_preroll"
              version="0.10.11">
        <doc xml:whitespace="preserve">If the #GstBaseSinkClass.render() method performs its own synchronisation
against the clock it must unblock when going from PLAYING to the PAUSED state
and call this method before continuing to render the remaining data.
This function will block until a state change to PLAYING happens (in which
case this function returns #GST_FLOW_OK) or the processing must be stopped due
to a state change to READY or a FLUSH event (in which case this function
returns #GST_FLOW_WRONG_STATE).
This function should only be called with the PREROLL_LOCK held, like in the
render function.
continue. Any other return value should be returned from the render vmethod.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GST_FLOW_OK if the preroll completed and processing can</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
      </method>
      <property name="async"
                version="0.10.15"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If set to #TRUE, the basesink will perform asynchronous state changes.
When set to #FALSE, the sink will not signal the parent when it prerolls.
Use this option when dealing with sparse streams or when synchronisation is
not required.</doc>
        <type name="gboolean"/>
      </property>
      <property name="blocksize"
                version="0.10.22"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The amount of bytes to pull when operating in pull mode.</doc>
        <type name="guint"/>
      </property>
      <property name="enable-last-buffer"
                version="0.10.30"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Enable the last-buffer property. If FALSE, basesink doesn't keep a
reference to the last buffer arrived and the last-buffer property is always
set to NULL. This can be useful if you need buffers to be released as soon
as possible, eg. if you're using a buffer pool.</doc>
        <type name="gboolean"/>
      </property>
      <property name="last-buffer" version="0.10.15" transfer-ownership="none">
        <doc xml:whitespace="preserve">The last buffer that arrived in the sink and was used for preroll or for
rendering. This property can be used to generate thumbnails. This property
can be NULL when the sink has not yet received a bufer.</doc>
        <type name="Gst.Buffer"/>
      </property>
      <property name="max-lateness" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="preroll-queue-len"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint"/>
      </property>
      <property name="qos" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="render-delay"
                version="0.10.22"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The additional delay between synchronisation and actual rendering of the
media. This property will add additional latency to the device in order to
make other sinks compensate for the delay.</doc>
        <type name="guint64"/>
      </property>
      <property name="sync" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="throttle-time"
                version="0.10.33"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The time to insert between buffers. This property can be used to control
the maximum amount of buffers per second to render. Setting this property
to a value bigger than 0 will make the sink create THROTTLE QoS events.</doc>
        <type name="guint64"/>
      </property>
      <property name="ts-offset"
                version="0.10.15"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Controls the final synchronisation, a negative value will render the buffer
earlier while a positive value delays playback. This property can be
used to fix synchronisation in bad files.</doc>
        <type name="gint64"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="pad_mode">
        <type name="Gst.ActivateMode" c:type="GstActivateMode"/>
      </field>
      <field name="offset">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="can_activate_pull">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="can_activate_push">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="preroll_queue">
        <type name="GLib.Queue" c:type="GQueue*"/>
      </field>
      <field name="preroll_queue_max_len">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="preroll_queued">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="buffers_queued">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="events_queued">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="eos">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="eos_queued">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="need_preroll">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="have_preroll">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="playing_async">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="have_newsegment">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="clock_id" readable="0" private="1">
        <type name="Gst.ClockID" c:type="GstClockID"/>
      </field>
      <field name="end_time" readable="0" private="1">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="sync" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="flushing" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="clip_segment" writable="1">
            <type name="Gst.Segment" c:type="GstSegment*"/>
          </field>
          <field name="max_lateness" writable="1">
            <type name="gint64" c:type="gint64"/>
          </field>
          <field name="running" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="19">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
      <field name="priv">
        <type name="BaseSinkPrivate" c:type="GstBaseSinkPrivate*"/>
      </field>
    </class>
    <record name="BaseSinkClass"
            c:type="GstBaseSinkClass"
            glib:is-gtype-struct-for="BaseSink">
      <doc xml:whitespace="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At the minimum, the @render method should be overridden to
output/present buffers.</doc>
      <field name="parent_class">
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="get_caps">
        <callback name="get_caps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_caps">
        <callback name="set_caps">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="buffer_alloc">
        <callback name="buffer_alloc">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_times">
        <callback name="get_times">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="start" transfer-ownership="none">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
            <parameter name="end" transfer-ownership="none">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock">
        <callback name="unlock">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="preroll">
        <callback name="preroll">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="render">
        <callback name="render">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="async_play">
        <callback name="async_play">
          <return-value transfer-ownership="none">
            <type name="Gst.StateChangeReturn" c:type="GstStateChangeReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate_pull">
        <callback name="activate_pull">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="active" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fixate">
        <callback name="fixate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock_stop">
        <callback name="unlock_stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="render_list">
        <callback name="render_list">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer_list" transfer-ownership="none">
              <type name="Gst.BufferList" c:type="GstBufferList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="15">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseSinkPrivate" c:type="GstBaseSinkPrivate" disguised="1">
    </record>
    <class name="BaseSrc"
           c:symbol-prefix="base_src"
           c:type="GstBaseSrc"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstBaseSrc"
           glib:get-type="gst_base_src_get_type"
           glib:type-struct="BaseSrcClass">
      <doc xml:whitespace="preserve">This is a generice base class for source elements. The following
types of sources are supported:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;random access sources like files&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;seekable sources&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;live sources&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
The source can be configured to operate in any #GstFormat with the
gst_base_src_set_format() method. The currently set format determines
the format of the internal #GstSegment and any #GST_EVENT_NEWSEGMENT
events. The default format for #GstBaseSrc is #GST_FORMAT_BYTES.
#GstBaseSrc always supports push mode scheduling. If the following
conditions are met, it also supports pull mode scheduling:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;The format is set to #GST_FORMAT_BYTES (default).&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;#GstBaseSrcClass.is_seekable() returns %TRUE.&lt;/para&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;
Since 0.10.9, any #GstBaseSrc can enable pull based scheduling at any time
by overriding #GstBaseSrcClass.check_get_range() so that it returns %TRUE.
If all the conditions are met for operating in pull mode, #GstBaseSrc is
automatically seekable in push mode as well. The following conditions must
be met to make the element seekable in push mode when the format is not
#GST_FORMAT_BYTES:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;
#GstBaseSrcClass.is_seekable() returns %TRUE.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
#GstBaseSrcClass.query() can convert all supported seek formats to the
internal format as set with gst_base_src_set_format().
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
#GstBaseSrcClass.do_seek() is implemented, performs the seek and returns
%TRUE.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
When the element does not meet the requirements to operate in pull mode, the
offset and length in the #GstBaseSrcClass.create() method should be ignored.
It is recommended to subclass #GstPushSrc instead, in this situation. If the
element can operate in pull mode but only with specific offsets and
lengths, it is allowed to generate an error when the wrong values are passed
to the #GstBaseSrcClass.create() function.
#GstBaseSrc has support for live sources. Live sources are sources that when
paused discard data, such as audio or video capture devices. A typical live
source also produces data at a fixed rate and thus provides a clock to publish
this rate.
Use gst_base_src_set_live() to activate the live source mode.
A live source does not produce data in the PAUSED state. This means that the
#GstBaseSrcClass.create() method will not be called in PAUSED but only in
PLAYING. To signal the pipeline that the element will not produce data, the
return value from the READY to PAUSED state will be
#GST_STATE_CHANGE_NO_PREROLL.
A typical live source will timestamp the buffers it creates with the
current running time of the pipeline. This is one reason why a live source
can only produce data in the PLAYING state, when the clock is actually
distributed and running.
Live sources that synchronize and block on the clock (an audio source, for
example) can since 0.10.12 use gst_base_src_wait_playing() when the
#GstBaseSrcClass.create() function was interrupted by a state change to
PAUSED.
The #GstBaseSrcClass.get_times() method can be used to implement pseudo-live
sources. It only makes sense to implement the #GstBaseSrcClass.get_times()
function if the source is a live source. The #GstBaseSrcClass.get_times()
function should return timestamps starting from 0, as if it were a non-live
source. The base class will make sure that the timestamps are transformed
into the current running_time. The base source will then wait for the
calculated running_time before pushing out the buffer.
For live sources, the base class will by default report a latency of 0.
For pseudo live sources, the base class will by default measure the difference
between the first buffer timestamp and the start time of get_times and will
report this value as the latency.
Subclasses should override the query function when this behaviour is not
acceptable.
There is only support in #GstBaseSrc for exactly one source pad, which
should be named "src". A source implementation (subclass of #GstBaseSrc)
should install a pad template in its class_init function, like so:
|[
static void
my_element_class_init (GstMyElementClass *klass)
{
GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
// srctemplate should be a #GstStaticPadTemplate with direction
// #GST_PAD_SRC and name "src"
gst_element_class_add_pad_template (gstelement_class,
gst_static_pad_template_get (&amp;amp;srctemplate));
// see #GstElementDetails
gst_element_class_set_details (gstelement_class, &amp;amp;details);
}
]|
&lt;refsect2&gt;
&lt;title&gt;Controlled shutdown of live sources in applications&lt;/title&gt;
&lt;para&gt;
Applications that record from a live source may want to stop recording
in a controlled way, so that the recording is stopped, but the data
already in the pipeline is processed to the end (remember that many live
sources would go on recording forever otherwise). For that to happen the
application needs to make the source stop recording and send an EOS
event down the pipeline. The application would then wait for an
EOS message posted on the pipeline's bus to know when all data has
been processed and the pipeline can safely be stopped.
Since GStreamer 0.10.16 an application may send an EOS event to a source
element to make it perform the EOS logic (send EOS event downstream or post a
#GST_MESSAGE_SEGMENT_DONE on the bus). This can typically be done
with the gst_element_send_event() function on the element or its parent bin.
After the EOS has been sent to the element, the application should wait for
an EOS message to be posted on the pipeline's bus. Once this EOS message is
received, it may safely shut down the entire pipeline.
The old behaviour for controlled shutdown introduced since GStreamer 0.10.3
is still available but deprecated as it is dangerous and less flexible.
Last reviewed on 2007-12-19 (0.10.16)
&lt;/para&gt;
&lt;/refsect2&gt;</doc>
      <virtual-method name="check_get_range">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="create">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="do_seek">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="segment" transfer-ownership="none">
            <type name="Gst.Segment" c:type="GstSegment*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fixate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_caps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_size">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_times">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_seekable">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="negotiate">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="newsegment">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="prepare_seek_segment">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="seek" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
          <parameter name="segment" transfer-ownership="none">
            <type name="Gst.Segment" c:type="GstSegment*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_caps">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unlock">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unlock_stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="get_blocksize"
              c:identifier="gst_base_src_get_blocksize"
              version="0.10.22">
        <doc xml:whitespace="preserve">Get the number of bytes that @src will push out with each buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes pushed with each buffer.</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
      </method>
      <method name="get_do_timestamp"
              c:identifier="gst_base_src_get_do_timestamp"
              version="0.10.15">
        <doc xml:whitespace="preserve">Query if @src timestamps outgoing buffers based on the current running_time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the base class will automatically timestamp outgoing buffers.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_live" c:identifier="gst_base_src_is_live">
        <doc xml:whitespace="preserve">Check if an element is in live mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if element is in live mode.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="new_seamless_segment"
              c:identifier="gst_base_src_new_seamless_segment"
              version="0.10.26">
        <doc xml:whitespace="preserve">Prepare a new seamless segment for emission downstream. This function must
only be called by derived sub-classes, and only from the create() function,
as the stream-lock needs to be held.
The format for the new segment will be the current format of the source, as
configured with gst_base_src_set_format()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if preparation of the seamless segment succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new start value for the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">Stop value for the new segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">The position value for the new segent</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_latency"
              c:identifier="gst_base_src_query_latency"
              version="0.10.13">
        <doc xml:whitespace="preserve">Query the source for the latency parameters. @live will be TRUE when @src is
configured as a live source. @min_latency will be set to the difference
between the running time and the timestamp of the first buffer.
This function is mostly used by subclasses.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">if the source is live</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="min_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the min latency of the source</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the max latency of the source</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blocksize"
              c:identifier="gst_base_src_set_blocksize"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the number of bytes that @src will push out with each buffer. When</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="blocksize" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new blocksize in bytes</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_do_timestamp"
              c:identifier="gst_base_src_set_do_timestamp"
              version="0.10.15">
        <doc xml:whitespace="preserve">Configure @src to automatically timestamp outgoing buffers based on the
current running_time of the pipeline. This property is mostly useful for live
sources.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">enable or disable timestamping</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_format"
              c:identifier="gst_base_src_set_format"
              version="0.10.1">
        <doc xml:whitespace="preserve">Sets the default format of the source. This will be the format used
for sending NEW_SEGMENT events and for performing seeks.
If a format of GST_FORMAT_BYTES is set, the element will be able to
operate in pull mode if the #GstBaseSrcClass.is_seekable() returns TRUE.
This function must only be called in states &lt; %GST_STATE_PAUSED.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format to use</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_live" c:identifier="gst_base_src_set_live">
        <doc xml:whitespace="preserve">If the element listens to a live source, @live should
be set to %TRUE.
A live source will not produce data in the PAUSED state and
will therefore not be able to participate in the PREROLL phase
of a pipeline. To signal this fact to the application and the
pipeline, the state change return value of the live source will
be GST_STATE_CHANGE_NO_PREROLL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="live" transfer-ownership="none">
            <doc xml:whitespace="preserve">new live-mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_playing"
              c:identifier="gst_base_src_wait_playing"
              version="0.10.12">
        <doc xml:whitespace="preserve">If the #GstBaseSrcClass.create() method performs its own synchronisation
against the clock it must unblock when going from PLAYING to the PAUSED state
and call this method before continuing to produce the remaining data.
This function will block until a state change to PLAYING happens (in which
case this function returns #GST_FLOW_OK) or the processing must be stopped due
to a state change to READY or a FLUSH event (in which case this function
returns #GST_FLOW_WRONG_STATE).
continue. Any other return value should be returned from the create vmethod.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GST_FLOW_OK if @src is PLAYING and processing can</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
      </method>
      <property name="blocksize" writable="1" transfer-ownership="none">
        <type name="gulong"/>
      </property>
      <property name="do-timestamp" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="num-buffers" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <property name="typefind" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="live_lock">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="live_cond">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="is_live">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="live_running">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="blocksize">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="can_activate_push">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="pad_mode">
        <type name="Gst.ActivateMode" c:type="GstActivateMode"/>
      </field>
      <field name="seekable">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="random_access">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="clock_id">
        <type name="Gst.ClockID" c:type="GstClockID"/>
      </field>
      <field name="end_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="need_newsegment">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="offset">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="size">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="num_buffers">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="num_buffers_left">
        <type name="gint" c:type="gint"/>
      </field>
      <union name="data" c:type="data">
        <record name="ABI" c:type="ABI">
          <field name="typefind" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="running" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="pending_seek" writable="1">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="19">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
      <field name="priv">
        <type name="BaseSrcPrivate" c:type="GstBaseSrcPrivate*"/>
      </field>
    </class>
    <record name="BaseSrcClass"
            c:type="GstBaseSrcClass"
            glib:is-gtype-struct-for="BaseSrc">
      <doc xml:whitespace="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At the minimum, the @create method should be overridden to produce
buffers.</doc>
      <field name="parent_class">
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="get_caps">
        <callback name="get_caps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_caps">
        <callback name="set_caps">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="negotiate">
        <callback name="negotiate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="newsegment">
        <callback name="newsegment">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_times">
        <callback name="get_times">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="start" transfer-ownership="none">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
            <parameter name="end" transfer-ownership="none">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_size">
        <callback name="get_size">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint64" c:type="guint64*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_seekable">
        <callback name="is_seekable">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock">
        <callback name="unlock">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create">
        <callback name="create">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="do_seek">
        <callback name="do_seek">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="segment" transfer-ownership="none">
              <type name="Gst.Segment" c:type="GstSegment*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query">
        <callback name="query">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="check_get_range">
        <callback name="check_get_range">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fixate">
        <callback name="fixate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock_stop">
        <callback name="unlock_stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare_seek_segment">
        <callback name="prepare_seek_segment">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="seek" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
            <parameter name="segment" transfer-ownership="none">
              <type name="Gst.Segment" c:type="GstSegment*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="14">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="BaseSrcFlags" c:type="GstBaseSrcFlags">
      <doc xml:whitespace="preserve">The #GstElement flags that a basesrc element may have.</doc>
      <member name="started"
              value="1048576"
              c:identifier="GST_BASE_SRC_STARTED"/>
      <member name="flag_last"
              value="4194304"
              c:identifier="GST_BASE_SRC_FLAG_LAST"/>
    </bitfield>
    <record name="BaseSrcPrivate" c:type="GstBaseSrcPrivate" disguised="1">
    </record>
    <class name="BaseTransform"
           c:symbol-prefix="base_transform"
           c:type="GstBaseTransform"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstBaseTransform"
           glib:get-type="gst_base_transform_get_type"
           glib:type-struct="BaseTransformClass">
      <doc xml:whitespace="preserve">This base class is for filter elements that process data.
It provides for:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;one sinkpad and one srcpad&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Possible formats on sink and source pad implemented
with custom transform_caps function. By default uses
same format on sink and source.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;Handles state changes&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;Does flushing&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;Push mode&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Pull mode if the sub-class transform can operate on arbitrary data
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;refsect2&gt;
&lt;title&gt;Use Cases&lt;/title&gt;
&lt;para&gt;
&lt;orderedlist&gt;
&lt;listitem&gt;
&lt;itemizedlist&gt;&lt;title&gt;Passthrough mode&lt;/title&gt;
&lt;listitem&gt;&lt;para&gt;
Element has no interest in modifying the buffer. It may want to inspect it,
in which case the element should have a transform_ip function. If there
is no transform_ip function in passthrough mode, the buffer is pushed
intact.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
On the GstBaseTransformClass is the passthrough_on_same_caps variable
which will automatically set/unset passthrough based on whether the
element negotiates the same caps on both pads.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
passthrough_on_same_caps on an element that doesn't implement a
transform_caps function is useful for elements that only inspect data
(such as level)
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;itemizedlist&gt;
&lt;title&gt;Example elements&lt;/title&gt;
&lt;listitem&gt;Level&lt;/listitem&gt;
&lt;listitem&gt;Videoscale, audioconvert, ffmpegcolorspace, audioresample in
certain modes.&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;itemizedlist&gt;
&lt;title&gt;Modifications in-place - input buffer and output buffer are the
same thing.&lt;/title&gt;
&lt;listitem&gt;&lt;para&gt;
The element must implement a transform_ip function.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Output buffer size must &lt;= input buffer size
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
If the always_in_place flag is set, non-writable buffers will be copied
and passed to the transform_ip function, otherwise a new buffer will be
created and the transform function called.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Incoming writable buffers will be passed to the transform_ip function
immediately.  &lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
only implementing transform_ip and not transform implies always_in_place
= TRUE
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;itemizedlist&gt;
&lt;title&gt;Example elements&lt;/title&gt;
&lt;listitem&gt;Volume&lt;/listitem&gt;
&lt;listitem&gt;Audioconvert in certain modes (signed/unsigned
conversion)&lt;/listitem&gt;
&lt;listitem&gt;ffmpegcolorspace in certain modes (endianness
swapping)&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;itemizedlist&gt;
&lt;title&gt;Modifications only to the caps/metadata of a buffer&lt;/title&gt;
&lt;listitem&gt;&lt;para&gt;
The element does not require writable data, but non-writable buffers
should be subbuffered so that the meta-information can be replaced.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Elements wishing to operate in this mode should replace the
prepare_output_buffer method to create subbuffers of the input buffer
and set always_in_place to TRUE
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;itemizedlist&gt;
&lt;title&gt;Example elements&lt;/title&gt;
&lt;listitem&gt;Capsfilter when setting caps on outgoing buffers that have
none.&lt;/listitem&gt;
&lt;listitem&gt;identity when it is going to re-timestamp buffers by
datarate.&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;itemizedlist&gt;&lt;title&gt;Normal mode&lt;/title&gt;
&lt;listitem&gt;&lt;para&gt;
always_in_place flag is not set, or there is no transform_ip function
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Element will receive an input buffer and output buffer to operate on.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Output buffer is allocated by calling the prepare_output_buffer function.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;itemizedlist&gt;
&lt;title&gt;Example elements&lt;/title&gt;
&lt;listitem&gt;Videoscale, ffmpegcolorspace, audioconvert when doing
scaling/conversions&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;itemizedlist&gt;&lt;title&gt;Special output buffer allocations&lt;/title&gt;
&lt;listitem&gt;&lt;para&gt;
Elements which need to do special allocation of their output buffers
other than what gst_buffer_pad_alloc allows should implement a
prepare_output_buffer method, which calls the parent implementation and
passes the newly allocated buffer.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;itemizedlist&gt;
&lt;title&gt;Example elements&lt;/title&gt;
&lt;listitem&gt;efence&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;/orderedlist&gt;
&lt;/para&gt;
&lt;/refsect2&gt;
&lt;refsect2&gt;
&lt;title&gt;Sub-class settable flags on GstBaseTransform&lt;/title&gt;
&lt;para&gt;
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;
&lt;itemizedlist&gt;&lt;title&gt;passthrough&lt;/title&gt;
&lt;listitem&gt;&lt;para&gt;
Implies that in the current configuration, the sub-class is not
interested in modifying the buffers.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Elements which are always in passthrough mode whenever the same caps
has been negotiated on both pads can set the class variable
passthrough_on_same_caps to have this behaviour automatically.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
&lt;itemizedlist&gt;&lt;title&gt;always_in_place&lt;/title&gt;
&lt;listitem&gt;&lt;para&gt;
Determines whether a non-writable buffer will be copied before passing
to the transform_ip function.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Implied TRUE if no transform function is implemented.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Implied FALSE if ONLY transform function is implemented.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
&lt;/para&gt;
&lt;/refsect2&gt;</doc>
      <virtual-method name="accept_caps">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="before_transform">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fixate_caps">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="othercaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_unit_size">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare_output_buffer">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="input" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_caps">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="incaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="outcaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="transform">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="inbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_caps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_ip">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_size">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="othercaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="othersize" transfer-ownership="none">
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="is_in_place" c:identifier="gst_base_transform_is_in_place">
        <doc xml:whitespace="preserve">See if @trans is configured as a in_place transform.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE is the transform is configured in in_place mode.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_passthrough"
              c:identifier="gst_base_transform_is_passthrough">
        <doc xml:whitespace="preserve">See if @trans is configured as a passthrough transform.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE is the transform is configured in passthrough mode.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_qos_enabled"
              c:identifier="gst_base_transform_is_qos_enabled"
              version="0.10.5">
        <doc xml:whitespace="preserve">Queries if the transform will handle QoS.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if QoS is enabled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="reconfigure"
              c:identifier="gst_base_transform_reconfigure"
              version="0.10.21">
        <doc xml:whitespace="preserve">Instructs @trans to renegotiate a new downstream transform on the next
buffer. This function is typically called after properties on the transform
were set that influence the output format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_gap_aware"
              c:identifier="gst_base_transform_set_gap_aware"
              version="0.10.16">
        <doc xml:whitespace="preserve">If @gap_aware is %FALSE (the default), output buffers will have the
%GST_BUFFER_FLAG_GAP flag unset.
If set to %TRUE, the element must handle output buffers with this flag set
correctly, i.e. it can assume that the buffer contains neutral data but must
unset the flag if the output is no neutral data.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gap_aware" transfer-ownership="none">
            <doc xml:whitespace="preserve">New state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_in_place"
              c:identifier="gst_base_transform_set_in_place">
        <doc xml:whitespace="preserve">Determines whether a non-writable buffer will be copied before passing
to the transform_ip function.
&lt;itemizedlist&gt;
&lt;listitem&gt;Always TRUE if no transform function is implemented.&lt;/listitem&gt;
&lt;listitem&gt;Always FALSE if ONLY transform function is implemented.&lt;/listitem&gt;
&lt;/itemizedlist&gt;
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="in_place" transfer-ownership="none">
            <doc xml:whitespace="preserve">Boolean value indicating that we would like to operate on in_place buffers.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_passthrough"
              c:identifier="gst_base_transform_set_passthrough">
        <doc xml:whitespace="preserve">Set passthrough mode for this filter by default. This is mostly
useful for filters that do not care about negotiation.
Always TRUE for filters which don't implement either a transform
or transform_ip method.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="passthrough" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean indicating passthrough mode.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qos_enabled"
              c:identifier="gst_base_transform_set_qos_enabled"
              version="0.10.5">
        <doc xml:whitespace="preserve">Enable or disable QoS handling in the transform.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="suggest"
              c:identifier="gst_base_transform_suggest"
              version="0.10.21">
        <doc xml:whitespace="preserve">Instructs @trans to suggest new @caps upstream. A copy of @caps will be
taken.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">caps to suggest</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">buffer size to suggest</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_qos"
              c:identifier="gst_base_transform_update_qos"
              version="0.10.5">
        <doc xml:whitespace="preserve">Set the QoS parameters in the transform. This function is called internally
when a QOS event is received but subclasses can provide custom information
when needed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="proportion" transfer-ownership="none">
            <doc xml:whitespace="preserve">the proportion</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="diff" transfer-ownership="none">
            <doc xml:whitespace="preserve">the diff against the clock</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timestamp of the buffer generating the QoS expressed in running_time.</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <property name="qos" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="passthrough">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="always_in_place">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="cache_caps1">
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="cache_caps1_size">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="cache_caps2">
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="cache_caps2_size">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="have_same_caps">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="delay_configure">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="pending_configure">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="negotiated">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="have_newsegment">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="transform_lock">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseTransformPrivate" c:type="GstBaseTransformPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="19">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="BaseTransformClass"
            c:type="GstBaseTransformClass"
            glib:is-gtype-struct-for="BaseTransform">
      <doc xml:whitespace="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At minimum either @transform or @transform_ip need to be overridden.
If the element can overwrite the input data with the results (data is of the
same type and quantity) it should provide @transform_ip.</doc>
      <field name="parent_class">
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="transform_caps">
        <callback name="transform_caps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fixate_caps">
        <callback name="fixate_caps">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="othercaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_size">
        <callback name="transform_size">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="othercaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="othersize" transfer-ownership="none">
              <type name="guint" c:type="guint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_unit_size">
        <callback name="get_unit_size">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_caps">
        <callback name="set_caps">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="incaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="outcaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform">
        <callback name="transform">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="inbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="outbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_ip">
        <callback name="transform_ip">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="passthrough_on_same_caps">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="prepare_output_buffer">
        <callback name="prepare_output_buffer">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="input" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_event">
        <callback name="src_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="before_transform">
        <callback name="before_transform">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="accept_caps">
        <callback name="accept_caps">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="17">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseTransformPrivate"
            c:type="GstBaseTransformPrivate"
            disguised="1">
    </record>
    <record name="BitReader" c:type="GstBitReader">
      <doc xml:whitespace="preserve">#GstBitReader provides a bit reader that can read any number of bits
from a memory buffer. It provides functions for reading any number of bits
into 8, 16, 32 and 64 bit variables.</doc>
      <field name="data" writable="1">
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="byte" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="bit" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="free" c:identifier="gst_bit_reader_free" version="0.10.22">
        <doc xml:whitespace="preserve">Frees a #GstBitReader instance, which was previously allocated by
gst_bit_reader_new() or gst_bit_reader_new_from_buffer().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_bits_uint16"
              c:identifier="gst_bit_reader_get_bits_uint16"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bits_uint32"
              c:identifier="gst_bit_reader_get_bits_uint32"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bits_uint64"
              c:identifier="gst_bit_reader_get_bits_uint64"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bits_uint8"
              c:identifier="gst_bit_reader_get_bits_uint8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pos"
              c:identifier="gst_bit_reader_get_pos"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns the current position of a #GstBitReader instance in bits.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current position of @reader in bits.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_remaining"
              c:identifier="gst_bit_reader_get_remaining"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns the remaining number of bits of a #GstBitReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The remaining number of bits of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_size"
              c:identifier="gst_bit_reader_get_size"
              version="0.10.26">
        <doc xml:whitespace="preserve">Returns the total number of bits of a #GstBitReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The total number of bits of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="init" c:identifier="gst_bit_reader_init" version="0.10.22">
        <doc xml:whitespace="preserve">Initializes a #GstBitReader instance to read from @data. This function
can be called on already initialized instances.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data from which the bit reader should read</doc>
            <array length="1" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_buffer"
              c:identifier="gst_bit_reader_init_from_buffer"
              version="0.10.22">
        <doc xml:whitespace="preserve">Initializes a #GstBitReader instance to read from @buffer. This function
can be called on already initialized instances.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">Buffer from which the #GstBitReader should read</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint16"
              c:identifier="gst_bit_reader_peek_bits_uint16"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint32"
              c:identifier="gst_bit_reader_peek_bits_uint32"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint64"
              c:identifier="gst_bit_reader_peek_bits_uint64"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint8"
              c:identifier="gst_bit_reader_peek_bits_uint8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read @nbits bits into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos"
              c:identifier="gst_bit_reader_set_pos"
              version="0.10.22">
        <doc xml:whitespace="preserve">Sets the new position of a #GstBitReader instance to @pos in bits.
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the position could be set successfully, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new position in bits</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip" c:identifier="gst_bit_reader_skip" version="0.10.22">
        <doc xml:whitespace="preserve">Skips @nbits bits of the #GstBitReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @nbits bits could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bits to skip</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip_to_byte"
              c:identifier="gst_bit_reader_skip_to_byte"
              version="0.10.22">
        <doc xml:whitespace="preserve">Skips until the next byte.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </record>
    <record name="ByteReader" c:type="GstByteReader">
      <doc xml:whitespace="preserve">#GstByteReader provides a byte reader that can read different integer and
floating point types from a memory buffer. It provides functions for reading
signed/unsigned, little/big endian integers of 8, 16, 24, 32 and 64 bits
and functions for reading little/big endian floating points numbers of
32 and 64 bits. It also provides functions to read NUL-terminated strings
in various character encodings.</doc>
      <field name="data" writable="1">
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="byte" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="dup_data"
              c:identifier="gst_byte_reader_dup_data"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns a newly-allocated copy of the current data
position if at least @size bytes are left and
updates the current position. Free with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Size in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a #guint8 pointer variable in which to store the result</doc>
            <array length="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="dup_string_utf16"
              c:identifier="gst_byte_reader_dup_string_utf16"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns a newly-allocated copy of the current data position if there is
a NUL-terminated UTF-16 string in the data (this could be an empty string
as well), and advances the current position.
No input checking for valid UTF-16 is done. This function is endianness
agnostic - you should not assume the UTF-16 characters are in host
endianness.
This function will fail if no NUL-terminator was found in in the data.
byte alignment of the UTF-16 string.
string put into @str must be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be read, %FALSE otherwise. The</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a #guint16 pointer varieble in which to store the result</doc>
            <array c:type="guint16**">
              <type name="guint16" c:type="guint16*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="dup_string_utf32"
              c:identifier="gst_byte_reader_dup_string_utf32"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns a newly-allocated copy of the current data position if there is
a NUL-terminated UTF-32 string in the data (this could be an empty string
as well), and advances the current position.
No input checking for valid UTF-32 is done. This function is endianness
agnostic - you should not assume the UTF-32 characters are in host
endianness.
This function will fail if no NUL-terminator was found in in the data.
byte alignment of the UTF-32 string.
string put into @str must be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be read, %FALSE otherwise. The</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a #guint32 pointer varieble in which to store the result</doc>
            <array c:type="guint32**">
              <type name="guint32" c:type="guint32*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="dup_string_utf8"
              c:identifier="gst_byte_reader_dup_string_utf8"
              version="0.10.24">
        <doc xml:whitespace="preserve">FIXME:Reads (copies) a NUL-terminated string in the #GstByteReader instance,
advancing the current position to the byte after the string. This will work
for any NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc. No input checking for valid UTF-8 is done.
This function will fail if no NUL-terminator was found in in the data.
string put into @str must be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be read into @str, %FALSE otherwise. The</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a #gchar pointer varieble in which to store the result</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="gst_byte_reader_free"
              version="0.10.22">
        <doc xml:whitespace="preserve">Frees a #GstByteReader instance, which was previously allocated by
gst_byte_reader_new() or gst_byte_reader_new_from_buffer().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_data"
              c:identifier="gst_byte_reader_get_data"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns a constant pointer to the current data
position if at least @size bytes are left and
updates the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Size in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">address of a #guint8 pointer variable in which to store the result</doc>
            <array length="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_float32_be"
              c:identifier="gst_byte_reader_get_float32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 32 bit big endian floating point value into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float32_le"
              c:identifier="gst_byte_reader_get_float32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 32 bit little endian floating point value into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float64_be"
              c:identifier="gst_byte_reader_get_float64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 64 bit big endian floating point value into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float64_le"
              c:identifier="gst_byte_reader_get_float64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 64 bit little endian floating point value into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int16_be"
              c:identifier="gst_byte_reader_get_int16_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 16 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int16_le"
              c:identifier="gst_byte_reader_get_int16_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 16 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int24_be"
              c:identifier="gst_byte_reader_get_int24_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 24 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int24_le"
              c:identifier="gst_byte_reader_get_int24_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 24 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int32_be"
              c:identifier="gst_byte_reader_get_int32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 32 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int32_le"
              c:identifier="gst_byte_reader_get_int32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 32 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64_be"
              c:identifier="gst_byte_reader_get_int64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 64 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64_le"
              c:identifier="gst_byte_reader_get_int64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 64 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int8"
              c:identifier="gst_byte_reader_get_int8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 8 bit integer into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint8 to store the result</doc>
            <type name="gint8" c:type="gint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pos"
              c:identifier="gst_byte_reader_get_pos"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns the current position of a #GstByteReader instance in bytes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current position of @reader in bytes.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_remaining"
              c:identifier="gst_byte_reader_get_remaining"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns the remaining number of bytes of a #GstByteReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The remaining number of bytes of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_size"
              c:identifier="gst_byte_reader_get_size"
              version="0.10.26">
        <doc xml:whitespace="preserve">Returns the total number of bytes of a #GstByteReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The total number of bytes of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_string_utf8"
              c:identifier="gst_byte_reader_get_string_utf8"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns a constant pointer to the current data position if there is
a NUL-terminated string in the data (this could be just a NUL terminator),
advancing the current position to the byte after the string. This will work
for any NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc.
No input checking for valid UTF-8 is done.
This function will fail if no NUL-terminator was found in in the data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be found, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">address of a #gchar pointer varieble in which to store the result</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint16_be"
              c:identifier="gst_byte_reader_get_uint16_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 16 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint16_le"
              c:identifier="gst_byte_reader_get_uint16_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 16 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint24_be"
              c:identifier="gst_byte_reader_get_uint24_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 24 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint24_le"
              c:identifier="gst_byte_reader_get_uint24_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 24 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint32_be"
              c:identifier="gst_byte_reader_get_uint32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 32 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint32_le"
              c:identifier="gst_byte_reader_get_uint32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 32 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64_be"
              c:identifier="gst_byte_reader_get_uint64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 64 bit big endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64_le"
              c:identifier="gst_byte_reader_get_uint64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 64 bit little endian integer into @val
and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint8"
              c:identifier="gst_byte_reader_get_uint8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 8 bit integer into @val and update the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init"
              c:identifier="gst_byte_reader_init"
              version="0.10.22">
        <doc xml:whitespace="preserve">Initializes a #GstByteReader instance to read from @data. This function
can be called on already initialized instances.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data from which the #GstByteReader should read</doc>
            <array length="1" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_buffer"
              c:identifier="gst_byte_reader_init_from_buffer"
              version="0.10.22">
        <doc xml:whitespace="preserve">Initializes a #GstByteReader instance to read from @buffer. This function
can be called on already initialized instances.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">Buffer from which the #GstByteReader should read</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="masked_scan_uint32"
              c:identifier="gst_byte_reader_masked_scan_uint32"
              version="0.10.24">
        <doc xml:whitespace="preserve">Scan for pattern @pattern with applied mask @mask in the byte reader data,
starting from offset @offset relative to the current position.
The bytes in @pattern and @mask are interpreted left-to-right, regardless
of endianness.  All four bytes of the pattern must be present in the
byte reader data for it to match, even if the first or last bytes are masked
out.
It is an error to call this function without making sure that there is
enough data (offset+size bytes) in the byte reader.
Example:
&lt;programlisting&gt;
// Assume the reader contains 0x00 0x01 0x02 ... 0xfe 0xff
gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x00010203, 0, 256);
// -&gt; returns 0
gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x00010203, 1, 255);
// -&gt; returns -1
gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x01020304, 1, 255);
// -&gt; returns 1
gst_byte_reader_masked_scan_uint32 (reader, 0xffff, 0x0001, 0, 256);
// -&gt; returns -1
gst_byte_reader_masked_scan_uint32 (reader, 0xffff, 0x0203, 0, 256);
// -&gt; returns 0
gst_byte_reader_masked_scan_uint32 (reader, 0xffff0000, 0x02030000, 0, 256);
// -&gt; returns 2
gst_byte_reader_masked_scan_uint32 (reader, 0xffff0000, 0x02030000, 0, 4);
// -&gt; returns -1
&lt;/programlisting&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">offset of the first match, or -1 if no match was found.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:whitespace="preserve">mask to apply to data before matching against @pattern</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:whitespace="preserve">pattern to match (after mask is applied)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">offset from which to start scanning, relative to the current position</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bytes to scan from offset</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_data"
              c:identifier="gst_byte_reader_peek_data"
              version="0.10.22">
        <doc xml:whitespace="preserve">Returns a constant pointer to the current data
position if at least @size bytes are left and
keeps the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Size in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">address of a #guint8 pointer variable in which to store the result</doc>
            <array length="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float32_be"
              c:identifier="gst_byte_reader_peek_float32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 32 bit big endian floating point value into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float32_le"
              c:identifier="gst_byte_reader_peek_float32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 32 bit little endian floating point value into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float64_be"
              c:identifier="gst_byte_reader_peek_float64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 64 bit big endian floating point value into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float64_le"
              c:identifier="gst_byte_reader_peek_float64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a 64 bit little endian floating point value into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int16_be"
              c:identifier="gst_byte_reader_peek_int16_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 16 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int16_le"
              c:identifier="gst_byte_reader_peek_int16_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 16 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int24_be"
              c:identifier="gst_byte_reader_peek_int24_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 24 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int24_le"
              c:identifier="gst_byte_reader_peek_int24_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 24 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int32_be"
              c:identifier="gst_byte_reader_peek_int32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 32 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int32_le"
              c:identifier="gst_byte_reader_peek_int32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 32 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int64_be"
              c:identifier="gst_byte_reader_peek_int64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 64 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int64_le"
              c:identifier="gst_byte_reader_peek_int64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 64 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int8"
              c:identifier="gst_byte_reader_peek_int8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read a signed 8 bit integer into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #gint8 to store the result</doc>
            <type name="gint8" c:type="gint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_string_utf8"
              c:identifier="gst_byte_reader_peek_string_utf8"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns a constant pointer to the current data position if there is
a NUL-terminated string in the data (this could be just a NUL terminator).
The current position will be maintained. This will work for any
NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc.
No input checking for valid UTF-8 is done.
This function will fail if no NUL-terminator was found in in the data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">address of a #gchar pointer varieble in which to store the result</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint16_be"
              c:identifier="gst_byte_reader_peek_uint16_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 16 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint16_le"
              c:identifier="gst_byte_reader_peek_uint16_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 16 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint24_be"
              c:identifier="gst_byte_reader_peek_uint24_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 24 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint24_le"
              c:identifier="gst_byte_reader_peek_uint24_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 24 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint32_be"
              c:identifier="gst_byte_reader_peek_uint32_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 32 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint32_le"
              c:identifier="gst_byte_reader_peek_uint32_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 32 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint64_be"
              c:identifier="gst_byte_reader_peek_uint64_be"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 64 bit big endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint64_le"
              c:identifier="gst_byte_reader_peek_uint64_le"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 64 bit little endian integer into @val
but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint8"
              c:identifier="gst_byte_reader_peek_uint8"
              version="0.10.22">
        <doc xml:whitespace="preserve">Read an unsigned 8 bit integer into @val but keep the current position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos"
              c:identifier="gst_byte_reader_set_pos"
              version="0.10.22">
        <doc xml:whitespace="preserve">Sets the new position of a #GstByteReader instance to @pos in bytes.
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the position could be set successfully, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new position in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip"
              c:identifier="gst_byte_reader_skip"
              version="0.10.22">
        <doc xml:whitespace="preserve">Skips @nbytes bytes of the #GstByteReader instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @nbytes bytes could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to skip</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip_string_utf16"
              c:identifier="gst_byte_reader_skip_string_utf16"
              version="0.10.24">
        <doc xml:whitespace="preserve">Skips a NUL-terminated UTF-16 string in the #GstByteReader instance,
advancing the current position to the byte after the string.
No input checking for valid UTF-16 is done.
This function will fail if no NUL-terminator was found in in the data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="skip_string_utf32"
              c:identifier="gst_byte_reader_skip_string_utf32"
              version="0.10.24">
        <doc xml:whitespace="preserve">Skips a NUL-terminated UTF-32 string in the #GstByteReader instance,
advancing the current position to the byte after the string.
No input checking for valid UTF-32 is done.
This function will fail if no NUL-terminator was found in in the data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="skip_string_utf8"
              c:identifier="gst_byte_reader_skip_string_utf8"
              version="0.10.24">
        <doc xml:whitespace="preserve">Skips a NUL-terminated string in the #GstByteReader instance, advancing
the current position to the byte after the string. This will work for
any NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc. No input checking for valid UTF-8 is done.
This function will fail if no NUL-terminator was found in in the data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </record>
    <record name="ByteWriter" c:type="GstByteWriter">
      <doc xml:whitespace="preserve">#GstByteWriter provides a byte writer and reader that can write/read different
integer and floating point types to/from a memory buffer. It provides functions
for writing/reading signed/unsigned, little/big endian integers of 8, 16, 24,
32 and 64 bits and functions for reading little/big endian floating points numbers of
32 and 64 bits. It also provides functions to write/read NUL-terminated strings
in various character encodings.</doc>
      <field name="parent" writable="1">
        <type name="ByteReader" c:type="GstByteReader"/>
      </field>
      <field name="alloc_size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="fixed" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="owned" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <method name="ensure_free_space"
              c:identifier="gst_byte_writer_ensure_free_space"
              version="0.10.26">
        <doc xml:whitespace="preserve">Checks if enough free space from the current write cursor is
available and reallocates if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if at least @size bytes are still available</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Number of bytes that should be available</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="fill"
              c:identifier="gst_byte_writer_fill"
              version="0.10.27">
        <doc xml:whitespace="preserve">Writes @size bytes containing @value to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to be writen</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Number of bytes to be writen</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="gst_byte_writer_free"
              version="0.10.26">
        <doc xml:whitespace="preserve">Frees @writer and all memory allocated by it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="free_and_get_buffer"
              c:identifier="gst_byte_writer_free_and_get_buffer"
              version="0.10.26">
        <doc xml:whitespace="preserve">Frees @writer and all memory allocated by it except
the current data, which is returned as #GstBuffer.
after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current data as buffer. gst_buffer_unref()</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="free_and_get_data"
              c:identifier="gst_byte_writer_free_and_get_data"
              version="0.10.26">
        <doc xml:whitespace="preserve">Frees @writer and all memory allocated by it except
the current data, which is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current data. g_free() after usage.</doc>
          <type name="guint8" c:type="guint8*"/>
        </return-value>
      </method>
      <method name="get_remaining"
              c:identifier="gst_byte_writer_get_remaining"
              version="0.10.26">
        <doc xml:whitespace="preserve">Returns the remaining size of data that can still be written. If
-1 is returned the remaining size is only limited by system resources.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the remaining size of data that can still be written</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="init"
              c:identifier="gst_byte_writer_init"
              version="0.10.26">
        <doc xml:whitespace="preserve">Initializes @writer to an empty instance</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="init_with_buffer"
              c:identifier="gst_byte_writer_init_with_buffer"
              version="0.10.26">
        <doc xml:whitespace="preserve">Initializes @writer with the given
buffer. If @initialized is %TRUE it is possible to
read the complete buffer from the #GstByteWriter from the beginning.
&lt;note&gt;@buffer must be writable&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">Buffer used for writing</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="initialized" transfer-ownership="none">
            <doc xml:whitespace="preserve">If %TRUE the complete data can be read from the beginning</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_with_data"
              c:identifier="gst_byte_writer_init_with_data"
              version="0.10.26">
        <doc xml:whitespace="preserve">Initializes @writer with the given
memory area. If @initialized is %TRUE it is possible to
read @size bytes from the #GstByteWriter from the beginning.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Memory area for writing</doc>
            <array length="1" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="initialized" transfer-ownership="none">
            <doc xml:whitespace="preserve">If %TRUE the complete data can be read from the beginning</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_with_size"
              c:identifier="gst_byte_writer_init_with_size"
              version="0.10.26">
        <doc xml:whitespace="preserve">Initializes @writer with the given initial data size.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Initial size of data</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="fixed" transfer-ownership="none">
            <doc xml:whitespace="preserve">If %TRUE the data can't be reallocated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_data"
              c:identifier="gst_byte_writer_put_data"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes @size bytes of @data to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to write</doc>
            <array length="1" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float32_be"
              c:identifier="gst_byte_writer_put_float32_be"
              version="0.10.27">
        <doc xml:whitespace="preserve">Writes a big endian 32 bit float to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float32_le"
              c:identifier="gst_byte_writer_put_float32_le"
              version="0.10.27">
        <doc xml:whitespace="preserve">Writes a little endian 32 bit float to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float64_be"
              c:identifier="gst_byte_writer_put_float64_be"
              version="0.10.27">
        <doc xml:whitespace="preserve">Writes a big endian 64 bit float to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float64_le"
              c:identifier="gst_byte_writer_put_float64_le"
              version="0.10.27">
        <doc xml:whitespace="preserve">Writes a little endian 64 bit float to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int16_be"
              c:identifier="gst_byte_writer_put_int16_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed big endian 16 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint16" c:type="gint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int16_le"
              c:identifier="gst_byte_writer_put_int16_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed little endian 16 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint16" c:type="gint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int24_be"
              c:identifier="gst_byte_writer_put_int24_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed big endian 24 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int24_le"
              c:identifier="gst_byte_writer_put_int24_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed little endian 24 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int32_be"
              c:identifier="gst_byte_writer_put_int32_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed big endian 32 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int32_le"
              c:identifier="gst_byte_writer_put_int32_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed little endian 32 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int64_be"
              c:identifier="gst_byte_writer_put_int64_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed big endian 64 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int64_le"
              c:identifier="gst_byte_writer_put_int64_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed little endian 64 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int8"
              c:identifier="gst_byte_writer_put_int8"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a signed 8 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="gint8" c:type="gint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_string_utf16"
              c:identifier="gst_byte_writer_put_string_utf16"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a NUL-terminated UTF16 string to @writer (including the terminator).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">UTF16 string to write</doc>
            <array c:type="guint16*">
              <type name="guint16" c:type="guint16"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="put_string_utf32"
              c:identifier="gst_byte_writer_put_string_utf32"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a NUL-terminated UTF32 string to @writer (including the terminator).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">UTF32 string to write</doc>
            <array c:type="guint32*">
              <type name="guint32" c:type="guint32"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="put_string_utf8"
              c:identifier="gst_byte_writer_put_string_utf8"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a NUL-terminated UTF8 string to @writer (including the terminator).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">UTF8 string to write</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint16_be"
              c:identifier="gst_byte_writer_put_uint16_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned big endian 16 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint16_le"
              c:identifier="gst_byte_writer_put_uint16_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned little endian 16 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint24_be"
              c:identifier="gst_byte_writer_put_uint24_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned big endian 24 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint24_le"
              c:identifier="gst_byte_writer_put_uint24_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned little endian 24 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint32_be"
              c:identifier="gst_byte_writer_put_uint32_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned big endian 32 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint32_le"
              c:identifier="gst_byte_writer_put_uint32_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned little endian 32 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint64_be"
              c:identifier="gst_byte_writer_put_uint64_be"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned big endian 64 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint64_le"
              c:identifier="gst_byte_writer_put_uint64_le"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned little endian 64 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint8"
              c:identifier="gst_byte_writer_put_uint8"
              version="0.10.26">
        <doc xml:whitespace="preserve">Writes a unsigned 8 bit integer to @writer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value to write</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset"
              c:identifier="gst_byte_writer_reset"
              version="0.10.26">
        <doc xml:whitespace="preserve">Resets @writer and frees the data if it's
owned by @writer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="reset_and_get_buffer"
              c:identifier="gst_byte_writer_reset_and_get_buffer"
              version="0.10.26">
        <doc xml:whitespace="preserve">Resets @writer and returns the current data as buffer.
after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current data as buffer. gst_buffer_unref()</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="reset_and_get_data"
              c:identifier="gst_byte_writer_reset_and_get_data"
              version="0.10.26">
        <doc xml:whitespace="preserve">Resets @writer and returns the current data.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current data. g_free() after usage.</doc>
          <type name="guint8" c:type="guint8*"/>
        </return-value>
      </method>
    </record>
    <record name="CollectData" c:type="GstCollectData">
      <doc xml:whitespace="preserve">Structure used by the collect_pads.</doc>
      <field name="collect" writable="1">
        <type name="CollectPads" c:type="GstCollectPads*"/>
      </field>
      <field name="pad" writable="1">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="buffer" writable="1">
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="pos" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="segment" writable="1">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="flushing" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="new_segment" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="eos" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="refcount" writable="1">
            <type name="gint" c:type="gint"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="4">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
    </record>
    <callback name="CollectDataDestroyNotify"
              c:type="GstCollectDataDestroyNotify"
              version="0.10.12">
      <doc xml:whitespace="preserve">A function that will be called when the #GstCollectData will be freed.
It is passed the pointer to the structure and should free any custom
memory and resources allocated for it.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstCollectData that will be freed</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="CollectPads"
           c:symbol-prefix="collect_pads"
           c:type="GstCollectPads"
           parent="Gst.Object"
           glib:type-name="GstCollectPads"
           glib:get-type="gst_collect_pads_get_type"
           glib:type-struct="CollectPadsClass">
      <doc xml:whitespace="preserve">Manages a set of pads that operate in collect mode. This means that control
is given to the manager of this object when all pads have data.
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;
Collectpads are created with gst_collect_pads_new(). A callback should then
be installed with gst_collect_pads_set_function ().
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Pads are added to the collection with gst_collect_pads_add_pad()/
gst_collect_pads_remove_pad(). The pad
has to be a sinkpad. The chain and event functions of the pad are
overridden. The element_private of the pad is used to store
private information for the collectpads.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
For each pad, data is queued in the _chain function or by
performing a pull_range.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
When data is queued on all pads, the callback function is called.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Data can be dequeued from the pad with the gst_collect_pads_pop() method.
One can peek at the data with the gst_collect_pads_peek() function.
These functions will return NULL if the pad received an EOS event. When all
pads return NULL from a gst_collect_pads_peek(), the element can emit an EOS
event itself.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Data can also be dequeued in byte units using the gst_collect_pads_available(),
gst_collect_pads_read() and gst_collect_pads_flush() calls.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
Elements should call gst_collect_pads_start() and gst_collect_pads_stop() in
their state change functions to start and stop the processing of the collecpads.
The gst_collect_pads_stop() call should be called before calling the parent
element state change function in the PAUSED_TO_READY state change to ensure
no pad is blocked and the element can finish streaming.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
gst_collect_pads_collect() and gst_collect_pads_collect_range() can be used by
elements that start a #GstTask to drive the collect_pads. This feature is however
not yet implemented.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
Last reviewed on 2006-05-10 (0.10.6)</doc>
      <constructor name="new" c:identifier="gst_collect_pads_new">
        <doc xml:whitespace="preserve">Create a new instance of #GstCollectPads.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstCollectPads, or NULL in case of an error.</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </return-value>
      </constructor>
      <method name="add_pad"
              c:identifier="gst_collect_pads_add_pad"
              introspectable="0">
        <doc xml:whitespace="preserve">Add a pad to the collection of collect pads. The pad has to be
a sinkpad. The refcount of the pad is incremented. Use
gst_collect_pads_remove_pad() to remove the pad from the collection
again.
This function will override the chain and event functions of the pad
along with the element_private data, which is used to store private
information for the collectpads.
You specify a size for the returned #GstCollectData structure
so that you can use it to store additional information.
The pad will be automatically activated in push mode when @pads is
started.
This function calls gst_collect_pads_add_pad_full() passing a value of NULL
for destroy_notify.
MT safe.
if wrong parameters are supplied.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #GstCollectData to identify the new pad. Or NULL</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to add</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the returned #GstCollectData structure</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_pad_full"
              c:identifier="gst_collect_pads_add_pad_full"
              version="0.10.12"
              introspectable="0">
        <doc xml:whitespace="preserve">Add a pad to the collection of collect pads. The pad has to be
a sinkpad. The refcount of the pad is incremented. Use
gst_collect_pads_remove_pad() to remove the pad from the collection
again.
You specify a size for the returned #GstCollectData structure
so that you can use it to store additional information.
You can also specify a #GstCollectDataDestroyNotify that will be called
just before the #GstCollectData structure is freed. It is passed the
pointer to the structure and should free any custom memory and resources
allocated for it.
The pad will be automatically activated in push mode when @pads is
started.
MT safe.
if wrong parameters are supplied.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #GstCollectData to identify the new pad. Or NULL</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to add</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the returned #GstCollectData structure</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="destroy_notify" transfer-ownership="none">
            <doc xml:whitespace="preserve">function to be called before the returned #GstCollectData structure is freed</doc>
            <type name="CollectDataDestroyNotify"
                  c:type="GstCollectDataDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="available" c:identifier="gst_collect_pads_available">
        <doc xml:whitespace="preserve">Query how much bytes can be read from each queued buffer. This means
that the result of this call is the maximum number of bytes that can
be read from each of the pads.
This function should be called with @pads LOCK held, such as
in the callback.
MT safe.
returns 0 if a pad has no queued buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The maximum number of bytes queued on all pads. This function</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="collect" c:identifier="gst_collect_pads_collect">
        <doc xml:whitespace="preserve">Collect data on all pads. This function is usually called
from a #GstTask function in an element.
This function is currently not implemented.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstFlowReturn of the operation.</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
      </method>
      <method name="collect_range"
              c:identifier="gst_collect_pads_collect_range">
        <doc xml:whitespace="preserve">Collect data with @offset and @length on all pads. This function
is typically called in the getrange function of an element.
This function is currently not implemented.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstFlowReturn of the operation.</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset to collect</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length to collect</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="gst_collect_pads_flush">
        <doc xml:whitespace="preserve">Flush @size bytes from the pad @data.
This function should be called with @pads LOCK held, such as
in the callback.
MT safe.
is 0 if the pad was end-of-stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of bytes flushed. This can be less than @size and</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to flush</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_active" c:identifier="gst_collect_pads_is_active">
        <doc xml:whitespace="preserve">Check if a pad is active.
This function is currently not implemented.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the pad is active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to check</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="gst_collect_pads_peek">
        <doc xml:whitespace="preserve">Peek at the buffer currently queued in @data. This function
should be called with the @pads LOCK held, such as in the callback
handler.
MT safe.
should unref the buffer after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The buffer in @data or NULL if no buffer is queued.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="gst_collect_pads_pop">
        <doc xml:whitespace="preserve">Pop the buffer currently queued in @data. This function
should be called with the @pads LOCK held, such as in the callback
handler.
MT safe.
queued. You should unref the buffer after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The buffer in @data or NULL if no buffer was</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="gst_collect_pads_read">
        <doc xml:whitespace="preserve">Get a pointer in @bytes where @size bytes can be read from the
given pad @data.
This function should be called with @pads LOCK held, such as
in the callback.
MT safe.
memory pointed to by @bytes. This can be less than @size and
is 0 if the pad is end-of-stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of bytes available for consumption in the</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="bytes"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a byte array</doc>
            <array length="2" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the number of bytes to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_buffer"
              c:identifier="gst_collect_pads_read_buffer"
              version="0.10.18">
        <doc xml:whitespace="preserve">Get a buffer of @size bytes from the given pad @data.
This function should be called with @pads LOCK held, such as in the callback.
that requested. A return of NULL signals that the pad is end-of-stream.
Unref the buffer with gst_buffer_unref() after use.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstBuffer. The size of the buffer can be less</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_pad" c:identifier="gst_collect_pads_remove_pad">
        <doc xml:whitespace="preserve">Remove a pad from the collection of collect pads. This function will also
free the #GstCollectData and all the resources that were allocated with
gst_collect_pads_add_pad().
The pad will be deactivated automatically when @pads is stopped.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the pad could be removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to remove</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_clip_function"
              c:identifier="gst_collect_pads_set_clip_function"
              version="0.10.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Install a clipping function that is called right after a buffer is received
on a pad managed by @pads. See #GstCollectPadsClipFunction for more info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clipfunc" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">clip function to install</doc>
            <type name="CollectPadsClipFunction"
                  c:type="GstCollectPadsClipFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @clip_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing"
              c:identifier="gst_collect_pads_set_flushing"
              version="0.10.7.">
        <doc xml:whitespace="preserve">Change the flushing state of all the pads in the collection. No pad
is able to accept anymore data when @flushing is %TRUE. Calling this
function with @flushing %FALSE makes @pads accept data again.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:whitespace="preserve">desired state of the pads</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_function"
              c:identifier="gst_collect_pads_set_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Set the callback function and user data that will be called when
all the pads added to the collection have buffers queued.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the function to set</doc>
            <type name="CollectPadsFunction" c:type="GstCollectPadsFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="gst_collect_pads_start">
        <doc xml:whitespace="preserve">Starts the processing of data in the collect_pads.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="stop" c:identifier="gst_collect_pads_stop">
        <doc xml:whitespace="preserve">Stops the processing of data in the collect_pads. this function
will also unblock any blocking operations.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="take_buffer"
              c:identifier="gst_collect_pads_take_buffer"
              version="0.10.18">
        <doc xml:whitespace="preserve">Get a buffer of @size bytes from the given pad @data. Flushes the amount
of read bytes.
This function should be called with @pads LOCK held, such as in the callback.
MT safe.
that requested. A return of NULL signals that the pad is end-of-stream.
Unref the buffer after use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstBuffer. The size of the buffer can be less</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="data">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="cookie" readable="0" private="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="cond" readable="0" private="1">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="func" readable="0" private="1">
        <type name="CollectPadsFunction" c:type="GstCollectPadsFunction"/>
      </field>
      <field name="user_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="numpads" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="queuedpads" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="eospads" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="started" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="pad_lock" writable="1">
            <type name="GLib.Mutex" c:type="GMutex*"/>
          </field>
          <field name="pad_list" writable="1">
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </field>
          <field name="pad_cookie" writable="1">
            <type name="guint32" c:type="guint32"/>
          </field>
          <field name="priv" writable="1">
            <type name="CollectPadsPrivate" c:type="GstCollectPadsPrivate*"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="4">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
    </class>
    <record name="CollectPadsClass"
            c:type="GstCollectPadsClass"
            glib:is-gtype-struct-for="CollectPads">
      <field name="parent_class">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="CollectPadsClipFunction"
              c:type="GstCollectPadsClipFunction"
              version="0.10.26"
              introspectable="0">
      <doc xml:whitespace="preserve">A function that will be called when @buffer is received on the pad managed
by @data in the collecpad object @pads.
The function should use the segment of @data and the negotiated media type on
the pad to perform clipping of @buffer. 
This function takes ownership of @buffer.
the buffer has been clipped completely.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a #GstBuffer that contains the clipped data of @buffer or NULL when</doc>
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="pads" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstCollectPads</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstCollectData</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CollectPadsFunction" c:type="GstCollectPadsFunction">
      <doc xml:whitespace="preserve">A function that will be called when all pads have received data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GST_FLOW_OK for success</doc>
        <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pads" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstCollectPads that triggered the callback</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">user data passed to gst_collect_pads_set_function()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="CollectPadsPrivate"
            c:type="GstCollectPadsPrivate"
            disguised="1">
    </record>
    <class name="DataQueue"
           c:symbol-prefix="data_queue"
           c:type="GstDataQueue"
           version="0.10.11"
           parent="GObject.Object"
           glib:type-name="GstDataQueue"
           glib:get-type="gst_data_queue_get_type"
           glib:type-struct="DataQueueClass">
      <doc xml:whitespace="preserve">#GstDataQueue is an object that handles threadsafe queueing of objects. It
also provides size-related functionality. This object should be used for
any #GstElement that wishes to provide some sort of queueing functionality.</doc>
      <constructor name="new"
                   c:identifier="gst_data_queue_new"
                   introspectable="0">
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstDataQueue.</doc>
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </return-value>
        <parameters>
          <parameter name="checkfull" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the callback used to tell if the element considers the queue full or not.</doc>
            <type name="DataQueueCheckFullFunction"
                  c:type="GstDataQueueCheckFullFunction"/>
          </parameter>
          <parameter name="checkdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gpointer that will be given in the @checkfull callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full"
                   c:identifier="gst_data_queue_new_full"
                   version="0.10.26"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstDataQueue. The difference with @gst_data_queue_new is that it will
not emit the 'full' and 'empty' signals, but instead calling directly @fullcallback
or @emptycallback.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstDataQueue.</doc>
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </return-value>
        <parameters>
          <parameter name="checkfull" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback used to tell if the element considers the queue full or not.</doc>
            <type name="DataQueueCheckFullFunction"
                  c:type="GstDataQueueCheckFullFunction"/>
          </parameter>
          <parameter name="fullcallback" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback which will be called when the queue is considered full.</doc>
            <type name="DataQueueFullCallback"
                  c:type="GstDataQueueFullCallback"/>
          </parameter>
          <parameter name="emptycallback"
                     transfer-ownership="none"
                     closure="3">
            <doc xml:whitespace="preserve">the callback which will be called when the queue is considered empty.</doc>
            <type name="DataQueueEmptyCallback"
                  c:type="GstDataQueueEmptyCallback"/>
          </parameter>
          <parameter name="checkdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gpointer that will be given in the @checkfull callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="empty">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="full">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <method name="drop_head"
              c:identifier="gst_data_queue_drop_head"
              version="0.10.11">
        <doc xml:whitespace="preserve">Pop and unref the head-most #GstMiniObject with the given #GType.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if an element was removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GType of the item to drop.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush"
              c:identifier="gst_data_queue_flush"
              version="0.10.11">
        <doc xml:whitespace="preserve">Flushes all the contents of the @queue. Any call to #gst_data_queue_push and
#gst_data_queue_pop will be released.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_level"
              c:identifier="gst_data_queue_get_level"
              version="0.10.11">
        <doc xml:whitespace="preserve">Get the current level of the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="level" transfer-ownership="none">
            <doc xml:whitespace="preserve">the location to store the result</doc>
            <type name="DataQueueSize" c:type="GstDataQueueSize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="gst_data_queue_is_empty"
              version="0.10.11">
        <doc xml:whitespace="preserve">Queries if there are any items in the @queue.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if @queue is empty.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_full"
              c:identifier="gst_data_queue_is_full"
              version="0.10.11">
        <doc xml:whitespace="preserve">Queries if @queue is full. This check will be done using the
#GstDataQueueCheckFullFunction registered with @queue.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if @queue is full.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="limits_changed"
              c:identifier="gst_data_queue_limits_changed"
              version="0.10.11">
        <doc xml:whitespace="preserve">Inform the queue that the limits for the fullness check have changed and that
any blocking gst_data_queue_push() should be unblocked to recheck the limts.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="pop" c:identifier="gst_data_queue_pop" version="0.10.11">
        <doc xml:whitespace="preserve">Retrieves the first @item available on the @queue. If the queue is currently
empty, the call will block until at least one item is available, OR the
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if an @item was successfully retrieved from the @queue.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="item" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to store the returned #GstDataQueueItem.</doc>
            <type name="DataQueueItem" c:type="GstDataQueueItem**"/>
          </parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="gst_data_queue_push" version="0.10.11">
        <doc xml:whitespace="preserve">Pushes a #GstDataQueueItem (or a structure that begins with the same fields)
on the @queue. If the @queue is full, the call will block until space is
available, OR the @queue is set to flushing state.
MT safe.
Note that this function has slightly different semantics than gst_pad_push()
the #GstMiniObject contained in @item if the push was successful. If FALSE
is returned, the caller is responsible for freeing @item and its contents.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if the @item was successfully pushed on the @queue.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="item" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstDataQueueItem.</doc>
            <type name="DataQueueItem" c:type="GstDataQueueItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing"
              c:identifier="gst_data_queue_set_flushing"
              version="0.10.11">
        <doc xml:whitespace="preserve">Sets the queue to flushing state if @flushing is #TRUE. If set to flushing
state, any incoming data on the @queue will be discarded. Any call currently
blocking on #gst_data_queue_push or #gst_data_queue_pop will return straight
away with a return value of #FALSE. While the @queue is in flushing state, 
all calls to those two functions will return #FALSE.
MT Safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gboolean stating if the queue will be flushing or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="current-level-bytes" transfer-ownership="none">
        <type name="guint"/>
      </property>
      <property name="current-level-time" transfer-ownership="none">
        <type name="guint64"/>
      </property>
      <property name="current-level-visible" transfer-ownership="none">
        <type name="guint"/>
      </property>
      <field name="object">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="queue" readable="0" private="1">
        <type name="GLib.Queue" c:type="GQueue*"/>
      </field>
      <field name="cur_level" readable="0" private="1">
        <type name="DataQueueSize" c:type="GstDataQueueSize"/>
      </field>
      <field name="checkfull" readable="0" private="1">
        <type name="DataQueueCheckFullFunction"
              c:type="GstDataQueueCheckFullFunction"/>
      </field>
      <field name="checkdata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer*"/>
      </field>
      <field name="qlock" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="item_add" readable="0" private="1">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="item_del" readable="0" private="1">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="flushing" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="fullcallback" readable="0" private="1">
        <type name="DataQueueFullCallback" c:type="GstDataQueueFullCallback"/>
      </field>
      <field name="emptycallback" readable="0" private="1">
        <type name="DataQueueEmptyCallback"
              c:type="GstDataQueueEmptyCallback"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="waiting_add" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="waiting_del" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="2">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
      <glib:signal name="empty">
        <doc xml:whitespace="preserve">Reports that the queue became empty (empty).
A queue is empty if the total amount of visible items inside it (num-visible, time,
size) is lower than the boundary values which can be set through the GObject
properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="full">
        <doc xml:whitespace="preserve">Reports that the queue became full (full).
A queue is full if the total amount of data inside it (num-visible, time,
size) is higher than the boundary values which can be set through the GObject
properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </class>
    <callback name="DataQueueCheckFullFunction"
              c:type="GstDataQueueCheckFullFunction"
              version="0.10.11">
      <doc xml:whitespace="preserve">The prototype of the function used to inform the queue that it should be
considered as full.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#TRUE if the queue should be considered full.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="queue" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstDataQueue.</doc>
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </parameter>
        <parameter name="visible" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of visible items currently in the queue.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:whitespace="preserve">The amount of bytes currently in the queue.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="time" transfer-ownership="none">
          <doc xml:whitespace="preserve">The accumulated duration of the items currently in the queue.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="checkdata" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #gpointer registered when the #GstDataQueue was created.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DataQueueClass"
            c:type="GstDataQueueClass"
            glib:is-gtype-struct-for="DataQueue">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="empty">
        <callback name="empty">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="queue" transfer-ownership="none">
              <type name="DataQueue" c:type="GstDataQueue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="full">
        <callback name="full">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="queue" transfer-ownership="none">
              <type name="DataQueue" c:type="GstDataQueue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="DataQueueEmptyCallback" c:type="GstDataQueueEmptyCallback">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="queue" transfer-ownership="none">
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </parameter>
        <parameter name="checkdata" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DataQueueFullCallback" c:type="GstDataQueueFullCallback">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="queue" transfer-ownership="none">
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </parameter>
        <parameter name="checkdata" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DataQueueItem" c:type="GstDataQueueItem" version="0.10.11">
      <doc xml:whitespace="preserve">Structure used by #GstDataQueue. You can supply a different structure, as
long as the top of the structure is identical to this structure.</doc>
      <field name="object" writable="1">
        <type name="Gst.MiniObject" c:type="GstMiniObject*"/>
      </field>
      <field name="size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="duration" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="visible" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="destroy" writable="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
    </record>
    <record name="DataQueueSize" c:type="GstDataQueueSize" version="0.10.11">
      <doc xml:whitespace="preserve">Structure describing the size of a queue.</doc>
      <field name="visible" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="bytes" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="time" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
    </record>
    <class name="PushSrc"
           c:symbol-prefix="push_src"
           c:type="GstPushSrc"
           parent="BaseSrc"
           glib:type-name="GstPushSrc"
           glib:get-type="gst_push_src_get_type"
           glib:type-struct="PushSrcClass">
      <doc xml:whitespace="preserve">This class is mostly useful for elements that cannot do
random access, or at least very slowly. The source usually
prefers to push out a fixed size buffer.
Subclasses usually operate in a format that is different from the
default GST_FORMAT_BYTES format of #GstBaseSrc.
Classes extending this base class will usually be scheduled
in a push based mode. If the peer accepts to operate without
offsets and within the limits of the allowed block size, this
class can operate in getrange based mode automatically. To make
this possible, the subclass should override the ::check_get_range
method.
The subclass should extend the methods from the baseclass in
addition to the ::create method.
Seeking, flushing, scheduling and sync is all handled by this
base class.
Last reviewed on 2006-07-04 (0.10.9)</doc>
      <virtual-method name="create">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="parent">
        <type name="BaseSrc" c:type="GstBaseSrc"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="PushSrcClass"
            c:type="GstPushSrcClass"
            glib:is-gtype-struct-for="PushSrc">
      <field name="parent_class">
        <type name="BaseSrcClass" c:type="GstBaseSrcClass"/>
      </field>
      <field name="create">
        <callback name="create">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="PushSrc" c:type="GstPushSrc*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="TypeFindHelperGetRangeFunction"
              c:type="GstTypeFindHelperGetRangeFunction">
      <doc xml:whitespace="preserve">This function will be called by gst_type_find_helper_get_range() when
typefinding functions request to peek at the data of a stream at certain
offsets. If this function returns GST_FLOW_OK, the result buffer will be
stored in @buffer. The  contents of @buffer is invalid for any other
return value.
This function is supposed to behave exactly like a #GstPadGetRangeFunction.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">GST_FLOW_OK for success</doc>
        <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstObject that will handle the getrange request</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset of the range</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of the range</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a memory location to hold the result buffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer**"/>
        </parameter>
      </parameters>
    </callback>
    <function name="bit_reader_new"
              c:identifier="gst_bit_reader_new"
              version="0.10.22"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new #GstBitReader instance, which will read from @data.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstBitReader instance</doc>
        <type name="BitReader" c:type="GstBitReader*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Data from which the #GstBitReader should read</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of @data in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_reader_new_from_buffer"
              c:identifier="gst_bit_reader_new_from_buffer"
              version="0.10.22"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new #GstBitReader instance, which will read from the
#GstBuffer @buffer.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstBitReader instance</doc>
        <type name="BitReader" c:type="GstBitReader*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">Buffer from which the #GstBitReader should read</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_reader_new"
              c:identifier="gst_byte_reader_new"
              version="0.10.22"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new #GstByteReader instance, which will read from @data.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstByteReader instance</doc>
        <type name="ByteReader" c:type="GstByteReader*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data from which the #GstByteReader should read</doc>
          <array length="1" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of @data in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_reader_new_from_buffer"
              c:identifier="gst_byte_reader_new_from_buffer"
              version="0.10.22"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new #GstByteReader instance, which will read from the
#GstBuffer @buffer.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstByteReader instance</doc>
        <type name="ByteReader" c:type="GstByteReader*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">Buffer from which the #GstByteReader should read</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_writer_new"
              c:identifier="gst_byte_writer_new"
              version="0.10.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new, empty #GstByteWriter instance</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new, empty #GstByteWriter instance</doc>
        <type name="ByteWriter" c:type="GstByteWriter*"/>
      </return-value>
    </function>
    <function name="byte_writer_new_with_buffer"
              c:identifier="gst_byte_writer_new_with_buffer"
              version="0.10.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GstByteWriter instance with the given
buffer. If @initialized is %TRUE it is possible to
read the complete buffer from the #GstByteWriter from the beginning.
&lt;note&gt;@buffer must be writable&lt;/note&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstByteWriter instance</doc>
        <type name="ByteWriter" c:type="GstByteWriter*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">Buffer used for writing</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="initialized" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE the complete data can be read from the beginning</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_writer_new_with_data"
              c:identifier="gst_byte_writer_new_with_data"
              version="0.10.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GstByteWriter instance with the given
memory area. If @initialized is %TRUE it is possible to
read @size bytes from the #GstByteWriter from the beginning.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstByteWriter instance</doc>
        <type name="ByteWriter" c:type="GstByteWriter*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Memory area for writing</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of @data in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="initialized" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE the complete data can be read from the beginning</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_writer_new_with_size"
              c:identifier="gst_byte_writer_new_with_size"
              version="0.10.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GstByteWriter instance with the given
initial data size.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstByteWriter instance</doc>
        <type name="ByteWriter" c:type="GstByteWriter*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Initial size of data</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="fixed" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE the data can't be reallocated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper" c:identifier="gst_type_find_helper">
      <doc xml:whitespace="preserve">Tries to find what type of data is flowing from the given source #GstPad.
Returns #NULL if no #GstCaps matches the data stream.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the #GstCaps corresponding to the data stream.</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">A source #GstPad</doc>
          <type name="Gst.Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">The length in bytes</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_for_buffer"
              c:identifier="gst_type_find_helper_for_buffer">
      <doc xml:whitespace="preserve">Tries to find what type of data is contained in the given #GstBuffer, the
assumption being that the buffer represents the beginning of the stream or
file.
All available typefinders will be called on the data in order of rank. If
a typefinding function returns a probability of #GST_TYPE_FIND_MAXIMUM,
typefinding is stopped immediately and the found caps will be returned
right away. Otherwise, all available typefind functions will the tried,
and the caps with the highest probability will be returned, or #NULL if
the content of the buffer could not be identified.
if no type could be found. The caller should free the caps returned
with gst_caps_unref().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the #GstCaps corresponding to the data, or #NULL</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">object doing the typefinding, or NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstBuffer with data to typefind</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">location to store the probability of the found caps, or #NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_for_extension"
              c:identifier="gst_type_find_helper_for_extension"
              version="0.10.23">
      <doc xml:whitespace="preserve">Tries to find the best #GstCaps associated with @extension.
All available typefinders will be checked against the extension in order
of rank. The caps of the first typefinder that can handle @extension will be
returned.
#NULL if no type could be found. The caller should free the caps
returned with gst_caps_unref().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the #GstCaps corresponding to @extension, or</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">object doing the typefinding, or NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="extension" transfer-ownership="none">
          <doc xml:whitespace="preserve">an extension</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_get_range"
              c:identifier="gst_type_find_helper_get_range">
      <doc xml:whitespace="preserve">Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
however, this function will use the specified function @func to obtain the
data needed by the typefind functions, rather than operating on a given
source pad. This is useful mostly for elements like tag demuxers which
strip off data at the beginning and/or end of a file and want to typefind
the stripped data stream before adding their own source pad (the specified
callback can then call the upstream peer pad with offsets adjusted for the
tag size, for example).
Returns #NULL if no #GstCaps matches the data stream.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the #GstCaps corresponding to the data stream.</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstObject that will be passed as first argument to @func</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">A generic #GstTypeFindHelperGetRangeFunction that will be used to access data at random offsets when doing the typefinding</doc>
          <type name="TypeFindHelperGetRangeFunction"
                c:type="GstTypeFindHelperGetRangeFunction"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">The length in bytes</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">location to store the probability of the found caps, or #NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_get_range_ext"
              c:identifier="gst_type_find_helper_get_range_ext"
              version="0.10.26">
      <doc xml:whitespace="preserve">Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
however, this function will use the specified function @func to obtain the
data needed by the typefind functions, rather than operating on a given
source pad. This is useful mostly for elements like tag demuxers which
strip off data at the beginning and/or end of a file and want to typefind
the stripped data stream before adding their own source pad (the specified
callback can then call the upstream peer pad with offsets adjusted for the
tag size, for example).
When @extension is not NULL, this function will first try the typefind
functions for the given extension, which might speed up the typefinding
in many cases.
Returns #NULL if no #GstCaps matches the data stream.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the #GstCaps corresponding to the data stream.</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstObject that will be passed as first argument to @func</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">A generic #GstTypeFindHelperGetRangeFunction that will be used to access data at random offsets when doing the typefinding</doc>
          <type name="TypeFindHelperGetRangeFunction"
                c:type="GstTypeFindHelperGetRangeFunction"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">The length in bytes</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="extension" transfer-ownership="none">
          <doc xml:whitespace="preserve">extension of the media</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">location to store the probability of the found caps, or #NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
