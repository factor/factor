<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="libxml2" version="2.0"/>
  <package name="gstreamer-0.10"/>
  <c:include name="gst/gst.h"/>
  <namespace name="Gst"
             version="0.10"
             shared-library="libgstreamer-0.10.so.0"
             c:identifier-prefixes="Gst"
             c:symbol-prefixes="gst">
    <alias name="ClockID" c:type="GstClockID">
      <doc xml:whitespace="preserve">A datatype to hold the handle to an outstanding sync or async clock callback.</doc>
      <type name="gpointer" c:type="gpointer"/>
    </alias>
    <alias name="ClockTime" c:type="GstClockTime">
      <doc xml:whitespace="preserve">A datatype to hold a time, measured in nanoseconds.</doc>
      <type name="guint64" c:type="guint64"/>
    </alias>
    <alias name="ClockTimeDiff" c:type="GstClockTimeDiff">
      <doc xml:whitespace="preserve">A datatype to hold a time difference, measured in nanoseconds.</doc>
      <type name="gint64" c:type="gint64"/>
    </alias>
    <alias name="ElementFactoryListType" c:type="GstElementFactoryListType">
      <type name="guint64" c:type="guint64"/>
    </alias>
    <enumeration name="ActivateMode" c:type="GstActivateMode">
      <doc xml:whitespace="preserve">The status of a GstPad. After activating a pad, which usually happens when the
parent element goes from READY to PAUSED, the GstActivateMode defines if the
pad operates in push or pull mode.</doc>
      <member name="none" value="0" c:identifier="GST_ACTIVATE_NONE"/>
      <member name="push" value="1" c:identifier="GST_ACTIVATE_PUSH"/>
      <member name="pull" value="2" c:identifier="GST_ACTIVATE_PULL"/>
    </enumeration>
    <record name="AllocTrace" c:type="GstAllocTrace">
      <doc xml:whitespace="preserve">The main tracing object</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="flags" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="live" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="mem_live" writable="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <method name="print" c:identifier="gst_alloc_trace_print">
        <doc xml:whitespace="preserve">Print the status of the given GstAllocTrace.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_flags" c:identifier="gst_alloc_trace_set_flags">
        <doc xml:whitespace="preserve">Enable the given features on the given GstAllocTrace object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags to set</doc>
            <type name="AllocTraceFlags" c:type="GstAllocTraceFlags"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="AllocTraceFlags" c:type="GstAllocTraceFlags">
      <doc xml:whitespace="preserve">Flags indicating which tracing feature to enable.</doc>
      <member name="live" value="1" c:identifier="GST_ALLOC_TRACE_LIVE"/>
      <member name="mem_live"
              value="2"
              c:identifier="GST_ALLOC_TRACE_MEM_LIVE"/>
    </bitfield>
    <bitfield name="AssocFlags" c:type="GstAssocFlags">
      <doc xml:whitespace="preserve">Flags for an association entry.</doc>
      <member name="none" value="0" c:identifier="GST_ASSOCIATION_FLAG_NONE"/>
      <member name="key_unit"
              value="1"
              c:identifier="GST_ASSOCIATION_FLAG_KEY_UNIT"/>
      <member name="delta_unit"
              value="2"
              c:identifier="GST_ASSOCIATION_FLAG_DELTA_UNIT"/>
      <member name="last"
              value="256"
              c:identifier="GST_ASSOCIATION_FLAG_LAST"/>
    </bitfield>
    <record name="AtomicQueue"
            c:type="GstAtomicQueue"
            disguised="1"
            version="0.10.33">
      <doc xml:whitespace="preserve">The #GstAtomicQueue object implements a queue that can be used from multiple
threads without performing any blocking operations.</doc>
      <method name="length"
              c:identifier="gst_atomic_queue_length"
              version="0.10.33">
        <doc xml:whitespace="preserve">Get the amount of items in the queue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of elements in the queue.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="peek"
              c:identifier="gst_atomic_queue_peek"
              version="0.10.33"
              introspectable="0">
        <doc xml:whitespace="preserve">Peek the head element of the queue without removing it from the queue.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the head element of @queue or NULL when the queue is empty.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="pop"
              c:identifier="gst_atomic_queue_pop"
              version="0.10.33"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the head element of the queue.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the head element of @queue or NULL when the queue is empty.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="push"
              c:identifier="gst_atomic_queue_push"
              version="0.10.33">
        <doc xml:whitespace="preserve">Append @data to the tail of the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gst_atomic_queue_ref" version="0.10.33">
        <doc xml:whitespace="preserve">Increase the refcount of @queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="unref"
              c:identifier="gst_atomic_queue_unref"
              version="0.10.33">
        <doc xml:whitespace="preserve">Unref @queue and free the memory when the refcount reaches 0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <constant name="BUFFER_COPY_ALL" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="BUFFER_OFFSET_NONE" value="-1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="BUFFER_TRACE_NAME" value="GstBuffer">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Bin"
           c:symbol-prefix="bin"
           c:type="GstBin"
           parent="Element"
           glib:type-name="GstBin"
           glib:get-type="gst_bin_get_type"
           glib:type-struct="BinClass">
      <doc xml:whitespace="preserve">#GstBin is an element that can contain other #GstElement, allowing them to be
managed as a group.
Pads from the child elements can be ghosted to the bin, see #GstGhostPad.
This makes the bin look like any other elements and enables creation of
higher-level abstraction elements.
A new #GstBin is created with gst_bin_new(). Use a #GstPipeline instead if you
want to create a toplevel bin because a normal bin doesn't have a bus or
handle clock distribution of its own.
After the bin has been created you will typically add elements to it with
gst_bin_add(). You can remove elements with gst_bin_remove().
An element can be retrieved from a bin with gst_bin_get_by_name(), using the
elements name. gst_bin_get_by_name_recurse_up() is mainly used for internal
purposes and will query the parent bins when the element is not found in the
current bin.
An iterator of elements in a bin can be retrieved with
gst_bin_iterate_elements(). Various other iterators exist to retrieve the
elements in a bin.
gst_object_unref() is used to drop your reference to the bin.
The #GstBin::element-added signal is fired whenever a new element is added to
the bin. Likewise the #GstBin::element-removed signal is fired whenever an
element is removed from the bin.
&lt;refsect2&gt;&lt;title&gt;Notes&lt;/title&gt;
&lt;para&gt;
A #GstBin internally intercepts every #GstMessage posted by its children and
implements the following default behaviour for each of them:
&lt;variablelist&gt;
&lt;varlistentry&gt;
&lt;term&gt;GST_MESSAGE_EOS&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;This message is only posted by sinks in the PLAYING
state. If all sinks posted the EOS message, this bin will post and EOS
message upwards.&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;GST_MESSAGE_SEGMENT_START&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;just collected and never forwarded upwards.
The messages are used to decide when all elements have completed playback
of their segment.&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;GST_MESSAGE_SEGMENT_DONE&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt; Is posted by #GstBin when all elements that posted
a SEGMENT_START have posted a SEGMENT_DONE.&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;GST_MESSAGE_DURATION&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt; Is posted by an element that detected a change
in the stream duration. The default bin behaviour is to clear any
cached duration values so that the next duration query will perform
a full duration recalculation. The duration change is posted to the
application so that it can refetch the new duration with a duration
query. Note that these messages can be posted before the bin is
prerolled, in which case the duration query might fail.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;GST_MESSAGE_CLOCK_LOST&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt; This message is posted by an element when it
can no longer provide a clock. The default bin behaviour is to
check if the lost clock was the one provided by the bin. If so and
the bin is currently in the PLAYING state, the message is forwarded to
the bin parent.
This message is also generated when a clock provider is removed from
the bin. If this message is received by the application, it should
PAUSE the pipeline and set it back to PLAYING to force a new clock
distribution.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;GST_MESSAGE_CLOCK_PROVIDE&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt; This message is generated when an element
can provide a clock. This mostly happens when a new clock
provider is added to the bin. The default behaviour of the bin is to
mark the currently selected clock as dirty, which will perform a clock
recalculation the next time the bin is asked to provide a clock.
This message is never sent tot the application but is forwarded to
the parent of the bin.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;OTHERS&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt; posted upwards.&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;/variablelist&gt;
A #GstBin implements the following default behaviour for answering to a
#GstQuery:
&lt;variablelist&gt;
&lt;varlistentry&gt;
&lt;term&gt;GST_QUERY_DURATION&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;If the query has been asked before with the same format
and the bin is a toplevel bin (ie. has no parent),
use the cached previous value. If no previous value was cached, the
query is sent to all sink elements in the bin and the MAXIMUM of all
values is returned. If the bin is a toplevel bin the value is cached.
If no sinks are available in the bin, the query fails.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;GST_QUERY_POSITION&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;The query is sent to all sink elements in the bin and the
MAXIMUM of all values is returned. If no sinks are available in the bin,
the query fails.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;OTHERS&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;the query is forwarded to all sink elements, the result
of the first sink that answers the query successfully is returned. If no
sink is in the bin, the query fails.&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;/variablelist&gt;
A #GstBin will by default forward any event sent to it to all sink elements.
If all the sinks return TRUE, the bin will also return TRUE, else FALSE is
returned. If no sinks are in the bin, the event handler will return TRUE.
&lt;/para&gt;
&lt;/refsect2&gt;
Last reviewed on 2006-04-28 (0.10.6)</doc>
      <implements name="ChildProxy"/>
      <constructor name="new" c:identifier="gst_bin_new">
        <doc xml:whitespace="preserve">Creates a new bin with the given name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstBin</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the new bin</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="add_element">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="do_latency">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="element_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="element_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_element">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add" c:identifier="gst_bin_add">
        <doc xml:whitespace="preserve">Adds the given element to the bin.  Sets the element's parent, and thus
takes ownership of the element. An element can only be added to one bin.
If the element's pads are linked to other pads, the pads will be unlinked
before the element is added to the bin.
&lt;note&gt;
When you add an element to an already-running pipeline, you will have to
take care to set the state of the newly-added element to the desired
state (usually PLAYING or PAUSED, same you set the pipeline to originally)
with gst_element_set_state(), or use gst_element_sync_state_with_parent().
The bin or pipeline will not take care of this for you.
&lt;/note&gt;
MT safe.
the bin does not want to accept the element.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the element could be added, FALSE if</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstElement to add</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_many"
              c:identifier="gst_bin_add_many"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds a NULL-terminated list of elements to a bin.  This function is
equivalent to calling gst_bin_add() for each member of the list. The return
value of each gst_bin_add() is ignored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="element_1" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstElement element to add to the bin</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="find_unconnected_pad"
              c:identifier="gst_bin_find_unconnected_pad"
              version="0.10.3"
              deprecated="use gst_bin_find_unlinked_pad() instead.">
        <doc xml:whitespace="preserve">Recursively looks for elements with an unlinked pad of the given
direction within the specified bin and returns an unlinked pad
if one is found, or NULL otherwise. If a pad is found, the caller
owns a reference to it and should use gst_object_unref() on the
pad when it is not needed any longer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">unlinked pad of the given direction, or NULL.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to look for an unlinked source or sink pad</doc>
            <type name="PadDirection" c:type="GstPadDirection"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_unlinked_pad"
              c:identifier="gst_bin_find_unlinked_pad"
              version="0.10.20">
        <doc xml:whitespace="preserve">Recursively looks for elements with an unlinked pad of the given
direction within the specified bin and returns an unlinked pad
if one is found, or NULL otherwise. If a pad is found, the caller
owns a reference to it and should use gst_object_unref() on the
pad when it is not needed any longer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">unlinked pad of the given direction, or NULL.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to look for an unlinked source or sink pad</doc>
            <type name="PadDirection" c:type="GstPadDirection"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_by_interface" c:identifier="gst_bin_get_by_interface">
        <doc xml:whitespace="preserve">Looks for an element inside the bin that implements the given
interface. If such an element is found, it returns the element.
You can cast this element to the given interface afterwards.  If you want
all elements that implement the interface, use
gst_bin_iterate_all_by_interface(). This function recurses into child bins.
MT safe.  Caller owns returned reference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GstElement inside the bin implementing the interface</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType of an interface</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_by_name" c:identifier="gst_bin_get_by_name">
        <doc xml:whitespace="preserve">Gets the element with the given name from a bin. This
function recurses into child bins.
Returns NULL if no element with the given name is found in the bin.
MT safe.  Caller owns returned reference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstElement with the given name, or NULL</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the element name to search for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_by_name_recurse_up"
              c:identifier="gst_bin_get_by_name_recurse_up">
        <doc xml:whitespace="preserve">Gets the element with the given name from this bin. If the
element is not found, a recursion is performed on the parent bin.
Returns NULL if:
- no element with the given name is found in the bin
MT safe.  Caller owns returned reference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstElement with the given name, or NULL</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the element name to search for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iterate_all_by_interface"
              c:identifier="gst_bin_iterate_all_by_interface"
              introspectable="0">
        <doc xml:whitespace="preserve">Looks for all elements inside the bin that implements the given
interface. You can safely cast all returned elements to the given interface.
The function recurses inside child bins. The iterator will yield a series
of #GstElement that should be unreffed after use.
Each element yielded by the iterator will have its refcount increased, so
unref after use.
MT safe.  Caller owns returned value.
in the bin implementing the given interface, or NULL</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement for all elements</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType of an interface</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="iterate_elements"
              c:identifier="gst_bin_iterate_elements"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets an iterator for the elements in this bin.
Each element yielded by the iterator will have its refcount increased, so
unref after use.
MT safe.  Caller owns returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement, or NULL</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_recurse"
              c:identifier="gst_bin_iterate_recurse"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets an iterator for the elements in this bin.
This iterator recurses into GstBin children.
Each element yielded by the iterator will have its refcount increased, so
unref after use.
MT safe.  Caller owns returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement, or NULL</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_sinks"
              c:identifier="gst_bin_iterate_sinks"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets an iterator for all elements in the bin that have the
#GST_ELEMENT_IS_SINK flag set.
Each element yielded by the iterator will have its refcount increased, so
unref after use.
MT safe.  Caller owns returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement, or NULL</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_sorted"
              c:identifier="gst_bin_iterate_sorted"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets an iterator for the elements in this bin in topologically
sorted order. This means that the elements are returned from
the most downstream elements (sinks) to the sources.
This function is used internally to perform the state changes
of the bin elements and for clock selection.
Each element yielded by the iterator will have its refcount increased, so
unref after use.
MT safe.  Caller owns returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement, or NULL</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_sources"
              c:identifier="gst_bin_iterate_sources"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets an iterator for all elements in the bin that have the
#GST_ELEMENT_IS_SOURCE flag set.
Each element yielded by the iterator will have its refcount increased, so
unref after use.
MT safe.  Caller owns returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement, or NULL</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="recalculate_latency"
              c:identifier="gst_bin_recalculate_latency"
              version="0.10.22.">
        <doc xml:whitespace="preserve">Query @bin for the current latency using and reconfigures this latency to all the
elements with a LATENCY event.
This method is typically called on the pipeline when a #GST_MESSAGE_LATENCY
is posted on the bus.
This function simply emits the 'do-latency' signal so any custom latency
calculations will be performed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the latency could be queried and reconfigured.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="remove" c:identifier="gst_bin_remove">
        <doc xml:whitespace="preserve">Removes the element from the bin, unparenting it as well.
Unparenting the element means that the element will be dereferenced,
so if the bin holds the only reference to the element, the element
will be freed in the process of removing it from the bin.  If you
want the element to still exist after removing, you need to call
gst_object_ref() before removing it from the bin.
If the element's pads are linked to other pads, the pads will be unlinked
before the element is removed from the bin.
MT safe.
the bin does not want to remove the element.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the element could be removed, FALSE if</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement to remove</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_many"
              c:identifier="gst_bin_remove_many"
              introspectable="0">
        <doc xml:whitespace="preserve">Remove a list of elements from a bin. This function is equivalent
to calling gst_bin_remove() with each member of the list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="element_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first #GstElement to remove from the bin</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <property name="async-handling"
                version="0.10.13"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If set to #TRUE, the bin will handle asynchronous state changes.
This should be used only if the bin subclass is modifying the state
of its children on its own.</doc>
        <type name="gboolean"/>
      </property>
      <property name="message-forward"
                version="0.10.31"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Forward all children messages, even those that would normally be filtered by
the bin. This can be interesting when one wants to be notified of the EOS
state of individual elements, for example.
The messages are converted to an ELEMENT message with the bin as the
source. The structure of the message is named 'GstBinForwarded' and contains
a field named 'message' of type GST_TYPE_MESSAGE that contains the original
forwarded message.</doc>
        <type name="gboolean"/>
      </property>
      <field name="element">
        <type name="Element" c:type="GstElement"/>
      </field>
      <field name="numchildren">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="children">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="children_cookie">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="child_bus">
        <type name="Bus" c:type="GstBus*"/>
      </field>
      <field name="messages">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="polling">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="state_dirty">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="clock_dirty">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="provided_clock">
        <type name="Clock" c:type="GstClock*"/>
      </field>
      <field name="clock_provider">
        <type name="Element" c:type="GstElement*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BinPrivate" c:type="GstBinPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="do-latency" version="0.10.22">
        <doc xml:whitespace="preserve">Will be emitted when the bin needs to perform latency calculations. This
signal is only emited for toplevel bins or when async-handling is
enabled.
Only one signal handler is invoked. If no signals are connected, the
default handler is invoked, which will query and distribute the lowest
possible latency to all sinks.
Connect to this signal if the default latency calculations are not
sufficient, like when you need different latencies for different sinks in
the same pipeline.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean"/>
        </return-value>
      </glib:signal>
      <glib:signal name="element-added">
        <doc xml:whitespace="preserve">Will be emitted after the element was added to the bin.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement that was added to the bin</doc>
            <type name="Element"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="element-removed">
        <doc xml:whitespace="preserve">Will be emitted after the element was removed from the bin.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement that was removed from the bin</doc>
            <type name="Element"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="BinClass"
            c:type="GstBinClass"
            glib:is-gtype-struct-for="Bin">
      <doc xml:whitespace="preserve">Subclasses can override the @add_element and @remove_element to
update the list of children in the bin.
The @handle_message method can be overridden to implement custom
message handling.  @handle_message takes ownership of the message, just like
#gst_element_post_message.</doc>
      <field name="parent_class">
        <type name="ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="pool" readable="0" private="1">
        <type name="GLib.ThreadPool" c:type="GThreadPool*"/>
      </field>
      <field name="element_added">
        <callback name="element_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
            <parameter name="child" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="element_removed">
        <callback name="element_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
            <parameter name="child" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_element">
        <callback name="add_element">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_element">
        <callback name="remove_element">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_message">
        <callback name="handle_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="Message" c:type="GstMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="do_latency">
        <callback name="do_latency">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="BinFlags" c:type="GstBinFlags">
      <doc xml:whitespace="preserve">GstBinFlags are a set of flags specific to bins. Most are set/used
internally. They can be checked using the GST_OBJECT_FLAG_IS_SET () macro,
and (un)set using GST_OBJECT_FLAG_SET () and GST_OBJECT_FLAG_UNSET ().</doc>
      <member name="bin_flag_last"
              value="33554432"
              c:identifier="GST_BIN_FLAG_LAST"/>
    </bitfield>
    <record name="BinPrivate" c:type="GstBinPrivate" disguised="1">
    </record>
    <class name="Buffer"
           c:symbol-prefix="buffer"
           c:type="GstBuffer"
           parent="MiniObject"
           glib:type-name="GstBuffer"
           glib:get-type="gst_buffer_get_type"
           glib:type-struct="BufferClass"
           glib:fundamental="1">
      <doc xml:whitespace="preserve">Buffers are the basic unit of data transfer in GStreamer.  The #GstBuffer
type provides all the state necessary to define a region of memory as part
of a stream.  Sub-buffers are also supported, allowing a smaller region of a
buffer to become its own buffer, with mechanisms in place to ensure that
neither memory space goes away prematurely.
Buffers are usually created with gst_buffer_new(). After a buffer has been
created one will typically allocate memory for it and set the size of the
buffer data.  The following example creates a buffer that can hold a given
video frame with a given width, height and bits per plane.
&lt;example&gt;
&lt;title&gt;Creating a buffer for a video frame&lt;/title&gt;
&lt;programlisting&gt;
GstBuffer *buffer;
gint size, width, height, bpp;
...
size = width * height * bpp;
buffer = gst_buffer_new ();
GST_BUFFER_SIZE (buffer) = size;
GST_BUFFER_MALLOCDATA (buffer) = g_malloc (size);
GST_BUFFER_DATA (buffer) = GST_BUFFER_MALLOCDATA (buffer);
...
&lt;/programlisting&gt;
&lt;/example&gt;
Alternatively, use gst_buffer_new_and_alloc()
to create a buffer with preallocated data of a given size.
The data pointed to by the buffer can be retrieved with the GST_BUFFER_DATA()
macro. The size of the data can be found with GST_BUFFER_SIZE(). For buffers
of size 0, the data pointer is undefined (usually NULL) and should never be used.
If an element knows what pad you will push the buffer out on, it should use
gst_pad_alloc_buffer() instead to create a buffer.  This allows downstream
elements to provide special buffers to write in, like hardware buffers.
A buffer has a pointer to a #GstCaps describing the media type of the data
in the buffer. Attach caps to the buffer with gst_buffer_set_caps(); this
is typically done before pushing out a buffer using gst_pad_push() so that
the downstream element knows the type of the buffer.
A buffer will usually have a timestamp, and a duration, but neither of these
are guaranteed (they may be set to #GST_CLOCK_TIME_NONE). Whenever a
meaningful value can be given for these, they should be set. The timestamp
and duration are measured in nanoseconds (they are #GstClockTime values).
A buffer can also have one or both of a start and an end offset. These are
media-type specific. For video buffers, the start offset will generally be
the frame number. For audio buffers, it will be the number of samples
produced so far. For compressed data, it could be the byte offset in a
source or destination file. Likewise, the end offset will be the offset of
the end of the buffer. These can only be meaningfully interpreted if you
know the media type of the buffer (the #GstCaps set on it). Either or both
can be set to #GST_BUFFER_OFFSET_NONE.
gst_buffer_ref() is used to increase the refcount of a buffer. This must be
done when you want to keep a handle to the buffer after pushing it to the
next element.
To efficiently create a smaller buffer out of an existing one, you can
use gst_buffer_create_sub().
If a plug-in wants to modify the buffer data in-place, it should first obtain
a buffer that is safe to modify by using gst_buffer_make_writable().  This
function is optimized so that a copy will only be made when it is necessary.
A plugin that only wishes to modify the metadata of a buffer, such as the
offset, timestamp or caps, should use gst_buffer_make_metadata_writable(),
which will create a subbuffer of the original buffer to ensure the caller
has sole ownership, and not copy the buffer data.
Several flags of the buffer can be set and unset with the
GST_BUFFER_FLAG_SET() and GST_BUFFER_FLAG_UNSET() macros. Use
GST_BUFFER_FLAG_IS_SET() to test if a certain #GstBufferFlag is set.
Buffers can be efficiently merged into a larger buffer with
gst_buffer_merge() and gst_buffer_span() if the gst_buffer_is_span_fast()
function returns TRUE.
An element should either unref the buffer or push it out on a src pad
using gst_pad_push() (see #GstPad).
Buffers are usually freed by unreffing them with gst_buffer_unref(). When
the refcount drops to 0, any data pointed to by GST_BUFFER_MALLOCDATA() will
also be freed.
Last reviewed on August 11th, 2006 (0.10.10)</doc>
      <constructor name="new" c:identifier="gst_buffer_new">
        <doc xml:whitespace="preserve">Creates a newly allocated buffer without any data.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBuffer.</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
      </constructor>
      <constructor name="new_and_alloc"
                   c:identifier="gst_buffer_new_and_alloc">
        <doc xml:whitespace="preserve">Creates a newly allocated buffer with data of the given size.
The buffer memory is not cleared. If the requested amount of
memory can't be allocated, the program will abort. Use
gst_buffer_try_new_and_alloc() if you want to handle this case
gracefully or have gotten the size to allocate from an untrusted
source such as a media stream.
Note that when @size == 0, the buffer data pointer will be NULL.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBuffer.</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size in bytes of the new buffer's data.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="try_new_and_alloc"
                   c:identifier="gst_buffer_try_new_and_alloc"
                   version="0.10.13">
        <doc xml:whitespace="preserve">Tries to create a newly allocated buffer with data of the given size. If
the requested amount of memory can't be allocated, NULL will be returned.
The buffer memory is not cleared.
Note that when @size == 0, the buffer data pointer will be NULL.
MT safe.
be allocated.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstBuffer, or NULL if the memory couldn't</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size in bytes of the new buffer's data.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy_metadata"
              c:identifier="gst_buffer_copy_metadata"
              version="0.10.13">
        <doc xml:whitespace="preserve">Copies the metadata from @src into @dest. The data, size and mallocdata
fields are not copied.
all the metadata fields.
This function is typically called from a custom buffer copy function after
creating @dest and setting the data, size, mallocdata.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">a source #GstBuffer</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags indicating what metadata fields should be copied.</doc>
            <type name="BufferCopyFlags" c:type="GstBufferCopyFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_sub" c:identifier="gst_buffer_create_sub">
        <doc xml:whitespace="preserve">Creates a sub-buffer from @parent at @offset and @size.
This sub-buffer uses the actual memory space of the parent buffer.
This function will copy the offset and timestamp fields when the
offset is 0. If not, they will be set to #GST_CLOCK_TIME_NONE and 
#GST_BUFFER_OFFSET_NONE.
If @offset equals 0 and @size equals the total size of @buffer, the
duration and offset end fields are also copied. If not they will be set
to #GST_CLOCK_TIME_NONE and #GST_BUFFER_OFFSET_NONE.
MT safe.
invalid.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBuffer or NULL if the arguments were</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset into parent #GstBuffer at which the new sub-buffer begins.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the new #GstBuffer sub-buffer, in bytes.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_caps" c:identifier="gst_buffer_get_caps">
        <doc xml:whitespace="preserve">Gets the media type of the buffer. This can be NULL if there
is no media type attached to this buffer.
Returns NULL if there were no caps on this buffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to the #GstCaps. unref after usage.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="is_metadata_writable"
              c:identifier="gst_buffer_is_metadata_writable">
        <doc xml:whitespace="preserve">Similar to gst_buffer_is_writable, but this only ensures that the
refcount of the buffer is 1, indicating that the caller is the sole
owner and can change the buffer metadata, such as caps and timestamps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the metadata is writable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_span_fast" c:identifier="gst_buffer_is_span_fast">
        <doc xml:whitespace="preserve">Determines whether a gst_buffer_span() can be done without copying
the contents, that is, whether the data areas are contiguous sub-buffers of 
the same buffer.
MT safe.
FALSE if a copy would be required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the buffers are contiguous,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="buf2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second #GstBuffer.</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="join" c:identifier="gst_buffer_join">
        <doc xml:whitespace="preserve">Create a new buffer that is the concatenation of the two source
buffers, and unrefs the original source buffers.
If the buffers point to contiguous areas of memory, the buffer
is created without copying the data.
This is a convenience function for C programmers. See also
gst_buffer_merge(), which does the same thing without
unreffing the input parameters. Language bindings without
explicit reference counting should not wrap this function.
the source buffers.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBuffer which is the concatenation of</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="buf2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second source #GstBuffer.</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_metadata_writable"
              c:identifier="gst_buffer_make_metadata_writable">
        <doc xml:whitespace="preserve">Similar to gst_buffer_make_writable, but does not ensure that the buffer
data array is writable. Instead, this just ensures that the returned buffer
is solely owned by the caller, by creating a subbuffer of the original
buffer if necessary.
After calling this function, @buf should not be referenced anymore. The
result of this function has guaranteed writable metadata.
may or may not be the same as @buf.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstBuffer with writable metadata, which</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="merge" c:identifier="gst_buffer_merge">
        <doc xml:whitespace="preserve">Create a new buffer that is the concatenation of the two source
buffers.  The original source buffers will not be modified or
unref'd.  Make sure you unref the source buffers if they are not used
anymore afterwards.
If the buffers point to contiguous areas of memory, the buffer
is created without copying the data.
of the source buffers.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBuffer which is the concatenation</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="buf2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second source #GstBuffer to merge.</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_caps" c:identifier="gst_buffer_set_caps">
        <doc xml:whitespace="preserve">Sets the media type on the buffer. The refcount of the caps will
be increased and any previous caps on the buffer will be
unreffed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="span" c:identifier="gst_buffer_span">
        <doc xml:whitespace="preserve">Creates a new buffer that consists of part of buf1 and buf2.
Logically, buf1 and buf2 are concatenated into a single larger
buffer, and a new buffer is created at the given offset inside
this space, with a given length.
If the two source buffers are children of the same larger buffer,
and are contiguous, the new buffer will be a child of the shared
parent, and thus no copying is necessary. you can use
gst_buffer_is_span_fast() to determine if a memcpy will be needed.
MT safe.
buffers, or NULL if the arguments are invalid.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBuffer that spans the two source</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset in the first buffer from where the new buffer should start.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="buf2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second source #GstBuffer to merge.</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the total length of the new buffer.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="stamp"
              c:identifier="gst_buffer_stamp"
              deprecated="use gst_buffer_copy_metadata() instead, it provides more">
        <doc xml:whitespace="preserve">Copies additional information (the timestamp, duration, and offset start
and end) from one buffer to the other.
This function does not copy any buffer flags or caps and is equivalent to
gst_buffer_copy_metadata(@dest, @src, GST_BUFFER_COPY_TIMESTAMPS).
control.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">buffer to stamp from</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <field name="mini_object">
        <type name="MiniObject" c:type="GstMiniObject"/>
      </field>
      <field name="data">
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="size">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="timestamp">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="duration">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="caps">
        <type name="Caps" c:type="GstCaps*"/>
      </field>
      <field name="offset">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="offset_end">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="malloc_data">
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="free_func">
        <type name="GLib.FreeFunc" c:type="GFreeFunc"/>
      </field>
      <field name="parent">
        <type name="Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="BufferClass"
            c:type="GstBufferClass"
            glib:is-gtype-struct-for="Buffer">
      <field name="mini_object_class">
        <type name="MiniObjectClass" c:type="GstMiniObjectClass"/>
      </field>
    </record>
    <bitfield name="BufferCopyFlags"
              version="0.10.13"
              c:type="GstBufferCopyFlags">
      <doc xml:whitespace="preserve">A set of flags that can be provided to the gst_buffer_copy_metadata()
function to specify which metadata fields should be copied.</doc>
      <member name="flags" value="1" c:identifier="GST_BUFFER_COPY_FLAGS"/>
      <member name="timestamps"
              value="2"
              c:identifier="GST_BUFFER_COPY_TIMESTAMPS"/>
      <member name="caps" value="4" c:identifier="GST_BUFFER_COPY_CAPS"/>
    </bitfield>
    <bitfield name="BufferFlag" c:type="GstBufferFlag">
      <doc xml:whitespace="preserve">A set of buffer flags used to describe properties of a #GstBuffer.</doc>
      <member name="readonly"
              value="1"
              c:identifier="GST_BUFFER_FLAG_READONLY"/>
      <member name="media4" value="2" c:identifier="GST_BUFFER_FLAG_MEDIA4"/>
      <member name="preroll"
              value="16"
              c:identifier="GST_BUFFER_FLAG_PREROLL"/>
      <member name="discont"
              value="32"
              c:identifier="GST_BUFFER_FLAG_DISCONT"/>
      <member name="in_caps"
              value="64"
              c:identifier="GST_BUFFER_FLAG_IN_CAPS"/>
      <member name="gap" value="128" c:identifier="GST_BUFFER_FLAG_GAP"/>
      <member name="delta_unit"
              value="256"
              c:identifier="GST_BUFFER_FLAG_DELTA_UNIT"/>
      <member name="media1" value="512" c:identifier="GST_BUFFER_FLAG_MEDIA1"/>
      <member name="media2"
              value="1024"
              c:identifier="GST_BUFFER_FLAG_MEDIA2"/>
      <member name="media3"
              value="2048"
              c:identifier="GST_BUFFER_FLAG_MEDIA3"/>
      <member name="last" value="4096" c:identifier="GST_BUFFER_FLAG_LAST"/>
    </bitfield>
    <class name="BufferList"
           c:symbol-prefix="buffer_list"
           c:type="GstBufferList"
           version="0.10.24"
           parent="MiniObject"
           glib:type-name="GstBufferList"
           glib:get-type="gst_buffer_list_get_type"
           glib:type-struct="BufferListClass"
           glib:fundamental="1">
      <doc xml:whitespace="preserve">Buffer lists are units of grouped scatter/gather data transfer in
GStreamer.
Buffer lists are created with gst_buffer_list_new() and filled with data
using a #GstBufferListIterator. The iterator has no current buffer; its
cursor position lies between buffers, immediately before the buffer that
would be returned by gst_buffer_list_iterator_next(). After iterating to the
end of a group the iterator must be advanced to the next group by a call to
gst_buffer_list_iterator_next_group() before any further calls to
gst_buffer_list_iterator_next() can return buffers again. The cursor position
of a newly created iterator lies before the first group; a call to
gst_buffer_list_iterator_next_group() is necessary before calls to
gst_buffer_list_iterator_next() can return buffers.
&lt;informalfigure&gt;
&lt;programlisting&gt;
+--- group0 ----------------------+--- group1 ------------+
|   buffer0   buffer1   buffer2   |   buffer3   buffer4   |
^   ^         ^         ^         ^   ^         ^         ^
Iterator positions between buffers
&lt;/programlisting&gt;
&lt;/informalfigure&gt;
The gst_buffer_list_iterator_remove(), gst_buffer_list_iterator_steal(),
gst_buffer_list_iterator_take() and gst_buffer_list_iterator_do() functions
are not defined in terms of the cursor position; they operate on the last
element returned from gst_buffer_list_iterator_next().
The basic use pattern of creating a buffer list with an iterator is as
follows:
&lt;example&gt;
&lt;title&gt;Creating a buffer list&lt;/title&gt;
&lt;programlisting&gt;
GstBufferList *list;
GstBufferListIterator *it;
list = gst_buffer_list_new ();
it = gst_buffer_list_iterate (list);
gst_buffer_list_iterator_add_group (it);
gst_buffer_list_iterator_add (it, header1);
gst_buffer_list_iterator_add (it, data1);
gst_buffer_list_iterator_add_group (it);
gst_buffer_list_iterator_add (it, header2);
gst_buffer_list_iterator_add (it, data2);
gst_buffer_list_iterator_add_group (it);
gst_buffer_list_iterator_add (it, header3);
gst_buffer_list_iterator_add (it, data3);
...
gst_buffer_list_iterator_free (it);
&lt;/programlisting&gt;
&lt;/example&gt;
The basic use pattern of iterating over a buffer list is as follows:
&lt;example&gt;
&lt;title&gt;Iterating a buffer list&lt;/title&gt;
&lt;programlisting&gt;
GstBufferListIterator *it;
it = gst_buffer_list_iterate (list);
while (gst_buffer_list_iterator_next_group (it)) {
while ((buffer = gst_buffer_list_iterator_next (it)) != NULL) {
do_something_with_buffer (buffer);
}
}
gst_buffer_list_iterator_free (it);
&lt;/programlisting&gt;
&lt;/example&gt;
The basic use pattern of modifying a buffer in a list is as follows:
&lt;example&gt;
&lt;title&gt;Modifying the data of the first buffer in a list&lt;/title&gt;
&lt;programlisting&gt;
GstBufferListIterator *it;
list = gst_buffer_list_make_writable (list);
it = gst_buffer_list_iterate (list);
if (gst_buffer_list_iterator_next_group (it)) {
GstBuffer *buf
buf = gst_buffer_list_iterator_next (it);
if (buf != NULL) {
buf = gst_buffer_list_iterator_do (it,
(GstBufferListDoFunction) gst_mini_object_make_writable, NULL);
modify_data (GST_BUFFER_DATA (buf));
}
}
gst_buffer_list_iterator_free (it);
&lt;/programlisting&gt;
&lt;/example&gt;</doc>
      <constructor name="new"
                   c:identifier="gst_buffer_list_new"
                   version="0.10.24">
        <doc xml:whitespace="preserve">Creates a new, empty #GstBufferList. The caller is responsible for unreffing
the returned #GstBufferList.
after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBufferList. gst_buffer_list_unref()</doc>
          <type name="BufferList" c:type="GstBufferList*"/>
        </return-value>
      </constructor>
      <method name="foreach"
              c:identifier="gst_buffer_list_foreach"
              version="0.10.24">
        <doc xml:whitespace="preserve">Call @func with @data for each buffer in @list.
of @func define if this function returns or if the remaining buffers in a
group should be skipped.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">a #GstBufferListFunc to call</doc>
            <type name="BufferListFunc" c:type="GstBufferListFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="gst_buffer_list_get" version="0.10.24">
        <doc xml:whitespace="preserve">Get the buffer at @idx in @group.
Note that this function is not efficient for iterating over the entire list.
Use an iterator or gst_buffer_list_foreach() instead.
is no buffer. The buffer remains valid as long as @list is valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the buffer at @idx in @group or NULL when there</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index in @group</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="iterate"
              c:identifier="gst_buffer_list_iterate"
              version="0.10.24">
        <doc xml:whitespace="preserve">Iterate the buffers in @list. The owner of the iterator must also be the
owner of a reference to @list while the returned iterator is in use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstBufferListIterator of the buffers in</doc>
          <type name="BufferListIterator" c:type="GstBufferListIterator*"/>
        </return-value>
      </method>
      <method name="n_groups"
              c:identifier="gst_buffer_list_n_groups"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns the number of groups in @list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of groups in the buffer list</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
    </class>
    <record name="BufferListClass"
            c:type="GstBufferListClass"
            disguised="1"
            glib:is-gtype-struct-for="BufferList">
    </record>
    <callback name="BufferListDoFunction"
              c:type="GstBufferListDoFunction"
              version="0.10.24">
      <doc xml:whitespace="preserve">A function for accessing the last buffer returned by
gst_buffer_list_iterator_next(). The function can leave @buffer in the list,
replace @buffer in the list or remove @buffer from the list, depending on
the return value. If the function returns NULL, @buffer will be removed from
the list, otherwise @buffer will be replaced with the returned buffer.
The last buffer returned by gst_buffer_list_iterator_next() will be replaced
with the buffer returned from the function. The function takes ownership of
unreffed. If NULL is returned, the buffer will be removed from the list. The
list must be writable.
to remove @buffer from the list</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the buffer to replace @buffer in the list, or NULL</doc>
        <type name="Buffer" c:type="GstBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstBuffer</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BufferListFunc"
              c:type="GstBufferListFunc"
              version="0.10.24">
      <doc xml:whitespace="preserve">A function that will be called from gst_buffer_list_foreach(). The @buffer
field will point to a the reference of the buffer at @idx in @group.
When this function returns #GST_BUFFER_LIST_CONTINUE, the next buffer will be
returned. When #GST_BUFFER_LIST_SKIP_GROUP is returned, all remaining buffers
in the current group will be skipped and the first buffer of the next group
is returned (if any). When GST_BUFFER_LIST_END is returned,
gst_buffer_list_foreach() will return.
When @buffer is set to NULL, the item will be removed from the bufferlist.
When @buffer has been made writable, the new buffer reference can be assigned
to @buffer. This function is responsible for unreffing the old buffer when
removing or modifying.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a #GstBufferListItem</doc>
        <type name="BufferListItem" c:type="GstBufferListItem"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer the buffer</doc>
          <type name="Buffer" c:type="GstBuffer**"/>
        </parameter>
        <parameter name="group" transfer-ownership="none">
          <doc xml:whitespace="preserve">the group index of @buffer</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="idx" transfer-ownership="none">
          <doc xml:whitespace="preserve">the index in @group of @buffer</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user data passed to gst_buffer_list_foreach()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="BufferListItem"
                 version="0.10.24"
                 c:type="GstBufferListItem">
      <doc xml:whitespace="preserve">The result of the #GstBufferListFunc.</doc>
      <member name="continue"
              value="0"
              c:identifier="GST_BUFFER_LIST_CONTINUE"/>
      <member name="skip_group"
              value="1"
              c:identifier="GST_BUFFER_LIST_SKIP_GROUP"/>
      <member name="end" value="2" c:identifier="GST_BUFFER_LIST_END"/>
    </enumeration>
    <record name="BufferListIterator"
            c:type="GstBufferListIterator"
            version="0.10.24"
            glib:type-name="GstBufferListIterator"
            glib:get-type="gst_buffer_list_iterator_get_type"
            c:symbol-prefix="buffer_list_iterator">
      <doc xml:whitespace="preserve">Opaque iterator for a #GstBufferList.</doc>
      <method name="add"
              c:identifier="gst_buffer_list_iterator_add"
              version="0.10.24">
        <doc xml:whitespace="preserve">Inserts @buffer into the #GstBufferList iterated with @it. The buffer is
inserted into the current group, immediately before the buffer that would be
returned by gst_buffer_list_iterator_next(). The buffer is inserted before
the implicit cursor, a subsequent call to gst_buffer_list_iterator_next()
will return the buffer after the inserted buffer, if any.
This function takes ownership of @buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstBuffer</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_group"
              c:identifier="gst_buffer_list_iterator_add_group"
              version="0.10.24">
        <doc xml:whitespace="preserve">Inserts a new, empty group into the #GstBufferList iterated with @it. The
group is inserted immediately before the group that would be returned by
gst_buffer_list_iterator_next_group(). A subsequent call to
gst_buffer_list_iterator_next_group() will advance the iterator to the group
after the inserted group, if any.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="add_list"
              c:identifier="gst_buffer_list_iterator_add_list"
              version="0.10.31">
        <doc xml:whitespace="preserve">Inserts @list of buffers into the #GstBufferList iterated with @it. The list is
inserted into the current group, immediately before the buffer that would be
returned by gst_buffer_list_iterator_next(). The list is inserted before
the implicit cursor, a subsequent call to gst_buffer_list_iterator_next()
will return the buffer after the last buffer of the inserted list, if any.
This function takes ownership of @list and all its buffers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GList of buffers</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Buffer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="do"
              c:identifier="gst_buffer_list_iterator_do"
              version="0.10.24">
        <doc xml:whitespace="preserve">Calls the given function for the last buffer returned by
gst_buffer_list_iterator_next(). gst_buffer_list_iterator_next() must have
been called on @it before this function is called.
gst_buffer_list_iterator_remove() and gst_buffer_list_iterator_steal() must
not have been called since the last call to gst_buffer_list_iterator_next().
See #GstBufferListDoFunction for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the return value from @do_func</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="do_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">the function to be called</doc>
            <type name="BufferListDoFunction"
                  c:type="GstBufferListDoFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gpointer to optional user data.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="gst_buffer_list_iterator_free"
              version="0.10.24">
        <doc xml:whitespace="preserve">Free the iterator.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="merge_group"
              c:identifier="gst_buffer_list_iterator_merge_group"
              version="0.10.24">
        <doc xml:whitespace="preserve">Merge a buffer list group into a normal #GstBuffer by copying its metadata
and memcpying its data into consecutive memory. All buffers in the current
group after the implicit cursor will be merged into one new buffer. The
metadata of the new buffer will be a copy of the metadata of the buffer that
would be returned by gst_buffer_list_iterator_next(). If there is no buffer
in the current group after the implicit cursor, NULL will be returned.
This function will not move the implicit cursor or in any other way affect
the state of the iterator @it or the list.
or NULL</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstBuffer, gst_buffer_unref() after usage,</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="n_buffers"
              c:identifier="gst_buffer_list_iterator_n_buffers"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns the number of buffers left to iterate in the current group. I.e. the
number of calls that can be made to gst_buffer_list_iterator_next() before
it returns NULL.
This function will not move the implicit cursor or in any other way affect
the state of the iterator @it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of buffers left to iterate in the current group</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="next"
              c:identifier="gst_buffer_list_iterator_next"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns the next buffer in the list iterated with @it. If the iterator is at
the end of a group, NULL will be returned. This function may be called
repeatedly to iterate through the current group.
The caller will not get a new ref to the returned #GstBuffer and must not
unref it.
buffer list, or NULL</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the next buffer in the current group of the</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="next_group"
              c:identifier="gst_buffer_list_iterator_next_group"
              version="0.10.24">
        <doc xml:whitespace="preserve">Advance the iterator @it to the first buffer in the next group. If the
iterator is at the last group, FALSE will be returned. This function may be
called repeatedly to iterate through the groups in a buffer list.
the iterator was already at the last group</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the iterator could be advanced to the next group, FALSE if</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="remove"
              c:identifier="gst_buffer_list_iterator_remove"
              version="0.10.24">
        <doc xml:whitespace="preserve">Removes the last buffer returned by gst_buffer_list_iterator_next() from
the #GstBufferList iterated with @it. gst_buffer_list_iterator_next() must
have been called on @it before this function is called. This function can
only be called once per call to gst_buffer_list_iterator_next().
The removed buffer is unreffed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="steal"
              c:identifier="gst_buffer_list_iterator_steal"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns the last buffer returned by gst_buffer_list_iterator_next() without
modifying the refcount of the buffer.
gst_buffer_list_iterator_next()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the last buffer returned by</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="take"
              c:identifier="gst_buffer_list_iterator_take"
              version="0.10.24">
        <doc xml:whitespace="preserve">Replaces the last buffer returned by gst_buffer_list_iterator_next() with
this function is called. gst_buffer_list_iterator_remove() must not have been
called since the last call to gst_buffer_list_iterator_next().
This function unrefs the replaced buffer if it has not been stolen with
gst_buffer_list_iterator_steal() and takes ownership of @buffer (i.e. the
refcount of @buffer is not increased).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstBuffer</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="BufferingMode" c:type="GstBufferingMode">
      <doc xml:whitespace="preserve">The different types of buffering methods.</doc>
      <member name="stream" value="0" c:identifier="GST_BUFFERING_STREAM"/>
      <member name="download" value="1" c:identifier="GST_BUFFERING_DOWNLOAD"/>
      <member name="timeshift"
              value="2"
              c:identifier="GST_BUFFERING_TIMESHIFT"/>
      <member name="live" value="3" c:identifier="GST_BUFFERING_LIVE"/>
    </enumeration>
    <class name="Bus"
           c:symbol-prefix="bus"
           c:type="GstBus"
           parent="Object"
           glib:type-name="GstBus"
           glib:get-type="gst_bus_get_type"
           glib:type-struct="BusClass">
      <doc xml:whitespace="preserve">The #GstBus is an object responsible for delivering #GstMessage packets in
a first-in first-out way from the streaming threads (see #GstTask) to the
application.
Since the application typically only wants to deal with delivery of these
messages from one thread, the GstBus will marshall the messages between
different threads. This is important since the actual streaming of media
is done in another thread than the application.
The GstBus provides support for #GSource based notifications. This makes it
possible to handle the delivery in the glib mainloop.
The #GSource callback function gst_bus_async_signal_func() can be used to
convert all bus messages into signal emissions.
A message is posted on the bus with the gst_bus_post() method. With the
gst_bus_peek() and gst_bus_pop() methods one can look at or retrieve a
previously posted message.
The bus can be polled with the gst_bus_poll() method. This methods blocks
up to the specified timeout value until one of the specified messages types
is posted on the bus. The application can then gst_bus_pop() the messages
from the bus to handle them.
Alternatively the application can register an asynchronous bus function
using gst_bus_add_watch_full() or gst_bus_add_watch(). This function will
install a #GSource in the default glib main loop and will deliver messages
a short while after they have been posted. Note that the main loop should
be running for the asynchronous callbacks.
It is also possible to get messages from the bus without any thread
marshalling with the gst_bus_set_sync_handler() method. This makes it
possible to react to a message in the same thread that posted the
message on the bus. This should only be used if the application is able
to deal with messages from different threads.
Every #GstPipeline has one bus.
Note that a #GstPipeline will set its bus into flushing state when changing
from READY to NULL state.
Last reviewed on 2006-03-12 (0.10.5)</doc>
      <constructor name="new" c:identifier="gst_bus_new">
        <doc xml:whitespace="preserve">Creates a new #GstBus instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstBus instance</doc>
          <type name="Bus" c:type="GstBus*"/>
        </return-value>
      </constructor>
      <virtual-method name="message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sync_message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_signal_watch" c:identifier="gst_bus_add_signal_watch">
        <doc xml:whitespace="preserve">Adds a bus signal watch to the default main context with the default priority
(%G_PRIORITY_DEFAULT). Since 0.10.33 it is also possible to use a non-default
main context set up using g_main_context_push_thread_default() (before
one had to create a bus watch source and attach it to the desired main
context 'manually').
After calling this statement, the bus will emit the "message" signal for each
message posted on the bus.
This function may be called multiple times. To clean up, the caller is
responsible for calling gst_bus_remove_signal_watch() as many times as this
function is called.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="add_signal_watch_full"
              c:identifier="gst_bus_add_signal_watch_full">
        <doc xml:whitespace="preserve">Adds a bus signal watch to the default main context with the given @priority
(e.g. %G_PRIORITY_DEFAULT). Since 0.10.33 it is also possible to use a
non-default main context set up using g_main_context_push_thread_default()
(before one had to create a bus watch source and attach it to the desired
main context 'manually').
After calling this statement, the bus will emit the "message" signal for each
message posted on the bus when the main loop is running.
This function may be called multiple times. To clean up, the caller is
responsible for calling gst_bus_remove_signal_watch() as many times as this
function is called.
There can only be a single bus watch per bus, you most remove all signal watch
before you can set another type of watch.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">The priority of the watch.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_watch"
              c:identifier="gst_bus_add_watch"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds a bus watch to the default main context with the default priority
(%G_PRIORITY_DEFAULT). Since 0.10.33 it is also possible to use a non-default
main context set up using g_main_context_push_thread_default() (before
one had to create a bus watch source and attach it to the desired main
context 'manually').
This function is used to receive asynchronous messages in the main loop.
There can only be a single bus watch per bus, you must remove it before you
can set a new one.
The watch can be removed using g_source_remove() or by returning FALSE
from @func.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The event source id.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">A function to call when a message is received.</doc>
            <type name="BusFunc" c:type="GstBusFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_watch_full" c:identifier="gst_bus_add_watch_full">
        <doc xml:whitespace="preserve">Adds a bus watch to the default main context with the given @priority (e.g.
%G_PRIORITY_DEFAULT). Since 0.10.33 it is also possible to use a non-default
main context set up using g_main_context_push_thread_default() (before
one had to create a bus watch source and attach it to the desired main
context 'manually').
This function is used to receive asynchronous messages in the main loop.
There can only be a single bus watch per bus, you must remove it before you
can set a new one.
When @func is called, the message belongs to the caller; if you want to
keep a copy of it, call gst_message_ref() before leaving @func.
The watch can be removed using g_source_remove() or by returning FALSE
from @func.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The event source id.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">The priority of the watch.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">A function to call when a message is received.</doc>
            <type name="BusFunc" c:type="GstBusFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">the function to call when the source is removed.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="async_signal_func"
              c:identifier="gst_bus_async_signal_func">
        <doc xml:whitespace="preserve">A helper #GstBusFunc that can be used to convert all asynchronous messages
into signals.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstMessage received</doc>
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_watch"
              c:identifier="gst_bus_create_watch"
              introspectable="0">
        <doc xml:whitespace="preserve">Create watch for this bus. The GSource will be dispatched whenever
a message is on the bus. After the GSource is dispatched, the
message is popped off the bus and unreffed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSource that can be added to a mainloop.</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </return-value>
      </method>
      <method name="disable_sync_message_emission"
              c:identifier="gst_bus_disable_sync_message_emission">
        <doc xml:whitespace="preserve">Instructs GStreamer to stop emitting the "sync-message" signal for this bus.
See gst_bus_enable_sync_message_emission() for more information.
In the event that multiple pieces of code have called
gst_bus_enable_sync_message_emission(), the sync-message emissions will only
be stopped after all calls to gst_bus_enable_sync_message_emission() were
"cancelled" by calling this function. In this way the semantics are exactly
the same as gst_object_ref() that which calls enable should also call
disable.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="enable_sync_message_emission"
              c:identifier="gst_bus_enable_sync_message_emission">
        <doc xml:whitespace="preserve">Instructs GStreamer to emit the "sync-message" signal after running the bus's
sync handler. This function is here so that code can ensure that they can
synchronously receive messages without having to affect what the bin's sync
handler is.
This function may be called multiple times. To clean up, the caller is
responsible for calling gst_bus_disable_sync_message_emission() as many times
as this function is called.
While this function looks similar to gst_bus_add_signal_watch(), it is not
exactly the same -- this function enables &lt;emphasis&gt;synchronous&lt;/emphasis&gt; emission of
signals when messages arrive; gst_bus_add_signal_watch() adds an idle callback
to pop messages off the bus &lt;emphasis&gt;asynchronously&lt;/emphasis&gt;. The sync-message signal
comes from the thread of whatever object posted the message; the "message"
signal is marshalled to the main thread via the main loop.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="have_pending" c:identifier="gst_bus_have_pending">
        <doc xml:whitespace="preserve">Check if there are pending messages on the bus that
should be handled.
otherwise.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if there are messages on the bus to be handled, FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="peek" c:identifier="gst_bus_peek">
        <doc xml:whitespace="preserve">Peek the message on the top of the bus' queue. The message will remain
on the bus' message queue. A reference is returned, and needs to be unreffed
by the caller.
bus is empty.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstMessage that is on the bus, or NULL if the</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
      </method>
      <method name="poll" c:identifier="gst_bus_poll">
        <doc xml:whitespace="preserve">Poll the bus for messages. Will block while waiting for messages to come.
You can specify a maximum time to poll with the @timeout parameter. If
All messages not in @events will be popped off the bus and will be ignored.
Because poll is implemented using the "message" signal enabled by
gst_bus_add_signal_watch(), calling gst_bus_poll() will cause the "message"
signal to be emitted for every message that poll sees. Thus a "message"
signal handler will see the same messages that this function sees -- neither
will steal messages from the other.
This function will run a main loop from the default main context when
polling.
You should never use this function, since it is pure evil. This is
especially true for GUI applications based on Gtk+ or Qt, but also for any
other non-trivial application that uses the GLib main loop. As this function
runs a GLib main loop, any callback attached to the default GLib main
context may be invoked. This could be timeouts, GUI events, I/O events etc.;
even if gst_bus_poll() is called with a 0 timeout. Any of these callbacks
may do things you do not expect, e.g. destroy the main application window or
some other resource; change other application state; display a dialog and
run another main loop until the user clicks it away. In short, using this
function may add a lot of complexity to your code through unexpected
re-entrancy and unexpected changes to your application's state.
For 0 timeouts use gst_bus_pop_filtered() instead of this function; for
other short timeouts use gst_bus_timed_pop_filtered(); everything else is
better handled by setting up an asynchronous bus watch and doing things
from there.
poll timed out. The message is taken from the bus and needs to be
unreffed with gst_message_unref() after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the message that was received, or NULL if the</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="events" transfer-ownership="none">
            <doc xml:whitespace="preserve">a mask of #GstMessageType, representing the set of message types to poll for.</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">the poll timeout, as a #GstClockTimeDiff, or -1 to poll indefinitely.</doc>
            <type name="ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="gst_bus_pop">
        <doc xml:whitespace="preserve">Get a message from the bus.
bus is empty. The message is taken from the bus and needs to be unreffed
with gst_message_unref() after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstMessage that is on the bus, or NULL if the</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
      </method>
      <method name="pop_filtered"
              c:identifier="gst_bus_pop_filtered"
              version="0.10.15">
        <doc xml:whitespace="preserve">Get a message matching @type from the bus.  Will discard all messages on
the bus that do not match @type and that have been posted before the first
message that does match @type.  If there is no message matching @type on
the bus, all messages will be discarded.
the bus, or NULL if the bus is empty or there is no message matching
gst_message_unref() after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the next #GstMessage matching @type that is on</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="types" transfer-ownership="none">
            <doc xml:whitespace="preserve">message types to take into account</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
        </parameters>
      </method>
      <method name="post" c:identifier="gst_bus_post">
        <doc xml:whitespace="preserve">Post a message on the given bus. Ownership of the message
is taken by the bus.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the message could be posted, FALSE if the bus is flushing.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstMessage to post</doc>
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_signal_watch"
              c:identifier="gst_bus_remove_signal_watch">
        <doc xml:whitespace="preserve">Removes a signal watch previously added with gst_bus_add_signal_watch().
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_flushing" c:identifier="gst_bus_set_flushing">
        <doc xml:whitespace="preserve">If @flushing, flush out and unref any messages queued in the bus. Releases
references to the message origin objects. Will flush future messages until
gst_bus_set_flushing() sets @flushing to #FALSE.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether or not to flush the bus</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sync_handler"
              c:identifier="gst_bus_set_sync_handler"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the synchronous handler on the bus. The function will be called
every time a new message is posted on the bus. Note that the function
will be called in the same thread context as the posting object. This
function is usually only called by the creator of the bus. Applications
should handle messages asynchronously using the gst_bus watch and poll
functions.
You cannot replace an existing sync_handler. You can pass NULL to this
function, which will clear the existing handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">The handler function to install</doc>
            <type name="BusSyncHandler" c:type="GstBusSyncHandler"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">User data that will be sent to the handler function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync_signal_handler"
              c:identifier="gst_bus_sync_signal_handler">
        <doc xml:whitespace="preserve">A helper GstBusSyncHandler that can be used to convert all synchronous
messages into signals.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">GST_BUS_PASS</doc>
          <type name="BusSyncReply" c:type="GstBusSyncReply"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstMessage received</doc>
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="timed_pop"
              c:identifier="gst_bus_timed_pop"
              version="0.10.12">
        <doc xml:whitespace="preserve">Get a message from the bus, waiting up to the specified timeout.
If @timeout is 0, this function behaves like gst_bus_pop(). If @timeout is
#GST_CLOCK_TIME_NONE, this function will block forever until a message was
posted on the bus.
specified timeout or NULL if the bus is empty after the timeout expired.
The message is taken from the bus and needs to be unreffed with
gst_message_unref() after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstMessage that is on the bus after the</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">a timeout</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="timed_pop_filtered"
              c:identifier="gst_bus_timed_pop_filtered"
              version="0.10.15">
        <doc xml:whitespace="preserve">Get a message from the bus whose type matches the message type mask @types,
waiting up to the specified timeout (and discarding any messages that do not
match the mask provided).
If @timeout is 0, this function behaves like gst_bus_pop_filtered(). If
matching message was posted on the bus.
or NULL if no matching message was found on the bus until the timeout
expired. The message is taken from the bus and needs to be unreffed
with gst_message_unref() after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstMessage matching the filter in @types,</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">a timeout in nanoseconds, or GST_CLOCK_TIME_NONE to wait forever</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="types" transfer-ownership="none">
            <doc xml:whitespace="preserve">message types to take into account, GST_MESSAGE_ANY for any type</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="queue" readable="0" private="1">
        <type name="GLib.Queue" c:type="GQueue*"/>
      </field>
      <field name="queue_lock" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="sync_handler" readable="0" private="1">
        <type name="BusSyncHandler" c:type="GstBusSyncHandler"/>
      </field>
      <field name="sync_handler_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="signal_watch_id" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="num_signal_watchers" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BusPrivate" c:type="GstBusPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="message">
        <doc xml:whitespace="preserve">A message has been posted on the bus. This signal is emitted from a
GSource added to the mainloop. this signal will only be emitted when
there is a mainloop running.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the message that has been posted asynchronously</doc>
            <type name="Message"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="sync-message">
        <doc xml:whitespace="preserve">A message has been posted on the bus. This signal is emitted from the
thread that posted the message so one has to be careful with locking.
This signal will not be emitted by default, you have to set up
gst_bus_sync_signal_handler() as a sync handler if you want this
signal to be emitted when a message is posted on the bus, like this:
&lt;programlisting&gt;
gst_bus_set_sync_handler (bus, gst_bus_sync_signal_handler, yourdata);
&lt;/programlisting&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the message that has been posted synchronously</doc>
            <type name="Message"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="BusClass"
            c:type="GstBusClass"
            glib:is-gtype-struct-for="Bus">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="message">
        <callback name="message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bus" transfer-ownership="none">
              <type name="Bus" c:type="GstBus*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="Message" c:type="GstMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sync_message">
        <callback name="sync_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bus" transfer-ownership="none">
              <type name="Bus" c:type="GstBus*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="Message" c:type="GstMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="BusFlags" c:type="GstBusFlags">
      <doc xml:whitespace="preserve">The standard flags that a bus may have.</doc>
      <member name="flushing" value="16" c:identifier="GST_BUS_FLUSHING"/>
      <member name="flag_last" value="32" c:identifier="GST_BUS_FLAG_LAST"/>
    </bitfield>
    <callback name="BusFunc" c:type="GstBusFunc">
      <doc xml:whitespace="preserve">Specifies the type of function passed to gst_bus_add_watch() or
gst_bus_add_watch_full(), which is called from the mainloop when a message
is available on the bus.
The message passed to the function will be unreffed after execution of this
function so it should not be freed in the function.
Note that this function is used as a GSourceFunc which means that returning
FALSE will remove the GSource from the mainloop.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE if the event source should be removed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="bus" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBus that sent the message</doc>
          <type name="Bus" c:type="GstBus*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstMessage</doc>
          <type name="Message" c:type="GstMessage*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data that has been given, when registering the handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BusPrivate" c:type="GstBusPrivate" disguised="1">
    </record>
    <callback name="BusSyncHandler" c:type="GstBusSyncHandler">
      <doc xml:whitespace="preserve">Handler will be invoked synchronously, when a new message has been injected
into the bus. This function is mostly used internally. Only one sync handler
can be attached to a given bus.
If the handler returns GST_BUS_DROP, it should unref the message, else the
message should not be unreffed by the sync handler.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GstBusSyncReply stating what to do with the message</doc>
        <type name="BusSyncReply" c:type="GstBusSyncReply"/>
      </return-value>
      <parameters>
        <parameter name="bus" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBus that sent the message</doc>
          <type name="Bus" c:type="GstBus*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstMessage</doc>
          <type name="Message" c:type="GstMessage*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data that has been given, when registering the handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="BusSyncReply" c:type="GstBusSyncReply">
      <doc xml:whitespace="preserve">The result values for a GstBusSyncHandler.</doc>
      <member name="drop" value="0" c:identifier="GST_BUS_DROP"/>
      <member name="pass" value="1" c:identifier="GST_BUS_PASS"/>
      <member name="async" value="2" c:identifier="GST_BUS_ASYNC"/>
    </enumeration>
    <constant name="CAN_INLINE" value="1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CLOCK_ENTRY_TRACE_NAME" value="GstClockEntry">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLOCK_TIME_NONE" value="-1">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Caps"
            c:type="GstCaps"
            glib:type-name="GstCaps"
            glib:get-type="gst_caps_get_type"
            c:symbol-prefix="caps">
      <doc xml:whitespace="preserve">Caps (capabilities) are lighweight refcounted objects describing media types.
They are composed of an array of #GstStructure.
Caps are exposed on #GstPadTemplate to describe all possible types a
given pad can handle. They are also stored in the #GstRegistry along with
a description of the #GstElement.
Caps are exposed on the element pads using the gst_pad_get_caps() pad
function. This function describes the possible types that the pad can
handle or produce at runtime.
Caps are also attached to buffers to describe to content of the data
pointed to by the buffer with gst_buffer_set_caps(). Caps attached to
a #GstBuffer allow for format negotiation upstream and downstream.
A #GstCaps can be constructed with the following code fragment:
&lt;example&gt;
&lt;title&gt;Creating caps&lt;/title&gt;
&lt;programlisting&gt;
GstCaps *caps;
caps = gst_caps_new_simple ("video/x-raw-yuv",
"format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('I', '4', '2', '0'),
"framerate", GST_TYPE_FRACTION, 25, 1,
"pixel-aspect-ratio", GST_TYPE_FRACTION, 1, 1,
"width", G_TYPE_INT, 320,
"height", G_TYPE_INT, 240,
NULL);
&lt;/programlisting&gt;
&lt;/example&gt;
A #GstCaps is fixed when it has no properties with ranges or lists. Use
gst_caps_is_fixed() to test for fixed caps. Only fixed caps can be
set on a #GstPad or #GstBuffer.
Various methods exist to work with the media types such as subtracting
or intersecting.
Last reviewed on 2007-02-13 (0.10.10)</doc>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="refcount" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="flags" writable="1">
        <type name="CapsFlags" c:type="GstCapsFlags"/>
      </field>
      <field name="structs" readable="0" private="1">
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <constructor name="new_any" c:identifier="gst_caps_new_any">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that indicates that it is compatible with
any media format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </constructor>
      <constructor name="new_empty" c:identifier="gst_caps_new_empty">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that is empty.  That is, the returned
#GstCaps contains no media formats.
Caller is responsible for unreffing the returned caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </constructor>
      <constructor name="new_full"
                   c:identifier="gst_caps_new_full"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstCaps and adds all the structures listed as
arguments.  The list must be NULL-terminated.  The structures
are not copied; the returned #GstCaps owns the structures.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="struct1" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first structure to add</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full_valist"
                   c:identifier="gst_caps_new_full_valist"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstCaps and adds all the structures listed as
arguments.  The list must be NULL-terminated.  The structures
are not copied; the returned #GstCaps owns the structures.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="structure" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first structure to add</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">additional structures to add</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_simple"
                   c:identifier="gst_caps_new_simple"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that contains one #GstStructure.  The
structure is defined by the arguments, which have the same format
as gst_structure_new().
Caller is responsible for unreffing the returned caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="media_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the media type of the structure</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">first field to set</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="gst_caps_append">
        <doc xml:whitespace="preserve">Appends the structures contained in @caps2 to @caps1. The structures in
freed. If either caps is ANY, the resulting caps will be ANY.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstCaps to append</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_structure" c:identifier="gst_caps_append_structure">
        <doc xml:whitespace="preserve">Appends @structure to @caps.  The structure is not copied; @caps
becomes the owner of @structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstStructure to append</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_intersect"
              c:identifier="gst_caps_can_intersect"
              version="0.10.25">
        <doc xml:whitespace="preserve">Tries intersecting @caps1 and @caps2 and reports whether the result would not
be empty</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if intersection would be not empty</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to intersect</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gst_caps_copy">
        <doc xml:whitespace="preserve">Creates a new #GstCaps as a copy of the old @caps. The new caps will have a
refcount of 1, owned by the caller. The structures are copied as well.
Note that this function is the semantic equivalent of a gst_caps_ref()
followed by a gst_caps_make_writable(). If you only want to hold on to a
reference to the data, you should use gst_caps_ref().
When you are finished with the caps, call gst_caps_unref() on it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="copy_nth" c:identifier="gst_caps_copy_nth">
        <doc xml:whitespace="preserve">Creates a new #GstCaps and appends a copy of the nth structure
contained in @caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="nth" transfer-ownership="none">
            <doc xml:whitespace="preserve">the nth structure to copy</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="do_simplify" c:identifier="gst_caps_do_simplify">
        <doc xml:whitespace="preserve">Modifies the given @caps inplace into a representation that represents the
same set of formats, but in a simpler form.  Component structures that are
identical are merged.  Component structures that have values that can be
merged are also merged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if the caps could be simplified</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_size" c:identifier="gst_caps_get_size">
        <doc xml:whitespace="preserve">Gets the number of structures contained in @caps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of structures that @caps contains</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_structure" c:identifier="gst_caps_get_structure">
        <doc xml:whitespace="preserve">Finds the structure in @caps that has the index @index, and
returns it.
non-const GstStructure *.  This is for programming convenience --
the caller should be aware that structures inside a constant
#GstCaps should not be modified. However, if you know the caps
are writable, either because you have just copied them or made
them writable with gst_caps_make_writable(), you may modify the
structure returned in the usual way, e.g. with functions like
gst_structure_set().
You do not need to free or unref the structure returned, it
belongs to the #GstCaps.
to @index</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to the #GstStructure corresponding</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index of the structure</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect" c:identifier="gst_caps_intersect">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that contains all the formats that are common
to both @caps1 and @caps2. Defaults to %GST_CAPS_INTERSECT_ZIG_ZAG mode.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to intersect</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect_full"
              c:identifier="gst_caps_intersect_full"
              version="0.10.33">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that contains all the formats that are common
to both @caps1 and @caps2, the order is defined by the #GstCapsIntersectMode
used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to intersect</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">The intersection algorithm/mode to use</doc>
            <type name="CapsIntersectMode" c:type="GstCapsIntersectMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_always_compatible"
              c:identifier="gst_caps_is_always_compatible">
        <doc xml:whitespace="preserve">A given #GstCaps structure is always compatible with another if
every media format that is in the first is also contained in the
second.  That is, @caps1 is a subset of @caps2.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @caps1 is a subset of @caps2.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstCaps to test</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_any" c:identifier="gst_caps_is_any">
        <doc xml:whitespace="preserve">Determines if @caps represents any media format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @caps represents any format.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_empty" c:identifier="gst_caps_is_empty">
        <doc xml:whitespace="preserve">Determines if @caps represents no media formats.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @caps represents no formats.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_equal" c:identifier="gst_caps_is_equal">
        <doc xml:whitespace="preserve">Checks if the given caps represent the same set of caps.
&lt;note&gt;This function does not work reliably if optional properties for caps
are included on one caps and omitted on the other.&lt;/note&gt;
This function deals correctly with passing NULL for any of the caps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if both caps are equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">another #GstCaps</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_equal_fixed" c:identifier="gst_caps_is_equal_fixed">
        <doc xml:whitespace="preserve">Tests if two #GstCaps are equal.  This function only works on fixed
#GstCaps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the arguments represent the same format</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstCaps to test</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_fixed" c:identifier="gst_caps_is_fixed">
        <doc xml:whitespace="preserve">Fixed #GstCaps describe exactly one format, that is, they have exactly
one structure, and each field in the structure describes a fixed type.
Examples of non-fixed types are GST_TYPE_INT_RANGE and GST_TYPE_LIST.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @caps is fixed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_subset" c:identifier="gst_caps_is_subset">
        <doc xml:whitespace="preserve">Checks if all caps represented by @subset are also represented by @superset.
&lt;note&gt;This function does not work reliably if optional properties for caps
are included on one caps and omitted on the other.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @subset is a subset of @superset</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="superset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a potentially greater #GstCaps</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_writable" c:identifier="gst_caps_make_writable">
        <doc xml:whitespace="preserve">Returns a writable copy of @caps.
If there is only one reference count on @caps, the caller must be the owner,
and so this function will return the caps object unchanged. If on the other
hand there is more than one reference on the object, a new caps object will
be returned. The caller's reference on @caps will be removed, and instead the
caller will own a reference to the returned object.
In short, this function unrefs the caps in the argument and refs the caps
that it returns. Don't access the argument after calling this function. See</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the same #GstCaps object.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="merge" c:identifier="gst_caps_merge" version="0.10.10">
        <doc xml:whitespace="preserve">Appends the structures contained in @caps2 to @caps1 if they are not yet
expressed by @caps1. The structures in @caps2 are not copied -- they are
transferred to @caps1, and then @caps2 is freed.
If either caps is ANY, the resulting caps will be ANY.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstCaps to merge in</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="merge_structure" c:identifier="gst_caps_merge_structure">
        <doc xml:whitespace="preserve">Appends @structure to @caps if its not already expressed by @caps.  The
structure is not copied; @caps becomes the owner of @structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstStructure to merge</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="gst_caps_normalize">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that represents the same set of formats as</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="gst_caps_ref">
        <doc xml:whitespace="preserve">Add a reference to a #GstCaps object.
From this point on, until the caller calls gst_caps_unref() or
gst_caps_make_writable(), it is guaranteed that the caps object will not
change. This means its structures won't change, etc. To use a #GstCaps
object, you must always have a refcount on it -- either the one made
implicitly by e.g. gst_caps_new_simple(), or via taking one explicitly with
this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the same #GstCaps object.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="remove_structure" c:identifier="gst_caps_remove_structure">
        <doc xml:whitespace="preserve">removes the stucture with the given index from the list of structures
contained in @caps.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">Index of the structure to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_thyself"
              c:identifier="gst_caps_save_thyself"
              introspectable="0">
        <doc xml:whitespace="preserve">Serializes a #GstCaps to XML and adds it as a child node of @parent.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a XML node pointer</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">a XML parent node</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_simple"
              c:identifier="gst_caps_set_simple"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets fields in a #GstCaps.  The arguments must be passed in the same
manner as gst_structure_set(), and be NULL-terminated.
&lt;note&gt;Prior to GStreamer version 0.10.26, this function failed when
of GStreamer, you may only call this function when GST_CAPS_IS_SIMPLE()
is %TRUE for @caps.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">first field to set</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_simple_valist"
              c:identifier="gst_caps_set_simple_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets fields in a #GstCaps.  The arguments must be passed in the same
manner as gst_structure_set(), and be NULL-terminated.
&lt;note&gt;Prior to GStreamer version 0.10.26, this function failed when
of GStreamer, you may only call this function when GST_CAPS_IS_SIMPLE()
is %TRUE for @caps.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">first field to set</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="varargs" transfer-ownership="none">
            <doc xml:whitespace="preserve">additional parameters</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value"
              c:identifier="gst_caps_set_value"
              version="0.10.26">
        <doc xml:whitespace="preserve">Sets the given @field on all structures of @caps to the given @value.
This is a convenience function for calling gst_structure_set_value() on
all structures of @caps.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the field to set</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">value to set the field to</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_structure"
              c:identifier="gst_caps_steal_structure"
              version="0.10.30">
        <doc xml:whitespace="preserve">Retrieves the stucture with the given index from the list of structures
contained in @caps. The caller becomes the owner of the returned structure.
to @index.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to the #GstStructure corresponding</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">Index of the structure to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract" c:identifier="gst_caps_subtract">
        <doc xml:whitespace="preserve">Subtracts the @subtrahend from the @minuend.
&lt;note&gt;This function does not work reliably if optional properties for caps
are included on one caps and omitted on the other.&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the resulting caps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="subtrahend" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstCaps to substract</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gst_caps_to_string">
        <doc xml:whitespace="preserve">Converts @caps to a string representation.  This string representation
can be converted back to a #GstCaps by gst_caps_from_string().
For debugging purposes its easier to do something like this:
|[
GST_LOG ("caps are %" GST_PTR_FORMAT, caps);
]|
This prints the caps in human readble form.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated string representing @caps.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="truncate" c:identifier="gst_caps_truncate">
        <doc xml:whitespace="preserve">Destructively discard all but the first structure from @caps. Useful when
fixating. @caps must be writable.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="union" c:identifier="gst_caps_union">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that contains all the formats that are in
either @caps1 and @caps2.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to union</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gst_caps_unref">
        <doc xml:whitespace="preserve">Unref a #GstCaps and and free all its structures and the
structures' values when the refcount reaches 0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <bitfield name="CapsFlags" c:type="GstCapsFlags">
      <doc xml:whitespace="preserve">Extra flags for a caps.</doc>
      <member name="caps_flags_any"
              value="1"
              c:identifier="GST_CAPS_FLAGS_ANY"/>
    </bitfield>
    <enumeration name="CapsIntersectMode"
                 version="0.10.33"
                 c:type="GstCapsIntersectMode">
      <doc xml:whitespace="preserve">Modes of caps intersection
by iterating on the caps' structures as the following matrix shows:
|[
caps1
+-------------
| 1  2  4  7
caps2 | 3  5  8 10
| 6  9 11 12
]|
Used when there is no explicit precedence of one caps over the other. e.g.
tee's sink pad getcaps function, it will probe its src pad peers' for their
caps and intersect them with this mode.
another element's caps priority order when intersecting with its own caps.
would be [A, B], maintaining the first caps priority on the intersection.</doc>
      <member name="zig_zag"
              value="0"
              c:identifier="GST_CAPS_INTERSECT_ZIG_ZAG"/>
      <member name="first" value="1" c:identifier="GST_CAPS_INTERSECT_FIRST"/>
    </enumeration>
    <interface name="ChildProxy"
               c:symbol-prefix="child_proxy"
               c:type="GstChildProxy"
               glib:type-name="GstChildProxy"
               glib:get-type="gst_child_proxy_get_type"
               glib:type-struct="ChildProxyInterface">
      <doc xml:whitespace="preserve">This interface abstracts handling of property sets for elements with
children. Imagine elements such as mixers or polyphonic generators. They all
have multiple #GstPad or some kind of voice objects. Another use case are
container elements like #GstBin.
The element implementing the interface acts as a parent for those child
objects.
By implementing this interface the child properties can be accessed from the
parent element by using gst_child_proxy_get() and gst_child_proxy_set().
Property names are written as "child-name::property-name". The whole naming
scheme is recursive. Thus "child1::child2::property" is valid too, if
"child1" and "child2" implement the #GstChildProxy interface.</doc>
      <prerequisite name="Object"/>
      <virtual-method name="child_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="child_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_child_by_index" invoker="get_child_by_index">
        <doc xml:whitespace="preserve">Fetches a child by its number.
too high). Unref after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the child object or %NULL if not found (index</doc>
          <type name="Object" c:type="GstObject*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the childs position in the child list</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_children_count" invoker="get_children_count">
        <doc xml:whitespace="preserve">Gets the number of child objects this parent contains.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of child objects</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </virtual-method>
      <method name="get_child_by_index"
              c:identifier="gst_child_proxy_get_child_by_index">
        <doc xml:whitespace="preserve">Fetches a child by its number.
too high). Unref after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the child object or %NULL if not found (index</doc>
          <type name="Object" c:type="GstObject*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the childs position in the child list</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_child_by_name"
              c:identifier="gst_child_proxy_get_child_by_name">
        <doc xml:whitespace="preserve">Looks up a child element by the given name.
Implementors can use #GstObject together with gst_object_get_name()
after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the child object or %NULL if not found. Unref</doc>
          <type name="Object" c:type="GstObject*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the childs name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_children_count"
              c:identifier="gst_child_proxy_get_children_count">
        <doc xml:whitespace="preserve">Gets the number of child objects this parent contains.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of child objects</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <glib:signal name="child-added">
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="child-removed">
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="ChildProxyInterface"
            c:type="GstChildProxyInterface"
            glib:is-gtype-struct-for="ChildProxy">
      <doc xml:whitespace="preserve">#GstChildProxy interface.</doc>
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_child_by_index">
        <callback name="get_child_by_index">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the child object or %NULL if not found (index</doc>
            <type name="Object" c:type="GstObject*"/>
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none">
              <type name="ChildProxy" c:type="GstChildProxy*"/>
            </parameter>
            <parameter name="index" transfer-ownership="none">
              <doc xml:whitespace="preserve">the childs position in the child list</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_children_count">
        <callback name="get_children_count">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of child objects</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none">
              <type name="ChildProxy" c:type="GstChildProxy*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="child_added">
        <callback name="child_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none">
              <type name="ChildProxy" c:type="GstChildProxy*"/>
            </parameter>
            <parameter name="child" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="child_removed">
        <callback name="child_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none">
              <type name="ChildProxy" c:type="GstChildProxy*"/>
            </parameter>
            <parameter name="child" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="Clock"
           c:symbol-prefix="clock"
           c:type="GstClock"
           parent="Object"
           glib:type-name="GstClock"
           glib:get-type="gst_clock_get_type"
           glib:type-struct="ClockClass">
      <doc xml:whitespace="preserve">GStreamer uses a global clock to synchronize the plugins in a pipeline.
Different clock implementations are possible by implementing this abstract
base class or, more conveniently, by subclassing #GstSystemClock.
The #GstClock returns a monotonically increasing time with the method
gst_clock_get_time(). Its accuracy and base time depend on the specific
clock implementation but time is always expressed in nanoseconds. Since the
baseline of the clock is undefined, the clock time returned is not
meaningful in itself, what matters are the deltas between two clock times.
The time returned by a clock is called the absolute time.
The pipeline uses the clock to calculate the running time. Usually all
renderers synchronize to the global clock using the buffer timestamps, the
newsegment events and the element's base time, see #GstPipeline.
A clock implementation can support periodic and single shot clock
notifications both synchronous and asynchronous.
One first needs to create a #GstClockID for the periodic or single shot
notification using gst_clock_new_single_shot_id() or
gst_clock_new_periodic_id().
To perform a blocking wait for the specific time of the #GstClockID use the
gst_clock_id_wait(). To receive a callback when the specific time is reached
in the clock use gst_clock_id_wait_async(). Both these calls can be
interrupted with the gst_clock_id_unschedule() call. If the blocking wait is
unscheduled a return value of #GST_CLOCK_UNSCHEDULED is returned.
Periodic callbacks scheduled async will be repeatedly called automatically
until it is unscheduled. To schedule a sync periodic callback,
gst_clock_id_wait() should be called repeatedly.
The async callbacks can happen from any thread, either provided by the core
or from a streaming thread. The application should be prepared for this.
A #GstClockID that has been unscheduled cannot be used again for any wait
operation, a new #GstClockID should be created and the old unscheduled one
should be destroyed with gst_clock_id_unref().
It is possible to perform a blocking wait on the same #GstClockID from
multiple threads. However, registering the same #GstClockID for multiple
async notifications is not possible, the callback will only be called for
the thread registering the entry last.
None of the wait operations unref the #GstClockID, the owner is responsible
for unreffing the ids itself. This holds for both periodic and single shot
notifications. The reason being that the owner of the #GstClockID has to
keep a handle to the #GstClockID to unblock the wait on FLUSHING events or
state changes and if the entry would be unreffed automatically, the handle 
might become invalid without any notification.
These clock operations do not operate on the running time, so the callbacks
will also occur when not in PLAYING state as if the clock just keeps on
running. Some clocks however do not progress when the element that provided
the clock is not PLAYING.
When a clock has the #GST_CLOCK_FLAG_CAN_SET_MASTER flag set, it can be
slaved to another #GstClock with the gst_clock_set_master(). The clock will
then automatically be synchronized to this master clock by repeatedly
sampling the master clock and the slave clock and recalibrating the slave
clock with gst_clock_set_calibration(). This feature is mostly useful for
plugins that have an internal clock but must operate with another clock
selected by the #GstPipeline.  They can track the offset and rate difference
of their internal clock relative to the master clock by using the
gst_clock_get_calibration() function. 
The master/slave synchronisation can be tuned with the #GstClock:timeout,
#GstClock:window-size and #GstClock:window-threshold properties.
The #GstClock:timeout property defines the interval to sample the master
clock and run the calibration functions. #GstClock:window-size defines the
number of samples to use when calibrating and #GstClock:window-threshold
defines the minimum number of samples before the calibration is performed.
Last reviewed on 2009-05-21 (0.10.24)</doc>
      <function name="id_compare_func"
                c:identifier="gst_clock_id_compare_func">
        <doc xml:whitespace="preserve">Compares the two #GstClockID instances. This function can be used
as a GCompareFunc when sorting ids.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">negative value if a &lt; b; zero if a = b; positive value if a &gt; b</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="id1" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GstClockID</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="id2" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GstClockID to compare with</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_get_time" c:identifier="gst_clock_id_get_time">
        <doc xml:whitespace="preserve">Get the time of the clock ID
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the time of the given clock id.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GstClockID to query</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_ref" c:identifier="gst_clock_id_ref">
        <doc xml:whitespace="preserve">Increase the refcount of given @id.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The same #GstClockID with increased refcount.</doc>
          <type name="ClockID" c:type="GstClockID"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GstClockID to ref</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_unref" c:identifier="gst_clock_id_unref">
        <doc xml:whitespace="preserve">Unref given @id. When the refcount reaches 0 the
#GstClockID will be freed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="full">
            <doc xml:whitespace="preserve">The #GstClockID to unref</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_unschedule" c:identifier="gst_clock_id_unschedule">
        <doc xml:whitespace="preserve">Cancel an outstanding request with @id. This can either
be an outstanding async notification or a pending sync notification.
After this call, @id cannot be used anymore to receive sync or
async notifications, you need to create a new #GstClockID.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">The id to unschedule</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_wait" c:identifier="gst_clock_id_wait">
        <doc xml:whitespace="preserve">Perform a blocking wait on @id. 
or gst_clock_new_periodic_id() and should not have been unscheduled
with a call to gst_clock_id_unschedule(). 
If the @jitter argument is not %NULL and this function returns #GST_CLOCK_OK
or #GST_CLOCK_EARLY, it will contain the difference
against the clock and the time of @id when this method was
called. 
Positive values indicate how late @id was relative to the clock
(in which case this function will return #GST_CLOCK_EARLY). 
Negative values indicate how much time was spent waiting on the clock 
before this function returned.
if the current clock time is past the time of @id, #GST_CLOCK_OK if 
unscheduled with gst_clock_id_unschedule().
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the result of the blocking wait. #GST_CLOCK_EARLY will be returned</doc>
          <type name="ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GstClockID to wait on</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
          <parameter name="jitter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer that will contain the jitter, can be %NULL.</doc>
            <type name="ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_wait_async"
                c:identifier="gst_clock_id_wait_async"
                introspectable="0">
        <doc xml:whitespace="preserve">Register a callback on the given #GstClockID @id with the given
function and user_data. When passing a #GstClockID with an invalid
time to this function, the callback will be called immediately
with  a time set to GST_CLOCK_TIME_NONE. The callback will
be called when the time of @id has been reached.
The callback @func can be invoked from any thread, either provided by the
core or from a streaming thread. The application should be prepared for this.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the result of the non blocking wait.</doc>
          <type name="ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockID to wait on</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">The callback function</doc>
            <type name="ClockCallback" c:type="GstClockCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">User data passed in the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_wait_async_full"
                c:identifier="gst_clock_id_wait_async_full"
                version="0.10.30">
        <doc xml:whitespace="preserve">Register a callback on the given #GstClockID @id with the given
function and user_data. When passing a #GstClockID with an invalid
time to this function, the callback will be called immediately
with  a time set to GST_CLOCK_TIME_NONE. The callback will
be called when the time of @id has been reached.
The callback @func can be invoked from any thread, either provided by the
core or from a streaming thread. The application should be prepared for this.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the result of the non blocking wait.</doc>
          <type name="ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockID to wait on</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">The callback function</doc>
            <type name="ClockCallback" c:type="GstClockCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">User data passed in the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_data"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">#GDestroyNotify for user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="change_resolution">
        <return-value transfer-ownership="none">
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="old_resolution" transfer-ownership="none">
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="new_resolution" transfer-ownership="none">
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_internal_time" invoker="get_internal_time">
        <doc xml:whitespace="preserve">Gets the current internal time of the given clock. The time is returned
unadjusted for the offset and the rate.
given invalid input.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the internal time of the clock. Or GST_CLOCK_TIME_NONE when</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_resolution" invoker="get_resolution">
        <doc xml:whitespace="preserve">Get the accuracy of the clock. The accuracy of the clock is the granularity
of the values returned by gst_clock_get_time().
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the resolution of the clock in units of #GstClockTime.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unschedule">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="entry" transfer-ownership="none">
            <type name="ClockEntry" c:type="GstClockEntry*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="wait">
        <return-value transfer-ownership="none">
          <type name="ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="entry" transfer-ownership="none">
            <type name="ClockEntry" c:type="GstClockEntry*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="wait_async">
        <return-value transfer-ownership="none">
          <type name="ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="entry" transfer-ownership="none">
            <type name="ClockEntry" c:type="GstClockEntry*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="wait_jitter">
        <return-value transfer-ownership="none">
          <type name="ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="entry" transfer-ownership="none">
            <type name="ClockEntry" c:type="GstClockEntry*"/>
          </parameter>
          <parameter name="jitter" transfer-ownership="none">
            <type name="ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_observation" c:identifier="gst_clock_add_observation">
        <doc xml:whitespace="preserve">The time @master of the master clock and the time @slave of the slave
clock are added to the list of observations. If enough observations
are available, a linear regression algorithm is run on the
observations and @clock is recalibrated.
If this functions returns %TRUE, @r_squared will contain the 
correlation coefficient of the interpolation. A value of 1.0
means a perfect regression was performed. This value can
be used to control the sampling frequency of the master and slave
clocks.
regression algorithm.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if enough observations were added to run the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="slave" transfer-ownership="none">
            <doc xml:whitespace="preserve">a time on the slave</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="master" transfer-ownership="none">
            <doc xml:whitespace="preserve">a time on the master</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="r_squared"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to hold the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="adjust_unlocked" c:identifier="gst_clock_adjust_unlocked">
        <doc xml:whitespace="preserve">Converts the given @internal clock time to the external time, adjusting for the
rate and reference time set with gst_clock_set_calibration() and making sure
that the returned time is increasing. This function should be called with the
clock's OBJECT_LOCK held and is mainly used by clock subclasses.
This function is the reverse of gst_clock_unadjust_unlocked().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the converted time of the clock.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="internal" transfer-ownership="none">
            <doc xml:whitespace="preserve">a clock time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_calibration" c:identifier="gst_clock_get_calibration">
        <doc xml:whitespace="preserve">Gets the internal rate and reference time of @clock. See
gst_clock_set_calibration() for more information.
caller is not interested in the values.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="internal"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to store the internal time</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="external"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to store the external time</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="rate_num"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to store the rate numerator</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="rate_denom"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to store the rate denominator</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_internal_time"
              c:identifier="gst_clock_get_internal_time">
        <doc xml:whitespace="preserve">Gets the current internal time of the given clock. The time is returned
unadjusted for the offset and the rate.
given invalid input.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the internal time of the clock. Or GST_CLOCK_TIME_NONE when</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_master" c:identifier="gst_clock_get_master">
        <doc xml:whitespace="preserve">Get the master clock that @clock is slaved to or %NULL when the clock is
not slaved to any master clock.
not slaved to a master clock. Unref after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a master #GstClock or %NULL when this clock is</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </method>
      <method name="get_resolution" c:identifier="gst_clock_get_resolution">
        <doc xml:whitespace="preserve">Get the accuracy of the clock. The accuracy of the clock is the granularity
of the values returned by gst_clock_get_time().
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the resolution of the clock in units of #GstClockTime.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_time" c:identifier="gst_clock_get_time">
        <doc xml:whitespace="preserve">Gets the current time of the given clock. The time is always
monotonically increasing and adjusted according to the current
offset and rate.
given invalid input.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the time of the clock. Or GST_CLOCK_TIME_NONE when</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="new_periodic_id" c:identifier="gst_clock_new_periodic_id">
        <doc xml:whitespace="preserve">Get an ID from @clock to trigger a periodic notification.
The periodic notifications will start at time @start_time and
will then be fired with the given @interval. @id should be unreffed
after usage.
time notification.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstClockID that can be used to request the</doc>
          <type name="ClockID" c:type="GstClockID"/>
        </return-value>
        <parameters>
          <parameter name="start_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested start time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested interval</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_single_shot_id"
              c:identifier="gst_clock_new_single_shot_id">
        <doc xml:whitespace="preserve">Get a #GstClockID from @clock to trigger a single shot
notification at the requested time. The single shot id should be
unreffed after usage.
time notification.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstClockID that can be used to request the</doc>
          <type name="ClockID" c:type="GstClockID"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="periodic_id_reinit"
              c:identifier="gst_clock_periodic_id_reinit"
              version="0.10.33">
        <doc xml:whitespace="preserve">Reinitializes the provided periodic @id to the provided start time and
interval. Does not modify the reference count.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the GstClockID could be reinitialized to the provided</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockID</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
          <parameter name="start_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested start time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested interval</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_calibration" c:identifier="gst_clock_set_calibration">
        <doc xml:whitespace="preserve">Adjusts the rate and time of @clock. A rate of 1/1 is the normal speed of
the clock. Values bigger than 1/1 make the clock go faster.
gst_clock_get_time() should have been @external at internal time @internal.
This internal time should not be in the future; that is, it should be less
than the value of gst_clock_get_internal_time() when this function is called.
Subsequent calls to gst_clock_get_time() will return clock times computed as
follows:
&lt;programlisting&gt;
time = (internal_time - internal) * rate_num / rate_denom + external
&lt;/programlisting&gt;
This formula is implemented in gst_clock_adjust_unlocked(). Of course, it
tries to do the integer arithmetic as precisely as possible.
Note that gst_clock_get_time() always returns increasing values so when you
move the clock backwards, gst_clock_get_time() will report the previous value
until the clock catches up.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="internal" transfer-ownership="none">
            <doc xml:whitespace="preserve">a reference internal time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="external" transfer-ownership="none">
            <doc xml:whitespace="preserve">a reference external time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="rate_num" transfer-ownership="none">
            <doc xml:whitespace="preserve">the numerator of the rate of the clock relative to its internal time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="rate_denom" transfer-ownership="none">
            <doc xml:whitespace="preserve">the denominator of the rate of the clock</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_master" c:identifier="gst_clock_set_master">
        <doc xml:whitespace="preserve">Set @master as the master clock for @clock. @clock will be automatically
calibrated so that gst_clock_get_time() reports the same time as the
master clock.  
A clock provider that slaves its clock to a master can get the current
calibration values with gst_clock_get_calibration().
however keep reporting its time adjusted with the last configured rate 
and time offsets.
Trying to set a master on a clock without the 
#GST_CLOCK_FLAG_CAN_SET_MASTER flag will make this function return %FALSE.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the clock is capable of being slaved to a master clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="master" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a master #GstClock</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resolution" c:identifier="gst_clock_set_resolution">
        <doc xml:whitespace="preserve">Set the accuracy of the clock. Some clocks have the possibility to operate
with different accuracy at the expense of more resource usage. There is
normally no need to change the default resolution of a clock. The resolution
of a clock can only be changed if the clock has the
#GST_CLOCK_FLAG_CAN_SET_RESOLUTION flag set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the new resolution of the clock.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="resolution" transfer-ownership="none">
            <doc xml:whitespace="preserve">The resolution to set</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="single_shot_id_reinit"
              c:identifier="gst_clock_single_shot_id_reinit"
              version="0.10.32">
        <doc xml:whitespace="preserve">Reinitializes the provided single shot @id to the provided time. Does not
modify the reference count.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the GstClockID could be reinitialized to the provided</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockID</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">The requested time.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="unadjust_unlocked"
              c:identifier="gst_clock_unadjust_unlocked"
              version="0.10.13">
        <doc xml:whitespace="preserve">Converts the given @external clock time to the internal time of @clock,
using the rate and reference time set with gst_clock_set_calibration().
This function should be called with the clock's OBJECT_LOCK held and
is mainly used by clock subclasses.
This function is the reverse of gst_clock_adjust_unlocked().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the internal time of the clock corresponding to @external.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="external" transfer-ownership="none">
            <doc xml:whitespace="preserve">an external clock time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <property name="stats" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="timeout" writable="1" transfer-ownership="none">
        <type name="guint64"/>
      </property>
      <property name="window-size" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <property name="window-threshold" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="slave_lock">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="internal_calibration">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="external_calibration">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="rate_numerator">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="rate_denominator">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="last_time">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="entries">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="entries_changed">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="resolution" readable="0" private="1">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="stats" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="master" readable="0" private="1">
        <type name="Clock" c:type="GstClock*"/>
      </field>
      <field name="filling" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="window_size" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="window_threshold" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="time_index" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="timeout" readable="0" private="1">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="times" readable="0" private="1">
        <type name="ClockTime" c:type="GstClockTime*"/>
      </field>
      <field name="clockid" readable="0" private="1">
        <type name="ClockID" c:type="GstClockID"/>
      </field>
      <union name="ABI" c:type="ABI">
        <field name="priv" writable="1">
          <type name="ClockPrivate" c:type="GstClockPrivate*"/>
        </field>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="GstClockTime" fixed-size="4">
            <type name="ClockTime" c:type="GstClockTime"/>
          </array>
        </field>
      </union>
    </class>
    <callback name="ClockCallback" c:type="GstClockCallback">
      <doc xml:whitespace="preserve">The function prototype of the callback.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE or %FALSE (currently unused)</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="clock" transfer-ownership="none">
          <doc xml:whitespace="preserve">The clock that triggered the callback</doc>
          <type name="Clock" c:type="GstClock*"/>
        </parameter>
        <parameter name="time" transfer-ownership="none">
          <doc xml:whitespace="preserve">The time it was triggered</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstClockID that expired</doc>
          <type name="ClockID" c:type="GstClockID"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user data passed in the gst_clock_id_wait_async() function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ClockClass"
            c:type="GstClockClass"
            glib:is-gtype-struct-for="Clock">
      <doc xml:whitespace="preserve">GStreamer clock class. Override the vmethods to implement the clock
functionality.</doc>
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="change_resolution">
        <callback name="change_resolution">
          <return-value transfer-ownership="none">
            <type name="ClockTime" c:type="GstClockTime"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
            <parameter name="old_resolution" transfer-ownership="none">
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
            <parameter name="new_resolution" transfer-ownership="none">
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_resolution">
        <callback name="get_resolution">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the resolution of the clock in units of #GstClockTime.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_internal_time">
        <callback name="get_internal_time">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the internal time of the clock. Or GST_CLOCK_TIME_NONE when</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wait">
        <callback name="wait">
          <return-value transfer-ownership="none">
            <type name="ClockReturn" c:type="GstClockReturn"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
            <parameter name="entry" transfer-ownership="none">
              <type name="ClockEntry" c:type="GstClockEntry*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wait_async">
        <callback name="wait_async">
          <return-value transfer-ownership="none">
            <type name="ClockReturn" c:type="GstClockReturn"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
            <parameter name="entry" transfer-ownership="none">
              <type name="ClockEntry" c:type="GstClockEntry*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unschedule">
        <callback name="unschedule">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
            <parameter name="entry" transfer-ownership="none">
              <type name="ClockEntry" c:type="GstClockEntry*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wait_jitter">
        <callback name="wait_jitter">
          <return-value transfer-ownership="none">
            <type name="ClockReturn" c:type="GstClockReturn"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
            <parameter name="entry" transfer-ownership="none">
              <type name="ClockEntry" c:type="GstClockEntry*"/>
            </parameter>
            <parameter name="jitter" transfer-ownership="none">
              <type name="ClockTimeDiff" c:type="GstClockTimeDiff*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ClockEntry" c:type="GstClockEntry">
      <doc xml:whitespace="preserve">All pending timeouts or periodic notifies are converted into
an entry.
Note that GstClockEntry should be treated as an opaque structure. It must
not be extended or allocated using a custom allocator.</doc>
      <field name="refcount" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="clock" writable="1">
        <type name="Clock" c:type="GstClock*"/>
      </field>
      <field name="type" writable="1">
        <type name="ClockEntryType" c:type="GstClockEntryType"/>
      </field>
      <field name="time" writable="1">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="interval" writable="1">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="status" writable="1">
        <type name="ClockReturn" c:type="GstClockReturn"/>
      </field>
      <field name="func" writable="1">
        <type name="ClockCallback" c:type="GstClockCallback"/>
      </field>
      <field name="user_data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="destroy_data" writable="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="unscheduled" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="woken_up" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </record>
    <enumeration name="ClockEntryType" c:type="GstClockEntryType">
      <doc xml:whitespace="preserve">The type of the clock entry</doc>
      <member name="single" value="0" c:identifier="GST_CLOCK_ENTRY_SINGLE"/>
      <member name="periodic"
              value="1"
              c:identifier="GST_CLOCK_ENTRY_PERIODIC"/>
    </enumeration>
    <bitfield name="ClockFlags" c:type="GstClockFlags">
      <doc xml:whitespace="preserve">The capabilities of this clock</doc>
      <member name="can_do_single_sync"
              value="16"
              c:identifier="GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC"/>
      <member name="can_do_single_async"
              value="32"
              c:identifier="GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC"/>
      <member name="can_do_periodic_sync"
              value="64"
              c:identifier="GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC"/>
      <member name="can_do_periodic_async"
              value="128"
              c:identifier="GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC"/>
      <member name="can_set_resolution"
              value="256"
              c:identifier="GST_CLOCK_FLAG_CAN_SET_RESOLUTION"/>
      <member name="can_set_master"
              value="512"
              c:identifier="GST_CLOCK_FLAG_CAN_SET_MASTER"/>
      <member name="last" value="4096" c:identifier="GST_CLOCK_FLAG_LAST"/>
    </bitfield>
    <record name="ClockPrivate" c:type="GstClockPrivate" disguised="1">
    </record>
    <enumeration name="ClockReturn" c:type="GstClockReturn">
      <doc xml:whitespace="preserve">The return value of a clock operation.</doc>
      <member name="ok" value="0" c:identifier="GST_CLOCK_OK"/>
      <member name="early" value="1" c:identifier="GST_CLOCK_EARLY"/>
      <member name="unscheduled"
              value="2"
              c:identifier="GST_CLOCK_UNSCHEDULED"/>
      <member name="busy" value="3" c:identifier="GST_CLOCK_BUSY"/>
      <member name="badtime" value="4" c:identifier="GST_CLOCK_BADTIME"/>
      <member name="error" value="5" c:identifier="GST_CLOCK_ERROR"/>
      <member name="unsupported"
              value="6"
              c:identifier="GST_CLOCK_UNSUPPORTED"/>
      <member name="done" value="7" c:identifier="GST_CLOCK_DONE"/>
    </enumeration>
    <enumeration name="ClockType" c:type="GstClockType">
      <doc xml:whitespace="preserve">The different kind of clocks.</doc>
      <member name="realtime"
              value="0"
              c:identifier="GST_CLOCK_TYPE_REALTIME"/>
      <member name="monotonic"
              value="1"
              c:identifier="GST_CLOCK_TYPE_MONOTONIC"/>
    </enumeration>
    <callback name="CopyFunction"
              c:type="GstCopyFunction"
              version="0.10.25"
              introspectable="0">
      <doc xml:whitespace="preserve">A function to create a copy of some object or
increase its reference count.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a copy of the object or the same object with increased reference count</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The object to copy</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="CoreError"
                 c:type="GstCoreError"
                 glib:error-quark="gst_core_error_quark">
      <doc xml:whitespace="preserve">Core errors are errors inside the core GStreamer library.</doc>
      <member name="failed" value="1" c:identifier="GST_CORE_ERROR_FAILED"/>
      <member name="too_lazy"
              value="2"
              c:identifier="GST_CORE_ERROR_TOO_LAZY"/>
      <member name="not_implemented"
              value="3"
              c:identifier="GST_CORE_ERROR_NOT_IMPLEMENTED"/>
      <member name="state_change"
              value="4"
              c:identifier="GST_CORE_ERROR_STATE_CHANGE"/>
      <member name="pad" value="5" c:identifier="GST_CORE_ERROR_PAD"/>
      <member name="thread" value="6" c:identifier="GST_CORE_ERROR_THREAD"/>
      <member name="negotiation"
              value="7"
              c:identifier="GST_CORE_ERROR_NEGOTIATION"/>
      <member name="event" value="8" c:identifier="GST_CORE_ERROR_EVENT"/>
      <member name="seek" value="9" c:identifier="GST_CORE_ERROR_SEEK"/>
      <member name="caps" value="10" c:identifier="GST_CORE_ERROR_CAPS"/>
      <member name="tag" value="11" c:identifier="GST_CORE_ERROR_TAG"/>
      <member name="missing_plugin"
              value="12"
              c:identifier="GST_CORE_ERROR_MISSING_PLUGIN"/>
      <member name="clock" value="13" c:identifier="GST_CORE_ERROR_CLOCK"/>
      <member name="disabled"
              value="14"
              c:identifier="GST_CORE_ERROR_DISABLED"/>
      <member name="num_errors"
              value="15"
              c:identifier="GST_CORE_ERROR_NUM_ERRORS"/>
    </enumeration>
    <constant name="DEBUG_BG_MASK" value="240">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="DEBUG_FG_MASK" value="15">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="DEBUG_FORMAT_MASK" value="65280">
      <type name="gint" c:type="gint"/>
    </constant>
    <glib:boxed glib:name="Date"
                c:symbol-prefix="date"
                glib:type-name="GstDate"
                glib:get-type="gst_date_get_type">
    </glib:boxed>
    <record name="DateTime"
            c:type="GstDateTime"
            glib:type-name="GstDateTime"
            glib:get-type="gst_date_time_get_type"
            c:symbol-prefix="date_time">
      <doc xml:whitespace="preserve">Struct to store date, time and timezone information altogether.
#GstDateTime is refcounted and immutable.
Date information is handled using the proleptic Gregorian calendar.
Provides basic creation functions and accessor functions to its fields.</doc>
      <constructor name="new"
                   c:identifier="gst_date_time_new"
                   version="0.10.31">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime using the date and times in the gregorian calendar
in the supplied timezone.
1 to 31, @hour from 0 to 23, @minutes and @seconds from 0 to 59.
Note that @tzoffset is a float and was chosen so for being able to handle
some fractional timezones, while it still keeps the readability of
represeting it in hours for most timezones.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="tzoffset" transfer-ownership="none">
            <doc xml:whitespace="preserve">Offset from UTC in hours.</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="year" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian year</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian month</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="day" transfer-ownership="none">
            <doc xml:whitespace="preserve">the day of the gregorian month</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hour" transfer-ownership="none">
            <doc xml:whitespace="preserve">the hour of the day</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minute" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minute of the hour</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="seconds" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second of the minute</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_unix_epoch_local_time"
                   c:identifier="gst_date_time_new_from_unix_epoch_local_time"
                   version="0.10.31">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime using the time since Jan 1, 1970 specified by</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="secs" transfer-ownership="none">
            <doc xml:whitespace="preserve">seconds from the Unix epoch</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_unix_epoch_utc"
                   c:identifier="gst_date_time_new_from_unix_epoch_utc"
                   version="0.10.31">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime using the time since Jan 1, 1970 specified by</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="secs" transfer-ownership="none">
            <doc xml:whitespace="preserve">seconds from the Unix epoch</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_local_time"
                   c:identifier="gst_date_time_new_local_time"
                   version="0.10.31">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime using the date and times in the gregorian calendar
in the local timezone.
1 to 31, @hour from 0 to 23, @minutes and @seconds from 0 to 59.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian year</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian month</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="day" transfer-ownership="none">
            <doc xml:whitespace="preserve">the day of the gregorian month</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hour" transfer-ownership="none">
            <doc xml:whitespace="preserve">the hour of the day</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minute" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minute of the hour</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="seconds" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second of the minute</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_now_local_time"
                   c:identifier="gst_date_time_new_now_local_time"
                   version="0.10.31">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime representing the current date and time.
be freed with gst_date_time_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime which should</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
      </constructor>
      <constructor name="new_now_utc"
                   c:identifier="gst_date_time_new_now_utc"
                   version="0.10.31">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime that represents the current instant at Universal
coordinated time.
be freed with gst_date_time_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime which should</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
      </constructor>
      <method name="get_day"
              c:identifier="gst_date_time_get_day"
              version="0.10.31">
        <doc xml:whitespace="preserve">Returns the day of this #GstDateTime.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The day of this #GstDateTime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_hour"
              c:identifier="gst_date_time_get_hour"
              version="0.10.31">
        <doc xml:whitespace="preserve">Retrieves the hour of the day represented by @datetime in the gregorian
calendar. The return is in the range of 0 to 23.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hour of the day</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_microsecond"
              c:identifier="gst_date_time_get_microsecond"
              version="0.10.31">
        <doc xml:whitespace="preserve">Retrieves the fractional part of the seconds in microseconds represented by</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the microsecond of the second</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_minute"
              c:identifier="gst_date_time_get_minute"
              version="0.10.31">
        <doc xml:whitespace="preserve">Retrieves the minute of the hour represented by @datetime in the gregorian
calendar.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the minute of the hour</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_month"
              c:identifier="gst_date_time_get_month"
              version="0.10.31">
        <doc xml:whitespace="preserve">Returns the month of this #GstDateTime. January is 1, February is 2, etc..</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The month of this #GstDateTime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_second"
              c:identifier="gst_date_time_get_second"
              version="0.10.31">
        <doc xml:whitespace="preserve">Retrieves the second of the minute represented by @datetime in the gregorian
calendar.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the second represented by @datetime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_time_zone_offset"
              c:identifier="gst_date_time_get_time_zone_offset"
              version="0.10.31">
        <doc xml:whitespace="preserve">Retrieves the offset from UTC in hours that the timezone specified
by @datetime represents. Timezones ahead (to the east) of UTC have positive
values, timezones before (to the west) of UTC have negative values.
If @datetime represents UTC time, then the offset is zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset from UTC in hours</doc>
          <type name="gfloat" c:type="gfloat"/>
        </return-value>
      </method>
      <method name="get_year"
              c:identifier="gst_date_time_get_year"
              version="0.10.31">
        <doc xml:whitespace="preserve">Returns the year of this #GstDateTime</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The year of this #GstDateTime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="gst_date_time_ref" version="0.10.31">
        <doc xml:whitespace="preserve">Atomically increments the reference count of @datetime by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the reference @datetime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
      </method>
      <method name="unref"
              c:identifier="gst_date_time_unref"
              version="0.10.31">
        <doc xml:whitespace="preserve">Atomically decrements the reference count of @datetime by one.  When the
reference count reaches zero, the structure is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="DebugCategory" c:type="GstDebugCategory">
      <doc xml:whitespace="preserve">This is the struct that describes the categories. Once initialized with
#GST_DEBUG_CATEGORY_INIT, its values can't be changed anymore.</doc>
      <field name="threshold" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="color" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="name" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="description" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <method name="free" c:identifier="gst_debug_category_free">
        <doc xml:whitespace="preserve">Removes and frees the category and all associated resources.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_color" c:identifier="gst_debug_category_get_color">
        <doc xml:whitespace="preserve">Returns the color of a debug category used when printing output in this
category.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the color of the category.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_description"
              c:identifier="gst_debug_category_get_description">
        <doc xml:whitespace="preserve">Returns the description of a debug category.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the description of the category.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_name" c:identifier="gst_debug_category_get_name">
        <doc xml:whitespace="preserve">Returns the name of a debug category.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the category.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_threshold"
              c:identifier="gst_debug_category_get_threshold">
        <doc xml:whitespace="preserve">Returns the threshold of a #GstDebugCategory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstDebugLevel that is used as threshold.</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </return-value>
      </method>
      <method name="reset_threshold"
              c:identifier="gst_debug_category_reset_threshold">
        <doc xml:whitespace="preserve">Resets the threshold of the category to the default level. Debug information
will only be output if the threshold is lower or equal to the level of the
debugging message.
Use this function to set the threshold back to where it was after using
gst_debug_category_set_threshold().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_threshold"
              c:identifier="gst_debug_category_set_threshold">
        <doc xml:whitespace="preserve">Sets the threshold of the category to the given level. Debug information will
only be output if the threshold is lower or equal to the level of the
debugging message.
&lt;note&gt;&lt;para&gt;
Do not use this function in production code, because other functions may
change the threshold of categories as side effect. It is however a nice
function to use when debugging (even from gdb).
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="level" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstDebugLevel threshold to set.</doc>
            <type name="DebugLevel" c:type="GstDebugLevel"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="DebugColorFlags" c:type="GstDebugColorFlags">
      <doc xml:whitespace="preserve">These are some terminal style flags you can use when creating your
debugging categories to make them stand out in debugging output.</doc>
      <member name="fg_black" value="0" c:identifier="GST_DEBUG_FG_BLACK"/>
      <member name="fg_red" value="1" c:identifier="GST_DEBUG_FG_RED"/>
      <member name="fg_green" value="2" c:identifier="GST_DEBUG_FG_GREEN"/>
      <member name="fg_yellow" value="3" c:identifier="GST_DEBUG_FG_YELLOW"/>
      <member name="fg_blue" value="4" c:identifier="GST_DEBUG_FG_BLUE"/>
      <member name="fg_magenta" value="5" c:identifier="GST_DEBUG_FG_MAGENTA"/>
      <member name="fg_cyan" value="6" c:identifier="GST_DEBUG_FG_CYAN"/>
      <member name="fg_white" value="7" c:identifier="GST_DEBUG_FG_WHITE"/>
      <member name="bg_black" value="0" c:identifier="GST_DEBUG_BG_BLACK"/>
      <member name="bg_red" value="16" c:identifier="GST_DEBUG_BG_RED"/>
      <member name="bg_green" value="32" c:identifier="GST_DEBUG_BG_GREEN"/>
      <member name="bg_yellow" value="48" c:identifier="GST_DEBUG_BG_YELLOW"/>
      <member name="bg_blue" value="64" c:identifier="GST_DEBUG_BG_BLUE"/>
      <member name="bg_magenta"
              value="80"
              c:identifier="GST_DEBUG_BG_MAGENTA"/>
      <member name="bg_cyan" value="96" c:identifier="GST_DEBUG_BG_CYAN"/>
      <member name="bg_white" value="112" c:identifier="GST_DEBUG_BG_WHITE"/>
      <member name="bold" value="256" c:identifier="GST_DEBUG_BOLD"/>
      <member name="underline" value="512" c:identifier="GST_DEBUG_UNDERLINE"/>
    </enumeration>
    <callback name="DebugFuncPtr" c:type="GstDebugFuncPtr">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </callback>
    <bitfield name="DebugGraphDetails"
              version="0.10.15"
              c:type="GstDebugGraphDetails">
      <doc xml:whitespace="preserve">Available details for pipeline graphs produced by GST_DEBUG_BIN_TO_DOT_FILE()
and GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS().</doc>
      <member name="media_type"
              value="1"
              c:identifier="GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE"/>
      <member name="caps_details"
              value="2"
              c:identifier="GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS"/>
      <member name="non_default_params"
              value="4"
              c:identifier="GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS"/>
      <member name="states"
              value="8"
              c:identifier="GST_DEBUG_GRAPH_SHOW_STATES"/>
      <member name="all" value="15" c:identifier="GST_DEBUG_GRAPH_SHOW_ALL"/>
    </bitfield>
    <enumeration name="DebugLevel" c:type="GstDebugLevel">
      <doc xml:whitespace="preserve">The level defines the importance of a debugging message. The more important a
message is, the greater the probability that the debugging system outputs it.</doc>
      <member name="none" value="0" c:identifier="GST_LEVEL_NONE"/>
      <member name="error" value="1" c:identifier="GST_LEVEL_ERROR"/>
      <member name="warning" value="2" c:identifier="GST_LEVEL_WARNING"/>
      <member name="info" value="3" c:identifier="GST_LEVEL_INFO"/>
      <member name="debug" value="4" c:identifier="GST_LEVEL_DEBUG"/>
      <member name="log" value="5" c:identifier="GST_LEVEL_LOG"/>
      <member name="fixme" value="6" c:identifier="GST_LEVEL_FIXME"/>
      <member name="trace" value="7" c:identifier="GST_LEVEL_TRACE"/>
      <member name="memdump" value="9" c:identifier="GST_LEVEL_MEMDUMP"/>
      <member name="count" value="10" c:identifier="GST_LEVEL_COUNT"/>
    </enumeration>
    <record name="DebugMessage" c:type="GstDebugMessage" disguised="1">
      <method name="get" c:identifier="gst_debug_message_get">
        <doc xml:whitespace="preserve">Gets the string representation of a #GstDebugMessage. This function is used
in debug handlers to extract the message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the string representation of a #GstDebugMessage.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
    </record>
    <constant name="ELEMENT_FACTORY_KLASS_DECODER" value="Decoder">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_DEMUXER" value="Demuxer">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_DEPAYLOADER" value="Depayloader">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_ENCODER" value="Encoder">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_FORMATTER" value="Formatter">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MEDIA_AUDIO" value="Audio">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MEDIA_IMAGE" value="Image">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MEDIA_METADATA" value="Metadata">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE" value="Subtitle">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MEDIA_VIDEO" value="Video">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MUXER" value="Muxer">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_PARSER" value="Parser">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_PAYLOADER" value="Payloader">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_SINK" value="Sink">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_SRC" value="Source">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_ANY" value="-1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_AUDIO_ENCODER" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_DECODABLE" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_DECODER" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_DEMUXER" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_DEPAYLOADER" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_ENCODER" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_FORMATTER" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MAX_ELEMENTS" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_ANY" value="-281474976710656">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_AUDIO" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_IMAGE" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_METADATA" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_VIDEO" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MUXER" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_PARSER" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_PAYLOADER" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_SINK" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_SRC" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_VIDEO_ENCODER" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ERROR_SYSTEM" value="system error: %s">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="EVENT_TRACE_NAME" value="GstEvent">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="EVENT_TYPE_BOTH" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EVENT_TYPE_SHIFT" value="4">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Element"
           c:symbol-prefix="element"
           c:type="GstElement"
           parent="Object"
           abstract="1"
           glib:type-name="GstElement"
           glib:get-type="gst_element_get_type"
           glib:type-struct="ElementClass">
      <doc xml:whitespace="preserve">GstElement is the abstract base class needed to construct an element that
can be used in a GStreamer pipeline. Please refer to the plugin writers
guide for more information on creating #GstElement subclasses.
The name of a #GstElement can be get with gst_element_get_name() and set with
gst_element_set_name().  For speed, GST_ELEMENT_NAME() can be used in the
core when using the appropriate locking. Do not use this in plug-ins or
applications in order to retain ABI compatibility.
All elements have pads (of the type #GstPad).  These pads link to pads on
other elements.  #GstBuffer flow between these linked pads.
A #GstElement has a #GList of #GstPad structures for all their input (or sink)
and output (or source) pads.
Core and plug-in writers can add and remove pads with gst_element_add_pad()
and gst_element_remove_pad().
A pad of an element can be retrieved by name with gst_element_get_pad().
An iterator of all pads can be retrieved with gst_element_iterate_pads().
Elements can be linked through their pads.
If the link is straightforward, use the gst_element_link()
convenience function to link two elements, or gst_element_link_many()
for more elements in a row.
Use gst_element_link_filtered() to link two elements constrained by
a specified set of #GstCaps.
For finer control, use gst_element_link_pads() and
gst_element_link_pads_filtered() to specify the pads to link on
each element by name.
Each element has a state (see #GstState).  You can get and set the state
of an element with gst_element_get_state() and gst_element_set_state().
Setting a state triggers a #GstStateChange. To get a string representation
of a #GstState, use gst_element_state_get_name().
You can get and set a #GstClock on an element using gst_element_get_clock()
and gst_element_set_clock().
Some elements can provide a clock for the pipeline if
gst_element_provides_clock() returns %TRUE. With the
gst_element_provide_clock() method one can retrieve the clock provided by
such an element.
Not all elements require a clock to operate correctly. If
gst_element_requires_clock() returns %TRUE, a clock should be set on the
element with gst_element_set_clock().
Note that clock slection and distribution is normally handled by the
toplevel #GstPipeline so the clock functions are only to be used in very
specific situations.
Last reviewed on 2009-05-29 (0.10.24)</doc>
      <function name="make_from_uri" c:identifier="gst_element_make_from_uri">
        <doc xml:whitespace="preserve">Creates an element for handling the given URI.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new element or NULL if none could be created</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether to create a source or a sink</doc>
            <type name="URIType" c:type="GstURIType"/>
          </parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">URI to create an element for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="elementname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">Name of created element, can be NULL.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register" c:identifier="gst_element_register">
        <doc xml:whitespace="preserve">Create a new elementfactory capable of instantiating objects of the</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if the registering succeeded, FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="plugin" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">#GstPlugin to register the element with, or NULL for a static element (note that passing NULL only works in GStreamer 0.10.13 and later)</doc>
            <type name="Plugin" c:type="GstPlugin*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of elements of this type</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="rank" transfer-ownership="none">
            <doc xml:whitespace="preserve">rank of element (higher rank means more importance when autoplugging)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">GType of element to register</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
      <function name="state_change_return_get_name"
                c:identifier="gst_element_state_change_return_get_name"
                version="0.10.11">
        <doc xml:whitespace="preserve">Gets a string representing the given state change result.
result.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string with the name of the state</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="state_ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstStateChangeReturn to get the name of.</doc>
            <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
          </parameter>
        </parameters>
      </function>
      <function name="state_get_name"
                c:identifier="gst_element_state_get_name">
        <doc xml:whitespace="preserve">Gets a string representing the given state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string with the name of the state.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstState to get the name of.</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="change_state" invoker="change_state">
        <doc xml:whitespace="preserve">Perform @transition on @element.
This function must be called with STATE_LOCK held and is mainly used
internally.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstStateChangeReturn of the state transition.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="transition" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested transition</doc>
            <type name="StateChange" c:type="GstStateChange"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_index" invoker="get_index">
        <doc xml:whitespace="preserve">Gets the index from the element.
element. unref after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIndex or %NULL when no index was set on the</doc>
          <type name="Index" c:type="GstIndex*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_query_types" invoker="get_query_types">
        <doc xml:whitespace="preserve">Get an array of query types from the element.
If the element doesn't implement a query types function,
the query will be forwarded to the peer of a random linked sink pad.
be freed or modified.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #GstQueryType elements that should not</doc>
          <type name="QueryType" c:type="GstQueryType*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_state" invoker="get_state">
        <doc xml:whitespace="preserve">Gets the state of the element.
For elements that performed an ASYNC state change, as reported by
gst_element_set_state(), this function will block up to the
specified timeout value for the state change to complete.
If the element completes the state change or goes into
an error, this function returns immediately with a return value of
%GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
returns the current and pending state immediately.
This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
successfully changed its state but is not able to provide data yet.
This mostly happens for live sources that only produce data in
%GST_STATE_PLAYING. While the state change return is equivalent to
%GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
some sink elements might not be able to complete their state change because
an element is not producing data to complete the preroll. When setting the
element to playing, the preroll will complete and playback will start.
and the last state change succeeded, %GST_STATE_CHANGE_ASYNC if the
element is still performing a state change or
%GST_STATE_CHANGE_FAILURE if the last state change failed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%GST_STATE_CHANGE_SUCCESS if the element has no more pending state</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="state"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to #GstState to hold the state. Can be %NULL.</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="pending"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to #GstState to hold the pending state. Can be %NULL.</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockTime to specify the timeout for an async state change or %GST_CLOCK_TIME_NONE for infinite timeout.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="no_more_pads" invoker="no_more_pads">
        <doc xml:whitespace="preserve">Use this function to signal that the element does not expect any more pads
to show up in the current pipeline. This function should be called whenever
pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
pad templates use this in combination with autopluggers to figure out that
the element is done initializing its pads.
This function emits the #GstElement::no-more-pads signal.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="pad_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pad_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="provide_clock" invoker="provide_clock">
        <doc xml:whitespace="preserve">Get the clock provided by the given element.
&lt;note&gt;An element is only required to provide a clock in the PAUSED
state. Some elements can provide a clock in other states.&lt;/note&gt;
if no clock could be provided.  Unref after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the GstClock provided by the element or %NULL</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="query" invoker="query">
        <doc xml:whitespace="preserve">Performs a query on the given element.
For elements that don't implement a query handler, this function
forwards the query to a random srcpad or to the peer of a
random linked sinkpad of this element.
Please note that some queries might need a running pipeline to work.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstQuery.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="release_pad">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_new_pad" introspectable="0">
        <return-value>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="templ" transfer-ownership="none">
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_new_pad_full" introspectable="0">
        <return-value>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="templ" transfer-ownership="none">
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send_event" invoker="send_event">
        <doc xml:whitespace="preserve">Sends an event to an element. If the element doesn't implement an
event handler, the event will be pushed on a random linked sink pad for
upstream events or a random linked source pad for downstream events.
This function takes owership of the provided event so you should
gst_event_ref() it if you want to reuse the event after this call.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the event was handled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstEvent to send to the element.</doc>
            <type name="Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_bus" invoker="set_bus">
        <doc xml:whitespace="preserve">Sets the bus of the element. Increases the refcount on the bus.
For internal use only, unless you're testing elements.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bus" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstBus to set.</doc>
            <type name="Bus" c:type="GstBus*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_clock" invoker="set_clock">
        <doc xml:whitespace="preserve">Sets the clock for the element. This function increases the
refcount on the clock. Any previously set clock on the object
is unreffed.
clock when it, for example, is not able to slave its internal clock to the
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the element accepted the clock. An element can refuse a</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstClock to set for the element.</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_index" invoker="set_index">
        <doc xml:whitespace="preserve">Set @index on the element. The refcount of the index
will be increased, any previously set index is unreffed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstIndex.</doc>
            <type name="Index" c:type="GstIndex*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_state" invoker="set_state">
        <doc xml:whitespace="preserve">Sets the state of the element. This function will try to set the
requested state by going through all the intermediary states and calling
the class's state change function for each.
This function can return #GST_STATE_CHANGE_ASYNC, in which case the
element will perform the remainder of the state change asynchronously in
another thread.
An application can use gst_element_get_state() to wait for the completion
of the state change or it can wait for a state change message on the bus.
State changes to %GST_STATE_READY or %GST_STATE_NULL never return
#GST_STATE_CHANGE_ASYNC.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Result of the state change using #GstStateChangeReturn.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the element's new #GstState.</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="abort_state" c:identifier="gst_element_abort_state">
        <doc xml:whitespace="preserve">Abort the state change of the element. This function is used
by elements that do asynchronous state changes and find out
something is wrong.
This function should be called with the STATE_LOCK held.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="add_pad" c:identifier="gst_element_add_pad">
        <doc xml:whitespace="preserve">Adds a pad (link point) to @element. @pad's parent will be set to @element;
see gst_object_set_parent() for refcounting information.
Pads are not automatically activated so elements should perform the needed
steps to activate the pad in case this pad is added in the PAUSED or PLAYING
state. See gst_pad_set_active() for more information about activating pads.
The pad and the element should be unlocked when calling this function.
This function will emit the #GstElement::pad-added signal on the element.
a pad with the same name already existed or the pad already had another
parent.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the pad could be added. This function can fail when</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstPad to add to the element.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_state" c:identifier="gst_element_change_state">
        <doc xml:whitespace="preserve">Perform @transition on @element.
This function must be called with STATE_LOCK held and is mainly used
internally.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstStateChangeReturn of the state transition.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="transition" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested transition</doc>
            <type name="StateChange" c:type="GstStateChange"/>
          </parameter>
        </parameters>
      </method>
      <method name="continue_state" c:identifier="gst_element_continue_state">
        <doc xml:whitespace="preserve">Commit the state change of the element and proceed to the next
pending state if any. This function is used
by elements that do asynchronous state changes.
The core will normally call this method automatically when an
element returned %GST_STATE_CHANGE_SUCCESS from the state change function.
If after calling this method the element still has not reached
the pending state, the next state change is performed.
This method is used internally and should normally not be called by plugins
or applications.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The result of the commit state change.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">The previous state return value</doc>
            <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_all_pads"
              c:identifier="gst_element_create_all_pads">
        <doc xml:whitespace="preserve">Creates a pad for each pad template that is always available.
This function is only useful during object intialization of
subclasses of #GstElement.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="found_tags" c:identifier="gst_element_found_tags">
        <doc xml:whitespace="preserve">Posts a message to the bus that new tags were found, and pushes an event
to all sourcepads. Takes ownership of the @list.
This is a utility method for elements. Applications should use the
#GstTagSetter interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">list of tags.</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="found_tags_for_pad"
              c:identifier="gst_element_found_tags_for_pad">
        <doc xml:whitespace="preserve">Posts a message to the bus that new tags were found and pushes the
tags as event. Takes ownership of the @list.
This is a utility method for elements. Applications should use the
#GstTagSetter interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">pad on which to push tag-event</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">the taglist to post on the bus and create event from</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_base_time" c:identifier="gst_element_get_base_time">
        <doc xml:whitespace="preserve">Returns the base time of the element. The base time is the
absolute time of the clock when this element was last put to
PLAYING. Subtracting the base time from the clock time gives
the running time of the element.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the base time of the element.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_bus" c:identifier="gst_element_get_bus">
        <doc xml:whitespace="preserve">Returns the bus of the element. Note that only a #GstPipeline will provide a
bus for the application.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the element's #GstBus. unref after usage.</doc>
          <type name="Bus" c:type="GstBus*"/>
        </return-value>
      </method>
      <method name="get_clock" c:identifier="gst_element_get_clock">
        <doc xml:whitespace="preserve">Gets the currently configured clock of the element. This is the clock as was
last set with gst_element_set_clock().
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstClock of the element. unref after usage.</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </method>
      <method name="get_compatible_pad"
              c:identifier="gst_element_get_compatible_pad">
        <doc xml:whitespace="preserve">Looks for an unlinked pad to which the given pad can link. It is not
guaranteed that linking the pads will work, though it should work in most
cases.
This function will first attempt to find a compatible unlinked ALWAYS pad,
and if none can be found, it will request a compatible REQUEST pad by looking
at the templates of @element.
if one cannot be found. gst_object_unref() after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstPad to which a link can be made, or %NULL</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad to find a compatible one for.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstCaps to use as a filter.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_compatible_pad_template"
              c:identifier="gst_element_get_compatible_pad_template">
        <doc xml:whitespace="preserve">Retrieves a pad template from @element that is compatible with @compattempl.
Pads from compatible templates can be linked together.
was found. No unreferencing is necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a compatible #GstPadTemplate, or NULL if none</doc>
          <type name="PadTemplate" c:type="GstPadTemplate*"/>
        </return-value>
        <parameters>
          <parameter name="compattempl" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadTemplate to find a compatible template for</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_factory" c:identifier="gst_element_get_factory">
        <doc xml:whitespace="preserve">Retrieves the factory that was used to create this element.
element. no refcounting is needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstElementFactory used for creating this</doc>
          <type name="ElementFactory" c:type="GstElementFactory*"/>
        </return-value>
      </method>
      <method name="get_index" c:identifier="gst_element_get_index">
        <doc xml:whitespace="preserve">Gets the index from the element.
element. unref after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIndex or %NULL when no index was set on the</doc>
          <type name="Index" c:type="GstIndex*"/>
        </return-value>
      </method>
      <method name="get_pad"
              c:identifier="gst_element_get_pad"
              deprecated="This function is deprecated as it&apos;s unclear if the reference">
        <doc xml:whitespace="preserve">Retrieves a pad from @element by name. Tries gst_element_get_static_pad()
first, then gst_element_get_request_pad().
to the result pad should be released with gst_object_unref() in case of a static pad
or gst_element_release_request_pad() in case of a request pad.
Use gst_element_get_static_pad() or gst_element_get_request_pad() instead.
depending on the type of the pad.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstPad if found, otherwise %NULL. Unref or Release after usage,</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the pad to retrieve.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_query_types"
              c:identifier="gst_element_get_query_types">
        <doc xml:whitespace="preserve">Get an array of query types from the element.
If the element doesn't implement a query types function,
the query will be forwarded to the peer of a random linked sink pad.
be freed or modified.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #GstQueryType elements that should not</doc>
          <type name="QueryType" c:type="GstQueryType*"/>
        </return-value>
      </method>
      <method name="get_request_pad"
              c:identifier="gst_element_get_request_pad">
        <doc xml:whitespace="preserve">Retrieves a pad from the element by name. This version only retrieves
request pads. The pad should be released with
gst_element_release_request_pad().
This method is slow and will be deprecated in the future. New code should
use gst_element_request_pad() with the requested template.
Release after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">requested #GstPad if found, otherwise %NULL.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the request #GstPad to retrieve.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_start_time"
              c:identifier="gst_element_get_start_time"
              version="0.10.24">
        <doc xml:whitespace="preserve">Returns the start time of the element. The start time is the
running time of the clock when this element was last put to PAUSED.
Usually the start_time is managed by a toplevel element such as
#GstPipeline.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the start time of the element.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_state" c:identifier="gst_element_get_state">
        <doc xml:whitespace="preserve">Gets the state of the element.
For elements that performed an ASYNC state change, as reported by
gst_element_set_state(), this function will block up to the
specified timeout value for the state change to complete.
If the element completes the state change or goes into
an error, this function returns immediately with a return value of
%GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.
For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
returns the current and pending state immediately.
This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
successfully changed its state but is not able to provide data yet.
This mostly happens for live sources that only produce data in
%GST_STATE_PLAYING. While the state change return is equivalent to
%GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
some sink elements might not be able to complete their state change because
an element is not producing data to complete the preroll. When setting the
element to playing, the preroll will complete and playback will start.
and the last state change succeeded, %GST_STATE_CHANGE_ASYNC if the
element is still performing a state change or
%GST_STATE_CHANGE_FAILURE if the last state change failed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%GST_STATE_CHANGE_SUCCESS if the element has no more pending state</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="state"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to #GstState to hold the state. Can be %NULL.</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="pending"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to #GstState to hold the pending state. Can be %NULL.</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockTime to specify the timeout for an async state change or %GST_CLOCK_TIME_NONE for infinite timeout.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_static_pad" c:identifier="gst_element_get_static_pad">
        <doc xml:whitespace="preserve">Retrieves a pad from @element by name. This version only retrieves
already-existing (i.e. 'static') pads.
unref after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the requested #GstPad if found, otherwise %NULL.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the static #GstPad to retrieve.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="implements_interface"
              c:identifier="gst_element_implements_interface">
        <doc xml:whitespace="preserve">Test whether the given element implements a certain interface of type
iface_type, and test whether it is supported for this specific instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether or not the element implements the interface.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iface_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">(final) type of the interface which we want to be implemented</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_indexable" c:identifier="gst_element_is_indexable">
        <doc xml:whitespace="preserve">Queries if the element can be indexed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the element can be indexed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_locked_state"
              c:identifier="gst_element_is_locked_state">
        <doc xml:whitespace="preserve">Checks if the state of an element is locked.
If the state of an element is locked, state changes of the parent don't
affect the element.
This way you can leave currently unused elements inside bins. Just lock their
state before changing the state from #GST_STATE_NULL.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if the element's state is locked.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="iterate_pads"
              c:identifier="gst_element_iterate_pads"
              introspectable="0">
        <doc xml:whitespace="preserve">Retrieves an iterattor of @element's pads. The iterator should
be freed after usage.
after use.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstIterator of #GstPad. Unref each pad</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_sink_pads"
              c:identifier="gst_element_iterate_sink_pads"
              introspectable="0">
        <doc xml:whitespace="preserve">Retrieves an iterator of @element's sink pads.
after use.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstIterator of #GstPad. Unref each pad</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_src_pads"
              c:identifier="gst_element_iterate_src_pads"
              introspectable="0">
        <doc xml:whitespace="preserve">Retrieves an iterator of @element's source pads.
after use.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstIterator of #GstPad. Unref each pad</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="link" c:identifier="gst_element_link">
        <doc xml:whitespace="preserve">Links @src to @dest. The link must be from source to
destination; the other direction will not be tried. The function looks for
existing pads that aren't linked yet. It will request new pads if necessary.
Such pads need to be released manualy when unlinking.
If multiple links are possible, only one is established.
Make sure you have added your elements to a bin or pipeline with
gst_bin_add() before trying to link them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the elements could be linked, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_filtered" c:identifier="gst_element_link_filtered">
        <doc xml:whitespace="preserve">Links @src to @dest using the given caps as filtercaps.
The link must be from source to
destination; the other direction will not be tried. The function looks for
existing pads that aren't linked yet. It will request new pads if necessary.
If multiple links are possible, only one is established.
Make sure you have added your elements to a bin or pipeline with
gst_bin_add() before trying to link them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads could be linked, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the #GstCaps to filter the link, or #NULL for no filter.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_many"
              c:identifier="gst_element_link_many"
              introspectable="0">
        <doc xml:whitespace="preserve">Chain together a series of elements. Uses gst_element_link().
Make sure you have added your elements to a bin or pipeline with
gst_bin_add() before trying to link them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second #GstElement in the link chain.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="link_pads" c:identifier="gst_element_link_pads">
        <doc xml:whitespace="preserve">Links the two named pads of the source and destination elements.
Side effect is that if one of the pads has no parent, it becomes a
child of the parent of the other element.  If they have different
parents, the link fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads could be linked, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="srcpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in source element or NULL for any pad.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="destpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in destination element, or NULL for any pad.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_pads_filtered"
              c:identifier="gst_element_link_pads_filtered">
        <doc xml:whitespace="preserve">Links the two named pads of the source and destination elements. Side effect
is that if one of the pads has no parent, it becomes a child of the parent of
the other element. If they have different parents, the link fails. If @caps
is not #NULL, makes sure that the caps of the link is a subset of @caps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads could be linked, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="srcpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in source element or NULL for any pad.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="destpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in destination element or NULL for any pad.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the #GstCaps to filter the link, or #NULL for no filter.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_pads_full"
              c:identifier="gst_element_link_pads_full"
              version="0.10.30">
        <doc xml:whitespace="preserve">Links the two named pads of the source and destination elements.
Side effect is that if one of the pads has no parent, it becomes a
child of the parent of the other element.  If they have different
parents, the link fails.
Calling gst_element_link_pads_full() with @flags == %GST_PAD_LINK_CHECK_DEFAULT
is the same as calling gst_element_link_pads() and the recommended way of
linking pads with safety checks applied.
This is a convenience function for gst_pad_link_full().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads could be linked, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="srcpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in source element or NULL for any pad.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="destpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in destination element, or NULL for any pad.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadLinkCheck to be performed when linking pads.</doc>
            <type name="PadLinkCheck" c:type="GstPadLinkCheck"/>
          </parameter>
        </parameters>
      </method>
      <method name="lost_state" c:identifier="gst_element_lost_state">
        <doc xml:whitespace="preserve">Brings the element to the lost state. This function calls
gst_element_lost_state_full() with the new_base_time set to %TRUE.
This function is used internally and should normally not be called from
plugins or applications.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="lost_state_full"
              c:identifier="gst_element_lost_state_full"
              version="0.10.24">
        <doc xml:whitespace="preserve">Brings the element to the lost state. The current state of the
element is copied to the pending state so that any call to
gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.
An ASYNC_START message is posted with indication to distribute a new
base_time to the element when @new_base_time is %TRUE.
If the element was PLAYING, it will go to PAUSED. The element
will be restored to its PLAYING state by the parent pipeline when it
prerolls again.
This is mostly used for elements that lost their preroll buffer
in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
they will go to their pending state again when a new preroll buffer is
queued. This function can only be called when the element is currently
not in error or an async state change.
This function is used internally and should normally not be called from
plugins or applications.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="new_base_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">if a new base time should be distributed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="message_full" c:identifier="gst_element_message_full">
        <doc xml:whitespace="preserve">Post an error, warning or info message on the bus from inside an element.
#GST_MESSAGE_INFO.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstMessageType</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GStreamer GError domain this message belongs to</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GError code belonging to the domain</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="text" transfer-ownership="full" allow-none="1">
            <doc xml:whitespace="preserve">an allocated text string to be used as a replacement for the default message connected to code, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="full" allow-none="1">
            <doc xml:whitespace="preserve">an allocated debug message to be used as a replacement for the default debugging information, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source code file where the error was generated</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="function" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source code function where the error was generated</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="line" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source code line where the error was generated</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="no_more_pads" c:identifier="gst_element_no_more_pads">
        <doc xml:whitespace="preserve">Use this function to signal that the element does not expect any more pads
to show up in the current pipeline. This function should be called whenever
pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
pad templates use this in combination with autopluggers to figure out that
the element is done initializing its pads.
This function emits the #GstElement::no-more-pads signal.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="post_message" c:identifier="gst_element_post_message">
        <doc xml:whitespace="preserve">Post a message on the element's #GstBus. This function takes ownership of the
message; if you want to access the message after this call, you should add an
additional reference before calling.
%FALSE if the element did not have a bus.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the message was successfully posted. The function returns</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstMessage to post</doc>
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="provide_clock" c:identifier="gst_element_provide_clock">
        <doc xml:whitespace="preserve">Get the clock provided by the given element.
&lt;note&gt;An element is only required to provide a clock in the PAUSED
state. Some elements can provide a clock in other states.&lt;/note&gt;
if no clock could be provided.  Unref after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the GstClock provided by the element or %NULL</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </method>
      <method name="provides_clock" c:identifier="gst_element_provides_clock">
        <doc xml:whitespace="preserve">Query if the element provides a clock. A #GstClock provided by an
element can be used as the global #GstClock for the pipeline.
An element that can provide a clock is only required to do so in the PAUSED
state, this means when it is fully negotiated and has allocated the resources
to operate the clock.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the element provides a clock</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="query" c:identifier="gst_element_query">
        <doc xml:whitespace="preserve">Performs a query on the given element.
For elements that don't implement a query handler, this function
forwards the query to a random srcpad or to the peer of a
random linked sinkpad of this element.
Please note that some queries might need a running pipeline to work.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstQuery.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_convert" c:identifier="gst_element_query_convert">
        <doc xml:whitespace="preserve">Queries an element to convert @src_val in @src_format to @dest_format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_format"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstFormat to convert from.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">a value to convert.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the #GstFormat to convert to.</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="dest_val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the result.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_duration" c:identifier="gst_element_query_duration">
        <doc xml:whitespace="preserve">Queries an element for the total stream duration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the #GstFormat asked for. On return contains the #GstFormat used.</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A location in which to store the total duration, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_position" c:identifier="gst_element_query_position">
        <doc xml:whitespace="preserve">Queries an element for the stream position. If one repeatedly calls this
function one can also create and reuse it in gst_element_query().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the #GstFormat asked for. On return contains the #GstFormat used.</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="cur"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location in which to store the current position, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_request_pad"
              c:identifier="gst_element_release_request_pad">
        <doc xml:whitespace="preserve">Makes the element free the previously requested pad as obtained
with gst_element_get_request_pad().
This does not unref the pad. If the pad was created by using
gst_element_get_request_pad(), gst_element_release_request_pad() needs to be
followed by gst_object_unref() to free the @pad.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad to release.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_pad" c:identifier="gst_element_remove_pad">
        <doc xml:whitespace="preserve">Removes @pad from @element. @pad will be destroyed if it has not been
referenced elsewhere using gst_object_unparent().
This function is used by plugin developers and should not be used
by applications. Pads that were dynamically requested from elements
with gst_element_get_request_pad() should be released with the
gst_element_release_request_pad() function instead.
Pads are not automatically deactivated so elements should perform the needed
steps to deactivate the pad in case this pad is removed in the PAUSED or
PLAYING state. See gst_pad_set_active() for more information about
deactivating pads.
The pad and the element should be unlocked when calling this function.
This function will emit the #GstElement::pad-removed signal on the element.
pad does not belong to the provided element.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the pad could be removed. Can return %FALSE if the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad to remove from the element.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_pad"
              c:identifier="gst_element_request_pad"
              version="0.10.32">
        <doc xml:whitespace="preserve">Retrieves a request pad from the element according to the provided template.
If the @caps are specified and the element implements thew new
request_new_pad_full virtual method, the element will use them to select
which pad to create.
The pad should be released with gst_element_release_request_pad().
Release after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">requested #GstPad if found, otherwise %NULL.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="templ" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPadTemplate of which we want a pad of.</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the name of the request #GstPad to retrieve. Can be %NULL.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the caps of the pad we want to request. Can be %NULL.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="requires_clock" c:identifier="gst_element_requires_clock">
        <doc xml:whitespace="preserve">Query if the element requires a clock.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the element requires a clock</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="seek" c:identifier="gst_element_seek">
        <doc xml:whitespace="preserve">Sends a seek event to an element. See gst_event_new_seek() for the details of
the parameters. The seek event is sent to the element using
gst_element_send_event().
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the event was handled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new playback rate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the seek values</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">The optional seek flags.</doc>
            <type name="SeekFlags" c:type="GstSeekFlags"/>
          </parameter>
          <parameter name="cur_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type and flags for the new current position</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="cur" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value of the new current position</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type and flags for the new stop position</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value of the new stop position</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="seek_simple"
              c:identifier="gst_element_seek_simple"
              version="0.10.7">
        <doc xml:whitespace="preserve">Simple API to perform a seek on the given element, meaning it just seeks
to the given position relative to the start of the stream. For more complex
operations like segment seeks (e.g. for looping) or changing the playback
rate or seeking relative to the last configured playback segment you should
use gst_element_seek().
In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
guaranteed to return %TRUE on a seekable media type or %FALSE when the media
type is certainly not seekable (such as a live stream).
Some elements allow for seeking in the READY state, in this
case they will store the seek event and execute it when they are put to
PAUSED. If the element supports seek in READY, it will always return %TRUE when
it receives the event in the READY state.
executed instantly though)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the seek operation succeeded (the seek might not always be</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstFormat to execute the seek in, such as #GST_FORMAT_TIME</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="seek_flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">seek options; playback applications will usually want to use GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT here</doc>
            <type name="SeekFlags" c:type="GstSeekFlags"/>
          </parameter>
          <parameter name="seek_pos" transfer-ownership="none">
            <doc xml:whitespace="preserve">position to seek to (relative to the start); if you are doing a seek in #GST_FORMAT_TIME this value is in nanoseconds - multiply with #GST_SECOND to convert seconds to nanoseconds or with #GST_MSECOND to convert milliseconds to nanoseconds.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_event" c:identifier="gst_element_send_event">
        <doc xml:whitespace="preserve">Sends an event to an element. If the element doesn't implement an
event handler, the event will be pushed on a random linked sink pad for
upstream events or a random linked source pad for downstream events.
This function takes owership of the provided event so you should
gst_event_ref() it if you want to reuse the event after this call.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the event was handled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstEvent to send to the element.</doc>
            <type name="Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_base_time" c:identifier="gst_element_set_base_time">
        <doc xml:whitespace="preserve">Set the base time of an element. See gst_element_get_base_time().
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the base time to set.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_bus" c:identifier="gst_element_set_bus">
        <doc xml:whitespace="preserve">Sets the bus of the element. Increases the refcount on the bus.
For internal use only, unless you're testing elements.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bus" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstBus to set.</doc>
            <type name="Bus" c:type="GstBus*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_clock" c:identifier="gst_element_set_clock">
        <doc xml:whitespace="preserve">Sets the clock for the element. This function increases the
refcount on the clock. Any previously set clock on the object
is unreffed.
clock when it, for example, is not able to slave its internal clock to the
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the element accepted the clock. An element can refuse a</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstClock to set for the element.</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_index" c:identifier="gst_element_set_index">
        <doc xml:whitespace="preserve">Set @index on the element. The refcount of the index
will be increased, any previously set index is unreffed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstIndex.</doc>
            <type name="Index" c:type="GstIndex*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_locked_state"
              c:identifier="gst_element_set_locked_state">
        <doc xml:whitespace="preserve">Locks the state of an element, so state changes of the parent don't affect
this element anymore.
MT safe.
or the elements state-locking needed no change.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the state was changed, FALSE if bad parameters were given</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="locked_state" transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE to lock the element's state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_start_time"
              c:identifier="gst_element_set_start_time"
              version="0.10.24">
        <doc xml:whitespace="preserve">Set the start time of an element. The start time of the element is the
running time of the element when it last went to the PAUSED state. In READY
or after a flushing seek, it is set to 0.
Toplevel elements like #GstPipeline will manage the start_time and
base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
on such a toplevel element will disable the distribution of the base_time to
the children and can be useful if the application manages the base_time
itself, for example if you want to synchronize capture from multiple
pipelines, and you can also ensure that the pipelines have the same clock.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the base time to set.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_state" c:identifier="gst_element_set_state">
        <doc xml:whitespace="preserve">Sets the state of the element. This function will try to set the
requested state by going through all the intermediary states and calling
the class's state change function for each.
This function can return #GST_STATE_CHANGE_ASYNC, in which case the
element will perform the remainder of the state change asynchronously in
another thread.
An application can use gst_element_get_state() to wait for the completion
of the state change or it can wait for a state change message on the bus.
State changes to %GST_STATE_READY or %GST_STATE_NULL never return
#GST_STATE_CHANGE_ASYNC.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Result of the state change using #GstStateChangeReturn.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the element's new #GstState.</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync_state_with_parent"
              c:identifier="gst_element_sync_state_with_parent">
        <doc xml:whitespace="preserve">Tries to change the state of the element to the same as its parent.
If this function returns FALSE, the state of element is undefined.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if the element's state could be synced to the parent's state.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="unlink" c:identifier="gst_element_unlink">
        <doc xml:whitespace="preserve">Unlinks all source pads of the source element with all sink pads
of the sink element to which they are linked.
If the link has been made using gst_element_link(), it could have created an
requestpad, which has to be released using gst_element_release_request_pad().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sink #GstElement to unlink.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unlink_many"
              c:identifier="gst_element_unlink_many"
              introspectable="0">
        <doc xml:whitespace="preserve">Unlinks a series of elements. Uses gst_element_unlink().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="element_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second #GstElement in the link chain.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="unlink_pads" c:identifier="gst_element_unlink_pads">
        <doc xml:whitespace="preserve">Unlinks the two named pads of the source and destination elements.
This is a convenience function for gst_pad_unlink().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="srcpadname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the #GstPad in source element.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="destpadname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the #GstPad in destination element.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="state_lock">
        <type name="GLib.StaticRecMutex" c:type="GStaticRecMutex*"/>
      </field>
      <field name="state_cond">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="state_cookie">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="current_state">
        <type name="State" c:type="GstState"/>
      </field>
      <field name="next_state">
        <type name="State" c:type="GstState"/>
      </field>
      <field name="pending_state">
        <type name="State" c:type="GstState"/>
      </field>
      <field name="last_return">
        <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
      </field>
      <field name="bus">
        <type name="Bus" c:type="GstBus*"/>
      </field>
      <field name="clock">
        <type name="Clock" c:type="GstClock*"/>
      </field>
      <field name="base_time">
        <type name="ClockTimeDiff" c:type="GstClockTimeDiff"/>
      </field>
      <field name="numpads">
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="pads">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="numsrcpads">
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="srcpads">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="numsinkpads">
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="sinkpads">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="pads_cookie">
        <type name="guint32" c:type="guint32"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="target_state" writable="1">
            <type name="State" c:type="GstState"/>
          </field>
          <field name="start_time" writable="1">
            <type name="ClockTime" c:type="GstClockTime"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="4">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
      <glib:signal name="no-more-pads">
        <doc xml:whitespace="preserve">This signals that the element will not generate more dynamic pads.
Note that this signal will usually be emitted from the context of
the streaming thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="pad-added">
        <doc xml:whitespace="preserve">a new #GstPad has been added to the element. Note that this signal will
usually be emitted from the context of the streaming thread. Also keep in
mind that if you add new elements to the pipeline in the signal handler
you will need to set them to the desired target state with
gst_element_set_state() or gst_element_sync_state_with_parent().</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="new_pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad that has been added</doc>
            <type name="Pad"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="pad-removed">
        <doc xml:whitespace="preserve">a #GstPad has been removed from the element</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="old_pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad that has been removed</doc>
            <type name="Pad"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ElementClass"
            c:type="GstElementClass"
            glib:is-gtype-struct-for="Element">
      <doc xml:whitespace="preserve">GStreamer element class. Override the vmethods to implement the element
functionality.</doc>
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="details">
        <type name="ElementDetails" c:type="GstElementDetails"/>
      </field>
      <field name="elementfactory">
        <type name="ElementFactory" c:type="GstElementFactory*"/>
      </field>
      <field name="padtemplates">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="numpadtemplates">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="pad_templ_cookie">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="pad_added">
        <callback name="pad_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pad_removed">
        <callback name="pad_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="no_more_pads">
        <callback name="no_more_pads">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_new_pad" introspectable="0">
        <callback name="request_new_pad" introspectable="0">
          <return-value>
            <type name="Pad" c:type="GstPad*"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="templ" transfer-ownership="none">
              <type name="PadTemplate" c:type="GstPadTemplate*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release_pad">
        <callback name="release_pad">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state">
        <callback name="get_state">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%GST_STATE_CHANGE_SUCCESS if the element has no more pending state</doc>
            <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="state"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       allow-none="1">
              <doc xml:whitespace="preserve">a pointer to #GstState to hold the state. Can be %NULL.</doc>
              <type name="State" c:type="GstState*"/>
            </parameter>
            <parameter name="pending"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       allow-none="1">
              <doc xml:whitespace="preserve">a pointer to #GstState to hold the pending state. Can be %NULL.</doc>
              <type name="State" c:type="GstState*"/>
            </parameter>
            <parameter name="timeout" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GstClockTime to specify the timeout for an async state change or %GST_CLOCK_TIME_NONE for infinite timeout.</doc>
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_state">
        <callback name="set_state">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">Result of the state change using #GstStateChangeReturn.</doc>
            <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="state" transfer-ownership="none">
              <doc xml:whitespace="preserve">the element's new #GstState.</doc>
              <type name="State" c:type="GstState"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="change_state">
        <callback name="change_state">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstStateChangeReturn of the state transition.</doc>
            <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="transition" transfer-ownership="none">
              <doc xml:whitespace="preserve">the requested transition</doc>
              <type name="StateChange" c:type="GstStateChange"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_bus">
        <callback name="set_bus">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="bus" transfer-ownership="none">
              <doc xml:whitespace="preserve">the #GstBus to set.</doc>
              <type name="Bus" c:type="GstBus*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="provide_clock">
        <callback name="provide_clock">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the GstClock provided by the element or %NULL</doc>
            <type name="Clock" c:type="GstClock*"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_clock">
        <callback name="set_clock">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the element accepted the clock. An element can refuse a</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="clock" transfer-ownership="none">
              <doc xml:whitespace="preserve">the #GstClock to set for the element.</doc>
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_index">
        <callback name="get_index">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstIndex or %NULL when no index was set on the</doc>
            <type name="Index" c:type="GstIndex*"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_index">
        <callback name="set_index">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="index" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GstIndex.</doc>
              <type name="Index" c:type="GstIndex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send_event">
        <callback name="send_event">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the event was handled.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="event" transfer-ownership="full">
              <doc xml:whitespace="preserve">the #GstEvent to send to the element.</doc>
              <type name="Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_query_types">
        <callback name="get_query_types">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #GstQueryType elements that should not</doc>
            <type name="QueryType" c:type="GstQueryType*"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query">
        <callback name="query">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <doc xml:whitespace="preserve">the #GstQuery.</doc>
              <type name="Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="meta_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="request_new_pad_full" introspectable="0">
        <callback name="request_new_pad_full" introspectable="0">
          <return-value>
            <type name="Pad" c:type="GstPad*"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="templ" transfer-ownership="none">
              <type name="PadTemplate" c:type="GstPadTemplate*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="add_pad_template"
              c:identifier="gst_element_class_add_pad_template">
        <doc xml:whitespace="preserve">Adds a padtemplate to an element class. This is mainly used in the _base_init
functions of classes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="templ" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPadTemplate to add to the element class.</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pad_template"
              c:identifier="gst_element_class_get_pad_template">
        <doc xml:whitespace="preserve">Retrieves a padtemplate from @element_class with the given name.
&lt;note&gt;If you use this function in the #GInstanceInitFunc of an object class
that has subclasses, make sure to pass the g_class parameter of the
#GInstanceInitFunc here.&lt;/note&gt;
if none was found. No unreferencing is necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPadTemplate with the given name, or %NULL</doc>
          <type name="PadTemplate" c:type="GstPadTemplate*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the #GstPadTemplate to get.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pad_template_list"
              c:identifier="gst_element_class_get_pad_template_list">
        <doc xml:whitespace="preserve">Retrieves a list of the pad templates associated with @element_class. The
list must not be modified by the calling code.
&lt;note&gt;If you use this function in the #GInstanceInitFunc of an object class
that has subclasses, make sure to pass the g_class parameter of the
#GInstanceInitFunc here.&lt;/note&gt;
pad templates.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GList of</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="PadTemplate"/>
          </type>
        </return-value>
      </method>
      <method name="install_std_props"
              c:identifier="gst_element_class_install_std_props"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds a list of standardized properties with types to the @klass.
the id is for the property switch in your get_prop method, and
the flags determine readability / writeability.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="first_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the first property. in a NULL terminated</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_details"
              c:identifier="gst_element_class_set_details"
              deprecated="Use gst_element_class_set_details_simple() instead.">
        <doc xml:whitespace="preserve">Sets the detailed information for a #GstElementClass.
&lt;note&gt;This function is for use in _base_init functions only.&lt;/note&gt;
The @details are copied.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">details to set</doc>
            <type name="ElementDetails" c:type="GstElementDetails*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_details_simple"
              c:identifier="gst_element_class_set_details_simple"
              version="0.10.14">
        <doc xml:whitespace="preserve">Sets the detailed information for a #GstElementClass. Simpler version of
gst_element_class_set_details() that generates less linker overhead.
&lt;note&gt;This function is for use in _base_init functions only.&lt;/note&gt;
The detail parameter strings are copied into the #GstElementDetails for
the element class.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="longname" transfer-ownership="none">
            <doc xml:whitespace="preserve">The long English name of the element. E.g. "File Sink"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="classification" transfer-ownership="none">
            <doc xml:whitespace="preserve">String describing the type of element, as an unordered list separated with slashes ('/'). See draft-klass.txt of the design docs for more details and common types. E.g: "Sink/File"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:whitespace="preserve">Sentence describing the purpose of the element. E.g: "Write stream to a file"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="author" transfer-ownership="none">
            <doc xml:whitespace="preserve">Name and contact details of the author(s). Use \n to separate multiple author details. E.g: "Joe Bloggs &amp;lt;joe.blogs at foo.com&amp;gt;"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_documentation_uri"
              c:identifier="gst_element_class_set_documentation_uri"
              version="0.10.31">
        <doc xml:whitespace="preserve">Set uri pointing to user documentation. Applications can use this to show
help for e.g. effects to users.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">uri of element documentation</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name"
              c:identifier="gst_element_class_set_icon_name"
              version="0.10.31">
        <doc xml:whitespace="preserve">Elements that bridge to certain other products can include an icon of that
used product. Application can show the icon in menus/selectors to help
identifying specific elements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of an icon</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ElementDetails" c:type="GstElementDetails">
      <doc xml:whitespace="preserve">This struct defines the public information about a #GstElement. It contains
meta-data about the element that is mostly for the benefit of editors.
The @klass member can be used by applications to filter elements based
on functionality.</doc>
      <field name="longname" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="klass" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="author" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="ElementFactory"
           c:symbol-prefix="element_factory"
           c:type="GstElementFactory"
           parent="PluginFeature"
           glib:type-name="GstElementFactory"
           glib:get-type="gst_element_factory_get_type"
           glib:type-struct="ElementFactoryClass">
      <doc xml:whitespace="preserve">#GstElementFactory is used to create instances of elements. A
GstElementfactory can be added to a #GstPlugin as it is also a
#GstPluginFeature.
Use the gst_element_factory_find() and gst_element_factory_create()
functions to create element instances or use gst_element_factory_make() as a
convenient shortcut.
The following code example shows you how to create a GstFileSrc element.
&lt;example&gt;
&lt;title&gt;Using an element factory&lt;/title&gt;
&lt;programlisting language="c"&gt;
#include &amp;lt;gst/gst.h&amp;gt;
GstElement *src;
GstElementFactory *srcfactory;
gst_init (&amp;amp;argc, &amp;amp;argv);
srcfactory = gst_element_factory_find ("filesrc");
g_return_if_fail (srcfactory != NULL);
src = gst_element_factory_create (srcfactory, "src");
g_return_if_fail (src != NULL);
...
&lt;/programlisting&gt;
&lt;/example&gt;
Last reviewed on 2005-11-23 (0.9.5)</doc>
      <function name="find" c:identifier="gst_element_factory_find">
        <doc xml:whitespace="preserve">Search for an element factory of the given name. Refs the returned
element factory; caller is responsible for unreffing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GstElementFactory if found, NULL otherwise</doc>
          <type name="ElementFactory" c:type="GstElementFactory*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of factory to find</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_filter"
                c:identifier="gst_element_factory_list_filter"
                version="0.10.31">
        <doc xml:whitespace="preserve">Filter out all the elementfactories in @list that can handle @caps in
the given direction.
If @subsetonly is %TRUE, then only the elements whose pads templates
are a complete superset of @caps will be returned. Else any element
whose pad templates caps can intersect with @caps will be returned.
#GstElementFactory elements that match the given requisits.
Use #gst_plugin_feature_list_free after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ElementFactory"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #GstElementFactory to filter</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="ElementFactory"/>
            </type>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPadDirection to filter on</doc>
            <type name="PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="subsetonly" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to filter on caps subsets or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_get_elements"
                c:identifier="gst_element_factory_list_get_elements"
                version="0.10.31">
        <doc xml:whitespace="preserve">Get a list of factories that match the given @type. Only elements
with a rank greater or equal to @minrank will be returned.
The list of factories is returned by decreasing rank.
#GstElementFactory elements. Use gst_plugin_feature_list_free() after
usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ElementFactory"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstElementFactoryListType</doc>
            <type name="ElementFactoryListType"
                  c:type="GstElementFactoryListType"/>
          </parameter>
          <parameter name="minrank" transfer-ownership="none">
            <doc xml:whitespace="preserve">Minimum rank</doc>
            <type name="Rank" c:type="GstRank"/>
          </parameter>
        </parameters>
      </function>
      <function name="make" c:identifier="gst_element_factory_make">
        <doc xml:whitespace="preserve">Create a new element of the type defined by the given element factory.
If name is NULL, then the element will receive a guaranteed unique name,
consisting of the element factory name and a number.
If name is given, it will be given the name supplied.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">new #GstElement or NULL if unable to create element</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="factoryname" transfer-ownership="none">
            <doc xml:whitespace="preserve">a named factory to instantiate</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">name of new element</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="can_sink_all_caps"
              c:identifier="gst_element_factory_can_sink_all_caps"
              version="0.10.33">
        <doc xml:whitespace="preserve">Checks if the factory can sink all possible capabilities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the caps are fully compatible.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps to check</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_sink_any_caps"
              c:identifier="gst_element_factory_can_sink_any_caps"
              version="0.10.33">
        <doc xml:whitespace="preserve">Checks if the factory can sink any possible capability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the caps have a common subset.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps to check</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_sink_caps"
              c:identifier="gst_element_factory_can_sink_caps"
              deprecated="use gst_element_factory_can_sink_all_caps() instead.">
        <doc xml:whitespace="preserve">Checks if the factory can sink the given capability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if it can sink the capabilities</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps to check</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_src_all_caps"
              c:identifier="gst_element_factory_can_src_all_caps"
              version="0.10.33">
        <doc xml:whitespace="preserve">Checks if the factory can src all possible capabilities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the caps are fully compatible.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps to check</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_src_any_caps"
              c:identifier="gst_element_factory_can_src_any_caps"
              version="0.10.33">
        <doc xml:whitespace="preserve">Checks if the factory can src any possible capability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the caps have a common subset.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps to check</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_src_caps"
              c:identifier="gst_element_factory_can_src_caps"
              deprecated="use gst_element_factory_can_src_all_caps() instead.">
        <doc xml:whitespace="preserve">Checks if the factory can source the given capability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if it can src the capabilities</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps to check</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create" c:identifier="gst_element_factory_create">
        <doc xml:whitespace="preserve">Create a new element of the type defined by the given elementfactory.
It will be given the name supplied, since all elements require a name as
their first argument.
be created</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">new #GstElement or NULL if the element couldn't</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new element</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_author" c:identifier="gst_element_factory_get_author">
        <doc xml:whitespace="preserve">Gets the author for this factory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the author</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_description"
              c:identifier="gst_element_factory_get_description">
        <doc xml:whitespace="preserve">Gets the description for this factory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the description</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_documentation_uri"
              c:identifier="gst_element_factory_get_documentation_uri"
              version="0.10.31">
        <doc xml:whitespace="preserve">Gets documentation uri for this factory if set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the documentation uri</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_element_type"
              c:identifier="gst_element_factory_get_element_type">
        <doc xml:whitespace="preserve">Get the #GType for elements managed by this factory. The type can
only be retrieved if the element factory is loaded, which can be
assured with gst_plugin_feature_load().
the factory is not loaded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType for elements managed by this factory or 0 if</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
      </method>
      <method name="get_icon_name"
              c:identifier="gst_element_factory_get_icon_name"
              version="0.10.31">
        <doc xml:whitespace="preserve">Gets icon name for this factory if set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the icon name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_klass" c:identifier="gst_element_factory_get_klass">
        <doc xml:whitespace="preserve">Gets the class for this factory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the class</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_longname"
              c:identifier="gst_element_factory_get_longname">
        <doc xml:whitespace="preserve">Gets the longname for this factory</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the longname</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_num_pad_templates"
              c:identifier="gst_element_factory_get_num_pad_templates">
        <doc xml:whitespace="preserve">Gets the number of pad_templates in this factory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of pad_templates</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_static_pad_templates"
              c:identifier="gst_element_factory_get_static_pad_templates">
        <doc xml:whitespace="preserve">Gets the #GList of #GstStaticPadTemplate for this factory.
static pad templates</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="StaticPadTemplate"/>
          </type>
        </return-value>
      </method>
      <method name="get_uri_protocols"
              c:identifier="gst_element_factory_get_uri_protocols">
        <doc xml:whitespace="preserve">Gets a NULL-terminated array of protocols this element supports or NULL if
no protocols are supported. You may not change the contents of the returned
array, as it is still owned by the element factory. Use g_strdupv() to
make a copy of the protocol string array if you need to.
or NULL</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the supported protocols</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_uri_type"
              c:identifier="gst_element_factory_get_uri_type">
        <doc xml:whitespace="preserve">Gets the type of URIs the element supports or #GST_URI_UNKNOWN if none.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">type of URIs this element supports</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="has_interface"
              c:identifier="gst_element_factory_has_interface"
              version="0.10.14">
        <doc xml:whitespace="preserve">Check if @factory implements the interface with name @interfacename.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE when @factory implement the interface.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="interfacename" transfer-ownership="none">
            <doc xml:whitespace="preserve">an interface name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_is_type"
              c:identifier="gst_element_factory_list_is_type"
              version="0.10.31">
        <doc xml:whitespace="preserve">Check if @factory if of the given types.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @factory is of @type.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstElementFactoryListType</doc>
            <type name="ElementFactoryListType"
                  c:type="GstElementFactoryListType"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="PluginFeature" c:type="GstPluginFeature"/>
      </field>
      <field name="type">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="details">
        <type name="ElementDetails" c:type="GstElementDetails"/>
      </field>
      <field name="staticpadtemplates">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="numpadtemplates">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="uri_type">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="uri_protocols">
        <type name="utf8" c:type="gchar**"/>
      </field>
      <field name="interfaces">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="meta_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="ElementFactoryClass"
            c:type="GstElementFactoryClass"
            glib:is-gtype-struct-for="ElementFactory">
      <field name="parent_class">
        <type name="PluginFeatureClass" c:type="GstPluginFeatureClass"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="ElementFlags" c:type="GstElementFlags">
      <doc xml:whitespace="preserve">The standard flags that an element may have.</doc>
      <member name="locked_state"
              value="16"
              c:identifier="GST_ELEMENT_LOCKED_STATE"/>
      <member name="is_sink" value="32" c:identifier="GST_ELEMENT_IS_SINK"/>
      <member name="unparenting"
              value="64"
              c:identifier="GST_ELEMENT_UNPARENTING"/>
      <member name="is_source"
              value="128"
              c:identifier="GST_ELEMENT_IS_SOURCE"/>
      <member name="flag_last"
              value="1048576"
              c:identifier="GST_ELEMENT_FLAG_LAST"/>
    </bitfield>
    <class name="Event"
           c:symbol-prefix="event"
           c:type="GstEvent"
           parent="MiniObject"
           glib:type-name="GstEvent"
           glib:get-type="gst_event_get_type"
           glib:type-struct="EventClass"
           glib:fundamental="1">
      <doc xml:whitespace="preserve">The event class provides factory methods to construct events for sending
and functions to query (parse) received events.
Events are usually created with gst_event_new_*() which takes event-type
specific parameters as arguments.
To send an event application will usually use gst_element_send_event() and
elements will use gst_pad_send_event() or gst_pad_push_event().
The event should be unreffed with gst_event_unref() if it has not been sent.
Events that have been received can be parsed with their respective 
gst_event_parse_*() functions. It is valid to pass %NULL for unwanted details.
Events are passed between elements in parallel to the data stream. Some events
are serialized with buffers, others are not. Some events only travel downstream,
others only upstream. Some events can travel both upstream and downstream. 
The events are used to signal special conditions in the datastream such as
EOS (end of stream) or the start of a new stream-segment.
Events are also used to flush the pipeline of any pending data.
Most of the event API is used inside plugins. Applications usually only 
construct and use seek events. 
To do that gst_event_new_seek() is used to create a seek event. It takes
the needed parameters to specity seeking time and mode.
&lt;example&gt;
&lt;title&gt;performing a seek on a pipeline&lt;/title&gt;
&lt;programlisting&gt;
GstEvent *event;
gboolean result;
...
// construct a seek event to play the media from second 2 to 5, flush
// the pipeline to decrease latency.
event = gst_event_new_seek (1.0, 
GST_FORMAT_TIME, 
GST_SEEK_FLAG_FLUSH,
GST_SEEK_TYPE_SET, 2 * GST_SECOND,
GST_SEEK_TYPE_SET, 5 * GST_SECOND);
...
result = gst_element_send_event (pipeline, event);
if (!result)
g_warning ("seek failed");
...
&lt;/programlisting&gt;
&lt;/example&gt;
Last reviewed on 2006-09-6 (0.10.10)</doc>
      <constructor name="new_buffer_size"
                   c:identifier="gst_event_new_buffer_size">
        <doc xml:whitespace="preserve">Create a new buffersize event. The event is sent downstream and notifies
elements that they should provide a buffer of the specified dimensions.
When the @async flag is set, a thread boundary is prefered.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">buffer format</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="minsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum buffer size</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="maxsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">maximum buffer size</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="async" transfer-ownership="none">
            <doc xml:whitespace="preserve">thread behavior</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_custom" c:identifier="gst_event_new_custom">
        <doc xml:whitespace="preserve">Create a new custom-typed event. This can be used for anything not
handled by other event-specific functions to pass an event to another
element.
Make sure to allocate an event type with the #GST_EVENT_MAKE_TYPE macro,
assigning a free number and filling in the correct direction and
serialization flags.
New custom events can also be created by subclassing the event type if
needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new custom event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type of the new event</doc>
            <type name="EventType" c:type="GstEventType"/>
          </parameter>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">the structure for the event. The event will take ownership of the structure.</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_eos" c:identifier="gst_event_new_eos">
        <doc xml:whitespace="preserve">Create a new EOS event. The eos event can only travel downstream
synchronized with the buffer flow. Elements that receive the EOS
event on a pad can return #GST_FLOW_UNEXPECTED as a #GstFlowReturn
when data after the EOS event arrives.
The EOS event will travel down to the sink elements in the pipeline
which will then post the #GST_MESSAGE_EOS on the bus after they have
finished playing any buffered data.
When all sinks have posted an EOS message, an EOS message is
forwarded to the application.
The EOS event itself will not cause any state transitions of the pipeline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new EOS event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
      </constructor>
      <constructor name="new_flush_start"
                   c:identifier="gst_event_new_flush_start">
        <doc xml:whitespace="preserve">Allocate a new flush start event. The flush start event can be sent
upstream and downstream and travels out-of-bounds with the dataflow.
It marks pads as being flushing and will make them return
#GST_FLOW_WRONG_STATE when used for data flow with gst_pad_push(),
gst_pad_chain(), gst_pad_alloc_buffer(), gst_pad_get_range() and
gst_pad_pull_range(). Any event (except a #GST_EVENT_FLUSH_STOP) received
on a flushing pad will return %FALSE immediately.
Elements should unlock any blocking functions and exit their streaming
functions as fast as possible when this event is received.
This event is typically generated after a seek to flush out all queued data
in the pipeline so that the new media is played as soon as possible.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new flush start event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
      </constructor>
      <constructor name="new_flush_stop"
                   c:identifier="gst_event_new_flush_stop">
        <doc xml:whitespace="preserve">Allocate a new flush stop event. The flush stop event can be sent
upstream and downstream and travels serialized with the dataflow.
It is typically sent after sending a FLUSH_START event to make the
pads accept data again.
Elements can process this event synchronized with the dataflow since
the preceeding FLUSH_START event stopped the dataflow.
This event is typically generated to complete a seek and to resume
dataflow.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new flush stop event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
      </constructor>
      <constructor name="new_latency"
                   c:identifier="gst_event_new_latency"
                   version="0.10.12">
        <doc xml:whitespace="preserve">Create a new latency event. The event is sent upstream from the sinks and
notifies elements that they should add an additional @latency to the
running time before synchronising against the clock.
The latency is mostly used in live sinks and is always expressed in
the time format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="latency" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new latency value</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_navigation"
                   c:identifier="gst_event_new_navigation">
        <doc xml:whitespace="preserve">Create a new navigation event from the given description.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">description of the event. The event will take ownership of the structure.</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_new_segment"
                   c:identifier="gst_event_new_new_segment">
        <doc xml:whitespace="preserve">Allocate a new newsegment event with the given format/values tripplets
This method calls gst_event_new_new_segment_full() passing a default
value of 1.0 for applied_rate</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new newsegment event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="update" transfer-ownership="none">
            <doc xml:whitespace="preserve">is this segment an update to a previous one</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new rate for playback</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the segment values</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">the start value of the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the stop value of the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">stream position</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_new_segment_full"
                   c:identifier="gst_event_new_new_segment_full"
                   version="0.10.6">
        <doc xml:whitespace="preserve">Allocate a new newsegment event with the given format/values triplets.
The newsegment event marks the range of buffers to be processed. All
data not within the segment range is not to be processed. This can be
used intelligently by plugins to apply more efficient methods of skipping
unneeded data. The valid range is expressed with the @start and @stop
values.
The position value of the segment is used in conjunction with the start
value to convert the buffer timestamps into the stream time. This is 
usually done in sinks to report the current stream_time. 
is a valid @stop given, it must be greater or equal the @start, including 
when the indicated playback @rate is &lt; 0.
The @applied_rate value provides information about any rate adjustment that
has already been made to the timestamps and content on the buffers of the 
stream. (@rate * @applied_rate) should always equal the rate that has been 
requested for playback. For example, if an element has an input segment 
with intended playback @rate of 2.0 and applied_rate of 1.0, it can adjust 
incoming timestamps and buffer content by half and output a newsegment event 
with @rate of 1.0 and @applied_rate of 2.0
After a newsegment event, the buffer stream time is calculated with:
position + (TIMESTAMP(buf) - start) * ABS (rate * applied_rate)</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new newsegment event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="update" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether this segment is an update to a previous one</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">A new rate for playback</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="applied_rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">The rate factor which has already been applied</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the segment values</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">The start value of the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">The stop value of the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">stream position</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_qos" c:identifier="gst_event_new_qos">
        <doc xml:whitespace="preserve">Allocate a new qos event with the given values. This function calls
gst_event_new_qos_full() with the type set to #GST_QOS_TYPE_OVERFLOW
when diff is negative (buffers are in time) and #GST_QOS_TYPE_UNDERFLOW
when @diff is positive (buffers are late).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new QOS event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="proportion" transfer-ownership="none">
            <doc xml:whitespace="preserve">the proportion of the qos message</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="diff" transfer-ownership="none">
            <doc xml:whitespace="preserve">The time difference of the last Clock sync</doc>
            <type name="ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">The timestamp of the buffer</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_qos_full"
                   c:identifier="gst_event_new_qos_full"
                   version="0.10.33">
        <doc xml:whitespace="preserve">Allocate a new qos event with the given values.
The QOS event is generated in an element that wants an upstream
element to either reduce or increase its rate because of
high/low CPU load or other resource usage such as network performance or
throttling. Typically sinks generate these events for each buffer
they receive.
used when a buffer arrived in time or when the sink cannot keep up with
the upstream datarate. #GST_QOS_TYPE_UNDERFLOW is when the sink is not
receiving buffers fast enough and thus has to drop late buffers. 
#GST_QOS_TYPE_THROTTLE is used when the datarate is artificially limited
by the application, for example to reduce power consumption.
element that generated the QoS event (usually the sink). The value is
generally computed based on more long term statistics about the streams
timestamps compared to the clock.
A value &lt; 1.0 indicates that the upstream element is producing data faster
than real-time. A value &gt; 1.0 indicates that the upstream element is not
producing data fast enough. 1.0 is the ideal @proportion value. The
proportion value can safely be used to lower or increase the quality of
the element.
buffer that caused the element to generate the QOS event. A negative value
means that the buffer with @timestamp arrived in time. A positive value
indicates how late the buffer with @timestamp was. When throttling is
enabled, @diff will be set to the requested throttling interval.
to generate the QOS event. It is expressed in running time and thus an ever
increasing value.
The upstream element can use the @diff and @timestamp values to decide
whether to process more buffers. For possitive @diff, all buffers with
timestamp &lt;= @timestamp + @diff will certainly arrive late in the sink
as well. A (negative) @diff value so that @timestamp + @diff would yield a
result smaller than 0 is not allowed.
The application can use general event probes to intercept the QoS
event and implement custom application specific QoS handling.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new QOS event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the QoS type</doc>
            <type name="QOSType" c:type="GstQOSType"/>
          </parameter>
          <parameter name="proportion" transfer-ownership="none">
            <doc xml:whitespace="preserve">the proportion of the qos message</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="diff" transfer-ownership="none">
            <doc xml:whitespace="preserve">The time difference of the last Clock sync</doc>
            <type name="ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">The timestamp of the buffer</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_seek" c:identifier="gst_event_new_seek">
        <doc xml:whitespace="preserve">Allocate a new seek event with the given parameters.
The seek event configures playback of the pipeline between @start to @stop
at the speed given in @rate, also called a playback segment.
The @start and @stop values are expressed in @format.
A @rate of 1.0 means normal playback rate, 2.0 means double speed.
Negatives values means backwards playback. A value of 0.0 for the
rate is not allowed and should be accomplished instead by PAUSING the
pipeline.
A pipeline has a default playback segment configured with a start
position of 0, a stop position of -1 and a rate of 1.0. The currently
configured playback segment can be queried with #GST_QUERY_SEGMENT. 
start and stop fields in playback segment. Adjustments can be made relative
or absolute to the last configured values. A type of #GST_SEEK_TYPE_NONE
means that the position should not be updated.
When the rate is positive and @start has been updated, playback will start
from the newly configured start position. 
For negative rates, playback will start from the newly configured stop
position (if any). If the stop position if updated, it must be different from
-1 for negative rates.
It is not possible to seek relative to the current playback position, to do
this, PAUSE the pipeline, query the current playback position with
#GST_QUERY_POSITION and update the playback segment current position with a
#GST_SEEK_TYPE_SET to the desired position.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new seek event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new playback rate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the seek values</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">The optional seek flags</doc>
            <type name="SeekFlags" c:type="GstSeekFlags"/>
          </parameter>
          <parameter name="start_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type and flags for the new start position</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value of the new start position</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type and flags for the new stop position</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value of the new stop position</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sink_message"
                   c:identifier="gst_event_new_sink_message"
                   version="0.10.26">
        <doc xml:whitespace="preserve">Create a new sink-message event. The purpose of the sink-message event is
to instruct a sink to post the message contained in the event synchronized
with the stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstMessage to be posted</doc>
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_step"
                   c:identifier="gst_event_new_step"
                   version="0.10.24">
        <doc xml:whitespace="preserve">Create a new step event. The purpose of the step event is to instruct a sink
to skip @amount (expressed in @format) of media. It can be used to implement
stepping through the video frame by frame or for doing fast trick modes.
A rate of &lt;= 0.0 is not allowed, pause the pipeline or reverse the playback
direction of the pipeline to get the same effect.
The @flush flag will clear any pending data in the pipeline before starting
the step operation.
The @intermediate flag instructs the pipeline that this step operation is
part of a larger step operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of @amount</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="amount" transfer-ownership="none">
            <doc xml:whitespace="preserve">the amount of data to step</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the step rate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="flush" transfer-ownership="none">
            <doc xml:whitespace="preserve">flushing steps</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="intermediate" transfer-ownership="none">
            <doc xml:whitespace="preserve">intermediate steps</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_tag" c:identifier="gst_event_new_tag">
        <doc xml:whitespace="preserve">Generates a metadata tag event from the given @taglist.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="taglist" transfer-ownership="full">
            <doc xml:whitespace="preserve">metadata list. The event will take ownership of the taglist.</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="type_get_flags" c:identifier="gst_event_type_get_flags">
        <doc xml:whitespace="preserve">Gets the #GstEventTypeFlags associated with @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstEventTypeFlags.</doc>
          <type name="EventTypeFlags" c:type="GstEventTypeFlags"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstEventType</doc>
            <type name="EventType" c:type="GstEventType"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_get_name" c:identifier="gst_event_type_get_name">
        <doc xml:whitespace="preserve">Get a printable name for the given event type. Do not modify or free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a reference to the static name of the event.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the event type</doc>
            <type name="EventType" c:type="GstEventType"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_to_quark" c:identifier="gst_event_type_to_quark">
        <doc xml:whitespace="preserve">Get the unique quark for the given event type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark associated with the event type</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the event type</doc>
            <type name="EventType" c:type="GstEventType"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_seqnum"
              c:identifier="gst_event_get_seqnum"
              version="0.10.22">
        <doc xml:whitespace="preserve">Retrieve the sequence number of a event.
Events have ever-incrementing sequence numbers, which may also be set
explicitly via gst_event_set_seqnum(). Sequence numbers are typically used to
indicate that a event corresponds to some other set of events or messages,
for example an EOS event corresponding to a SEEK event. It is considered good
practice to make this correspondence when possible, though it is not
required.
Note that events and messages share the same sequence number incrementor;
two events or messages will never not have the same sequence number unless
that correspondence was made explicitly.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The event's sequence number.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_structure" c:identifier="gst_event_get_structure">
        <doc xml:whitespace="preserve">Access the structure of the event.
owned by the event, which means that you should not free it and
that the pointer becomes invalid when you free the event.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The structure of the event. The structure is still</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
      </method>
      <method name="has_name"
              c:identifier="gst_event_has_name"
              version="0.10.20">
        <doc xml:whitespace="preserve">Checks if @event has the given @name. This function is usually used to
check the name of a custom event.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @name matches the name of the event structure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name to check</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_buffer_size"
              c:identifier="gst_event_parse_buffer_size">
        <doc xml:whitespace="preserve">Get the format, minsize, maxsize and async-flag in the buffersize event.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the format in</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="minsize"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the minsize in</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="maxsize"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the maxsize in</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="async"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the async-flag in</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_latency"
              c:identifier="gst_event_parse_latency"
              version="0.10.12">
        <doc xml:whitespace="preserve">Get the latency in the latency event.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the latency in.</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_new_segment"
              c:identifier="gst_event_parse_new_segment">
        <doc xml:whitespace="preserve">Get the update flag, rate, format, start, stop and position in the 
newsegment event. In general, gst_event_parse_new_segment_full() should
be used instead of this, to also retrieve the applied_rate value of the
segment. See gst_event_new_new_segment_full() for a full description 
of the newsegment event.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="update"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to the update flag of the segment</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to the rate of the segment</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to the format of the newsegment values</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the start value in</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="stop"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the stop value in</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="position"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the stream time in</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_new_segment_full"
              c:identifier="gst_event_parse_new_segment_full"
              version="0.10.6">
        <doc xml:whitespace="preserve">Get the update, rate, applied_rate, format, start, stop and 
position in the newsegment event. See gst_event_new_new_segment_full() 
for a full description of the newsegment event.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="update"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to the update flag of the segment</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to the rate of the segment</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="applied_rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to the applied_rate of the segment</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to the format of the newsegment values</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the start value in</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="stop"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the stop value in</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="position"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the stream time in</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_qos" c:identifier="gst_event_parse_qos">
        <doc xml:whitespace="preserve">Get the proportion, diff and timestamp in the qos event. See
gst_event_new_qos() for more information about the different QoS values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="proportion"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the proportion in</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="diff"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the diff in</doc>
            <type name="ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
          <parameter name="timestamp"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the timestamp in</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_qos_full"
              c:identifier="gst_event_parse_qos_full"
              version="0.10.33">
        <doc xml:whitespace="preserve">Get the type, proportion, diff and timestamp in the qos event. See
gst_event_new_qos_full() for more information about the different QoS values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the QoS type in</doc>
            <type name="QOSType" c:type="GstQOSType*"/>
          </parameter>
          <parameter name="proportion"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the proportion in</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="diff"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the diff in</doc>
            <type name="ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
          <parameter name="timestamp"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the timestamp in</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_seek" c:identifier="gst_event_parse_seek">
        <doc xml:whitespace="preserve">Parses a seek @event and stores the results in the given result locations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the rate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the stream format</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="flags"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the #GstSeekFlags</doc>
            <type name="SeekFlags" c:type="GstSeekFlags*"/>
          </parameter>
          <parameter name="start_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the #GstSeekType of the start position</doc>
            <type name="SeekType" c:type="GstSeekType*"/>
          </parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the start postion expressed in @format</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="stop_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the #GstSeekType of the stop position</doc>
            <type name="SeekType" c:type="GstSeekType*"/>
          </parameter>
          <parameter name="stop"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the stop postion expressed in @format</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_sink_message"
              c:identifier="gst_event_parse_sink_message"
              version="0.10.26">
        <doc xml:whitespace="preserve">Parse the sink-message event. Unref @msg after usage.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="msg"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to store the #GstMessage in.</doc>
            <type name="Message" c:type="GstMessage**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_step"
              c:identifier="gst_event_parse_step"
              version="0.10.24">
        <doc xml:whitespace="preserve">Parse the step event.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to store the format in</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="amount"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to store the amount in</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to store the rate in</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="flush"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to store the flush boolean in</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="intermediate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to store the intermediate boolean in</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_tag" c:identifier="gst_event_parse_tag">
        <doc xml:whitespace="preserve">Parses a tag @event and stores the results in the given @taglist location.
No reference to the taglist will be returned, it remains valid only until
the @event is freed. Don't modify or free the taglist, make a copy if you
want to modify it or store it for later use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="taglist"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to metadata list</doc>
            <type name="TagList" c:type="GstTagList**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_seqnum"
              c:identifier="gst_event_set_seqnum"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the sequence number of a event.
This function might be called by the creator of a event to indicate that the
event relates to other events or messages. See gst_event_get_seqnum() for
more information.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="seqnum" transfer-ownership="none">
            <doc xml:whitespace="preserve">A sequence number.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <field name="mini_object">
        <type name="MiniObject" c:type="GstMiniObject"/>
      </field>
      <field name="type">
        <type name="EventType" c:type="GstEventType"/>
      </field>
      <field name="timestamp">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="src">
        <type name="Object" c:type="GstObject*"/>
      </field>
      <field name="structure">
        <type name="Structure" c:type="GstStructure*"/>
      </field>
      <union name="abidata" c:type="abidata">
        <field name="seqnum" writable="1">
          <type name="guint32" c:type="guint32"/>
        </field>
        <field name="_gst_reserved" writable="1">
          <type name="gpointer" c:type="gpointer"/>
        </field>
      </union>
    </class>
    <record name="EventClass"
            c:type="GstEventClass"
            glib:is-gtype-struct-for="Event">
      <field name="mini_object_class">
        <type name="MiniObjectClass" c:type="GstMiniObjectClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="EventType" c:type="GstEventType">
      <doc xml:whitespace="preserve">#GstEventType lists the standard event types that can be sent in a pipeline.
The custom event types can be used for private messages between elements
that can't be expressed using normal
GStreamer buffer passing semantics. Custom events carry an arbitrary
#GstStructure.
Specific custom events are distinguished by the name of the structure.</doc>
      <member name="unknown" value="0" c:identifier="GST_EVENT_UNKNOWN"/>
      <member name="flush_start"
              value="19"
              c:identifier="GST_EVENT_FLUSH_START"/>
      <member name="flush_stop"
              value="39"
              c:identifier="GST_EVENT_FLUSH_STOP"/>
      <member name="eos" value="86" c:identifier="GST_EVENT_EOS"/>
      <member name="newsegment"
              value="102"
              c:identifier="GST_EVENT_NEWSEGMENT"/>
      <member name="tag" value="118" c:identifier="GST_EVENT_TAG"/>
      <member name="buffersize"
              value="134"
              c:identifier="GST_EVENT_BUFFERSIZE"/>
      <member name="sink_message"
              value="150"
              c:identifier="GST_EVENT_SINK_MESSAGE"/>
      <member name="qos" value="241" c:identifier="GST_EVENT_QOS"/>
      <member name="seek" value="257" c:identifier="GST_EVENT_SEEK"/>
      <member name="navigation"
              value="273"
              c:identifier="GST_EVENT_NAVIGATION"/>
      <member name="latency" value="289" c:identifier="GST_EVENT_LATENCY"/>
      <member name="step" value="305" c:identifier="GST_EVENT_STEP"/>
      <member name="custom_upstream"
              value="513"
              c:identifier="GST_EVENT_CUSTOM_UPSTREAM"/>
      <member name="custom_downstream"
              value="518"
              c:identifier="GST_EVENT_CUSTOM_DOWNSTREAM"/>
      <member name="custom_downstream_oob"
              value="514"
              c:identifier="GST_EVENT_CUSTOM_DOWNSTREAM_OOB"/>
      <member name="custom_both"
              value="519"
              c:identifier="GST_EVENT_CUSTOM_BOTH"/>
      <member name="custom_both_oob"
              value="515"
              c:identifier="GST_EVENT_CUSTOM_BOTH_OOB"/>
    </bitfield>
    <bitfield name="EventTypeFlags" c:type="GstEventTypeFlags">
      <doc xml:whitespace="preserve">#GstEventTypeFlags indicate the aspects of the different #GstEventType
values. You can get the type flags of a #GstEventType with the
gst_event_type_get_flags() function.</doc>
      <member name="upstream"
              value="1"
              c:identifier="GST_EVENT_TYPE_UPSTREAM"/>
      <member name="downstream"
              value="2"
              c:identifier="GST_EVENT_TYPE_DOWNSTREAM"/>
      <member name="serialized"
              value="4"
              c:identifier="GST_EVENT_TYPE_SERIALIZED"/>
    </bitfield>
    <constant name="FOURCC_FORMAT" value="c%c%c%c">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <callback name="FilterFunc" c:type="GstFilterFunc">
      <doc xml:whitespace="preserve">Function prototype for a filter callback that can be use in gst_filter_run().
The function should apply its filtering to @obj. Additional data passed to
gst_filter_run() are in @data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE for success.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">filter data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="FlowReturn" c:type="GstFlowReturn">
      <doc xml:whitespace="preserve">sent yet) (unused/unimplemented).
this error should post an error message with more
details.
this (and higher) to define custom success
codes. Since 0.10.7.
custom success code to this to avoid compiler
warnings). Since 0.10.29.
this (and lower) to define custom error codes.
Since 0.10.7.
custom error code to this to avoid compiler
warnings). Since 0.10.29.
The result of passing data to a pad.
Note that the custom return values should not be exposed outside of the
element scope and are available since 0.10.7.</doc>
      <member name="custom_success_2"
              value="102"
              c:identifier="GST_FLOW_CUSTOM_SUCCESS_2"/>
      <member name="custom_success_1"
              value="101"
              c:identifier="GST_FLOW_CUSTOM_SUCCESS_1"/>
      <member name="custom_success"
              value="100"
              c:identifier="GST_FLOW_CUSTOM_SUCCESS"/>
      <member name="resend" value="1" c:identifier="GST_FLOW_RESEND"/>
      <member name="ok" value="0" c:identifier="GST_FLOW_OK"/>
      <member name="not_linked" value="-1" c:identifier="GST_FLOW_NOT_LINKED"/>
      <member name="wrong_state"
              value="-2"
              c:identifier="GST_FLOW_WRONG_STATE"/>
      <member name="unexpected" value="-3" c:identifier="GST_FLOW_UNEXPECTED"/>
      <member name="not_negotiated"
              value="-4"
              c:identifier="GST_FLOW_NOT_NEGOTIATED"/>
      <member name="error" value="-5" c:identifier="GST_FLOW_ERROR"/>
      <member name="not_supported"
              value="-6"
              c:identifier="GST_FLOW_NOT_SUPPORTED"/>
      <member name="custom_error"
              value="-100"
              c:identifier="GST_FLOW_CUSTOM_ERROR"/>
      <member name="custom_error_1"
              value="-101"
              c:identifier="GST_FLOW_CUSTOM_ERROR_1"/>
      <member name="custom_error_2"
              value="-102"
              c:identifier="GST_FLOW_CUSTOM_ERROR_2"/>
    </enumeration>
    <enumeration name="Format" c:type="GstFormat">
      <doc xml:whitespace="preserve">Standard predefined formats</doc>
      <member name="undefined" value="0" c:identifier="GST_FORMAT_UNDEFINED"/>
      <member name="default" value="1" c:identifier="GST_FORMAT_DEFAULT"/>
      <member name="bytes" value="2" c:identifier="GST_FORMAT_BYTES"/>
      <member name="time" value="3" c:identifier="GST_FORMAT_TIME"/>
      <member name="buffers" value="4" c:identifier="GST_FORMAT_BUFFERS"/>
      <member name="percent" value="5" c:identifier="GST_FORMAT_PERCENT"/>
    </enumeration>
    <record name="FormatDefinition" c:type="GstFormatDefinition">
      <doc xml:whitespace="preserve">A format definition</doc>
      <field name="value" writable="1">
        <type name="Format" c:type="GstFormat"/>
      </field>
      <field name="nick" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="quark" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
    </record>
    <class name="GhostPad"
           c:symbol-prefix="ghost_pad"
           c:type="GstGhostPad"
           parent="ProxyPad"
           glib:type-name="GstGhostPad"
           glib:get-type="gst_ghost_pad_get_type"
           glib:type-struct="GhostPadClass">
      <doc xml:whitespace="preserve">GhostPads are useful when organizing pipelines with #GstBin like elements.
The idea here is to create hierarchical element graphs. The bin element
contains a sub-graph. Now one would like to treat the bin-element like any
other #GstElement. This is where GhostPads come into play. A GhostPad acts as
a proxy for another pad. Thus the bin can have sink and source ghost-pads
that are associated with sink and source pads of the child elements.
If the target pad is known at creation time, gst_ghost_pad_new() is the
function to use to get a ghost-pad. Otherwise one can use gst_ghost_pad_new_no_target()
to create the ghost-pad and use gst_ghost_pad_set_target() to establish the
association later on.
Note that GhostPads add overhead to the data processing of a pipeline.
Last reviewed on 2005-11-18 (0.9.5)</doc>
      <constructor name="new" c:identifier="gst_ghost_pad_new">
        <doc xml:whitespace="preserve">Create a new ghostpad with @target as the target. The direction will be taken
from the target pad. @target must be unlinked.
Will ref the target.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the name of the new pad, or NULL to assign a default name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to ghost.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_template"
                   c:identifier="gst_ghost_pad_new_from_template"
                   version="0.10.10">
        <doc xml:whitespace="preserve">Create a new ghostpad with @target as the target. The direction will be taken
from the target pad. The template used on the ghostpad will be @template.
Will ref the target.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the name of the new pad, or NULL to assign a default name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to ghost.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="templ" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadTemplate to use on the ghostpad.</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_no_target"
                   c:identifier="gst_ghost_pad_new_no_target">
        <doc xml:whitespace="preserve">Create a new ghostpad without a target with the given direction.
A target can be set on the ghostpad later with the
gst_ghost_pad_set_target() function.
The created ghostpad will not have a padtemplate.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the name of the new pad, or NULL to assign a default name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="dir" transfer-ownership="none">
            <doc xml:whitespace="preserve">the direction of the ghostpad</doc>
            <type name="PadDirection" c:type="GstPadDirection"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_no_target_from_template"
                   c:identifier="gst_ghost_pad_new_no_target_from_template"
                   version="0.10.10">
        <doc xml:whitespace="preserve">Create a new ghostpad based on @templ, without setting a target. The
direction will be taken from the @templ.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the name of the new pad, or NULL to assign a default name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="templ" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadTemplate to create the ghostpad from.</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="construct"
              c:identifier="gst_ghost_pad_construct"
              version="0.10.22">
        <doc xml:whitespace="preserve">Finish initialization of a newly allocated ghost pad.
This function is most useful in language bindings and when subclassing
#GstGhostPad; plugin and application developers normally will not call this
function. Call this function directly after a call to g_object_new
(GST_TYPE_GHOST_PAD, "direction", @dir, ..., NULL).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the construction succeeds, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_target" c:identifier="gst_ghost_pad_get_target">
        <doc xml:whitespace="preserve">Get the target pad of @gpad. Unref target pad after usage.
has no target set. Unref target pad after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the target #GstPad, can be NULL if the ghostpad</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
      </method>
      <method name="set_target" c:identifier="gst_ghost_pad_set_target">
        <doc xml:whitespace="preserve">Set the new target of the ghostpad @gpad. Any existing target
is unlinked and links to the new target are established. if @newtarget is
NULL the target will be cleared.
can return FALSE when the internal pads could not be linked.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">TRUE if the new target could be set. This function</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="newtarget" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the new pad target</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <field name="pad">
        <type name="ProxyPad" c:type="GstProxyPad"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GhostPadPrivate" c:type="GstGhostPadPrivate*"/>
      </field>
    </class>
    <record name="GhostPadClass"
            c:type="GstGhostPadClass"
            glib:is-gtype-struct-for="GhostPad">
      <field name="parent_class">
        <type name="ProxyPadClass" c:type="GstProxyPadClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GhostPadPrivate" c:type="GstGhostPadPrivate" disguised="1">
    </record>
    <constant name="INDEX_ID_INVALID" value="-1">
      <type name="gint" c:type="gint"/>
    </constant>
    <interface name="ImplementsInterface"
               c:symbol-prefix="implements_interface"
               c:type="GstImplementsInterface"
               glib:type-name="GstImplementsInterface"
               glib:get-type="gst_implements_interface_get_type">
      <doc xml:whitespace="preserve">Provides interface functionality on per instance basis and not per class
basis, which is the case for gobject.</doc>
      <prerequisite name="Element"/>
    </interface>
    <record name="ImplementsInterfaceClass"
            c:type="GstImplementsInterfaceClass">
      <field name="parent" writable="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="supported">
        <callback name="supported">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="iface" transfer-ownership="none">
              <type name="ImplementsInterface"
                    c:type="GstImplementsInterface*"/>
            </parameter>
            <parameter name="iface_type" transfer-ownership="none">
              <type name="GType" c:type="GType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="Index"
           c:symbol-prefix="index"
           c:type="GstIndex"
           parent="Object"
           glib:type-name="GstIndex"
           glib:get-type="gst_index_get_type"
           glib:type-struct="IndexClass">
      <doc xml:whitespace="preserve">GstIndex is used to generate a stream index of one or more elements
in a pipeline.
Elements will overload the set_index and get_index virtual methods in
#GstElement. When streaming data, the element will add index entries if it
has an index set.
Each element that adds to the index will do that using a writer_id. The
writer_id is obtained from gst_index_get_writer_id().
The application that wants to index the stream will create a new index object
using gst_index_new() or gst_index_factory_make(). The index is assigned to a
specific element, a bin or the whole pipeline. This will cause indexable
elements to add entires to the index while playing.</doc>
      <constructor name="new" c:identifier="gst_index_new">
        <doc xml:whitespace="preserve">Create a new dummy index object. Use gst_element_set_index() to assign that
to an element or pipeline. This index is not storing anything, but will
still emit e.g. the #GstIndex::entry-added signal.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new index object</doc>
          <type name="Index" c:type="GstIndex*"/>
        </return-value>
      </constructor>
      <virtual-method name="add_entry">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="entry" transfer-ownership="none">
            <type name="IndexEntry" c:type="GstIndexEntry*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="commit" invoker="commit">
        <doc xml:whitespace="preserve">Tell the index that the writer with the given id is done
with this index and is not going to write any more entries
to it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the writer that commited the index</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="entry_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="entry" transfer-ownership="none">
            <type name="IndexEntry" c:type="GstIndexEntry*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_assoc_entry" introspectable="0">
        <return-value transfer-ownership="full">
          <type name="IndexEntry" c:type="GstIndexEntry*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="method" transfer-ownership="none">
            <type name="IndexLookupMethod" c:type="GstIndexLookupMethod"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="AssocFlags" c:type="GstAssocFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="6">
            <type name="GLib.CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="6">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_writer_id" invoker="get_writer_id">
        <doc xml:whitespace="preserve">Before entries can be added to the index, a writer
should obtain a unique id. The methods to add new entries
to the index require this id as an argument.
The application can implement a custom function to map the writer object
to a string. That string will be used to register or look up an id
in the index.
&lt;note&gt;
The caller must not hold @writer's #GST_OBJECT_LOCK, as the default
resolver may call functions that take the object lock as well, and
the lock is not recursive.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the writer would be mapped to an id.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="writer_id" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="writer_string" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_association"
              c:identifier="gst_index_add_association"
              introspectable="0">
        <doc xml:whitespace="preserve">Associate given format/value pairs with each other.
Be sure to pass gint64 values to this functions varargs,
you might want to use a gint64 cast to be sure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to the newly added entry in the index.</doc>
          <type name="IndexEntry" c:type="GstIndexEntry*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id of the index writer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">optinal flags for this entry</doc>
            <type name="AssocFlags" c:type="GstAssocFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the value</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_associationv"
              c:identifier="gst_index_add_associationv">
        <doc xml:whitespace="preserve">Associate given format/value pairs with each other.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to the newly added entry in the index.</doc>
          <type name="IndexEntry" c:type="GstIndexEntry*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id of the index writer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">optinal flags for this entry</doc>
            <type name="AssocFlags" c:type="GstAssocFlags"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of associations</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">list of associations</doc>
            <type name="IndexAssociation" c:type="GstIndexAssociation*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_format" c:identifier="gst_index_add_format">
        <doc xml:whitespace="preserve">Adds a format entry into the index. This function is
used to map dynamic GstFormat ids to their original
format key.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to the newly added entry in the index.</doc>
          <type name="IndexEntry" c:type="GstIndexEntry*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id of the index writer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format to add to the index</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_id" c:identifier="gst_index_add_id">
        <doc xml:whitespace="preserve">Add an id entry into the index.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to the newly added entry in the index.</doc>
          <type name="IndexEntry" c:type="GstIndexEntry*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id of the index writer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:whitespace="preserve">the description of the index writer</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_object" c:identifier="gst_index_add_object">
        <doc xml:whitespace="preserve">Add the given object to the index with the given key.
This function is not yet implemented.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to the newly added entry in the index.</doc>
          <type name="IndexEntry" c:type="GstIndexEntry*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id of the index writer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key for the object</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GType of the object</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to the object to add</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="commit" c:identifier="gst_index_commit">
        <doc xml:whitespace="preserve">Tell the index that the writer with the given id is done
with this index and is not going to write any more entries
to it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the writer that commited the index</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_assoc_entry" c:identifier="gst_index_get_assoc_entry">
        <doc xml:whitespace="preserve">Finds the given format/value in the index
value was not found.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the entry associated with the value or NULL if the</doc>
          <type name="IndexEntry" c:type="GstIndexEntry*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id of the index writer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:whitespace="preserve">The lookup method to use</doc>
            <type name="IndexLookupMethod" c:type="GstIndexLookupMethod"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags for the entry</doc>
            <type name="AssocFlags" c:type="GstAssocFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the value</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to find</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_assoc_entry_full"
              c:identifier="gst_index_get_assoc_entry_full"
              introspectable="0">
        <doc xml:whitespace="preserve">Finds the given format/value in the index with the given
compare function and user_data.
value was not found.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the entry associated with the value or NULL if the</doc>
          <type name="IndexEntry" c:type="GstIndexEntry*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id of the index writer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:whitespace="preserve">The lookup method to use</doc>
            <type name="IndexLookupMethod" c:type="GstIndexLookupMethod"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags for the entry</doc>
            <type name="AssocFlags" c:type="GstAssocFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the value</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to find</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="6">
            <doc xml:whitespace="preserve">the function used to compare entries</doc>
            <type name="GLib.CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the compare function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_certainty" c:identifier="gst_index_get_certainty">
        <doc xml:whitespace="preserve">Get the certainty of the given index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the certainty of the index.</doc>
          <type name="IndexCertainty" c:type="GstIndexCertainty"/>
        </return-value>
      </method>
      <method name="get_group" c:identifier="gst_index_get_group">
        <doc xml:whitespace="preserve">Get the id of the current group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the id of the current group.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_writer_id" c:identifier="gst_index_get_writer_id">
        <doc xml:whitespace="preserve">Before entries can be added to the index, a writer
should obtain a unique id. The methods to add new entries
to the index require this id as an argument.
The application can implement a custom function to map the writer object
to a string. That string will be used to register or look up an id
in the index.
&lt;note&gt;
The caller must not hold @writer's #GST_OBJECT_LOCK, as the default
resolver may call functions that take the object lock as well, and
the lock is not recursive.
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the writer would be mapped to an id.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="writer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GstObject to allocate an id for</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a gint to hold the id</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_group" c:identifier="gst_index_new_group">
        <doc xml:whitespace="preserve">Create a new group for the given index. It will be
set as the current group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the id of the newly created group.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="set_certainty" c:identifier="gst_index_set_certainty">
        <doc xml:whitespace="preserve">Set the certainty of the given index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="certainty" transfer-ownership="none">
            <doc xml:whitespace="preserve">the certainty to set</doc>
            <type name="IndexCertainty" c:type="GstIndexCertainty"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_filter"
              c:identifier="gst_index_set_filter"
              introspectable="0">
        <doc xml:whitespace="preserve">Lets the app register a custom filter function so that
it can select what entries should be stored in the index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the filter to register</doc>
            <type name="IndexFilter" c:type="GstIndexFilter"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data passed to the filter function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_filter_full" c:identifier="gst_index_set_filter_full">
        <doc xml:whitespace="preserve">Lets the app register a custom filter function so that
it can select what entries should be stored in the index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the filter to register</doc>
            <type name="IndexFilter" c:type="GstIndexFilter"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data passed to the filter function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_destroy"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">function to call when @user_data is unset</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_group" c:identifier="gst_index_set_group">
        <doc xml:whitespace="preserve">Set the current groupnumber to the given argument.
did not exist.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the operation succeeded, FALSE if the group</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="groupnum" transfer-ownership="none">
            <doc xml:whitespace="preserve">the groupnumber to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resolver"
              c:identifier="gst_index_set_resolver"
              introspectable="0">
        <doc xml:whitespace="preserve">Lets the app register a custom function to map index
ids to writer descriptions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="resolver" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the resolver to register</doc>
            <type name="IndexResolver" c:type="GstIndexResolver"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data passed to the resolver function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resolver_full"
              c:identifier="gst_index_set_resolver_full"
              version="0.10.18">
        <doc xml:whitespace="preserve">Lets the app register a custom function to map index
ids to writer descriptions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="resolver"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the resolver to register</doc>
            <type name="IndexResolver" c:type="GstIndexResolver"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data passed to the resolver function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_destroy"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">destroy function for @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <property name="resolver"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="groups" readable="0" private="1">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="curgroup" readable="0" private="1">
        <type name="IndexGroup" c:type="GstIndexGroup*"/>
      </field>
      <field name="maxgroup" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="method" readable="0" private="1">
        <type name="IndexResolverMethod" c:type="GstIndexResolverMethod"/>
      </field>
      <field name="resolver" readable="0" private="1">
        <type name="IndexResolver" c:type="GstIndexResolver"/>
      </field>
      <field name="resolver_user_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="filter" readable="0" private="1">
        <type name="IndexFilter" c:type="GstIndexFilter"/>
      </field>
      <field name="filter_user_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="filter_user_data_destroy" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="writers" readable="0" private="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="last_id" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="resolver_user_data_destroy" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="entry-added">
        <doc xml:whitespace="preserve">Is emitted when a new entry is added to the index.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="arg1" transfer-ownership="none">
            <doc xml:whitespace="preserve">The entry added to the index.</doc>
            <type name="IndexEntry"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="IndexAssociation" c:type="GstIndexAssociation">
      <doc xml:whitespace="preserve">An association in an entry.</doc>
      <field name="format" writable="1">
        <type name="Format" c:type="GstFormat"/>
      </field>
      <field name="value" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
    </record>
    <enumeration name="IndexCertainty" c:type="GstIndexCertainty">
      <doc xml:whitespace="preserve">The certainty of a group in the index.</doc>
      <member name="unknown" value="0" c:identifier="GST_INDEX_UNKNOWN"/>
      <member name="certain" value="1" c:identifier="GST_INDEX_CERTAIN"/>
      <member name="fuzzy" value="2" c:identifier="GST_INDEX_FUZZY"/>
    </enumeration>
    <record name="IndexClass"
            c:type="GstIndexClass"
            glib:is-gtype-struct-for="Index">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="get_writer_id">
        <callback name="get_writer_id">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the writer would be mapped to an id.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="Index" c:type="GstIndex*"/>
            </parameter>
            <parameter name="writer_id" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
            <parameter name="writer_string" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="commit">
        <callback name="commit">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="Index" c:type="GstIndex*"/>
            </parameter>
            <parameter name="id" transfer-ownership="none">
              <doc xml:whitespace="preserve">the writer that commited the index</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_entry">
        <callback name="add_entry">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="Index" c:type="GstIndex*"/>
            </parameter>
            <parameter name="entry" transfer-ownership="none">
              <type name="IndexEntry" c:type="GstIndexEntry*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_assoc_entry" introspectable="0">
        <callback name="get_assoc_entry" introspectable="0">
          <return-value transfer-ownership="full">
            <type name="IndexEntry" c:type="GstIndexEntry*"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="Index" c:type="GstIndex*"/>
            </parameter>
            <parameter name="id" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="method" transfer-ownership="none">
              <type name="IndexLookupMethod" c:type="GstIndexLookupMethod"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="AssocFlags" c:type="GstAssocFlags"/>
            </parameter>
            <parameter name="format" transfer-ownership="none">
              <type name="Format" c:type="GstFormat"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="func" transfer-ownership="none" closure="7">
              <type name="GLib.CompareDataFunc" c:type="GCompareDataFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="7">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="entry_added">
        <callback name="entry_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="Index" c:type="GstIndex*"/>
            </parameter>
            <parameter name="entry" transfer-ownership="none">
              <type name="IndexEntry" c:type="GstIndexEntry*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="IndexEntry"
            c:type="GstIndexEntry"
            glib:type-name="GstIndexEntry"
            glib:get-type="gst_index_entry_get_type"
            c:symbol-prefix="index_entry">
      <doc xml:whitespace="preserve">The basic element of an index.</doc>
      <field name="type" readable="0" private="1">
        <type name="IndexEntryType" c:type="GstIndexEntryType"/>
      </field>
      <field name="id" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <union name="data" c:type="data">
        <record name="id" c:type="id">
          <field name="description" writable="1">
            <type name="utf8" c:type="gchar*"/>
          </field>
        </record>
        <record name="assoc" c:type="assoc">
          <field name="nassocs" writable="1">
            <type name="gint" c:type="gint"/>
          </field>
          <field name="assocs" writable="1">
            <type name="IndexAssociation" c:type="GstIndexAssociation*"/>
          </field>
          <field name="flags" writable="1">
            <type name="AssocFlags" c:type="GstAssocFlags"/>
          </field>
        </record>
        <record name="object" c:type="object">
          <field name="key" writable="1">
            <type name="utf8" c:type="gchar*"/>
          </field>
          <field name="type" writable="1">
            <type name="GType" c:type="GType"/>
          </field>
          <field name="object" writable="1">
            <type name="gpointer" c:type="gpointer"/>
          </field>
        </record>
        <record name="format" c:type="format">
          <field name="format" writable="1">
            <type name="Format" c:type="GstFormat"/>
          </field>
          <field name="key" writable="1">
            <type name="utf8" c:type="gchar*"/>
          </field>
        </record>
      </union>
      <method name="assoc_map" c:identifier="gst_index_entry_assoc_map">
        <doc xml:whitespace="preserve">Gets alternative formats associated with the indexentry.
format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if there was a value associated with the given</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the value the find</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to store the value</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gst_index_entry_copy">
        <doc xml:whitespace="preserve">Copies an entry and returns the result.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GstIndexEntry.</doc>
          <type name="IndexEntry" c:type="GstIndexEntry*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="gst_index_entry_free">
        <doc xml:whitespace="preserve">Free the memory used by the given entry.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <enumeration name="IndexEntryType" c:type="GstIndexEntryType">
      <doc xml:whitespace="preserve">The different types of entries in the index.</doc>
      <member name="id" value="0" c:identifier="GST_INDEX_ENTRY_ID"/>
      <member name="association"
              value="1"
              c:identifier="GST_INDEX_ENTRY_ASSOCIATION"/>
      <member name="object" value="2" c:identifier="GST_INDEX_ENTRY_OBJECT"/>
      <member name="format" value="3" c:identifier="GST_INDEX_ENTRY_FORMAT"/>
    </enumeration>
    <class name="IndexFactory"
           c:symbol-prefix="index_factory"
           c:type="GstIndexFactory"
           parent="PluginFeature"
           glib:type-name="GstIndexFactory"
           glib:get-type="gst_index_factory_get_type"
           glib:type-struct="IndexFactoryClass">
      <doc xml:whitespace="preserve">GstIndexFactory is used to dynamically create GstIndex implementations.</doc>
      <constructor name="new" c:identifier="gst_index_factory_new">
        <doc xml:whitespace="preserve">Create a new indexfactory with the given parameters</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstIndexFactory.</doc>
          <type name="IndexFactory" c:type="GstIndexFactory*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of indexfactory to create</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="longdesc" transfer-ownership="none">
            <doc xml:whitespace="preserve">long description of indexfactory to create</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GType of the GstIndex element of this factory</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="find" c:identifier="gst_index_factory_find">
        <doc xml:whitespace="preserve">Search for an indexfactory of the given name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GstIndexFactory if found, NULL otherwise</doc>
          <type name="IndexFactory" c:type="GstIndexFactory*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of indexfactory to find</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="make" c:identifier="gst_index_factory_make">
        <doc xml:whitespace="preserve">Create a new #GstIndex instance from the
indexfactory with the given name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstIndex instance.</doc>
          <type name="Index" c:type="GstIndex*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the factory used to create the instance</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="create" c:identifier="gst_index_factory_create">
        <doc xml:whitespace="preserve">Create a new #GstIndex instance from the
given indexfactory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstIndex instance.</doc>
          <type name="Index" c:type="GstIndex*"/>
        </return-value>
      </method>
      <method name="destroy" c:identifier="gst_index_factory_destroy">
        <doc xml:whitespace="preserve">Removes the index from the global list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <field name="feature">
        <type name="PluginFeature" c:type="GstPluginFeature"/>
      </field>
      <field name="longdesc">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="type">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="IndexFactoryClass"
            c:type="GstIndexFactoryClass"
            glib:is-gtype-struct-for="IndexFactory">
      <field name="parent">
        <type name="PluginFeatureClass" c:type="GstPluginFeatureClass"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="IndexFilter" c:type="GstIndexFilter">
      <doc xml:whitespace="preserve">Function to filter out entries in the index.
to the index, %FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">This function should return %TRUE if the entry is to be added</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="index" transfer-ownership="none">
          <doc xml:whitespace="preserve">The index being queried</doc>
          <type name="Index" c:type="GstIndex*"/>
        </parameter>
        <parameter name="entry" transfer-ownership="none">
          <doc xml:whitespace="preserve">The entry to be added.</doc>
          <type name="IndexEntry" c:type="GstIndexEntry*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">User data passed to the function.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="IndexFlags" c:type="GstIndexFlags">
      <doc xml:whitespace="preserve">Flags for this index</doc>
      <member name="writable" value="16" c:identifier="GST_INDEX_WRITABLE"/>
      <member name="readable" value="32" c:identifier="GST_INDEX_READABLE"/>
      <member name="flag_last"
              value="4096"
              c:identifier="GST_INDEX_FLAG_LAST"/>
    </bitfield>
    <record name="IndexGroup" c:type="GstIndexGroup">
      <doc xml:whitespace="preserve">A group of related entries in an index.</doc>
      <field name="groupnum" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="entries" readable="0" private="1">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="certainty" readable="0" private="1">
        <type name="IndexCertainty" c:type="GstIndexCertainty"/>
      </field>
      <field name="peergroup" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
    </record>
    <enumeration name="IndexLookupMethod" c:type="GstIndexLookupMethod">
      <doc xml:whitespace="preserve">Specify the method to find an index entry in the index.</doc>
      <member name="exact" value="0" c:identifier="GST_INDEX_LOOKUP_EXACT"/>
      <member name="before" value="1" c:identifier="GST_INDEX_LOOKUP_BEFORE"/>
      <member name="after" value="2" c:identifier="GST_INDEX_LOOKUP_AFTER"/>
    </enumeration>
    <callback name="IndexResolver" c:type="GstIndexResolver">
      <doc xml:whitespace="preserve">Function to resolve ids to writer descriptions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if an id could be assigned to the writer.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="index" transfer-ownership="none">
          <doc xml:whitespace="preserve">the index being queried.</doc>
          <type name="Index" c:type="GstIndex*"/>
        </parameter>
        <parameter name="writer" transfer-ownership="none">
          <doc xml:whitespace="preserve">The object that wants to write</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="writer_string" transfer-ownership="none">
          <doc xml:whitespace="preserve">A description of the writer.</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user_data as registered</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="IndexResolverMethod" c:type="GstIndexResolverMethod">
      <doc xml:whitespace="preserve">The method used to resolve index writers</doc>
      <member name="custom"
              value="0"
              c:identifier="GST_INDEX_RESOLVER_CUSTOM"/>
      <member name="gtype" value="1" c:identifier="GST_INDEX_RESOLVER_GTYPE"/>
      <member name="path" value="2" c:identifier="GST_INDEX_RESOLVER_PATH"/>
    </enumeration>
    <record name="Iterator" c:type="GstIterator">
      <doc xml:whitespace="preserve">A GstIterator is used to retrieve multiple objects from another object in
a threadsafe way.
Various GStreamer objects provide access to their internal structures using
an iterator.
In general, whenever calling a GstIterator function results in your code
receiving a refcounted object, the refcount for that object will have been
increased.  Your code is responsible for unrefing that object after use.
The basic use pattern of an iterator is as follows:
&lt;example&gt;
&lt;title&gt;Using an iterator&lt;/title&gt;
&lt;programlisting&gt;
it = _get_iterator(object);
done = FALSE;
while (!done) {
switch (gst_iterator_next (it, &amp;amp;item)) {
case GST_ITERATOR_OK:
... use/change item here...
gst_object_unref (item);
break;
case GST_ITERATOR_RESYNC:
...rollback changes to items...
gst_iterator_resync (it);
break;
case GST_ITERATOR_ERROR:
...wrong parameters were given...
done = TRUE;
break;
case GST_ITERATOR_DONE:
done = TRUE;
break;
}
}
gst_iterator_free (it);
&lt;/programlisting&gt;
&lt;/example&gt;
Last reviewed on 2009-06-16 (0.10.24)</doc>
      <field name="next" writable="1">
        <type name="IteratorNextFunction" c:type="GstIteratorNextFunction"/>
      </field>
      <field name="item" writable="1">
        <type name="IteratorItemFunction" c:type="GstIteratorItemFunction"/>
      </field>
      <field name="resync" writable="1">
        <type name="IteratorResyncFunction"
              c:type="GstIteratorResyncFunction"/>
      </field>
      <field name="free" writable="1">
        <type name="IteratorFreeFunction" c:type="GstIteratorFreeFunction"/>
      </field>
      <field name="pushed" writable="1">
        <type name="Iterator" c:type="GstIterator*"/>
      </field>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="lock" writable="1">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="cookie" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="master_cookie" writable="1">
        <type name="guint32" c:type="guint32*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="filter"
              c:identifier="gst_iterator_filter"
              introspectable="0">
        <doc xml:whitespace="preserve">Create a new iterator from an existing iterator. The new iterator
will only return those elements that match the given compare function @func.
in the iterator.
When this iterator is freed, @it will also be freed.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstIterator.</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">the compare function to select elements</doc>
            <type name="GLib.CompareFunc" c:type="GCompareFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the compare function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_custom" c:identifier="gst_iterator_find_custom">
        <doc xml:whitespace="preserve">Find the first element in @it that matches the compare function @func.
the refcount of a refcounted object will be increased before @func is 
called, and should be unrefed after use in @func unless it is the matching
element.
The iterator will not be freed.
This function will return NULL if an error happened to the iterator.
function or NULL when no element matched.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The element in the iterator that matches the compare</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">the compare function to use</doc>
            <type name="GLib.CompareFunc" c:type="GCompareFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the compare function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="fold" c:identifier="gst_iterator_fold">
        <doc xml:whitespace="preserve">Folds @func over the elements of @iter. That is to say, @func will be called
as @func (object, @ret, @user_data) for each object in @it. The normal use
of this procedure is to accumulate the results of operating on the objects in
before @func is called, and it should be unrefed after use in @func.
This procedure can be used (and is used internally) to implement the
gst_iterator_foreach() and gst_iterator_find_custom() operations.
The fold will proceed as long as @func returns TRUE. When the iterator has no
more arguments, %GST_ITERATOR_DONE will be returned. If @func returns FALSE,
the fold will stop, and %GST_ITERATOR_OK will be returned. Errors or resyncs
will cause fold to return %GST_ITERATOR_ERROR or %GST_ITERATOR_RESYNC as
appropriate.
The iterator will not be freed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstIteratorResult, as described above.</doc>
          <type name="IteratorResult" c:type="GstIteratorResult"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:whitespace="preserve">the fold function</doc>
            <type name="IteratorFoldFunction"
                  c:type="GstIteratorFoldFunction"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seed value passed to the fold function</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the fold function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="gst_iterator_foreach">
        <doc xml:whitespace="preserve">Iterate over all element of @it and call the given function @func for
each element.  As in gst_iterator_fold(), the refcount of a refcounted 
object will be increased before @func is called, and should be unrefed
after use.
freed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the result call to gst_iterator_fold(). The iterator will not be</doc>
          <type name="IteratorResult" c:type="GstIteratorResult"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">the function to call for each element.</doc>
            <type name="GLib.Func" c:type="GFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_iterator_free">
        <doc xml:whitespace="preserve">Free the iterator.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="next" c:identifier="gst_iterator_next">
        <doc xml:whitespace="preserve">Get the next item from the iterator in @elem. 
Only when this function returns %GST_ITERATOR_OK, @elem will contain a valid
value. For iterators that return refcounted objects, the returned object
will have its refcount increased and should therefore be unreffed after
usage.
When this function returns %GST_ITERATOR_DONE, no more elements can be
retrieved from @it.
A return value of %GST_ITERATOR_RESYNC indicates that the element list was
concurrently updated. The user of @it should call gst_iterator_resync() to
get the newly updated list. 
A return value of %GST_ITERATOR_ERROR indicates an unrecoverable fatal error.
is a refcounted object.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The result of the iteration. Unref @elem after usage if this</doc>
          <type name="IteratorResult" c:type="GstIteratorResult"/>
        </return-value>
        <parameters>
          <parameter name="elem" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to hold next element</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="gst_iterator_push">
        <doc xml:whitespace="preserve">Pushes @other iterator onto @it. All calls performed on @it are
forwarded to @other. If @other returns %GST_ITERATOR_DONE, it is
popped again and calls are handled by @it again.
This function is mainly used by objects implementing the iterator
next function to recurse into substructures.
When gst_iterator_resync() is called on @it, @other will automatically be
popped.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="other" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GstIterator to push</doc>
            <type name="Iterator" c:type="GstIterator*"/>
          </parameter>
        </parameters>
      </method>
      <method name="resync" c:identifier="gst_iterator_resync">
        <doc xml:whitespace="preserve">Resync the iterator. this function is mostly called
after gst_iterator_next() returned %GST_ITERATOR_RESYNC.
When an iterator was pushed on @it, it will automatically be popped again
with this function.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <callback name="IteratorDisposeFunction"
              c:type="GstIteratorDisposeFunction">
      <doc xml:whitespace="preserve">The function that will be called when a #GList iterator is freed. The
owner of the #GList iterator can then clean up its resources.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="owner" transfer-ownership="none">
          <doc xml:whitespace="preserve">the owner of the iterator</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="IteratorFoldFunction" c:type="GstIteratorFoldFunction">
      <doc xml:whitespace="preserve">A function to be passed to gst_iterator_fold().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the fold should continue, FALSE if it should stop.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="item" transfer-ownership="none">
          <doc xml:whitespace="preserve">the item to fold</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue collecting the result</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">data passed to gst_iterator_fold()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="IteratorFreeFunction" c:type="GstIteratorFreeFunction">
      <doc xml:whitespace="preserve">This function will be called when the iterator is freed.
Implementors of a #GstIterator should implement this
function and pass it to the constructor of the custom iterator.
The function will be called with the iterator lock held.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="it" transfer-ownership="none">
          <doc xml:whitespace="preserve">the iterator</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="IteratorItem" c:type="GstIteratorItem">
      <doc xml:whitespace="preserve">The result of a #GstIteratorItemFunction.</doc>
      <member name="skip" value="0" c:identifier="GST_ITERATOR_ITEM_SKIP"/>
      <member name="pass" value="1" c:identifier="GST_ITERATOR_ITEM_PASS"/>
      <member name="end" value="2" c:identifier="GST_ITERATOR_ITEM_END"/>
    </enumeration>
    <callback name="IteratorItemFunction" c:type="GstIteratorItemFunction">
      <doc xml:whitespace="preserve">The function that will be called after the next item of the iterator
has been retrieved. This function will typically increase the refcount
of the item or make a copy.
Implementors of a #GstIterator should implement this
function and pass it to the constructor of the custom iterator.
The function will be called with the iterator lock held.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the result of the operation.</doc>
        <type name="IteratorItem" c:type="GstIteratorItem"/>
      </return-value>
      <parameters>
        <parameter name="it" transfer-ownership="none">
          <doc xml:whitespace="preserve">the iterator</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </parameter>
        <parameter name="item" transfer-ownership="none">
          <doc xml:whitespace="preserve">the item being retrieved.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="IteratorNextFunction" c:type="GstIteratorNextFunction">
      <doc xml:whitespace="preserve">The function that will be called when the next element of the iterator
should be retrieved. 
Implementors of a #GstIterator should implement this
function and pass it to the constructor of the custom iterator.
The function will be called with the iterator lock held.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the result of the operation.</doc>
        <type name="IteratorResult" c:type="GstIteratorResult"/>
      </return-value>
      <parameters>
        <parameter name="it" transfer-ownership="none">
          <doc xml:whitespace="preserve">the iterator</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </parameter>
        <parameter name="result" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to hold the next item</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="IteratorResult" c:type="GstIteratorResult">
      <doc xml:whitespace="preserve">The result of gst_iterator_next().</doc>
      <member name="done" value="0" c:identifier="GST_ITERATOR_DONE"/>
      <member name="ok" value="1" c:identifier="GST_ITERATOR_OK"/>
      <member name="resync" value="2" c:identifier="GST_ITERATOR_RESYNC"/>
      <member name="error" value="3" c:identifier="GST_ITERATOR_ERROR"/>
    </enumeration>
    <callback name="IteratorResyncFunction" c:type="GstIteratorResyncFunction">
      <doc xml:whitespace="preserve">This function will be called whenever a concurrent update happened
to the iterated datastructure. The implementor of the iterator should
restart the iterator from the beginning and clean up any state it might
have.
Implementors of a #GstIterator should implement this
function and pass it to the constructor of the custom iterator.
The function will be called with the iterator lock held.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="it" transfer-ownership="none">
          <doc xml:whitespace="preserve">the iterator</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="LICENSE_UNKNOWN" value="unknown">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="LibraryError"
                 c:type="GstLibraryError"
                 glib:error-quark="gst_library_error_quark">
      <doc xml:whitespace="preserve">Library errors are for errors from the library being used by elements
(initializing, finalizing, settings, ...)</doc>
      <member name="failed" value="1" c:identifier="GST_LIBRARY_ERROR_FAILED"/>
      <member name="too_lazy"
              value="2"
              c:identifier="GST_LIBRARY_ERROR_TOO_LAZY"/>
      <member name="init" value="3" c:identifier="GST_LIBRARY_ERROR_INIT"/>
      <member name="shutdown"
              value="4"
              c:identifier="GST_LIBRARY_ERROR_SHUTDOWN"/>
      <member name="settings"
              value="5"
              c:identifier="GST_LIBRARY_ERROR_SETTINGS"/>
      <member name="encode" value="6" c:identifier="GST_LIBRARY_ERROR_ENCODE"/>
      <member name="num_errors"
              value="7"
              c:identifier="GST_LIBRARY_ERROR_NUM_ERRORS"/>
    </enumeration>
    <callback name="LogFunction" c:type="GstLogFunction">
      <doc xml:whitespace="preserve">Function prototype for a logging function that can be registered with
gst_debug_add_log_function().
Use G_GNUC_NO_INSTRUMENT on that function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="category" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstDebugCategory</doc>
          <type name="DebugCategory" c:type="GstDebugCategory*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstDebugLevel</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <doc xml:whitespace="preserve">file name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="function" transfer-ownership="none">
          <doc xml:whitespace="preserve">function name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <doc xml:whitespace="preserve">line number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GObject</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">the message</doc>
          <type name="DebugMessage" c:type="GstDebugMessage*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data for the log function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="MESSAGE_TRACE_NAME" value="GstMessage">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MSECOND" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Message"
           c:symbol-prefix="message"
           c:type="GstMessage"
           parent="MiniObject"
           glib:type-name="GstMessage"
           glib:get-type="gst_message_get_type"
           glib:type-struct="MessageClass"
           glib:fundamental="1">
      <doc xml:whitespace="preserve">Messages are implemented as a subclass of #GstMiniObject with a generic
#GstStructure as the content. This allows for writing custom messages without
requiring an API change while allowing a wide range of different types
of messages.
Messages are posted by objects in the pipeline and are passed to the
application using the #GstBus.
The basic use pattern of posting a message on a #GstBus is as follows:
&lt;example&gt;
&lt;title&gt;Posting a #GstMessage&lt;/title&gt;
&lt;programlisting&gt;
gst_bus_post (bus, gst_message_new_eos());
&lt;/programlisting&gt;
&lt;/example&gt;
A #GstElement usually posts messages on the bus provided by the parent
container using gst_element_post_message().
Last reviewed on 2005-11-09 (0.9.4)</doc>
      <constructor name="new_application"
                   c:identifier="gst_message_new_application">
        <doc xml:whitespace="preserve">Create a new application-typed message. GStreamer will never create these
messages; they are a gift from us to you. Enjoy.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new application message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">the structure for the message. The message will take ownership of the structure.</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_async_done"
                   c:identifier="gst_message_new_async_done"
                   version="0.10.13">
        <doc xml:whitespace="preserve">The message is posted when elements completed an ASYNC state change.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new async_done message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_async_start"
                   c:identifier="gst_message_new_async_start"
                   version="0.10.13">
        <doc xml:whitespace="preserve">This message is posted by elements when they start an ASYNC state change. 
PLAYING.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new async_start message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="new_base_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">if a new base_time should be set on the element</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_buffering"
                   c:identifier="gst_message_new_buffering"
                   version="0.10.11">
        <doc xml:whitespace="preserve">Create a new buffering message. This message can be posted by an element that
needs to buffer data before it can continue processing. @percent should be a
value between 0 and 100. A value of 100 means that the buffering completed.
When @percent is &lt; 100 the application should PAUSE a PLAYING pipeline. When
The application must be prepared to receive BUFFERING messages in the
PREROLLING state and may only set the pipeline to PLAYING after receiving a
message with @percent set to 100, which can happen after the pipeline
completed prerolling. 
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new buffering message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="percent" transfer-ownership="none">
            <doc xml:whitespace="preserve">The buffering percent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_clock_lost"
                   c:identifier="gst_message_new_clock_lost">
        <doc xml:whitespace="preserve">Create a clock lost message. This message is posted whenever the
clock is not valid anymore.
If this message is posted by the pipeline, the pipeline will
select a new clock again when it goes to PLAYING. It might therefore
be needed to set the pipeline to PAUSED and PLAYING again.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new clock lost message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the clock that was lost</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_clock_provide"
                   c:identifier="gst_message_new_clock_provide">
        <doc xml:whitespace="preserve">Create a clock provide message. This message is posted whenever an
element is ready to provide a clock or lost its ability to provide
a clock (maybe because it paused or became EOS).
This message is mainly used internally to manage the clock
selection.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new provide clock message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the clock it provides</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
          <parameter name="ready" transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the sender can provide a clock</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_custom" c:identifier="gst_message_new_custom">
        <doc xml:whitespace="preserve">Create a new custom-typed message. This can be used for anything not
handled by other message-specific functions to pass a message to the
app. The structure field can be NULL.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GstMessageType to distinguish messages</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">the structure for the message. The message will take ownership of the structure.</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_duration" c:identifier="gst_message_new_duration">
        <doc xml:whitespace="preserve">Create a new duration message. This message is posted by elements that
know the duration of a stream in a specific format. This message
is received by bins and is used to calculate the total duration of a
pipeline. Elements may post a duration message with a duration of
GST_CLOCK_TIME_NONE to indicate that the duration has changed and the 
cached duration should be discarded. The new duration can then be 
retrieved via a query.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new duration message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the duration</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new duration</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_element" c:identifier="gst_message_new_element">
        <doc xml:whitespace="preserve">Create a new element-specific message. This is meant as a generic way of
allowing one-way communication from an element to an application, for example
"the firewire cable was unplugged". The format of the message should be
documented in the element's documentation. The structure field can be NULL.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new element message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">The structure for the message. The message will take ownership of the structure.</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_eos" c:identifier="gst_message_new_eos">
        <doc xml:whitespace="preserve">Create a new eos message. This message is generated and posted in
the sink elements of a GstBin. The bin will only forward the EOS
message to the application if all sinks have posted an EOS message.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new eos message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_error" c:identifier="gst_message_new_error">
        <doc xml:whitespace="preserve">Create a new error message. The message will copy @error and
occured. The pipeline will probably (partially) stop. The application
receiving this message should stop the pipeline.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new error message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">The GError for this message.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none">
            <doc xml:whitespace="preserve">A debugging string.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_info"
                   c:identifier="gst_message_new_info"
                   version="0.10.12">
        <doc xml:whitespace="preserve">Create a new info message. The message will make copies of @error and
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new info message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">The GError for this message.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none">
            <doc xml:whitespace="preserve">A debugging string.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_latency"
                   c:identifier="gst_message_new_latency"
                   version="0.10.12">
        <doc xml:whitespace="preserve">This message can be posted by elements when their latency requirements have
changed.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new latency message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_new_clock"
                   c:identifier="gst_message_new_new_clock">
        <doc xml:whitespace="preserve">Create a new clock message. This message is posted whenever the
pipeline selectes a new clock for the pipeline.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new new clock message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new selected clock</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_progress"
                   c:identifier="gst_message_new_progress"
                   version="0.10.33">
        <doc xml:whitespace="preserve">Progress messages are posted by elements when they use an asynchronous task
to perform actions triggered by a state change.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new qos message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstProgressType</doc>
            <type name="ProgressType" c:type="GstProgressType"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">a progress code</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:whitespace="preserve">free, user visible text describing the progress</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_qos"
                   c:identifier="gst_message_new_qos"
                   version="0.10.29">
        <doc xml:whitespace="preserve">A QOS message is posted on the bus whenever an element decides to drop a
buffer because of QoS reasons or whenever it changes its processing strategy
because of QoS reasons (quality adjustments such as processing at lower
accuracy).
This message can be posted by an element that performs synchronisation against the
clock (live) or it could be dropped by an element that performs QoS because of QOS
events received from a downstream element (!live).
respective running-time, stream-time, timestamp and duration of the (dropped)
buffer that generated the QoS event. Values can be left to
GST_CLOCK_TIME_NONE when unknown.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new qos message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="live" transfer-ownership="none">
            <doc xml:whitespace="preserve">if the message was generated by a live element</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="running_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the running time of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="stream_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the stream time of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timestamps of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:whitespace="preserve">the duration of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_request_state"
                   c:identifier="gst_message_new_request_state"
                   version="0.10.23">
        <doc xml:whitespace="preserve">This message can be posted by elements when they want to have their state
changed. A typical use case would be an audio server that wants to pause the
pipeline because a higher priority stream is being played.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new requst state message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new requested state</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_segment_done"
                   c:identifier="gst_message_new_segment_done">
        <doc xml:whitespace="preserve">Create a new segment done message. This message is posted by elements that
finish playback of a segment as a result of a segment seek. This message
is received by the application after all elements that posted a segment_start
have posted the segment_done.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new segment done message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the position being done</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">The position of the segment being done</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_segment_start"
                   c:identifier="gst_message_new_segment_start">
        <doc xml:whitespace="preserve">Create a new segment message. This message is posted by elements that
start playback of a segment as a result of a segment seek. This message
is not received by the application but is used for maintenance reasons in
container elements.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new segment start message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the position being played</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">The position of the segment being played</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_state_changed"
                   c:identifier="gst_message_new_state_changed">
        <doc xml:whitespace="preserve">Create a state change message. This message is posted whenever an element
changed its state.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new state change message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="oldstate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the previous state</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
          <parameter name="newstate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new (current) state</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
          <parameter name="pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pending (target) state</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_state_dirty"
                   c:identifier="gst_message_new_state_dirty">
        <doc xml:whitespace="preserve">Create a state dirty message. This message is posted whenever an element
changed its state asynchronously and is used internally to update the
states of container objects.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new state dirty message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_step_done"
                   c:identifier="gst_message_new_step_done"
                   version="0.10.24">
        <doc xml:whitespace="preserve">This message is posted by elements when they complete a part, when @intermediate set
to TRUE, or a complete step operation.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new step_done message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of @amount</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="amount" transfer-ownership="none">
            <doc xml:whitespace="preserve">the amount of stepped data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rate of the stepped amount</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="flush" transfer-ownership="none">
            <doc xml:whitespace="preserve">is this an flushing step</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="intermediate" transfer-ownership="none">
            <doc xml:whitespace="preserve">is this an intermediate step</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:whitespace="preserve">the duration of the data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="eos" transfer-ownership="none">
            <doc xml:whitespace="preserve">the step caused EOS</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_step_start"
                   c:identifier="gst_message_new_step_start"
                   version="0.10.24">
        <doc xml:whitespace="preserve">This message is posted by elements when they accept or activate a new step
event for @amount in @format. 
queued it for execution in the streaming threads.
is now ready to start executing the step in the streaming thread. After this
message is emited, the application can queue a new step operation in the
element.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new step_start message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">if the step is active or queued</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of @amount</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="amount" transfer-ownership="none">
            <doc xml:whitespace="preserve">the amount of stepped data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rate of the stepped amount</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="flush" transfer-ownership="none">
            <doc xml:whitespace="preserve">is this an flushing step</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="intermediate" transfer-ownership="none">
            <doc xml:whitespace="preserve">is this an intermediate step</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_stream_status"
                   c:identifier="gst_message_new_stream_status"
                   version="0.10.24.">
        <doc xml:whitespace="preserve">Create a new stream status message. This message is posted when a streaming
thread is created/destroyed or when the state changed.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new stream status message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The stream status type.</doc>
            <type name="StreamStatusType" c:type="GstStreamStatusType"/>
          </parameter>
          <parameter name="owner" transfer-ownership="none">
            <doc xml:whitespace="preserve">the owner element of @src.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_structure_change"
                   c:identifier="gst_message_new_structure_change"
                   version="0.10.22.">
        <doc xml:whitespace="preserve">Create a new structure change message. This message is posted when the
structure of a pipeline is in the process of being changed, for example
when pads are linked or unlinked.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new structure change message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The change type.</doc>
            <type name="StructureChangeType" c:type="GstStructureChangeType"/>
          </parameter>
          <parameter name="owner" transfer-ownership="none">
            <doc xml:whitespace="preserve">The owner element of @src.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="busy" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether the structure change is busy.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_tag" c:identifier="gst_message_new_tag">
        <doc xml:whitespace="preserve">Create a new tag message. The message will take ownership of the tag list.
The message is posted by elements that discovered a new taglist.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new tag message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="tag_list" transfer-ownership="full">
            <doc xml:whitespace="preserve">the tag list for the message.</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_tag_full"
                   c:identifier="gst_message_new_tag_full"
                   version="0.10.24">
        <doc xml:whitespace="preserve">Create a new tag message. The message will take ownership of the tag list.
The message is posted by elements that discovered a new taglist.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new tag message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the originating pad for the tag.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="tag_list" transfer-ownership="full">
            <doc xml:whitespace="preserve">the tag list for the message.</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_warning" c:identifier="gst_message_new_warning">
        <doc xml:whitespace="preserve">Create a new warning message. The message will make copies of @error and
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new warning message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">The GError for this message.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none">
            <doc xml:whitespace="preserve">A debugging string.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="type_get_name" c:identifier="gst_message_type_get_name">
        <doc xml:whitespace="preserve">Get a printable name for the given message type. Do not modify or free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a reference to the static name of the message.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the message type</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_to_quark" c:identifier="gst_message_type_to_quark">
        <doc xml:whitespace="preserve">Get the unique quark for the given message type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark associated with the message type</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the message type</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_seqnum"
              c:identifier="gst_message_get_seqnum"
              version="0.10.22">
        <doc xml:whitespace="preserve">Retrieve the sequence number of a message.
Messages have ever-incrementing sequence numbers, which may also be set
explicitly via gst_message_set_seqnum(). Sequence numbers are typically used
to indicate that a message corresponds to some other set of messages or
events, for example a SEGMENT_DONE message corresponding to a SEEK event. It
is considered good practice to make this correspondence when possible, though
it is not required.
Note that events and messages share the same sequence number incrementor;
two events or messages will never not have the same sequence number unless
that correspondence was made explicitly.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The message's sequence number.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_stream_status_object"
              c:identifier="gst_message_get_stream_status_object"
              version="0.10.24">
        <doc xml:whitespace="preserve">Extracts the object managing the streaming thread from @message.
This object is usually of type GstTask but other types can be added in the
future. The object remains valid as long as @message is valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue containing the object that manages the streaming thread.</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </return-value>
      </method>
      <method name="get_structure" c:identifier="gst_message_get_structure">
        <doc xml:whitespace="preserve">Access the structure of the message.
still owned by the message, which means that you should not free it and
that the pointer becomes invalid when you free the message.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The structure of the message. The structure is</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
      </method>
      <method name="parse_async_start"
              c:identifier="gst_message_parse_async_start"
              version="0.10.13">
        <doc xml:whitespace="preserve">Extract the new_base_time from the async_start message. 
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="new_base_time"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the new_base_time or NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_buffering"
              c:identifier="gst_message_parse_buffering"
              version="0.10.11">
        <doc xml:whitespace="preserve">Extracts the buffering percent from the GstMessage. see also
gst_message_new_buffering().
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="percent"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">Return location for the percent.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_buffering_stats"
              c:identifier="gst_message_parse_buffering_stats"
              version="0.10.20">
        <doc xml:whitespace="preserve">Extracts the buffering stats values from @message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a buffering mode, or NULL</doc>
            <type name="BufferingMode" c:type="GstBufferingMode*"/>
          </parameter>
          <parameter name="avg_in"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the average input rate, or NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="avg_out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the average output rate, or NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="buffering_left"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">amount of buffering time left in milliseconds, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_clock_lost"
              c:identifier="gst_message_parse_clock_lost">
        <doc xml:whitespace="preserve">Extracts the lost clock from the GstMessage.
The clock object returned remains valid until the message is freed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clock"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to hold the lost clock</doc>
            <type name="Clock" c:type="GstClock**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_clock_provide"
              c:identifier="gst_message_parse_clock_provide">
        <doc xml:whitespace="preserve">Extracts the clock and ready flag from the GstMessage.
The clock object returned remains valid until the message is freed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clock"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to  hold a clock object, or NULL</doc>
            <type name="Clock" c:type="GstClock**"/>
          </parameter>
          <parameter name="ready"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to hold the ready flag, or NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_duration" c:identifier="gst_message_parse_duration">
        <doc xml:whitespace="preserve">Extracts the duration and format from the duration message. The duration
might be GST_CLOCK_TIME_NONE, which indicates that the duration has
changed. Applications should always use a query to retrieve the duration
of a pipeline.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the format, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the duration, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_error" c:identifier="gst_message_parse_error">
        <doc xml:whitespace="preserve">Extracts the GError and debug string from the GstMessage. The values returned
in the output arguments are copies; the caller must free them when done.
Typical usage of this function might be:
|[
...
switch (GST_MESSAGE_TYPE (msg)) {
GError *err = NULL;
gchar *dbg_info = NULL;
gst_message_parse_error (msg, &amp;amp;err, &amp;amp;dbg_info);
GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);
g_error_free (err);
g_free (dbg_info);
break;
}
...
}
...
]|
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gerror"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the GError</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="debug"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the debug message, or NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_info"
              c:identifier="gst_message_parse_info"
              version="0.10.12">
        <doc xml:whitespace="preserve">Extracts the GError and debug string from the GstMessage. The values returned
in the output arguments are copies; the caller must free them when done.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gerror"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the GError</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="debug"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the debug message, or NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_new_clock"
              c:identifier="gst_message_parse_new_clock">
        <doc xml:whitespace="preserve">Extracts the new clock from the GstMessage.
The clock object returned remains valid until the message is freed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clock"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to hold the selected new clock</doc>
            <type name="Clock" c:type="GstClock**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_progress"
              c:identifier="gst_message_parse_progress"
              version="0.10.33">
        <doc xml:whitespace="preserve">Parses the progress @type, @code and @text.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the type</doc>
            <type name="ProgressType" c:type="GstProgressType*"/>
          </parameter>
          <parameter name="code"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the code</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="text"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the text</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_qos"
              c:identifier="gst_message_parse_qos"
              version="0.10.29">
        <doc xml:whitespace="preserve">Extract the timestamps and live status from the QoS message.
The returned values give the running_time, stream_time, timestamp and
duration of the dropped buffer. Values of GST_CLOCK_TIME_NONE mean unknown
values.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">if the message was generated by a live element</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="running_time"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the running time of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="stream_time"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the stream time of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="timestamp"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the timestamps of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the duration of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_qos_stats"
              c:identifier="gst_message_parse_qos_stats"
              version="0.10.29">
        <doc xml:whitespace="preserve">Extract the QoS stats representing the history of the current continuous
pipeline playback period.
When @format is @GST_FORMAT_UNDEFINED both @dropped and @processed are
invalid. Values of -1 for either @processed or @dropped mean unknown values.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">Units of the 'processed' and 'dropped' fields. Video sinks and video filters will use GST_FORMAT_BUFFERS (frames). Audio sinks and audio filters will likely use GST_FORMAT_DEFAULT (samples).</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="processed"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">Total number of units correctly processed since the last state change to READY or a flushing operation.</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="dropped"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">Total number of units dropped since the last state change to READY or a flushing operation.</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_qos_values"
              c:identifier="gst_message_parse_qos_values"
              version="0.10.29">
        <doc xml:whitespace="preserve">Extract the QoS values that have been calculated/analysed from the QoS data
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="jitter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">The difference of the running-time against the deadline.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="proportion"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">Long term prediction of the ideal rate relative to normal rate to get optimal quality.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="quality"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">An element dependent integer value that specifies the current quality level of the element. The default maximum quality is 1000000.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_request_state"
              c:identifier="gst_message_parse_request_state"
              version="0.10.23">
        <doc xml:whitespace="preserve">Extract the requested state from the request_state message.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="state"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the requested state or NULL</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_segment_done"
              c:identifier="gst_message_parse_segment_done">
        <doc xml:whitespace="preserve">Extracts the position and format from the segment start message.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the format, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="position"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the position, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_segment_start"
              c:identifier="gst_message_parse_segment_start">
        <doc xml:whitespace="preserve">Extracts the position and format from the segment start message.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the format, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="position"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the position, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_state_changed"
              c:identifier="gst_message_parse_state_changed">
        <doc xml:whitespace="preserve">Extracts the old and new states from the GstMessage.
Typical usage of this function might be:
|[
...
switch (GST_MESSAGE_TYPE (msg)) {
GstState old_state, new_state;
gst_message_parse_state_changed (msg, &amp;amp;old_state, &amp;amp;new_state, NULL);
g_print ("Element %s changed state from %s to %s.\n",
GST_OBJECT_NAME (msg-&gt;src),
gst_element_state_get_name (old_state),
gst_element_state_get_name (new_state));
break;
}
...
}
...
]|
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="oldstate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the previous state, or NULL</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="newstate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the new (current) state, or NULL</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="pending"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the pending (target) state, or NULL</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_step_done"
              c:identifier="gst_message_parse_step_done"
              version="0.10.24">
        <doc xml:whitespace="preserve">Extract the values the step_done message.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the format</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="amount"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the amount</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the rate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="flush"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the flush flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="intermediate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the intermediate flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the duration</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="eos"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the EOS flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_step_start"
              c:identifier="gst_message_parse_step_start"
              version="0.10.24">
        <doc xml:whitespace="preserve">Extract the values from step_start message.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="active"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the active flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the format</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="amount"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the amount</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the rate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="flush"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the flush flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="intermediate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the intermediate flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_stream_status"
              c:identifier="gst_message_parse_stream_status"
              version="0.10.24.">
        <doc xml:whitespace="preserve">Extracts the stream status type and owner the GstMessage. The returned
owner remains valid for as long as the reference to @message is valid and
should thus not be unreffed.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to hold the status type</doc>
            <type name="StreamStatusType" c:type="GstStreamStatusType*"/>
          </parameter>
          <parameter name="owner"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">The owner element of the message source</doc>
            <type name="Element" c:type="GstElement**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_structure_change"
              c:identifier="gst_message_parse_structure_change"
              version="0.10.22">
        <doc xml:whitespace="preserve">Extracts the change type and completion status from the GstMessage.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to hold the change type</doc>
            <type name="StructureChangeType" c:type="GstStructureChangeType*"/>
          </parameter>
          <parameter name="owner"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">The owner element of the message source</doc>
            <type name="Element" c:type="GstElement**"/>
          </parameter>
          <parameter name="busy"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to hold whether the change is in progress or has been completed</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_tag" c:identifier="gst_message_parse_tag">
        <doc xml:whitespace="preserve">Extracts the tag list from the GstMessage. The tag list returned in the
output argument is a copy; the caller must free it when done.
Typical usage of this function might be:
|[
...
switch (GST_MESSAGE_TYPE (msg)) {
GstTagList *tags = NULL;
gst_message_parse_tag (msg, &amp;amp;tags);
g_print ("Got tags from element %s\n", GST_OBJECT_NAME (msg-&gt;src));
handle_tags (tags);
gst_tag_list_free (tags);
break;
}
...
}
...
]|
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tag_list"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the tag-list.</doc>
            <type name="TagList" c:type="GstTagList**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_tag_full"
              c:identifier="gst_message_parse_tag_full"
              version="0.10.24">
        <doc xml:whitespace="preserve">Extracts the tag list from the GstMessage. The tag list returned in the
output argument is a copy; the caller must free it when done.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location where the originating pad is stored, unref after usage</doc>
            <type name="Pad" c:type="GstPad**"/>
          </parameter>
          <parameter name="tag_list"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the tag-list.</doc>
            <type name="TagList" c:type="GstTagList**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_warning" c:identifier="gst_message_parse_warning">
        <doc xml:whitespace="preserve">Extracts the GError and debug string from the GstMessage. The values returned
in the output arguments are copies; the caller must free them when done.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gerror"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the GError</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="debug"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the debug message, or NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffering_stats"
              c:identifier="gst_message_set_buffering_stats"
              version="0.10.20">
        <doc xml:whitespace="preserve">Configures the buffering stats values in @message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffering mode</doc>
            <type name="BufferingMode" c:type="GstBufferingMode"/>
          </parameter>
          <parameter name="avg_in" transfer-ownership="none">
            <doc xml:whitespace="preserve">the average input rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="avg_out" transfer-ownership="none">
            <doc xml:whitespace="preserve">the average output rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="buffering_left" transfer-ownership="none">
            <doc xml:whitespace="preserve">amount of buffering time left in milliseconds</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qos_stats"
              c:identifier="gst_message_set_qos_stats"
              version="0.10.29">
        <doc xml:whitespace="preserve">Set the QoS stats representing the history of the current continuous pipeline
playback period.
When @format is @GST_FORMAT_UNDEFINED both @dropped and @processed are
invalid. Values of -1 for either @processed or @dropped mean unknown values.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">Units of the 'processed' and 'dropped' fields. Video sinks and video filters will use GST_FORMAT_BUFFERS (frames). Audio sinks and audio filters will likely use GST_FORMAT_DEFAULT (samples).</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="processed" transfer-ownership="none">
            <doc xml:whitespace="preserve">Total number of units correctly processed since the last state change to READY or a flushing operation.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="dropped" transfer-ownership="none">
            <doc xml:whitespace="preserve">Total number of units dropped since the last state change to READY or a flushing operation.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qos_values"
              c:identifier="gst_message_set_qos_values"
              version="0.10.29">
        <doc xml:whitespace="preserve">Set the QoS values that have been calculated/analysed from the QoS data
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="jitter" transfer-ownership="none">
            <doc xml:whitespace="preserve">The difference of the running-time against the deadline.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="proportion" transfer-ownership="none">
            <doc xml:whitespace="preserve">Long term prediction of the ideal rate relative to normal rate to get optimal quality.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="quality" transfer-ownership="none">
            <doc xml:whitespace="preserve">An element dependent integer value that specifies the current quality level of the element. The default maximum quality is 1000000.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_seqnum"
              c:identifier="gst_message_set_seqnum"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the sequence number of a message.
This function might be called by the creator of a message to indicate that
the message relates to other messages or events. See gst_message_get_seqnum()
for more information.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="seqnum" transfer-ownership="none">
            <doc xml:whitespace="preserve">A sequence number.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stream_status_object"
              c:identifier="gst_message_set_stream_status_object"
              version="0.10.24">
        <doc xml:whitespace="preserve">Configures the object handling the streaming thread. This is usually a
GstTask object but other objects might be added in the future.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object controlling the streaming</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <field name="mini_object">
        <type name="MiniObject" c:type="GstMiniObject"/>
      </field>
      <field name="lock" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="cond" readable="0" private="1">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="type">
        <type name="MessageType" c:type="GstMessageType"/>
      </field>
      <field name="timestamp">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="src">
        <type name="Object" c:type="GstObject*"/>
      </field>
      <field name="structure">
        <type name="Structure" c:type="GstStructure*"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="seqnum" writable="1">
            <type name="guint32" c:type="guint32"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="4">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
    </class>
    <record name="MessageClass"
            c:type="GstMessageClass"
            glib:is-gtype-struct-for="Message">
      <field name="mini_object_class">
        <type name="MiniObjectClass" c:type="GstMiniObjectClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="MessageType" c:type="GstMessageType">
      <doc xml:whitespace="preserve">The different message types that are available.</doc>
      <member name="unknown" value="0" c:identifier="GST_MESSAGE_UNKNOWN"/>
      <member name="eos" value="1" c:identifier="GST_MESSAGE_EOS"/>
      <member name="error" value="2" c:identifier="GST_MESSAGE_ERROR"/>
      <member name="warning" value="4" c:identifier="GST_MESSAGE_WARNING"/>
      <member name="info" value="8" c:identifier="GST_MESSAGE_INFO"/>
      <member name="tag" value="16" c:identifier="GST_MESSAGE_TAG"/>
      <member name="buffering"
              value="32"
              c:identifier="GST_MESSAGE_BUFFERING"/>
      <member name="state_changed"
              value="64"
              c:identifier="GST_MESSAGE_STATE_CHANGED"/>
      <member name="state_dirty"
              value="128"
              c:identifier="GST_MESSAGE_STATE_DIRTY"/>
      <member name="step_done"
              value="256"
              c:identifier="GST_MESSAGE_STEP_DONE"/>
      <member name="clock_provide"
              value="512"
              c:identifier="GST_MESSAGE_CLOCK_PROVIDE"/>
      <member name="clock_lost"
              value="1024"
              c:identifier="GST_MESSAGE_CLOCK_LOST"/>
      <member name="new_clock"
              value="2048"
              c:identifier="GST_MESSAGE_NEW_CLOCK"/>
      <member name="structure_change"
              value="4096"
              c:identifier="GST_MESSAGE_STRUCTURE_CHANGE"/>
      <member name="stream_status"
              value="8192"
              c:identifier="GST_MESSAGE_STREAM_STATUS"/>
      <member name="application"
              value="16384"
              c:identifier="GST_MESSAGE_APPLICATION"/>
      <member name="element" value="32768" c:identifier="GST_MESSAGE_ELEMENT"/>
      <member name="segment_start"
              value="65536"
              c:identifier="GST_MESSAGE_SEGMENT_START"/>
      <member name="segment_done"
              value="131072"
              c:identifier="GST_MESSAGE_SEGMENT_DONE"/>
      <member name="duration"
              value="262144"
              c:identifier="GST_MESSAGE_DURATION"/>
      <member name="latency"
              value="524288"
              c:identifier="GST_MESSAGE_LATENCY"/>
      <member name="async_start"
              value="1048576"
              c:identifier="GST_MESSAGE_ASYNC_START"/>
      <member name="async_done"
              value="2097152"
              c:identifier="GST_MESSAGE_ASYNC_DONE"/>
      <member name="request_state"
              value="4194304"
              c:identifier="GST_MESSAGE_REQUEST_STATE"/>
      <member name="step_start"
              value="8388608"
              c:identifier="GST_MESSAGE_STEP_START"/>
      <member name="qos" value="16777216" c:identifier="GST_MESSAGE_QOS"/>
      <member name="progress"
              value="33554432"
              c:identifier="GST_MESSAGE_PROGRESS"/>
      <member name="any" value="-1" c:identifier="GST_MESSAGE_ANY"/>
    </bitfield>
    <class name="MiniObject"
           c:symbol-prefix="mini_object"
           c:type="GstMiniObject"
           abstract="1"
           glib:type-name="GstMiniObject"
           glib:get-type="gst_mini_object_get_type"
           glib:type-struct="MiniObjectClass"
           glib:fundamental="1"
           glib:ref-func="gst_mini_object_ref"
           glib:unref-func="gst_mini_object_unref"
           glib:set-value-func="gst_value_set_mini_object"
           glib:get-value-func="gst_value_get_mini_object">
      <doc xml:whitespace="preserve">#GstMiniObject is a baseclass like #GObject, but has been stripped down of
features to be fast and small.
It offers sub-classing and ref-counting in the same way as #GObject does.
It has no properties and no signal-support though.
Last reviewed on 2005-11-23 (0.9.5)</doc>
      <constructor name="new" c:identifier="gst_mini_object_new">
        <doc xml:whitespace="preserve">Creates a new mini-object of the desired type.
MT safe</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new mini-object.</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType of the mini-object to create</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="replace" c:identifier="gst_mini_object_replace">
        <doc xml:whitespace="preserve">Modifies a pointer to point to a new mini-object.  The modification
is done atomically, and the reference counts are updated correctly.
Either @newdata and the value pointed to by @olddata may be NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="olddata"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">pointer to a pointer to a mini-object to be replaced</doc>
            <type name="MiniObject" c:type="GstMiniObject**"/>
          </parameter>
          <parameter name="newdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to new mini-object</doc>
            <type name="MiniObject" c:type="GstMiniObject*"/>
          </parameter>
        </parameters>
      </function>
      <method name="copy" c:identifier="gst_mini_object_copy">
        <doc xml:whitespace="preserve">Creates a copy of the mini-object.
MT safe</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new mini-object.</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </return-value>
      </method>
      <method name="is_writable" c:identifier="gst_mini_object_is_writable">
        <doc xml:whitespace="preserve">Checks if a mini-object is writable.  A mini-object is writable
if the reference count is one and the #GST_MINI_OBJECT_FLAG_READONLY
flag is not set.  Modification of a mini-object should only be
done after verifying that it is writable.
MT safe</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the object is writable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="make_writable"
              c:identifier="gst_mini_object_make_writable">
        <doc xml:whitespace="preserve">Checks if a mini-object is writable.  If not, a writable copy is made and
returned.  This gives away the reference to the original mini object,
and returns a reference to the new object.
MT safe
is writable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a mini-object (possibly the same pointer) that</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="gst_mini_object_ref">
        <doc xml:whitespace="preserve">Increase the reference count of the mini-object.
Note that the refcount affects the writeability
of @mini-object, see gst_mini_object_is_writable(). It is
important to note that keeping additional references to
GstMiniObject instances can potentially increase the number
of memcpy operations in a pipeline, especially if the miniobject
is a #GstBuffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the mini-object.</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </return-value>
      </method>
      <method name="unref" c:identifier="gst_mini_object_unref">
        <doc xml:whitespace="preserve">Decreases the reference count of the mini-object, possibly freeing
the mini-object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <field name="instance">
        <type name="GObject.TypeInstance" c:type="GTypeInstance"/>
      </field>
      <field name="refcount">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="flags">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="MiniObjectClass"
            c:type="GstMiniObjectClass"
            glib:is-gtype-struct-for="MiniObject">
      <field name="type_class">
        <type name="GObject.TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="copy" introspectable="0">
        <type name="MiniObjectCopyFunction"
              c:type="GstMiniObjectCopyFunction"/>
      </field>
      <field name="finalize">
        <type name="MiniObjectFinalizeFunction"
              c:type="GstMiniObjectFinalizeFunction"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <callback name="MiniObjectCopyFunction"
              c:type="GstMiniObjectCopyFunction"
              introspectable="0">
      <doc xml:whitespace="preserve">Virtual function prototype for methods to create copies of instances.</doc>
      <return-value>
        <doc xml:whitespace="preserve">reference to cloned instance.</doc>
        <type name="MiniObject" c:type="GstMiniObject*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">MiniObject to copy</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="MiniObjectFinalizeFunction"
              c:type="GstMiniObjectFinalizeFunction">
      <doc xml:whitespace="preserve">Virtual function prototype for methods to free ressources used by
mini-objects. Subclasses of the mini object are allowed to revive the
passed object by doing a gst_mini_object_ref(). If the object is not
revived after the finalize function, the memory associated with the
object is freed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">MiniObject to finalize</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="MiniObjectFlags" c:type="GstMiniObjectFlags">
      <doc xml:whitespace="preserve">Flags for the mini object</doc>
      <member name="readonly"
              value="1"
              c:identifier="GST_MINI_OBJECT_FLAG_READONLY"/>
      <member name="reserved1"
              value="2"
              c:identifier="GST_MINI_OBJECT_FLAG_RESERVED1"/>
      <member name="last" value="16" c:identifier="GST_MINI_OBJECT_FLAG_LAST"/>
    </bitfield>
    <constant name="NSECOND" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="GstObject"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GstObject"
           glib:get-type="gst_object_get_type"
           glib:type-struct="ObjectClass">
      <doc xml:whitespace="preserve">#GstObject provides a root for the object hierarchy tree filed in by the
GStreamer library.  It is currently a thin wrapper on top of
#GObject. It is an abstract class that is not very usable on its own.
#GstObject gives us basic refcounting, parenting functionality and locking.
Most of the function are just extended for special GStreamer needs and can be
found under the same name in the base class of #GstObject which is #GObject
(e.g. g_object_ref() becomes gst_object_ref()).
The most interesting difference between #GstObject and #GObject is the
"floating" reference count. A #GObject is created with a reference count of
1, owned by the creator of the #GObject. (The owner of a reference is the
code section that has the right to call gst_object_unref() in order to
remove that reference.) A #GstObject is created with a reference count of 1
also, but it isn't owned by anyone; Instead, the initial reference count
of a #GstObject is "floating". The floating reference can be removed by
anyone at any time, by calling gst_object_sink().  gst_object_sink() does
nothing if an object is already sunk (has no floating reference).
When you add a #GstElement to its parent container, the parent container will
do this:
&lt;informalexample&gt;
&lt;programlisting&gt;
gst_object_ref (GST_OBJECT (child_element));
gst_object_sink (GST_OBJECT (child_element));
&lt;/programlisting&gt;
&lt;/informalexample&gt;
This means that the container now owns a reference to the child element
(since it called gst_object_ref()), and the child element has no floating
reference.
The purpose of the floating reference is to keep the child element alive
until you add it to a parent container, which then manages the lifetime of
the object itself:
&lt;informalexample&gt;
&lt;programlisting&gt;
element = gst_element_factory_make (factoryname, name);
// element has one floating reference to keep it alive
gst_bin_add (GST_BIN (bin), element);
// element has one non-floating reference owned by the container
&lt;/programlisting&gt;
&lt;/informalexample&gt;
Another effect of this is, that calling gst_object_unref() on a bin object,
will also destoy all the #GstElement objects in it. The same is true for
calling gst_bin_remove().
Special care has to be taken for all methods that gst_object_sink() an object
since if the caller of those functions had a floating reference to the object,
the object reference is now invalid.
In contrast to #GObject instances, #GstObject adds a name property. The functions
gst_object_set_name() and gst_object_get_name() are used to set/get the name
of the object.
Last reviewed on 2005-11-09 (0.9.4)</doc>
      <function name="check_uniqueness"
                c:identifier="gst_object_check_uniqueness">
        <doc xml:whitespace="preserve">Checks to see if there is any object named @name in @list. This function
does not do any locking of any kind. You might want to protect the
provided list with the lock of the owner of the list. This function
will lock each #GstObject in the list to compare the name, so be
carefull when passing a list with a locked object.
FALSE if it does.
MT safe. Grabs and releases the LOCK of each object in the list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if a #GstObject named @name does not appear in @list,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a list of #GstObject to check through</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Object"/>
            </type>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name to search for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="default_deep_notify"
                c:identifier="gst_object_default_deep_notify">
        <doc xml:whitespace="preserve">A default deep_notify signal callback for an object. The user data
should contain a pointer to an array of strings that should be excluded
from the notify. The default handler will print the new value of the property
using g_print.
MT safe. This function grabs and releases @object's LOCK for getting its
path string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GObject that signalled the notify.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="orig" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstObject that initiated the notify.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GParamSpec of the property.</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="excluded_props" transfer-ownership="none">
            <doc xml:whitespace="preserve">(array zero-terminated=1) (element-type gchar*) (allow-none):a set of user-specified properties to exclude or NULL to show all changes.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </function>
      <function name="ref" c:identifier="gst_object_ref">
        <doc xml:whitespace="preserve">Increments the reference count on @object. This function
does not take the lock on @object because it relies on
atomic refcounting.
This object returns the input parameter to ease writing
constructs like :
result = gst_object_ref (object-&gt;parent);</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A pointer to @object</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstObject to reference</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="ref_sink"
                c:identifier="gst_object_ref_sink"
                version="0.10.24">
        <doc xml:whitespace="preserve">Increase the reference count of @object, and possibly remove the floating
reference, if @object has a floating reference.
In other words, if the object is floating, then this call "assumes ownership"
of the floating reference, converting it to a normal reference by clearing
the floating flag while leaving the reference count unchanged. If the object
is not floating, then this call adds a new normal reference increasing the
reference count by one.
MT safe. This function grabs and releases @object lock.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstObject to sink</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="replace" c:identifier="gst_object_replace">
        <doc xml:whitespace="preserve">Unrefs the #GstObject pointed to by @oldobj, refs @newobj and
puts @newobj in *@oldobj. Be carefull when calling this
function, it does not take any locks. You might want to lock
the object owning @oldobj pointer before calling this
function.
Make sure not to LOCK @oldobj because it might be unreffed
which could cause a deadlock when it is disposed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="oldobj"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">pointer to a place of a #GstObject to replace</doc>
            <type name="Object" c:type="GstObject**"/>
          </parameter>
          <parameter name="newobj" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new #GstObject</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="sink" c:identifier="gst_object_sink">
        <doc xml:whitespace="preserve">If @object was floating, the #GST_OBJECT_FLOATING flag is removed
and @object is unreffed. When @object was not floating,
this function does nothing.
Any newly created object has a refcount of 1 and is floating.
This function should be used when creating a new object to
symbolically 'take ownership' of @object. This done by first doing a
gst_object_ref() to keep a reference to @object and then gst_object_sink()
to remove and unref any floating references to @object.
Use gst_object_set_parent() to have this done for you.
MT safe. This function grabs and releases @object lock.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstObject to sink</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref" c:identifier="gst_object_unref">
        <doc xml:whitespace="preserve">Decrements the reference count on @object.  If reference count hits
zero, destroy @object. This function does not take the lock
on @object as it relies on atomic refcounting.
The unref method should never be called with the LOCK held since
this might deadlock the dispose function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstObject to unreference</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="deep_notify">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="orig" transfer-ownership="none">
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="object_saved">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parent_set">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parent_unset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="restore_thyself" invoker="restore_thyself">
        <doc xml:whitespace="preserve">Restores @object with the data from the parent XML node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">The XML node to load @object from</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="save_thyself"
                      invoker="save_thyself"
                      introspectable="0">
        <doc xml:whitespace="preserve">Saves @object into the parent XML node.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the new xmlNodePtr with the saved object</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">The parent XML node to save @object into</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="default_error" c:identifier="gst_object_default_error">
        <doc xml:whitespace="preserve">A default error function.
The default handler will simply print the error string using g_print.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GError.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an additional debug information string, or NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="gst_object_get_name">
        <doc xml:whitespace="preserve">Returns a copy of the name of @object.
Caller should g_free() the return value after usage.
For a nameless object, this returns NULL, which you can safely g_free()
as well.
MT safe. This function grabs and releases @object's LOCK.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the name of @object. g_free() after usage.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_name_prefix"
              c:identifier="gst_object_get_name_prefix"
              deprecated="deprecated because the name prefix has never actually been used">
        <doc xml:whitespace="preserve">Returns a copy of the name prefix of @object.
Caller should g_free() the return value after usage.
For a prefixless object, this returns NULL, which you can safely g_free()
as well.
MT safe. This function grabs and releases @object's LOCK.
for anything.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the name prefix of @object. g_free() after usage.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_parent" c:identifier="gst_object_get_parent">
        <doc xml:whitespace="preserve">Returns the parent of @object. This function increases the refcount
of the parent object so you should gst_object_unref() it after usage.
has no parent. unref after usage.
MT safe. Grabs and releases @object's LOCK.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">parent of @object, this can be NULL if @object</doc>
          <type name="Object" c:type="GstObject*"/>
        </return-value>
      </method>
      <method name="get_path_string" c:identifier="gst_object_get_path_string">
        <doc xml:whitespace="preserve">Generates a string describing the path of @object in
the object hierarchy. Only useful (or used) for debugging.
g_free() the string after usage.
MT safe. Grabs and releases the #GstObject's LOCK for all objects
in the hierarchy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string describing the path of @object. You must</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="has_ancestor" c:identifier="gst_object_has_ancestor">
        <doc xml:whitespace="preserve">Check if @object has an ancestor @ancestor somewhere up in
the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.
MT safe. Grabs and releases @object's locks.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @ancestor is an ancestor of @object.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="ancestor" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstObject to check as ancestor</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="restore_thyself" c:identifier="gst_object_restore_thyself">
        <doc xml:whitespace="preserve">Restores @object with the data from the parent XML node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">The XML node to load @object from</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_thyself"
              c:identifier="gst_object_save_thyself"
              introspectable="0">
        <doc xml:whitespace="preserve">Saves @object into the parent XML node.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the new xmlNodePtr with the saved object</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">The parent XML node to save @object into</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="gst_object_set_name">
        <doc xml:whitespace="preserve">Sets the name of @object, or gives @object a guaranteed unique
name (if @name is NULL).
This function makes a copy of the provided name, so the caller
retains ownership of the name it sent.
a parent cannot be renamed, this function returns FALSE in those
cases.
MT safe.  This function grabs and releases @object's LOCK.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the name could be set. Since Objects that have</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">new name of object</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name_prefix"
              c:identifier="gst_object_set_name_prefix"
              deprecated="deprecated because the name prefix has never actually been used">
        <doc xml:whitespace="preserve">Sets the name prefix of @object to @name_prefix.
This function makes a copy of the provided name prefix, so the caller
retains ownership of the name prefix it sent.
MT safe.  This function grabs and releases @object's LOCK.
for anything.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name_prefix" transfer-ownership="none">
            <doc xml:whitespace="preserve">new name prefix of @object</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parent" c:identifier="gst_object_set_parent">
        <doc xml:whitespace="preserve">Sets the parent of @object to @parent. The object's reference count will
be incremented, and any floating reference will be removed (see gst_object_sink()).
This function causes the parent-set signal to be emitted when the parent
was successfully set.
already had a parent or @object and @parent are the same.
MT safe. Grabs and releases @object's LOCK.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @parent could be set or FALSE when @object</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">new parent of object</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unparent" c:identifier="gst_object_unparent">
        <doc xml:whitespace="preserve">Clear the parent of @object, removing the associated reference.
This function decreases the refcount of @object.
MT safe. Grabs and releases @object's lock.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <property name="name"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <field name="object">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="refcount">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="lock">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="name">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="name_prefix">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="parent">
        <type name="Object" c:type="GstObject*"/>
      </field>
      <field name="flags">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="deep-notify" introspectable="0">
        <doc xml:whitespace="preserve">The deep notify signal is used to be notified of property changes. It is
typically attached to the toplevel bin to receive notifications from all
the elements contained in that bin.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="prop_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object that originated the signal</doc>
            <type name="Object"/>
          </parameter>
          <parameter name="prop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property that changed</doc>
            <type/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="object-saved">
        <doc xml:whitespace="preserve">Trigered whenever a new object is saved to XML. You can connect to this
signal to insert custom XML tags into the core XML.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="xml_node" transfer-ownership="none">
            <doc xml:whitespace="preserve">the xmlNodePtr of the parent node</doc>
            <type name="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="parent-set">
        <doc xml:whitespace="preserve">Emitted when the parent of an object is set.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new parent</doc>
            <type name="Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="parent-unset">
        <doc xml:whitespace="preserve">Emitted when the parent of an object is unset.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the old parent</doc>
            <type name="Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ObjectClass"
            c:type="GstObjectClass"
            glib:is-gtype-struct-for="Object">
      <doc xml:whitespace="preserve">GStreamer base object class.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="path_string_separator">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="signal_object">
        <type name="GObject.Object" c:type="GObject*"/>
      </field>
      <field name="lock">
        <type name="GLib.StaticRecMutex" c:type="GStaticRecMutex*"/>
      </field>
      <field name="parent_set">
        <callback name="parent_set">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="parent" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parent_unset">
        <callback name="parent_unset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="parent" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="object_saved">
        <callback name="object_saved">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="parent" transfer-ownership="none">
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="deep_notify">
        <callback name="deep_notify">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="orig" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="save_thyself" introspectable="0">
        <callback name="save_thyself" introspectable="0">
          <return-value>
            <doc xml:whitespace="preserve">the new xmlNodePtr with the saved object</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="parent" transfer-ownership="none">
              <doc xml:whitespace="preserve">The parent XML node to save @object into</doc>
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="restore_thyself">
        <callback name="restore_thyself">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="self" transfer-ownership="none">
              <doc xml:whitespace="preserve">The XML node to load @object from</doc>
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="ObjectFlags" c:type="GstObjectFlags">
      <doc xml:whitespace="preserve">The standard flags that an gstobject may have.</doc>
      <member name="disposing" value="1" c:identifier="GST_OBJECT_DISPOSING"/>
      <member name="floating" value="2" c:identifier="GST_OBJECT_FLOATING"/>
      <member name="flag_last" value="16" c:identifier="GST_OBJECT_FLAG_LAST"/>
    </bitfield>
    <constant name="PAD_LINK_CHECK_DEFAULT" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_CONTROLLABLE" value="2">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_MUTABLE_PAUSED" value="8">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_MUTABLE_PLAYING" value="16">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_MUTABLE_READY" value="4">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_USER_SHIFT" value="256">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Pad"
           c:symbol-prefix="pad"
           c:type="GstPad"
           parent="Object"
           glib:type-name="GstPad"
           glib:get-type="gst_pad_get_type"
           glib:type-struct="PadClass">
      <doc xml:whitespace="preserve">A #GstElement is linked to other elements via "pads", which are extremely
light-weight generic link points.
After two pads are retrieved from an element with gst_element_get_pad(),
the pads can be link with gst_pad_link(). (For quick links,
you can also use gst_element_link(), which will make the obvious
link for you if it's straightforward.)
Pads are typically created from a #GstPadTemplate with
gst_pad_new_from_template().
Pads have #GstCaps attached to it to describe the media type they are
capable of dealing with.  gst_pad_get_caps() and gst_pad_set_caps() are
used to manipulate the caps of the pads.
Pads created from a pad template cannot set capabilities that are
incompatible with the pad template capabilities.
Pads without pad templates can be created with gst_pad_new(),
which takes a direction and a name as an argument.  If the name is NULL,
then a guaranteed unique name will be assigned to it.
gst_pad_get_parent() will retrieve the #GstElement that owns the pad.
A #GstElement creating a pad will typically use the various
gst_pad_set_*_function() calls to register callbacks for various events
on the pads.
GstElements will use gst_pad_push() and gst_pad_pull_range() to push out
or pull in a buffer.
To send a #GstEvent on a pad, use gst_pad_send_event() and
gst_pad_push_event().
Last reviewed on 2006-07-06 (0.10.9)</doc>
      <constructor name="new" c:identifier="gst_pad_new">
        <doc xml:whitespace="preserve">Creates a new pad with the given name in the given direction.
If name is NULL, a guaranteed unique name (across all pads)
will be assigned.
This function makes a copy of the name so you can safely free the name.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the new pad.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadDirection of the pad.</doc>
            <type name="PadDirection" c:type="GstPadDirection"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_static_template"
                   c:identifier="gst_pad_new_from_static_template">
        <doc xml:whitespace="preserve">Creates a new pad with the given name from the given static template.
If name is NULL, a guaranteed unique name (across all pads)
will be assigned.
This function makes a copy of the name so you can safely free the name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="templ" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstStaticPadTemplate to use</doc>
            <type name="StaticPadTemplate" c:type="GstStaticPadTemplate*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the element</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_template"
                   c:identifier="gst_pad_new_from_template">
        <doc xml:whitespace="preserve">Creates a new pad with the given name from the given template.
If name is NULL, a guaranteed unique name (across all pads)
will be assigned.
This function makes a copy of the name so you can safely free the name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="templ" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad template to use</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the element</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="load_and_link" c:identifier="gst_pad_load_and_link">
        <doc xml:whitespace="preserve">Reads the pad definition from the XML node and links the given pad
in the element to a pad of an element up in the hierarchy.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #xmlNodePtr to read the description from.</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstObject element that owns the pad.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="have_data">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <type name="MiniObject" c:type="GstMiniObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="linked">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="peer" transfer-ownership="none">
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_link">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unlinked">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="peer" transfer-ownership="none">
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="accept_caps" c:identifier="gst_pad_accept_caps">
        <doc xml:whitespace="preserve">Check if the given pad accepts the caps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad can accept the caps.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to check on the pad</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="activate_pull" c:identifier="gst_pad_activate_pull">
        <doc xml:whitespace="preserve">Activates or deactivates the given pad in pull mode via dispatching to the
pad's activatepullfunc. For use from within pad activation functions only.
When called on sink pads, will first proxy the call to the peer pad, which
is expected to activate its internally linked pads from within its
activate_pull function.
If you don't know what this is, you probably don't want to call it.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the operation was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether or not the pad should be active.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="activate_push" c:identifier="gst_pad_activate_push">
        <doc xml:whitespace="preserve">Activates or deactivates the given pad in push mode via dispatching to the
pad's activatepushfunc. For use from within pad activation functions only.
If you don't know what this is, you probably don't want to call it.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the pad should be active or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_buffer_probe"
              c:identifier="gst_pad_add_buffer_probe"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds a probe that will be called for all buffers passing through a pad. See
gst_pad_add_data_probe() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The handler id</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <parameter name="handler" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">function to call when buffers are passed over pad</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass along with the handler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_buffer_probe_full"
              c:identifier="gst_pad_add_buffer_probe_full"
              version="0.10.20">
        <doc xml:whitespace="preserve">Adds a probe that will be called for all buffers passing through a pad. See
gst_pad_add_data_probe() for more information.
The @notify function is called when the probe is disconnected and usually
used to free @data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The handler id</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <parameter name="handler"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">function to call when buffer are passed over pad</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass along with the handler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async">
            <doc xml:whitespace="preserve">function to call when the probe is disconnected, or NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_data_probe"
              c:identifier="gst_pad_add_data_probe"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds a "data probe" to a pad. This function will be called whenever data
passes through a pad. In this case data means both events and buffers. The
probe will be called with the data as an argument, meaning @handler should
have the same callback signature as the #GstPad::have-data signal.
Note that the data will have a reference count greater than 1, so it will
be immutable -- you must not change it.
For source pads, the probe will be called after the blocking function, if any
(see gst_pad_set_blocked_async()), but before looking up the peer to chain
to. For sink pads, the probe function will be called before configuring the
sink with new caps, if any, and before calling the pad's chain function.
Your data probe should return TRUE to let the data continue to flow, or FALSE
to drop it. Dropping data is rarely useful, but occasionally comes in handy
with events.
Although probes are implemented internally by connecting @handler to the
have-data signal on the pad, if you want to remove a probe it is insufficient
to only call g_signal_handler_disconnect on the returned handler id. To
remove a probe, use the appropriate function, such as
gst_pad_remove_data_probe().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The handler id.</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <parameter name="handler" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">function to call when data is passed over pad</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass along with the handler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_data_probe_full"
              c:identifier="gst_pad_add_data_probe_full"
              version="0.10.20">
        <doc xml:whitespace="preserve">Adds a "data probe" to a pad. This function will be called whenever data
passes through a pad. In this case data means both events and buffers. The
probe will be called with the data as an argument, meaning @handler should
have the same callback signature as the #GstPad::have-data signal.
Note that the data will have a reference count greater than 1, so it will
be immutable -- you must not change it.
For source pads, the probe will be called after the blocking function, if any
(see gst_pad_set_blocked_async()), but before looking up the peer to chain
to. For sink pads, the probe function will be called before configuring the
sink with new caps, if any, and before calling the pad's chain function.
Your data probe should return TRUE to let the data continue to flow, or FALSE
to drop it. Dropping data is rarely useful, but occasionally comes in handy
with events.
Although probes are implemented internally by connecting @handler to the
have-data signal on the pad, if you want to remove a probe it is insufficient
to only call g_signal_handler_disconnect on the returned handler id. To
remove a probe, use the appropriate function, such as
gst_pad_remove_data_probe().
The @notify function is called when the probe is disconnected and usually
used to free @data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The handler id.</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <parameter name="handler"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">function to call when data is passed over pad</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass along with the handler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async">
            <doc xml:whitespace="preserve">function to call when the probe is disconnected, or NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_event_probe"
              c:identifier="gst_pad_add_event_probe"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds a probe that will be called for all events passing through a pad. See
gst_pad_add_data_probe() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The handler id</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <parameter name="handler" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">function to call when events are passed over pad</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass along with the handler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_event_probe_full"
              c:identifier="gst_pad_add_event_probe_full"
              version="0.10.20">
        <doc xml:whitespace="preserve">Adds a probe that will be called for all events passing through a pad. See
gst_pad_add_data_probe() for more information.
The @notify function is called when the probe is disconnected and usually
used to free @data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The handler id</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <parameter name="handler"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">function to call when events are passed over pad</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass along with the handler, or NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async">
            <doc xml:whitespace="preserve">function to call when probe is disconnected, or NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="alloc_buffer" c:identifier="gst_pad_alloc_buffer">
        <doc xml:whitespace="preserve">Allocates a new, empty buffer optimized to push to pad @pad.  This
function only works if @pad is a source pad and has a peer.
A new, empty #GstBuffer will be put in the @buf argument.
You need to check the caps of the buffer after performing this
function and renegotiate to the format if needed. If the caps changed, it is
possible that the buffer returned in @buf is not of the right size for the
new format, @buf needs to be unreffed and reallocated if this is the case.
result code other than #GST_FLOW_OK is an error and @buf should
not be used.
An error can occur if the pad is not connected or when the downstream
peer elements cannot provide an acceptable buffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a result code indicating success of the operation. Any</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset of the new buffer in the stream</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the new buffer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps of the new buffer</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:whitespace="preserve">a newly allocated buffer</doc>
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </method>
      <method name="alloc_buffer_and_set_caps"
              c:identifier="gst_pad_alloc_buffer_and_set_caps">
        <doc xml:whitespace="preserve">In addition to the function gst_pad_alloc_buffer(), this function
automatically calls gst_pad_set_caps() when the caps of the
newly allocated buffer are different from the @pad caps.
After a renegotiation, the size of the new buffer returned in @buf could
be of the wrong size for the new format and must be unreffed an reallocated
in that case.
result code other than #GST_FLOW_OK is an error and @buf should
not be used.
An error can occur if the pad is not connected or when the downstream
peer elements cannot provide an acceptable buffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a result code indicating success of the operation. Any</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset of the new buffer in the stream</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the new buffer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps of the new buffer</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="buf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a newly allocated buffer</doc>
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_link" c:identifier="gst_pad_can_link">
        <doc xml:whitespace="preserve">Checks if the source pad and the sink pad are compatible so they can be
linked.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads can be linked.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="sinkpad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sink #GstPad.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="chain" c:identifier="gst_pad_chain">
        <doc xml:whitespace="preserve">Chain a buffer to @pad.
The function returns #GST_FLOW_WRONG_STATE if the pad was flushing.
If the caps on @buffer are different from the current caps on @pad, this
function will call any setcaps function (see gst_pad_set_setcaps_function())
installed on @pad. If the new caps are not acceptable for @pad, this
function returns #GST_FLOW_NOT_NEGOTIATED.
The function proceeds calling the chain function installed on @pad (see
gst_pad_set_chain_function()) and the return value of that function is
returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if @pad has no
chain function.
In all cases, success or failure, the caller loses its reference to @buffer
after calling this function.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the pad.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstBuffer to send, return GST_FLOW_ERROR if not.</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="chain_list"
              c:identifier="gst_pad_chain_list"
              version="0.10.24">
        <doc xml:whitespace="preserve">Chain a bufferlist to @pad.
The function returns #GST_FLOW_WRONG_STATE if the pad was flushing.
If the caps on the first buffer of @list are different from the current
caps on @pad, this function will call any setcaps function
(see gst_pad_set_setcaps_function()) installed on @pad. If the new caps
are not acceptable for @pad, this function returns #GST_FLOW_NOT_NEGOTIATED.
The function proceeds calling the chainlist function installed on @pad (see
gst_pad_set_chain_list_function()) and the return value of that function is
returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if @pad has no
chainlist function.
In all cases, success or failure, the caller loses its reference to @list
after calling this function.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the pad.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstBufferList to send, return GST_FLOW_ERROR if not.</doc>
            <type name="BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_pull_range" c:identifier="gst_pad_check_pull_range">
        <doc xml:whitespace="preserve">Checks if a gst_pad_pull_range() can be performed on the peer
source pad. This function is used by plugins that want to check
if they can use random access on the peer source pad.
The peer sourcepad can implement a custom #GstPadCheckGetRangeFunction
if it needs to perform some logic to determine if pull_range is
possible.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a gboolean with the result.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="dispatcher"
              c:identifier="gst_pad_dispatcher"
              introspectable="0">
        <doc xml:whitespace="preserve">Invokes the given dispatcher function on each respective peer of
all pads that are internally linked to the given pad.
The GstPadDispatcherFunction should return TRUE when no further pads
need to be processed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if one of the dispatcher functions returned TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dispatch" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the #GstPadDispatcherFunction to call.</doc>
            <type name="PadDispatcherFunction"
                  c:type="GstPadDispatcherFunction"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">gpointer user data passed to the dispatcher function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="event_default" c:identifier="gst_pad_event_default">
        <doc xml:whitespace="preserve">Invokes the default event handler for the given pad. End-of-stream and
discontinuity events are handled specially, and then the event is sent to all
pads internally linked to @pad. Note that if there are many possible sink
pads that are internally linked to @pad, only one will be sent an event.
Multi-sinkpad elements should implement custom event handlers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the event was sent succesfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstEvent to handle.</doc>
            <type name="Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fixate_caps" c:identifier="gst_pad_fixate_caps">
        <doc xml:whitespace="preserve">Fixate a caps on the given pad. Modifies the caps in place, so you should
make sure that the caps are actually writable (see gst_caps_make_writable()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the  #GstCaps to fixate</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_allowed_caps" c:identifier="gst_pad_get_allowed_caps">
        <doc xml:whitespace="preserve">Gets the capabilities of the allowed media types that can flow through
The allowed capabilities is calculated as the intersection of the results of
calling gst_pad_get_caps() on @pad and its peer. The caller owns a reference
on the resulting caps.
caps when you no longer need it. This function returns NULL when @pad
has no peer.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the allowed #GstCaps of the pad link. Unref the</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_caps" c:identifier="gst_pad_get_caps">
        <doc xml:whitespace="preserve">Gets the capabilities this pad can produce or consume.
Note that this method doesn't necessarily return the caps set by
gst_pad_set_caps() - use GST_PAD_CAPS() for that instead.
gst_pad_get_caps returns all possible caps a pad can operate with, using
the pad's get_caps function;
this returns the pad template caps if not explicitly set.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated copy of the #GstCaps of this pad</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_caps_reffed"
              c:identifier="gst_pad_get_caps_reffed"
              version="0.10.26">
        <doc xml:whitespace="preserve">Gets the capabilities this pad can produce or consume. Preferred function if
one only wants to read or intersect the caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the caps of the pad with incremented ref-count.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_direction" c:identifier="gst_pad_get_direction">
        <doc xml:whitespace="preserve">Gets the direction of the pad. The direction of the pad is
decided at construction time so this function does not take
the LOCK.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPadDirection of the pad.</doc>
          <type name="PadDirection" c:type="GstPadDirection"/>
        </return-value>
      </method>
      <method name="get_element_private"
              c:identifier="gst_pad_get_element_private">
        <doc xml:whitespace="preserve">Gets the private data of a pad.
No locking is performed in this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gpointer to the private data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="get_fixed_caps_func"
              c:identifier="gst_pad_get_fixed_caps_func">
        <doc xml:whitespace="preserve">A helper function you can use as a GetCaps function that
will return the currently negotiated caps or the padtemplate
when NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the currently negotiated caps or the padtemplate.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_internal_links"
              c:identifier="gst_pad_get_internal_links"
              deprecated="This function does not ref the pads in the list so that they">
        <doc xml:whitespace="preserve">Gets a list of pads to which the given pad is linked to
inside of the parent element.
The caller must free this list after use.
Not MT safe.
of pads, free with g_list_free().
could become invalid by the time the application accesses them. It's also
possible that the list changes while handling the pads, which the caller of
this function is unable to know. Use the thread-safe 
gst_pad_iterate_internal_links() instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Pad"/>
          </type>
        </return-value>
      </method>
      <method name="get_internal_links_default"
              c:identifier="gst_pad_get_internal_links_default"
              deprecated="This function does not ref the pads in the list so that they">
        <doc xml:whitespace="preserve">Gets a list of pads to which the given pad is linked to
inside of the parent element.
This is the default handler, and thus returns a list of all of the
pads inside the parent element with opposite direction.
The caller must free this list after use with g_list_free().
of pads, or NULL if the pad has no parent.
Not MT safe.
could become invalid by the time the application accesses them. It's also
possible that the list changes while handling the pads, which the caller of
this function is unable to know. Use the thread-safe 
gst_pad_iterate_internal_links_default() instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Pad"/>
          </type>
        </return-value>
      </method>
      <method name="get_negotiated_caps"
              c:identifier="gst_pad_get_negotiated_caps">
        <doc xml:whitespace="preserve">Gets the capabilities of the media type that currently flows through @pad
and its peer.
This function can be used on both src and sinkpads. Note that srcpads are
always negotiated before sinkpads so it is possible that the negotiated caps
on the srcpad do not match the negotiated caps of the peer.
the caps when you no longer need it. This function returns NULL when
the @pad has no peer or is not negotiated yet.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the negotiated #GstCaps of the pad link. Unref</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_pad_template" c:identifier="gst_pad_get_pad_template">
        <doc xml:whitespace="preserve">Gets the template for @pad.
instantiated, or %NULL if this pad has no template.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPadTemplate from which this pad was</doc>
          <type name="PadTemplate" c:type="GstPadTemplate*"/>
        </return-value>
      </method>
      <method name="get_pad_template_caps"
              c:identifier="gst_pad_get_pad_template_caps">
        <doc xml:whitespace="preserve">Gets the capabilities for @pad's template.
to keep a reference on the caps, make a copy (see gst_caps_copy ()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstCaps of this pad template. If you intend</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_parent_element"
              c:identifier="gst_pad_get_parent_element">
        <doc xml:whitespace="preserve">Gets the parent of @pad, cast to a #GstElement. If a @pad has no parent or
its parent is not an element, return NULL.
reference on the parent, so unref when you're finished with it.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the parent of the pad. The caller has a</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
      </method>
      <method name="get_peer" c:identifier="gst_pad_get_peer">
        <doc xml:whitespace="preserve">Gets the peer of @pad. This function refs the peer pad so
you need to unref it after use.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the peer #GstPad. Unref after usage.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
      </method>
      <method name="get_query_types" c:identifier="gst_pad_get_query_types">
        <doc xml:whitespace="preserve">Get an array of supported queries that can be performed
on this pad.
of #GstQueryType.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a zero-terminated array</doc>
          <array c:type="GstQueryType*">
            <type name="QueryType" c:type="GstQueryType"/>
          </array>
        </return-value>
      </method>
      <method name="get_query_types_default"
              c:identifier="gst_pad_get_query_types_default">
        <doc xml:whitespace="preserve">Invoke the default dispatcher for the query types on
the pad.
of #GstQueryType, or NULL if none of the internally-linked pads has a
query types function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a zero-terminated array</doc>
          <array c:type="GstQueryType*">
            <type name="QueryType" c:type="GstQueryType"/>
          </array>
        </return-value>
      </method>
      <method name="get_range" c:identifier="gst_pad_get_range">
        <doc xml:whitespace="preserve">When @pad is flushing this function returns #GST_FLOW_WRONG_STATE
immediatly and @buffer is %NULL.
Calls the getrange function of @pad, see #GstPadGetRangeFunction for a
description of a getrange function. If @pad has no getrange function
installed (see gst_pad_set_getrange_function()) this function returns
#GST_FLOW_NOT_SUPPORTED.
This is a lowlevel function. Usualy gst_pad_pull_range() is used.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the pad.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The start offset of the buffer</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">The length of the buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buffer"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to hold the #GstBuffer, returns #GST_FLOW_ERROR if %NULL.</doc>
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_active" c:identifier="gst_pad_is_active">
        <doc xml:whitespace="preserve">Query if a pad is active
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad is active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_blocked" c:identifier="gst_pad_is_blocked">
        <doc xml:whitespace="preserve">Checks if the pad is blocked or not. This function returns the
last requested state of the pad. It is not certain that the pad
is actually blocking at this point (see gst_pad_is_blocking()).
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad is blocked.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_blocking"
              c:identifier="gst_pad_is_blocking"
              version="0.10.11">
        <doc xml:whitespace="preserve">Checks if the pad is blocking or not. This is a guaranteed state
of whether the pad is actually blocking on a #GstBuffer or a #GstEvent.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad is blocking.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_linked" c:identifier="gst_pad_is_linked">
        <doc xml:whitespace="preserve">Checks if a @pad is linked to another pad or not.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad is linked, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="iterate_internal_links"
              c:identifier="gst_pad_iterate_internal_links"
              version="0.10.21"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets an iterator for the pads to which the given pad is linked to inside
of the parent element.
Each #GstPad element yielded by the iterator will have its refcount increased,
so unref after use.
pad does not have an iterator function configured. Use
gst_iterator_free() after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstIterator of #GstPad or %NULL when the</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_internal_links_default"
              c:identifier="gst_pad_iterate_internal_links_default"
              version="0.10.21"
              introspectable="0">
        <doc xml:whitespace="preserve">Iterate the list of pads to which the given pad is linked to inside of
the parent element.
This is the default handler, and thus returns an iterator of all of the
pads inside the parent element with opposite direction.
The caller must free this iterator after use with gst_iterator_free().
returned pad with gst_object_unref().</doc>
        <return-value>
          <doc xml:whitespace="preserve">a #GstIterator of #GstPad, or NULL if @pad has no parent. Unref each</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="link" c:identifier="gst_pad_link">
        <doc xml:whitespace="preserve">Links the source pad and the sink pad.
what went wrong.
MT Safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A result code indicating if the connection worked or</doc>
          <type name="PadLinkReturn" c:type="GstPadLinkReturn"/>
        </return-value>
        <parameters>
          <parameter name="sinkpad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sink #GstPad to link.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_full"
              c:identifier="gst_pad_link_full"
              version="0.10.30">
        <doc xml:whitespace="preserve">Links the source pad and the sink pad.
This variant of #gst_pad_link provides a more granular control on the
checks being done when linking. While providing some considerable speedups
the caller of this method must be aware that wrong usage of those flags
can cause severe issues. Refer to the documentation of #GstPadLinkCheck
for more information.
MT Safe.
what went wrong.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A result code indicating if the connection worked or</doc>
          <type name="PadLinkReturn" c:type="GstPadLinkReturn"/>
        </return-value>
        <parameters>
          <parameter name="sinkpad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sink #GstPad to link.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the checks to validate when linking</doc>
            <type name="PadLinkCheck" c:type="GstPadLinkCheck"/>
          </parameter>
        </parameters>
      </method>
      <method name="pause_task" c:identifier="gst_pad_pause_task">
        <doc xml:whitespace="preserve">Pause the task of @pad. This function will also wait until the
function executed by the task is finished if this function is not
called from the task function.
has no task.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a TRUE if the task could be paused or FALSE when the pad</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="peer_accept_caps" c:identifier="gst_pad_peer_accept_caps">
        <doc xml:whitespace="preserve">Check if the peer of @pad accepts @caps. If @pad has no peer, this function
returns TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the peer of @pad can accept the caps or @pad has no peer.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to check on the pad</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peer_get_caps" c:identifier="gst_pad_peer_get_caps">
        <doc xml:whitespace="preserve">Gets the capabilities of the peer connected to this pad. Similar to
gst_pad_get_caps().
peer pad. Use gst_caps_unref() to get rid of it. This function
returns %NULL if there is no peer pad.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated copy of the #GstCaps of the</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="peer_get_caps_reffed"
              c:identifier="gst_pad_peer_get_caps_reffed"
              version="0.10.26">
        <doc xml:whitespace="preserve">Gets the capabilities of the peer connected to this pad. Preferred function
if one only wants to read or intersect the caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the caps of the pad with incremented ref-count</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="peer_query"
              c:identifier="gst_pad_peer_query"
              version="0.10.15">
        <doc xml:whitespace="preserve">Performs gst_pad_query() on the peer of @pad.
The caller is responsible for both the allocation and deallocation of
the query structure.
if @pad has no peer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed. This function returns %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstQuery to perform.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="proxy_getcaps" c:identifier="gst_pad_proxy_getcaps">
        <doc xml:whitespace="preserve">Calls gst_pad_get_allowed_caps() for every other pad belonging to the
same element as @pad, and returns the intersection of the results.
This function is useful as a default getcaps function for an element
that can handle any stream format, but requires all its pads to have
the same caps.  Two such elements are tee and adder.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the intersection of the other pads' allowed caps.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="proxy_setcaps" c:identifier="gst_pad_proxy_setcaps">
        <doc xml:whitespace="preserve">Calls gst_pad_set_caps() for every other pad belonging to the
same element as @pad.  If gst_pad_set_caps() fails on any pad,
the proxy setcaps fails. May be used only during negotiation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if sucessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstCaps to link with</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pull_range" c:identifier="gst_pad_pull_range">
        <doc xml:whitespace="preserve">Pulls a @buffer from the peer pad.
This function will first trigger the pad block signal if it was
installed.
When @pad is not linked #GST_FLOW_NOT_LINKED is returned else this
function returns the result of gst_pad_get_range() on the peer pad.
See gst_pad_get_range() for a list of return values and for the
semantics of the arguments of this function.
configured on @pad. Renegotiation within a running pull-mode pipeline is not
supported.
When this function returns #GST_FLOW_OK, @buffer will contain a valid
#GstBuffer that should be freed with gst_buffer_unref() after usage.
#GST_FLOW_OK is returned.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the peer pad.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The start offset of the buffer</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">The length of the buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buffer"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to hold the #GstBuffer, returns GST_FLOW_ERROR if %NULL.</doc>
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="gst_pad_push">
        <doc xml:whitespace="preserve">Pushes a buffer to the peer of @pad.
This function will call an installed pad block before triggering any
installed pad probes.
If the caps on @buffer are different from the currently configured caps on
gst_pad_set_setcaps_function()). In case of failure to renegotiate the new
format, this function returns #GST_FLOW_NOT_NEGOTIATED.
The function proceeds calling gst_pad_chain() on the peer pad and returns
the value from that function. If @pad has no peer, #GST_FLOW_NOT_LINKED will
be returned.
In all cases, success or failure, the caller loses its reference to @buffer
after calling this function.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the peer pad.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstBuffer to push returns GST_FLOW_ERROR if not.</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_event" c:identifier="gst_pad_push_event">
        <doc xml:whitespace="preserve">Sends the event to the peer of the given pad. This function is
mainly used by elements to send events to their peer
elements.
This function takes owership of the provided event so you should
gst_event_ref() it if you want to reuse the event after this call.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the event was handled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstEvent to send to the pad.</doc>
            <type name="Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_list"
              c:identifier="gst_pad_push_list"
              version="0.10.24">
        <doc xml:whitespace="preserve">Pushes a buffer list to the peer of @pad.
This function will call an installed pad block before triggering any
installed pad probes.
If the caps on the first buffer in the first group of @list are different
from the currently configured caps on @pad, this function will call any
installed setcaps function on @pad (see gst_pad_set_setcaps_function()). In
case of failure to renegotiate the new format, this function returns
#GST_FLOW_NOT_NEGOTIATED.
If there are any probes installed on @pad every group of the buffer list
will be merged into a normal #GstBuffer and pushed via gst_pad_push and the
buffer list will be unreffed.
The function proceeds calling the chain function on the peer pad and returns
the value from that function. If @pad has no peer, #GST_FLOW_NOT_LINKED will
be returned. If the peer pad does not have any installed chainlist function
every group buffer of the list will be merged into a normal #GstBuffer and
chained via gst_pad_chain().
In all cases, success or failure, the caller loses its reference to @list
after calling this function.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the peer pad.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstBufferList to push returns GST_FLOW_ERROR if not.</doc>
            <type name="BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query" c:identifier="gst_pad_query">
        <doc xml:whitespace="preserve">Dispatches a query to a pad. The query should have been allocated by the
caller via one of the type-specific allocation functions. The element that
the pad belongs to is responsible for filling the query with an appropriate
response, which should then be parsed with a type-specific query parsing
function.
Again, the caller is responsible for both the allocation and deallocation of
the query structure.
Please also note that some queries might need a running pipeline to work.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstQuery to perform.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_convert" c:identifier="gst_pad_query_convert">
        <doc xml:whitespace="preserve">Queries a pad to convert @src_val in @src_format to @dest_format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstFormat to convert from.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">a value to convert.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the #GstFormat to convert to.</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="dest_val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the result.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_default" c:identifier="gst_pad_query_default">
        <doc xml:whitespace="preserve">Invokes the default query handler for the given pad.
The query is sent to all pads internally linked to @pad. Note that
if there are many possible sink pads that are internally linked to
Multi-sinkpad elements should implement custom query handlers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query was performed succesfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstQuery to handle.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_duration" c:identifier="gst_pad_query_duration">
        <doc xml:whitespace="preserve">Queries a pad for the total stream duration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the #GstFormat asked for. On return contains the #GstFormat used.</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location in which to store the total duration, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_peer_convert"
              c:identifier="gst_pad_query_peer_convert">
        <doc xml:whitespace="preserve">Queries the peer pad of a given sink pad to convert @src_val in @src_format
to @dest_format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstFormat to convert from.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">a value to convert.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the #GstFormat to convert to.</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="dest_val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the result.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_peer_duration"
              c:identifier="gst_pad_query_peer_duration">
        <doc xml:whitespace="preserve">Queries the peer pad of a given sink pad for the total stream duration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the #GstFormat asked for. On return contains the #GstFormat used.</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location in which to store the total duration, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_peer_position"
              c:identifier="gst_pad_query_peer_position">
        <doc xml:whitespace="preserve">Queries the peer of a given sink pad for the stream position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the #GstFormat asked for. On return contains the #GstFormat used.</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="cur"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location in which to store the current position, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_position" c:identifier="gst_pad_query_position">
        <doc xml:whitespace="preserve">Queries a pad for the stream position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the #GstFormat asked for. On return contains the #GstFormat used.</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="cur"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A location in which to store the current position, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_buffer_probe"
              c:identifier="gst_pad_remove_buffer_probe">
        <doc xml:whitespace="preserve">Removes a buffer probe from @pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handler_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">handler id returned from gst_pad_add_buffer_probe</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_data_probe"
              c:identifier="gst_pad_remove_data_probe">
        <doc xml:whitespace="preserve">Removes a data probe from @pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handler_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">handler id returned from gst_pad_add_data_probe</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_event_probe"
              c:identifier="gst_pad_remove_event_probe">
        <doc xml:whitespace="preserve">Removes an event probe from @pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handler_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">handler id returned from gst_pad_add_event_probe</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_event" c:identifier="gst_pad_send_event">
        <doc xml:whitespace="preserve">Sends the event to the pad. This function can be used
by applications to send events in the pipeline.
If @pad is a source pad, @event should be an upstream event. If @pad is a
sink pad, @event should be a downstream event. For example, you would not
send a #GST_EVENT_EOS on a src pad; EOS events only propagate downstream.
Furthermore, some downstream events have to be serialized with data flow,
like EOS, while some can travel out-of-band, like #GST_EVENT_FLUSH_START. If
the event needs to be serialized with data flow, this function will take the
pad's stream lock while calling its event function.
To find out whether an event type is upstream, downstream, or downstream and
serialized, see #GstEventTypeFlags, gst_event_type_get_flags(),
#GST_EVENT_IS_UPSTREAM, #GST_EVENT_IS_DOWNSTREAM, and
#GST_EVENT_IS_SERIALIZED. Note that in practice that an application or
plugin doesn't need to bother itself with this information; the core handles
all necessary locks and checks.
This function takes owership of the provided event so you should
gst_event_ref() it if you want to reuse the event after this call.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the event was handled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstEvent to send to the pad.</doc>
            <type name="Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_acceptcaps_function"
              c:identifier="gst_pad_set_acceptcaps_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given acceptcaps function for the pad.  The acceptcaps function
will be called to check if the pad can accept the given caps. Setting the
acceptcaps function to NULL restores the default behaviour of allowing
any caps that matches the caps from gst_pad_get_caps().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="acceptcaps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadAcceptCapsFunction to set.</doc>
            <type name="PadAcceptCapsFunction"
                  c:type="GstPadAcceptCapsFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_activate_function"
              c:identifier="gst_pad_set_activate_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given activate function for @pad. The activate function will
dispatch to gst_pad_activate_push() or gst_pad_activate_pull() to perform
the actual activation. Only makes sense to set on sink pads.
Call this function if your sink pad can start a pull-based task.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="activate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadActivateFunction to set.</doc>
            <type name="PadActivateFunction" c:type="GstPadActivateFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_activatepull_function"
              c:identifier="gst_pad_set_activatepull_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given activate_pull function for the pad. An activate_pull function
prepares the element and any upstream connections for pulling. See XXX
part-activation.txt for details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="activatepull" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadActivateModeFunction to set.</doc>
            <type name="PadActivateModeFunction"
                  c:type="GstPadActivateModeFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_activatepush_function"
              c:identifier="gst_pad_set_activatepush_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given activate_push function for the pad. An activate_push function
prepares the element for pushing. See XXX part-activation.txt for details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="activatepush" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadActivateModeFunction to set.</doc>
            <type name="PadActivateModeFunction"
                  c:type="GstPadActivateModeFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_active" c:identifier="gst_pad_set_active">
        <doc xml:whitespace="preserve">Activates or deactivates the given pad.
Normally called from within core state change functions.
If @active, makes sure the pad is active. If it is already active, either in
push or pull mode, just return. Otherwise dispatches to the pad's activate
function to perform the actual activation.
If not @active, checks the pad's current mode and calls
gst_pad_activate_push() or gst_pad_activate_pull(), as appropriate, with a
FALSE argument.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if the operation was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether or not the pad should be active.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blocked" c:identifier="gst_pad_set_blocked">
        <doc xml:whitespace="preserve">Blocks or unblocks the dataflow on a pad. This function is
a shortcut for gst_pad_set_blocked_async() with a NULL
callback.
&lt;note&gt;
Pad blocks are only possible for source pads in push mode
and sink pads in pull mode.
&lt;/note&gt;
wrong parameters were passed or the pad was already in the requested state.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad could be blocked. This function can fail if the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="blocked" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean indicating we should block or unblock</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blocked_async"
              c:identifier="gst_pad_set_blocked_async"
              introspectable="0">
        <doc xml:whitespace="preserve">Blocks or unblocks the dataflow on a pad. The provided callback
is called when the operation succeeds; this happens right before the next
attempt at pushing a buffer on the pad.
This can take a while as the pad can only become blocked when real dataflow
is happening.
When the pipeline is stalled, for example in PAUSED, this can
take an indeterminate amount of time.
You can pass NULL as the callback to make this call block. Be careful with
this blocking call as it might not return for reasons stated above.
&lt;note&gt;
Pad block handlers are only called for source pads in push mode
and sink pads in pull mode.
&lt;/note&gt;
wrong parameters were passed or the pad was already in the requested state.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad could be blocked. This function can fail if the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="blocked" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean indicating whether the pad should be blocked or unblocked</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">#GstPadBlockCallback that will be called when the operation succeeds</doc>
            <type name="PadBlockCallback" c:type="GstPadBlockCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blocked_async_full"
              c:identifier="gst_pad_set_blocked_async_full"
              version="0.10.23">
        <doc xml:whitespace="preserve">Blocks or unblocks the dataflow on a pad. The provided callback
is called when the operation succeeds; this happens right before the next
attempt at pushing a buffer on the pad.
This can take a while as the pad can only become blocked when real dataflow
is happening.
When the pipeline is stalled, for example in PAUSED, this can
take an indeterminate amount of time.
You can pass NULL as the callback to make this call block. Be careful with
this blocking call as it might not return for reasons stated above.
&lt;note&gt;
Pad block handlers are only called for source pads in push mode
and sink pads in pull mode.
&lt;/note&gt;
wrong parameters were passed or the pad was already in the requested state.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad could be blocked. This function can fail if the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="blocked" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean indicating whether the pad should be blocked or unblocked</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">#GstPadBlockCallback that will be called when the operation succeeds</doc>
            <type name="PadBlockCallback" c:type="GstPadBlockCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_data"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">#GDestroyNotify for user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_bufferalloc_function"
              c:identifier="gst_pad_set_bufferalloc_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given bufferalloc function for the pad. Note that the
bufferalloc function can only be set on sinkpads.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bufalloc" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadBufferAllocFunction to set.</doc>
            <type name="PadBufferAllocFunction"
                  c:type="GstPadBufferAllocFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_caps" c:identifier="gst_pad_set_caps">
        <doc xml:whitespace="preserve">Sets the capabilities of this pad. The caps must be fixed. Any previous
caps on the pad will be unreffed. This function refs the caps so you should
unref if as soon as you don't need it anymore.
It is possible to set NULL caps, which will make the pad unnegotiated
again.
or bad parameters were provided to this function.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the caps could be set. FALSE if the caps were not fixed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to set.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_chain_function"
              c:identifier="gst_pad_set_chain_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given chain function for the pad. The chain function is called to
process a #GstBuffer input buffer. see #GstPadChainFunction for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="chain" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadChainFunction to set.</doc>
            <type name="PadChainFunction" c:type="GstPadChainFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_chain_list_function"
              c:identifier="gst_pad_set_chain_list_function"
              version="0.10.24"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given chain list function for the pad. The chainlist function is
called to process a #GstBufferList input buffer list. See
#GstPadChainListFunction for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="chainlist" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadChainListFunction to set.</doc>
            <type name="PadChainListFunction"
                  c:type="GstPadChainListFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_checkgetrange_function"
              c:identifier="gst_pad_set_checkgetrange_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given checkgetrange function for the pad. Implement this function
on a pad if you dynamically support getrange based scheduling on the pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="check" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadCheckGetRangeFunction to set.</doc>
            <type name="PadCheckGetRangeFunction"
                  c:type="GstPadCheckGetRangeFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_element_private"
              c:identifier="gst_pad_set_element_private">
        <doc xml:whitespace="preserve">Set the given private data gpointer on the pad.
This function can only be used by the element that owns the pad.
No locking is performed in this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="priv" transfer-ownership="none">
            <doc xml:whitespace="preserve">The private data to attach to the pad.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_event_function"
              c:identifier="gst_pad_set_event_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given event handler for the pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadEventFunction to set.</doc>
            <type name="PadEventFunction" c:type="GstPadEventFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_fixatecaps_function"
              c:identifier="gst_pad_set_fixatecaps_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given fixatecaps function for the pad.  The fixatecaps function
will be called whenever the default values for a GstCaps needs to be
filled in.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fixatecaps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadFixateCapsFunction to set.</doc>
            <type name="PadFixateCapsFunction"
                  c:type="GstPadFixateCapsFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_getcaps_function"
              c:identifier="gst_pad_set_getcaps_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given getcaps function for the pad. @getcaps should return the
allowable caps for a pad in the context of the element's state, its link to
other elements, and the devices or files it has opened. These caps must be a
subset of the pad template caps. In the NULL state with no links, @getcaps
should ideally return the same caps as the pad template. In rare
circumstances, an object property can affect the caps returned by @getcaps,
but this is discouraged.
You do not need to call this function if @pad's allowed caps are always the
same as the pad template caps. This can only be true if the padtemplate
has fixed simple caps.
For most filters, the caps returned by @getcaps is directly affected by the
allowed caps on other pads. For demuxers and decoders, the caps returned by
the srcpad's getcaps function is directly related to the stream data. Again,
helps with autoplugging.
Note that the return value from @getcaps is owned by the caller, so the
caller should unref the caps after usage.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="getcaps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadGetCapsFunction to set.</doc>
            <type name="PadGetCapsFunction" c:type="GstPadGetCapsFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_getrange_function"
              c:identifier="gst_pad_set_getrange_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given getrange function for the pad. The getrange function is
called to produce a new #GstBuffer to start the processing pipeline. see
#GstPadGetRangeFunction for a description of the getrange function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="get" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadGetRangeFunction to set.</doc>
            <type name="PadGetRangeFunction" c:type="GstPadGetRangeFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_internal_link_function"
              c:identifier="gst_pad_set_internal_link_function"
              introspectable="0"
              deprecated="Use the thread-safe gst_pad_set_iterate_internal_links_function()">
        <doc xml:whitespace="preserve">Sets the given internal link function for the pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="intlink" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadIntLinkFunction to set.</doc>
            <type name="PadIntLinkFunction" c:type="GstPadIntLinkFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_iterate_internal_links_function"
              c:identifier="gst_pad_set_iterate_internal_links_function"
              version="0.10.21"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given internal link iterator function for the pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iterintlink" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadIterIntLinkFunction to set.</doc>
            <type name="PadIterIntLinkFunction"
                  c:type="GstPadIterIntLinkFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_link_function"
              c:identifier="gst_pad_set_link_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given link function for the pad. It will be called when
the pad is linked with another pad.
The return value #GST_PAD_LINK_OK should be used when the connection can be
made.
The return value #GST_PAD_LINK_REFUSED should be used when the connection
cannot be made for some reason.
If @link is installed on a source pad, it should call the #GstPadLinkFunction
of the peer sink pad, if present.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="link" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadLinkFunction to set.</doc>
            <type name="PadLinkFunction" c:type="GstPadLinkFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_query_function"
              c:identifier="gst_pad_set_query_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Set the given query function for the pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadQueryFunction to set.</doc>
            <type name="PadQueryFunction" c:type="GstPadQueryFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_query_type_function"
              c:identifier="gst_pad_set_query_type_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Set the given query type function for the pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadQueryTypeFunction to set.</doc>
            <type name="PadQueryTypeFunction"
                  c:type="GstPadQueryTypeFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_setcaps_function"
              c:identifier="gst_pad_set_setcaps_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given setcaps function for the pad.  The setcaps function
will be called whenever a buffer with a new media type is pushed or
pulled from the pad. The pad/element needs to update its internal
structures to process the new media type. If this new type is not
acceptable, the setcaps function should return FALSE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="setcaps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadSetCapsFunction to set.</doc>
            <type name="PadSetCapsFunction" c:type="GstPadSetCapsFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_unlink_function"
              c:identifier="gst_pad_set_unlink_function"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given unlink function for the pad. It will be called
when the pad is unlinked.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="unlink" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadUnlinkFunction to set.</doc>
            <type name="PadUnlinkFunction" c:type="GstPadUnlinkFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_task"
              c:identifier="gst_pad_start_task"
              introspectable="0">
        <doc xml:whitespace="preserve">Starts a task that repeatedly calls @func with @data. This function
is mostly used in pad activation functions to start the dataflow.
The #GST_PAD_STREAM_LOCK of @pad will automatically be acquired
before @func is called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a %TRUE if the task could be started.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the task function to call</doc>
            <type name="TaskFunction" c:type="GstTaskFunction"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data passed to the task function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop_task" c:identifier="gst_pad_stop_task">
        <doc xml:whitespace="preserve">Stop the task of @pad. This function will also make sure that the
function executed by the task will effectively stop if not called
from the GstTaskFunction.
This function will deadlock if called from the GstTaskFunction of
the task. Use gst_task_pause() instead.
Regardless of whether the pad has a task, the stream lock is acquired and
released so as to ensure that streaming through this pad has finished.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a TRUE if the task could be stopped or FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="unlink" c:identifier="gst_pad_unlink">
        <doc xml:whitespace="preserve">Unlinks the source pad from the sink pad. Will emit the #GstPad::unlinked
signal on both pads.
the pads were not linked together.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads were unlinked. This function returns FALSE if</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="sinkpad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sink #GstPad to unlink.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="use_fixed_caps" c:identifier="gst_pad_use_fixed_caps">
        <doc xml:whitespace="preserve">A helper function you can use that sets the
pad. This way the function will always return the negotiated caps
or in case the pad is not negotiated, the padtemplate caps.
Use this function on a pad that, once gst_pad_set_caps() has been called
on it, cannot be renegotiated to something else.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <property name="caps" transfer-ownership="none">
        <type name="Caps"/>
      </property>
      <property name="direction"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="template" writable="1" transfer-ownership="none">
        <type name="PadTemplate"/>
      </property>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="element_private">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="padtemplate">
        <type name="PadTemplate" c:type="GstPadTemplate*"/>
      </field>
      <field name="direction">
        <type name="PadDirection" c:type="GstPadDirection"/>
      </field>
      <field name="stream_rec_lock">
        <type name="GLib.StaticRecMutex" c:type="GStaticRecMutex*"/>
      </field>
      <field name="task">
        <type name="Task" c:type="GstTask*"/>
      </field>
      <field name="preroll_lock">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="preroll_cond">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="block_cond">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="block_callback">
        <type name="PadBlockCallback" c:type="GstPadBlockCallback"/>
      </field>
      <field name="block_data">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="caps">
        <type name="Caps" c:type="GstCaps*"/>
      </field>
      <field name="getcapsfunc">
        <type name="PadGetCapsFunction" c:type="GstPadGetCapsFunction"/>
      </field>
      <field name="setcapsfunc">
        <type name="PadSetCapsFunction" c:type="GstPadSetCapsFunction"/>
      </field>
      <field name="acceptcapsfunc">
        <type name="PadAcceptCapsFunction" c:type="GstPadAcceptCapsFunction"/>
      </field>
      <field name="fixatecapsfunc">
        <type name="PadFixateCapsFunction" c:type="GstPadFixateCapsFunction"/>
      </field>
      <field name="activatefunc">
        <type name="PadActivateFunction" c:type="GstPadActivateFunction"/>
      </field>
      <field name="activatepushfunc">
        <type name="PadActivateModeFunction"
              c:type="GstPadActivateModeFunction"/>
      </field>
      <field name="activatepullfunc">
        <type name="PadActivateModeFunction"
              c:type="GstPadActivateModeFunction"/>
      </field>
      <field name="linkfunc">
        <type name="PadLinkFunction" c:type="GstPadLinkFunction"/>
      </field>
      <field name="unlinkfunc">
        <type name="PadUnlinkFunction" c:type="GstPadUnlinkFunction"/>
      </field>
      <field name="peer">
        <type name="Pad" c:type="GstPad*"/>
      </field>
      <field name="sched_private">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="chainfunc">
        <type name="PadChainFunction" c:type="GstPadChainFunction"/>
      </field>
      <field name="checkgetrangefunc">
        <type name="PadCheckGetRangeFunction"
              c:type="GstPadCheckGetRangeFunction"/>
      </field>
      <field name="getrangefunc">
        <type name="PadGetRangeFunction" c:type="GstPadGetRangeFunction"/>
      </field>
      <field name="eventfunc">
        <type name="PadEventFunction" c:type="GstPadEventFunction"/>
      </field>
      <field name="mode">
        <type name="ActivateMode" c:type="GstActivateMode"/>
      </field>
      <field name="querytypefunc">
        <type name="PadQueryTypeFunction" c:type="GstPadQueryTypeFunction"/>
      </field>
      <field name="queryfunc">
        <type name="PadQueryFunction" c:type="GstPadQueryFunction"/>
      </field>
      <field name="intlinkfunc">
        <type name="PadIntLinkFunction" c:type="GstPadIntLinkFunction"/>
      </field>
      <field name="bufferallocfunc">
        <type name="PadBufferAllocFunction"
              c:type="GstPadBufferAllocFunction"/>
      </field>
      <field name="do_buffer_signals">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="do_event_signals">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="iterintlinkfunc" introspectable="0">
        <type name="PadIterIntLinkFunction"
              c:type="GstPadIterIntLinkFunction"/>
      </field>
      <field name="block_destroy_data">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="block_callback_called" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="priv" writable="1">
            <type name="PadPrivate" c:type="GstPadPrivate*"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="2">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
      <glib:signal name="have-data">
        <doc xml:whitespace="preserve">Signals that new data is available on the pad. This signal is used
internally for implementing pad probes.
See gst_pad_add_*_probe functions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE to keep the data, %FALSE to drop it</doc>
          <type name="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="mini_obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">new data</doc>
            <type name="MiniObject"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="linked">
        <doc xml:whitespace="preserve">Signals that a pad has been linked to the peer pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="peer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the peer pad that has been connected</doc>
            <type name="Pad"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-link">
        <doc xml:whitespace="preserve">Signals that a pad connection has been requested.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="unlinked">
        <doc xml:whitespace="preserve">Signals that a pad has been unlinked from the peer pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="peer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the peer pad that has been disconnected</doc>
            <type name="Pad"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="PadAcceptCapsFunction" c:type="GstPadAcceptCapsFunction">
      <doc xml:whitespace="preserve">Check if @pad can accept @caps. By default this function will see if @caps
intersect with the result from gst_pad_get_caps() by can be overridden to
perform extra checks.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the caps can be accepted by the pad.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to check</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="caps" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstCaps to check</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadActivateFunction" c:type="GstPadActivateFunction">
      <doc xml:whitespace="preserve">This function is called when the pad is activated during the element
READY to PAUSED state change. By default this function will call the
activate function that puts the pad in push mode but elements can
override this function to activate the pad in pull mode if they wish.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the pad could be activated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstPad</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadActivateModeFunction"
              c:type="GstPadActivateModeFunction">
      <doc xml:whitespace="preserve">The prototype of the push and pull activate functions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the pad could be activated or deactivated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstPad</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="active" transfer-ownership="none">
          <doc xml:whitespace="preserve">activate or deactivate the pad.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadBlockCallback" c:type="GstPadBlockCallback">
      <doc xml:whitespace="preserve">Callback used by gst_pad_set_blocked_async(). Gets called when the blocking
operation succeeds.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad that is blockend or unblocked.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="blocked" transfer-ownership="none">
          <doc xml:whitespace="preserve">blocking state for the pad</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">the gpointer to optional user data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadBufferAllocFunction" c:type="GstPadBufferAllocFunction">
      <doc xml:whitespace="preserve">Ask the sinkpad @pad to allocate a buffer with @offset, @size and @caps.
The result will be stored in @buf.
The purpose of this function is to allocate a buffer that is optimal to
be processed by @pad. The function is mostly overridden by elements that can
provide a hardware buffer in order to avoid additional memcpy operations.
The function can return a buffer that has caps different from the requested
new caps.
If a format change was requested, the returned buffer will be one to hold
the data of said new caps, so its size might be different from the requested
When this function returns anything else than #GST_FLOW_OK, the buffer allocation
failed and @buf does not contain valid data. If the function returns #GST_FLOW_OK and
the @buf is NULL, a #GstBuffer will be created with @caps, @offset and @size.
By default this function returns a new buffer of @size and with @caps containing
purely malloced data. The buffer should be freed with gst_buffer_unref()
after usage.
value means @buf does not hold a valid buffer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GST_FLOW_OK if @buf contains a valid buffer, any other return</doc>
        <type name="FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">a sink #GstPad</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">the desired offset of the buffer</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">the desired size of the buffer</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="caps" transfer-ownership="none">
          <doc xml:whitespace="preserve">the desired caps of the buffer</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to hold the allocated buffer.</doc>
          <type name="Buffer" c:type="GstBuffer**"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadChainFunction" c:type="GstPadChainFunction">
      <doc xml:whitespace="preserve">A function that will be called on sinkpads when chaining buffers.
The function typically processes the data contained in the buffer and
either consumes the data or passes it on to the internally linked pad(s).
The implementer of this function receives a refcount to @buffer and should
gst_buffer_unref() when the buffer is no longer needed.
When a chain function detects an error in the data stream, it must post an
error on the bus and return an appropriate #GstFlowReturn value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GST_FLOW_OK for success</doc>
        <type name="FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the sink #GstPad that performed the chain.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBuffer that is chained, not %NULL.</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadChainListFunction" c:type="GstPadChainListFunction">
      <doc xml:whitespace="preserve">A function that will be called on sinkpads when chaining buffer lists.
The function typically processes the data contained in the buffer list and
either consumes the data or passes it on to the internally linked pad(s).
The implementer of this function receives a refcount to @list and
should gst_buffer_list_unref() when the list is no longer needed.
When a chainlist function detects an error in the data stream, it must
post an error on the bus and return an appropriate #GstFlowReturn value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GST_FLOW_OK for success</doc>
        <type name="FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the sink #GstPad that performed the chain.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBufferList that is chained, not %NULL.</doc>
          <type name="BufferList" c:type="GstBufferList*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadCheckGetRangeFunction"
              c:type="GstPadCheckGetRangeFunction">
      <doc xml:whitespace="preserve">Check if @pad can be activated in pull mode.
This function will be deprecated after 0.10; use the seeking query to check
if a pad can support random access.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the pad can operate in pull mode.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstPad</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PadClass"
            c:type="GstPadClass"
            glib:is-gtype-struct-for="Pad">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="linked">
        <callback name="linked">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
            <parameter name="peer" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlinked">
        <callback name="unlinked">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
            <parameter name="peer" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_link">
        <callback name="request_link">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="have_data">
        <callback name="have_data">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="MiniObject" c:type="GstMiniObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="PadDirection" c:type="GstPadDirection">
      <doc xml:whitespace="preserve">The direction of a pad.</doc>
      <member name="unknown" value="0" c:identifier="GST_PAD_UNKNOWN"/>
      <member name="src" value="1" c:identifier="GST_PAD_SRC"/>
      <member name="sink" value="2" c:identifier="GST_PAD_SINK"/>
    </enumeration>
    <callback name="PadDispatcherFunction" c:type="GstPadDispatcherFunction">
      <doc xml:whitespace="preserve">A dispatcher function is called for all internally linked pads, see
gst_pad_dispatcher().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the dispatching procedure has to be stopped.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad that is dispatched.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">the gpointer to optional user data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadEventFunction" c:type="GstPadEventFunction">
      <doc xml:whitespace="preserve">Function signature to handle an event for the pad.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the pad could handle the event.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to handle the event.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstEvent to handle.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadFixateCapsFunction" c:type="GstPadFixateCapsFunction">
      <doc xml:whitespace="preserve">Given possibly unfixed caps @caps, let @pad use its default prefered
format to make a fixed caps. @caps should be writable. By default this
function will pick the first value of any ranges or lists in the caps but
elements can override this function to perform other behaviour.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstPad</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="caps" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstCaps to fixate</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="PadFlags" c:type="GstPadFlags">
      <doc xml:whitespace="preserve">Pad state flags</doc>
      <member name="blocked" value="16" c:identifier="GST_PAD_BLOCKED"/>
      <member name="flushing" value="32" c:identifier="GST_PAD_FLUSHING"/>
      <member name="in_getcaps" value="64" c:identifier="GST_PAD_IN_GETCAPS"/>
      <member name="in_setcaps" value="128" c:identifier="GST_PAD_IN_SETCAPS"/>
      <member name="blocking" value="256" c:identifier="GST_PAD_BLOCKING"/>
      <member name="flag_last" value="4096" c:identifier="GST_PAD_FLAG_LAST"/>
    </bitfield>
    <callback name="PadGetCapsFunction" c:type="GstPadGetCapsFunction">
      <doc xml:whitespace="preserve">Returns a copy of the capabilities of the specified pad. By default this
function will return the pad template capabilities, but can optionally
be overridden by elements.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated copy #GstCaps of the pad.</doc>
        <type name="Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to get the capabilities of.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadGetRangeFunction" c:type="GstPadGetRangeFunction">
      <doc xml:whitespace="preserve">This function will be called on source pads when a peer element
request a buffer at the specified @offset and @length. If this function
returns #GST_FLOW_OK, the result buffer will be stored in @buffer. The
contents of @buffer is invalid for any other return value.
This function is installed on a source pad with
gst_pad_set_getrange_function() and can only be called on source pads after
they are successfully activated with gst_pad_activate_pull().
between 0 and the length in bytes of the data available on @pad. The
length (duration in bytes) can be retrieved with a #GST_QUERY_DURATION or with a
#GST_QUERY_SEEKING.
Any @offset larger or equal than the length will make the function return
#GST_FLOW_UNEXPECTED, which corresponds to EOS. In this case @buffer does not
contain a valid buffer.
The buffer size of @buffer will only be smaller than @length when @offset is
near the end of the stream. In all other cases, the size of @buffer must be
exactly the requested size.
It is allowed to call this function with a 0 @length and valid @offset, in
which case @buffer will contain a 0-sized buffer and the function returns
#GST_FLOW_OK.
When this function is called with a -1 @offset, the sequentially next buffer
of length @length in the stream is returned.
When this function is called with a -1 @length, a buffer with a default
optimal length is returned in @buffer. The length might depend on the value
of @offset.
return value leaves @buffer undefined.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GST_FLOW_OK for success and a valid buffer in @buffer. Any other</doc>
        <type name="FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the src #GstPad to perform the getrange on.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset of the range</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of the range</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a memory location to hold the result buffer, cannot be NULL.</doc>
          <type name="Buffer" c:type="GstBuffer**"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadIntLinkFunction"
              c:type="GstPadIntLinkFunction"
              deprecated="use the threadsafe #GstPadIterIntLinkFunction instead.">
      <doc xml:whitespace="preserve">The signature of the internal pad link function.
the inside of the parent element.
The caller must call g_list_free() on it after use.</doc>
      <return-value transfer-ownership="container">
        <doc xml:whitespace="preserve">a newly allocated #GList of pads that are linked to the given pad on</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Pad"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstPad to query.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadIterIntLinkFunction"
              c:type="GstPadIterIntLinkFunction"
              introspectable="0">
      <doc xml:whitespace="preserve">The signature of the internal pad link iterator function.
linked to the given pad on the inside of the parent element.
the caller must call gst_iterator_free() after usage.
Since 0.10.21</doc>
      <return-value>
        <doc xml:whitespace="preserve">a new #GstIterator that will iterate over all pads that are</doc>
        <type name="Iterator" c:type="GstIterator*"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstPad to query.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="PadLinkCheck" version="0.10.30" c:type="GstPadLinkCheck">
      <doc xml:whitespace="preserve">The amount of checking to be done when linking pads. @GST_PAD_LINK_CHECK_CAPS
and @GST_PAD_LINK_CHECK_TEMPLATE_CAPS are mutually exclusive. If both are
specified, expensive but safe @GST_PAD_LINK_CHECK_CAPS are performed.
&lt;warning&gt;&lt;para&gt;
Only disable some of the checks if you are 100% certain you know the link
will not fail because of hierarchy/caps compatibility failures. If uncertain,
use the default checks (%GST_PAD_LINK_CHECK_DEFAULT) or the regular methods
for linking the pads.
&lt;/para&gt;&lt;/warning&gt;</doc>
      <member name="nothing"
              value="0"
              c:identifier="GST_PAD_LINK_CHECK_NOTHING"/>
      <member name="hierarchy"
              value="1"
              c:identifier="GST_PAD_LINK_CHECK_HIERARCHY"/>
      <member name="template_caps"
              value="2"
              c:identifier="GST_PAD_LINK_CHECK_TEMPLATE_CAPS"/>
      <member name="caps" value="4" c:identifier="GST_PAD_LINK_CHECK_CAPS"/>
    </bitfield>
    <callback name="PadLinkFunction" c:type="GstPadLinkFunction">
      <doc xml:whitespace="preserve">Function signature to handle a new link on the pad.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the result of the link with the specified peer.</doc>
        <type name="PadLinkReturn" c:type="GstPadLinkReturn"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad that is linked.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="peer" transfer-ownership="none">
          <doc xml:whitespace="preserve">the peer #GstPad of the link</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="PadLinkReturn" c:type="GstPadLinkReturn">
      <doc xml:whitespace="preserve">Result values from gst_pad_link and friends.</doc>
      <member name="ok" value="0" c:identifier="GST_PAD_LINK_OK"/>
      <member name="wrong_hierarchy"
              value="-1"
              c:identifier="GST_PAD_LINK_WRONG_HIERARCHY"/>
      <member name="was_linked"
              value="-2"
              c:identifier="GST_PAD_LINK_WAS_LINKED"/>
      <member name="wrong_direction"
              value="-3"
              c:identifier="GST_PAD_LINK_WRONG_DIRECTION"/>
      <member name="noformat" value="-4" c:identifier="GST_PAD_LINK_NOFORMAT"/>
      <member name="nosched" value="-5" c:identifier="GST_PAD_LINK_NOSCHED"/>
      <member name="refused" value="-6" c:identifier="GST_PAD_LINK_REFUSED"/>
    </enumeration>
    <enumeration name="PadPresence" c:type="GstPadPresence">
      <doc xml:whitespace="preserve">Indicates when this pad will become available.</doc>
      <member name="always" value="0" c:identifier="GST_PAD_ALWAYS"/>
      <member name="sometimes" value="1" c:identifier="GST_PAD_SOMETIMES"/>
      <member name="request" value="2" c:identifier="GST_PAD_REQUEST"/>
    </enumeration>
    <record name="PadPrivate" c:type="GstPadPrivate" disguised="1">
    </record>
    <callback name="PadQueryFunction" c:type="GstPadQueryFunction">
      <doc xml:whitespace="preserve">The signature of the query function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to query.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="query" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstQuery object to execute</doc>
          <type name="Query" c:type="GstQuery*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadQueryTypeFunction" c:type="GstPadQueryTypeFunction">
      <doc xml:whitespace="preserve">The signature of the query types function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a constant array of query types</doc>
        <type name="QueryType" c:type="GstQueryType*"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstPad to query</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadSetCapsFunction" c:type="GstPadSetCapsFunction">
      <doc xml:whitespace="preserve">Set @caps on @pad. By default this function updates the caps of the
pad but the function can be overriden by elements to perform extra
actions or verifications.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the caps could be set on the pad.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to set the capabilities of.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="caps" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstCaps to set</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="PadTemplate"
           c:symbol-prefix="pad_template"
           c:type="GstPadTemplate"
           parent="Object"
           glib:type-name="GstPadTemplate"
           glib:get-type="gst_pad_template_get_type"
           glib:type-struct="PadTemplateClass">
      <doc xml:whitespace="preserve">Padtemplates describe the possible media types a pad or an elementfactory can
handle. This allows for both inspection of handled types before loading the
element plugin as well as identifying pads on elements that are not yet
created (request or sometimes pads).
Pad and PadTemplates have #GstCaps attached to it to describe the media type
they are capable of dealing with. gst_pad_template_get_caps() or
GST_PAD_TEMPLATE_CAPS() are used to get the caps of a padtemplate. It's not
possible to modify the caps of a padtemplate after creation.
PadTemplates have a #GstPadPresence property which identifies the lifetime
of the pad and that can be retrieved with GST_PAD_TEMPLATE_PRESENCE(). Also
the direction of the pad can be retrieved from the #GstPadTemplate with
GST_PAD_TEMPLATE_DIRECTION().
The GST_PAD_TEMPLATE_NAME_TEMPLATE () is important for GST_PAD_REQUEST pads
because it has to be used as the name in the gst_element_get_request_pad()
call to instantiate a pad from this template.
Padtemplates can be created with gst_pad_template_new() or with
gst_static_pad_template_get (), which creates a #GstPadTemplate from a
#GstStaticPadTemplate that can be filled with the
convenient GST_STATIC_PAD_TEMPLATE() macro.
A padtemplate can be used to create a pad (see gst_pad_new_from_template()
or gst_pad_new_from_static_template ()) or to add to an element class
(see gst_element_class_add_pad_template ()).
The following code example shows the code to create a pad from a padtemplate.
&lt;example&gt;
&lt;title&gt;Create a pad from a padtemplate&lt;/title&gt;
&lt;programlisting&gt;
GstStaticPadTemplate my_template =
GST_STATIC_PAD_TEMPLATE (
"sink",          // the name of the pad
GST_PAD_SINK,    // the direction of the pad
GST_PAD_ALWAYS,  // when this pad will be present
GST_STATIC_CAPS (        // the capabilities of the padtemplate
"audio/x-raw-int, "
"channels = (int) [ 1, 6 ]"
)
);
void
my_method (void)
{
GstPad *pad;
pad = gst_pad_new_from_static_template (&amp;amp;my_template, "sink");
...
}
&lt;/programlisting&gt;
&lt;/example&gt;
The following example shows you how to add the padtemplate to an
element class, this is usually done in the base_init of the class:
&lt;informalexample&gt;
&lt;programlisting&gt;
static void
my_element_base_init (gpointer g_class)
{
GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
gst_element_class_add_pad_template (gstelement_class,
gst_static_pad_template_get (&amp;amp;my_template));
}
&lt;/programlisting&gt;
&lt;/informalexample&gt;
Last reviewed on 2006-02-14 (0.10.3)</doc>
      <constructor name="new" c:identifier="gst_pad_template_new">
        <doc xml:whitespace="preserve">Creates a new pad template with a name according to the given template
and with the given arguments. This functions takes ownership of the provided
caps, so be sure to not use them afterwards.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPadTemplate.</doc>
          <type name="PadTemplate" c:type="GstPadTemplate*"/>
        </return-value>
        <parameters>
          <parameter name="name_template" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name template.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadDirection of the template.</doc>
            <type name="PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadPresence of the pad.</doc>
            <type name="PadPresence" c:type="GstPadPresence"/>
          </parameter>
          <parameter name="caps" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstCaps set for the template. The caps are taken ownership of.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="pad_created" invoker="pad_created">
        <doc xml:whitespace="preserve">Emit the pad-created signal for this template when created by this pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad that created it</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_caps" c:identifier="gst_pad_template_get_caps">
        <doc xml:whitespace="preserve">Gets the capabilities of the pad template.
keep a reference to the caps, take a ref (see gst_caps_ref ()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstCaps of the pad template. If you need to</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="pad_created" c:identifier="gst_pad_template_pad_created">
        <doc xml:whitespace="preserve">Emit the pad-created signal for this template when created by this pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad that created it</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <property name="caps"
                version="0.10.21"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The capabilities of the pad described by the pad template.</doc>
        <type name="Caps"/>
      </property>
      <property name="direction"
                version="0.10.21"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The direction of the pad described by the pad template.</doc>
        <type/>
      </property>
      <property name="name-template"
                version="0.10.21"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name template of the pad template.</doc>
        <type name="utf8"/>
      </property>
      <property name="presence"
                version="0.10.21"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">When the pad described by the pad template will become available.</doc>
        <type/>
      </property>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="name_template">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="direction">
        <type name="PadDirection" c:type="GstPadDirection"/>
      </field>
      <field name="presence">
        <type name="PadPresence" c:type="GstPadPresence"/>
      </field>
      <field name="caps">
        <type name="Caps" c:type="GstCaps*"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="pad-created">
        <doc xml:whitespace="preserve">This signal is fired when an element creates a pad from this template.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad that was created.</doc>
            <type name="Pad"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="PadTemplateClass"
            c:type="GstPadTemplateClass"
            glib:is-gtype-struct-for="PadTemplate">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="pad_created">
        <callback name="pad_created">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="templ" transfer-ownership="none">
              <type name="PadTemplate" c:type="GstPadTemplate*"/>
            </parameter>
            <parameter name="pad" transfer-ownership="none">
              <doc xml:whitespace="preserve">the #GstPad that created it</doc>
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="PadTemplateFlags" c:type="GstPadTemplateFlags">
      <doc xml:whitespace="preserve">Flags for the padtemplate</doc>
      <member name="fixed" value="16" c:identifier="GST_PAD_TEMPLATE_FIXED"/>
      <member name="flag_last"
              value="256"
              c:identifier="GST_PAD_TEMPLATE_FLAG_LAST"/>
    </bitfield>
    <callback name="PadUnlinkFunction" c:type="GstPadUnlinkFunction">
      <doc xml:whitespace="preserve">Function signature to handle a unlinking the pad prom its peer.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad that is linked.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ParamFraction"
           c:symbol-prefix="param_spec_fraction"
           glib:type-name="GstParamFraction"
           glib:get-type="gst_param_spec_fraction_get_type"
           glib:fundamental="1">
      <function name=""
                c:identifier="gst_param_spec_fraction"
                version="0.10.14"
                introspectable="0">
        <doc xml:whitespace="preserve">This function creates a fraction GParamSpec for use by objects/elements
that want to expose properties of fraction type. This function is typically
used in connection with g_object_class_install_property() in a GObjects's
instance_init function.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a newly created parameter specification</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">canonical name of the property specified</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="nick" transfer-ownership="none">
            <doc xml:whitespace="preserve">nick name for the property specified</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="blurb" transfer-ownership="none">
            <doc xml:whitespace="preserve">description of the property specified</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="min_num" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum value (fraction numerator)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="min_denom" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum value (fraction denominator)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="max_num" transfer-ownership="none">
            <doc xml:whitespace="preserve">maximum value (fraction numerator)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="max_denom" transfer-ownership="none">
            <doc xml:whitespace="preserve">maximum value (fraction denominator)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="default_num" transfer-ownership="none">
            <doc xml:whitespace="preserve">default value (fraction numerator)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="default_denom" transfer-ownership="none">
            <doc xml:whitespace="preserve">default value (fraction denominator)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags for the property specified</doc>
            <type name="GObject.ParamFlags" c:type="GParamFlags"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <record name="ParamSpecFraction" c:type="GstParamSpecFraction">
      <doc xml:whitespace="preserve">A GParamSpec derived structure that contains the meta data for fractional
properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="min_num" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="min_den" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="max_num" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="max_den" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="def_num" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="def_den" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
    </record>
    <record name="ParamSpecMiniObject" c:type="GstParamSpecMiniObject">
      <doc xml:whitespace="preserve">A %GParamSpec derived structure that contains the meta data
for %GstMiniObject properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpec" c:type="GParamSpec"/>
      </field>
    </record>
    <record name="ParseContext"
            c:type="GstParseContext"
            version="0.10.20"
            glib:type-name="GstParseContext"
            glib:get-type="gst_parse_context_get_type"
            c:symbol-prefix="parse_context">
      <doc xml:whitespace="preserve">Opaque structure.</doc>
      <constructor name="new"
                   c:identifier="gst_parse_context_new"
                   version="0.10.20">
        <doc xml:whitespace="preserve">Allocates a parse context for use with gst_parse_launch_full() or
gst_parse_launchv_full().
gst_parse_context_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly-allocated parse context. Free with</doc>
          <type name="ParseContext" c:type="GstParseContext*"/>
        </return-value>
      </constructor>
      <method name="free"
              c:identifier="gst_parse_context_free"
              version="0.10.20">
        <doc xml:whitespace="preserve">Frees a parse context previously allocated with gst_parse_context_new().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_missing_elements"
              c:identifier="gst_parse_context_get_missing_elements"
              version="0.10.20">
        <doc xml:whitespace="preserve">Retrieve missing elements from a previous run of gst_parse_launch_full()
or gst_parse_launchv_full(). Will only return results if an error code
of %GST_PARSE_ERROR_NO_SUCH_ELEMENT was returned.
NULL-terminated array of element factory name strings of missing
elements. Free with g_strfreev() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
    </record>
    <enumeration name="ParseError"
                 c:type="GstParseError"
                 glib:error-quark="gst_parse_error_quark">
      <doc xml:whitespace="preserve">The different parsing errors that can occur.</doc>
      <member name="syntax" value="0" c:identifier="GST_PARSE_ERROR_SYNTAX"/>
      <member name="no_such_element"
              value="1"
              c:identifier="GST_PARSE_ERROR_NO_SUCH_ELEMENT"/>
      <member name="no_such_property"
              value="2"
              c:identifier="GST_PARSE_ERROR_NO_SUCH_PROPERTY"/>
      <member name="link" value="3" c:identifier="GST_PARSE_ERROR_LINK"/>
      <member name="could_not_set_property"
              value="4"
              c:identifier="GST_PARSE_ERROR_COULD_NOT_SET_PROPERTY"/>
      <member name="empty_bin"
              value="5"
              c:identifier="GST_PARSE_ERROR_EMPTY_BIN"/>
      <member name="empty" value="6" c:identifier="GST_PARSE_ERROR_EMPTY"/>
    </enumeration>
    <bitfield name="ParseFlags" version="0.10.20" c:type="GstParseFlags">
      <doc xml:whitespace="preserve">Parsing options.</doc>
      <member name="none" value="0" c:identifier="GST_PARSE_FLAG_NONE"/>
      <member name="fatal_errors"
              value="1"
              c:identifier="GST_PARSE_FLAG_FATAL_ERRORS"/>
    </bitfield>
    <class name="Pipeline"
           c:symbol-prefix="pipeline"
           c:type="GstPipeline"
           parent="Bin"
           glib:type-name="GstPipeline"
           glib:get-type="gst_pipeline_get_type"
           glib:type-struct="PipelineClass">
      <doc xml:whitespace="preserve">A #GstPipeline is a special #GstBin used as the toplevel container for
the filter graph. The #GstPipeline will manage the selection and
distribution of a global #GstClock as well as provide a #GstBus to the
application. It will also implement a default behavour for managing
seek events (see gst_element_seek()).
gst_pipeline_new() is used to create a pipeline. when you are done with
the pipeline, use gst_object_unref() to free its resources including all
added #GstElement objects (if not otherwise referenced).
Elements are added and removed from the pipeline using the #GstBin
methods like gst_bin_add() and gst_bin_remove() (see #GstBin).
Before changing the state of the #GstPipeline (see #GstElement) a #GstBus
can be retrieved with gst_pipeline_get_bus(). This bus can then be
used to receive #GstMessage from the elements in the pipeline.
By default, a #GstPipeline will automatically flush the pending #GstBus
messages when going to the NULL state to ensure that no circular
references exist when no messages are read from the #GstBus. This
behaviour can be changed with gst_pipeline_set_auto_flush_bus().
When the #GstPipeline performs the PAUSED to PLAYING state change it will
select a clock for the elements. The clock selection algorithm will by
default select a clock provided by an element that is most upstream
(closest to the source). For live pipelines (ones that return
#GST_STATE_CHANGE_NO_PREROLL from the gst_element_set_state() call) this
will select the clock provided by the live source. For normal pipelines
this will select a clock provided by the sinks (most likely the audio
sink). If no element provides a clock, a default #GstSystemClock is used.
The clock selection can be controlled with the gst_pipeline_use_clock()
method, which will enforce a given clock on the pipeline. With
gst_pipeline_auto_clock() the default clock selection algorithm can be
restored.
A #GstPipeline maintains a running time for the elements. The running
time is defined as the difference between the current clock time and
the base time. When the pipeline goes to READY or a flushing seek is
performed on it, the running time is reset to 0. When the pipeline is
set from PLAYING to PAUSED, the current clock time is sampled and used to
configure the base time for the elements when the pipeline is set
to PLAYING again. The effect is that the running time (as the difference
between the clock time and the base time) will count how much time was spent
in the PLAYING state. This default behaviour can be changed with the
gst_element_set_start_time() method.
When sending a flushing seek event to a GstPipeline (see
gst_element_seek()), it will make sure that the pipeline is properly
PAUSED and resumed as well as set the new running time to 0 when the
seek succeeded.
Last reviewed on 2009-05-29 (0.10.24)</doc>
      <implements name="ChildProxy"/>
      <constructor name="new" c:identifier="gst_pipeline_new">
        <doc xml:whitespace="preserve">Create a new pipeline with the given name.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">newly created GstPipeline</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new pipeline</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="auto_clock" c:identifier="gst_pipeline_auto_clock">
        <doc xml:whitespace="preserve">Let @pipeline select a clock automatically. This is the default
behaviour.
Use this function if you previous forced a fixed clock with
gst_pipeline_use_clock() and want to restore the default
pipeline clock selection algorithm.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_auto_flush_bus"
              c:identifier="gst_pipeline_get_auto_flush_bus"
              version="0.10.4">
        <doc xml:whitespace="preserve">Check if @pipeline will automatically flush messages when going to
the NULL state.
going from READY to NULL state or not.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the pipeline will automatically flush its bus when</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_bus" c:identifier="gst_pipeline_get_bus">
        <doc xml:whitespace="preserve">Gets the #GstBus of @pipeline. The bus allows applications to receive
#GstMessage packets.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstBus, unref after usage.</doc>
          <type name="Bus" c:type="GstBus*"/>
        </return-value>
      </method>
      <method name="get_clock" c:identifier="gst_pipeline_get_clock">
        <doc xml:whitespace="preserve">Gets the current clock used by @pipeline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstClock, unref after usage.</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </method>
      <method name="get_delay"
              c:identifier="gst_pipeline_get_delay"
              version="0.10.5">
        <doc xml:whitespace="preserve">Get the configured delay (see gst_pipeline_set_delay()).
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The configured delay.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_last_stream_time"
              c:identifier="gst_pipeline_get_last_stream_time"
              deprecated="This function has the wrong name and is equivalent to">
        <doc xml:whitespace="preserve">Gets the last running time of @pipeline. If the pipeline is PLAYING,
the returned time is the running time used to configure the element's
base time in the PAUSED-&gt;PLAYING state. If the pipeline is PAUSED, the
returned time is the running time when the pipeline was paused.
This function returns #GST_CLOCK_TIME_NONE if the pipeline was
configured to not handle the management of the element's base time
(see gst_pipeline_set_new_stream_time()).
MT safe.
gst_element_get_start_time().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstClockTime.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="set_auto_flush_bus"
              c:identifier="gst_pipeline_set_auto_flush_bus"
              version="0.10.4">
        <doc xml:whitespace="preserve">Usually, when a pipeline goes from READY to NULL state, it automatically
flushes all pending messages on the bus, which is done for refcounting
purposes, to break circular references.
This means that applications that update state using (async) bus messages
(e.g. do certain things when a pipeline goes from PAUSED to READY) might
not get to see messages when the pipeline is shut down, because they might
be flushed before they can be dispatched in the main thread. This behaviour
can be disabled using this function.
It is important that all messages on the bus are handled when the
automatic flushing is disabled else memory leaks will be introduced.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="auto_flush" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether or not to automatically flush the bus when the pipeline goes from READY to NULL state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_clock" c:identifier="gst_pipeline_set_clock">
        <doc xml:whitespace="preserve">Set the clock for @pipeline. The clock will be distributed
to all the elements managed by the pipeline.
some element did not accept the clock.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the clock could be set on the pipeline. FALSE if</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the clock to set</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delay"
              c:identifier="gst_pipeline_set_delay"
              version="0.10.5">
        <doc xml:whitespace="preserve">Set the expected delay needed for all elements to perform the
PAUSED to PLAYING state change. @delay will be added to the
base time of the elements so that they wait an additional @delay
amount of time before starting to process buffers and cannot be
#GST_CLOCK_TIME_NONE.
This option is used for tuning purposes and should normally not be
used.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="delay" transfer-ownership="none">
            <doc xml:whitespace="preserve">the delay</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_new_stream_time"
              c:identifier="gst_pipeline_set_new_stream_time"
              deprecated="This function has the wrong name and is equivalent to">
        <doc xml:whitespace="preserve">Set the new start time of @pipeline to @time. The start time is used to
set the base time on the elements (see gst_element_set_base_time())
in the PAUSED-&gt;PLAYING state transition.
Setting @time to #GST_CLOCK_TIME_NONE will disable the pipeline's management
of element base time. The application will then be responsible for
performing base time distribution. This is sometimes useful if you want to
synchronize capture from multiple pipelines, and you can also ensure that the
pipelines have the same clock.
MT safe.
gst_element_set_start_time().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new running time to set</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="use_clock" c:identifier="gst_pipeline_use_clock">
        <doc xml:whitespace="preserve">Force @pipeline to use the given @clock. The pipeline will
always use the given clock even if new clock providers are added
to this pipeline.
If @clock is NULL all clocking will be disabled which will make
the pipeline run as fast as possible.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the clock to use</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </method>
      <property name="auto-flush-bus"
                version="0.10.4"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether or not to automatically flush all messages on the
pipeline's bus when going from READY to NULL state. Please see
gst_pipeline_set_auto_flush_bus() for more information on this option.</doc>
        <type name="gboolean"/>
      </property>
      <property name="delay"
                version="0.10.5"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The expected delay needed for elements to spin up to the
PLAYING state expressed in nanoseconds.
see gst_pipeline_set_delay() for more information on this option.</doc>
        <type name="guint64"/>
      </property>
      <field name="bin">
        <type name="Bin" c:type="GstBin"/>
      </field>
      <field name="fixed_clock">
        <type name="Clock" c:type="GstClock*"/>
      </field>
      <field name="stream_time">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="delay">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PipelinePrivate" c:type="GstPipelinePrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="PipelineClass"
            c:type="GstPipelineClass"
            glib:is-gtype-struct-for="Pipeline">
      <field name="parent_class">
        <type name="BinClass" c:type="GstBinClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="PipelineFlags" c:type="GstPipelineFlags">
      <doc xml:whitespace="preserve">Pipeline flags</doc>
      <member name="fixed_clock"
              value="33554432"
              c:identifier="GST_PIPELINE_FLAG_FIXED_CLOCK"/>
      <member name="last"
              value="536870912"
              c:identifier="GST_PIPELINE_FLAG_LAST"/>
    </bitfield>
    <record name="PipelinePrivate" c:type="GstPipelinePrivate" disguised="1">
    </record>
    <class name="Plugin"
           c:symbol-prefix="plugin"
           c:type="GstPlugin"
           parent="Object"
           glib:type-name="GstPlugin"
           glib:get-type="gst_plugin_get_type"
           glib:type-struct="PluginClass">
      <doc xml:whitespace="preserve">GStreamer is extensible, so #GstElement instances can be loaded at runtime.
A plugin system can provide one or more of the basic
&lt;application&gt;GStreamer&lt;/application&gt; #GstPluginFeature subclasses.
A plugin should export a symbol &lt;symbol&gt;gst_plugin_desc&lt;/symbol&gt; that is a
struct of type #GstPluginDesc.
the plugin loader will check the version of the core library the plugin was
linked against and will create a new #GstPlugin. It will then call the
#GstPluginInitFunc function that was provided in the
&lt;symbol&gt;gst_plugin_desc&lt;/symbol&gt;.
Once you have a handle to a #GstPlugin (e.g. from the #GstRegistry), you
can add any object that subclasses #GstPluginFeature.
Usually plugins are always automaticlly loaded so you don't need to call
gst_plugin_load() explicitly to bring it into memory. There are options to
statically link plugins to an app or even use GStreamer without a plugin
repository in which case gst_plugin_load() can be needed to bring the plugin
into memory.</doc>
      <function name="error_quark" c:identifier="gst_plugin_error_quark">
        <doc xml:whitespace="preserve">Get the error quark.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The error quark used in GError messages</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="list_free" c:identifier="gst_plugin_list_free">
        <doc xml:whitespace="preserve">Unrefs each member of @list, then frees the list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">list of #GstPlugin</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Plugin"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="load_by_name" c:identifier="gst_plugin_load_by_name">
        <doc xml:whitespace="preserve">Load the named plugin. Refs the plugin.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a loaded plugin, or NULL on error.</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of plugin to load</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="load_file"
                c:identifier="gst_plugin_load_file"
                throws="1">
        <doc xml:whitespace="preserve">Loads the given plugin and refs it.  Caller needs to unref after use.
reference to the newly-loaded GstPlugin, or NULL if an error occurred.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to the existing loaded GstPlugin, a</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">the plugin filename to load</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register_static"
                c:identifier="gst_plugin_register_static"
                version="0.10.16">
        <doc xml:whitespace="preserve">Registers a static plugin, ie. a plugin which is private to an application
or library and contained within the application or library (as opposed to
being shipped as a separate module file).
You must make sure that GStreamer has been initialised (with gst_init() or
via gst_init_get_option_group()) before calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the plugin was registered correctly, otherwise FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="major_version" transfer-ownership="none">
            <doc xml:whitespace="preserve">the major version number of the GStreamer core that the plugin was compiled for, you can just use GST_VERSION_MAJOR here</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minor_version" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minor version number of the GStreamer core that the plugin was compiled for, you can just use GST_VERSION_MINOR here</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a unique name of the plugin (ideally prefixed with an application- or library-specific namespace prefix in order to avoid name conflicts in case a similar plugin with the same name ever gets added to GStreamer)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:whitespace="preserve">description of the plugin</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="init_func" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">pointer to the init function of this plugin.</doc>
            <type name="PluginInitFunc" c:type="GstPluginInitFunc"/>
          </parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:whitespace="preserve">version string of the plugin</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="license" transfer-ownership="none">
            <doc xml:whitespace="preserve">effective license of plugin. Must be one of the approved licenses (see #GstPluginDesc above) or the plugin will not be registered.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">source module plugin belongs to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="package" transfer-ownership="none">
            <doc xml:whitespace="preserve">shipped package plugin belongs to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="origin" transfer-ownership="none">
            <doc xml:whitespace="preserve">URL to provider of plugin</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register_static_full"
                c:identifier="gst_plugin_register_static_full"
                version="0.10.24">
        <doc xml:whitespace="preserve">Registers a static plugin, ie. a plugin which is private to an application
or library and contained within the application or library (as opposed to
being shipped as a separate module file) with a #GstPluginInitFullFunc
which allows user data to be passed to the callback function (useful
for bindings).
You must make sure that GStreamer has been initialised (with gst_init() or
via gst_init_get_option_group()) before calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the plugin was registered correctly, otherwise FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="major_version" transfer-ownership="none">
            <doc xml:whitespace="preserve">the major version number of the GStreamer core that the plugin was compiled for, you can just use GST_VERSION_MAJOR here</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minor_version" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minor version number of the GStreamer core that the plugin was compiled for, you can just use GST_VERSION_MINOR here</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a unique name of the plugin (ideally prefixed with an application- or library-specific namespace prefix in order to avoid name conflicts in case a similar plugin with the same name ever gets added to GStreamer)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:whitespace="preserve">description of the plugin</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="init_full_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="10">
            <doc xml:whitespace="preserve">pointer to the init function with user data of this plugin.</doc>
            <type name="PluginInitFullFunc" c:type="GstPluginInitFullFunc"/>
          </parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:whitespace="preserve">version string of the plugin</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="license" transfer-ownership="none">
            <doc xml:whitespace="preserve">effective license of plugin. Must be one of the approved licenses (see #GstPluginDesc above) or the plugin will not be registered.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">source module plugin belongs to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="package" transfer-ownership="none">
            <doc xml:whitespace="preserve">shipped package plugin belongs to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="origin" transfer-ownership="none">
            <doc xml:whitespace="preserve">URL to provider of plugin</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">gpointer to user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_dependency"
              c:identifier="gst_plugin_add_dependency"
              version="0.10.22">
        <doc xml:whitespace="preserve">Make GStreamer aware of external dependencies which affect the feature
set of this plugin (ie. the elements or typefinders associated with it).
GStreamer will re-inspect plugins with external dependencies whenever any
of the external dependencies change. This is useful for plugins which wrap
other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
library and makes visualisations available as GStreamer elements, or a
codec loader which exposes elements and/or caps dependent on what external
codec libraries are currently installed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="env_vars" transfer-ownership="none">
            <doc xml:whitespace="preserve">NULL-terminated array of environent variables affecting the feature set of the plugin (e.g. an environment variable containing paths where to look for additional modules/plugins of a library), or NULL. Environment variable names may be followed by a path component which will be added to the content of the environment variable, e.g. "HOME/.mystuff/plugins".</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="paths" transfer-ownership="none">
            <doc xml:whitespace="preserve">NULL-terminated array of directories/paths where dependent files may be.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="names" transfer-ownership="none">
            <doc xml:whitespace="preserve">NULL-terminated array of file names (or file name suffixes, depending on @flags) to be used in combination with the paths from</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">optional flags, or #GST_PLUGIN_DEPENDENCY_FLAG_NONE</doc>
            <type name="PluginDependencyFlags"
                  c:type="GstPluginDependencyFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dependency_simple"
              c:identifier="gst_plugin_add_dependency_simple"
              version="0.10.22">
        <doc xml:whitespace="preserve">Make GStreamer aware of external dependencies which affect the feature
set of this plugin (ie. the elements or typefinders associated with it).
GStreamer will re-inspect plugins with external dependencies whenever any
of the external dependencies change. This is useful for plugins which wrap
other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
library and makes visualisations available as GStreamer elements, or a
codec loader which exposes elements and/or caps dependent on what external
codec libraries are currently installed.
Convenience wrapper function for gst_plugin_add_dependency() which
takes simple strings as arguments instead of string arrays, with multiple
arguments separated by predefined delimiters (see above).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="env_vars" transfer-ownership="none">
            <doc xml:whitespace="preserve">one or more environent variables (separated by ':', ';' or ','), or NULL. Environment variable names may be followed by a path component which will be added to the content of the environment variable, e.g. "HOME/.mystuff/plugins:MYSTUFF_PLUGINS_PATH"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="paths" transfer-ownership="none">
            <doc xml:whitespace="preserve">one ore more directory paths (separated by ':' or ';' or ','), or NULL. Example: "/usr/lib/mystuff/plugins"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="names" transfer-ownership="none">
            <doc xml:whitespace="preserve">one or more file names or file name suffixes (separated by commas), or NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">optional flags, or #GST_PLUGIN_DEPENDENCY_FLAG_NONE</doc>
            <type name="PluginDependencyFlags"
                  c:type="GstPluginDependencyFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cache_data"
              c:identifier="gst_plugin_get_cache_data"
              version="0.10.24">
        <doc xml:whitespace="preserve">Gets the plugin specific data cache. If it is %NULL there is no cached data
stored. This is the case when the registry is getting rebuilt.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The cached data as a #GstStructure or %NULL.</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
      </method>
      <method name="get_description" c:identifier="gst_plugin_get_description">
        <doc xml:whitespace="preserve">Get the long descriptive name of the plugin</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the long name of the plugin</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_filename" c:identifier="gst_plugin_get_filename">
        <doc xml:whitespace="preserve">get the filename of the plugin</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the filename of the plugin</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_license" c:identifier="gst_plugin_get_license">
        <doc xml:whitespace="preserve">get the license of the plugin</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the license of the plugin</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_module" c:identifier="gst_plugin_get_module">
        <doc xml:whitespace="preserve">Gets the #GModule of the plugin. If the plugin isn't loaded yet, NULL is
returned.
plugin isn't loaded yet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">module belonging to the plugin or NULL if the</doc>
          <type name="GModule.Module" c:type="GModule*"/>
        </return-value>
      </method>
      <method name="get_name" c:identifier="gst_plugin_get_name">
        <doc xml:whitespace="preserve">Get the short name of the plugin</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the plugin</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_origin" c:identifier="gst_plugin_get_origin">
        <doc xml:whitespace="preserve">get the URL where the plugin comes from</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the origin of the plugin</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_package" c:identifier="gst_plugin_get_package">
        <doc xml:whitespace="preserve">get the package the plugin belongs to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the package of the plugin</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_source" c:identifier="gst_plugin_get_source">
        <doc xml:whitespace="preserve">get the source module the plugin belongs to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the source of the plugin</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_version" c:identifier="gst_plugin_get_version">
        <doc xml:whitespace="preserve">get the version of the plugin</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the version of the plugin</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="is_loaded" c:identifier="gst_plugin_is_loaded">
        <doc xml:whitespace="preserve">queries if the plugin is loaded into memory</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE is loaded, FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="load" c:identifier="gst_plugin_load">
        <doc xml:whitespace="preserve">Loads @plugin. Note that the *return value* is the loaded plugin; @plugin is
untouched. The normal use pattern of this function goes like this:
&lt;programlisting&gt;
GstPlugin *loaded_plugin;
loaded_plugin = gst_plugin_load (plugin);
// presumably, we're no longer interested in the potentially-unloaded plugin
gst_object_unref (plugin);
plugin = loaded_plugin;
&lt;/programlisting&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a loaded plugin, or NULL on error.</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </return-value>
      </method>
      <method name="name_filter" c:identifier="gst_plugin_name_filter">
        <doc xml:whitespace="preserve">A standard filter that returns TRUE when the plugin is of the
given name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the plugin is of the given name.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the plugin</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cache_data"
              c:identifier="gst_plugin_set_cache_data"
              version="0.10.24">
        <doc xml:whitespace="preserve">Adds plugin specific data to cache. Passes the ownership of the structure to
the @plugin.
The cache is flushed every time the registry is rebuilt.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cache_data" transfer-ownership="full">
            <doc xml:whitespace="preserve">a structure containing the data to cache</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="desc" readable="0" private="1">
        <type name="PluginDesc" c:type="GstPluginDesc"/>
      </field>
      <field name="orig_desc" readable="0" private="1">
        <type name="PluginDesc" c:type="GstPluginDesc*"/>
      </field>
      <field name="flags" readable="0" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="filename" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="basename" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="module" readable="0" private="1">
        <type name="GModule.Module" c:type="GModule*"/>
      </field>
      <field name="file_size" readable="0" private="1">
        <type name="gsize" c:type="off_t"/>
      </field>
      <field name="file_mtime" readable="0" private="1">
        <type name="glong" c:type="time_t"/>
      </field>
      <field name="registered" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PluginPrivate" c:type="GstPluginPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="PluginClass"
            c:type="GstPluginClass"
            glib:is-gtype-struct-for="Plugin">
      <field name="object_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="PluginDependencyFlags"
              version="0.10.22"
              c:type="GstPluginDependencyFlags">
      <doc xml:whitespace="preserve">Flags used in connection with gst_plugin_add_dependency().</doc>
      <member name="none"
              value="0"
              c:identifier="GST_PLUGIN_DEPENDENCY_FLAG_NONE"/>
      <member name="recurse"
              value="1"
              c:identifier="GST_PLUGIN_DEPENDENCY_FLAG_RECURSE"/>
      <member name="paths_are_default_only"
              value="2"
              c:identifier="GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY"/>
      <member name="file_name_is_suffix"
              value="4"
              c:identifier="GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX"/>
    </bitfield>
    <record name="PluginDesc" c:type="GstPluginDesc">
      <doc xml:whitespace="preserve">A plugin should export a variable of this type called plugin_desc. The plugin
loader will use the data provided there to initialize the plugin.
BSD, MIT/X11, Proprietary, unknown.</doc>
      <field name="major_version" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="minor_version" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="plugin_init" writable="1">
        <type name="PluginInitFunc" c:type="GstPluginInitFunc"/>
      </field>
      <field name="version" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="license" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="source" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="package" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="origin" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="release_datetime" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="PluginError" c:type="GstPluginError">
      <doc xml:whitespace="preserve">The plugin loading errors</doc>
      <member name="module" value="0" c:identifier="GST_PLUGIN_ERROR_MODULE"/>
      <member name="dependencies"
              value="1"
              c:identifier="GST_PLUGIN_ERROR_DEPENDENCIES"/>
      <member name="name_mismatch"
              value="2"
              c:identifier="GST_PLUGIN_ERROR_NAME_MISMATCH"/>
    </enumeration>
    <class name="PluginFeature"
           c:symbol-prefix="plugin_feature"
           c:type="GstPluginFeature"
           parent="Object"
           abstract="1"
           glib:type-name="GstPluginFeature"
           glib:get-type="gst_plugin_feature_get_type"
           glib:type-struct="PluginFeatureClass">
      <doc xml:whitespace="preserve">This is a base class for anything that can be added to a #GstPlugin.</doc>
      <function name="list_copy"
                c:identifier="gst_plugin_feature_list_copy"
                version="0.10.26">
        <doc xml:whitespace="preserve">Copies the list of features. Caller should call @gst_plugin_feature_list_free
when done with the list.
with each feature's reference count incremented.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a copy of @list,</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="PluginFeature"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">list of #GstPluginFeature</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="PluginFeature"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="list_debug"
                c:identifier="gst_plugin_feature_list_debug"
                version="0.10.31">
        <doc xml:whitespace="preserve">Debug the plugin feature names in @list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of plugin features</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="PluginFeature"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="list_free" c:identifier="gst_plugin_feature_list_free">
        <doc xml:whitespace="preserve">Unrefs each member of @list, then frees the list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">list of #GstPluginFeature</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="PluginFeature"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="rank_compare_func"
                c:identifier="gst_plugin_feature_rank_compare_func"
                version="0.10.31">
        <doc xml:whitespace="preserve">Compares the two given #GstPluginFeature instances. This function can be
used as a #GCompareFunc when sorting by rank and then by name.
equal but the name of p1 comes before the name of p2; zero if the rank
and names are equal; positive value if the rank of p1 &lt; the rank of p2 or the
ranks are equal but the name of p2 comes after the name of p1</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">negative value if the rank of p1 &gt; the rank of p2 or the ranks are</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPluginFeature</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPluginFeature</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="check_version"
              c:identifier="gst_plugin_feature_check_version">
        <doc xml:whitespace="preserve">Checks whether the given plugin feature is at least
the required version
the required version, otherwise #FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if the plugin feature has at least</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="min_major" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum required major version</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="min_minor" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum required minor version</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="min_micro" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum required micro version</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="gst_plugin_feature_get_name">
        <doc xml:whitespace="preserve">Gets the name of a plugin feature.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_rank" c:identifier="gst_plugin_feature_get_rank">
        <doc xml:whitespace="preserve">Gets the rank of a plugin feature.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The rank of the feature</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="load" c:identifier="gst_plugin_feature_load">
        <doc xml:whitespace="preserve">Loads the plugin containing @feature if it's not already loaded. @feature is
unaffected; use the return value instead.
Normally this function is used like this:
|[
GstPluginFeature *loaded_feature;
loaded_feature = gst_plugin_feature_load (feature);
// presumably, we're no longer interested in the potentially-unloaded feature
gst_object_unref (feature);
feature = loaded_feature;
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to the loaded feature, or NULL on error</doc>
          <type name="PluginFeature" c:type="GstPluginFeature*"/>
        </return-value>
      </method>
      <method name="set_name" c:identifier="gst_plugin_feature_set_name">
        <doc xml:whitespace="preserve">Sets the name of a plugin feature. The name uniquely identifies a feature
within all features of the same type. Renaming a plugin feature is not
allowed. A copy is made of the name so you should free the supplied @name
after calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_rank" c:identifier="gst_plugin_feature_set_rank">
        <doc xml:whitespace="preserve">Specifies a rank for a plugin feature, so that autoplugging uses
the most appropriate feature.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="rank" transfer-ownership="none">
            <doc xml:whitespace="preserve">rank value - higher number means more priority rank</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="type_name_filter"
              c:identifier="gst_plugin_feature_type_name_filter">
        <doc xml:whitespace="preserve">Compares type and name of plugin feature. Can be used with gst_filter_run().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type and name to check against</doc>
            <type name="TypeNameData" c:type="GstTypeNameData*"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="loaded" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="name" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="rank" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="plugin_name" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="plugin" readable="0" private="1">
        <type name="Plugin" c:type="GstPlugin*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="PluginFeatureClass"
            c:type="GstPluginFeatureClass"
            glib:is-gtype-struct-for="PluginFeature">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="PluginFeatureFilter" c:type="GstPluginFeatureFilter">
      <doc xml:whitespace="preserve">A function that can be used with e.g. gst_registry_feature_filter()
to get a list of pluginfeature that match certain criteria.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE for a positive match, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="feature" transfer-ownership="none">
          <doc xml:whitespace="preserve">the pluginfeature to check</doc>
          <type name="PluginFeature" c:type="GstPluginFeature*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">the user_data that has been passed on e.g. gst_registry_feature_filter()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PluginFilter" c:type="GstPluginFilter">
      <doc xml:whitespace="preserve">A function that can be used with e.g. gst_registry_plugin_filter()
to get a list of plugins that match certain criteria.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE for a positive match, FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">the plugin to check</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">the user_data that has been passed on e.g. gst_registry_plugin_filter()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="PluginFlags" c:type="GstPluginFlags">
      <doc xml:whitespace="preserve">The plugin loading state</doc>
      <member name="cached" value="1" c:identifier="GST_PLUGIN_FLAG_CACHED"/>
      <member name="blacklisted"
              value="2"
              c:identifier="GST_PLUGIN_FLAG_BLACKLISTED"/>
    </bitfield>
    <callback name="PluginInitFullFunc"
              c:type="GstPluginInitFullFunc"
              version="0.10.24">
      <doc xml:whitespace="preserve">A plugin should provide a pointer to a function of either #GstPluginInitFunc
or this type in the plugin_desc struct.
The function will be called by the loader at startup. One would then
register each #GstPluginFeature. This version allows
user data to be passed to init function (useful for bindings).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if plugin initialised successfully</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">The plugin object</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">extra data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PluginInitFunc" c:type="GstPluginInitFunc">
      <doc xml:whitespace="preserve">A plugin should provide a pointer to a function of this type in the
plugin_desc struct.
This function will be called by the loader at startup. One would then
register each #GstPluginFeature.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if plugin initialised successfully</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">The plugin object</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PluginPrivate" c:type="GstPluginPrivate" disguised="1">
    </record>
    <record name="Poll" c:type="GstPoll" disguised="1">
      <doc xml:whitespace="preserve">A #GstPoll keeps track of file descriptors much like fd_set (used with
select()) or a struct pollfd array (used with poll()). Once created with
gst_poll_new(), the set can be used to wait for file descriptors to be
readable and/or writeable. It is possible to make this wait be controlled
by specifying %TRUE for the @controllable flag when creating the set (or
later calling gst_poll_set_controllable()).
New file descriptors are added to the set using gst_poll_add_fd(), and
removed using gst_poll_remove_fd(). Controlling which file descriptors
should be waited for to become readable and/or writeable are done using
gst_poll_fd_ctl_read() and gst_poll_fd_ctl_write().
Use gst_poll_wait() to wait for the file descriptors to actually become
readable and/or writeable, or to timeout if no file descriptor is available
in time. The wait can be controlled by calling gst_poll_restart() and
gst_poll_set_flushing().
Once the file descriptor set has been waited for, one can use
gst_poll_fd_has_closed() to see if the file descriptor has been closed,
gst_poll_fd_has_error() to see if it has generated an error,
gst_poll_fd_can_read() to see if it is possible to read from the file
descriptor, and gst_poll_fd_can_write() to see if it is possible to
write to it.</doc>
      <method name="add_fd" c:identifier="gst_poll_add_fd" version="0.10.18">
        <doc xml:whitespace="preserve">Add a file descriptor to the file descriptor set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file descriptor was successfully added to the set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_can_read"
              c:identifier="gst_poll_fd_can_read"
              version="0.10.18">
        <doc xml:whitespace="preserve">Check if @fd in @set has data to be read.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the descriptor has data to be read.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_can_write"
              c:identifier="gst_poll_fd_can_write"
              version="0.10.18">
        <doc xml:whitespace="preserve">Check if @fd in @set can be used for writing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the descriptor can be used for writing.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_ctl_read"
              c:identifier="gst_poll_fd_ctl_read"
              version="0.10.18">
        <doc xml:whitespace="preserve">Control whether the descriptor @fd in @set will be monitored for
readability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the descriptor was successfully updated.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new status.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_ctl_write"
              c:identifier="gst_poll_fd_ctl_write"
              version="0.10.18">
        <doc xml:whitespace="preserve">Control whether the descriptor @fd in @set will be monitored for
writability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the descriptor was successfully updated.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new status.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_has_closed"
              c:identifier="gst_poll_fd_has_closed"
              version="0.10.18">
        <doc xml:whitespace="preserve">Check if @fd in @set has closed the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection was closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_has_error"
              c:identifier="gst_poll_fd_has_error"
              version="0.10.18">
        <doc xml:whitespace="preserve">Check if @fd in @set has an error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the descriptor has an error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_ignored"
              c:identifier="gst_poll_fd_ignored"
              version="0.10.18">
        <doc xml:whitespace="preserve">Mark @fd as ignored so that the next call to gst_poll_wait() will yield
the same result for @fd as last time. This function must be called if no
operation (read/write/recv/send/etc.) will be performed on @fd before
the next call to gst_poll_wait().
The reason why this is needed is because the underlying implementation
might not allow querying the fd more than once between calls to one of
the re-enabling operations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_poll_free" version="0.10.18">
        <doc xml:whitespace="preserve">Free a file descriptor set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_read_gpollfd"
              c:identifier="gst_poll_get_read_gpollfd"
              version="0.10.32">
        <doc xml:whitespace="preserve">Get a GPollFD for the reading part of the control socket. This is useful when
integrating with a GSource and GMainLoop.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPollFD</doc>
            <type name="GLib.PollFD" c:type="GPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_control"
              c:identifier="gst_poll_read_control"
              version="0.10.23">
        <doc xml:whitespace="preserve">Read a byte from the control socket of the controllable @set.
This function is mostly useful for timer #GstPoll objects created with
gst_poll_new_timer(). 
was no byte to read.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success. %FALSE when @set is not controllable or when there</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="remove_fd"
              c:identifier="gst_poll_remove_fd"
              version="0.10.18">
        <doc xml:whitespace="preserve">Remove a file descriptor from the file descriptor set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file descriptor was successfully removed from the set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="restart" c:identifier="gst_poll_restart" version="0.10.18">
        <doc xml:whitespace="preserve">Restart any gst_poll_wait() that is in progress. This function is typically
used after adding or removing descriptors to @set.
If @set is not controllable, then this call will have no effect.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_controllable"
              c:identifier="gst_poll_set_controllable"
              version="0.10.18">
        <doc xml:whitespace="preserve">When @controllable is %TRUE, this function ensures that future calls to
gst_poll_wait() will be affected by gst_poll_restart() and
gst_poll_set_flushing().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the controllability of @set could be updated.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="controllable" transfer-ownership="none">
            <doc xml:whitespace="preserve">new controllable state.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing"
              c:identifier="gst_poll_set_flushing"
              version="0.10.18">
        <doc xml:whitespace="preserve">When @flushing is %TRUE, this function ensures that current and future calls
to gst_poll_wait() will return -1, with errno set to EBUSY.
Unsetting the flushing state will restore normal operation of @set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:whitespace="preserve">new flushing state.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait" c:identifier="gst_poll_wait" version="0.10.18">
        <doc xml:whitespace="preserve">Wait for activity on the file descriptors in @set. This function waits up to
the specified @timeout.  A timeout of #GST_CLOCK_TIME_NONE waits forever.
For #GstPoll objects created with gst_poll_new(), this function can only be
called from a single thread at a time.  If called from multiple threads,
-1 will be returned with errno set to EPERM.
This is not true for timer #GstPoll objects created with
gst_poll_new_timer(), where it is allowed to have multiple threads waiting
simultaneously.
activity was detected after @timeout. If an error occurs, -1 is returned
and errno is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of #GstPollFD in @set that have activity or 0 when no</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">a timeout in nanoseconds.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_control"
              c:identifier="gst_poll_write_control"
              version="0.10.23">
        <doc xml:whitespace="preserve">Write a byte to the control socket of the controllable @set.
This function is mostly useful for timer #GstPoll objects created with
gst_poll_new_timer(). 
It will make any current and future gst_poll_wait() function return with
1, meaning the control socket is set. After an equal amount of calls to
gst_poll_read_control() have been performed, calls to gst_poll_wait() will
block again until their timeout expired.
byte could not be written.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success. %FALSE when @set is not controllable or when the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </record>
    <record name="PollFD" c:type="GstPollFD">
      <doc xml:whitespace="preserve">A file descriptor object.</doc>
      <field name="fd" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="idx" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <method name="init" c:identifier="gst_poll_fd_init" version="0.10.18">
        <doc xml:whitespace="preserve">Initializes @fd. Alternatively you can initialize it with
#GST_POLL_FD_INIT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <interface name="Preset"
               c:symbol-prefix="preset"
               c:type="GstPreset"
               glib:type-name="GstPreset"
               glib:get-type="gst_preset_get_type"
               glib:type-struct="PresetInterface">
      <doc xml:whitespace="preserve">This interface offers methods to query and manipulate parameter preset sets.
A preset is a bunch of property settings, together with meta data and a name.
The name of a preset serves as key for subsequent method calls to manipulate
single presets.
All instances of one type will share the list of presets. The list is created
on demand, if presets are not used, the list is not created.
The interface comes with a default implementation that serves most plugins.
Wrapper plugins will override most methods to implement support for the
native preset format of those wrapped plugins.
One method that is useful to be overridden is gst_preset_get_property_names().
With that one can control which properties are saved and in which order.</doc>
      <virtual-method name="delete_preset"
                      invoker="delete_preset"
                      version="0.10.20">
        <doc xml:whitespace="preserve">Delete the given preset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to remove</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_meta" invoker="get_meta" version="0.10.20">
        <doc xml:whitespace="preserve">Gets the @value for an existing meta data @tag. Meta data @tag names can be
something like e.g. "comment". Returned values need to be released when done.
or no value for the given @tag</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">meta data item name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">value</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_preset_names"
                      invoker="get_preset_names"
                      version="0.10.20">
        <doc xml:whitespace="preserve">Get a copy of preset names as a NULL terminated string array.
list with names, ue g_strfreev() after usage.</doc>
        <return-value transfer-ownership="full">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </virtual-method>
      <virtual-method name="get_property_names"
                      invoker="get_property_names"
                      version="0.10.20">
        <doc xml:whitespace="preserve">Get a the names of the GObject properties that can be used for presets.
array of property names which should be freed with g_strfreev() after use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">an</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </virtual-method>
      <virtual-method name="load_preset"
                      invoker="load_preset"
                      version="0.10.20">
        <doc xml:whitespace="preserve">Load the given preset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to load</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="rename_preset"
                      invoker="rename_preset"
                      version="0.10.20">
        <doc xml:whitespace="preserve">Renames a preset. If there is already a preset by the @new_name it will be
overwritten.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with @old_name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">current preset name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">new preset name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="save_preset"
                      invoker="save_preset"
                      version="0.10.20">
        <doc xml:whitespace="preserve">Save the current object settings as a preset under the given name. If there
is already a preset by this @name it will be overwritten.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to save</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_meta" invoker="set_meta" version="0.10.20">
        <doc xml:whitespace="preserve">Sets a new @value for an existing meta data item or adds a new item. Meta
data @tag names can be something like e.g. "comment". Supplying %NULL for the</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">meta data item name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">new value</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="delete_preset"
              c:identifier="gst_preset_delete_preset"
              version="0.10.20">
        <doc xml:whitespace="preserve">Delete the given preset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to remove</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_meta"
              c:identifier="gst_preset_get_meta"
              version="0.10.20">
        <doc xml:whitespace="preserve">Gets the @value for an existing meta data @tag. Meta data @tag names can be
something like e.g. "comment". Returned values need to be released when done.
or no value for the given @tag</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">meta data item name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">value</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_preset_names"
              c:identifier="gst_preset_get_preset_names"
              version="0.10.20">
        <doc xml:whitespace="preserve">Get a copy of preset names as a NULL terminated string array.
list with names, ue g_strfreev() after usage.</doc>
        <return-value transfer-ownership="full">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_property_names"
              c:identifier="gst_preset_get_property_names"
              version="0.10.20">
        <doc xml:whitespace="preserve">Get a the names of the GObject properties that can be used for presets.
array of property names which should be freed with g_strfreev() after use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">an</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="load_preset"
              c:identifier="gst_preset_load_preset"
              version="0.10.20">
        <doc xml:whitespace="preserve">Load the given preset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to load</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename_preset"
              c:identifier="gst_preset_rename_preset"
              version="0.10.20">
        <doc xml:whitespace="preserve">Renames a preset. If there is already a preset by the @new_name it will be
overwritten.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with @old_name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">current preset name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">new preset name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_preset"
              c:identifier="gst_preset_save_preset"
              version="0.10.20">
        <doc xml:whitespace="preserve">Save the current object settings as a preset under the given name. If there
is already a preset by this @name it will be overwritten.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to save</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_meta"
              c:identifier="gst_preset_set_meta"
              version="0.10.20">
        <doc xml:whitespace="preserve">Sets a new @value for an existing meta data item or adds a new item. Meta
data @tag names can be something like e.g. "comment". Supplying %NULL for the</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">meta data item name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">new value</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="PresetInterface"
            c:type="GstPresetInterface"
            glib:is-gtype-struct-for="Preset">
      <doc xml:whitespace="preserve">#GstPreset interface.</doc>
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_preset_names">
        <callback name="get_preset_names">
          <return-value transfer-ownership="full">
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_property_names">
        <callback name="get_property_names">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">an</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="load_preset">
        <callback name="load_preset">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">preset name to load</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="save_preset">
        <callback name="save_preset">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">preset name to save</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="rename_preset">
        <callback name="rename_preset">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with @old_name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="old_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">current preset name</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="new_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">new preset name</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_preset">
        <callback name="delete_preset">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">preset name to remove</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_meta">
        <callback name="set_meta">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">preset name</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="tag" transfer-ownership="none">
              <doc xml:whitespace="preserve">meta data item name</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:whitespace="preserve">new value</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_meta">
        <callback name="get_meta">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">preset name</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="tag" transfer-ownership="none">
              <doc xml:whitespace="preserve">meta data item name</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="value"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:whitespace="preserve">value</doc>
              <type name="utf8" c:type="gchar**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="ProgressType"
                 version="0.10.33"
                 c:type="GstProgressType">
      <doc xml:whitespace="preserve">The type of a %GST_MESSAGE_PROGRESS. The progress messages inform the
application of the status of assynchronous tasks.</doc>
      <member name="start" value="0" c:identifier="GST_PROGRESS_TYPE_START"/>
      <member name="continue"
              value="1"
              c:identifier="GST_PROGRESS_TYPE_CONTINUE"/>
      <member name="complete"
              value="2"
              c:identifier="GST_PROGRESS_TYPE_COMPLETE"/>
      <member name="canceled"
              value="3"
              c:identifier="GST_PROGRESS_TYPE_CANCELED"/>
      <member name="error" value="4" c:identifier="GST_PROGRESS_TYPE_ERROR"/>
    </enumeration>
    <class name="ProxyPad"
           c:symbol-prefix="proxy_pad"
           c:type="GstProxyPad"
           parent="Pad"
           glib:type-name="GstProxyPad"
           glib:get-type="gst_proxy_pad_get_type"
           glib:type-struct="ProxyPadClass">
      <field name="pad">
        <type name="Pad" c:type="GstPad"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProxyPadPrivate" c:type="GstProxyPadPrivate*"/>
      </field>
    </class>
    <record name="ProxyPadClass"
            c:type="GstProxyPadClass"
            glib:is-gtype-struct-for="ProxyPad">
      <field name="parent_class">
        <type name="PadClass" c:type="GstPadClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="1">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ProxyPadPrivate" c:type="GstProxyPadPrivate" disguised="1">
    </record>
    <enumeration name="QOSType" version="0.10.33" c:type="GstQOSType">
      <doc xml:whitespace="preserve">The different types of QoS events that can be given to the 
gst_event_new_qos_full() method.</doc>
      <member name="overflow" value="0" c:identifier="GST_QOS_TYPE_OVERFLOW"/>
      <member name="underflow"
              value="1"
              c:identifier="GST_QOS_TYPE_UNDERFLOW"/>
      <member name="throttle" value="2" c:identifier="GST_QOS_TYPE_THROTTLE"/>
    </enumeration>
    <class name="Query"
           c:symbol-prefix="query"
           c:type="GstQuery"
           parent="MiniObject"
           glib:type-name="GstQuery"
           glib:get-type="gst_query_get_type"
           glib:type-struct="QueryClass"
           glib:fundamental="1">
      <doc xml:whitespace="preserve">GstQuery functions are used to register new query types to the gstreamer
core and use them.
Queries can be performed on pads (gst_pad_query()) and elements
(gst_element_query()). Please note that some queries might need a running
pipeline to work.
Queries can be created using the gst_query_new_*() functions.
Query values can be set using gst_query_set_*(), and parsed using
gst_query_parse_*() helpers.
The following example shows how to query the duration of a pipeline:
&lt;example&gt;
&lt;title&gt;Query duration on a pipeline&lt;/title&gt;
&lt;programlisting&gt;
GstQuery *query;
gboolean res;
query = gst_query_new_duration (GST_FORMAT_TIME);
res = gst_element_query (pipeline, query);
if (res) {
gint64 duration;
gst_query_parse_duration (query, NULL, &amp;amp;duration);
g_print ("duration = %"GST_TIME_FORMAT, GST_TIME_ARGS (duration));
}
else {
g_print ("duration query failed...");
}
gst_query_unref (query);
&lt;/programlisting&gt;
&lt;/example&gt;
Last reviewed on 2006-02-14 (0.10.4)</doc>
      <constructor name="new_application"
                   c:identifier="gst_query_new_application">
        <doc xml:whitespace="preserve">Constructs a new custom application query object. Use gst_query_unref()
when done with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the query type</doc>
            <type name="QueryType" c:type="GstQueryType"/>
          </parameter>
          <parameter name="structure" transfer-ownership="none">
            <doc xml:whitespace="preserve">a structure for the query</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_buffering"
                   c:identifier="gst_query_new_buffering"
                   version="0.10.20">
        <doc xml:whitespace="preserve">Constructs a new query object for querying the buffering status of
a stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the default #GstFormat for the new query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_convert" c:identifier="gst_query_new_convert">
        <doc xml:whitespace="preserve">Constructs a new convert query object. Use gst_query_unref()
when done with it. A convert query is used to ask for a conversion between
one format and another.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="src_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source #GstFormat for the new query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to convert</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target #GstFormat</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_duration" c:identifier="gst_query_new_duration">
        <doc xml:whitespace="preserve">Constructs a new stream duration query object to query in the given format.
Use gst_query_unref() when done with it. A duration query will give the
total length of the stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat for this duration query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_formats"
                   c:identifier="gst_query_new_formats"
                   version="0.10.4">
        <doc xml:whitespace="preserve">Constructs a new query object for querying formats of
the stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
      </constructor>
      <constructor name="new_latency"
                   c:identifier="gst_query_new_latency"
                   version="0.10.12">
        <doc xml:whitespace="preserve">Constructs a new latency query object.
Use gst_query_unref() when done with it. A latency query is usually performed
by sinks to compensate for additional latency introduced by elements in the
pipeline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
      </constructor>
      <constructor name="new_position" c:identifier="gst_query_new_position">
        <doc xml:whitespace="preserve">Constructs a new query stream position query object. Use gst_query_unref()
when done with it. A position query is used to query the current position
of playback in the streams, in some format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the default #GstFormat for the new query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_seeking" c:identifier="gst_query_new_seeking">
        <doc xml:whitespace="preserve">Constructs a new query object for querying seeking properties of
the stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the default #GstFormat for the new query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_segment" c:identifier="gst_query_new_segment">
        <doc xml:whitespace="preserve">Constructs a new segment query object. Use gst_query_unref()
when done with it. A segment query is used to discover information about the
currently configured segment for playback.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat for the new query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_uri"
                   c:identifier="gst_query_new_uri"
                   version="0.10.22">
        <doc xml:whitespace="preserve">Constructs a new query URI query object. Use gst_query_unref()
when done with it. An URI query is used to query the current URI
that is used by the source or sink.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
      </constructor>
      <function name="type_get_by_nick"
                c:identifier="gst_query_type_get_by_nick">
        <doc xml:whitespace="preserve">Get the query type registered with @nick.
if the query was not registered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The query registered with @nick or #GST_QUERY_NONE</doc>
          <type name="QueryType" c:type="GstQueryType"/>
        </return-value>
        <parameters>
          <parameter name="nick" transfer-ownership="none">
            <doc xml:whitespace="preserve">The nick of the query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_get_details"
                c:identifier="gst_query_type_get_details">
        <doc xml:whitespace="preserve">Get details about the given #GstQueryType.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstQueryTypeDefinition for @type or NULL on failure.</doc>
          <type name="QueryTypeDefinition" c:type="GstQueryTypeDefinition*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstQueryType</doc>
            <type name="QueryType" c:type="GstQueryType"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_get_name" c:identifier="gst_query_type_get_name">
        <doc xml:whitespace="preserve">Get a printable name for the given query type. Do not modify or free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a reference to the static name of the query.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the query type</doc>
            <type name="QueryType" c:type="GstQueryType"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_iterate_definitions"
                c:identifier="gst_query_type_iterate_definitions"
                introspectable="0">
        <doc xml:whitespace="preserve">Get a #GstIterator of all the registered query types. The definitions
iterated over are read only.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstQueryTypeDefinition.</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </function>
      <function name="type_register" c:identifier="gst_query_type_register">
        <doc xml:whitespace="preserve">Create a new GstQueryType based on the nick or return an
already registered query with that nick
with the same nick.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A new GstQueryType or an already registered query</doc>
          <type name="QueryType" c:type="GstQueryType"/>
        </return-value>
        <parameters>
          <parameter name="nick" transfer-ownership="none">
            <doc xml:whitespace="preserve">The nick of the new query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:whitespace="preserve">The description of the new query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_to_quark" c:identifier="gst_query_type_to_quark">
        <doc xml:whitespace="preserve">Get the unique quark for the given query type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark associated with the query type</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the query type</doc>
            <type name="QueryType" c:type="GstQueryType"/>
          </parameter>
        </parameters>
      </function>
      <function name="types_contains" c:identifier="gst_query_types_contains">
        <doc xml:whitespace="preserve">See if the given #GstQueryType is inside the @types query types array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the type is found inside the array</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="types" transfer-ownership="none">
            <doc xml:whitespace="preserve">The query array to search</doc>
            <type name="QueryType" c:type="GstQueryType*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstQueryType to find</doc>
            <type name="QueryType" c:type="GstQueryType"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_buffering_range"
              c:identifier="gst_query_add_buffering_range"
              version="0.10.31">
        <doc xml:whitespace="preserve">Set the buffering-ranges array field in @query. The current last
start position of the array should be inferior to @start.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gboolean indicating if the range was added or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">start position of the range</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">stop position of the range</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_buffering_ranges"
              c:identifier="gst_query_get_n_buffering_ranges"
              version="0.10.31">
        <doc xml:whitespace="preserve">Retrieve the number of values currently stored in the
buffered-ranges array of the query's structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the range array size as a #guint.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_structure" c:identifier="gst_query_get_structure">
        <doc xml:whitespace="preserve">Get the structure of a query.
still owned by the query and will therefore be freed when the query
is unreffed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstStructure of the query. The structure is</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
      </method>
      <method name="parse_buffering_percent"
              c:identifier="gst_query_parse_buffering_percent"
              version="0.10.20">
        <doc xml:whitespace="preserve">Get the percentage of buffered data. This is a value between 0 and 100.
The @busy indicator is %TRUE when the buffering is in progress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="busy"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">if buffering is busy, or NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="percent"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a buffering percent, or NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_buffering_range"
              c:identifier="gst_query_parse_buffering_range"
              version="0.10.20">
        <doc xml:whitespace="preserve">Parse an available query, writing the format into @format, and
other results into the passed parameters, if the respective parameters
are non-NULL</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the format to set for the @segment_start and @segment_end values, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the start to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="stop"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the stop to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="estimated_total"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">estimated total amount of download time, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_buffering_stats"
              c:identifier="gst_query_parse_buffering_stats"
              version="0.10.20">
        <doc xml:whitespace="preserve">Extracts the buffering stats values from @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a buffering mode, or NULL</doc>
            <type name="BufferingMode" c:type="GstBufferingMode*"/>
          </parameter>
          <parameter name="avg_in"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the average input rate, or NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="avg_out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the average output rat, or NULLe</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="buffering_left"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">amount of buffering time left, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_convert" c:identifier="gst_query_parse_convert">
        <doc xml:whitespace="preserve">Parse a convert query answer. Any of @src_format, @src_value, @dest_format,
and @dest_value may be NULL, in which case that value is omitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="src_format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the #GstFormat of the source value, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="src_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the source value, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="dest_format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the #GstFormat of the destination value, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="dest_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the destination value, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_duration" c:identifier="gst_query_parse_duration">
        <doc xml:whitespace="preserve">Parse a duration query answer. Write the format of the duration into @format,
and the value into @duration, if the respective variables are non-NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the #GstFormat of the duration value, or NULL.</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the total duration, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_formats_length"
              c:identifier="gst_query_parse_formats_length"
              version="0.10.4">
        <doc xml:whitespace="preserve">Parse the number of formats in the formats @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_formats"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the number of formats in this query.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_formats_nth"
              c:identifier="gst_query_parse_formats_nth"
              version="0.10.4">
        <doc xml:whitespace="preserve">Parse the format query and retrieve the @nth format from it into
set to GST_FORMAT_UNDEFINED.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nth"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the nth format to retrieve.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to store the nth format</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_latency"
              c:identifier="gst_query_parse_latency"
              version="0.10.12">
        <doc xml:whitespace="preserve">Parse a latency query answer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">storage for live or NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="min_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the min latency or NULL</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the max latency or NULL</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_nth_buffering_range"
              c:identifier="gst_query_parse_nth_buffering_range"
              version="0.10.31">
        <doc xml:whitespace="preserve">Parse an available query and get the start and stop values stored
at the @index of the buffered ranges array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gboolean indicating if the parsing succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">position in the buffered-ranges array to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the start position to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="stop"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the stop position to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_position" c:identifier="gst_query_parse_position">
        <doc xml:whitespace="preserve">Parse a position query, writing the format into @format, and the position
into @cur, if the respective parameters are non-NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the #GstFormat of the position values (may be NULL)</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="cur"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the current position (may be NULL)</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_seeking" c:identifier="gst_query_parse_seeking">
        <doc xml:whitespace="preserve">Parse a seeking query, writing the format into @format, and
other results into the passed parameters, if the respective parameters
are non-NULL</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the format to set for the @segment_start and @segment_end values, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="seekable"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the seekable flag to set, or NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="segment_start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the segment_start to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="segment_end"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the segment_end to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_segment" c:identifier="gst_query_parse_segment">
        <doc xml:whitespace="preserve">Parse a segment query answer. Any of @rate, @format, @start_value, and
See gst_query_set_segment() for an explanation of the function arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the rate of the segment, or NULL</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the #GstFormat of the values, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="start_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the start value, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="stop_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the stop value, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_uri"
              c:identifier="gst_query_parse_uri"
              version="0.10.22">
        <doc xml:whitespace="preserve">Parse an URI query, writing the URI into @uri as a newly
allocated string, if the respective parameters are non-NULL.
Free the string with g_free() after usage.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the current URI (may be NULL)</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffering_percent"
              c:identifier="gst_query_set_buffering_percent"
              version="0.10.20">
        <doc xml:whitespace="preserve">Set the percentage of buffered data. This is a value between 0 and 100.
The @busy indicator is %TRUE when the buffering is in progress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="busy" transfer-ownership="none">
            <doc xml:whitespace="preserve">if buffering is busy</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="percent" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffering percent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffering_range"
              c:identifier="gst_query_set_buffering_range"
              version="0.10.20">
        <doc xml:whitespace="preserve">Set the available query result fields in @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format to set for the @start and @stop values</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">the start to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the stop to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="estimated_total" transfer-ownership="none">
            <doc xml:whitespace="preserve">estimated total amount of download time</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffering_stats"
              c:identifier="gst_query_set_buffering_stats"
              version="0.10.20">
        <doc xml:whitespace="preserve">Configures the buffering stats values in @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffering mode</doc>
            <type name="BufferingMode" c:type="GstBufferingMode"/>
          </parameter>
          <parameter name="avg_in" transfer-ownership="none">
            <doc xml:whitespace="preserve">the average input rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="avg_out" transfer-ownership="none">
            <doc xml:whitespace="preserve">the average output rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="buffering_left" transfer-ownership="none">
            <doc xml:whitespace="preserve">amount of buffering time left</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_convert" c:identifier="gst_query_set_convert">
        <doc xml:whitespace="preserve">Answer a convert query by setting the requested values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="src_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source #GstFormat</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the destination #GstFormat</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the destination value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_duration" c:identifier="gst_query_set_duration">
        <doc xml:whitespace="preserve">Answer a duration query by setting the requested value in the given format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat for the duration</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:whitespace="preserve">the duration of the stream</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_formats"
              c:identifier="gst_query_set_formats"
              introspectable="0">
        <doc xml:whitespace="preserve">Set the formats query result fields in @query. The number of formats passed
must be equal to @n_formats.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_formats" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of formats to set.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_formatsv"
              c:identifier="gst_query_set_formatsv"
              version="0.10.4">
        <doc xml:whitespace="preserve">Set the formats query result fields in @query. The number of formats passed
in the @formats array must be equal to @n_formats.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_formats" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of formats to set.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="formats" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array containing @n_formats</doc>
            <array length="0" c:type="GstFormat*">
              <type name="Format" c:type="GstFormat"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_latency"
              c:identifier="gst_query_set_latency"
              version="0.10.12">
        <doc xml:whitespace="preserve">Answer a latency query by setting the requested values in the given format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="live" transfer-ownership="none">
            <doc xml:whitespace="preserve">if there is a live element upstream</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="min_latency" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minimal latency of the live element</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="max_latency" transfer-ownership="none">
            <doc xml:whitespace="preserve">the maximal latency of the live element</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_position" c:identifier="gst_query_set_position">
        <doc xml:whitespace="preserve">Answer a position query by setting the requested value in the given format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested #GstFormat</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="cur" transfer-ownership="none">
            <doc xml:whitespace="preserve">the position to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_seeking" c:identifier="gst_query_set_seeking">
        <doc xml:whitespace="preserve">Set the seeking query result fields in @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format to set for the @segment_start and @segment_end values</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="seekable" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seekable flag to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="segment_start" transfer-ownership="none">
            <doc xml:whitespace="preserve">the segment_start to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="segment_end" transfer-ownership="none">
            <doc xml:whitespace="preserve">the segment_end to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_segment" c:identifier="gst_query_set_segment">
        <doc xml:whitespace="preserve">Answer a segment query by setting the requested values. The normal
playback segment of a pipeline is 0 to duration at the default rate of
1.0. If a seek was performed on the pipeline to play a different
segment, this query will return the range specified in the last seek.
playback range start and stop values expressed in @format.
The values are always between 0 and the duration of the media and
negative rates, playback will actually happen from @stop_value to</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rate of the segment</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat of the segment values (@start_value and @stop_value)</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="start_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the start value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the stop value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri"
              c:identifier="gst_query_set_uri"
              version="0.10.22">
        <doc xml:whitespace="preserve">Answer a URI query by setting the requested URI.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the URI to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="mini_object">
        <type name="MiniObject" c:type="GstMiniObject"/>
      </field>
      <field name="type">
        <type name="QueryType" c:type="GstQueryType"/>
      </field>
      <field name="structure">
        <type name="Structure" c:type="GstStructure*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="QueryClass"
            c:type="GstQueryClass"
            glib:is-gtype-struct-for="Query">
      <field name="mini_object_class">
        <type name="MiniObjectClass" c:type="GstMiniObjectClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="QueryType" c:type="GstQueryType">
      <doc xml:whitespace="preserve">Standard predefined Query types</doc>
      <member name="none" value="0" c:identifier="GST_QUERY_NONE"/>
      <member name="position" value="1" c:identifier="GST_QUERY_POSITION"/>
      <member name="duration" value="2" c:identifier="GST_QUERY_DURATION"/>
      <member name="latency" value="3" c:identifier="GST_QUERY_LATENCY"/>
      <member name="jitter" value="4" c:identifier="GST_QUERY_JITTER"/>
      <member name="rate" value="5" c:identifier="GST_QUERY_RATE"/>
      <member name="seeking" value="6" c:identifier="GST_QUERY_SEEKING"/>
      <member name="segment" value="7" c:identifier="GST_QUERY_SEGMENT"/>
      <member name="convert" value="8" c:identifier="GST_QUERY_CONVERT"/>
      <member name="formats" value="9" c:identifier="GST_QUERY_FORMATS"/>
      <member name="buffering" value="10" c:identifier="GST_QUERY_BUFFERING"/>
      <member name="custom" value="11" c:identifier="GST_QUERY_CUSTOM"/>
      <member name="uri" value="12" c:identifier="GST_QUERY_URI"/>
    </enumeration>
    <record name="QueryTypeDefinition" c:type="GstQueryTypeDefinition">
      <doc xml:whitespace="preserve">A Query Type definition</doc>
      <field name="value" writable="1">
        <type name="QueryType" c:type="GstQueryType"/>
      </field>
      <field name="nick" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="quark" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
    </record>
    <enumeration name="Rank" c:type="GstRank">
      <doc xml:whitespace="preserve">Element priority ranks. Defines the order in which the autoplugger (or
similar rank-picking mechanisms, such as e.g. gst_element_make_from_uri())
will choose this element over an alternative one with the same function.
These constants serve as a rough guidance for defining the rank of a
#GstPluginFeature. Any value is valid, including values bigger than</doc>
      <member name="none" value="0" c:identifier="GST_RANK_NONE"/>
      <member name="marginal" value="64" c:identifier="GST_RANK_MARGINAL"/>
      <member name="secondary" value="128" c:identifier="GST_RANK_SECONDARY"/>
      <member name="primary" value="256" c:identifier="GST_RANK_PRIMARY"/>
    </enumeration>
    <class name="Registry"
           c:symbol-prefix="registry"
           c:type="GstRegistry"
           parent="Object"
           glib:type-name="GstRegistry"
           glib:get-type="gst_registry_get_type"
           glib:type-struct="RegistryClass">
      <doc xml:whitespace="preserve">One registry holds the metadata of a set of plugins.
&lt;emphasis role="bold"&gt;Design:&lt;/emphasis&gt;
The #GstRegistry object is a list of plugins and some functions for dealing
with them. Each #GstPlugin is matched 1-1 with a file on disk, and may or may
not be loaded at a given time. There may be multiple #GstRegistry objects,
but the "default registry" is the only object that has any meaning to the
core.
The registry file is actually a cache of plugin information. This is
unlike versions prior to 0.10, where the registry file was the primary source
of plugin information, and was created by the gst-register command.
The primary source, at all times, of plugin information is each plugin file
itself. Thus, if an application wants information about a particular plugin,
or wants to search for a feature that satisfies given criteria, the primary
means of doing so is to load every plugin and look at the resulting
information that is gathered in the default registry. Clearly, this is a time
consuming process, so we cache information in the registry file. The format
and location of the cache file is internal to gstreamer. 
On startup, plugins are searched for in the plugin search path. The following
locations are checked in this order:
&lt;itemizedlist&gt;
&lt;listitem&gt;
&lt;para&gt;location from --gst-plugin-path commandline option.&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;para&gt;the GST_PLUGIN_PATH environment variable.&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;para&gt;the GST_PLUGIN_SYSTEM_PATH environment variable.&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;para&gt;default locations (if GST_PLUGIN_SYSTEM_PATH is not set). Those
default locations are:
&lt;filename&gt;~/.gstreamer-$GST_MAJORMINOR/plugins/&lt;/filename&gt;
and &lt;filename&gt;$prefix/libs/gstreamer-$GST_MAJORMINOR/&lt;/filename&gt;.
&lt;/para&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;
The registry cache file is loaded from
&lt;filename&gt;~/.gstreamer-$GST_MAJORMINOR/registry-$ARCH.bin&lt;/filename&gt; or the
file listed in the GST_REGISTRY env var. One reason to change the registry
location is for testing.
For each plugin that is found in the plugin search path, there could be 3
possibilities for cached information:
&lt;itemizedlist&gt;
&lt;listitem&gt;
&lt;para&gt;the cache may not contain information about a given file.&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;para&gt;the cache may have stale information.&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;para&gt;the cache may have current information.&lt;/para&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;
In the first two cases, the plugin is loaded and the cache updated. In
addition to these cases, the cache may have entries for plugins that are not
relevant to the current process. These are marked as not available to the
current process. If the cache is updated for whatever reason, it is marked
dirty.
A dirty cache is written out at the end of initialization. Each entry is
checked to make sure the information is minimally valid. If not, the entry is
simply dropped.
&lt;emphasis role="bold"&gt;Implementation notes:&lt;/emphasis&gt;
The "cache" and "default registry" are different concepts and can represent
different sets of plugins. For various reasons, at init time, the cache is
stored in the default registry, and plugins not relevant to the current
process are marked with the %GST_PLUGIN_FLAG_CACHED bit. These plugins are
removed at the end of intitialization.</doc>
      <function name="fork_is_enabled"
                c:identifier="gst_registry_fork_is_enabled"
                version="0.10.10">
        <doc xml:whitespace="preserve">By default GStreamer will perform scanning and rebuilding of the
registry file using a helper child process.
Applications might want to disable this behaviour with the
gst_registry_fork_set_enabled() function, in which case new plugins
are scanned (and loaded) into the application process.
rebuilding the registry.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if GStreamer will use the child helper process when</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </function>
      <function name="fork_set_enabled"
                c:identifier="gst_registry_fork_set_enabled"
                version="0.10.10">
        <doc xml:whitespace="preserve">Applications might want to disable/enable spawning of a child helper process
when rebuilding the registry. See gst_registry_fork_is_enabled() for more
information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether rebuilding the registry can use a temporary child helper process.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_default" c:identifier="gst_registry_get_default">
        <doc xml:whitespace="preserve">Retrieves the default registry. The caller does not own a reference on the
registry, as it is alive as long as GStreamer is initialized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The default #GstRegistry.</doc>
          <type name="Registry" c:type="GstRegistry*"/>
        </return-value>
      </function>
      <virtual-method name="feature_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <type name="PluginFeature" c:type="GstPluginFeature*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="plugin_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="plugin" transfer-ownership="none">
            <type name="Plugin" c:type="GstPlugin*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_feature" c:identifier="gst_registry_add_feature">
        <doc xml:whitespace="preserve">Add the feature to the registry. The feature-added signal will be emitted.
This function sinks @feature.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="full">
            <doc xml:whitespace="preserve">the feature to add</doc>
            <type name="PluginFeature" c:type="GstPluginFeature*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_path" c:identifier="gst_registry_add_path">
        <doc xml:whitespace="preserve">Add the given path to the registry. The syntax of the
path is specific to the registry. If the path has already been
added, do nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the path to add to the registry</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_plugin" c:identifier="gst_registry_add_plugin">
        <doc xml:whitespace="preserve">Add the plugin to the registry. The plugin-added signal will be emitted.
This function will sink @plugin.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="plugin" transfer-ownership="full">
            <doc xml:whitespace="preserve">the plugin to add</doc>
            <type name="Plugin" c:type="GstPlugin*"/>
          </parameter>
        </parameters>
      </method>
      <method name="feature_filter" c:identifier="gst_registry_feature_filter">
        <doc xml:whitespace="preserve">Runs a filter against all features of the plugins in the registry
and returns a GList with the results.
If the first flag is set, only the first match is
returned (as a list with a single object).
#GstPluginFeature. Use gst_plugin_feature_list_free() after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="PluginFeature"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="filter"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:whitespace="preserve">the filter to use</doc>
            <type name="PluginFeatureFilter" c:type="GstPluginFeatureFilter"/>
          </parameter>
          <parameter name="first" transfer-ownership="none">
            <doc xml:whitespace="preserve">only return first match</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the filter function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_feature" c:identifier="gst_registry_find_feature">
        <doc xml:whitespace="preserve">Find the pluginfeature with the given name and type in the registry.
or NULL if the plugin was not found. gst_object_unref() after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the pluginfeature with the given name and type</doc>
          <type name="PluginFeature" c:type="GstPluginFeature*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pluginfeature name to find</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pluginfeature type to find</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_plugin" c:identifier="gst_registry_find_plugin">
        <doc xml:whitespace="preserve">Find the plugin with the given name in the registry.
The plugin will be reffed; caller is responsible for unreffing.
plugin was not found. gst_object_unref() after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the plugin with the given name or NULL if the</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the plugin name to find</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_feature_list"
              c:identifier="gst_registry_get_feature_list">
        <doc xml:whitespace="preserve">Retrieves a #GList of #GstPluginFeature of @type.
#GstPluginFeature of @type. Use gst_plugin_feature_list_free() after use
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="PluginFeature"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GType.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_feature_list_by_plugin"
              c:identifier="gst_registry_get_feature_list_by_plugin">
        <doc xml:whitespace="preserve">Retrieves a #GList of features of the plugin with name @name.
#GstPluginFeature. Use gst_plugin_feature_list_free() after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="PluginFeature"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a plugin name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_feature_list_cookie"
              c:identifier="gst_registry_get_feature_list_cookie"
              version="0.10.26">
        <doc xml:whitespace="preserve">Returns the registrys feature list cookie. This changes
every time a feature is added or removed from the registry.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the feature list cookie.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_path_list" c:identifier="gst_registry_get_path_list">
        <doc xml:whitespace="preserve">Get the list of paths for the given registry.
strings. g_list_free after use.
MT safe.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">A #GList of paths as</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="utf8"/>
          </type>
        </return-value>
      </method>
      <method name="get_plugin_list"
              c:identifier="gst_registry_get_plugin_list">
        <doc xml:whitespace="preserve">Get a copy of all plugins registered in the given registry. The refcount
of each element in the list in incremented.
Use gst_plugin_list_free() after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GstPlugin.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Plugin"/>
          </type>
        </return-value>
      </method>
      <method name="lookup" c:identifier="gst_registry_lookup">
        <doc xml:whitespace="preserve">Look up a plugin in the given registry with the given filename.
If found, plugin is reffed.
gst_object_unref() after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstPlugin if found, or NULL if not.</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the file to look up</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_feature" c:identifier="gst_registry_lookup_feature">
        <doc xml:whitespace="preserve">Find a #GstPluginFeature with @name in @registry.
use gst_object_unref() after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstPluginFeature with its refcount incremented,</doc>
          <type name="PluginFeature" c:type="GstPluginFeature*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPluginFeature name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="plugin_filter" c:identifier="gst_registry_plugin_filter">
        <doc xml:whitespace="preserve">Runs a filter against all plugins in the registry and returns a #GList with
the results. If the first flag is set, only the first match is
returned (as a list with a single object).
Every plugin is reffed; use gst_plugin_list_free() after use, which
will unref again.
Use gst_plugin_list_free() after usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GstPlugin.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Plugin"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="filter"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:whitespace="preserve">the filter to use</doc>
            <type name="PluginFilter" c:type="GstPluginFilter"/>
          </parameter>
          <parameter name="first" transfer-ownership="none">
            <doc xml:whitespace="preserve">only return first match</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the filter function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_feature" c:identifier="gst_registry_remove_feature">
        <doc xml:whitespace="preserve">Remove the feature from the registry.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the feature to remove</doc>
            <type name="PluginFeature" c:type="GstPluginFeature*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_plugin" c:identifier="gst_registry_remove_plugin">
        <doc xml:whitespace="preserve">Remove the plugin from the registry.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="plugin" transfer-ownership="none">
            <doc xml:whitespace="preserve">the plugin to remove</doc>
            <type name="Plugin" c:type="GstPlugin*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scan_path" c:identifier="gst_registry_scan_path">
        <doc xml:whitespace="preserve">Scan the given path for plugins to add to the registry. The syntax of the
path is specific to the registry.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if registry changed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the path to scan</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="xml_read_cache" c:identifier="gst_registry_xml_read_cache">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="location" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="xml_write_cache"
              c:identifier="gst_registry_xml_write_cache">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="location" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="plugins" readable="0" private="1">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="features" readable="0" private="1">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="paths" readable="0" private="1">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="cache_file" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="feature_hash" readable="0" private="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="basename_hash" readable="0" private="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="RegistryPrivate" c:type="GstRegistryPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="1">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="feature-added">
        <doc xml:whitespace="preserve">Signals that a feature has been added to the registry (possibly
replacing a previously-added one by the same name)</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the feature that has been added</doc>
            <type name="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="plugin-added">
        <doc xml:whitespace="preserve">Signals that a plugin has been added to the registry (possibly
replacing a previously-added one by the same name)</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="plugin" transfer-ownership="none">
            <doc xml:whitespace="preserve">the plugin that has been added</doc>
            <type name="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="RegistryClass"
            c:type="GstRegistryClass"
            glib:is-gtype-struct-for="Registry">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="plugin_added">
        <callback name="plugin_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="registry" transfer-ownership="none">
              <type name="Registry" c:type="GstRegistry*"/>
            </parameter>
            <parameter name="plugin" transfer-ownership="none">
              <type name="Plugin" c:type="GstPlugin*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="feature_added">
        <callback name="feature_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="registry" transfer-ownership="none">
              <type name="Registry" c:type="GstRegistry*"/>
            </parameter>
            <parameter name="feature" transfer-ownership="none">
              <type name="PluginFeature" c:type="GstPluginFeature*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="RegistryPrivate" c:type="GstRegistryPrivate" disguised="1">
    </record>
    <enumeration name="ResourceError"
                 c:type="GstResourceError"
                 glib:error-quark="gst_resource_error_quark">
      <doc xml:whitespace="preserve">Resource errors are for any resource used by an element:
memory, files, network connections, process space, ...
They're typically used by source and sink elements.</doc>
      <member name="failed"
              value="1"
              c:identifier="GST_RESOURCE_ERROR_FAILED"/>
      <member name="too_lazy"
              value="2"
              c:identifier="GST_RESOURCE_ERROR_TOO_LAZY"/>
      <member name="not_found"
              value="3"
              c:identifier="GST_RESOURCE_ERROR_NOT_FOUND"/>
      <member name="busy" value="4" c:identifier="GST_RESOURCE_ERROR_BUSY"/>
      <member name="open_read"
              value="5"
              c:identifier="GST_RESOURCE_ERROR_OPEN_READ"/>
      <member name="open_write"
              value="6"
              c:identifier="GST_RESOURCE_ERROR_OPEN_WRITE"/>
      <member name="open_read_write"
              value="7"
              c:identifier="GST_RESOURCE_ERROR_OPEN_READ_WRITE"/>
      <member name="close" value="8" c:identifier="GST_RESOURCE_ERROR_CLOSE"/>
      <member name="read" value="9" c:identifier="GST_RESOURCE_ERROR_READ"/>
      <member name="write" value="10" c:identifier="GST_RESOURCE_ERROR_WRITE"/>
      <member name="seek" value="11" c:identifier="GST_RESOURCE_ERROR_SEEK"/>
      <member name="sync" value="12" c:identifier="GST_RESOURCE_ERROR_SYNC"/>
      <member name="settings"
              value="13"
              c:identifier="GST_RESOURCE_ERROR_SETTINGS"/>
      <member name="no_space_left"
              value="14"
              c:identifier="GST_RESOURCE_ERROR_NO_SPACE_LEFT"/>
      <member name="num_errors"
              value="15"
              c:identifier="GST_RESOURCE_ERROR_NUM_ERRORS"/>
    </enumeration>
    <constant name="SECOND" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="SearchMode" version="0.10.23" c:type="GstSearchMode">
      <doc xml:whitespace="preserve">The different search modes.</doc>
      <member name="exact" value="0" c:identifier="GST_SEARCH_MODE_EXACT"/>
      <member name="before" value="1" c:identifier="GST_SEARCH_MODE_BEFORE"/>
      <member name="after" value="2" c:identifier="GST_SEARCH_MODE_AFTER"/>
    </enumeration>
    <bitfield name="SeekFlags" c:type="GstSeekFlags">
      <doc xml:whitespace="preserve">Flags to be used with gst_element_seek() or gst_event_new_seek(). All flags
can be used together.
A non flushing seek might take some time to perform as the currently
playing data in the pipeline will not be cleared.
An accurate seek might be slower for formats that don't have any indexes
or timestamp markers in the stream. Specifying this flag might require a
complete scan of the file in those cases.
no EOS will be emmited by the element that performed the seek, but a
#GST_MESSAGE_SEGMENT_DONE message will be posted on the bus by the element.
When this message is posted, it is possible to send a new seek event to
continue playback. With this seek method it is possible to perform seemless
looping or simple linear editing.
When doing fast forward (rate &gt; 1.0) or fast reverse (rate &lt; -1.0) trickmode
playback, the @GST_SEEK_FLAG_SKIP flag can be used to instruct decoders
and demuxers to adjust the playback rate by skipping frames. This can improve
performance and decrease CPU usage because not all frames need to be decoded.
Also see part-seeking.txt in the GStreamer design documentation for more
details on the meaning of these flags and the behaviour expected of
elements that handle them.</doc>
      <member name="none" value="0" c:identifier="GST_SEEK_FLAG_NONE"/>
      <member name="flush" value="1" c:identifier="GST_SEEK_FLAG_FLUSH"/>
      <member name="accurate" value="2" c:identifier="GST_SEEK_FLAG_ACCURATE"/>
      <member name="key_unit" value="4" c:identifier="GST_SEEK_FLAG_KEY_UNIT"/>
      <member name="segment" value="8" c:identifier="GST_SEEK_FLAG_SEGMENT"/>
      <member name="skip" value="16" c:identifier="GST_SEEK_FLAG_SKIP"/>
    </bitfield>
    <enumeration name="SeekType" c:type="GstSeekType">
      <doc xml:whitespace="preserve">The different types of seek events. When constructing a seek event with
gst_event_new_seek(), a format, a seek method and optional flags are to
be provided. The seek event is then inserted into the graph with
gst_pad_send_event() or gst_element_send_event().</doc>
      <member name="none" value="0" c:identifier="GST_SEEK_TYPE_NONE"/>
      <member name="cur" value="1" c:identifier="GST_SEEK_TYPE_CUR"/>
      <member name="set" value="2" c:identifier="GST_SEEK_TYPE_SET"/>
      <member name="end" value="3" c:identifier="GST_SEEK_TYPE_END"/>
    </enumeration>
    <record name="Segment"
            c:type="GstSegment"
            glib:type-name="GstSegment"
            glib:get-type="gst_segment_get_type"
            c:symbol-prefix="segment">
      <doc xml:whitespace="preserve">This helper structure holds the relevant values for tracking the region of
interest in a media file, called a segment. 
The structure can be used for two purposes:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;performing seeks (handling seek events)&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;tracking playback regions (handling newsegment events)&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
The segment is usually configured by the application with a seek event which 
is propagated upstream and eventually handled by an element that performs the seek.
The configured segment is then propagated back downstream with a newsegment event.
This information is then used to clip media to the segment boundaries.
A segment structure is initialized with gst_segment_init(), which takes a #GstFormat
that will be used as the format of the segment values. The segment will be configured
with a start value of 0 and a stop/duration of -1, which is undefined. The default
rate and applied_rate is 1.0.
If the segment is used for managing seeks, the segment duration should be set with
gst_segment_set_duration(). The public duration field contains the duration of the
segment. When using the segment for seeking, the start and time members should 
normally be left to their default 0 value. The stop position is left to -1 unless
explicitly configured to a different value after a seek event.
The current position in the segment should be set with the gst_segment_set_last_stop().
The public last_stop field contains the last set stop position in the segment.
For elements that perform seeks, the current segment should be updated with the
gst_segment_set_seek() and the values from the seek event. This method will update
all the segment fields. The last_stop field will contain the new playback position.
If the cur_type was different from GST_SEEK_TYPE_NONE, playback continues from
the last_stop position, possibly with updated flags or rate.
For elements that want to use #GstSegment to track the playback region, use
gst_segment_set_newsegment() to update the segment fields with the information from
the newsegment event. The gst_segment_clip() method can be used to check and clip
the media data to the segment boundaries.
For elements that want to synchronize to the pipeline clock, gst_segment_to_running_time()
can be used to convert a timestamp to a value that can be used to synchronize
to the clock. This function takes into account all accumulated segments as well as
any rate or applied_rate conversions.
For elements that need to perform operations on media data in stream_time, 
gst_segment_to_stream_time() can be used to convert a timestamp and the segment
info to stream time (which is always between 0 and the duration of the stream).
Last reviewed on 2007-05-17 (0.10.13)</doc>
      <field name="rate" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="abs_rate" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="format" writable="1">
        <type name="Format" c:type="GstFormat"/>
      </field>
      <field name="flags" writable="1">
        <type name="SeekFlags" c:type="GstSeekFlags"/>
      </field>
      <field name="start" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="stop" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="time" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="accum" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="last_stop" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="duration" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="applied_rate" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="guint8" fixed-size="0">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
      <constructor name="new" c:identifier="gst_segment_new">
        <doc xml:whitespace="preserve">Allocate a new #GstSegment structure and initialize it using 
gst_segment_init().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstSegment, free with gst_segment_free().</doc>
          <type name="Segment" c:type="GstSegment*"/>
        </return-value>
      </constructor>
      <method name="clip" c:identifier="gst_segment_clip">
        <doc xml:whitespace="preserve">Clip the given @start and @stop values to the segment boundaries given
in @segment. @start and @stop are compared and clipped to @segment 
start and stop values.
If the function returns FALSE, @start and @stop are known to fall
outside of @segment and @clip_start and @clip_stop are not updated.
When the function returns TRUE, @clip_start and @clip_stop will be
updated. If @clip_start or @clip_stop are different from @start or @stop
respectively, the region fell partially in the segment.
Note that when @stop is -1, @clip_stop will be set to the end of the
segment. Depending on the use case, this may or may not be what you want.
completely in @segment, FALSE if the values are completely outside 
of the segment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the given @start and @stop times fall partially or</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">the start position in the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the stop position in the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="clip_start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the clipped start position in the segment</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="clip_stop"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the clipped stop position in the segment</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gst_segment_copy" version="0.10.20">
        <doc xml:whitespace="preserve">Create a copy of given @segment.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstSegment, free with gst_segment_free().</doc>
          <type name="Segment" c:type="GstSegment*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="gst_segment_free">
        <doc xml:whitespace="preserve">Free the allocated segment @segment.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="init" c:identifier="gst_segment_init">
        <doc xml:whitespace="preserve">The start/last_stop positions are set to 0 and the stop/duration
fields are set to -1 (unknown). The default rate of 1.0 and no
flags are set.
Initialize @segment to its default values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_duration" c:identifier="gst_segment_set_duration">
        <doc xml:whitespace="preserve">Set the duration of the segment to @duration. This function is mainly
used by elements that perform seeking and know the total duration of the
segment. 
This field should be set to allow seeking requests relative to the
duration.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:whitespace="preserve">the duration of the segment info or -1 if unknown.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_last_stop" c:identifier="gst_segment_set_last_stop">
        <doc xml:whitespace="preserve">Set the last observed stop position in the segment to @position.
This field should be set to allow seeking requests relative to the
current playing position.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">the position</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_newsegment"
              c:identifier="gst_segment_set_newsegment"
              version="0.10.6">
        <doc xml:whitespace="preserve">Update the segment structure with the field values of a new segment event and
with a default applied_rate of 1.0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="update" transfer-ownership="none">
            <doc xml:whitespace="preserve">flag indicating a new segment is started or updated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rate of the segment.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new start value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new stop value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new stream time</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_newsegment_full"
              c:identifier="gst_segment_set_newsegment_full">
        <doc xml:whitespace="preserve">Update the segment structure with the field values of a new segment event.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="update" transfer-ownership="none">
            <doc xml:whitespace="preserve">flag indicating a new segment is started or updated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rate of the segment.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="applied_rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the applied rate of the segment.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new start value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new stop value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new stream time</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_running_time"
              c:identifier="gst_segment_set_running_time"
              version="0.10.24">
        <doc xml:whitespace="preserve">Adjust the start/stop and accum values of @segment such that the next valid
buffer will be one with @running_time.
returned, @running_time is -1 or not in @segment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the segment could be updated successfully. If %FALSE is</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="running_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the running_time in the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_seek" c:identifier="gst_segment_set_seek">
        <doc xml:whitespace="preserve">Update the segment structure with the field values of a seek event (see
gst_event_new_seek()).
After calling this method, the segment field last_stop and time will
contain the requested new position in the segment. The new requested
position in the segment depends on @rate and @start_type and @stop_type. 
For positive @rate, the new position in the segment is the new @segment
start field when it was updated with a @start_type different from
#GST_SEEK_TYPE_NONE. If no update was performed on @segment start position
(#GST_SEEK_TYPE_NONE), @start is ignored and @segment last_stop is
unmodified.
For negative @rate, the new position in the segment is the new @segment
stop field when it was updated with a @stop_type different from
#GST_SEEK_TYPE_NONE. If no stop was previously configured in the segment, the
duration of the segment will be used to update the stop position.
If no update was performed on @segment stop position (#GST_SEEK_TYPE_NONE),
The applied rate of the segment will be set to 1.0 by default.
If the caller can apply a rate change, it should update @segment
rate and applied_rate after calling this function.
last_stop field. This field can be FALSE if, for example, only the @rate
has been changed but not the playback position.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rate of the segment.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seek flags for the segment</doc>
            <type name="SeekFlags" c:type="GstSeekFlags"/>
          </parameter>
          <parameter name="start_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seek method</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seek start value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seek method</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seek stop value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="update" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean holding whether last_stop was updated.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_position"
              c:identifier="gst_segment_to_position"
              version="0.10.24">
        <doc xml:whitespace="preserve">Convert @running_time into a position in the segment so that
gst_segment_to_running_time() with that position returns @running_time.
-1 when @running_time is -1 or when it is not inside @segment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the position in the segment for @running_time. This function returns</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="running_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the running_time in the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_running_time"
              c:identifier="gst_segment_to_running_time">
        <doc xml:whitespace="preserve">Translate @position to the total running time using the currently configured 
and previously accumulated segments. Position is a value between @segment
start and stop time.
This function is typically used by elements that need to synchronize to the
global clock in a pipeline. The runnning time is a constantly increasing value
starting from 0. When gst_segment_init() is called, this value will reset to
0.
This function returns -1 if the position is outside of @segment start and stop.
was given.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the position as the total running time or -1 when an invalid position</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">the position in the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_stream_time" c:identifier="gst_segment_to_stream_time">
        <doc xml:whitespace="preserve">Translate @position to stream time using the currently configured 
segment. The @position value must be between @segment start and
stop value. 
This function is typically used by elements that need to operate on
the stream time of the buffers it receives, such as effect plugins.
In those use cases, @position is typically the buffer timestamp or 
clock time that one wants to convert to the stream time.
The stream time is always between 0 and the total duration of the 
media stream. 
was given.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the position in stream_time or -1 when an invalid position</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">the position in the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="State" c:type="GstState">
      <doc xml:whitespace="preserve">The possible states an element can be in. States can be changed using
gst_element_set_state() and checked using gst_element_get_state().</doc>
      <member name="void_pending"
              value="0"
              c:identifier="GST_STATE_VOID_PENDING"/>
      <member name="null" value="1" c:identifier="GST_STATE_NULL"/>
      <member name="ready" value="2" c:identifier="GST_STATE_READY"/>
      <member name="paused" value="3" c:identifier="GST_STATE_PAUSED"/>
      <member name="playing" value="4" c:identifier="GST_STATE_PLAYING"/>
    </enumeration>
    <bitfield name="StateChange" c:type="GstStateChange">
      <doc xml:whitespace="preserve">These are the different state changes an element goes through.
%GST_STATE_NULL &amp;rArr; %GST_STATE_PLAYING is called an upwards state change
and %GST_STATE_PLAYING &amp;rArr; %GST_STATE_NULL a downwards state change.</doc>
      <member name="null_to_ready"
              value="10"
              c:identifier="GST_STATE_CHANGE_NULL_TO_READY"/>
      <member name="ready_to_paused"
              value="19"
              c:identifier="GST_STATE_CHANGE_READY_TO_PAUSED"/>
      <member name="paused_to_playing"
              value="28"
              c:identifier="GST_STATE_CHANGE_PAUSED_TO_PLAYING"/>
      <member name="playing_to_paused"
              value="35"
              c:identifier="GST_STATE_CHANGE_PLAYING_TO_PAUSED"/>
      <member name="paused_to_ready"
              value="26"
              c:identifier="GST_STATE_CHANGE_PAUSED_TO_READY"/>
      <member name="ready_to_null"
              value="17"
              c:identifier="GST_STATE_CHANGE_READY_TO_NULL"/>
    </bitfield>
    <enumeration name="StateChangeReturn" c:type="GstStateChangeReturn">
      <doc xml:whitespace="preserve">The possible return values from a state change function. Only</doc>
      <member name="failure"
              value="0"
              c:identifier="GST_STATE_CHANGE_FAILURE"/>
      <member name="success"
              value="1"
              c:identifier="GST_STATE_CHANGE_SUCCESS"/>
      <member name="async" value="2" c:identifier="GST_STATE_CHANGE_ASYNC"/>
      <member name="no_preroll"
              value="3"
              c:identifier="GST_STATE_CHANGE_NO_PREROLL"/>
    </enumeration>
    <record name="StaticCaps" c:type="GstStaticCaps">
      <doc xml:whitespace="preserve">Datastructure to initialize #GstCaps from a string description usually
used in conjunction with GST_STATIC_CAPS() and gst_static_caps_get() to
instantiate a #GstCaps.</doc>
      <field name="caps" writable="1">
        <type name="Caps" c:type="GstCaps"/>
      </field>
      <field name="string" writable="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="get" c:identifier="gst_static_caps_get">
        <doc xml:whitespace="preserve">Converts a #GstStaticCaps to a #GstCaps.
Since the core holds an additional ref to the returned caps,
use gst_caps_make_writable() on the returned caps to modify it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to the #GstCaps. Unref after usage.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
    </record>
    <record name="StaticPadTemplate" c:type="GstStaticPadTemplate">
      <doc xml:whitespace="preserve">Structure describing the #GstStaticPadTemplate.</doc>
      <field name="name_template" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="direction" writable="1">
        <type name="PadDirection" c:type="GstPadDirection"/>
      </field>
      <field name="presence" writable="1">
        <type name="PadPresence" c:type="GstPadPresence"/>
      </field>
      <field name="static_caps" writable="1">
        <type name="StaticCaps" c:type="GstStaticCaps"/>
      </field>
      <method name="get" c:identifier="gst_static_pad_template_get">
        <doc xml:whitespace="preserve">Converts a #GstStaticPadTemplate into a #GstPadTemplate.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPadTemplate.</doc>
          <type name="PadTemplate" c:type="GstPadTemplate*"/>
        </return-value>
      </method>
      <method name="get_caps" c:identifier="gst_static_pad_template_get_caps">
        <doc xml:whitespace="preserve">Gets the capabilities of the static pad template.
Unref after usage. Since the core holds an additional
ref to the returned caps, use gst_caps_make_writable()
on the returned caps to modify it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstCaps of the static pad template.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
    </record>
    <enumeration name="StreamError"
                 c:type="GstStreamError"
                 glib:error-quark="gst_stream_error_quark">
      <doc xml:whitespace="preserve">Stream errors are for anything related to the stream being processed:
format errors, media type errors, ...
They're typically used by decoders, demuxers, converters, ...</doc>
      <member name="failed" value="1" c:identifier="GST_STREAM_ERROR_FAILED"/>
      <member name="too_lazy"
              value="2"
              c:identifier="GST_STREAM_ERROR_TOO_LAZY"/>
      <member name="not_implemented"
              value="3"
              c:identifier="GST_STREAM_ERROR_NOT_IMPLEMENTED"/>
      <member name="type_not_found"
              value="4"
              c:identifier="GST_STREAM_ERROR_TYPE_NOT_FOUND"/>
      <member name="wrong_type"
              value="5"
              c:identifier="GST_STREAM_ERROR_WRONG_TYPE"/>
      <member name="codec_not_found"
              value="6"
              c:identifier="GST_STREAM_ERROR_CODEC_NOT_FOUND"/>
      <member name="decode" value="7" c:identifier="GST_STREAM_ERROR_DECODE"/>
      <member name="encode" value="8" c:identifier="GST_STREAM_ERROR_ENCODE"/>
      <member name="demux" value="9" c:identifier="GST_STREAM_ERROR_DEMUX"/>
      <member name="mux" value="10" c:identifier="GST_STREAM_ERROR_MUX"/>
      <member name="format" value="11" c:identifier="GST_STREAM_ERROR_FORMAT"/>
      <member name="decrypt"
              value="12"
              c:identifier="GST_STREAM_ERROR_DECRYPT"/>
      <member name="decrypt_nokey"
              value="13"
              c:identifier="GST_STREAM_ERROR_DECRYPT_NOKEY"/>
      <member name="num_errors"
              value="14"
              c:identifier="GST_STREAM_ERROR_NUM_ERRORS"/>
    </enumeration>
    <enumeration name="StreamStatusType"
                 version="0.10.24"
                 c:type="GstStreamStatusType">
      <doc xml:whitespace="preserve">The type of a %GST_MESSAGE_STREAM_STATUS. The stream status messages inform the
application of new streaming threads and their status.</doc>
      <member name="create"
              value="0"
              c:identifier="GST_STREAM_STATUS_TYPE_CREATE"/>
      <member name="enter"
              value="1"
              c:identifier="GST_STREAM_STATUS_TYPE_ENTER"/>
      <member name="leave"
              value="2"
              c:identifier="GST_STREAM_STATUS_TYPE_LEAVE"/>
      <member name="destroy"
              value="3"
              c:identifier="GST_STREAM_STATUS_TYPE_DESTROY"/>
      <member name="start"
              value="8"
              c:identifier="GST_STREAM_STATUS_TYPE_START"/>
      <member name="pause"
              value="9"
              c:identifier="GST_STREAM_STATUS_TYPE_PAUSE"/>
      <member name="stop"
              value="10"
              c:identifier="GST_STREAM_STATUS_TYPE_STOP"/>
    </enumeration>
    <record name="Structure"
            c:type="GstStructure"
            glib:type-name="GstStructure"
            glib:get-type="gst_structure_get_type"
            c:symbol-prefix="structure">
      <doc xml:whitespace="preserve">A #GstStructure is a collection of key/value pairs. The keys are expressed
as GQuarks and the values can be of any GType.
In addition to the key/value pairs, a #GstStructure also has a name. The name
starts with a letter and can be folled by letters, numbers and any of "/-_.:".
#GstStructure is used by various GStreamer subsystems to store information
in a flexible and extensible way. A #GstStructure does not have a refcount
because it usually is part of a higher level object such as #GstCaps. It
provides a means to enforce mutability using the refcount of the parent
with the gst_structure_set_parent_refcount() method.
A #GstStructure can be created with gst_structure_empty_new() or
gst_structure_new(), which both take a name and an optional set of
key/value pairs along with the types of the values.
Field values can be changed with gst_structure_set_value() or
gst_structure_set().
Field values can be retrieved with gst_structure_get_value() or the more
convenient gst_structure_get_*() functions.
Fields can be removed with gst_structure_remove_field() or
gst_structure_remove_fields().
Strings in structures must be ASCII or UTF-8 encoded. Other encodings are
not allowed. Strings must not be empty either, but may be NULL.
Last reviewed on 2009-06-08 (0.10.23)</doc>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="name" readable="0" private="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="parent_refcount" readable="0" private="1">
        <type name="gint" c:type="gint*"/>
      </field>
      <field name="fields" readable="0" private="1">
        <array name="GLib.Array" c:type="GArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <constructor name="empty_new" c:identifier="gst_structure_empty_new">
        <doc xml:whitespace="preserve">Creates a new, empty #GstStructure with the given @name.
See gst_structure_set_name() for constraints on the @name parameter.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new, empty #GstStructure</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new structure</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="id_empty_new"
                   c:identifier="gst_structure_id_empty_new">
        <doc xml:whitespace="preserve">Creates a new, empty #GstStructure with the given name as a GQuark.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new, empty #GstStructure</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new structure</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="id_new"
                   c:identifier="gst_structure_id_new"
                   version="0.10.24"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstStructure with the given name as a GQuark, followed by
fieldname quark, GType, argument(s) "triplets" in the same format as
gst_structure_id_set(). Basically a convenience wrapper around
gst_structure_id_empty_new() and gst_structure_id_set().
The last variable argument must be NULL (or 0).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstStructure</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="name_quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new structure</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="field_quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GQuark for the name of the field to set</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new"
                   c:identifier="gst_structure_new"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstStructure with the given name.  Parses the
list of variable arguments and sets fields to the values listed.
Variable arguments should be passed as field name, field type,
and value.  Last variable argument should be NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstStructure</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new structure</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="firstfield" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of first field to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_valist"
                   c:identifier="gst_structure_new_valist"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstStructure with the given @name.  Structure fields
are set according to the varargs in a manner similar to
gst_structure_new().
See gst_structure_set_name() for constraints on the @name parameter.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstStructure</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new structure</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="firstfield" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of first field to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="varargs" transfer-ownership="none">
            <doc xml:whitespace="preserve">variable argument list</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="gst_structure_copy">
        <doc xml:whitespace="preserve">Duplicates a #GstStructure and all its fields and values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #GstStructure.</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
      </method>
      <method name="fixate_field_boolean"
              c:identifier="gst_structure_fixate_field_boolean">
        <doc xml:whitespace="preserve">Fixates a #GstStructure by changing the given @field_name field to the given</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure could be fixated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a field in @structure</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target value of the fixation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="fixate_field_nearest_double"
              c:identifier="gst_structure_fixate_field_nearest_double">
        <doc xml:whitespace="preserve">Fixates a #GstStructure by changing the given field to the nearest
double to @target that is a subset of the existing field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure could be fixated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a field in @structure</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target value of the fixation</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="fixate_field_nearest_fraction"
              c:identifier="gst_structure_fixate_field_nearest_fraction">
        <doc xml:whitespace="preserve">Fixates a #GstStructure by changing the given field to the nearest
fraction to @target_numerator/@target_denominator that is a subset
of the existing field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure could be fixated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a field in @structure</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="target_numerator" transfer-ownership="none">
            <doc xml:whitespace="preserve">The numerator of the target value of the fixation</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="target_denominator" transfer-ownership="none">
            <doc xml:whitespace="preserve">The denominator of the target value of the fixation</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="fixate_field_nearest_int"
              c:identifier="gst_structure_fixate_field_nearest_int">
        <doc xml:whitespace="preserve">Fixates a #GstStructure by changing the given field to the nearest
integer to @target that is a subset of the existing field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure could be fixated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a field in @structure</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target value of the fixation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="fixate_field_string"
              c:identifier="gst_structure_fixate_field_string"
              version="0.10.30">
        <doc xml:whitespace="preserve">Fixates a #GstStructure by changing the given @field_name field to the given</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure could be fixated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a field in @structure</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target value of the fixation</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="gst_structure_foreach">
        <doc xml:whitespace="preserve">Calls the provided function once for each field in the #GstStructure. The
function must not modify the fields. Also see gst_structure_map_in_place().
FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the supplied function returns TRUE For each of the fields,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">a function to call for each field</doc>
            <type name="StructureForeachFunc"
                  c:type="GstStructureForeachFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">private data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_structure_free">
        <doc xml:whitespace="preserve">Frees a #GstStructure and all its fields and values. The structure must not
have a parent when this function is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get"
              c:identifier="gst_structure_get"
              version="0.10.24"
              introspectable="0">
        <doc xml:whitespace="preserve">Parses the variable arguments and reads fields from @structure accordingly.
Variable arguments should be in the form field name, field type
(as a GType), pointer(s) to a variable(s) to hold the return value(s).
The last variable argument should be NULL.
For refcounted (mini)objects you will acquire your own reference which
you must release with a suitable _unref() when no longer needed. For
strings and boxed types you will acquire a copy which you will need to
release with either g_free() or the suiteable function for the boxed type.
because the field requested did not exist, or was of a type other
than the type specified), otherwise TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">FALSE if there was a problem reading any of the fields (e.g.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="first_fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the first field to read</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean" c:identifier="gst_structure_get_boolean">
        <doc xml:whitespace="preserve">Sets the boolean pointed to by @value corresponding to the value of the
given field.  Caller is responsible for making sure the field exists
and has the correct type.
with @fieldname or the existing field did not contain a boolean, this
function returns FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a #gboolean to set</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_clock_time"
              c:identifier="gst_structure_get_clock_time">
        <doc xml:whitespace="preserve">Sets the clock time pointed to by @value corresponding to the clock time
of the given field.  Caller is responsible for making sure the field exists
and has the correct type.
with @fieldname or the existing field did not contain a #GstClockTime, this
function returns FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a #GstClockTime to set</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date" c:identifier="gst_structure_get_date">
        <doc xml:whitespace="preserve">Sets the date pointed to by @value corresponding to the date of the
given field.  Caller is responsible for making sure the field exists
and has the correct type.
On success @value will point to a newly-allocated copy of the date which
inconsistent with e.g. gst_structure_get_string() which doesn't return a
copy of the string).
with @fieldname or the existing field did not contain a data, this function
returns FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a #GDate to set</doc>
            <type name="GLib.Date" c:type="GDate**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date_time"
              c:identifier="gst_structure_get_date_time"
              version="0.10.31">
        <doc xml:whitespace="preserve">Sets the datetime pointed to by @value corresponding to the datetime of the
given field. Caller is responsible for making sure the field exists
and has the correct type.
On success @value will point to a reference of the datetime which
should be unreffed with gst_date_time_unref() when no longer needed
(note: this is inconsistent with e.g. gst_structure_get_string()
which doesn't return a copy of the string).
with @fieldname or the existing field did not contain a data, this function
returns FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a #GstDateTime to set</doc>
            <type name="DateTime" c:type="GstDateTime**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="gst_structure_get_double">
        <doc xml:whitespace="preserve">Sets the double pointed to by @value corresponding to the value of the
given field.  Caller is responsible for making sure the field exists
and has the correct type.
with @fieldname or the existing field did not contain a double, this
function returns FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a gdouble to set</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_enum" c:identifier="gst_structure_get_enum">
        <doc xml:whitespace="preserve">Sets the int pointed to by @value corresponding to the value of the
given field.  Caller is responsible for making sure the field exists,
has the correct type and that the enumtype is correct.
with @fieldname or the existing field did not contain an enum of the given
type, this function returns FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="enumtype" transfer-ownership="none">
            <doc xml:whitespace="preserve">the enum type of a field</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to an int to set</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_field_type"
              c:identifier="gst_structure_get_field_type">
        <doc xml:whitespace="preserve">Finds the field with the given name, and returns the type of the
value it contains.  If the field is not found, G_TYPE_INVALID is
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue of the field</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fourcc" c:identifier="gst_structure_get_fourcc">
        <doc xml:whitespace="preserve">Sets the Fourcc pointed to by @value corresponding to the value of the
given field.  Caller is responsible for making sure the field exists
and has the correct type.
with @fieldname or the existing field did not contain a fourcc, this function
returns FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a 32bit unsigned int to set</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fraction" c:identifier="gst_structure_get_fraction">
        <doc xml:whitespace="preserve">Sets the integers pointed to by @value_numerator and @value_denominator
corresponding to the value of the given field.  Caller is responsible
for making sure the field exists and has the correct type.
with @fieldname or the existing field did not contain a GstFraction, this
function returns FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the values could be set correctly. If there was no field</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value_numerator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to an int to set</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="value_denominator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to an int to set</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int" c:identifier="gst_structure_get_int">
        <doc xml:whitespace="preserve">Sets the int pointed to by @value corresponding to the value of the
given field.  Caller is responsible for making sure the field exists
and has the correct type.
with @fieldname or the existing field did not contain an int, this function
returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be set correctly. If there was no field</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to an int to set</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="gst_structure_get_name">
        <doc xml:whitespace="preserve">Get the name of @structure as a string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the structure.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_name_id" c:identifier="gst_structure_get_name_id">
        <doc xml:whitespace="preserve">Get the name of @structure as a GQuark.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark representing the name of the structure.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </method>
      <method name="get_string" c:identifier="gst_structure_get_string">
        <doc xml:whitespace="preserve">Finds the field corresponding to @fieldname, and returns the string
contained in the field's value.  Caller is responsible for making
sure the field exists and has the correct type.
The string should not be modified, and remains valid until the next
call to a gst_structure_*() function with the given structure.
or did not contain a string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to the string or NULL when the field did not exist</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint"
              c:identifier="gst_structure_get_uint"
              version="0.10.15">
        <doc xml:whitespace="preserve">Sets the uint pointed to by @value corresponding to the value of the
given field.  Caller is responsible for making sure the field exists
and has the correct type.
with @fieldname or the existing field did not contain a uint, this function
returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be set correctly. If there was no field</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a uint to set</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valist"
              c:identifier="gst_structure_get_valist"
              version="0.10.24"
              introspectable="0">
        <doc xml:whitespace="preserve">Parses the variable arguments and reads fields from @structure accordingly.
valist-variant of gst_structure_get(). Look at the documentation of
gst_structure_get() for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, or FALSE if there was a problem reading any of the fields</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="first_fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the first field to read</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:whitespace="preserve">variable arguments</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="gst_structure_get_value">
        <doc xml:whitespace="preserve">Get the value of the field with name @fieldname.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue corresponding to the field with the given name.</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to get</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_field" c:identifier="gst_structure_has_field">
        <doc xml:whitespace="preserve">Check if @structure contains a field named @fieldname.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure contains a field with the given name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_field_typed"
              c:identifier="gst_structure_has_field_typed">
        <doc xml:whitespace="preserve">Check if @structure contains a field named @fieldname and with GType @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure contains a field with the given name and type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of a value</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_name" c:identifier="gst_structure_has_name">
        <doc xml:whitespace="preserve">Checks if the structure has the given name</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @name matches the name of the structure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">structure name to check for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_get"
              c:identifier="gst_structure_id_get"
              version="0.10.24"
              introspectable="0">
        <doc xml:whitespace="preserve">Parses the variable arguments and reads fields from @structure accordingly.
Variable arguments should be in the form field id quark, field type
(as a GType), pointer(s) to a variable(s) to hold the return value(s).
The last variable argument should be NULL (technically it should be a
0 quark, but we require NULL so compilers that support it can check for
the NULL terminator and warn if it's not there).
This function is just like gst_structure_get() only that it is slightly
more efficient since it saves the string-to-quark lookup in the global
quark hashtable.
For refcounted (mini)objects you will acquire your own reference which
you must release with a suitable _unref() when no longer needed. For
strings and boxed types you will acquire a copy which you will need to
release with either g_free() or the suiteable function for the boxed type.
because the field requested did not exist, or was of a type other
than the type specified), otherwise TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">FALSE if there was a problem reading any of the fields (e.g.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="first_field_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the quark of the first field to read</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="id_get_valist"
              c:identifier="gst_structure_id_get_valist"
              version="0.10.24"
              introspectable="0">
        <doc xml:whitespace="preserve">Parses the variable arguments and reads fields from @structure accordingly.
valist-variant of gst_structure_id_get(). Look at the documentation of
gst_structure_id_get() for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, or FALSE if there was a problem reading any of the fields</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="first_field_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the quark of the first field to read</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:whitespace="preserve">variable arguments</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_get_value" c:identifier="gst_structure_id_get_value">
        <doc xml:whitespace="preserve">Get the value of the field with GQuark @field.
identifier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue corresponding to the field with the given name</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GQuark of the field to get</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_has_field"
              c:identifier="gst_structure_id_has_field"
              version="0.10.26">
        <doc xml:whitespace="preserve">Check if @structure contains a field named @field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure contains a field with the given name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GQuark of the field name</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_has_field_typed"
              c:identifier="gst_structure_id_has_field_typed"
              version="0.10.26">
        <doc xml:whitespace="preserve">Check if @structure contains a field named @field and with GType @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure contains a field with the given name and type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GQuark of the field name</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of a value</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_set"
              c:identifier="gst_structure_id_set"
              version="0.10.10"
              introspectable="0">
        <doc xml:whitespace="preserve">Identical to gst_structure_set, except that field names are
passed using the GQuark for the field name. This allows more efficient
setting of the structure if the caller already knows the associated
quark values.
The last variable argument must be NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GQuark for the name of the field to set</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="id_set_valist"
              c:identifier="gst_structure_id_set_valist"
              version="0.10.10"
              introspectable="0">
        <doc xml:whitespace="preserve">va_list form of gst_structure_id_set().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to set</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="varargs" transfer-ownership="none">
            <doc xml:whitespace="preserve">variable arguments</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_set_value" c:identifier="gst_structure_id_set_value">
        <doc xml:whitespace="preserve">Sets the field with the given GQuark @field to @value.  If the field
does not exist, it is created.  If the field exists, the previous
value is replaced and freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GQuark representing a field</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value of the field</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_take_value"
              c:identifier="gst_structure_id_take_value"
              version="0.10.31">
        <doc xml:whitespace="preserve">Sets the field with the given GQuark @field to @value.  If the field
does not exist, it is created.  If the field exists, the previous
value is replaced and freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GQuark representing a field</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="value" transfer-ownership="full">
            <doc xml:whitespace="preserve">the new value of the field</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="map_in_place" c:identifier="gst_structure_map_in_place">
        <doc xml:whitespace="preserve">Calls the provided function once for each field in the #GstStructure. In
contrast to gst_structure_foreach(), the function may modify but not delete the
fields. The structure must be mutable.
FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the supplied function returns TRUE For each of the fields,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">a function to call for each field</doc>
            <type name="StructureMapFunc" c:type="GstStructureMapFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">private data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="n_fields" c:identifier="gst_structure_n_fields">
        <doc xml:whitespace="preserve">Get the number of fields in the structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of fields in the structure</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="nth_field_name"
              c:identifier="gst_structure_nth_field_name">
        <doc xml:whitespace="preserve">Get the name of the given field number, counting from 0 onwards.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the given field number</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index to get the name of</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_all_fields"
              c:identifier="gst_structure_remove_all_fields">
        <doc xml:whitespace="preserve">Removes all fields in a GstStructure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="remove_field" c:identifier="gst_structure_remove_field">
        <doc xml:whitespace="preserve">Removes the field with the given name.  If the field with the given
name does not exist, the structure is unchanged.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to remove</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_fields"
              c:identifier="gst_structure_remove_fields"
              introspectable="0">
        <doc xml:whitespace="preserve">Removes the fields with the given names. If a field does not exist, the
argument is ignored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to remove</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="remove_fields_valist"
              c:identifier="gst_structure_remove_fields_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">va_list form of gst_structure_remove_fields().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to remove</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="varargs" transfer-ownership="none">
            <doc xml:whitespace="preserve">NULL-terminated list of more fieldnames to remove</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="gst_structure_set" introspectable="0">
        <doc xml:whitespace="preserve">Parses the variable arguments and sets fields accordingly.
Variable arguments should be in the form field name, field type
(as a GType), value(s).  The last variable argument should be NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="gst_structure_set_name">
        <doc xml:whitespace="preserve">Sets the name of the structure to the given @name.  The string
provided is copied before being used. It must not be empty, start with a
letter and can be followed by letters, numbers and any of "/-_.:".</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new name of the structure</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parent_refcount"
              c:identifier="gst_structure_set_parent_refcount">
        <doc xml:whitespace="preserve">Sets the parent_refcount field of #GstStructure. This field is used to
determine whether a structure is mutable or not. This function should only be
called by code implementing parent objects of #GstStructure, as described in
the MT Refcounting section of the design documents.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="refcount" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to the parent's refcount</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_valist"
              c:identifier="gst_structure_set_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">va_list form of gst_structure_set().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="varargs" transfer-ownership="none">
            <doc xml:whitespace="preserve">variable arguments</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="gst_structure_set_value">
        <doc xml:whitespace="preserve">Sets the field with the given name @field to @value.  If the field
does not exist, it is created.  If the field exists, the previous
value is replaced and freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value of the field</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_value"
              c:identifier="gst_structure_take_value"
              version="0.10.31">
        <doc xml:whitespace="preserve">Sets the field with the given name @field to @value.  If the field
does not exist, it is created.  If the field exists, the previous
value is replaced and freed. The function will take ownership of @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="full">
            <doc xml:whitespace="preserve">the new value of the field</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gst_structure_to_string">
        <doc xml:whitespace="preserve">Converts @structure to a human-readable string representation.
For debugging purposes its easier to do something like this:
|[
GST_LOG ("structure is %" GST_PTR_FORMAT, structure);
]|
This prints the structure in human readble form.
g_free() after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">(transfer full)L a pointer to string allocated by g_malloc().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
    </record>
    <enumeration name="StructureChangeType"
                 version="0.10.22"
                 c:type="GstStructureChangeType">
      <doc xml:whitespace="preserve">The type of a %GST_MESSAGE_STRUCTURE_CHANGE.</doc>
      <member name="link"
              value="0"
              c:identifier="GST_STRUCTURE_CHANGE_TYPE_PAD_LINK"/>
      <member name="unlink"
              value="1"
              c:identifier="GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK"/>
    </enumeration>
    <callback name="StructureForeachFunc" c:type="GstStructureForeachFunc">
      <doc xml:whitespace="preserve">A function that will be called in gst_structure_foreach(). The function may
not modify @value.
the foreach operation should stop with FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the foreach operation should continue, FALSE if</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="field_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GQuark of the field name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue of the field</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="StructureMapFunc" c:type="GstStructureMapFunc">
      <doc xml:whitespace="preserve">A function that will be called in gst_structure_map_in_place(). The function
may modify @value.
the map operation should stop with FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the map operation should continue, FALSE if</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="field_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GQuark of the field name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue of the field</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="SystemClock"
           c:symbol-prefix="system_clock"
           c:type="GstSystemClock"
           parent="Clock"
           glib:type-name="GstSystemClock"
           glib:get-type="gst_system_clock_get_type"
           glib:type-struct="SystemClockClass">
      <doc xml:whitespace="preserve">The GStreamer core provides a GstSystemClock based on the system time.
Asynchronous callbacks are scheduled from an internal thread.
Clock implementors are encouraged to subclass this systemclock as it
implements the async notification.
Subclasses can however override all of the important methods for sync and
async notifications to implement their own callback methods or blocking
wait operations.
Last reviewed on 2006-03-08 (0.10.4)</doc>
      <function name="obtain" c:identifier="gst_system_clock_obtain">
        <doc xml:whitespace="preserve">Get a handle to the default system clock. The refcount of the
clock will be increased so you need to unref the clock after
usage.
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the default clock.</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </function>
      <property name="clock-type"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <field name="clock">
        <type name="Clock" c:type="GstClock"/>
      </field>
      <field name="thread" readable="0" private="1">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="stopping" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SystemClockPrivate" c:type="GstSystemClockPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="SystemClockClass"
            c:type="GstSystemClockClass"
            glib:is-gtype-struct-for="SystemClock">
      <field name="parent_class">
        <type name="ClockClass" c:type="GstClockClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SystemClockPrivate"
            c:type="GstSystemClockPrivate"
            disguised="1">
    </record>
    <constant name="TAG_ALBUM" value="album">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_ARTIST" value="album-artist">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_ARTIST_SORTNAME" value="album-artist-sortname">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_GAIN" value="replaygain-album-gain">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_PEAK" value="replaygain-album-peak">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_SORTNAME" value="album-sortname">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_VOLUME_COUNT" value="album-disc-count">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_VOLUME_NUMBER" value="album-disc-number">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_APPLICATION_DATA" value="application-data">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_APPLICATION_NAME" value="application-name">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ARTIST" value="artist">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ARTIST_SORTNAME" value="musicbrainz-sortname">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ATTACHMENT" value="attachment">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_AUDIO_CODEC" value="audio-codec">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_BEATS_PER_MINUTE" value="beats-per-minute">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_BITRATE" value="bitrate">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_CODEC" value="codec">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_COMMENT" value="comment">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_COMPOSER" value="composer">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_COMPOSER_SORTNAME" value="composer-sortname">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_CONTACT" value="contact">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_CONTAINER_FORMAT" value="container-format">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_COPYRIGHT" value="copyright">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_COPYRIGHT_URI" value="copyright-uri">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DATE" value="date">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DATE_TIME" value="datetime">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DESCRIPTION" value="description">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DEVICE_MANUFACTURER" value="device-manufacturer">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DEVICE_MODEL" value="device-model">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DURATION" value="duration">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ENCODED_BY" value="encoded-by">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ENCODER" value="encoder">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ENCODER_VERSION" value="encoder-version">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_EXTENDED_COMMENT" value="extended-comment">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GENRE" value="genre">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_CAPTURE_DIRECTION"
              value="geo-location-capture-direction">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_CITY" value="geo-location-city">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_COUNTRY" value="geo-location-country">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_ELEVATION" value="geo-location-elevation">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_HORIZONTAL_ERROR"
              value="geo-location-horizontal-error">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_LATITUDE" value="geo-location-latitude">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_LONGITUDE" value="geo-location-longitude">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_MOVEMENT_DIRECTION"
              value="geo-location-movement-direction">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_MOVEMENT_SPEED"
              value="geo-location-movement-speed">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_NAME" value="geo-location-name">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_SUBLOCATION"
              value="geo-location-sublocation">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GROUPING" value="grouping">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_HOMEPAGE" value="homepage">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_IMAGE" value="image">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_IMAGE_ORIENTATION" value="image-orientation">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ISRC" value="isrc">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_KEYWORDS" value="keywords">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LANGUAGE_CODE" value="language-code">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LICENSE" value="license">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LICENSE_URI" value="license-uri">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LOCATION" value="location">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LYRICS" value="lyrics">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_MAXIMUM_BITRATE" value="maximum-bitrate">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_MINIMUM_BITRATE" value="minimum-bitrate">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_NOMINAL_BITRATE" value="nominal-bitrate">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ORGANIZATION" value="organization">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_PERFORMER" value="performer">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_PREVIEW_IMAGE" value="preview-image">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_REFERENCE_LEVEL" value="replaygain-reference-level">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SERIAL" value="serial">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SHOW_EPISODE_NUMBER" value="show-episode-number">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SHOW_NAME" value="show-name">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SHOW_SEASON_NUMBER" value="show-season-number">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SHOW_SORTNAME" value="show-sortname">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SUBTITLE_CODEC" value="subtitle-codec">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TITLE" value="title">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TITLE_SORTNAME" value="title-sortname">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TRACK_COUNT" value="track-count">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TRACK_GAIN" value="replaygain-track-gain">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TRACK_NUMBER" value="track-number">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TRACK_PEAK" value="replaygain-track-peak">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_USER_RATING" value="user-rating">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_VERSION" value="version">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_VIDEO_CODEC" value="video-codec">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TIME_FORMAT" value="u:%02u:%02u.%09u">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="TagFlag" c:type="GstTagFlag">
      <doc xml:whitespace="preserve">Extra tag flags used when registering tags.</doc>
      <member name="undefined"
              value="0"
              c:identifier="GST_TAG_FLAG_UNDEFINED"/>
      <member name="meta" value="1" c:identifier="GST_TAG_FLAG_META"/>
      <member name="encoded" value="2" c:identifier="GST_TAG_FLAG_ENCODED"/>
      <member name="decoded" value="3" c:identifier="GST_TAG_FLAG_DECODED"/>
      <member name="count" value="4" c:identifier="GST_TAG_FLAG_COUNT"/>
    </enumeration>
    <callback name="TagForeachFunc" c:type="GstTagForeachFunc">
      <doc xml:whitespace="preserve">A function that will be called in gst_tag_list_foreach(). The function may
not modify the tag list.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstTagList</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </parameter>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">a name of a tag in @list</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TagList"
            c:type="GstTagList"
            glib:type-name="GstTagList"
            glib:get-type="gst_tag_list_get_type"
            c:symbol-prefix="tag_list">
      <doc xml:whitespace="preserve">List of tags and values used to describe media metadata.
Strings must be in ASCII or UTF-8 encoding. No other encodings are allowed.
Last reviewed on 2009-06-09 (0.10.23)</doc>
      <constructor name="new" c:identifier="gst_tag_list_new">
        <doc xml:whitespace="preserve">Creates a new empty GstTagList.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">An empty tag list</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
      </constructor>
      <constructor name="new_full"
                   c:identifier="gst_tag_list_new_full"
                   version="0.10.24"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new taglist and appends the values for the given tags. It expects
tag-value pairs like gst_tag_list_add(), and a NULL terminator after the
last pair. The type of the values is implicit and is documented in the API
reference, but can also be queried at runtime with gst_tag_get_type(). It
is an error to pass a value of a type not matching the tag type into this
function. The tag list will make copies of any arguments passed
(e.g. strings, buffers).
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstTagList. Free with gst_tag_list_free()</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full_valist"
                   c:identifier="gst_tag_list_new_full_valist"
                   version="0.10.24"
                   introspectable="0">
        <doc xml:whitespace="preserve">Just like gst_tag_list_new_full(), only that it takes a va_list argument.
Useful mostly for language bindings.
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstTagList. Free with gst_tag_list_free()</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
        <parameters>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag / value pairs to set</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="gst_tag_list_add" introspectable="0">
        <doc xml:whitespace="preserve">Sets the values for the given tags using the specified mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_valist"
              c:identifier="gst_tag_list_add_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the values for the given tags using the specified mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag / value pairs to set</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_valist_values"
              c:identifier="gst_tag_list_add_valist_values"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the GValues for the given tags using the specified mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag / GValue pairs to set</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_value"
              c:identifier="gst_tag_list_add_value"
              version="0.10.24">
        <doc xml:whitespace="preserve">Sets the GValue for a given tag using the specified mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">GValue for this tag</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_values"
              c:identifier="gst_tag_list_add_values"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the GValues for the given tags using the specified mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gst_tag_list_copy">
        <doc xml:whitespace="preserve">Copies a given #GstTagList.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">copy of the given list</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
      </method>
      <method name="foreach" c:identifier="gst_tag_list_foreach">
        <doc xml:whitespace="preserve">Calls the given function for each tag inside the tag list. Note that if there
is no tag, the function won't be called at all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">function to be called for each tag</doc>
            <type name="TagForeachFunc" c:type="GstTagForeachFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user specified data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_tag_list_free">
        <doc xml:whitespace="preserve">Frees the given list and all associated values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_boolean" c:identifier="gst_tag_list_get_boolean">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean_index"
              c:identifier="gst_tag_list_get_boolean_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer"
              c:identifier="gst_tag_list_get_buffer"
              version="0.10.23">
        <doc xml:whitespace="preserve">Copies the first buffer for the given tag in the taglist into the variable
pointed to by @value. Free the buffer with gst_buffer_unref() when it is
no longer needed.
given list or if it was #NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a buffer was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a GstBuffer pointer variable to store the result into</doc>
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer_index"
              c:identifier="gst_tag_list_get_buffer_index"
              version="0.10.23">
        <doc xml:whitespace="preserve">Gets the buffer that is at the given index for the given tag in the given
list and copies it into the variable pointed to by @value. Free the buffer
with gst_buffer_unref() when it is no longer needed.
given list or if it was #NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a buffer was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a GstBuffer pointer variable to store the result into</doc>
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_char" c:identifier="gst_tag_list_get_char">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_char_index" c:identifier="gst_tag_list_get_char_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date" c:identifier="gst_tag_list_get_date">
        <doc xml:whitespace="preserve">Copies the first date for the given tag in the taglist into the variable
pointed to by @value. Free the date with g_date_free() when it is no longer
needed.
given list or if it was #NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a date was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a GDate pointer variable to store the result into</doc>
            <type name="GLib.Date" c:type="GDate**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date_index" c:identifier="gst_tag_list_get_date_index">
        <doc xml:whitespace="preserve">Gets the date that is at the given index for the given tag in the given
list and copies it into the variable pointed to by @value. Free the date
with g_date_free() when it is no longer needed.
given list or if it was #NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="GLib.Date" c:type="GDate**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date_time"
              c:identifier="gst_tag_list_get_date_time"
              version="0.10.31">
        <doc xml:whitespace="preserve">Copies the first datetime for the given tag in the taglist into the variable
pointed to by @value. Unref the date with gst_date_time_unref() when
it is no longer needed.
thegiven list or if it was #NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a datetime was copied, FALSE if the tag didn't exist in</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a #GstDateTime pointer variable to store the result into</doc>
            <type name="DateTime" c:type="GstDateTime**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date_time_index"
              c:identifier="gst_tag_list_get_date_time_index"
              version="0.10.31">
        <doc xml:whitespace="preserve">Gets the datetime that is at the given index for the given tag in the given
list and copies it into the variable pointed to by @value. Unref the datetime
with gst_date_time_unref() when it is no longer needed.
given list or if it was #NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="DateTime" c:type="GstDateTime**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="gst_tag_list_get_double">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double_index"
              c:identifier="gst_tag_list_get_double_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float" c:identifier="gst_tag_list_get_float">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float_index"
              c:identifier="gst_tag_list_get_float_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int" c:identifier="gst_tag_list_get_int">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64" c:identifier="gst_tag_list_get_int64">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64_index"
              c:identifier="gst_tag_list_get_int64_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int_index" c:identifier="gst_tag_list_get_int_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_long" c:identifier="gst_tag_list_get_long">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="glong" c:type="glong*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_long_index" c:identifier="gst_tag_list_get_long_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="glong" c:type="glong*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pointer" c:identifier="gst_tag_list_get_pointer">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pointer_index"
              c:identifier="gst_tag_list_get_pointer_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="gst_tag_list_get_string">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, possibly merging
multiple values into one if multiple values are associated with the tag.
Use gst_tag_list_get_string_index (list, tag, 0, value) if you want
to retrieve the first string associated with this tag unmodified.
The resulting string in @value will be in UTF-8 encoding and should be
freed by the caller using g_free when no longer needed. Since 0.10.24 the
returned string is also guaranteed to be non-NULL and non-empty.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string_index"
              c:identifier="gst_tag_list_get_string_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
The resulting string in @value will be in UTF-8 encoding and should be
freed by the caller using g_free when no longer needed. Since 0.10.24 the
returned string is also guaranteed to be non-NULL and non-empty.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_tag_size" c:identifier="gst_tag_list_get_tag_size">
        <doc xml:whitespace="preserve">Checks how many value are stored in this tag list for the given tag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of tags stored</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">the tag to query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uchar" c:identifier="gst_tag_list_get_uchar">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uchar_index"
              c:identifier="gst_tag_list_get_uchar_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint" c:identifier="gst_tag_list_get_uint">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64" c:identifier="gst_tag_list_get_uint64">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64_index"
              c:identifier="gst_tag_list_get_uint64_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint_index" c:identifier="gst_tag_list_get_uint_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ulong" c:identifier="gst_tag_list_get_ulong">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gulong" c:type="gulong*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ulong_index"
              c:identifier="gst_tag_list_get_ulong_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gulong" c:type="gulong*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value_index"
              c:identifier="gst_tag_list_get_value_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.
tag wasn't available or the tag doesn't have as many entries</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The GValue for the specified entry or NULL if the</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="gst_tag_list_insert">
        <doc xml:whitespace="preserve">Inserts the tags of the @from list into the first list using the given mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="from" transfer-ownership="none">
            <doc xml:whitespace="preserve">list to merge from</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="gst_tag_list_is_empty"
              version="0.10.11">
        <doc xml:whitespace="preserve">Checks if the given taglist is empty.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the taglist is empty, otherwise FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="merge" c:identifier="gst_tag_list_merge">
        <doc xml:whitespace="preserve">Merges the two given lists into a new list. If one of the lists is NULL, a
copy of the other is returned. If both lists are NULL, NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new list</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
        <parameters>
          <parameter name="list2" transfer-ownership="none">
            <doc xml:whitespace="preserve">second list to merge</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_string_index"
              c:identifier="gst_tag_list_peek_string_index">
        <doc xml:whitespace="preserve">Peeks at the value that is at the given index for the given tag in the given
list.
The resulting string in @value will be in UTF-8 encoding and doesn't need
to be freed by the caller. The returned string is also guaranteed to
be non-NULL and non-empty.
given list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was set, FALSE if the tag didn't exist in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_tag" c:identifier="gst_tag_list_remove_tag">
        <doc xml:whitespace="preserve">Removes the given tag from the taglist.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to remove</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="TagMergeFunc" c:type="GstTagMergeFunc">
      <doc xml:whitespace="preserve">A function for merging multiple values of a tag used when registering
tags.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:whitespace="preserve">the destination #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="TagMergeMode" c:type="GstTagMergeMode">
      <doc xml:whitespace="preserve">The different tag merging modes are basically replace, overwrite and append,
already in the element and (B) the ones that are supplied to the element (
e.g. via gst_tag_setter_merge_tags() / gst_tag_setter_add_tags() or a
%GST_EVENT_TAG), how are these tags merged?
In the table below this is shown for the cases that a tag exists in the list
(A) or does not exists (!A) and combinations thereof.
&lt;table frame="all" colsep="1" rowsep="1"&gt;
&lt;title&gt;merge mode&lt;/title&gt;
&lt;tgroup cols='5' align='left'&gt;
&lt;thead&gt;
&lt;row&gt;
&lt;entry&gt;merge mode&lt;/entry&gt;
&lt;entry&gt;A + B&lt;/entry&gt;
&lt;entry&gt;A + !B&lt;/entry&gt;
&lt;entry&gt;!A + B&lt;/entry&gt;
&lt;entry&gt;!A + !B&lt;/entry&gt;
&lt;/row&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;row&gt;
&lt;entry&gt;REPLACE_ALL&lt;/entry&gt;
&lt;entry&gt;B&lt;/entry&gt;
&lt;entry&gt;-&lt;/entry&gt;
&lt;entry&gt;B&lt;/entry&gt;
&lt;entry&gt;-&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;REPLACE&lt;/entry&gt;
&lt;entry&gt;B&lt;/entry&gt;
&lt;entry&gt;A&lt;/entry&gt;
&lt;entry&gt;B&lt;/entry&gt;
&lt;entry&gt;-&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;APPEND&lt;/entry&gt;
&lt;entry&gt;A, B&lt;/entry&gt;
&lt;entry&gt;A&lt;/entry&gt;
&lt;entry&gt;B&lt;/entry&gt;
&lt;entry&gt;-&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;PREPEND&lt;/entry&gt;
&lt;entry&gt;B, A&lt;/entry&gt;
&lt;entry&gt;A&lt;/entry&gt;
&lt;entry&gt;B&lt;/entry&gt;
&lt;entry&gt;-&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;KEEP&lt;/entry&gt;
&lt;entry&gt;A&lt;/entry&gt;
&lt;entry&gt;A&lt;/entry&gt;
&lt;entry&gt;B&lt;/entry&gt;
&lt;entry&gt;-&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;KEEP_ALL&lt;/entry&gt;
&lt;entry&gt;A&lt;/entry&gt;
&lt;entry&gt;A&lt;/entry&gt;
&lt;entry&gt;-&lt;/entry&gt;
&lt;entry&gt;-&lt;/entry&gt;
&lt;/row&gt;
&lt;/tbody&gt;
&lt;/tgroup&gt;
&lt;/table&gt;</doc>
      <member name="undefined"
              value="0"
              c:identifier="GST_TAG_MERGE_UNDEFINED"/>
      <member name="replace_all"
              value="1"
              c:identifier="GST_TAG_MERGE_REPLACE_ALL"/>
      <member name="replace" value="2" c:identifier="GST_TAG_MERGE_REPLACE"/>
      <member name="append" value="3" c:identifier="GST_TAG_MERGE_APPEND"/>
      <member name="prepend" value="4" c:identifier="GST_TAG_MERGE_PREPEND"/>
      <member name="keep" value="5" c:identifier="GST_TAG_MERGE_KEEP"/>
      <member name="keep_all" value="6" c:identifier="GST_TAG_MERGE_KEEP_ALL"/>
      <member name="count" value="7" c:identifier="GST_TAG_MERGE_COUNT"/>
    </enumeration>
    <interface name="TagSetter"
               c:symbol-prefix="tag_setter"
               c:type="GstTagSetter"
               glib:type-name="GstTagSetter"
               glib:get-type="gst_tag_setter_get_type">
      <doc xml:whitespace="preserve">Element interface that allows setting of media metadata.
Elements that support changing a stream's metadata will implement this
interface. Examples of such elements are 'vorbisenc', 'theoraenc' and
'id3v2mux'.
If you just want to retrieve metadata in your application then all you
need to do is watch for tag messages on your pipeline's bus. This
interface is only for setting metadata, not for extracting it. To set tags
from the application, find tagsetter elements and set tags using e.g.
gst_tag_setter_merge_tags() or gst_tag_setter_add_tags(). Also consider
setting the #GstTagMergeMode that is used for tag events that arrive at the
tagsetter element (default mode is to keep existing tags).
The application should do that before the element goes to %GST_STATE_PAUSED.
Elements implementing the #GstTagSetter interface often have to merge
any tags received from upstream and the tags set by the application via
the interface. This can be done like this:
|[
GstTagMergeMode merge_mode;
const GstTagList *application_tags;
const GstTagList *event_tags;
GstTagSetter *tagsetter;
GstTagList *result;
tagsetter = GST_TAG_SETTER (element);
merge_mode = gst_tag_setter_get_tag_merge_mode (tagsetter);
application_tags = gst_tag_setter_get_tag_list (tagsetter);
event_tags = (const GstTagList *) element-&gt;event_tags;
GST_LOG_OBJECT (tagsetter, "merging tags, merge mode = %d", merge_mode);
result = gst_tag_list_merge (application_tags, event_tags, merge_mode);
]|
Last reviewed on 2006-05-18 (0.10.6)</doc>
      <prerequisite name="Element"/>
      <method name="add_tag_valist"
              c:identifier="gst_tag_setter_add_tag_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds the given tag / value pairs on the setter using the given merge mode.
The list must be terminated with NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag / value pairs to set</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_tag_valist_values"
              c:identifier="gst_tag_setter_add_tag_valist_values"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds the given tag / GValue pairs on the setter using the given merge mode.
The list must be terminated with NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag / GValue pairs to set</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_tag_value"
              c:identifier="gst_tag_setter_add_tag_value"
              version="0.10.24">
        <doc xml:whitespace="preserve">Adds the given tag / GValue pair on the setter using the given merge mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">GValue to set for the tag</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_tag_values"
              c:identifier="gst_tag_setter_add_tag_values"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds the given tag / GValue pairs on the setter using the given merge mode.
The list must be terminated with NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_tags"
              c:identifier="gst_tag_setter_add_tags"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds the given tag / value pairs on the setter using the given merge mode.
The list must be terminated with NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="get_tag_list" c:identifier="gst_tag_setter_get_tag_list">
        <doc xml:whitespace="preserve">Returns the current list of tags the setter uses.  The list should not be
modified or freed.
This function is not thread-safe.
setter or NULL if none is used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a current snapshot of the taglist used in the</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
      </method>
      <method name="get_tag_merge_mode"
              c:identifier="gst_tag_setter_get_tag_merge_mode">
        <doc xml:whitespace="preserve">Queries the mode by which tags inside the setter are overwritten by tags
from events</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the merge mode used inside the element.</doc>
          <type name="TagMergeMode" c:type="GstTagMergeMode"/>
        </return-value>
      </method>
      <method name="merge_tags" c:identifier="gst_tag_setter_merge_tags">
        <doc xml:whitespace="preserve">Merges the given list into the setter's list using the given mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a tag list to merge from</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to merge with</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset_tags"
              c:identifier="gst_tag_setter_reset_tags"
              version="0.10.22">
        <doc xml:whitespace="preserve">Reset the internal taglist. Elements should call this from within the
state-change handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_tag_merge_mode"
              c:identifier="gst_tag_setter_set_tag_merge_mode">
        <doc xml:whitespace="preserve">Sets the given merge mode that is used for adding tags from events to tags
specified by this interface. The default is #GST_TAG_MERGE_KEEP, which keeps
the tags set with this interface and discards tags from events.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">The mode with which tags are added</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="TagSetterIFace" c:type="GstTagSetterIFace">
      <doc xml:whitespace="preserve">#GstTagSetterIFace interface.</doc>
      <field name="g_iface" writable="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
    </record>
    <class name="Task"
           c:symbol-prefix="task"
           c:type="GstTask"
           parent="Object"
           glib:type-name="GstTask"
           glib:get-type="gst_task_get_type"
           glib:type-struct="TaskClass">
      <doc xml:whitespace="preserve">#GstTask is used by #GstElement and #GstPad to provide the data passing
threads in a #GstPipeline.
A #GstPad will typically start a #GstTask to push or pull data to/from the
peer pads. Most source elements start a #GstTask to push data. In some cases
a demuxer element can start a #GstTask to pull data from a peer element. This
is typically done when the demuxer can perform random access on the upstream
peer element for improved performance.
Although convenience functions exist on #GstPad to start/pause/stop tasks, it
might sometimes be needed to create a #GstTask manually if it is not related to
a #GstPad.
Before the #GstTask can be run, it needs a #GStaticRecMutex that can be set with
gst_task_set_lock().
The task can be started, paused and stopped with gst_task_start(), gst_task_pause()
and gst_task_stop() respectively or with the gst_task_set_state() function.
A #GstTask will repeatedly call the #GstTaskFunction with the user data
that was provided when creating the task with gst_task_create(). While calling
the function it will acquire the provided lock. The provided lock is released
when the task pauses or stops.
Stopping a task with gst_task_stop() will not immediately make sure the task is
not running anymore. Use gst_task_join() to make sure the task is completely
stopped and the thread is stopped.
After creating a #GstTask, use gst_object_unref() to free its resources. This can
only be done it the task is not running anymore.
Task functions can send a #GstMessage to send out-of-band data to the
application. The application can receive messages from the #GstBus in its
mainloop.
For debugging perposes, the task will configure its object name as the thread
name on Linux. Please note that the object name should be configured before the
task is started; changing the object name after the task has been started, has
no effect on the thread name.
Last reviewed on 2010-03-15 (0.10.29)</doc>
      <function name="cleanup_all" c:identifier="gst_task_cleanup_all">
        <doc xml:whitespace="preserve">Wait for all tasks to be stopped. This is mainly used internally
to ensure proper cleanup of internal data structures in test suites.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="create"
                c:identifier="gst_task_create"
                introspectable="0">
        <doc xml:whitespace="preserve">Create a new Task that will repeatedly call the provided @func
with @data as a parameter. Typically the task will run in
a new thread.
The function cannot be changed after the task has been created. You
must create a new #GstTask to change the function.
This function will not yet create and start a thread. Use gst_task_start() or
gst_task_pause() to create and start the GThread.
Before the task can be used, a #GStaticRecMutex must be configured using the
gst_task_set_lock() function. This lock will always be acquired while
MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #GstTask.</doc>
          <type name="Task" c:type="GstTask*"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">The #GstTaskFunction to use</doc>
            <type name="TaskFunction" c:type="GstTaskFunction"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">User data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_pool"
              c:identifier="gst_task_get_pool"
              version="0.10.24">
        <doc xml:whitespace="preserve">Get the #GstTaskPool that this task will use for its streaming
threads.
MT safe.
after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstTaskPool used by @task. gst_object_unref()</doc>
          <type name="TaskPool" c:type="GstTaskPool*"/>
        </return-value>
      </method>
      <method name="get_state" c:identifier="gst_task_get_state">
        <doc xml:whitespace="preserve">Get the current state of the task.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstTaskState of the task</doc>
          <type name="TaskState" c:type="GstTaskState"/>
        </return-value>
      </method>
      <method name="join" c:identifier="gst_task_join">
        <doc xml:whitespace="preserve">Joins @task. After this call, it is safe to unref the task
and clean up the lock set with gst_task_set_lock().
The task will automatically be stopped with this call.
This function cannot be called from within a task function as this
would cause a deadlock. The function will detect this and print a
g_warning.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the task could be joined.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="pause" c:identifier="gst_task_pause">
        <doc xml:whitespace="preserve">Pauses @task. This method can also be called on a task in the
stopped state, in which case a thread will be started and will remain
in the paused state. This function does not wait for the task to complete
the paused state.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the task could be paused.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_lock" c:identifier="gst_task_set_lock">
        <doc xml:whitespace="preserve">Set the mutex used by the task. The mutex will be acquired before
calling the #GstTaskFunction.
This function has to be called before calling gst_task_pause() or
gst_task_start().
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mutex" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GMutex to use</doc>
            <type name="GLib.StaticRecMutex" c:type="GStaticRecMutex*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pool"
              c:identifier="gst_task_set_pool"
              version="0.10.24">
        <doc xml:whitespace="preserve">Set @pool as the new GstTaskPool for @task. Any new streaming threads that
will be created by @task will now use @pool.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pool" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstTaskPool</doc>
            <type name="TaskPool" c:type="GstTaskPool*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority"
              c:identifier="gst_task_set_priority"
              version="0.10.24">
        <doc xml:whitespace="preserve">Changes the priority of @task to @priority.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new priority for @task</doc>
            <type name="GLib.ThreadPriority" c:type="GThreadPriority"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_state"
              c:identifier="gst_task_set_state"
              version="0.10.24">
        <doc xml:whitespace="preserve">Sets the state of @task to @state.
The @task must have a lock associated with it using
gst_task_set_lock() when going to GST_TASK_STARTED or GST_TASK_PAUSED or
this function will return %FALSE.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the state could be changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new task state</doc>
            <type name="TaskState" c:type="GstTaskState"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_thread_callbacks"
              c:identifier="gst_task_set_thread_callbacks"
              version="0.10.24">
        <doc xml:whitespace="preserve">Set callbacks which will be executed when a new thread is needed, the thread
function is entered and left and when the thread is joined.
By default a thread for @task will be created from a default thread pool.
Objects can use custom GThreads or can perform additional configuration of
the threads (such as changing the thread priority) by installing callbacks.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callbacks" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstTaskThreadCallbacks pointer</doc>
            <type name="TaskThreadCallbacks" c:type="GstTaskThreadCallbacks*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the callbacks</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called when @user_data is no longer referenced</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="gst_task_start">
        <doc xml:whitespace="preserve">Starts @task. The @task must have a lock associated with it using
gst_task_set_lock() or this function will return %FALSE.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the task could be started.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="stop" c:identifier="gst_task_stop">
        <doc xml:whitespace="preserve">Stops @task. This method merely schedules the task to stop and
will not wait for the task to have completely stopped. Use
gst_task_join() to stop and wait for completion.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the task could be stopped.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="state">
        <type name="TaskState" c:type="GstTaskState"/>
      </field>
      <field name="cond">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="lock">
        <type name="GLib.StaticRecMutex" c:type="GStaticRecMutex*"/>
      </field>
      <field name="func">
        <type name="TaskFunction" c:type="GstTaskFunction"/>
      </field>
      <field name="data">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="running">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="thread" writable="1">
            <type name="GLib.Thread" c:type="GThread*"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="3">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
      <field name="priv">
        <type name="TaskPrivate" c:type="GstTaskPrivate*"/>
      </field>
    </class>
    <record name="TaskClass"
            c:type="GstTaskClass"
            glib:is-gtype-struct-for="Task">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="pool" readable="0" private="1">
        <type name="TaskPool" c:type="GstTaskPool*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="TaskFunction" c:type="GstTaskFunction">
      <doc xml:whitespace="preserve">A function that will repeatedly be called in the thread created by
a #GstTask.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data passed to the function</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="TaskPool"
           c:symbol-prefix="task_pool"
           c:type="GstTaskPool"
           parent="Object"
           glib:type-name="GstTaskPool"
           glib:get-type="gst_task_pool_get_type"
           glib:type-struct="TaskPoolClass">
      <doc xml:whitespace="preserve">This object provides an abstraction for creating threads. The default
implementation uses a regular GThreadPool to start tasks.
Subclasses can be made to create custom threads.
Last reviewed on 2009-04-23 (0.10.24)</doc>
      <constructor name="new"
                   c:identifier="gst_task_pool_new"
                   version="0.10.24">
        <doc xml:whitespace="preserve">Create a new default task pool. The default task pool will use a regular
GThreadPool for threads.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstTaskPool. gst_object_unref() after usage.</doc>
          <type name="TaskPool" c:type="GstTaskPool*"/>
        </return-value>
      </constructor>
      <virtual-method name="cleanup" invoker="cleanup" version="0.10.24">
        <doc xml:whitespace="preserve">Wait for all tasks to be stopped. This is mainly used internally
to ensure proper cleanup of internal data structures in test suites.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="join" invoker="join" version="0.10.24">
        <doc xml:whitespace="preserve">Join a task and/or return it to the pool. @id is the id obtained from 
gst_task_pool_push().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare"
                      invoker="prepare"
                      version="0.10.24"
                      throws="1">
        <doc xml:whitespace="preserve">Prepare the taskpool for accepting gst_task_pool_push() operations.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="push"
                      invoker="push"
                      version="0.10.24"
                      introspectable="0"
                      throws="1">
        <doc xml:whitespace="preserve">Start the execution of a new thread from @pool.
function. This pointer can be NULL, you must check @error to detect
errors.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a pointer that should be used for the gst_task_pool_join</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the function to call</doc>
            <type name="TaskPoolFunction" c:type="GstTaskPoolFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="cleanup"
              c:identifier="gst_task_pool_cleanup"
              version="0.10.24">
        <doc xml:whitespace="preserve">Wait for all tasks to be stopped. This is mainly used internally
to ensure proper cleanup of internal data structures in test suites.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="join" c:identifier="gst_task_pool_join" version="0.10.24">
        <doc xml:whitespace="preserve">Join a task and/or return it to the pool. @id is the id obtained from 
gst_task_pool_push().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare"
              c:identifier="gst_task_pool_prepare"
              version="0.10.24"
              throws="1">
        <doc xml:whitespace="preserve">Prepare the taskpool for accepting gst_task_pool_push() operations.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="push"
              c:identifier="gst_task_pool_push"
              version="0.10.24"
              introspectable="0"
              throws="1">
        <doc xml:whitespace="preserve">Start the execution of a new thread from @pool.
function. This pointer can be NULL, you must check @error to detect
errors.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a pointer that should be used for the gst_task_pool_join</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the function to call</doc>
            <type name="TaskPoolFunction" c:type="GstTaskPoolFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="pool" readable="0" private="1">
        <type name="GLib.ThreadPool" c:type="GThreadPool*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="TaskPoolClass"
            c:type="GstTaskPoolClass"
            glib:is-gtype-struct-for="TaskPool">
      <doc xml:whitespace="preserve">The #GstTaskPoolClass object.</doc>
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="prepare">
        <callback name="prepare" throws="1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="TaskPool" c:type="GstTaskPool*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cleanup">
        <callback name="cleanup">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="TaskPool" c:type="GstTaskPool*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="push" introspectable="0">
        <callback name="push" introspectable="0" throws="1">
          <return-value>
            <doc xml:whitespace="preserve">a pointer that should be used for the gst_task_pool_join</doc>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="TaskPool" c:type="GstTaskPool*"/>
            </parameter>
            <parameter name="func" transfer-ownership="none" closure="2">
              <doc xml:whitespace="preserve">the function to call</doc>
              <type name="TaskPoolFunction" c:type="GstTaskPoolFunction"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="2">
              <doc xml:whitespace="preserve">data to pass to @func</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="join">
        <callback name="join">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="TaskPool" c:type="GstTaskPool*"/>
            </parameter>
            <parameter name="id" transfer-ownership="none">
              <doc xml:whitespace="preserve">the id</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="TaskPoolFunction"
              c:type="GstTaskPoolFunction"
              version="0.10.24">
      <doc xml:whitespace="preserve">Task function, see gst_task_pool_push().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data for the task function</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TaskPrivate" c:type="GstTaskPrivate" disguised="1">
    </record>
    <enumeration name="TaskState" c:type="GstTaskState">
      <doc xml:whitespace="preserve">The different states a task can be in</doc>
      <member name="started" value="0" c:identifier="GST_TASK_STARTED"/>
      <member name="stopped" value="1" c:identifier="GST_TASK_STOPPED"/>
      <member name="paused" value="2" c:identifier="GST_TASK_PAUSED"/>
    </enumeration>
    <record name="TaskThreadCallbacks"
            c:type="GstTaskThreadCallbacks"
            version="0.10.24">
      <doc xml:whitespace="preserve">Custom GstTask thread callback functions that can be installed.</doc>
      <field name="enter_thread">
        <callback name="enter_thread">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="task" transfer-ownership="none">
              <type name="Task" c:type="GstTask*"/>
            </parameter>
            <parameter name="thread" transfer-ownership="none">
              <type name="GLib.Thread" c:type="GThread*"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="2">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="leave_thread">
        <callback name="leave_thread">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="task" transfer-ownership="none">
              <type name="Task" c:type="GstTask*"/>
            </parameter>
            <parameter name="thread" transfer-ownership="none">
              <type name="GLib.Thread" c:type="GThread*"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="2">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="Trace" c:type="GstTrace">
      <doc xml:whitespace="preserve">Traces allows to track object allocation. They provide a instance counter per
#GType. The counter is incremented for each object allocated and decremented
it when it's freed.
&lt;example&gt;
&lt;title&gt;Tracing object instances&lt;/title&gt;
&lt;programlisting&gt;
// trace un-freed object instances
gst_alloc_trace_set_flags_all (GST_ALLOC_TRACE_LIVE);
if (!gst_alloc_trace_available ()) {
g_warning ("Trace not available (recompile with trace enabled).");
}
gst_alloc_trace_print_live ();
// do something here
gst_alloc_trace_print_live ();
&lt;/programlisting&gt;
&lt;/example&gt;
Last reviewed on 2005-11-21 (0.9.5)</doc>
      <field name="filename" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="fd" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="buf" readable="0" private="1">
        <type name="TraceEntry" c:type="GstTraceEntry*"/>
      </field>
      <field name="bufsize" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="bufoffset" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <method name="destroy" c:identifier="gst_trace_destroy">
        <doc xml:whitespace="preserve">Flush an close the previously allocated @trace.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="flush" c:identifier="gst_trace_flush">
        <doc xml:whitespace="preserve">Flush any pending trace entries in @trace to the trace file.
flushed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_default" c:identifier="gst_trace_set_default">
        <doc xml:whitespace="preserve">Set the default #GstTrace to @trace.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="text_flush" c:identifier="gst_trace_text_flush">
        <doc xml:whitespace="preserve">Flush any pending trace entries in @trace to the trace file,
formatted as a text line with timestamp and sequence numbers.
flushed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="TraceEntry" c:type="GstTraceEntry">
      <field name="timestamp" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="sequence" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="data" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="message" writable="1">
        <array zero-terminated="0" c:type="gchar" fixed-size="112">
          <type name="gchar" c:type="gchar"/>
        </array>
      </field>
    </record>
    <record name="TypeFind" c:type="GstTypeFind">
      <doc xml:whitespace="preserve">The following functions allow you to detect the media type of an unknown
stream.
Last reviewed on 2005-11-09 (0.9.4)</doc>
      <field name="peek">
        <callback name="peek">
          <return-value transfer-ownership="none">
            <type name="guint8" c:type="guint8*"/>
          </return-value>
          <parameters>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="suggest">
        <callback name="suggest">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="probability" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="get_length">
        <callback name="get_length">
          <return-value transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </return-value>
          <parameters>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="get_length" c:identifier="gst_type_find_get_length">
        <doc xml:whitespace="preserve">Get the length of the data stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The length of the data stream, or 0 if it is not available.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="peek" c:identifier="gst_type_find_peek">
        <doc xml:whitespace="preserve">Returns the @size bytes of the stream to identify beginning at offset. If
offset is a positive number, the offset is relative to the beginning of the
stream, if offset is a negative number the offset is relative to the end of
the stream. The returned memory is valid until the typefinding function
returns and must not be freed.
if that data is not available.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the requested data, or NULL</doc>
          <array length="1" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The offset</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">The number of bytes to return</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="suggest" c:identifier="gst_type_find_suggest">
        <doc xml:whitespace="preserve">If a #GstTypeFindFunction calls this function it suggests the caps with the
given probability. A #GstTypeFindFunction may supply different suggestions
in one call.
It is up to the caller of the #GstTypeFindFunction to interpret these values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="probability" transfer-ownership="none">
            <doc xml:whitespace="preserve">The probability in percent that the suggestion is right</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">The fixed #GstCaps to suggest</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="suggest_simple"
              c:identifier="gst_type_find_suggest_simple"
              version="0.10.20"
              introspectable="0">
        <doc xml:whitespace="preserve">If a #GstTypeFindFunction calls this function it suggests the caps with the
given probability. A #GstTypeFindFunction may supply different suggestions
in one call. It is up to the caller of the #GstTypeFindFunction to interpret
these values.
This function is similar to gst_type_find_suggest(), only that instead of
passing a #GstCaps argument you can create the caps on the fly in the same
way as you can with gst_caps_new_simple().
Make sure you terminate the list of arguments with a NULL argument and that
the values passed have the correct type (in terms of width in bytes when
passed to the vararg function - this applies particularly to gdouble and
guint64 arguments).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="probability" transfer-ownership="none">
            <doc xml:whitespace="preserve">The probability in percent that the suggestion is right</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="media_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the media type of the suggested caps</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">first field of the suggested caps, or NULL</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="TypeFindFactory"
           c:symbol-prefix="type_find_factory"
           c:type="GstTypeFindFactory"
           parent="PluginFeature"
           glib:type-name="GstTypeFindFactory"
           glib:get-type="gst_type_find_factory_get_type"
           glib:type-struct="TypeFindFactoryClass">
      <doc xml:whitespace="preserve">These functions allow querying informations about registered typefind
functions. How to create and register these functions is described in
the section &lt;link linkend="gstreamer-Writing-typefind-functions"&gt;
"Writing typefind functions"&lt;/link&gt;.
&lt;example&gt;
&lt;title&gt;how to write a simple typefinder&lt;/title&gt;
&lt;programlisting&gt;
typedef struct {
guint8 *data;
guint size;
guint probability;
GstCaps *data;
} MyTypeFind;
static void
my_peek (gpointer data, gint64 offset, guint size)
{
MyTypeFind *find = (MyTypeFind *) data;
if (offset &amp;gt;= 0 &amp;amp;&amp;amp; offset + size &amp;lt;= find-&gt;size) {
return find-&gt;data + offset;
}
return NULL;
}
static void
my_suggest (gpointer data, guint probability, GstCaps *caps)
{
MyTypeFind *find = (MyTypeFind *) data;
if (probability &amp;gt; find-&gt;probability) {
find-&gt;probability = probability;
gst_caps_replace (&amp;amp;find-&gt;caps, caps);
}
}
static GstCaps *
find_type (guint8 *data, guint size)
{
GList *walk, *type_list;
MyTypeFind find = {data, size, 0, NULL};
GstTypeFind gst_find = {my_peek, my_suggest, &amp;amp;find, };
walk = type_list = gst_type_find_factory_get_list ();
while (walk) {
GstTypeFindFactory *factory = GST_TYPE_FIND_FACTORY (walk-&gt;data);
walk = g_list_next (walk)
gst_type_find_factory_call_function (factory, &amp;amp;gst_find);
}
g_list_free (type_list);
return find.caps;
};
&lt;/programlisting&gt;
&lt;/example&gt;
The above example shows how to write a very simple typefinder that
identifies the given data. You can get quite a bit more complicated than
that though.
Last reviewed on 2005-11-09 (0.9.4)</doc>
      <function name="get_list" c:identifier="gst_type_find_factory_get_list">
        <doc xml:whitespace="preserve">Gets the list of all registered typefind factories. You must free the
list using gst_plugin_feature_list_free().
The returned factories are sorted by highest rank first, and then by
factory name. (behaviour change since 0.10.26)
registered #GstTypeFindFactory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the list of all</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TypeFindFactory"/>
          </type>
        </return-value>
      </function>
      <method name="call_function"
              c:identifier="gst_type_find_factory_call_function">
        <doc xml:whitespace="preserve">Calls the #GstTypeFindFunction associated with this factory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="find" transfer-ownership="none">
            <doc xml:whitespace="preserve">a properly setup #GstTypeFind entry. The get_data and suggest_type members must be set.</doc>
            <type name="TypeFind" c:type="GstTypeFind*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_caps" c:identifier="gst_type_find_factory_get_caps">
        <doc xml:whitespace="preserve">Gets the #GstCaps associated with a typefind factory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstCaps associated with this factory</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_extensions"
              c:identifier="gst_type_find_factory_get_extensions">
        <doc xml:whitespace="preserve">Gets the extensions associated with a #GstTypeFindFactory. The returned
array should not be changed. If you need to change stuff in it, you should
copy it using g_strdupv().  This function may return NULL to indicate
a 0-length list.
NULL-terminated array of extensions associated with this factory</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <field name="feature">
        <type name="PluginFeature" c:type="GstPluginFeature"/>
      </field>
      <field name="function" readable="0" private="1">
        <type name="TypeFindFunction" c:type="GstTypeFindFunction"/>
      </field>
      <field name="extensions" readable="0" private="1">
        <type name="utf8" c:type="gchar**"/>
      </field>
      <field name="caps" readable="0" private="1">
        <type name="Caps" c:type="GstCaps*"/>
      </field>
      <field name="user_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="user_data_notify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="TypeFindFactoryClass"
            c:type="GstTypeFindFactoryClass"
            glib:is-gtype-struct-for="TypeFindFactory">
      <field name="parent">
        <type name="PluginFeatureClass" c:type="GstPluginFeatureClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="TypeFindFunction" c:type="GstTypeFindFunction">
      <doc xml:whitespace="preserve">A function that will be called by typefinding.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="find" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstTypeFind structure</doc>
          <type name="TypeFind" c:type="GstTypeFind*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">optionnal data to pass to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="TypeFindProbability" c:type="GstTypeFindProbability">
      <doc xml:whitespace="preserve">The probability of the typefind function. Higher values have more certainty
in doing a reliable typefind.</doc>
      <member name="minimum" value="1" c:identifier="GST_TYPE_FIND_MINIMUM"/>
      <member name="possible"
              value="50"
              c:identifier="GST_TYPE_FIND_POSSIBLE"/>
      <member name="likely" value="80" c:identifier="GST_TYPE_FIND_LIKELY"/>
      <member name="nearly_certain"
              value="99"
              c:identifier="GST_TYPE_FIND_NEARLY_CERTAIN"/>
      <member name="maximum" value="100" c:identifier="GST_TYPE_FIND_MAXIMUM"/>
    </enumeration>
    <record name="TypeNameData" c:type="GstTypeNameData">
      <doc xml:whitespace="preserve">Structure used for filtering based on @name and @type.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
    </record>
    <interface name="URIHandler"
               c:symbol-prefix="uri_handler"
               c:type="GstURIHandler"
               glib:type-name="GstURIHandler"
               glib:get-type="gst_uri_handler_get_type"
               glib:type-struct="URIHandlerInterface">
      <doc xml:whitespace="preserve">The URIHandler is an interface that is implemented by Source and Sink 
#GstElement to simplify then handling of URI.
An application can use the following functions to quickly get an element
that handles the given URI for reading or writing
(gst_element_make_from_uri()).
Source and Sink plugins should implement this interface when possible.
Last reviewed on 2005-11-09 (0.9.4)</doc>
      <virtual-method name="get_uri" invoker="get_uri">
        <doc xml:whitespace="preserve">Gets the currently handled URI.
Returns NULL if there are no URI currently handled. The
returned string must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the URI currently handled by the @handler.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="new_uri" invoker="new_uri">
        <doc xml:whitespace="preserve">Emits the new-uri signal for a given handler, when that handler has a new URI.
This function should only be called by URI handlers themselves.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">new URI or NULL if it was unset</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_uri" invoker="set_uri">
        <doc xml:whitespace="preserve">Tries to set the URI of the given handler.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the URI was set successfully, else FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">URI to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_protocols"
              c:identifier="gst_uri_handler_get_protocols">
        <doc xml:whitespace="preserve">Gets the list of protocols supported by @handler. This list may not be
modified.
supported protocols. Returns NULL if the @handler isn't implemented
properly, or the @handler doesn't support any protocols.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_uri" c:identifier="gst_uri_handler_get_uri">
        <doc xml:whitespace="preserve">Gets the currently handled URI.
Returns NULL if there are no URI currently handled. The
returned string must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the URI currently handled by the @handler.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_uri_type" c:identifier="gst_uri_handler_get_uri_type">
        <doc xml:whitespace="preserve">Gets the type of the given URI handler
Returns #GST_URI_UNKNOWN if the @handler isn't implemented correctly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstURIType of the URI handler.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="new_uri" c:identifier="gst_uri_handler_new_uri">
        <doc xml:whitespace="preserve">Emits the new-uri signal for a given handler, when that handler has a new URI.
This function should only be called by URI handlers themselves.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">new URI or NULL if it was unset</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri" c:identifier="gst_uri_handler_set_uri">
        <doc xml:whitespace="preserve">Tries to set the URI of the given handler.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the URI was set successfully, else FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">URI to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="new-uri">
        <doc xml:whitespace="preserve">The URI of the given @handler has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new URI, or NULL if the URI was removed</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="URIHandlerInterface"
            c:type="GstURIHandlerInterface"
            glib:is-gtype-struct-for="URIHandler">
      <doc xml:whitespace="preserve">Any #GstElement using this interface should implement these methods.</doc>
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="new_uri">
        <callback name="new_uri">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="handler" transfer-ownership="none">
              <type name="URIHandler" c:type="GstURIHandler*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <doc xml:whitespace="preserve">new URI or NULL if it was unset</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_type">
        <callback name="get_type">
          <return-value transfer-ownership="none">
            <type name="URIType" c:type="GstURIType"/>
          </return-value>
        </callback>
      </field>
      <field name="get_protocols" introspectable="0">
        <callback name="get_protocols" introspectable="0">
          <return-value>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
        </callback>
      </field>
      <field name="get_uri">
        <callback name="get_uri">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the URI currently handled by the @handler.</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="handler" transfer-ownership="none">
              <type name="URIHandler" c:type="GstURIHandler*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_uri">
        <callback name="set_uri">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the URI was set successfully, else FALSE.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="handler" transfer-ownership="none">
              <type name="URIHandler" c:type="GstURIHandler*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <doc xml:whitespace="preserve">URI to set</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_type_full">
        <callback name="get_type_full">
          <return-value transfer-ownership="none">
            <type name="URIType" c:type="GstURIType"/>
          </return-value>
          <parameters>
            <parameter name="type" transfer-ownership="none">
              <type name="GType" c:type="GType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_protocols_full" introspectable="0">
        <callback name="get_protocols_full" introspectable="0">
          <return-value>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="type" transfer-ownership="none">
              <type name="GType" c:type="GType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="URIType" c:type="GstURIType">
      <doc xml:whitespace="preserve">The different types of URI direction.</doc>
      <member name="unknown" value="0" c:identifier="GST_URI_UNKNOWN"/>
      <member name="sink" value="1" c:identifier="GST_URI_SINK"/>
      <member name="src" value="2" c:identifier="GST_URI_SRC"/>
    </enumeration>
    <constant name="USECOND" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VALUE_EQUAL" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VALUE_GREATER_THAN" value="1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VALUE_LESS_THAN" value="-1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VALUE_UNORDERED" value="2">
      <type name="gint" c:type="gint"/>
    </constant>
    <callback name="ValueCompareFunc" c:type="GstValueCompareFunc">
      <doc xml:whitespace="preserve">Used together with gst_value_compare() to compare #GValue items.
or GST_VALUE_UNORDERED</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">one of GST_VALUE_LESS_THAN, GST_VALUE_EQUAL, GST_VALUE_GREATER_THAN</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">first value for comparison</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">second value for comparison</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ValueDeserializeFunc" c:type="GstValueDeserializeFunc">
      <doc xml:whitespace="preserve">Used by gst_value_deserialize() to parse a non-binary form into the #GValue.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE for success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="s" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ValueIntersectFunc" c:type="GstValueIntersectFunc">
      <doc xml:whitespace="preserve">Used by gst_value_intersect() to perform intersection for a specific #GValue
type. If the intersection is non-empty, the result is
placed in @dest and TRUE is returned.  If the intersection is
empty, @dest is unmodified and FALSE is returned.
Register a new implementation with gst_value_register_intersect_func().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the values can intersect</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue for the result</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue operand</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue operand</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ValueSerializeFunc" c:type="GstValueSerializeFunc">
      <doc xml:whitespace="preserve">Used by gst_value_serialize() to obtain a non-binary form of the #GValue.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the string representation of the value</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ValueSubtractFunc" c:type="GstValueSubtractFunc">
      <doc xml:whitespace="preserve">Used by gst_value_subtract() to perform subtraction for a specific #GValue
type. Register a new implementation with gst_value_register_subtract_func().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the subtraction is not empty</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue for the result</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="minuend" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue operand</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="subtrahend" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue operand</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ValueTable" c:type="GstValueTable">
      <doc xml:whitespace="preserve">VTable for the #GValue @type.</doc>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="compare" writable="1">
        <type name="ValueCompareFunc" c:type="GstValueCompareFunc"/>
      </field>
      <field name="serialize" writable="1">
        <type name="ValueSerializeFunc" c:type="GstValueSerializeFunc"/>
      </field>
      <field name="deserialize" writable="1">
        <type name="ValueDeserializeFunc" c:type="GstValueDeserializeFunc"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="void*"/>
        </array>
      </field>
    </record>
    <callback name="ValueUnionFunc" c:type="GstValueUnionFunc">
      <doc xml:whitespace="preserve">Used by gst_value_union() to perform unification for a specific #GValue
type. Register a new implementation with gst_value_register_union_func().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if a union was successful</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue for the result</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue operand</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue operand</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="XML"
           c:symbol-prefix="xml"
           c:type="GstXML"
           parent="Object"
           glib:type-name="GstXML"
           glib:get-type="gst_xml_get_type"
           glib:type-struct="XMLClass">
      <doc xml:whitespace="preserve">GStreamer pipelines can be saved to xml files using gst_xml_write_file().
They can be loaded back using gst_xml_parse_doc() / gst_xml_parse_file() / 
gst_xml_parse_memory().
Additionally one can load saved pipelines into the gst-editor to inspect the
graph.
#GstElement implementations need to override the #GstObjectClass.save_thyself()
and #GstObjectClass.restore_thyself() virtual functions of #GstObject.
broken for all but the most simple pipelines. It will most likely be
removed in future. Don't use it.</doc>
      <constructor name="new" c:identifier="gst_xml_new">
        <doc xml:whitespace="preserve">Create a new GstXML parser object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to a new GstXML object.</doc>
          <type name="XML" c:type="GstXML*"/>
        </return-value>
      </constructor>
      <function name="make_element"
                c:identifier="gst_xml_make_element"
                introspectable="0">
        <doc xml:whitespace="preserve">Load the element from the XML description</doc>
        <return-value>
          <doc xml:whitespace="preserve">the new element</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="cur" transfer-ownership="none">
            <doc xml:whitespace="preserve">the xml node</doc>
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent of this object when it's loaded</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="write" c:identifier="gst_xml_write" introspectable="0">
        <doc xml:whitespace="preserve">Converts the given element into an XML presentation.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a pointer to an XML document</doc>
          <type name="libxml2.DocPtr" c:type="xmlDocPtr"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">The element to write out</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </function>
      <function name="write_file" c:identifier="gst_xml_write_file">
        <doc xml:whitespace="preserve">Converts the given element into XML and writes the formatted XML to an open
file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">number of bytes written on success, -1 otherwise.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">The element to write out</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:whitespace="preserve">an open file, like stdout</doc>
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="object_loaded">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="self" transfer-ownership="none">
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="object_saved">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="self" transfer-ownership="none">
            <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_element"
              c:identifier="gst_xml_get_element"
              introspectable="0">
        <doc xml:whitespace="preserve">This function is used to get a pointer to the GstElement corresponding
to name in the pipeline description. You would use this if you have
to do anything to the element after loading.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a pointer to a new GstElement, caller owns returned reference.</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of element to retrieve</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_topelements"
              c:identifier="gst_xml_get_topelements"
              introspectable="0">
        <doc xml:whitespace="preserve">Retrieve a list of toplevel elements.
of the list and must not free or modify the list. The caller also does not
own a reference to any of the elements in the list and should obtain its own
reference using gst_object_ref() if necessary.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a GList of top-level elements. The caller does not own a copy</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
      </method>
      <method name="parse_doc" c:identifier="gst_xml_parse_doc">
        <doc xml:whitespace="preserve">Fills the GstXML object with the elements from the
xmlDocPtr.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success, FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="doc" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to an xml document to parse</doc>
            <type name="libxml2.DocPtr" c:type="xmlDocPtr"/>
          </parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the root object to build</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_file" c:identifier="gst_xml_parse_file">
        <doc xml:whitespace="preserve">Fills the GstXML object with the corresponding elements from
the XML file fname. Optionally it will only build the element from
the element node root (if it is not NULL). This feature is useful
if you only want to build a specific element from an XML file
but not the pipeline it is embedded in.
Pass "-" as fname to read from stdin. You can also pass a URI
of any format that libxml supports, including http.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success, FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fname" transfer-ownership="none">
            <doc xml:whitespace="preserve">The filename with the xml description</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the root object to build</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_memory" c:identifier="gst_xml_parse_memory">
        <doc xml:whitespace="preserve">Fills the GstXML object with the corresponding elements from
an in memory XML buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to the in memory XML buffer</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the root objects to build</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="topelements">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="ns">
        <type name="libxml2.NsPtr" c:type="xmlNsPtr"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="object-loaded">
        <doc xml:whitespace="preserve">Signals that a new object has been deserialized.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object that has been loaded</doc>
            <type name="Object"/>
          </parameter>
          <parameter name="xml_node" transfer-ownership="none">
            <doc xml:whitespace="preserve">the related xml_node pointer to the document tree</doc>
            <type name="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="XMLClass"
            c:type="GstXMLClass"
            glib:is-gtype-struct-for="XML">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="object_loaded">
        <callback name="object_loaded">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="xml" transfer-ownership="none">
              <type name="XML" c:type="GstXML*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="self" transfer-ownership="none">
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="object_saved">
        <callback name="object_saved">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="xml" transfer-ownership="none">
              <type name="XML" c:type="GstXML*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="self" transfer-ownership="none">
              <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <function name="alloc_trace_available"
              c:identifier="gst_alloc_trace_available">
      <doc xml:whitespace="preserve">Check if alloc tracing was compiled into the core
tracing enabled.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the core was compiled with alloc</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="alloc_trace_get"
              c:identifier="gst_alloc_trace_get"
              introspectable="0">
      <doc xml:whitespace="preserve">Get the named alloc trace object.
no alloc tracer was registered with that name.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a GstAllocTrace with the given name or NULL when</doc>
        <type name="AllocTrace" c:type="GstAllocTrace*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the alloc trace object</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="alloc_trace_list" c:identifier="gst_alloc_trace_list">
      <doc xml:whitespace="preserve">Get a list of all registered alloc trace objects.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a GList of GstAllocTrace objects.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
    </function>
    <function name="alloc_trace_live_all"
              c:identifier="gst_alloc_trace_live_all">
      <doc xml:whitespace="preserve">Get the total number of live registered alloc trace objects.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the total number of live registered alloc trace objects.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="alloc_trace_print_all"
              c:identifier="gst_alloc_trace_print_all">
      <doc xml:whitespace="preserve">Print the status of all registered alloc trace objects.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="alloc_trace_print_live"
              c:identifier="gst_alloc_trace_print_live">
      <doc xml:whitespace="preserve">Print the status of all registered alloc trace objects, ignoring those
without live objects.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="alloc_trace_set_flags_all"
              c:identifier="gst_alloc_trace_set_flags_all">
      <doc xml:whitespace="preserve">Enable the specified options on all registered alloc trace
objects.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">the options to enable</doc>
          <type name="AllocTraceFlags" c:type="GstAllocTraceFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_set"
              c:identifier="gst_atomic_int_set"
              deprecated="Use g_atomic_int_set().">
      <doc xml:whitespace="preserve">Unconditionally sets the atomic integer to @value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="atomic_int"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to an atomic integer</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value to set</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_queue_new"
              c:identifier="gst_atomic_queue_new"
              version="0.10.33"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new atomic queue instance. @initial_size will be rounded up to the
nearest power of 2 and used as the initial size of the queue.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a new #GstAtomicQueue</doc>
        <type name="AtomicQueue" c:type="GstAtomicQueue*"/>
      </return-value>
      <parameters>
        <parameter name="initial_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">initial queue size</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="caps_from_string" c:identifier="gst_caps_from_string">
      <doc xml:whitespace="preserve">Converts @caps from a string representation.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated #GstCaps</doc>
        <type name="Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string to convert to #GstCaps</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="caps_load_thyself" c:identifier="gst_caps_load_thyself">
      <doc xml:whitespace="preserve">Creates a #GstCaps from its XML serialization.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstCaps structure</doc>
        <type name="Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="parent" transfer-ownership="none">
          <doc xml:whitespace="preserve">a XML node</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
      </parameters>
    </function>
    <function name="caps_replace" c:identifier="gst_caps_replace">
      <doc xml:whitespace="preserve">Replaces *caps with @newcaps.  Unrefs the #GstCaps in the location
pointed to by @caps, if applicable, then modifies @caps to point to
This function does not take any locks so you might want to lock
the object owning @caps pointer.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="caps"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to #GstCaps</doc>
          <type name="Caps" c:type="GstCaps**"/>
        </parameter>
        <parameter name="newcaps" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstCaps to replace *caps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </parameter>
      </parameters>
    </function>
    <function name="child_proxy_child_added"
              c:identifier="gst_child_proxy_child_added">
      <doc xml:whitespace="preserve">Emits the "child-added" signal.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent object</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="child" transfer-ownership="none">
          <doc xml:whitespace="preserve">the newly added child</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="child_proxy_child_removed"
              c:identifier="gst_child_proxy_child_removed">
      <doc xml:whitespace="preserve">Emits the "child-removed" signal.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent object</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="child" transfer-ownership="none">
          <doc xml:whitespace="preserve">the removed child</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="child_proxy_get"
              c:identifier="gst_child_proxy_get"
              introspectable="0">
      <doc xml:whitespace="preserve">Gets properties of the parent object and its children.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent object</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="first_property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the first property to get</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="child_proxy_get_property"
              c:identifier="gst_child_proxy_get_property">
      <doc xml:whitespace="preserve">Gets a single property using the GstChildProxy mechanism.
You are responsible for for freeing it by calling g_value_unset()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">object to query</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the property</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue that should take the result.</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="child_proxy_get_valist"
              c:identifier="gst_child_proxy_get_valist"
              introspectable="0">
      <doc xml:whitespace="preserve">Gets properties of the parent object and its children.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object to query</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="first_property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the first property to get</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:whitespace="preserve">return location for the first property, followed optionally by more name/return location pairs, followed by NULL</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="child_proxy_lookup" c:identifier="gst_child_proxy_lookup">
      <doc xml:whitespace="preserve">Looks up which object and #GParamSpec would be effected by the given @name.
case the values for @pspec and @target are not modified. Unref @target after
usage.
MT safe.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if @target and @pspec could be found. FALSE otherwise. In that</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">object to lookup the property in</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the property to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="target"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to a #GstObject that takes the real object to set property on</doc>
          <type name="Object" c:type="GstObject**"/>
        </parameter>
        <parameter name="pspec"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to take the #GParamSpec describing the property</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec**"/>
        </parameter>
      </parameters>
    </function>
    <function name="child_proxy_set"
              c:identifier="gst_child_proxy_set"
              introspectable="0">
      <doc xml:whitespace="preserve">Sets properties of the parent object and its children.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent object</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="first_property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the first property to set</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="child_proxy_set_property"
              c:identifier="gst_child_proxy_set_property">
      <doc xml:whitespace="preserve">Sets a single property using the GstChildProxy mechanism.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent object</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the property to set</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">new #GValue for the property</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="child_proxy_set_valist"
              c:identifier="gst_child_proxy_set_valist"
              introspectable="0">
      <doc xml:whitespace="preserve">Sets properties of the parent object and its children.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent object</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="first_property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the first property to set</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:whitespace="preserve">value for the first property, followed optionally by more name/value pairs, followed by NULL</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="class_signal_connect"
              c:identifier="gst_class_signal_connect">
      <doc xml:whitespace="preserve">Connect to a class signal.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the signal id.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="klass" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstObjectClass to attach the signal to</doc>
          <type name="ObjectClass" c:type="GstObjectClass*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the signal to attach to</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="func_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="class_signal_emit_by_name"
              c:identifier="gst_class_signal_emit_by_name">
      <doc xml:whitespace="preserve">emits the named class signal.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstObject that emits the signal</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the signal to emit</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">data for the signal</doc>
          <type name="libxml2.NodePtr" c:type="xmlNodePtr"/>
        </parameter>
      </parameters>
    </function>
    <function name="core_error_quark" c:identifier="gst_core_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="debug_add_log_function"
              c:identifier="gst_debug_add_log_function"
              introspectable="0">
      <doc xml:whitespace="preserve">Adds the logging function to the list of logging functions.
Be sure to use #G_GNUC_NO_INSTRUMENT on that function, it is needed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="func" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">the function to use</doc>
          <type name="LogFunction" c:type="GstLogFunction"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_construct_term_color"
              c:identifier="gst_debug_construct_term_color">
      <doc xml:whitespace="preserve">Constructs a string that can be used for getting the desired color in color
terminals.
You need to free the string after use.
definition</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a string containing the color</doc>
        <type name="utf8"/>
      </return-value>
      <parameters>
        <parameter name="colorinfo" transfer-ownership="none">
          <doc xml:whitespace="preserve">the color info</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_construct_win_color"
              c:identifier="gst_debug_construct_win_color"
              version="0.10.23">
      <doc xml:whitespace="preserve">Constructs an integer that can be used for getting the desired color in
windows' terminals (cmd.exe). As there is no mean to underline, we simply
ignore this attribute.
This function returns 0 on non-windows machines.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">an integer containing the color definition</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="colorinfo" transfer-ownership="none">
          <doc xml:whitespace="preserve">the color info</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_get_all_categories"
              c:identifier="gst_debug_get_all_categories">
      <doc xml:whitespace="preserve">Returns a snapshot of a all categories that are currently in use . This list
may change anytime.
The caller has to free the list after use.
debug categories</doc>
      <return-value transfer-ownership="container">
        <doc xml:whitespace="preserve">the list of</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="DebugCategory"/>
        </type>
      </return-value>
    </function>
    <function name="debug_get_default_threshold"
              c:identifier="gst_debug_get_default_threshold">
      <doc xml:whitespace="preserve">Returns the default threshold that is used for new categories.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the default threshold level</doc>
        <type name="DebugLevel" c:type="GstDebugLevel"/>
      </return-value>
    </function>
    <function name="debug_is_active" c:identifier="gst_debug_is_active">
      <doc xml:whitespace="preserve">Checks if debugging output is activated.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE, if debugging is activated</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="debug_is_colored" c:identifier="gst_debug_is_colored">
      <doc xml:whitespace="preserve">Checks if the debugging output should be colored.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE, if the debug output should be colored.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="debug_level_get_name"
              c:identifier="gst_debug_level_get_name">
      <doc xml:whitespace="preserve">Get the string representation of a debugging level</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the name</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">the level to get the name for</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_log" c:identifier="gst_debug_log" introspectable="0">
      <doc xml:whitespace="preserve">Logs the given message using the currently registered debugging handlers.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="category" transfer-ownership="none">
          <doc xml:whitespace="preserve">category to log</doc>
          <type name="DebugCategory" c:type="GstDebugCategory*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">level of the message is in</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <doc xml:whitespace="preserve">the file that emitted the message, usually the __FILE__ identifier</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="function" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function that emitted the message</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <doc xml:whitespace="preserve">the line from that the message was emitted, usually __LINE__</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">the object this message relates to, or NULL if none</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">a printf style format string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="debug_log_default" c:identifier="gst_debug_log_default">
      <doc xml:whitespace="preserve">The default logging handler used by GStreamer. Logging functions get called
whenever a macro like GST_DEBUG or similar is used. This function outputs the
message and additional info to stderr (or the log file specified via the
GST_DEBUG_FILE environment variable).
You can add other handlers by using gst_debug_add_log_function().
And you can remove this handler by calling
gst_debug_remove_log_function(gst_debug_log_default);</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="category" transfer-ownership="none">
          <doc xml:whitespace="preserve">category to log</doc>
          <type name="DebugCategory" c:type="GstDebugCategory*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">level of the message</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <doc xml:whitespace="preserve">the file that emitted the message, usually the __FILE__ identifier</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="function" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function that emitted the message</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <doc xml:whitespace="preserve">the line from that the message was emitted, usually __LINE__</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">the object this message relates to, or NULL if none</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">the actual message</doc>
          <type name="DebugMessage" c:type="GstDebugMessage*"/>
        </parameter>
        <parameter name="unused" transfer-ownership="none">
          <doc xml:whitespace="preserve">an unused variable, reserved for some user_data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_log_valist"
              c:identifier="gst_debug_log_valist"
              introspectable="0">
      <doc xml:whitespace="preserve">Logs the given message using the currently registered debugging handlers.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="category" transfer-ownership="none">
          <doc xml:whitespace="preserve">category to log</doc>
          <type name="DebugCategory" c:type="GstDebugCategory*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">level of the message is in</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <doc xml:whitespace="preserve">the file that emitted the message, usually the __FILE__ identifier</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="function" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function that emitted the message</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <doc xml:whitespace="preserve">the line from that the message was emitted, usually __LINE__</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">the object this message relates to, or NULL if none</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">a printf style format string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:whitespace="preserve">optional arguments for the format</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_print_stack_trace"
              c:identifier="gst_debug_print_stack_trace">
      <doc xml:whitespace="preserve">If GST_ENABLE_FUNC_INSTRUMENTATION is defined a stacktrace is available for
gstreamer code, which can be printed with this function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="debug_remove_log_function"
              c:identifier="gst_debug_remove_log_function"
              introspectable="0">
      <doc xml:whitespace="preserve">Removes all registered instances of the given logging functions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">How many instances of the function were removed</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">the log function to remove</doc>
          <type name="LogFunction" c:type="GstLogFunction"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_remove_log_function_by_data"
              c:identifier="gst_debug_remove_log_function_by_data">
      <doc xml:whitespace="preserve">Removes all registered instances of log functions with the given user data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">How many instances of the function were removed</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data of the log function to remove</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_active" c:identifier="gst_debug_set_active">
      <doc xml:whitespace="preserve">If activated, debugging messages are sent to the debugging
handlers.
It makes sense to deactivate it for speed issues.
&lt;note&gt;&lt;para&gt;This function is not threadsafe. It makes sense to only call it
during initialization.&lt;/para&gt;&lt;/note&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="active" transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether to use debugging output or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_colored" c:identifier="gst_debug_set_colored">
      <doc xml:whitespace="preserve">Sets or unsets the use of coloured debugging output.
This function may be called before gst_init().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="colored" transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether to use colored output or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_default_threshold"
              c:identifier="gst_debug_set_default_threshold">
      <doc xml:whitespace="preserve">Sets the default threshold to the given level and updates all categories to
use this threshold.
This function may be called before gst_init().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">level to set</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_threshold_for_name"
              c:identifier="gst_debug_set_threshold_for_name">
      <doc xml:whitespace="preserve">Sets all categories which match the given glob style pattern to the given
level.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the categories to set</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">level to set them to</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_unset_threshold_for_name"
              c:identifier="gst_debug_unset_threshold_for_name">
      <doc xml:whitespace="preserve">Resets all categories with the given name back to the default level.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the categories to set</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="default_registry_check_feature_version"
              c:identifier="gst_default_registry_check_feature_version">
      <doc xml:whitespace="preserve">Checks whether a plugin feature by the given name exists in the
default registry and whether its version is at least the
version required.
the same as the required version or newer, and #FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#TRUE if the feature could be found and the version is</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="feature_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the feature (e.g. "oggdemux")</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="min_major" transfer-ownership="none">
          <doc xml:whitespace="preserve">the minimum major version number</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="min_minor" transfer-ownership="none">
          <doc xml:whitespace="preserve">the minimum minor version number</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="min_micro" transfer-ownership="none">
          <doc xml:whitespace="preserve">the minimum micro version number</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="deinit" c:identifier="gst_deinit">
      <doc xml:whitespace="preserve">Clean up any resources created by GStreamer in gst_init().
It is normally not needed to call this function in a normal application
as the resources will automatically be freed when the program terminates.
This function is therefore mostly used by testsuites and other memory
profiling tools.
After this call GStreamer (including this method) should not be used anymore.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="double_range_get_type"
              c:identifier="gst_double_range_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="error_get_message" c:identifier="gst_error_get_message">
      <doc xml:whitespace="preserve">Get a string describing the error message in the current locale.
the error message (in UTF-8 encoding)</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated string describing</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the GStreamer error domain this error belongs to.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="code" transfer-ownership="none">
          <doc xml:whitespace="preserve">the error code belonging to the domain.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_to_uri"
              c:identifier="gst_filename_to_uri"
              version="0.10.33"
              throws="1">
      <doc xml:whitespace="preserve">Similar to g_filename_to_uri(), but attempts to handle relative file paths
as well. Before converting @filename into an URI, it will be prefixed by
the current working directory if it is a relative path, and then the path
will be canonicalised so that it doesn't contain any './' or '../' segments.
On Windows #filename should be in UTF-8 encoding.</doc>
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">absolute or relative file name path</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filter_run" c:identifier="gst_filter_run">
      <doc xml:whitespace="preserve">Iterates over the elements in @list, calling @func with the
list item data for each item.  If @func returns TRUE, @data is
prepended to the list of results returned.  If @first is true,
the search is halted after the first result is found.
Since gst_filter_run() knows nothing about the type of @data, no
reference will be taken (if @data refers to an object) and no copy of
results.
when no longer needed (the data contained in the list is a flat copy
and does need to be unreferenced or freed).</doc>
      <return-value transfer-ownership="container">
        <doc xml:whitespace="preserve">the list of results. Free with g_list_free()</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a linked list</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="call"
                   closure="3">
          <doc xml:whitespace="preserve">the function to execute for each item</doc>
          <type name="FilterFunc" c:type="GstFilterFunc"/>
        </parameter>
        <parameter name="first" transfer-ownership="none">
          <doc xml:whitespace="preserve">flag to stop execution after a successful item</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="flow_get_name" c:identifier="gst_flow_get_name">
      <doc xml:whitespace="preserve">Gets a string representing the given flow return.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a static string with the name of the flow return.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn to get the name of.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </parameter>
      </parameters>
    </function>
    <function name="flow_to_quark" c:identifier="gst_flow_to_quark">
      <doc xml:whitespace="preserve">Get the unique quark for the given GstFlowReturn.
invalid return was specified.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark associated with the flow return or 0 if an</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn to get the quark of.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_get_by_nick" c:identifier="gst_format_get_by_nick">
      <doc xml:whitespace="preserve">Return the format registered with the given nick.
if the format was not registered.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The format with @nick or GST_FORMAT_UNDEFINED</doc>
        <type name="Format" c:type="GstFormat"/>
      </return-value>
      <parameters>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">The nick of the format</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_get_details" c:identifier="gst_format_get_details">
      <doc xml:whitespace="preserve">Get details about the given format.
MT safe.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GstFormatDefinition for @format or NULL on failure.</doc>
        <type name="FormatDefinition" c:type="GstFormatDefinition*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">The format to get details of</doc>
          <type name="Format" c:type="GstFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_get_name" c:identifier="gst_format_get_name">
      <doc xml:whitespace="preserve">Get a printable name for the given format. Do not modify or free.
the format is unknown.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a reference to the static name of the format or NULL if</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFormat</doc>
          <type name="Format" c:type="GstFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_iterate_definitions"
              c:identifier="gst_format_iterate_definitions"
              introspectable="0">
      <doc xml:whitespace="preserve">Iterate all the registered formats. The format definition is read
only.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a GstIterator of #GstFormatDefinition.</doc>
        <type name="Iterator" c:type="GstIterator*"/>
      </return-value>
    </function>
    <function name="format_register" c:identifier="gst_format_register">
      <doc xml:whitespace="preserve">Create a new GstFormat based on the nick or return an
already registered format with that nick.
with the same nick.
MT safe.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">A new GstFormat or an already registered format</doc>
        <type name="Format" c:type="GstFormat"/>
      </return-value>
      <parameters>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">The nick of the new format</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="description" transfer-ownership="none">
          <doc xml:whitespace="preserve">The description of the new format</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_to_quark" c:identifier="gst_format_to_quark">
      <doc xml:whitespace="preserve">Get the unique quark for the given format.
is unknown.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark associated with the format or 0 if the format</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFormat</doc>
          <type name="Format" c:type="GstFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="formats_contains" c:identifier="gst_formats_contains">
      <doc xml:whitespace="preserve">See if the given format is inside the format array.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the format is found inside the array</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="formats" transfer-ownership="none">
          <doc xml:whitespace="preserve">The format array to search</doc>
          <type name="Format" c:type="GstFormat*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">the format to find</doc>
          <type name="Format" c:type="GstFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="fourcc_get_type" c:identifier="gst_fourcc_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="fraction_get_type" c:identifier="gst_fraction_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="fraction_range_get_type"
              c:identifier="gst_fraction_range_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="implements_interface_cast"
              c:identifier="gst_implements_interface_cast">
      <doc xml:whitespace="preserve">cast a given object to an interface type, and check whether this
interface is supported for this specific instance.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a gpointer to the interface type</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="from" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object (any sort) from which to cast to the interface</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface type to cast to</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="implements_interface_check"
              c:identifier="gst_implements_interface_check">
      <doc xml:whitespace="preserve">check a given object for an interface implementation, and check
whether this interface is supported for this specific instance.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">whether or not the object implements the given interface</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="from" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object (any sort) from which to check from for the interface</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface type to check for</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="init" c:identifier="gst_init">
      <doc xml:whitespace="preserve">Initializes the GStreamer library, setting up internal path lists,
registering built-in elements, and loading standard plugins.
Unless the plugin registry is disabled at compile time, the registry will be
loaded. By default this will also check if the registry cache needs to be
updated and rescan all plugins if needed. See gst_update_registry() for
details and section
&lt;link linkend="gst-running"&gt;Running GStreamer Applications&lt;/link&gt;
for how to disable automatic registry updates.
This function should be called before calling any other GLib functions. If
this is not an option, your program must initialise the GLib thread system
using g_thread_init() before any other GLib functions are called.
&lt;note&gt;&lt;para&gt;
This function will terminate your program if it was unable to initialize
GStreamer for some reason.  If you want your program to fall back,
use gst_init_check() instead.
&lt;/para&gt;&lt;/note&gt;
functions in other glib-style libraries, such as gtk_init().  In
particular, unknown command line options cause this function to
abort program execution.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="argc"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to application's argc</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="argv"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to application's argv</doc>
          <array length="0" c:type="char**">
            <type name="utf8" c:type="char*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="init_check" c:identifier="gst_init_check" throws="1">
      <doc xml:whitespace="preserve">Initializes the GStreamer library, setting up internal path lists,
registering built-in elements, and loading standard plugins.
This function will return %FALSE if GStreamer could not be initialized
for some reason.  If you want your program to fail fatally,
use gst_init() instead.
This function should be called before calling any other GLib functions. If
this is not an option, your program must initialise the GLib thread system
using g_thread_init() before any other GLib functions are called.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if GStreamer could be initialized.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="argc"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to application's argc</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="argv"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to application's argv</doc>
          <array length="0" c:type="char**">
            <type name="utf8" c:type="char*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="init_get_option_group"
              c:identifier="gst_init_get_option_group"
              introspectable="0">
      <doc xml:whitespace="preserve">Returns a #GOptionGroup with GStreamer's argument specifications. The
group is set up to use standard GOption callbacks, so when using this
group in combination with GOption parsing methods, all argument parsing
and initialization is automated.
This function is useful if you want to integrate GStreamer with other
libraries that use GOption (see g_option_context_add_group() ).
If you use this function, you should make sure you initialise the GLib
threading system as one of the very first things in your program
(see the example at the beginning of this section).</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a pointer to GStreamer's option group.</doc>
        <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
      </return-value>
    </function>
    <function name="int64_range_get_type"
              c:identifier="gst_int64_range_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="int_range_get_type" c:identifier="gst_int_range_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="is_initialized"
              c:identifier="gst_is_initialized"
              version="0.10.31">
      <doc xml:whitespace="preserve">Use this function to check if GStreamer has been initialized with gst_init()
or gst_init_check().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if initialization has been done, FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="is_tag_list" c:identifier="gst_is_tag_list">
      <doc xml:whitespace="preserve">Checks if the given pointer is a taglist.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE, if the given pointer is a taglist</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="p" transfer-ownership="none">
          <doc xml:whitespace="preserve">Object that might be a taglist</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="iterator_new"
              c:identifier="gst_iterator_new"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new iterator. This function is mainly used for objects
implementing the next/resync/free function to iterate a data structure.
For each item retrieved, the @item function is called with the lock
held. The @free function is called when the iterator is freed.
MT safe.</doc>
      <return-value>
        <doc xml:whitespace="preserve">the new #GstIterator.</doc>
        <type name="Iterator" c:type="GstIterator*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the iterator structure</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GType of children</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="lock" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to a #GMutex.</doc>
          <type name="GLib.Mutex" c:type="GMutex*"/>
        </parameter>
        <parameter name="master_cookie" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to a guint32 that is changed when the items in the iterator changed.</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
        <parameter name="next" transfer-ownership="none">
          <doc xml:whitespace="preserve">function to get next item</doc>
          <type name="IteratorNextFunction" c:type="GstIteratorNextFunction"/>
        </parameter>
        <parameter name="item" transfer-ownership="none">
          <doc xml:whitespace="preserve">function to call on each item retrieved</doc>
          <type name="IteratorItemFunction" c:type="GstIteratorItemFunction"/>
        </parameter>
        <parameter name="resync" transfer-ownership="none">
          <doc xml:whitespace="preserve">function to resync the iterator</doc>
          <type name="IteratorResyncFunction"
                c:type="GstIteratorResyncFunction"/>
        </parameter>
        <parameter name="free" transfer-ownership="none">
          <doc xml:whitespace="preserve">function to free the iterator</doc>
          <type name="IteratorFreeFunction" c:type="GstIteratorFreeFunction"/>
        </parameter>
      </parameters>
    </function>
    <function name="iterator_new_list"
              c:identifier="gst_iterator_new_list"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new iterator designed for iterating @list.
The list you iterate is usually part of a data structure @owner and is
protected with @lock. 
The iterator will use @lock to retrieve the next item of the list and it
will then call the @item function before releasing @lock again.
The @item function usualy makes sure that the item remains alive while
responsible for freeing/unreffing the item after usage as explained in
gst_iterator_next().
When a concurrent update to the list is performed, usually by @owner while
holding @lock, @master_cookie will be updated. The iterator implementation
will notice the update of the cookie and will return %GST_ITERATOR_RESYNC to
the user of the iterator in the next call to gst_iterator_next().
MT safe.</doc>
      <return-value>
        <doc xml:whitespace="preserve">the new #GstIterator for @list.</doc>
        <type name="Iterator" c:type="GstIterator*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GType of elements</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="lock" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to a #GMutex protecting the list.</doc>
          <type name="GLib.Mutex" c:type="GMutex*"/>
        </parameter>
        <parameter name="master_cookie" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to a guint32 that is incremented when the list is changed.</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to the list</doc>
          <type name="GLib.List" c:type="GList**">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="owner" transfer-ownership="none">
          <doc xml:whitespace="preserve">object owning the list</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="item" transfer-ownership="none">
          <doc xml:whitespace="preserve">function to call for each item</doc>
          <type name="IteratorItemFunction" c:type="GstIteratorItemFunction"/>
        </parameter>
        <parameter name="free" transfer-ownership="none">
          <doc xml:whitespace="preserve">function to call when the iterator is freed</doc>
          <type name="IteratorDisposeFunction"
                c:type="GstIteratorDisposeFunction"/>
        </parameter>
      </parameters>
    </function>
    <function name="iterator_new_single"
              c:identifier="gst_iterator_new_single"
              version="0.10.25"
              introspectable="0">
      <doc xml:whitespace="preserve">This #GstIterator is a convenient iterator for the common
case where a #GstIterator needs to be returned but only
a single object has to be considered. This happens often
for the #GstPadIterIntLinkFunction.</doc>
      <return-value>
        <doc xml:whitespace="preserve">the new #GstIterator for @object.</doc>
        <type name="Iterator" c:type="GstIterator*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GType of the passed object</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">object that this iterator should return</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="copy" transfer-ownership="none">
          <doc xml:whitespace="preserve">Function that returns a copy of @object or increases its refcount</doc>
          <type name="CopyFunction" c:type="GstCopyFunction"/>
        </parameter>
        <parameter name="free" transfer-ownership="none">
          <doc xml:whitespace="preserve">Function to be called for freeing @object</doc>
          <type name="GLib.FreeFunc" c:type="GFreeFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="library_error_quark"
              c:identifier="gst_library_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="param_spec_mini_object"
              c:identifier="gst_param_spec_mini_object"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpec instance that hold #GstMiniObject references.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated #GParamSpec instance</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the canonical name of the property</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">the nickname of the property</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">a short description of the property</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="object_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstMiniObject #GType for the property</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">a combination of #GParamFlags</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_mini_object_get_type"
              c:identifier="gst_param_spec_mini_object_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="parse_bin_from_description"
              c:identifier="gst_parse_bin_from_description"
              version="0.10.3"
              throws="1">
      <doc xml:whitespace="preserve">This is a convenience wrapper around gst_parse_launch() to create a
#GstBin from a gst-launch-style pipeline description. See
gst_parse_launch() and the gst-launch man page for details about the
syntax. Ghost pads on the bin for unlinked source or sink pads
within the bin can automatically be created (but only a maximum of
one ghost pad for each direction will be created; if you expect
multiple unlinked source pads or multiple unlinked sink pads
and want them all ghosted, you will have to create the ghost pads
yourself).</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly-created bin, or NULL if an error occurred.</doc>
        <type name="Element" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="bin_description" transfer-ownership="none">
          <doc xml:whitespace="preserve">command line describing the bin</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="ghost_unlinked_pads" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether to automatically create ghost pads for unlinked source or sink pads within the bin</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="parse_bin_from_description_full"
              c:identifier="gst_parse_bin_from_description_full"
              version="0.10.20"
              throws="1">
      <doc xml:whitespace="preserve">This is a convenience wrapper around gst_parse_launch() to create a
#GstBin from a gst-launch-style pipeline description. See
gst_parse_launch() and the gst-launch man page for details about the
syntax. Ghost pads on the bin for unlinked source or sink pads
within the bin can automatically be created (but only a maximum of
one ghost pad for each direction will be created; if you expect
multiple unlinked source pads or multiple unlinked sink pads
and want them all ghosted, you will have to create the ghost pads
yourself).</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly-created bin, or NULL if an error occurred.</doc>
        <type name="Element" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="bin_description" transfer-ownership="none">
          <doc xml:whitespace="preserve">command line describing the bin</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="ghost_unlinked_pads" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether to automatically create ghost pads for unlinked source or sink pads within the bin</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="context" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a parse context allocated with gst_parse_context_new(), or %NULL</doc>
          <type name="ParseContext" c:type="GstParseContext*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">parsing options, or #GST_PARSE_FLAG_NONE</doc>
          <type name="ParseFlags" c:type="GstParseFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="parse_error_quark" c:identifier="gst_parse_error_quark">
      <doc xml:whitespace="preserve">Get the error quark used by the parsing subsystem.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark of the parse errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="parse_launch" c:identifier="gst_parse_launch" throws="1">
      <doc xml:whitespace="preserve">Create a new pipeline based on command line syntax.
Please note that you might get a return value that is not %NULL even though
the @error is set. In this case there was a recoverable parsing error and you
can try to play the pipeline.
more than one toplevel element is specified by the @pipeline_description,
all elements are put into a #GstPipeline, which than is returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new element on success, %NULL on failure. If</doc>
        <type name="Element" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="pipeline_description" transfer-ownership="none">
          <doc xml:whitespace="preserve">the command line describing the pipeline</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="parse_launch_full"
              c:identifier="gst_parse_launch_full"
              version="0.10.20"
              throws="1">
      <doc xml:whitespace="preserve">Create a new pipeline based on command line syntax.
Please note that you might get a return value that is not %NULL even though
the @error is set. In this case there was a recoverable parsing error and you
can try to play the pipeline.
more than one toplevel element is specified by the @pipeline_description,
all elements are put into a #GstPipeline, which then is returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new element on success, %NULL on failure. If</doc>
        <type name="Element" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="pipeline_description" transfer-ownership="none">
          <doc xml:whitespace="preserve">the command line describing the pipeline</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a parse context allocated with gst_parse_context_new(), or %NULL</doc>
          <type name="ParseContext" c:type="GstParseContext*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">parsing options, or #GST_PARSE_FLAG_NONE</doc>
          <type name="ParseFlags" c:type="GstParseFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="parse_launchv" c:identifier="gst_parse_launchv" throws="1">
      <doc xml:whitespace="preserve">Create a new element based on command line syntax.
An error does not mean that the pipeline could not be constructed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new element on success and %NULL on failure.</doc>
        <type name="Element" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:whitespace="preserve">null-terminated array of arguments</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="parse_launchv_full"
              c:identifier="gst_parse_launchv_full"
              version="0.10.20"
              throws="1">
      <doc xml:whitespace="preserve">Create a new element based on command line syntax.
An error does not mean that the pipeline could not be constructed.
or a partially-constructed bin or element will be returned and @error will
be set (unless you passed #GST_PARSE_FLAG_FATAL_ERRORS in @flags, then
%NULL will always be returned on failure)</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new element on success; on failure, either %NULL</doc>
        <type name="Element" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:whitespace="preserve">null-terminated array of arguments</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="context" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a parse context allocated with gst_parse_context_new(), or %NULL</doc>
          <type name="ParseContext" c:type="GstParseContext*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">parsing options, or #GST_PARSE_FLAG_NONE</doc>
          <type name="ParseFlags" c:type="GstParseFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="poll_new"
              c:identifier="gst_poll_new"
              version="0.10.18"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new file descriptor set. If @controllable, it
is possible to restart or flush a call to gst_poll_wait() with
gst_poll_restart() and gst_poll_set_flushing() respectively.
Free with gst_poll_free().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstPoll, or %NULL in case of an error.</doc>
        <type name="Poll" c:type="GstPoll*"/>
      </return-value>
      <parameters>
        <parameter name="controllable" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether it should be possible to control a wait.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="poll_new_timer"
              c:identifier="gst_poll_new_timer"
              version="0.10.23"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new poll object that can be used for scheduling cancellable
timeouts.
A timeout is performed with gst_poll_wait(). Multiple timeouts can be
performed from different threads. 
Free with gst_poll_free().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstPoll, or %NULL in case of an error.</doc>
        <type name="Poll" c:type="GstPoll*"/>
      </return-value>
    </function>
    <function name="print_element_args" c:identifier="gst_print_element_args">
      <doc xml:whitespace="preserve">Print the element argument in a human readable format in the given
GString.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">the buffer to print the args in</doc>
          <type name="GLib.String" c:type="GString*"/>
        </parameter>
        <parameter name="indent" transfer-ownership="none">
          <doc xml:whitespace="preserve">initial indentation</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="element" transfer-ownership="none">
          <doc xml:whitespace="preserve">the element to print the args of</doc>
          <type name="Element" c:type="GstElement*"/>
        </parameter>
      </parameters>
    </function>
    <function name="print_pad_caps" c:identifier="gst_print_pad_caps">
      <doc xml:whitespace="preserve">Write the pad capabilities in a human readable format into
the given GString.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">the buffer to print the caps in</doc>
          <type name="GLib.String" c:type="GString*"/>
        </parameter>
        <parameter name="indent" transfer-ownership="none">
          <doc xml:whitespace="preserve">initial indentation</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the pad to print the caps from</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </function>
    <function name="resource_error_quark"
              c:identifier="gst_resource_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="segtrap_is_enabled"
              c:identifier="gst_segtrap_is_enabled"
              version="0.10.10">
      <doc xml:whitespace="preserve">Some functions in the GStreamer core might install a custom SIGSEGV handler
to better catch and report errors to the application. Currently this feature
is enabled by default when loading plugins.
Applications might want to disable this behaviour with the
gst_segtrap_set_enabled() function. This is typically done if the application
wants to install its own handler without GStreamer interfering.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if GStreamer is allowed to install a custom SIGSEGV handler.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="segtrap_set_enabled"
              c:identifier="gst_segtrap_set_enabled"
              version="0.10.10">
      <doc xml:whitespace="preserve">Applications might want to disable/enable the SIGSEGV handling of
the GStreamer core. See gst_segtrap_is_enabled() for more information.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="enabled" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether a custom SIGSEGV handler should be installed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="static_caps_get_type"
              c:identifier="gst_static_caps_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="static_pad_template_get_type"
              c:identifier="gst_static_pad_template_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="stream_error_quark" c:identifier="gst_stream_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="structure_from_string"
              c:identifier="gst_structure_from_string">
      <doc xml:whitespace="preserve">Creates a #GstStructure from a string representation.
If end is not NULL, a pointer to the place inside the given string
where parsing ended will be returned.
not be parsed. Free with gst_structure_free() after use.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstStructure or NULL when the string could</doc>
        <type name="Structure" c:type="GstStructure*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string representation of a #GstStructure.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="end"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to store the end of the string in.</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_exists" c:identifier="gst_tag_exists">
      <doc xml:whitespace="preserve">Checks if the given type is already registered.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the type is already registered</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the tag</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_get_description"
              c:identifier="gst_tag_get_description">
      <doc xml:whitespace="preserve">Returns the human-readable description of this tag, You must not change or
free this string.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the human-readable description of this tag</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">the tag</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_get_flag" c:identifier="gst_tag_get_flag">
      <doc xml:whitespace="preserve">Gets the flag of @tag.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the flag of this tag.</doc>
        <type name="TagFlag" c:type="GstTagFlag"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">the tag</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_get_nick" c:identifier="gst_tag_get_nick">
      <doc xml:whitespace="preserve">Returns the human-readable name of this tag, You must not change or free
this string.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the human-readable name of this tag</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">the tag</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_get_type" c:identifier="gst_tag_get_type">
      <doc xml:whitespace="preserve">Gets the #GType used for this tag.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the #GType of this tag</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">the tag</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_is_fixed" c:identifier="gst_tag_is_fixed">
      <doc xml:whitespace="preserve">Checks if the given tag is fixed. A fixed tag can only contain one value.
Unfixed tags can contain lists of values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE, if the given tag is fixed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">tag to check</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_list_copy_value"
              c:identifier="gst_tag_list_copy_value">
      <doc xml:whitespace="preserve">Copies the contents for the given tag into the value,
merging multiple values into one if multiple values are associated
with the tag.
You must g_value_unset() the value after use.
given list.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">uninitialized #GValue to copy into</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">list to get the tag from</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </parameter>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">tag to read out</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_merge_strings_with_comma"
              c:identifier="gst_tag_merge_strings_with_comma">
      <doc xml:whitespace="preserve">This is a convenience function for the func argument of gst_tag_register().
It concatenates all given strings using a comma. The tag must be registered
as a G_TYPE_STRING or this function will fail.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">uninitialized GValue to store result in</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">GValue to copy from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_merge_use_first"
              c:identifier="gst_tag_merge_use_first">
      <doc xml:whitespace="preserve">This is a convenience function for the func argument of gst_tag_register().
It creates a copy of the first value from the list.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">uninitialized GValue to store result in</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">GValue to copy from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_register"
              c:identifier="gst_tag_register"
              introspectable="0">
      <doc xml:whitespace="preserve">Registers a new tag type for the use with GStreamer's type system. If a type
with that name is already registered, that one is used.
The old registration may have used a different type however. So don't rely
on your supplied values.
that there can only be one single value for this tag in a tag list and
any additional values will silenty be discarded when being added (unless
#GST_TAG_MERGE_REPLACE, #GST_TAG_MERGE_REPLACE_ALL, or
#GST_TAG_MERGE_PREPEND is used as merge mode, in which case the new
value will replace the old one in the list).
The merge function will be called from gst_tag_list_copy_value() when
it is required that one or more values for a tag be condensed into
one single value. This may happen from gst_tag_list_get_string(),
gst_tag_list_get_int(), gst_tag_list_get_double() etc. What will happen
exactly in that case depends on how the tag was registered and if a
merge function was supplied and if so which one.
gst_tag_merge_strings_with_comma().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name or identifier string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flag" transfer-ownership="none">
          <doc xml:whitespace="preserve">a flag describing the type of tag info</doc>
          <type name="TagFlag" c:type="GstTagFlag"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type this data is in</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">human-readable name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">a human-readable description about this tag</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">function for merging multiple values of this tag, or NULL</doc>
          <type name="TagMergeFunc" c:type="GstTagMergeFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="trace_new" c:identifier="gst_trace_new" introspectable="0">
      <doc xml:whitespace="preserve">Create a ringbuffer of @size in the file with @filename to
store trace results in.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstTrace.</doc>
        <type name="Trace" c:type="GstTrace*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">a filename</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">the max size of the file</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="trace_read_tsc" c:identifier="gst_trace_read_tsc">
      <doc xml:whitespace="preserve">Read a platform independent timer value that can be used in
benchmarks.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dst" transfer-ownership="none">
          <doc xml:whitespace="preserve">(out) pointer to hold the result.</doc>
          <type name="gint64" c:type="gint64*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_get_type" c:identifier="gst_type_find_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="type_find_register" c:identifier="gst_type_find_register">
      <doc xml:whitespace="preserve">Registers a new typefind function to be used for typefinding. After
registering this function will be available for typefinding.
This function is typically called during an element's plugin initialization.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE on success, FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstPlugin, or NULL for a static typefind function (note that passing NULL only works in GStreamer 0.10.16 and later)</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name for registering</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="rank" transfer-ownership="none">
          <doc xml:whitespace="preserve">The rank (or importance) of this typefind function</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="notified"
                   closure="6"
                   destroy="7">
          <doc xml:whitespace="preserve">The #GstTypeFindFunction to use</doc>
          <type name="TypeFindFunction" c:type="GstTypeFindFunction"/>
        </parameter>
        <parameter name="extensions" transfer-ownership="none">
          <doc xml:whitespace="preserve">Optional extensions that could belong to this type</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="possible_caps" transfer-ownership="none">
          <doc xml:whitespace="preserve">Optionally the caps that could be returned when typefinding succeeds</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Optional user data. This user data must be available until the plugin is unloaded.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data_notify" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">a #GDestroyNotify that will be called on @data when the plugin is unloaded.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_register_static_full"
              c:identifier="gst_type_register_static_full"
              version="0.10.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Helper function which constructs a #GTypeInfo structure and registers a
GType, but which generates less linker overhead than a static const
#GTypeInfo structure. For further details of the parameters, please see
#GTypeInfo in the GLib documentation.
Registers type_name as the name of a new static type derived from
parent_type. The value of flags determines the nature (e.g. abstract or
not) of the type. It works by filling a GTypeInfo struct and calling
g_type_register_static().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GType for the newly-registered type.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="parent_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The GType of the parent type the newly registered type will derive from</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="type_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">NULL-terminated string used as the name of the new type</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="class_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of the class structure.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="base_init" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location of the base initialization function (optional).</doc>
          <type name="GObject.BaseInitFunc" c:type="GBaseInitFunc"/>
        </parameter>
        <parameter name="base_finalize" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location of the base finalization function (optional).</doc>
          <type name="GObject.BaseFinalizeFunc" c:type="GBaseFinalizeFunc"/>
        </parameter>
        <parameter name="class_init" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location of the class initialization function for class types Location of the default vtable inititalization function for interface types. (optional)</doc>
          <type name="GObject.ClassInitFunc" c:type="GClassInitFunc"/>
        </parameter>
        <parameter name="class_finalize" transfer-ownership="none" closure="7">
          <doc xml:whitespace="preserve">Location of the class finalization function for class types. Location of the default vtable finalization function for interface types. (optional)</doc>
          <type name="GObject.ClassFinalizeFunc" c:type="GClassFinalizeFunc"/>
        </parameter>
        <parameter name="class_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">User-supplied data passed to the class init/finalize functions.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="instance_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of the instance (object) structure (required for instantiatable types only).</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="n_preallocs" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Ignored on recent GLib's.</doc>
          <type name="guint16" c:type="guint16"/>
        </parameter>
        <parameter name="instance_init" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location of the instance initialization function (optional, for instantiatable types only).</doc>
          <type name="GObject.InstanceInitFunc" c:type="GInstanceInitFunc"/>
        </parameter>
        <parameter name="value_table" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GTypeValueTable function table for generic handling of GValues of this type (usually only useful for fundamental types).</doc>
          <type name="GObject.TypeValueTable" c:type="GTypeValueTable*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GTypeFlags for this GType. E.g: G_TYPE_FLAG_ABSTRACT</doc>
          <type name="GObject.TypeFlags" c:type="GTypeFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="update_registry"
              c:identifier="gst_update_registry"
              version="0.10.12">
      <doc xml:whitespace="preserve">Forces GStreamer to re-scan its plugin paths and update the default
plugin registry.
Applications will almost never need to call this function, it is only
useful if the application knows new plugins have been installed (or old
ones removed) since the start of the application (or, to be precise, the
first call to gst_init()) and the application wants to make use of any
newly-installed plugins without restarting the application.
Applications should assume that the registry update is neither atomic nor
thread-safe and should therefore not have any dynamic pipelines running
(including the playbin and decodebin elements) and should also not create
any elements or access the GStreamer registry while the update is in
progress.
Note that this function may block for a significant amount of time.
imply that there were changes), otherwise %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the registry has been updated successfully (does not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="uri_construct" c:identifier="gst_uri_construct">
      <doc xml:whitespace="preserve">Constructs a URI for a given valid protocol and location.
URI. Returns NULL if the given URI protocol is not valid, or the given
location is NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new string for this</doc>
        <array c:type="gchar*">
          <type name="utf8" c:type="gchar"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="protocol" transfer-ownership="none">
          <doc xml:whitespace="preserve">Protocol for URI</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="location" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location for URI</doc>
          <array c:type="gchar*">
            <type name="utf8" c:type="gchar"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="uri_get_location" c:identifier="gst_uri_get_location">
      <doc xml:whitespace="preserve">Extracts the location out of a given valid URI, ie. the protocol and "://"
are stripped from the URI, which means that the location returned includes
the hostname if one is specified. The returned string must be freed using
g_free().
URI. Returns NULL if the URI isn't valid. If the URI does not contain
a location, an empty string is returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the location for this</doc>
        <array c:type="gchar*">
          <type name="utf8" c:type="gchar"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">A URI string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_get_protocol" c:identifier="gst_uri_get_protocol">
      <doc xml:whitespace="preserve">Extracts the protocol out of a given valid URI. The returned string must be
freed using g_free().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">The protocol for this URI.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">A URI string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_has_protocol"
              c:identifier="gst_uri_has_protocol"
              version="0.10.4">
      <doc xml:whitespace="preserve">Checks if the protocol of a given valid URI matches @protocol.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the protocol matches.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">a URI string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="protocol" transfer-ownership="none">
          <doc xml:whitespace="preserve">a protocol string (e.g. "http")</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_is_valid" c:identifier="gst_uri_is_valid">
      <doc xml:whitespace="preserve">Tests if the given string is a valid URI identifier. URIs start with a valid
scheme followed by ":" and maybe a string identifying the location.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the string is a valid URI</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">A URI string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_protocol_is_supported"
              c:identifier="gst_uri_protocol_is_supported"
              version="0.10.13">
      <doc xml:whitespace="preserve">Checks if an element exists that supports the given URI protocol. Note
that a positive return value does not imply that a subsequent call to
gst_element_make_from_uri() is guaranteed to work.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether to check for a source or a sink</doc>
          <type name="URIType" c:type="GstURIType"/>
        </parameter>
        <parameter name="protocol" transfer-ownership="none">
          <doc xml:whitespace="preserve">Protocol that should be checked for (e.g. "http" or "smb")</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_protocol_is_valid"
              c:identifier="gst_uri_protocol_is_valid">
      <doc xml:whitespace="preserve">Tests if the given string is a valid protocol identifier. Protocols
must consist of alphanumeric characters, '+', '-' and '.' and must
start with a alphabetic character. See RFC 3986 Section 3.1.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the string is a valid protocol identifier, FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="protocol" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_array_binary_search"
              c:identifier="gst_util_array_binary_search"
              version="0.10.23">
      <doc xml:whitespace="preserve">Searches inside @array for @search_data by using the comparison function
As @search_data is always passed as second argument to @search_func it's
not required that @search_data has the same type as the array elements.
The complexity of this search function is O(log (num_elements)).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The address of the found element or %NULL if nothing was found</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:whitespace="preserve">the sorted input array</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="num_elements" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of elements in the array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="element_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">size of every element in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="search_func"
                   transfer-ownership="none"
                   scope="call"
                   closure="6">
          <doc xml:whitespace="preserve">function to compare two elements, @search_data will always be passed as second argument</doc>
          <type name="GLib.CompareDataFunc" c:type="GCompareDataFunc"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:whitespace="preserve">search mode that should be used</doc>
          <type name="SearchMode" c:type="GstSearchMode"/>
        </parameter>
        <parameter name="search_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">element that should be found</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data to pass to @search_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_double_to_fraction"
              c:identifier="gst_util_double_to_fraction"
              version="0.10.26">
      <doc xml:whitespace="preserve">Transforms a #gdouble to a fraction and simplifies
the result.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">#gdouble to transform</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="dest_n"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a #gint to hold the result numerator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="dest_d"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a #gint to hold the result denominator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_dump_mem" c:identifier="gst_util_dump_mem">
      <doc xml:whitespace="preserve">Dumps the memory block into a hex representation. Useful for debugging.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to the memory to dump</doc>
          <type name="guint8" c:type="guchar*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the memory block to dump</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_fraction_add"
              c:identifier="gst_util_fraction_add"
              version="0.10.26">
      <doc xml:whitespace="preserve">Adds the fractions @a_n/@a_d and @b_n/@b_d and stores
the result in @res_n and @res_d.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE on overflow, %TRUE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="a_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="a_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="res_n"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Pointer to #gint to hold the result numerator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="res_d"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Pointer to #gint to hold the result denominator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_fraction_compare"
              c:identifier="gst_util_fraction_compare"
              version="0.10.31">
      <doc xml:whitespace="preserve">Compares the fractions @a_n/@a_d and @b_n/@b_d and returns
-1 if a &lt; b, 0 if a = b and 1 if a &gt; b.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">-1 if a &lt; b; 0 if a = b; 1 if a &gt; b.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="a_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="a_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_fraction_multiply"
              c:identifier="gst_util_fraction_multiply"
              version="0.10.26">
      <doc xml:whitespace="preserve">Multiplies the fractions @a_n/@a_d and @b_n/@b_d and stores
the result in @res_n and @res_d.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE on overflow, %TRUE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="a_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="a_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="res_n"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Pointer to #gint to hold the result numerator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="res_d"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Pointer to #gint to hold the result denominator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_fraction_to_double"
              c:identifier="gst_util_fraction_to_double"
              version="0.10.26">
      <doc xml:whitespace="preserve">Transforms a fraction to a #gdouble.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Fraction numerator as #gint</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="src_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Fraction denominator #gint</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a #gdouble for the result</doc>
          <type name="gdouble" c:type="gdouble*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_gdouble_to_guint64"
              c:identifier="gst_util_gdouble_to_guint64">
      <return-value transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_get_timestamp"
              c:identifier="gst_util_get_timestamp"
              version="0.10.16">
      <doc xml:whitespace="preserve">Get a timestamp as GstClockTime to be used for interval meassurements.
The timestamp should not be interpreted in any other way.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the timestamp</doc>
        <type name="ClockTime" c:type="GstClockTime"/>
      </return-value>
    </function>
    <function name="util_greatest_common_divisor"
              c:identifier="gst_util_greatest_common_divisor"
              version="0.10.26">
      <doc xml:whitespace="preserve">Calculates the greatest common divisor of @a
and @b.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">Greatest common divisor of @a and @b</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:whitespace="preserve">First value as #gint</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:whitespace="preserve">Second value as #gint</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_guint64_to_gdouble"
              c:identifier="gst_util_guint64_to_gdouble">
      <return-value transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_seqnum_compare"
              c:identifier="gst_util_seqnum_compare"
              version="0.10.22">
      <doc xml:whitespace="preserve">Compare two sequence numbers, handling wraparound.
The current implementation just returns (gint32)(@s1 - @s2).
positive number if @s1 is after @s2.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">A negative number if @s1 is before @s2, 0 if they are equal, or a</doc>
        <type name="gint32" c:type="gint32"/>
      </return-value>
      <parameters>
        <parameter name="s1" transfer-ownership="none">
          <doc xml:whitespace="preserve">A sequence number.</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="s2" transfer-ownership="none">
          <doc xml:whitespace="preserve">Another sequence number.</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_seqnum_next"
              c:identifier="gst_util_seqnum_next"
              version="0.10.22">
      <doc xml:whitespace="preserve">Return a constantly incrementing sequence number.
This function is used internally to GStreamer to be able to determine which
events and messages are "the same". For example, elements may set the seqnum
on a segment-done message to be the same as that of the last seek event, to
indicate that event and the message correspond to the same segment.
overflow back to 0 at some point. Use gst_util_seqnum_compare() to make sure
you handle wraparound correctly.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">A constantly incrementing 32-bit unsigned integer, which might</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
    </function>
    <function name="util_set_object_arg"
              c:identifier="gst_util_set_object_arg">
      <doc xml:whitespace="preserve">Convertes the string value to the type of the objects argument and
sets the argument with it.
Note that this function silently returns if @object has no property named</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object to set the argument of</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the argument to set</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the string value to set</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_set_value_from_string"
              c:identifier="gst_util_set_value_from_string">
      <doc xml:whitespace="preserve">Converts the string to the type of the value and
sets the value with it.
Note that this function is dangerous as it does not return any indication
if the conversion worked or not.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value_str" transfer-ownership="none">
          <doc xml:whitespace="preserve">the string to get the value from</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale" c:identifier="gst_util_uint64_scale">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.
This function can potentially be very slow if val and num are both
greater than G_MAXUINT32.
function returns G_MAXUINT64.  If the result is not exactly
representable as an integer it is truncated.  See also
gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil(),
gst_util_uint64_scale_int(), gst_util_uint64_scale_int_round(),
gst_util_uint64_scale_int_ceil().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number to scale</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale_ceil"
              c:identifier="gst_util_uint64_scale_ceil">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.
This function can potentially be very slow if val and num are both
greater than G_MAXUINT32.
function returns G_MAXUINT64.  If the result is not exactly
representable as an integer, it is rounded up.  See also
gst_util_uint64_scale(), gst_util_uint64_scale_round(),
gst_util_uint64_scale_int(), gst_util_uint64_scale_int_round(),
gst_util_uint64_scale_int_ceil().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number to scale</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale_int"
              c:identifier="gst_util_uint64_scale_int">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.  @num must be non-negative and
function returns G_MAXUINT64.  If the result is not exactly
representable as an integer, it is truncated.  See also
gst_util_uint64_scale_int_round(), gst_util_uint64_scale_int_ceil(),
gst_util_uint64_scale(), gst_util_uint64_scale_round(),
gst_util_uint64_scale_ceil().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">guint64 (such as a #GstClockTime) to scale.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">numerator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">denominator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale_int_ceil"
              c:identifier="gst_util_uint64_scale_int_ceil">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.  @num must be non-negative and
function returns G_MAXUINT64.  If the result is not exactly
representable as an integer, it is rounded up.  See also
gst_util_uint64_scale_int(), gst_util_uint64_scale_int_round(),
gst_util_uint64_scale(), gst_util_uint64_scale_round(),
gst_util_uint64_scale_ceil().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">guint64 (such as a #GstClockTime) to scale.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">numerator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">denominator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale_int_round"
              c:identifier="gst_util_uint64_scale_int_round">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.  @num must be non-negative and
function returns G_MAXUINT64.  If the result is not exactly
representable as an integer, it is rounded to the nearest integer
(half-way cases are rounded up).  See also gst_util_uint64_scale_int(),
gst_util_uint64_scale_int_ceil(), gst_util_uint64_scale(),
gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">guint64 (such as a #GstClockTime) to scale.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">numerator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">denominator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale_round"
              c:identifier="gst_util_uint64_scale_round">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.
This function can potentially be very slow if val and num are both
greater than G_MAXUINT32.
function returns G_MAXUINT64.  If the result is not exactly
representable as an integer, it is rounded to the nearest integer
(half-way cases are rounded up).  See also gst_util_uint64_scale(),
gst_util_uint64_scale_ceil(), gst_util_uint64_scale_int(),
gst_util_uint64_scale_int_round(), gst_util_uint64_scale_int_ceil().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number to scale</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_append_value"
              c:identifier="gst_value_array_append_value">
      <doc xml:whitespace="preserve">Appends @append_value to the GstValueArray in @value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_ARRAY</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="append_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to append</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_get_size"
              c:identifier="gst_value_array_get_size">
      <doc xml:whitespace="preserve">Gets the number of values contained in @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the number of values</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_ARRAY</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_get_type"
              c:identifier="gst_value_array_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="value_array_get_value"
              c:identifier="gst_value_array_get_value">
      <doc xml:whitespace="preserve">Gets the value that is a member of the array contained in @value and
has the index @index.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the value at the given index</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_ARRAY</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="index" transfer-ownership="none">
          <doc xml:whitespace="preserve">index of value to get from the array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_array_prepend_value"
              c:identifier="gst_value_array_prepend_value">
      <doc xml:whitespace="preserve">Prepends @prepend_value to the GstValueArray in @value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_ARRAY</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="prepend_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to prepend</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_can_compare" c:identifier="gst_value_can_compare">
      <doc xml:whitespace="preserve">Determines if @value1 and @value2 can be compared.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the values can be compared</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to compare</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to compare</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_can_intersect"
              c:identifier="gst_value_can_intersect">
      <doc xml:whitespace="preserve">Determines if intersecting two values will produce a valid result.
Two values will produce a valid intersection if they have the same
type, or if there is a method (registered by
gst_value_register_intersect_func()) to calculate the intersection.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the values can intersect</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to intersect</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to intersect</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_can_subtract" c:identifier="gst_value_can_subtract">
      <doc xml:whitespace="preserve">Checks if it's possible to subtract @subtrahend from @minuend.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if a subtraction is possible</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="minuend" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to subtract from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="subtrahend" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to subtract</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_can_union" c:identifier="gst_value_can_union">
      <doc xml:whitespace="preserve">Determines if @value1 and @value2 can be non-trivially unioned.
Any two values can be trivially unioned by adding both of them
to a GstValueList.  However, certain types have the possibility
to be unioned in a simpler way.  For example, an integer range
and an integer can be unioned if the integer is a subset of the
integer range.  If there is the possibility that two values can
be unioned, this function returns TRUE.
be unioned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if there is a function allowing the two values to</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to union</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to union</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_compare" c:identifier="gst_value_compare">
      <doc xml:whitespace="preserve">Compares @value1 and @value2.  If @value1 and @value2 cannot be
compared, the function returns GST_VALUE_UNORDERED.  Otherwise,
if @value1 is greater than @value2, GST_VALUE_GREATER_THAN is returned.
If @value1 is less than @value2, GST_VALUE_LESS_THAN is returned.
If the values are equal, GST_VALUE_EQUAL is returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">comparison result</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to compare</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to compare</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_deserialize" c:identifier="gst_value_deserialize">
      <doc xml:whitespace="preserve">Tries to deserialize a string into the type specified by the given GValue.
If the operation succeeds, TRUE is returned, FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">#GValue to fill with contents of deserialization</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">string to deserialize</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_dup_mini_object"
              c:identifier="gst_value_dup_mini_object"
              version="0.10.20">
      <doc xml:whitespace="preserve">Get the contents of a %GST_TYPE_MINI_OBJECT derived #GValue,
increasing its reference count. If the contents of the #GValue
are %NULL, %NULL will be returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">mini object contents of @value</doc>
        <type name="MiniObject" c:type="GstMiniObject*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a valid #GValue of %GST_TYPE_MINI_OBJECT derived type</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_fraction_multiply"
              c:identifier="gst_value_fraction_multiply">
      <doc xml:whitespace="preserve">Multiplies the two #GValue items containing a #GST_TYPE_FRACTION and sets</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">FALSE in case of an error (like integer overflow), TRUE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="product" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="factor1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="factor2" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_fraction_subtract"
              c:identifier="gst_value_fraction_subtract">
      <doc xml:whitespace="preserve">Subtracts the @subtrahend from the @minuend and sets @dest to the result.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">FALSE in case of an error (like integer overflow), TRUE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="minuend" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="subtrahend" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_caps" c:identifier="gst_value_get_caps">
      <doc xml:whitespace="preserve">Gets the contents of @value. The reference count of the returned
#GstCaps will not be modified, therefore the caller must take one
before getting rid of the @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the contents of @value</doc>
        <type name="Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_CAPS</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_date" c:identifier="gst_value_get_date">
      <doc xml:whitespace="preserve">Gets the contents of @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the contents of @value</doc>
        <type name="GLib.Date" c:type="GDate*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_DATE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_double_range_max"
              c:identifier="gst_value_get_double_range_max">
      <doc xml:whitespace="preserve">Gets the maximum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maxumum of the range</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_DOUBLE_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_double_range_min"
              c:identifier="gst_value_get_double_range_min">
      <doc xml:whitespace="preserve">Gets the minimum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the minimum of the range</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_DOUBLE_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_fourcc" c:identifier="gst_value_get_fourcc">
      <doc xml:whitespace="preserve">Gets the #guint32 fourcc contained in @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the #guint32 fourcc contained in @value.</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FOURCC</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_fraction_denominator"
              c:identifier="gst_value_get_fraction_denominator">
      <doc xml:whitespace="preserve">Gets the denominator of the fraction specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the denominator of the fraction.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_fraction_numerator"
              c:identifier="gst_value_get_fraction_numerator">
      <doc xml:whitespace="preserve">Gets the numerator of the fraction specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the numerator of the fraction.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_fraction_range_max"
              c:identifier="gst_value_get_fraction_range_max">
      <doc xml:whitespace="preserve">Gets the maximum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maximum of the range</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_FRACTION_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_fraction_range_min"
              c:identifier="gst_value_get_fraction_range_min">
      <doc xml:whitespace="preserve">Gets the minimum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the minimum of the range</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_FRACTION_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_int64_range_max"
              c:identifier="gst_value_get_int64_range_max"
              version="0.10.31">
      <doc xml:whitespace="preserve">Gets the maximum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maxumum of the range</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT64_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_int64_range_min"
              c:identifier="gst_value_get_int64_range_min"
              version="0.10.31">
      <doc xml:whitespace="preserve">Gets the minimum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the minimum of the range</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT64_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_int_range_max"
              c:identifier="gst_value_get_int_range_max">
      <doc xml:whitespace="preserve">Gets the maximum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maxumum of the range</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_int_range_min"
              c:identifier="gst_value_get_int_range_min">
      <doc xml:whitespace="preserve">Gets the minimum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the minimum of the range</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_mini_object"
              c:identifier="gst_value_get_mini_object">
      <doc xml:whitespace="preserve">Get the contents of a %GST_TYPE_MINI_OBJECT derived #GValue.
Does not increase the refcount of the returned object.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">mini object contents of @value</doc>
        <type name="MiniObject" c:type="GstMiniObject*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a valid #GValue of %GST_TYPE_MINI_OBJECT derived type</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_structure"
              c:identifier="gst_value_get_structure"
              version="0.10.15">
      <doc xml:whitespace="preserve">Gets the contents of @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the contents of @value</doc>
        <type name="Structure" c:type="GstStructure*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_STRUCTURE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_init_and_copy"
              c:identifier="gst_value_init_and_copy">
      <doc xml:whitespace="preserve">Initialises the target value to be of the same type as source and then copies
the contents from source to target.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">the target value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_intersect" c:identifier="gst_value_intersect">
      <doc xml:whitespace="preserve">Calculates the intersection of two values.  If the values have
a non-empty intersection, the value representing the intersection
is placed in @dest.  If the intersection is non-empty, @dest is
not modified.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the intersection is non-empty</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">a uninitialized #GValue that will hold the calculated intersection value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to intersect</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to intersect</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_is_fixed" c:identifier="gst_value_is_fixed">
      <doc xml:whitespace="preserve">Tests if the given GValue, if available in a GstStructure (or any other
(which means: multiple possible values, such as data lists or data
ranges) value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">true if the value is "fixed".</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue to check</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_list_append_value"
              c:identifier="gst_value_list_append_value">
      <doc xml:whitespace="preserve">Appends @append_value to the GstValueList in @value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_LIST</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="append_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to append</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_list_concat" c:identifier="gst_value_list_concat">
      <doc xml:whitespace="preserve">Concatenates copies of @value1 and @value2 into a list.  Values that are not
of type #GST_TYPE_LIST are treated as if they were lists of length 1.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">an uninitialized #GValue to take the result</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_list_get_size"
              c:identifier="gst_value_list_get_size">
      <doc xml:whitespace="preserve">Gets the number of values contained in @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the number of values</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_LIST</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_list_get_type"
              c:identifier="gst_value_list_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="value_list_get_value"
              c:identifier="gst_value_list_get_value">
      <doc xml:whitespace="preserve">Gets the value that is a member of the list contained in @value and
has the index @index.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the value at the given index</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_LIST</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="index" transfer-ownership="none">
          <doc xml:whitespace="preserve">index of value to get from the list</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_list_merge"
              c:identifier="gst_value_list_merge"
              version="0.10.32">
      <doc xml:whitespace="preserve">Merges copies of @value1 and @value2.  Values that are not
of type #GST_TYPE_LIST are treated as if they were lists of length 1.
The result will be put into @dest and will either be a list that will not
contain any duplicates, or a non-list type (if @value1 and @value2
were equal).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">an uninitialized #GValue to take the result</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_list_prepend_value"
              c:identifier="gst_value_list_prepend_value">
      <doc xml:whitespace="preserve">Prepends @prepend_value to the GstValueList in @value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_LIST</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="prepend_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to prepend</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_register" c:identifier="gst_value_register">
      <doc xml:whitespace="preserve">Registers functions to perform calculations on #GValue items of a given
type. Each type can only be added once.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="table" transfer-ownership="none">
          <doc xml:whitespace="preserve">structure containing functions to register</doc>
          <type name="ValueTable" c:type="GstValueTable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_register_intersect_func"
              c:identifier="gst_value_register_intersect_func"
              introspectable="0">
      <doc xml:whitespace="preserve">Registers a function that is called to calculate the intersection
of the values having the types @type1 and @type2.
Intersect functions should be registered at startup before any pipelines are
started, as gst_value_register_intersect_func() is not thread-safe and
cannot be used at the same time as gst_value_intersect() or
gst_value_can_intersect().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type1" transfer-ownership="none">
          <doc xml:whitespace="preserve">the first type to intersect</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="type2" transfer-ownership="none">
          <doc xml:whitespace="preserve">the second type to intersect</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">the intersection function</doc>
          <type name="ValueIntersectFunc" c:type="GstValueIntersectFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_register_subtract_func"
              c:identifier="gst_value_register_subtract_func"
              introspectable="0">
      <doc xml:whitespace="preserve">Registers @func as a function capable of subtracting the values of
Subtract functions should be registered at startup before any pipelines are
started, as gst_value_register_subtract_func() is not thread-safe and
cannot be used at the same time as gst_value_subtract().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="minuend_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">type of the minuend</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="subtrahend_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">type of the subtrahend</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">function to use</doc>
          <type name="ValueSubtractFunc" c:type="GstValueSubtractFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_register_union_func"
              c:identifier="gst_value_register_union_func"
              introspectable="0">
      <doc xml:whitespace="preserve">Registers a union function that can create a union between #GValue items
of the type @type1 and @type2.
Union functions should be registered at startup before any pipelines are
started, as gst_value_register_union_func() is not thread-safe and cannot
be used at the same time as gst_value_union() or gst_value_can_union().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a type to union</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="type2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another type to union</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">a function that implments creating a union between the two types</doc>
          <type name="ValueUnionFunc" c:type="GstValueUnionFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_serialize" c:identifier="gst_value_serialize">
      <doc xml:whitespace="preserve">tries to transform the given @value into a string representation that allows
getting back this string later on using gst_value_deserialize().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the serialization for @value or NULL if none exists</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue to serialize</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_caps" c:identifier="gst_value_set_caps">
      <doc xml:whitespace="preserve">Sets the contents of @value to @caps. A reference to the
provided @caps will be taken by the @value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_CAPS</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="caps" transfer-ownership="none">
          <doc xml:whitespace="preserve">the caps to set the value to</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_date" c:identifier="gst_value_set_date">
      <doc xml:whitespace="preserve">Sets the contents of @value to coorespond to @date.  The actual
#GDate structure is copied before it is used.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_DATE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="date" transfer-ownership="none">
          <doc xml:whitespace="preserve">the date to set the value to</doc>
          <type name="GLib.Date" c:type="GDate*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_double_range"
              c:identifier="gst_value_set_double_range">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @start and @end.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_DOUBLE_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the start of the range</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the end of the range</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_fourcc" c:identifier="gst_value_set_fourcc">
      <doc xml:whitespace="preserve">Sets @value to @fourcc.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FOURCC</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="fourcc" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #guint32 fourcc to set</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_fraction" c:identifier="gst_value_set_fraction">
      <doc xml:whitespace="preserve">Sets @value to the fraction specified by @numerator over @denominator.
The fraction gets reduced to the smallest numerator and denominator,
and if necessary the sign is moved to the numerator.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="numerator" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator of the fraction</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denominator" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator of the fraction</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_fraction_range"
              c:identifier="gst_value_set_fraction_range">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @start and @end.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_FRACTION_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the start of the range (a GST_TYPE_FRACTION GValue)</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the end of the range (a GST_TYPE_FRACTION GValue)</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_fraction_range_full"
              c:identifier="gst_value_set_fraction_range_full">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @numerator_start/@denominator_start
and @numerator_end/@denominator_end.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_FRACTION_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="numerator_start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator start of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denominator_start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator start of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="numerator_end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator end of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denominator_end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator end of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_int64_range"
              c:identifier="gst_value_set_int64_range"
              version="0.10.31">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @start and @end.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT64_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the start of the range</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the end of the range</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_int_range"
              c:identifier="gst_value_set_int_range">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @start and @end.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the start of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the end of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_mini_object"
              c:identifier="gst_value_set_mini_object">
      <doc xml:whitespace="preserve">Set the contents of a %GST_TYPE_MINI_OBJECT derived #GValue to
The caller retains ownership of the reference.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a valid #GValue of %GST_TYPE_MINI_OBJECT derived type</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="mini_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">mini object value to set</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_structure"
              c:identifier="gst_value_set_structure"
              version="0.10.15">
      <doc xml:whitespace="preserve">Sets the contents of @value to @structure.  The actual</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_STRUCTURE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="structure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the structure to set the value to</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_subtract" c:identifier="gst_value_subtract">
      <doc xml:whitespace="preserve">Subtracts @subtrahend from @minuend and stores the result in @dest.
Note that this means subtraction as in sets, not as in mathematics.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the subtraction is not empty</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">the destination value for the result if the subtraction is not empty</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="minuend" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to subtract from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="subtrahend" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to subtract</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_take_mini_object"
              c:identifier="gst_value_take_mini_object">
      <doc xml:whitespace="preserve">Set the contents of a %GST_TYPE_MINI_OBJECT derived #GValue to
Takes over the ownership of the caller's reference to @mini_object;
the caller doesn't have to unref it any more.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a valid #GValue of %GST_TYPE_MINI_OBJECT derived type</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="mini_object" transfer-ownership="full">
          <doc xml:whitespace="preserve">mini object value to take</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_union" c:identifier="gst_value_union">
      <doc xml:whitespace="preserve">Creates a GValue corresponding to the union of @value1 and @value2.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">always returns %TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">the destination value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to union</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to union</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="version" c:identifier="gst_version">
      <doc xml:whitespace="preserve">Gets the version number of the GStreamer library.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="major"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a guint to store the major version number</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="minor"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a guint to store the minor version number</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="micro"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a guint to store the micro version number</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="nano"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a guint to store the nano version number</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="version_string" c:identifier="gst_version_string">
      <doc xml:whitespace="preserve">This function returns a string that is useful for describing this version
of GStreamer.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated string describing this version</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
    </function>
  </namespace>
</repository>
