IN: sequences
USING: arrays help kernel kernel-internals sequences-internals
strings vectors words ;

ARTICLE: "sequence-implementations" "Sequence implementations"
"There are two basic types of sequences. Instances of the following two types have fixed length:"
{ $subsection "arrays" }
{ $subsection "strings" }
"Instances of the following are resizable:"
{ $subsection "vectors" }
{ $subsection "sbufs" }
"Quotations are special sequences which hold code:"
{ $subsection "quotations" }
"Integers support the sequence protocol:"
{ $subsection "sequences-integers" }
"The " { $link f } " object also supports the sequence protocol. It responds with a length of zero, and instead of throwing an out of bounds error, outputs " { $link f } " when an element is accessed. This can simplify code that would like a dummy sequence behaving as if it has arbitrary length." ;

ARTICLE: "sequences-integers" "Integer sequences and counted loops"
"Integers support the sequence protocol in a trivial fashion; a non-negative integer presents its non-negative predecessors as elements. For example, the integer 3, when viewed as a sequence, contains the elements 0, 1, and 2. This is very useful for performing counted loops."
$terpri
"For example, the " { $link each } " combinator, given an integer, simply calls a quotation that number of times, pushing a counter on each iteration that ranges from 0 up to that integer:"
{ $example "3 [ . ] each" "0\n1\n2" }
"A common idiom is to iterate over a sequence, while also maintaining a loop counter. This can be done using " { $link 2each } ":"
{ $example "{ \"a\" \"b\" \"c\" } dup length [\n    \"Index: \" write . \"Element: \" write .\n] 2each" "Index: 0\nElement: \"a\"\nIndex: 1\nElement: \"b\"\nIndex: 2\nElement: \"c\"" }
"Combinators that produce new sequences, such as " { $link map } ", will output an array if the input is an integer." ;

ARTICLE: "sequences-access" "Accessing sequence elements"
{ $subsection nth }
{ $subsection ?nth }
{ $subsection first }
{ $subsection second }
{ $subsection third }
{ $subsection fourth }
{ $subsection first2 }
{ $subsection first3 }
{ $subsection first4 }
{ $subsection peek }
{ $subsection last/first } ;

ARTICLE: "sequences-combinators" "Sequence combinators"
"Iteration:"
{ $subsection each }
{ $subsection each-with }
{ $subsection reduce }
{ $subsection interleave }
{ $subsection 2each }
{ $subsection 2reduce }
"Mapping:"
{ $subsection map }
{ $subsection map-with }
{ $subsection accumulate }
{ $subsection 2map }
"Filtering:"
{ $subsection subset }
{ $subsection subset-with } ;

ARTICLE: "sequences-tests" "Testing sequences"
"Testing for an empty sequence:"
{ $subsection empty? }
"Testing indices:"
{ $subsection bounds-check? }
"Testing if a sequence contains an object:"
{ $subsection member? }
{ $subsection memq? }
"Testing if a sequence contains a subsequence:"
{ $subsection head? }
{ $subsection tail? }
{ $subsection subseq? }
"Testing if a sequence contains elements satisfying a predicate:"
{ $subsection contains? }
{ $subsection contains-with? }
{ $subsection all? }
{ $subsection all-with? }
"Testing how elements are related:"
{ $subsection monotonic? }
{ $subsection all-eq? }
{ $subsection all-equal? } ;

ARTICLE: "sequences-search" "Searching sequences"
"Finding the index of an element:"
{ $subsection index }
{ $subsection index* }
{ $subsection last-index }
{ $subsection last-index* }
"Finding the start of a subsequence:"
{ $subsection start }
{ $subsection start* }
"Finding the index of an element satisfying a predicate:"
{ $subsection find }
{ $subsection find* }
{ $subsection find-with }
{ $subsection find-with* }
{ $subsection find-last }
{ $subsection find-last-with }
{ $subsection find-last* }
{ $subsection find-last-with* } ;

ARTICLE: "sequences-join-split" "Joining and splitting sequences"
"Forming new sequences from existing sequences:"
{ $subsection append }
{ $subsection append3 }
{ $subsection concat }
{ $subsection join }
{ $subsection replace-slice }
"Slicing sequences:"
{ $subsection subseq }
{ $subsection head }
{ $subsection tail }
{ $subsection head* }
{ $subsection tail* }
"Variants of the above which output a virtual sequence sharing storage with the input sequence:"
{ $subsection <slice> }
{ $subsection head-slice }
{ $subsection tail-slice }
{ $subsection head-slice* }
{ $subsection tail-slice* }
"Splitting sequences at specific indices:"
{ $subsection cut }
{ $subsection cut* }
{ $subsection unclip }
"Splitting sequences at occurrences of subsequences:"
{ $subsection ?head }
{ $subsection ?tail }
{ $subsection split1 }
{ $subsection split }
{ $subsection drop-prefix } ;

ARTICLE: "sequences-add-remove" "Adding and removing sequence elements"
"Adding elements:"
{ $subsection add }
{ $subsection add* }
"Removing elements:"
{ $subsection remove }
{ $subsection remove-nth }
{ $subsection diff }
{ $subsection prune } ;

ARTICLE: "sequences-reshape" "Reshaping sequences"
{ $subsection reverse }
{ $subsection <reversed> }
{ $subsection group }
{ $subsection flatten }
{ $subsection flip }
{ $subsection subst } ;

ARTICLE: "sequences-destructive" "Destructive operations"
"These words modify their input, instead of creating a new sequence."
$terpri
"In-place variant of " { $link add } ":"
{ $subsection push }
"In-place variant of " { $link append } ":"
{ $subsection nappend }
"In-place variant of " { $link remove } ":"
{ $subsection delete }
"In-place variant of " { $link map } ":"
{ $subsection inject }
{ $subsection inject-with }
"Changing elements:"
{ $subsection set-nth }
{ $subsection change-nth }
{ $subsection cache-nth }
"Other destructive words:"
{ $subsection exchange }
{ $subsection push-new }
{ $subsection pop }
{ $subsection pop* }
{ $subsection delete-all }
{ $subsection copy-into } ;

ARTICLE: "sequences-stacks" "Stack operations"
"The classical stack operations, modifying a sequence in place:"
{ $subsection empty? }
{ $subsection peek }
{ $subsection push }
{ $subsection pop }
{ $subsection pop* }
"Lazy instantiation of stacks:"
{ $subsection ?push } ;

ARTICLE: "sequences-comparing" "Comparing sequences"
"Element equality:"
{ $subsection sequence= }
{ $subsection mismatch }
"Lexicographic order:"
{ $subsection <=> } ;

ARTICLE: "sequences-assoc" "Association lists"
"An " { $emphasis "association list" } " is a sequence of pairs. Association lists come up from time to time; for example, the " { $link cond } " combinator takes an association list of quotations as input. You can perform lookups and take association lists apart:"
{ $subsection assoc }
{ $subsection rassoc }
{ $subsection unpair }
"An association list is slower to search than a hashtable. The main advantage of an association list is that the elements are ordered; also sometimes it is more convenient to construct an association list with sequence words than to construct a hashtable with hastable words. Most of the time, hashtables are more appropriate. See " { $link "hashtables" } "." ;

ARTICLE: "sequence-protocol" "Sequence protocol"
"All sequences must know their length, and provide a way to access elements:"
{ $subsection length }
{ $subsection nth }
"Mutable sequences:"
{ $subsection set-nth }
"Resizable sequences:"
{ $subsection set-length }
"An optional generic word for creating sequences of the same class as a given sequence:"
{ $subsection like }
"Another optional generic word for optimization purposes:"
{ $subsection thaw } ;

ARTICLE: "arrays" "Arrays"
"An array is a fixed-size mutable sequence whose elements are stored in a contiguous range of memory. The literal syntax is covered in " { $link "syntax-arrays" } ". Sometimes you need a resizable array -- this is called a vector, and vectors are documented in " { $link "vectors" } "."
$terpri
"Array words are in the " { $vocab-link "arrays" } " vocabulary. Unsafe implementation words are in the " { $vocab-link "kernel-internals" } " vocabulary."
$terpri
"Arrays form a class of objects."
{ $subsection array }
{ $subsection array? }
"There are several ways to construct arrays."
{ $subsection >array }
{ $subsection <array> }
{ $subsection 1array }
{ $subsection 2array }
{ $subsection 3array }
{ $subsection 4array }
"Arrays can be accessed without bounds checks in a pointer unsafe way."
{ $subsection array-nth }
{ $subsection set-array-nth } ;

ARTICLE: "strings" "Strings"
"A string is a fixed-size mutable sequence of characters."
$terpri
"String words are found in the " { $vocab-link "strings" } " vocabulary."
{ $subsection string? }
{ $subsection >string }
{ $subsection <string> }
"A pair of words are used to nicely format columns of text."
{ $subsection pad-left }
{ $subsection pad-right }
"Characters are not a first-class type; they are simply represented as integers between 0 and 65535. A few words operate on characters:"
{ $subsection blank? }
{ $subsection letter? }
{ $subsection LETTER? }
{ $subsection digit? }
{ $subsection printable? }
{ $subsection control? }
{ $subsection quotable? }
{ $subsection ch>lower }
{ $subsection ch>upper } ;

ARTICLE: "sbufs" "String buffers"
"A string buffer is a resizable mutable sequence of characters. String buffers can be used to construct new strings by accumilating substrings and characters, however usually they are only used indirectly, since the sequence construction words are more convenient to use in most cases (see " { $link "namespaces-make" } ")."
$terpri
"String buffer words are found in the " { $vocab-link "strings" } " vocabulary."
{ $subsection sbuf? }
"Words for creating string buffers:"
{ $subsection >sbuf }
{ $subsection <sbuf> }
"If you don't care about initial capacity, a more elegant way to create a new string buffer is to write:"
{ $code "SBUF\" \" clone" } ;

ARTICLE: "vectors" "Vectors"
"A vector is a resizable mutable sequence of objects. Vector words are found in the " { $vocab-link "vectors" } " vocabulary."
{ $subsection vector? }
"Words for creating vectors:"
{ $subsection >vector }
{ $subsection <vector> }
"If you don't care about initial capacity, a more elegant way to create a new vector is to write:"
{ $code "V{ } clone" } ;

ARTICLE: "sequences-sorting" "Sorting and binary search"
"Sorting and binary search combinators all take comparator quotations with stack effect " { $snippet "( elt1 elt2 -- n )" } " that order the two given elements and output a value whose sign denotes the result:"
{ $list
    { "positive - indicates that " { $snippet "elt1" } " follows " { $snippet "elt2" } }
    { "zero - indicates that " { $snippet "elt1" } " is ordered equivalently to " { $snippet "elt2" } }
    { "negative - indicates that " { $snippet "elt1" } " precedes " { $snippet "elt2" } }
}
"In-place sorting:"
{ $subsection nsort }
"Sorting elements in a new sequence:"
{ $subsection sort }
"Using the default comparator:"
{ $subsection natural-sort }
"Binary search:"
{ $subsection binsearch }
{ $subsection binsearch* } ;

ARTICLE: "sequences-unsafe" "Unsafe sequence operations"
"The unsafe sequence protocol bypasses bounds checks for increased performance:"
{ $subsection nth-unsafe }
{ $subsection set-nth-unsafe }
"These words assume the sequence index given is within bounds; if it is not, memory corruption can occur. Please think twice before using them; first, make sure the code in question is actually a bottleneck; next, try improving the algorithm first. If all else fails, then use these words and test your code very carefully."
$terpri
"There is a very important invariant these word must preserve: if at some point in time, the length of a sequence was " { $snippet "n" } ", then any future lookups of elements with indices below " { $snippet "n" } " must not crash the runtime, even if the sequence length is now less than " { $snippet "n" } ". For example, vectors preserve this invariant by never shrinking the underlying storage, only growing it as necessary."
$terpri
"The justification for this is that the runtime should not crash if a resizable sequence is resized during the execution of an iteration combinator."
$terpri
"Indeed, iteration combinators are the primary use-case for these words; if the iteration index is already guarded by a loop test which ensures it is within bounds, then additional bounds checks are redundant. For example, see the implementation of " { $link each } "." ;

ARTICLE: "sequences-resizable" "Resizable sequence implementation"
"Resizable sequences are implementing by having a wrapper object hold a reference to an underlying sequence, together with a fill pointer indicating how many elements of the underlying sequence are occupied. When the fill pointer exceeds the underlying sequence capacity, the underlying sequence grows."
$terpri
"There is a resizable sequence protocol:"
{ $subsection underlying }
{ $subsection set-underlying }
{ $subsection set-fill }
"Any instance of a class implementing the above generics can make use of several utility words:"
{ $subsection capacity }
{ $subsection ensure }
{ $subsection grow-length }
{ $subsection clone-resizable }
"This protocol and the above words are unsafe; they do not perform bounds checks for performance reasons, and thus a mistake can lead to memory corruption due to an underlying sequence being shorter than the fill pointer."
$terpri
"Vectors and string buffers are implemented using the resizable sequence facility (and they perform full bounds-checks and thus are safe)." ;

ARTICLE: "sequences" "Sequences"
"A sequence is a linearly-ordered finite collection of elements."
$terpri
"Sequence utility words can operate on any object whose class implements the sequence protocol."
{ $subsection "sequence-protocol" }
"There are a number of implementations of sequences in the core library, and you can write new implementations yourself."
{ $subsection "sequence-implementations" }
"Much of the power of sequences lies in the polymorphic utility words that allow computations to be expressed as bulk operations without loops, recursion or micro-management of elements."
{ $subsection "sequences-access" }
{ $subsection "sequences-combinators" }
{ $subsection "sequences-tests" }
{ $subsection "sequences-search" }
{ $subsection "sequences-add-remove" }
{ $subsection "sequences-join-split" }
{ $subsection "sequences-reshape" }
{ $subsection "sequences-comparing" }
{ $subsection "sequences-sorting" }
{ $subsection "sequences-destructive" }
"Sequences are also used to implement other data structures:"
{ $subsection "sequences-stacks" }
{ $subsection "sequences-assoc" }
"Some implementation details which your code should probably not care about:"
{ $subsection "sequences-unsafe" }
{ $subsection "sequences-resizable" }
{ $see-also "namespaces-make" } ;
