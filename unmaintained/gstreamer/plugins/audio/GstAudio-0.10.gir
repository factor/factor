<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gst" version="0.10"/>
  <include name="GstBase" version="0.10"/>
  <include name="GstInterfaces" version="0.10"/>
  <include name="libxml2" version="2.0"/>
  <package name="gstreamer-audio-0.10"/>
  <c:include name="gst/audio/audio-enumtypes.h"/>
  <c:include name="gst/audio/audio.h"/>
  <c:include name="gst/audio/gstaudioclock.h"/>
  <c:include name="gst/audio/gstaudiofilter.h"/>
  <c:include name="gst/audio/gstaudiosink.h"/>
  <c:include name="gst/audio/gstaudiosrc.h"/>
  <c:include name="gst/audio/gstbaseaudiosink.h"/>
  <c:include name="gst/audio/gstbaseaudiosrc.h"/>
  <c:include name="gst/audio/gstringbuffer.h"/>
  <c:include name="gst/audio/mixerutils.h"/>
  <c:include name="gst/audio/multichannel.h"/>
  <namespace name="GstAudio"
             version="0.10"
             shared-library="libgstaudio-0.10.so.0"
             c:identifier-prefixes="Gst"
             c:symbol-prefixes="gst">
    <constant name="AUDIO_DEF_RATE" value="44100">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUDIO_FLOAT_PAD_TEMPLATE_CAPS"
              value="audio/x-raw-float, rate = (int) [ 1, MAX ], channels = (int) [ 1, MAX ], endianness = (int) { LITTLE_ENDIAN , BIG_ENDIAN }, width = (int) { 32, 64 }">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_FLOAT_STANDARD_PAD_TEMPLATE_CAPS"
              value="audio/x-raw-float, width = (int) 32, rate = (int) [ 1, MAX ], channels = (int) 1, endianness = (int) BYTE_ORDER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_INT_PAD_TEMPLATE_CAPS"
              value="audio/x-raw-int, rate = (int) [ 1, MAX ], channels = (int) [ 1, MAX ], endianness = (int) { LITTLE_ENDIAN, BIG_ENDIAN }, width = (int) { 8, 16, 24, 32 }, depth = (int) [ 1, 32 ], signed = (boolean) { true, false }">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_INT_STANDARD_PAD_TEMPLATE_CAPS"
              value="audio/x-raw-int, rate = (int) [ 1, MAX ], channels = (int) 2, endianness = (int) BYTE_ORDER, width = (int) 16, depth = (int) 16, signed = (boolean) true">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="AudioChannelPosition"
                 glib:type-name="GstAudioChannelPosition"
                 glib:get-type="gst_audio_channel_position_get_type"
                 c:type="GstAudioChannelPosition">
      <member name="invalid"
              value="-1"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_INVALID"
              glib:nick="invalid"/>
      <member name="front_mono"
              value="0"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_MONO"
              glib:nick="front-mono"/>
      <member name="front_left"
              value="1"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT"
              glib:nick="front-left"/>
      <member name="front_right"
              value="2"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT"
              glib:nick="front-right"/>
      <member name="rear_center"
              value="3"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_CENTER"
              glib:nick="rear-center"/>
      <member name="rear_left"
              value="4"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_LEFT"
              glib:nick="rear-left"/>
      <member name="rear_right"
              value="5"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT"
              glib:nick="rear-right"/>
      <member name="lfe"
              value="6"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_LFE"
              glib:nick="lfe"/>
      <member name="front_center"
              value="7"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER"
              glib:nick="front-center"/>
      <member name="front_left_of_center"
              value="8"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER"
              glib:nick="front-left-of-center"/>
      <member name="front_right_of_center"
              value="9"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER"
              glib:nick="front-right-of-center"/>
      <member name="side_left"
              value="10"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT"
              glib:nick="side-left"/>
      <member name="side_right"
              value="11"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT"
              glib:nick="side-right"/>
      <member name="none"
              value="12"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_NONE"
              glib:nick="none"/>
      <member name="num"
              value="13"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_NUM"
              glib:nick="num"/>
    </enumeration>
    <class name="AudioClock"
           c:symbol-prefix="audio_clock"
           c:type="GstAudioClock"
           parent="Gst.SystemClock"
           glib:type-name="GstAudioClock"
           glib:get-type="gst_audio_clock_get_type"
           glib:type-struct="AudioClockClass">
      <doc xml:whitespace="preserve">Opaque #GstAudioClock.</doc>
      <constructor name="new"
                   c:identifier="gst_audio_clock_new"
                   introspectable="0">
        <doc xml:whitespace="preserve">Create a new #GstAudioClock instance. Whenever the clock time should be
calculated it will call @func with @user_data. When @func returns
#GST_CLOCK_TIME_NONE, the clock will return the last reported time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstAudioClock casted to a #GstClock.</doc>
          <type name="Gst.Clock" c:type="GstClock*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the clock</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">a function</doc>
            <type name="AudioClockGetTimeFunc"
                  c:type="GstAudioClockGetTimeFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full"
                   c:identifier="gst_audio_clock_new_full"
                   version="0.10.31">
        <doc xml:whitespace="preserve">Create a new #GstAudioClock instance. Whenever the clock time should be
calculated it will call @func with @user_data. When @func returns
#GST_CLOCK_TIME_NONE, the clock will return the last reported time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstAudioClock casted to a #GstClock.</doc>
          <type name="Gst.Clock" c:type="GstClock*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the clock</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">a function</doc>
            <type name="AudioClockGetTimeFunc"
                  c:type="GstAudioClockGetTimeFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_notify"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">#GDestroyNotify for @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="adjust"
                c:identifier="gst_audio_clock_adjust"
                version="0.10.23">
        <doc xml:whitespace="preserve">Adjust @time with the internal offset of the audio clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@time adjusted with the internal offset.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstAudioClock</doc>
            <type name="Gst.Clock" c:type="GstClock*"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockTime</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_time"
                c:identifier="gst_audio_clock_get_time"
                version="0.10.23">
        <doc xml:whitespace="preserve">Report the time as returned by the #GstAudioClockGetTimeFunc without applying
any offsets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the time as reported by the time function of the audio clock</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstAudioClock</doc>
            <type name="Gst.Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </function>
      <function name="invalidate"
                c:identifier="gst_audio_clock_invalidate"
                version="0.10.31">
        <doc xml:whitespace="preserve">Invalidate the clock function. Call this function when the provided
#GstAudioClockGetTimeFunc cannot be called anymore, for example, when the
user_data becomes invalid.
After calling this function, @clock will return the last returned time for
the rest of its lifetime.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstAudioClock</doc>
            <type name="Gst.Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </function>
      <method name="reset" c:identifier="gst_audio_clock_reset">
        <doc xml:whitespace="preserve">Inform @clock that future calls to #GstAudioClockGetTimeFunc will return values
starting from @time. The clock will update an internal offset to make sure that
future calls to internal_time will return an increasing result as required by
the #GstClock object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockTime</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <field name="clock">
        <type name="Gst.SystemClock" c:type="GstSystemClock"/>
      </field>
      <field name="func">
        <type name="AudioClockGetTimeFunc" c:type="GstAudioClockGetTimeFunc"/>
      </field>
      <field name="user_data">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="last_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="time_offset" writable="1">
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </field>
          <field name="destroy_notify" writable="1">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="4">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
    </class>
    <record name="AudioClockClass"
            c:type="GstAudioClockClass"
            glib:is-gtype-struct-for="AudioClock">
      <field name="parent_class">
        <type name="Gst.SystemClockClass" c:type="GstSystemClockClass"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="AudioClockGetTimeFunc" c:type="GstAudioClockGetTimeFunc">
      <doc xml:whitespace="preserve">This function will be called whenever the current clock time needs to be
calculated. If this function returns #GST_CLOCK_TIME_NONE, the last reported
time will be returned by the clock.
be used.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the current time or #GST_CLOCK_TIME_NONE if the previous time should</doc>
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </return-value>
      <parameters>
        <parameter name="clock" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstAudioClock</doc>
          <type name="Gst.Clock" c:type="GstClock*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="AudioFieldFlag"
              deprecated="use gst_structure_set() directly"
              c:type="GstAudioFieldFlag">
      <doc xml:whitespace="preserve">Do not use anymore.</doc>
      <member name="rate" value="1" c:identifier="GST_AUDIO_FIELD_RATE"/>
      <member name="channels"
              value="2"
              c:identifier="GST_AUDIO_FIELD_CHANNELS"/>
      <member name="endianness"
              value="4"
              c:identifier="GST_AUDIO_FIELD_ENDIANNESS"/>
      <member name="width" value="8" c:identifier="GST_AUDIO_FIELD_WIDTH"/>
      <member name="depth" value="16" c:identifier="GST_AUDIO_FIELD_DEPTH"/>
      <member name="signed" value="32" c:identifier="GST_AUDIO_FIELD_SIGNED"/>
    </bitfield>
    <class name="AudioFilter"
           c:symbol-prefix="audio_filter"
           c:type="GstAudioFilter"
           version="0.10.12"
           parent="GstBase.BaseTransform"
           abstract="1"
           glib:type-name="GstAudioFilter"
           glib:get-type="gst_audio_filter_get_type"
           glib:type-struct="AudioFilterClass">
      <doc xml:whitespace="preserve">Base class for audio filters with the same format for input and output.</doc>
      <virtual-method name="setup">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="basetransform">
        <type name="GstBase.BaseTransform" c:type="GstBaseTransform"/>
      </field>
      <field name="format">
        <type name="RingBufferSpec" c:type="GstRingBufferSpec"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioFilterClass"
            c:type="GstAudioFilterClass"
            glib:is-gtype-struct-for="AudioFilter"
            version="0.10.12">
      <doc xml:whitespace="preserve">In addition to the @setup virtual function, you should also override the
GstBaseTransform::transform and/or GstBaseTransform::transform_ip virtual
function.</doc>
      <field name="basetransformclass">
        <type name="GstBase.BaseTransformClass"
              c:type="GstBaseTransformClass"/>
      </field>
      <field name="setup">
        <callback name="setup">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <type name="AudioFilter" c:type="GstAudioFilter*"/>
            </parameter>
            <parameter name="format" transfer-ownership="none">
              <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="add_pad_templates"
              c:identifier="gst_audio_filter_class_add_pad_templates"
              version="0.10.12">
        <doc xml:whitespace="preserve">Convenience function to add pad templates to this element class, with
This function is usually used from within a GObject base_init function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="allowed_caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">what formats the filter can handle, as #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="AudioMixerFilterFunc" c:type="GstAudioMixerFilterFunc">
      <doc xml:whitespace="preserve">Function that will be called by gst_audio_default_registry_mixer_filter()
so the caller can decide which mixer elements should be kept and returned.
When the mixer element is passed to the callback function, it is opened
and in READY state. If you decide to keep the element, you need to set it
back to NULL state yourself (unless you want to keep it opened of course).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the element should be kept, FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mixer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstElement implementing the #GstMixer interface</doc>
          <type name="GstInterfaces.Mixer" c:type="GstMixer*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="AudioSink"
           c:symbol-prefix="audio_sink"
           c:type="GstAudioSink"
           parent="BaseAudioSink"
           glib:type-name="GstAudioSink"
           glib:get-type="gst_audio_sink_get_type"
           glib:type-struct="AudioSinkClass">
      <doc xml:whitespace="preserve">Opaque #GstAudioSink.</doc>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="delay">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="prepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unprepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="write">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="element">
        <type name="BaseAudioSink" c:type="GstBaseAudioSink"/>
      </field>
      <field name="thread">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioSinkClass"
            c:type="GstAudioSinkClass"
            glib:is-gtype-struct-for="AudioSink">
      <doc xml:whitespace="preserve">#GstAudioSink class. Override the vmethods to implement functionality.</doc>
      <field name="parent_class">
        <type name="BaseAudioSinkClass" c:type="GstBaseAudioSinkClass"/>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare">
        <callback name="prepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unprepare">
        <callback name="unprepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write">
        <callback name="write">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="AudioSrc"
           c:symbol-prefix="audio_src"
           c:type="GstAudioSrc"
           parent="BaseAudioSrc"
           glib:type-name="GstAudioSrc"
           glib:get-type="gst_audio_src_get_type"
           glib:type-struct="AudioSrcClass">
      <doc xml:whitespace="preserve">Base class for simple audio sources.</doc>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="delay">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="prepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unprepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <field name="element">
        <type name="BaseAudioSrc" c:type="GstBaseAudioSrc"/>
      </field>
      <field name="thread">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioSrcClass"
            c:type="GstAudioSrcClass"
            glib:is-gtype-struct-for="AudioSrc">
      <doc xml:whitespace="preserve">#GstAudioSrc class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <type name="BaseAudioSrcClass" c:type="GstBaseAudioSrcClass"/>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare">
        <callback name="prepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unprepare">
        <callback name="unprepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read">
        <callback name="read">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="BaseAudioSink"
           c:symbol-prefix="base_audio_sink"
           c:type="GstBaseAudioSink"
           parent="GstBase.BaseSink"
           glib:type-name="GstBaseAudioSink"
           glib:get-type="gst_base_audio_sink_get_type"
           glib:type-struct="BaseAudioSinkClass">
      <doc xml:whitespace="preserve">Opaque #GstBaseAudioSink.</doc>
      <virtual-method name="create_ringbuffer"
                      invoker="create_ringbuffer"
                      introspectable="0">
        <doc xml:whitespace="preserve">Create and return the #GstRingBuffer for @sink. This function will call the
::create_ringbuffer vmethod and will set @sink as the parent of the returned
buffer (see gst_object_set_parent()).</doc>
        <return-value>
          <doc xml:whitespace="preserve">The new ringbuffer of @sink.</doc>
          <type name="RingBuffer" c:type="GstRingBuffer*"/>
        </return-value>
      </virtual-method>
      <method name="create_ringbuffer"
              c:identifier="gst_base_audio_sink_create_ringbuffer"
              introspectable="0">
        <doc xml:whitespace="preserve">Create and return the #GstRingBuffer for @sink. This function will call the
::create_ringbuffer vmethod and will set @sink as the parent of the returned
buffer (see gst_object_set_parent()).</doc>
        <return-value>
          <doc xml:whitespace="preserve">The new ringbuffer of @sink.</doc>
          <type name="RingBuffer" c:type="GstRingBuffer*"/>
        </return-value>
      </method>
      <method name="get_drift_tolerance"
              c:identifier="gst_base_audio_sink_get_drift_tolerance">
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_provide_clock"
              c:identifier="gst_base_audio_sink_get_provide_clock"
              version="0.10.16">
        <doc xml:whitespace="preserve">Queries whether @sink will provide a clock or not. See also
gst_base_audio_sink_set_provide_clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @sink will provide a clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_slave_method"
              c:identifier="gst_base_audio_sink_get_slave_method"
              version="0.10.16">
        <doc xml:whitespace="preserve">Get the current slave method used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current slave method used by @sink.</doc>
          <type name="BaseAudioSinkSlaveMethod"
                c:type="GstBaseAudioSinkSlaveMethod"/>
        </return-value>
      </method>
      <method name="set_drift_tolerance"
              c:identifier="gst_base_audio_sink_set_drift_tolerance"
              version="0.10.31">
        <doc xml:whitespace="preserve">Controls the sink's drift tolerance.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="drift_tolerance" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new drift tolerance in microseconds</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_provide_clock"
              c:identifier="gst_base_audio_sink_set_provide_clock"
              version="0.10.16">
        <doc xml:whitespace="preserve">Controls whether @sink will provide a clock or not. If @provide is %TRUE,
gst_element_provide_clock() will return a clock that reflects the datarate
of @sink. If @provide is %FALSE, gst_element_provide_clock() will return NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="provide" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_slave_method"
              c:identifier="gst_base_audio_sink_set_slave_method"
              version="0.10.16">
        <doc xml:whitespace="preserve">Controls how clock slaving will be performed in @sink.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new slave method</doc>
            <type name="BaseAudioSinkSlaveMethod"
                  c:type="GstBaseAudioSinkSlaveMethod"/>
          </parameter>
        </parameters>
      </method>
      <property name="buffer-time" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="can-activate-pull"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="drift-tolerance" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="latency-time" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="provide-clock" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="slave-method" writable="1" transfer-ownership="none">
        <type name="BaseAudioSinkSlaveMethod"/>
      </property>
      <field name="element">
        <type name="GstBase.BaseSink" c:type="GstBaseSink"/>
      </field>
      <field name="ringbuffer">
        <type name="RingBuffer" c:type="GstRingBuffer*"/>
      </field>
      <field name="buffer_time">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="latency_time">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="next_sample">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="provide_clock">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="provided_clock">
        <type name="Gst.Clock" c:type="GstClock*"/>
      </field>
      <field name="priv">
        <type name="BaseAudioSinkPrivate" c:type="GstBaseAudioSinkPrivate*"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="BaseAudioSinkClass"
            c:type="GstBaseAudioSinkClass"
            glib:is-gtype-struct-for="BaseAudioSink">
      <doc xml:whitespace="preserve">#GstBaseAudioSink class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <type name="GstBase.BaseSinkClass" c:type="GstBaseSinkClass"/>
      </field>
      <field name="create_ringbuffer" introspectable="0">
        <callback name="create_ringbuffer" introspectable="0">
          <return-value>
            <doc xml:whitespace="preserve">The new ringbuffer of @sink.</doc>
            <type name="RingBuffer" c:type="GstRingBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseAudioSink" c:type="GstBaseAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseAudioSinkPrivate"
            c:type="GstBaseAudioSinkPrivate"
            disguised="1">
    </record>
    <enumeration name="BaseAudioSinkSlaveMethod"
                 glib:type-name="GstBaseAudioSinkSlaveMethod"
                 glib:get-type="gst_base_audio_sink_slave_method_get_type"
                 c:type="GstBaseAudioSinkSlaveMethod">
      <doc xml:whitespace="preserve">Different possible clock slaving algorithms used when the internal audio
clock is not selected as the pipeline master clock.</doc>
      <member name="resample"
              value="0"
              c:identifier="GST_BASE_AUDIO_SINK_SLAVE_RESAMPLE"
              glib:nick="resample"/>
      <member name="skew"
              value="1"
              c:identifier="GST_BASE_AUDIO_SINK_SLAVE_SKEW"
              glib:nick="skew"/>
      <member name="none"
              value="2"
              c:identifier="GST_BASE_AUDIO_SINK_SLAVE_NONE"
              glib:nick="none"/>
    </enumeration>
    <class name="BaseAudioSrc"
           c:symbol-prefix="base_audio_src"
           c:type="GstBaseAudioSrc"
           parent="GstBase.PushSrc"
           glib:type-name="GstBaseAudioSrc"
           glib:get-type="gst_base_audio_src_get_type"
           glib:type-struct="BaseAudioSrcClass">
      <doc xml:whitespace="preserve">Opaque #GstBaseAudioSrc.</doc>
      <virtual-method name="create_ringbuffer"
                      invoker="create_ringbuffer"
                      introspectable="0">
        <doc xml:whitespace="preserve">Create and return the #GstRingBuffer for @src. This function will call the
::create_ringbuffer vmethod and will set @src as the parent of the returned
buffer (see gst_object_set_parent()).</doc>
        <return-value>
          <doc xml:whitespace="preserve">The new ringbuffer of @src.</doc>
          <type name="RingBuffer" c:type="GstRingBuffer*"/>
        </return-value>
      </virtual-method>
      <method name="create_ringbuffer"
              c:identifier="gst_base_audio_src_create_ringbuffer"
              introspectable="0">
        <doc xml:whitespace="preserve">Create and return the #GstRingBuffer for @src. This function will call the
::create_ringbuffer vmethod and will set @src as the parent of the returned
buffer (see gst_object_set_parent()).</doc>
        <return-value>
          <doc xml:whitespace="preserve">The new ringbuffer of @src.</doc>
          <type name="RingBuffer" c:type="GstRingBuffer*"/>
        </return-value>
      </method>
      <method name="get_provide_clock"
              c:identifier="gst_base_audio_src_get_provide_clock"
              version="0.10.16">
        <doc xml:whitespace="preserve">Queries whether @src will provide a clock or not. See also
gst_base_audio_src_set_provide_clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @src will provide a clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_slave_method"
              c:identifier="gst_base_audio_src_get_slave_method"
              version="0.10.20">
        <doc xml:whitespace="preserve">Get the current slave method used by @src.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current slave method used by @src.</doc>
          <type name="BaseAudioSrcSlaveMethod"
                c:type="GstBaseAudioSrcSlaveMethod"/>
        </return-value>
      </method>
      <method name="set_provide_clock"
              c:identifier="gst_base_audio_src_set_provide_clock"
              version="0.10.16">
        <doc xml:whitespace="preserve">Controls whether @src will provide a clock or not. If @provide is %TRUE, 
gst_element_provide_clock() will return a clock that reflects the datarate
of @src. If @provide is %FALSE, gst_element_provide_clock() will return NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="provide" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_slave_method"
              c:identifier="gst_base_audio_src_set_slave_method"
              version="0.10.20">
        <doc xml:whitespace="preserve">Controls how clock slaving will be performed in @src.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new slave method</doc>
            <type name="BaseAudioSrcSlaveMethod"
                  c:type="GstBaseAudioSrcSlaveMethod"/>
          </parameter>
        </parameters>
      </method>
      <property name="actual-buffer-time"
                version="0.10.20"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Actual configured size of audio buffer in microseconds.</doc>
        <type name="gint64"/>
      </property>
      <property name="actual-latency-time"
                version="0.10.20"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Actual configured audio latency in microseconds.</doc>
        <type name="gint64"/>
      </property>
      <property name="buffer-time" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="latency-time" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="provide-clock" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="slave-method" writable="1" transfer-ownership="none">
        <type name="BaseAudioSrcSlaveMethod"/>
      </property>
      <field name="element">
        <type name="GstBase.PushSrc" c:type="GstPushSrc"/>
      </field>
      <field name="ringbuffer">
        <type name="RingBuffer" c:type="GstRingBuffer*"/>
      </field>
      <field name="buffer_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="latency_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="next_sample">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="clock">
        <type name="Gst.Clock" c:type="GstClock*"/>
      </field>
      <field name="priv">
        <type name="BaseAudioSrcPrivate" c:type="GstBaseAudioSrcPrivate*"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="BaseAudioSrcClass"
            c:type="GstBaseAudioSrcClass"
            glib:is-gtype-struct-for="BaseAudioSrc">
      <doc xml:whitespace="preserve">#GstBaseAudioSrc class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <type name="GstBase.PushSrcClass" c:type="GstPushSrcClass"/>
      </field>
      <field name="create_ringbuffer" introspectable="0">
        <callback name="create_ringbuffer" introspectable="0">
          <return-value>
            <doc xml:whitespace="preserve">The new ringbuffer of @src.</doc>
            <type name="RingBuffer" c:type="GstRingBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseAudioSrc" c:type="GstBaseAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseAudioSrcPrivate"
            c:type="GstBaseAudioSrcPrivate"
            disguised="1">
    </record>
    <enumeration name="BaseAudioSrcSlaveMethod"
                 glib:type-name="GstBaseAudioSrcSlaveMethod"
                 glib:get-type="gst_base_audio_src_slave_method_get_type"
                 c:type="GstBaseAudioSrcSlaveMethod">
      <doc xml:whitespace="preserve">Different possible clock slaving algorithms when the internal audio clock was
not selected as the pipeline clock.</doc>
      <member name="resample"
              value="0"
              c:identifier="GST_BASE_AUDIO_SRC_SLAVE_RESAMPLE"
              glib:nick="resample"/>
      <member name="re_timestamp"
              value="1"
              c:identifier="GST_BASE_AUDIO_SRC_SLAVE_RETIMESTAMP"
              glib:nick="re-timestamp"/>
      <member name="skew"
              value="2"
              c:identifier="GST_BASE_AUDIO_SRC_SLAVE_SKEW"
              glib:nick="skew"/>
      <member name="none"
              value="3"
              c:identifier="GST_BASE_AUDIO_SRC_SLAVE_NONE"
              glib:nick="none"/>
    </enumeration>
    <enumeration name="BufferFormat"
                 glib:type-name="GstBufferFormat"
                 glib:get-type="gst_buffer_format_get_type"
                 c:type="GstBufferFormat">
      <member name="unknown"
              value="0"
              c:identifier="GST_UNKNOWN"
              glib:nick="unknown"/>
      <member name="s8" value="1" c:identifier="GST_S8" glib:nick="s8"/>
      <member name="u8" value="2" c:identifier="GST_U8" glib:nick="u8"/>
      <member name="s16_le"
              value="3"
              c:identifier="GST_S16_LE"
              glib:nick="s16-le"/>
      <member name="s16_be"
              value="4"
              c:identifier="GST_S16_BE"
              glib:nick="s16-be"/>
      <member name="u16_le"
              value="5"
              c:identifier="GST_U16_LE"
              glib:nick="u16-le"/>
      <member name="u16_be"
              value="6"
              c:identifier="GST_U16_BE"
              glib:nick="u16-be"/>
      <member name="s24_le"
              value="7"
              c:identifier="GST_S24_LE"
              glib:nick="s24-le"/>
      <member name="s24_be"
              value="8"
              c:identifier="GST_S24_BE"
              glib:nick="s24-be"/>
      <member name="u24_le"
              value="9"
              c:identifier="GST_U24_LE"
              glib:nick="u24-le"/>
      <member name="u24_be"
              value="10"
              c:identifier="GST_U24_BE"
              glib:nick="u24-be"/>
      <member name="s32_le"
              value="11"
              c:identifier="GST_S32_LE"
              glib:nick="s32-le"/>
      <member name="s32_be"
              value="12"
              c:identifier="GST_S32_BE"
              glib:nick="s32-be"/>
      <member name="u32_le"
              value="13"
              c:identifier="GST_U32_LE"
              glib:nick="u32-le"/>
      <member name="u32_be"
              value="14"
              c:identifier="GST_U32_BE"
              glib:nick="u32-be"/>
      <member name="s24_3le"
              value="15"
              c:identifier="GST_S24_3LE"
              glib:nick="s24-3le"/>
      <member name="s24_3be"
              value="16"
              c:identifier="GST_S24_3BE"
              glib:nick="s24-3be"/>
      <member name="u24_3le"
              value="17"
              c:identifier="GST_U24_3LE"
              glib:nick="u24-3le"/>
      <member name="u24_3be"
              value="18"
              c:identifier="GST_U24_3BE"
              glib:nick="u24-3be"/>
      <member name="s20_3le"
              value="19"
              c:identifier="GST_S20_3LE"
              glib:nick="s20-3le"/>
      <member name="s20_3be"
              value="20"
              c:identifier="GST_S20_3BE"
              glib:nick="s20-3be"/>
      <member name="u20_3le"
              value="21"
              c:identifier="GST_U20_3LE"
              glib:nick="u20-3le"/>
      <member name="u20_3be"
              value="22"
              c:identifier="GST_U20_3BE"
              glib:nick="u20-3be"/>
      <member name="s18_3le"
              value="23"
              c:identifier="GST_S18_3LE"
              glib:nick="s18-3le"/>
      <member name="s18_3be"
              value="24"
              c:identifier="GST_S18_3BE"
              glib:nick="s18-3be"/>
      <member name="u18_3le"
              value="25"
              c:identifier="GST_U18_3LE"
              glib:nick="u18-3le"/>
      <member name="u18_3be"
              value="26"
              c:identifier="GST_U18_3BE"
              glib:nick="u18-3be"/>
      <member name="float32_le"
              value="27"
              c:identifier="GST_FLOAT32_LE"
              glib:nick="float32-le"/>
      <member name="float32_be"
              value="28"
              c:identifier="GST_FLOAT32_BE"
              glib:nick="float32-be"/>
      <member name="float64_le"
              value="29"
              c:identifier="GST_FLOAT64_LE"
              glib:nick="float64-le"/>
      <member name="float64_be"
              value="30"
              c:identifier="GST_FLOAT64_BE"
              glib:nick="float64-be"/>
      <member name="mu_law"
              value="31"
              c:identifier="GST_MU_LAW"
              glib:nick="mu-law"/>
      <member name="a_law"
              value="32"
              c:identifier="GST_A_LAW"
              glib:nick="a-law"/>
      <member name="ima_adpcm"
              value="33"
              c:identifier="GST_IMA_ADPCM"
              glib:nick="ima-adpcm"/>
      <member name="mpeg" value="34" c:identifier="GST_MPEG" glib:nick="mpeg"/>
      <member name="gsm" value="35" c:identifier="GST_GSM" glib:nick="gsm"/>
      <member name="iec958"
              value="36"
              c:identifier="GST_IEC958"
              glib:nick="iec958"/>
      <member name="ac3" value="37" c:identifier="GST_AC3" glib:nick="ac3"/>
      <member name="eac3" value="38" c:identifier="GST_EAC3" glib:nick="eac3"/>
      <member name="dts" value="39" c:identifier="GST_DTS" glib:nick="dts"/>
    </enumeration>
    <enumeration name="BufferFormatType"
                 glib:type-name="GstBufferFormatType"
                 glib:get-type="gst_buffer_format_type_get_type"
                 c:type="GstBufferFormatType">
      <doc xml:whitespace="preserve">The format of the samples in the ringbuffer.</doc>
      <member name="linear"
              value="0"
              c:identifier="GST_BUFTYPE_LINEAR"
              glib:nick="linear"/>
      <member name="float"
              value="1"
              c:identifier="GST_BUFTYPE_FLOAT"
              glib:nick="float"/>
      <member name="mu_law"
              value="2"
              c:identifier="GST_BUFTYPE_MU_LAW"
              glib:nick="mu-law"/>
      <member name="a_law"
              value="3"
              c:identifier="GST_BUFTYPE_A_LAW"
              glib:nick="a-law"/>
      <member name="ima_adpcm"
              value="4"
              c:identifier="GST_BUFTYPE_IMA_ADPCM"
              glib:nick="ima-adpcm"/>
      <member name="mpeg"
              value="5"
              c:identifier="GST_BUFTYPE_MPEG"
              glib:nick="mpeg"/>
      <member name="gsm"
              value="6"
              c:identifier="GST_BUFTYPE_GSM"
              glib:nick="gsm"/>
      <member name="iec958"
              value="7"
              c:identifier="GST_BUFTYPE_IEC958"
              glib:nick="iec958"/>
      <member name="ac3"
              value="8"
              c:identifier="GST_BUFTYPE_AC3"
              glib:nick="ac3"/>
      <member name="eac3"
              value="9"
              c:identifier="GST_BUFTYPE_EAC3"
              glib:nick="eac3"/>
      <member name="dts"
              value="10"
              c:identifier="GST_BUFTYPE_DTS"
              glib:nick="dts"/>
    </enumeration>
    <class name="RingBuffer"
           c:symbol-prefix="ring_buffer"
           c:type="GstRingBuffer"
           parent="Gst.Object"
           abstract="1"
           glib:type-name="GstRingBuffer"
           glib:get-type="gst_ring_buffer_get_type"
           glib:type-struct="RingBufferClass">
      <doc xml:whitespace="preserve">The ringbuffer base class structure.</doc>
      <function name="debug_spec_buff"
                c:identifier="gst_ring_buffer_debug_spec_buff">
        <doc xml:whitespace="preserve">Print debug info about the buffer sized in @spec to the debug log.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the spec to debug</doc>
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="debug_spec_caps"
                c:identifier="gst_ring_buffer_debug_spec_caps">
        <doc xml:whitespace="preserve">Print debug info about the parsed caps in @spec to the debug log.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the spec to debug</doc>
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_caps" c:identifier="gst_ring_buffer_parse_caps">
        <doc xml:whitespace="preserve">Parse @caps into @spec.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the caps could be parsed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">a spec</doc>
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="acquire" invoker="acquire">
        <doc xml:whitespace="preserve">Allocate the resources for the ringbuffer. This function fills
in the data pointer of the ring buffer with a valid #GstBuffer
to which samples can be written.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be acquired, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the specs of the buffer</doc>
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="activate" invoker="activate" version="0.10.22.">
        <doc xml:whitespace="preserve">Activate @buf to start or stop pulling data.
MT safe.
FALSE on error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be activated in the requested mode,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="clear_all" invoker="clear_all">
        <doc xml:whitespace="preserve">Fill the ringbuffer with silence.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="close_device" invoker="close_device">
        <doc xml:whitespace="preserve">Close the audio device associated with the ring buffer. The ring buffer
should already have been released via gst_ring_buffer_release().
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be closed, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="commit">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="sample" transfer-ownership="none">
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="in_samples" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_samples" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="accum" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delay" invoker="delay">
        <doc xml:whitespace="preserve">Get the number of samples queued in the audio device. This is
usually less than the segment size but can be bigger when the
implementation uses another internal buffer between the audio
device.
For playback ringbuffers this is the amount of samples transfered from the
ringbuffer to the device but still not played.
For capture ringbuffers this is the amount of samples in the device that are
not yet transfered to the ringbuffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples queued in the audio device.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </virtual-method>
      <virtual-method name="open_device" invoker="open_device">
        <doc xml:whitespace="preserve">Open the audio device associated with the ring buffer. Does not perform any
setup on the device. You must open the device before acquiring the ring
buffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be opened, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="pause" invoker="pause">
        <doc xml:whitespace="preserve">Pause processing samples from the ringbuffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be paused, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="release" invoker="release">
        <doc xml:whitespace="preserve">Free the resources of the ringbuffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be released, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="resume">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="start" invoker="start">
        <doc xml:whitespace="preserve">Start processing samples from the ringbuffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be started, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop" invoker="stop">
        <doc xml:whitespace="preserve">Stop processing samples from the ringbuffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be stopped, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="acquire" c:identifier="gst_ring_buffer_acquire">
        <doc xml:whitespace="preserve">Allocate the resources for the ringbuffer. This function fills
in the data pointer of the ring buffer with a valid #GstBuffer
to which samples can be written.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be acquired, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the specs of the buffer</doc>
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="activate"
              c:identifier="gst_ring_buffer_activate"
              version="0.10.22.">
        <doc xml:whitespace="preserve">Activate @buf to start or stop pulling data.
MT safe.
FALSE on error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be activated in the requested mode,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="advance" c:identifier="gst_ring_buffer_advance">
        <doc xml:whitespace="preserve">Subclasses should call this function to notify the fact that 
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="advance" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of segments written</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="gst_ring_buffer_clear">
        <doc xml:whitespace="preserve">Clear the given segment of the buffer with silence samples.
This function is used by subclasses.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:whitespace="preserve">the segment to clear</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_all" c:identifier="gst_ring_buffer_clear_all">
        <doc xml:whitespace="preserve">Fill the ringbuffer with silence.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="close_device" c:identifier="gst_ring_buffer_close_device">
        <doc xml:whitespace="preserve">Close the audio device associated with the ring buffer. The ring buffer
should already have been released via gst_ring_buffer_release().
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be closed, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="commit" c:identifier="gst_ring_buffer_commit">
        <doc xml:whitespace="preserve">Same as gst_ring_buffer_commit_full() but with a in_samples and out_samples
equal to @len, ignoring accum.
error.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples written to the ringbuffer or -1 on</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to commit</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of samples in the data to commit</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="commit_full"
              c:identifier="gst_ring_buffer_commit_full"
              version="0.10.11.">
        <doc xml:whitespace="preserve">Commit @in_samples samples pointed to by @data to the ringbuffer @buf. 
samples in @data. For negative rates, @out_samples must be negative and
When @out_samples is positive, the first sample will be written at position @sample
in the ringbuffer. When @out_samples is negative, the last sample will be written to
although it is recommended for optimal performance. 
set to 0 when this function is first called. In case the commit operation is
interrupted, one can resume the processing by passing the previously returned
MT safe.
number of samples written can be less than @out_samples when @buf was interrupted
with a flush or stop.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples written to the ringbuffer or -1 on error. The</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to commit</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="in_samples" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of samples in the data to commit</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_samples" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of samples to write to the ringbuffer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="accum" transfer-ownership="none">
            <doc xml:whitespace="preserve">accumulator for rate conversion.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="convert"
              c:identifier="gst_ring_buffer_convert"
              version="0.10.22.">
        <doc xml:whitespace="preserve">Convert @src_val in @src_fmt to the equivalent value in @dest_fmt. The result
will be put in @dest_val.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the conversion succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_fmt" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source format</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_fmt" transfer-ownership="none">
            <doc xml:whitespace="preserve">the destination format</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store the converted value</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delay" c:identifier="gst_ring_buffer_delay">
        <doc xml:whitespace="preserve">Get the number of samples queued in the audio device. This is
usually less than the segment size but can be bigger when the
implementation uses another internal buffer between the audio
device.
For playback ringbuffers this is the amount of samples transfered from the
ringbuffer to the device but still not played.
For capture ringbuffers this is the amount of samples in the device that are
not yet transfered to the ringbuffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples queued in the audio device.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="device_is_open"
              c:identifier="gst_ring_buffer_device_is_open">
        <doc xml:whitespace="preserve">Checks the status of the device associated with the ring buffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device was open, FALSE if it was closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_acquired" c:identifier="gst_ring_buffer_is_acquired">
        <doc xml:whitespace="preserve">Check if the ringbuffer is acquired and ready to use.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the ringbuffer is acquired, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_active"
              c:identifier="gst_ring_buffer_is_active"
              version="0.10.22.">
        <doc xml:whitespace="preserve">Check if @buf is activated.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device is active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="may_start"
              c:identifier="gst_ring_buffer_may_start"
              version="0.10.6">
        <doc xml:whitespace="preserve">Tell the ringbuffer that it is allowed to start playback when
the ringbuffer is filled with samples. 
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="allowed" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_device" c:identifier="gst_ring_buffer_open_device">
        <doc xml:whitespace="preserve">Open the audio device associated with the ring buffer. Does not perform any
setup on the device. You must open the device before acquiring the ring
buffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be opened, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="pause" c:identifier="gst_ring_buffer_pause">
        <doc xml:whitespace="preserve">Pause processing samples from the ringbuffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be paused, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="prepare_read" c:identifier="gst_ring_buffer_prepare_read">
        <doc xml:whitespace="preserve">Returns a pointer to memory where the data from segment @segment
can be found. This function is mostly used by subclasses.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">FALSE if the buffer is not started.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:whitespace="preserve">the segment to read</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="readptr" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pointer to the memory where samples can be read</doc>
            <type name="guint8" c:type="guint8**"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to read</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="gst_ring_buffer_read">
        <doc xml:whitespace="preserve">Read @len samples from the ringbuffer into the memory pointed 
to by @data.
The first sample should be read from position @sample in
the ringbuffer.
although it is recommended.
error.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples read from the ringbuffer or -1 on</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">where the data should be read</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of samples in data to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="release" c:identifier="gst_ring_buffer_release">
        <doc xml:whitespace="preserve">Free the resources of the ringbuffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be released, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="samples_done" c:identifier="gst_ring_buffer_samples_done">
        <doc xml:whitespace="preserve">Get the number of samples that were processed by the ringbuffer
since it was last started. This does not include the number of samples not
yet processed (see gst_ring_buffer_delay()).
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples processed by the ringbuffer.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="set_callback"
              c:identifier="gst_ring_buffer_set_callback"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given callback function on the buffer. This function
will be called every time a segment has been written to a device.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cb" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the callback to set</doc>
            <type name="RingBufferCallback" c:type="GstRingBufferCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing" c:identifier="gst_ring_buffer_set_flushing">
        <doc xml:whitespace="preserve">Set the ringbuffer to flushing mode or normal mode.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sample" c:identifier="gst_ring_buffer_set_sample">
        <doc xml:whitespace="preserve">Make sure that the next sample written to the device is
accounted for as being the @sample sample written to the
device. This value will be used in reporting the current
sample position of the ringbuffer.
This function will also clear the buffer with silence.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sample number to set</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="gst_ring_buffer_start">
        <doc xml:whitespace="preserve">Start processing samples from the ringbuffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be started, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="stop" c:identifier="gst_ring_buffer_stop">
        <doc xml:whitespace="preserve">Stop processing samples from the ringbuffer.
MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be stopped, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <field name="object">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="cond">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="open">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="acquired">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="data">
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="spec">
        <type name="RingBufferSpec" c:type="GstRingBufferSpec"/>
      </field>
      <field name="segstate">
        <type name="RingBufferSegState" c:type="GstRingBufferSegState*"/>
      </field>
      <field name="samples_per_seg">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="empty_seg">
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="state">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segdone">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segbase">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="waiting">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="callback">
        <type name="RingBufferCallback" c:type="GstRingBufferCallback"/>
      </field>
      <field name="cb_data">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="flushing" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="may_start" writable="1">
            <type name="gint" c:type="gint"/>
          </field>
          <field name="active" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="4">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
    </class>
    <callback name="RingBufferCallback" c:type="GstRingBufferCallback">
      <doc xml:whitespace="preserve">This function is set with gst_ring_buffer_set_callback() and is
called to fill the memory at @data with @len bytes of samples.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="rbuf" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstRingBuffer</doc>
          <type name="RingBuffer" c:type="GstRingBuffer*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">target to fill</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:whitespace="preserve">amount to fill</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="RingBufferClass"
            c:type="GstRingBufferClass"
            glib:is-gtype-struct-for="RingBuffer">
      <doc xml:whitespace="preserve">The vmethods that subclasses can override to implement the ringbuffer.</doc>
      <field name="parent_class">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="open_device">
        <callback name="open_device">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be opened, FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acquire">
        <callback name="acquire">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be acquired, FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <doc xml:whitespace="preserve">the specs of the buffer</doc>
              <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release">
        <callback name="release">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be released, FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_device">
        <callback name="close_device">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be closed, FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be started, FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pause">
        <callback name="pause">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be paused, FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="resume">
        <callback name="resume">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be stopped, FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of samples queued in the audio device.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be activated in the requested mode,</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
            <parameter name="active" transfer-ownership="none">
              <doc xml:whitespace="preserve">the new mode</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="commit">
        <callback name="commit">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
            <parameter name="sample" transfer-ownership="none">
              <type name="guint64" c:type="guint64*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="guint8" c:type="guchar*"/>
            </parameter>
            <parameter name="in_samples" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="out_samples" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="accum" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear_all">
        <callback name="clear_all">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="1">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="RingBufferSegState"
                 glib:type-name="GstRingBufferSegState"
                 glib:get-type="gst_ring_buffer_seg_state_get_type"
                 c:type="GstRingBufferSegState">
      <doc xml:whitespace="preserve">The state of a segment in the ringbuffer.</doc>
      <member name="invalid"
              value="0"
              c:identifier="GST_SEGSTATE_INVALID"
              glib:nick="invalid"/>
      <member name="empty"
              value="1"
              c:identifier="GST_SEGSTATE_EMPTY"
              glib:nick="empty"/>
      <member name="filled"
              value="2"
              c:identifier="GST_SEGSTATE_FILLED"
              glib:nick="filled"/>
      <member name="partial"
              value="3"
              c:identifier="GST_SEGSTATE_PARTIAL"
              glib:nick="partial"/>
    </enumeration>
    <record name="RingBufferSpec" c:type="GstRingBufferSpec">
      <doc xml:whitespace="preserve">The structure containing the format specification of the ringbuffer.</doc>
      <field name="caps" writable="1">
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="type" writable="1">
        <type name="BufferFormatType" c:type="GstBufferFormatType"/>
      </field>
      <field name="format" writable="1">
        <type name="BufferFormat" c:type="GstBufferFormat"/>
      </field>
      <field name="sign" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="bigend" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="width" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="depth" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="rate" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="channels" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="latency_time" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="buffer_time" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="segsize" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segtotal" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="bytes_per_sample" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="silence_sample" writable="1">
        <array zero-terminated="0" c:type="guint8" fixed-size="32">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
      <field name="seglatency" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="_gst_reserved" writable="1">
        <array zero-terminated="0" c:type="guint8" fixed-size="0">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
    </record>
    <enumeration name="RingBufferState"
                 glib:type-name="GstRingBufferState"
                 glib:get-type="gst_ring_buffer_state_get_type"
                 c:type="GstRingBufferState">
      <doc xml:whitespace="preserve">The state of the ringbuffer.</doc>
      <member name="stopped"
              value="0"
              c:identifier="GST_RING_BUFFER_STATE_STOPPED"
              glib:nick="stopped"/>
      <member name="paused"
              value="1"
              c:identifier="GST_RING_BUFFER_STATE_PAUSED"
              glib:nick="paused"/>
      <member name="started"
              value="2"
              c:identifier="GST_RING_BUFFER_STATE_STARTED"
              glib:nick="started"/>
    </enumeration>
    <function name="audio_buffer_clip"
              c:identifier="gst_audio_buffer_clip"
              version="0.10.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Clip the the buffer to the given %GstSegment.
After calling this function the caller does not own a reference to 
otherwise the clipped buffer is returned.
If the buffer has no timestamp, it is assumed to be inside the segment and
is not clipped</doc>
      <return-value>
        <doc xml:whitespace="preserve">%NULL if the buffer is completely outside the configured segment,</doc>
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">The buffer to clip.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="segment" transfer-ownership="none">
          <doc xml:whitespace="preserve">Segment in %GST_FORMAT_TIME or %GST_FORMAT_DEFAULT to which the buffer should be clipped.</doc>
          <type name="Gst.Segment" c:type="GstSegment*"/>
        </parameter>
        <parameter name="rate" transfer-ownership="none">
          <doc xml:whitespace="preserve">sample rate.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="frame_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">size of one audio frame in bytes.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_check_channel_positions"
              c:identifier="gst_audio_check_channel_positions"
              version="0.10.20">
      <doc xml:whitespace="preserve">This functions checks if the given channel positions are valid. Channel
positions are valid if:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;No channel positions appears twice or all positions are %GST_AUDIO_CHANNEL_POSITION_NONE.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;Either all or none of the channel positions are %GST_AUDIO_CHANNEL_POSITION_NONE.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;%GST_AUDIO_CHANNEL_POSITION_FRONT_MONO and %GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT or %GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT don't appear together in the given positions.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
and %FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the given channel positions are valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pos" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #GstAudioChannelPosition.</doc>
          <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of elements in @pos.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_default_registry_mixer_filter"
              c:identifier="gst_audio_default_registry_mixer_filter"
              version="0.10.2"
              introspectable="0">
      <doc xml:whitespace="preserve">Utility function to find audio mixer elements.
Will traverse the default plugin registry in order of plugin rank and
find usable audio mixer elements. The caller may optionally fine-tune
the selection by specifying a filter function.
element in the list by setting it to NULL state and calling
gst_object_unref(). After that the list itself should be freed
using g_list_free().</doc>
      <return-value>
        <doc xml:whitespace="preserve">a #GList of audio mixer #GstElement&lt;!-- --&gt;s. You must free each</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="filter_func" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">filter function, or #NULL</doc>
          <type name="AudioMixerFilterFunc" c:type="GstAudioMixerFilterFunc"/>
        </parameter>
        <parameter name="first" transfer-ownership="none">
          <doc xml:whitespace="preserve">set to #TRUE if you only want the first suitable mixer element</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data to pass to the filter function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_duration_from_pad_buffer"
              c:identifier="gst_audio_duration_from_pad_buffer">
      <doc xml:whitespace="preserve">Calculate length in nanoseconds of audio buffer @buf based on capabilities of</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the length.</doc>
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to get the caps from</doc>
          <type name="Gst.Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_fixate_channel_positions"
              c:identifier="gst_audio_fixate_channel_positions">
      <doc xml:whitespace="preserve">Custom fixate function. Elements that implement some sort of
channel conversion algorithm should use this function for
fixating on GstAudioChannelPosition properties. It will take
care of equal channel positioning (left/right). Caller g_free()s
the return value. The input properties may be (and are supposed
to be) unfixed.
Note that this function is mostly a hack because we currently
have no way to add default fixation functions for new GTypes.
set of #GstAudioChannelPosition values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">fixed values that the caller could use as a fixed</doc>
        <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstStructure containing a (possibly unfixed) "channel-positions" field.</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_frame_byte_size"
              c:identifier="gst_audio_frame_byte_size">
      <doc xml:whitespace="preserve">Calculate byte size of an audio frame.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the byte size, or 0 if there was an error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to get the caps from</doc>
          <type name="Gst.Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_frame_length" c:identifier="gst_audio_frame_length">
      <doc xml:whitespace="preserve">Calculate length of buffer in frames.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if there's an error, or the number of frames if everything's ok</doc>
        <type name="glong" c:type="long"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to get the caps from</doc>
          <type name="Gst.Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_get_channel_positions"
              c:identifier="gst_audio_get_channel_positions">
      <doc xml:whitespace="preserve">Retrieves a number of (fixed!) audio channel positions from
the provided #GstStructure and returns it as a newly allocated
array. The caller should g_free () this array. The caller
should also check that the members in this #GstStructure are
indeed "fixed" before calling this function.
positions as provided in the given #GstStructure. Returns
NULL on error.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a newly allocated array containing the channel</doc>
        <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstStructure to retrieve channel positions from.</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_is_buffer_framed"
              c:identifier="gst_audio_is_buffer_framed">
      <doc xml:whitespace="preserve">Check if the buffer size is a whole multiple of the frame size.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if buffer size is multiple.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to get the caps from</doc>
          <type name="Gst.Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_set_caps_channel_positions_list"
              c:identifier="gst_audio_set_caps_channel_positions_list">
      <doc xml:whitespace="preserve">Sets a (possibly non-fixed) list of possible audio channel
positions (given in pos) on the given caps. Each of the
structures of the caps, after this function has been called,
will contain a "channel-positions" field with an array.
Each value in the array will contain each of the values given
in the pos array. Note that the size of the caps might be
increased by this, since each structure with a "channel-
positions" field needs to have a fixed "channels" field.
The input caps is not required to have this.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="caps" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstCaps to set the list of channel positions on.</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <doc xml:whitespace="preserve">the array containing one or more possible audio channel positions that we should add in each value of the array in the given structure.</doc>
          <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
        </parameter>
        <parameter name="num_positions" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of values in pos.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_set_channel_positions"
              c:identifier="gst_audio_set_channel_positions">
      <doc xml:whitespace="preserve">Adds a "channel-positions" field to the given #GstStructure,
which will represent the channel positions as given in the
provided #GstAudioChannelPosition array.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstStructure to set channel positions on.</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of channel positions. The number of members in this array should be equal to the (fixed!) number of the "channels" field in the given #GstStructure.</doc>
          <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_set_structure_channel_positions_list"
              c:identifier="gst_audio_set_structure_channel_positions_list">
      <doc xml:whitespace="preserve">Sets a (possibly non-fixed) list of possible audio channel
positions (given in pos) on the given structure. The
structure, after this function has been called, will contain
a "channel-positions" field with an array of the size of
the "channels" field value in the given structure (note
that this means that the channels field in the provided
structure should be fixed!). Each value in the array will
contain each of the values given in the pos array.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstStructure to set the list of channel positions on.</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <doc xml:whitespace="preserve">the array containing one or more possible audio channel positions that we should add in each value of the array in the given structure.</doc>
          <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
        </parameter>
        <parameter name="num_positions" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of values in pos.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_structure_set_int"
              c:identifier="gst_audio_structure_set_int"
              deprecated="use gst_structure_set()">
      <doc xml:whitespace="preserve">Do not use anymore.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="structure" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstStructure</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
        <parameter name="flag" transfer-ownership="none">
          <doc xml:whitespace="preserve">a set of #GstAudioFieldFlag</doc>
          <type name="AudioFieldFlag" c:type="GstAudioFieldFlag"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
