<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <package name="gio-2.0"/>
  <package name="gio-unix-2.0"/>
  <c:include name="gio/gio.h"/>
  <namespace name="Gio"
             version="2.0"
             shared-library="libgio-2.0.so.0"
             c:identifier-prefixes="G"
             c:symbol-prefixes="g">
    <interface name="Action"
               c:symbol-prefix="action"
               c:type="GAction"
               glib:type-name="GAction"
               glib:get-type="g_action_get_type"
               glib:type-struct="ActionInterface">
      <virtual-method name="activate" invoker="activate" version="2.26">
        <doc xml:whitespace="preserve">Activates the action.
the parameter type given at construction time).  If the parameter
type was %NULL then @parameter must also be %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parameter" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_enabled" invoker="get_enabled" version="2.26">
        <doc xml:whitespace="preserve">Checks if @action is currently enabled.
An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the action is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name" version="2.26">
        <doc xml:whitespace="preserve">Queries the name of @action.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the action</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_parameter_type"
                      invoker="get_parameter_type"
                      version="2.26">
        <doc xml:whitespace="preserve">Queries the type of the parameter that must be given when activating
When activating the action using g_action_activate(), the #GVariant
given to that function must be of the type returned by this function.
In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the parameter type</doc>
          <type name="GLib.VariantType" c:type="GVariantType*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_state" invoker="get_state" version="2.26">
        <doc xml:whitespace="preserve">Queries the current state of @action.
If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_get_state_type().
The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_state_hint"
                      invoker="get_state_hint"
                      version="2.26">
        <doc xml:whitespace="preserve">Requests a hint about the valid range of values for the state of
If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.
If a #GVariant array is returned then each item in the array is a
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.
In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.
The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_state_type"
                      invoker="get_state_type"
                      version="2.26">
        <doc xml:whitespace="preserve">Queries the type of the state of @action.
g_action_new_stateful()) then this function returns the #GVariantType
of the state.  This is the type of the initial value given as the
state.  All calls to g_action_set_state() must give a #GVariant of
this type and g_action_get_state() will return a #GVariant of the
same type.
this function will return %NULL.  In that case, g_action_get_state()
will return %NULL and you must not call g_action_set_state().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="GVariantType*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="set_state" invoker="set_state" version="2.26">
        <doc xml:whitespace="preserve">Request for the state of @action to be changed to @value.
The action must be stateful and @value must be of the correct type.
See g_action_get_state_type().
This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_get_state_hint().
If the @value GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="activate" c:identifier="g_action_activate" version="2.26">
        <doc xml:whitespace="preserve">Activates the action.
the parameter type given at construction time).  If the parameter
type was %NULL then @parameter must also be %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parameter" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_enabled"
              c:identifier="g_action_get_enabled"
              version="2.26">
        <doc xml:whitespace="preserve">Checks if @action is currently enabled.
An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the action is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_name" c:identifier="g_action_get_name" version="2.26">
        <doc xml:whitespace="preserve">Queries the name of @action.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the action</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_parameter_type"
              c:identifier="g_action_get_parameter_type"
              version="2.26">
        <doc xml:whitespace="preserve">Queries the type of the parameter that must be given when activating
When activating the action using g_action_activate(), the #GVariant
given to that function must be of the type returned by this function.
In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the parameter type</doc>
          <type name="GLib.VariantType" c:type="GVariantType*"/>
        </return-value>
      </method>
      <method name="get_state"
              c:identifier="g_action_get_state"
              version="2.26">
        <doc xml:whitespace="preserve">Queries the current state of @action.
If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_get_state_type().
The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="get_state_hint"
              c:identifier="g_action_get_state_hint"
              version="2.26">
        <doc xml:whitespace="preserve">Requests a hint about the valid range of values for the state of
If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.
If a #GVariant array is returned then each item in the array is a
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.
In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.
The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="get_state_type"
              c:identifier="g_action_get_state_type"
              version="2.26">
        <doc xml:whitespace="preserve">Queries the type of the state of @action.
g_action_new_stateful()) then this function returns the #GVariantType
of the state.  This is the type of the initial value given as the
state.  All calls to g_action_set_state() must give a #GVariant of
this type and g_action_get_state() will return a #GVariant of the
same type.
this function will return %NULL.  In that case, g_action_get_state()
will return %NULL and you must not call g_action_set_state().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="GVariantType*"/>
        </return-value>
      </method>
      <method name="set_state"
              c:identifier="g_action_set_state"
              version="2.26">
        <doc xml:whitespace="preserve">Request for the state of @action to be changed to @value.
The action must be stateful and @value must be of the correct type.
See g_action_get_state_type().
This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_get_state_hint().
If the @value GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <property name="enabled" version="2.26" transfer-ownership="none">
        <doc xml:whitespace="preserve">If @action is currently enabled.
If the action is disabled then calls to g_action_activate() and
g_action_set_state() have no effect.</doc>
        <type name="gboolean"/>
      </property>
      <property name="name" version="2.26" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the action.  This is mostly meaningful for identifying
the action once it has been added to a #GActionGroup.</doc>
        <type name="utf8"/>
      </property>
      <property name="parameter-type"
                version="2.26"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The type of the parameter that must be given when activating the
action.</doc>
        <type/>
      </property>
      <property name="state"
                version="2.26"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The state of the action, or %NULL if the action is stateless.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="state-type"
                version="2.26"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GVariantType of the state that the action has, or %NULL if the
action is stateless.</doc>
        <type/>
      </property>
    </interface>
    <interface name="ActionGroup"
               c:symbol-prefix="action_group"
               c:type="GActionGroup"
               glib:type-name="GActionGroup"
               glib:get-type="g_action_group_get_type"
               glib:type-struct="ActionGroupInterface">
      <virtual-method name="activate" invoker="activate" version="2.26">
        <doc xml:whitespace="preserve">Activate the named action within @action_group.
If the action is expecting a parameter, then the correct type of
parameter must be given as @parameter.  If the action is expecting no
parameters then @parameter must be %NULL.  See
g_action_group_get_parameter_type().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to activate</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameter" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">parameters to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_enabled" invoker="get_enabled" version="2.26">
        <doc xml:whitespace="preserve">Checks if the named action within @action_group is currently enabled.
An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether or not the action is currently enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_parameter_type"
                      invoker="get_parameter_type"
                      version="2.26">
        <doc xml:whitespace="preserve">Queries the type of the parameter that must be given when activating
the named action within @action_group.
When activating the action using g_action_group_activate(), the
#GVariant given to that function must be of the type returned by this
function.
In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.
The parameter type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different parameter type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the parameter type</doc>
          <type name="GLib.VariantType" c:type="GVariantType*"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_state" invoker="get_state" version="2.26">
        <doc xml:whitespace="preserve">Queries the current state of the named action within @action_group.
If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_group_get_state_type().
The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_state_hint"
                      invoker="get_state_hint"
                      version="2.26">
        <doc xml:whitespace="preserve">Requests a hint about the valid range of values for the state of the
named action within @action_group.
If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.
If a #GVariant array is returned then each item in the array is a
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.
In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.
The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_state_type"
                      invoker="get_state_type"
                      version="2.26"
                      introspectable="0">
        <doc xml:whitespace="preserve">Queries the type of the state of the named action within
If the action is stateful then this function returns the
#GVariantType of the state.  All calls to g_action_group_set_state()
must give a #GVariant of this type and g_action_group_get_state()
will return a #GVariant of the same type.
If the action is not stateful then this function will return %NULL.
In that case, g_action_group_get_state() will return %NULL and you
must not call g_action_group_set_state().
The state type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different state type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="GVariantType*"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_action" invoker="has_action" version="2.26">
        <doc xml:whitespace="preserve">Checks if the named action exists within @action_group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the named action exists</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to check for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="list_actions"
                      invoker="list_actions"
                      version="2.26">
        <doc xml:whitespace="preserve">Lists the actions contained within @action_group.
The caller is responsible for freeing the list with g_strfreev() when
it is no longer required.
actions in the groupb</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a %NULL-terminated array of the names of the</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </virtual-method>
      <virtual-method name="set_state" invoker="set_state" version="2.26">
        <doc xml:whitespace="preserve">Request for the state of the named action within @action_group to be
changed to @value.
The action must be stateful and @value must be of the correct type.
See g_action_group_get_state_type().
This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_group_get_state_hint().
If the @value GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to request the change on</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="action_added"
              c:identifier="g_action_group_action_added"
              version="2.26">
        <doc xml:whitespace="preserve">Emits the #GActionGroup::action-added signal on @action_group.
This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="action_enabled_changed"
              c:identifier="g_action_group_action_enabled_changed"
              version="2.26">
        <doc xml:whitespace="preserve">Emits the #GActionGroup::action-enabled-changed signal on @action_group.
This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether or not the action is now enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="action_removed"
              c:identifier="g_action_group_action_removed"
              version="2.26">
        <doc xml:whitespace="preserve">Emits the #GActionGroup::action-removed signal on @action_group.
This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="action_state_changed"
              c:identifier="g_action_group_action_state_changed"
              version="2.26">
        <doc xml:whitespace="preserve">Emits the #GActionGroup::action-state-changed signal on @action_group.
This function should only be called by #GActionGroup implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of an action in the group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new state of the named action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="activate"
              c:identifier="g_action_group_activate"
              version="2.26">
        <doc xml:whitespace="preserve">Activate the named action within @action_group.
If the action is expecting a parameter, then the correct type of
parameter must be given as @parameter.  If the action is expecting no
parameters then @parameter must be %NULL.  See
g_action_group_get_parameter_type().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to activate</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameter" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">parameters to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_enabled"
              c:identifier="g_action_group_get_enabled"
              version="2.26">
        <doc xml:whitespace="preserve">Checks if the named action within @action_group is currently enabled.
An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether or not the action is currently enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parameter_type"
              c:identifier="g_action_group_get_parameter_type"
              version="2.26">
        <doc xml:whitespace="preserve">Queries the type of the parameter that must be given when activating
the named action within @action_group.
When activating the action using g_action_group_activate(), the
#GVariant given to that function must be of the type returned by this
function.
In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.
The parameter type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different parameter type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the parameter type</doc>
          <type name="GLib.VariantType" c:type="GVariantType*"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_state"
              c:identifier="g_action_group_get_state"
              version="2.26">
        <doc xml:whitespace="preserve">Queries the current state of the named action within @action_group.
If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_group_get_state_type().
The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_state_hint"
              c:identifier="g_action_group_get_state_hint"
              version="2.26">
        <doc xml:whitespace="preserve">Requests a hint about the valid range of values for the state of the
named action within @action_group.
If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.
If a #GVariant array is returned then each item in the array is a
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.
In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.
The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_state_type"
              c:identifier="g_action_group_get_state_type"
              version="2.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Queries the type of the state of the named action within
If the action is stateful then this function returns the
#GVariantType of the state.  All calls to g_action_group_set_state()
must give a #GVariant of this type and g_action_group_get_state()
will return a #GVariant of the same type.
If the action is not stateful then this function will return %NULL.
In that case, g_action_group_get_state() will return %NULL and you
must not call g_action_group_set_state().
The state type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different state type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="GVariantType*"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to query</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_action"
              c:identifier="g_action_group_has_action"
              version="2.26">
        <doc xml:whitespace="preserve">Checks if the named action exists within @action_group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the named action exists</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to check for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_actions"
              c:identifier="g_action_group_list_actions"
              version="2.26">
        <doc xml:whitespace="preserve">Lists the actions contained within @action_group.
The caller is responsible for freeing the list with g_strfreev() when
it is no longer required.
actions in the groupb</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a %NULL-terminated array of the names of the</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="set_state"
              c:identifier="g_action_group_set_state"
              version="2.26">
        <doc xml:whitespace="preserve">Request for the state of the named action within @action_group to be
changed to @value.
The action must be stateful and @value must be of the correct type.
See g_action_group_get_state_type().
This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_group_get_state_hint().
If the @value GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to request the change on</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="action-added" version="2.26">
        <doc xml:whitespace="preserve">Signals that a new action was just added to the group.  This signal
is emitted after the action has been added and is now visible.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action in @action_group</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="action-enabled-changed" version="2.26">
        <doc xml:whitespace="preserve">Signals that the enabled status of the named action has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action in @action_group</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the action is enabled or not</doc>
            <type name="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="action-removed" version="2.26">
        <doc xml:whitespace="preserve">Signals that an action is just about to be removed from the group.
This signal is emitted before the action is removed, so the action
is still visible and can be queried from the signal handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action in @action_group</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="action-state-changed" version="2.26">
        <doc xml:whitespace="preserve">Signals that the state of the named action has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action in @action_group</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value of the state</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="ActionGroupInterface"
            c:type="GActionGroupInterface"
            glib:is-gtype-struct-for="ActionGroup"
            version="2.26">
      <doc xml:whitespace="preserve">The virtual function table for #GActionGroup.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="has_action">
        <callback name="has_action">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the named action exists</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">the name of the action to check for</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="list_actions">
        <callback name="list_actions">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a %NULL-terminated array of the names of the</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_enabled">
        <callback name="get_enabled">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">whether or not the action is currently enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">the name of the action to query</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_parameter_type">
        <callback name="get_parameter_type">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the parameter type</doc>
            <type name="GLib.VariantType" c:type="GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">the name of the action to query</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state_type" introspectable="0">
        <callback name="get_state_type" introspectable="0">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the state type, if the action is stateful</doc>
            <type name="GLib.VariantType" c:type="GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">the name of the action to query</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state_hint">
        <callback name="get_state_hint">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the state range hint</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">the name of the action to query</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state">
        <callback name="get_state">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the current state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">the name of the action to query</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_state">
        <callback name="set_state">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">the name of the action to request the change on</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:whitespace="preserve">the new state</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">the name of the action to activate</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="parameter"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">parameters to the activation</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_added">
        <callback name="action_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_removed">
        <callback name="action_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_enabled_changed">
        <callback name="action_enabled_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="enabled" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="action_state_changed">
        <callback name="action_state_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none">
              <type name="ActionGroup" c:type="GActionGroup*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="ActionInterface"
            c:type="GActionInterface"
            glib:is-gtype-struct-for="Action"
            version="2.26">
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_name">
        <callback name="get_name">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_parameter_type">
        <callback name="get_parameter_type">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the parameter type</doc>
            <type name="GLib.VariantType" c:type="GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state_type">
        <callback name="get_state_type">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the state type, if the action is stateful</doc>
            <type name="GLib.VariantType" c:type="GVariantType*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state_hint">
        <callback name="get_state_hint">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the state range hint</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_enabled">
        <callback name="get_enabled">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the action is enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state">
        <callback name="get_state">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the current state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="Action" c:type="GAction*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_state">
        <callback name="set_state">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="Action" c:type="GAction*"/>
            </parameter>
            <parameter name="state" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none">
              <type name="Action" c:type="GAction*"/>
            </parameter>
            <parameter name="parameter"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">the parameter to the activation</doc>
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="AppInfo"
               c:symbol-prefix="app_info"
               c:type="GAppInfo"
               glib:type-name="GAppInfo"
               glib:get-type="g_app_info_get_type"
               glib:type-struct="AppInfoIface">
      <doc xml:whitespace="preserve">Information about an installed application and methods to launch
it (with file arguments).</doc>
      <virtual-method name="add_supports_type"
                      invoker="add_supports_type"
                      throws="1">
        <doc xml:whitespace="preserve">Adds a content type to the application information to indicate the
application is capable of opening files with the given content type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_delete" invoker="can_delete" version="2.20">
        <doc xml:whitespace="preserve">Obtains the information whether the #GAppInfo can be deleted.
See g_app_info_delete().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @appinfo can be deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="can_remove_supports_type"
                      invoker="can_remove_supports_type">
        <doc xml:whitespace="preserve">Checks if a supported content type can be removed from an application.
content types from a given @appinfo, %FALSE if not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if it is possible to remove supported</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="do_delete" invoker="delete" version="2.20">
        <doc xml:whitespace="preserve">Tries to delete a #GAppInfo.
On some platforms, there may be a difference between user-defined
#GAppInfo&lt;!-- --&gt;s which can be deleted, and system-wide ones which
cannot. See g_app_info_can_delete().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @appinfo has been deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="dup" invoker="dup">
        <doc xml:whitespace="preserve">Creates a duplicate of a #GAppInfo.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a duplicate of @appinfo.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="equal" invoker="equal">
        <doc xml:whitespace="preserve">Checks if two #GAppInfo&lt;!-- --&gt;s are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="appinfo2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_commandline"
                      invoker="get_commandline"
                      version="2.20">
        <doc xml:whitespace="preserve">Gets the commandline with which the application will be
started.
or %NULL if this information is not available</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the @appinfo's commandline,</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_description" invoker="get_description">
        <doc xml:whitespace="preserve">Gets a human-readable description of an installed application.
application @appinfo, or %NULL if none.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing a description of the</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_display_name"
                      invoker="get_display_name"
                      version="2.24">
        <doc xml:whitespace="preserve">Gets the display name of the application. The display name is often more
descriptive to the user than the name itself.
no display name is available.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the display name of the application for @appinfo, or the name if</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_executable" invoker="get_executable">
        <doc xml:whitespace="preserve">Gets the executable's name for the installed application.
binaries name</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the @appinfo's application</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_icon" invoker="get_icon">
        <doc xml:whitespace="preserve">Gets the icon for the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the default #GIcon for @appinfo.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_id" invoker="get_id">
        <doc xml:whitespace="preserve">Gets the ID of an application. An id is a string that
identifies the application. The exact format of the id is
platform dependent. For instance, on Unix this is the
desktop file id from the xdg menu specification.
Note that the returned ID may be %NULL, depending on how
the @appinfo has been constructed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the application's ID.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name">
        <doc xml:whitespace="preserve">Gets the installed name of the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the application for @appinfo.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="launch" invoker="launch" throws="1">
        <doc xml:whitespace="preserve">Launches the application. Passes @files to the launched application
as arguments, using the optional @launch_context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly.
To launch the application without arguments pass a %NULL @files list.
Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.
Some URIs can be changed when passed through a GFile (for instance
unsupported uris with strange formats like mailto:), so if you have
a textual uri you want to pass in as argument, consider using
g_app_info_launch_uris() instead.
On UNIX, this function sets the &lt;envvar&gt;GIO_LAUNCHED_DESKTOP_FILE&lt;/envvar&gt;
environment variable with the path of the launched desktop file and
&lt;envvar&gt;GIO_LAUNCHED_DESKTOP_FILE_PID&lt;/envvar&gt; to the process
id of the launched process. This can be used to ignore
&lt;envvar&gt;GIO_LAUNCHED_DESKTOP_FILE&lt;/envvar&gt;, should it be inherited
by further processes. The &lt;envvar&gt;DISPLAY&lt;/envvar&gt; and
&lt;envvar&gt;DESKTOP_STARTUP_ID&lt;/envvar&gt; environment variables are also
set, based on information provided in @launch_context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="filenames" transfer-ownership="none">
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="launch_context"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GAppLaunchContext or %NULL</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launch_uris" invoker="launch_uris" throws="1">
        <doc xml:whitespace="preserve">Launches the application. Passes @uris to the launched application
as arguments, using the optional @launch_context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly.
To lauch the application without arguments pass a %NULL @uris list.
Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uris" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList containing URIs to launch.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="launch_context"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GAppLaunchContext or %NULL</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_supports_type"
                      invoker="remove_supports_type"
                      throws="1">
        <doc xml:whitespace="preserve">Removes a supported type from an application, if possible.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_as_default_for_extension"
                      invoker="set_as_default_for_extension"
                      throws="1">
        <doc xml:whitespace="preserve">Sets the application as the default handler for the given file extension.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="extension" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the file extension (without the dot).</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_as_default_for_type"
                      invoker="set_as_default_for_type"
                      throws="1">
        <doc xml:whitespace="preserve">Sets the application as the default handler for a given type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the content type.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="should_show" invoker="should_show">
        <doc xml:whitespace="preserve">Checks if the application info should be shown in menus that
list available applications.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @appinfo should be shown, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="supports_files" invoker="supports_files">
        <doc xml:whitespace="preserve">Checks if the application accepts files as arguments.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @appinfo supports files.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="supports_uris" invoker="supports_uris">
        <doc xml:whitespace="preserve">Checks if the application supports reading files and directories from URIs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @appinfo supports URIs.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="add_supports_type"
              c:identifier="g_app_info_add_supports_type"
              throws="1">
        <doc xml:whitespace="preserve">Adds a content type to the application information to indicate the
application is capable of opening files with the given content type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_delete"
              c:identifier="g_app_info_can_delete"
              version="2.20">
        <doc xml:whitespace="preserve">Obtains the information whether the #GAppInfo can be deleted.
See g_app_info_delete().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @appinfo can be deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="can_remove_supports_type"
              c:identifier="g_app_info_can_remove_supports_type">
        <doc xml:whitespace="preserve">Checks if a supported content type can be removed from an application.
content types from a given @appinfo, %FALSE if not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if it is possible to remove supported</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="delete" c:identifier="g_app_info_delete" version="2.20">
        <doc xml:whitespace="preserve">Tries to delete a #GAppInfo.
On some platforms, there may be a difference between user-defined
#GAppInfo&lt;!-- --&gt;s which can be deleted, and system-wide ones which
cannot. See g_app_info_can_delete().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @appinfo has been deleted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="dup" c:identifier="g_app_info_dup">
        <doc xml:whitespace="preserve">Creates a duplicate of a #GAppInfo.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a duplicate of @appinfo.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
      </method>
      <method name="equal" c:identifier="g_app_info_equal">
        <doc xml:whitespace="preserve">Checks if two #GAppInfo&lt;!-- --&gt;s are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="appinfo2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second #GAppInfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_commandline"
              c:identifier="g_app_info_get_commandline"
              version="2.20">
        <doc xml:whitespace="preserve">Gets the commandline with which the application will be
started.
or %NULL if this information is not available</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the @appinfo's commandline,</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_description" c:identifier="g_app_info_get_description">
        <doc xml:whitespace="preserve">Gets a human-readable description of an installed application.
application @appinfo, or %NULL if none.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing a description of the</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_display_name"
              c:identifier="g_app_info_get_display_name"
              version="2.24">
        <doc xml:whitespace="preserve">Gets the display name of the application. The display name is often more
descriptive to the user than the name itself.
no display name is available.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the display name of the application for @appinfo, or the name if</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_executable" c:identifier="g_app_info_get_executable">
        <doc xml:whitespace="preserve">Gets the executable's name for the installed application.
binaries name</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the @appinfo's application</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_icon" c:identifier="g_app_info_get_icon">
        <doc xml:whitespace="preserve">Gets the icon for the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the default #GIcon for @appinfo.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </method>
      <method name="get_id" c:identifier="g_app_info_get_id">
        <doc xml:whitespace="preserve">Gets the ID of an application. An id is a string that
identifies the application. The exact format of the id is
platform dependent. For instance, on Unix this is the
desktop file id from the xdg menu specification.
Note that the returned ID may be %NULL, depending on how
the @appinfo has been constructed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the application's ID.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_name" c:identifier="g_app_info_get_name">
        <doc xml:whitespace="preserve">Gets the installed name of the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the application for @appinfo.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="launch" c:identifier="g_app_info_launch" throws="1">
        <doc xml:whitespace="preserve">Launches the application. Passes @files to the launched application
as arguments, using the optional @launch_context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly.
To launch the application without arguments pass a %NULL @files list.
Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.
Some URIs can be changed when passed through a GFile (for instance
unsupported uris with strange formats like mailto:), so if you have
a textual uri you want to pass in as argument, consider using
g_app_info_launch_uris() instead.
On UNIX, this function sets the &lt;envvar&gt;GIO_LAUNCHED_DESKTOP_FILE&lt;/envvar&gt;
environment variable with the path of the launched desktop file and
&lt;envvar&gt;GIO_LAUNCHED_DESKTOP_FILE_PID&lt;/envvar&gt; to the process
id of the launched process. This can be used to ignore
&lt;envvar&gt;GIO_LAUNCHED_DESKTOP_FILE&lt;/envvar&gt;, should it be inherited
by further processes. The &lt;envvar&gt;DISPLAY&lt;/envvar&gt; and
&lt;envvar&gt;DESKTOP_STARTUP_ID&lt;/envvar&gt; environment variables are also
set, based on information provided in @launch_context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="files" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #GFile objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
          <parameter name="launch_context"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GAppLaunchContext or %NULL</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="launch_uris"
              c:identifier="g_app_info_launch_uris"
              throws="1">
        <doc xml:whitespace="preserve">Launches the application. Passes @uris to the launched application
as arguments, using the optional @launch_context to get information
about the details of the launcher (like what screen it is on).
On error, @error will be set accordingly.
To lauch the application without arguments pass a %NULL @uris list.
Note that even if the launch is successful the application launched
can fail to start if it runs into problems during startup. There is
no way to detect this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uris" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList containing URIs to launch.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="launch_context"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GAppLaunchContext or %NULL</doc>
            <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_supports_type"
              c:identifier="g_app_info_remove_supports_type"
              throws="1">
        <doc xml:whitespace="preserve">Removes a supported type from an application, if possible.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_as_default_for_extension"
              c:identifier="g_app_info_set_as_default_for_extension"
              throws="1">
        <doc xml:whitespace="preserve">Sets the application as the default handler for the given file extension.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="extension" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the file extension (without the dot).</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_as_default_for_type"
              c:identifier="g_app_info_set_as_default_for_type"
              throws="1">
        <doc xml:whitespace="preserve">Sets the application as the default handler for a given type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the content type.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="should_show" c:identifier="g_app_info_should_show">
        <doc xml:whitespace="preserve">Checks if the application info should be shown in menus that
list available applications.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @appinfo should be shown, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_files" c:identifier="g_app_info_supports_files">
        <doc xml:whitespace="preserve">Checks if the application accepts files as arguments.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @appinfo supports files.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_uris" c:identifier="g_app_info_supports_uris">
        <doc xml:whitespace="preserve">Checks if the application supports reading files and directories from URIs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @appinfo supports URIs.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </interface>
    <bitfield name="AppInfoCreateFlags"
              glib:type-name="GAppInfoCreateFlags"
              glib:get-type="g_app_info_create_flags_get_type"
              c:type="GAppInfoCreateFlags">
      <doc xml:whitespace="preserve">Flags used when creating a #GAppInfo.</doc>
      <member name="none"
              value="0"
              c:identifier="G_APP_INFO_CREATE_NONE"
              glib:nick="none"/>
      <member name="needs_terminal"
              value="1"
              c:identifier="G_APP_INFO_CREATE_NEEDS_TERMINAL"
              glib:nick="needs-terminal"/>
      <member name="supports_uris"
              value="2"
              c:identifier="G_APP_INFO_CREATE_SUPPORTS_URIS"
              glib:nick="supports-uris"/>
      <member name="supports_startup_notification"
              value="4"
              c:identifier="G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION"
              glib:nick="supports-startup-notification"/>
    </bitfield>
    <record name="AppInfoIface"
            c:type="GAppInfoIface"
            glib:is-gtype-struct-for="AppInfo">
      <doc xml:whitespace="preserve">Application Information interface, for operating system portability.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="dup">
        <callback name="dup">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a duplicate of @appinfo.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="equal">
        <callback name="equal">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if @appinfo1 is equal to @appinfo2. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo1" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="appinfo2" transfer-ownership="none">
              <doc xml:whitespace="preserve">the second #GAppInfo.</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_id">
        <callback name="get_id">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the application's ID.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_name">
        <callback name="get_name">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the application for @appinfo.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_description">
        <callback name="get_description">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a description of the</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_executable">
        <callback name="get_executable">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the @appinfo's application</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_icon">
        <callback name="get_icon">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the default #GIcon for @appinfo.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch">
        <callback name="launch" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="filenames" transfer-ownership="none">
              <type name="GLib.List" c:type="GList*">
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
            <parameter name="launch_context"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GAppLaunchContext or %NULL</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supports_uris">
        <callback name="supports_uris">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @appinfo supports URIs.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supports_files">
        <callback name="supports_files">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @appinfo supports files.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch_uris">
        <callback name="launch_uris" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE on successful launch, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="uris" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GList containing URIs to launch.</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="utf8"/>
              </type>
            </parameter>
            <parameter name="launch_context"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GAppLaunchContext or %NULL</doc>
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="should_show">
        <callback name="should_show">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @appinfo should be shown, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_as_default_for_type">
        <callback name="set_as_default_for_type" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="content_type" transfer-ownership="none">
              <doc xml:whitespace="preserve">the content type.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_as_default_for_extension">
        <callback name="set_as_default_for_extension" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="extension" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string containing the file extension (without the dot).</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_supports_type">
        <callback name="add_supports_type" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="content_type" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_remove_supports_type">
        <callback name="can_remove_supports_type">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if it is possible to remove supported</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_supports_type">
        <callback name="remove_supports_type" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="content_type" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_delete">
        <callback name="can_delete">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if @appinfo can be deleted</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="do_delete">
        <callback name="do_delete">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if @appinfo has been deleted</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_commandline">
        <callback name="get_commandline">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the @appinfo's commandline,</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_display_name">
        <callback name="get_display_name">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the display name of the application for @appinfo, or the name if</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="appinfo" transfer-ownership="none">
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="AppLaunchContext"
           c:symbol-prefix="app_launch_context"
           c:type="GAppLaunchContext"
           parent="GObject.Object"
           glib:type-name="GAppLaunchContext"
           glib:get-type="g_app_launch_context_get_type"
           glib:type-struct="AppLaunchContextClass">
      <doc xml:whitespace="preserve">Integrating the launch with the launching application. This is used to
handle for instance startup notification and launching the new application
on the same screen as the launching window.</doc>
      <constructor name="new" c:identifier="g_app_launch_context_new">
        <doc xml:whitespace="preserve">Creates a new application launch context. This is not normally used,
instead you instantiate a subclass of this, such as #GdkAppLaunchContext.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GAppLaunchContext.</doc>
          <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
        </return-value>
      </constructor>
      <virtual-method name="get_display" invoker="get_display">
        <doc xml:whitespace="preserve">Gets the display string for the @context. This is used to ensure new
applications are started on the same display as the launching
application, by setting the &lt;envvar&gt;DISPLAY&lt;/envvar&gt; environment variable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a display string for the display.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #GFile objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_startup_notify_id"
                      invoker="get_startup_notify_id">
        <doc xml:whitespace="preserve">Initiates startup notification for the application and returns the
&lt;envvar&gt;DESKTOP_STARTUP_ID&lt;/envvar&gt; for the launched operation,
if supported.
Startup notification IDs are defined in the &lt;ulink
url="http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt"&gt;
FreeDesktop.Org Startup Notifications standard&lt;/ulink&gt;.
not supported.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a startup notification ID for the application, or %NULL if</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of of #GFile objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="launch_failed" invoker="launch_failed">
        <doc xml:whitespace="preserve">Called when an application has failed to launch, so that it can cancel
the application startup notification started in g_app_launch_context_get_startup_notify_id().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="startup_notify_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_display"
              c:identifier="g_app_launch_context_get_display">
        <doc xml:whitespace="preserve">Gets the display string for the @context. This is used to ensure new
applications are started on the same display as the launching
application, by setting the &lt;envvar&gt;DISPLAY&lt;/envvar&gt; environment variable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a display string for the display.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #GFile objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_startup_notify_id"
              c:identifier="g_app_launch_context_get_startup_notify_id">
        <doc xml:whitespace="preserve">Initiates startup notification for the application and returns the
&lt;envvar&gt;DESKTOP_STARTUP_ID&lt;/envvar&gt; for the launched operation,
if supported.
Startup notification IDs are defined in the &lt;ulink
url="http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt"&gt;
FreeDesktop.Org Startup Notifications standard&lt;/ulink&gt;.
not supported.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a startup notification ID for the application, or %NULL if</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAppInfo</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </parameter>
          <parameter name="files" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of of #GFile objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="File"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="launch_failed"
              c:identifier="g_app_launch_context_launch_failed">
        <doc xml:whitespace="preserve">Called when an application has failed to launch, so that it can cancel
the application startup notification started in g_app_launch_context_get_startup_notify_id().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="startup_notify_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="AppLaunchContextPrivate"
              c:type="GAppLaunchContextPrivate*"/>
      </field>
    </class>
    <record name="AppLaunchContextClass"
            c:type="GAppLaunchContextClass"
            glib:is-gtype-struct-for="AppLaunchContext">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_display">
        <callback name="get_display">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a display string for the display.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAppInfo</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="files" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GList of #GFile objects</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="File"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_startup_notify_id">
        <callback name="get_startup_notify_id">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a startup notification ID for the application, or %NULL if</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAppInfo</doc>
              <type name="AppInfo" c:type="GAppInfo*"/>
            </parameter>
            <parameter name="files" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GList of of #GFile objects</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="File"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="launch_failed">
        <callback name="launch_failed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
            </parameter>
            <parameter name="startup_notify_id" transfer-ownership="none">
              <doc xml:whitespace="preserve">the startup notification id that was returned by g_app_launch_context_get_startup_notify_id().</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="AppLaunchContextPrivate"
            c:type="GAppLaunchContextPrivate"
            disguised="1">
    </record>
    <class name="Application"
           c:symbol-prefix="application"
           c:type="GApplication"
           version="2.26"
           parent="GObject.Object"
           glib:type-name="GApplication"
           glib:get-type="g_application_get_type"
           glib:type-struct="ApplicationClass">
      <doc xml:whitespace="preserve">The &lt;structname&gt;GApplication&lt;/structname&gt; structure contains private
data and should only be accessed using the provided API</doc>
      <implements name="Initable"/>
      <constructor name="new" c:identifier="g_application_new" version="2.26">
        <doc xml:whitespace="preserve">Create a new #GApplication.  This uses a platform-specific
mechanism to ensure the current process is the unique owner of the
application (as defined by the @appid). If successful, the
#GApplication:is-remote property will be %FALSE, and it is safe to
continue creating other resources such as graphics windows.
If the given @appid is already running in another process, the the
GApplication::activate_with_data signal will be emitted in the
remote process, with the data from @argv and other
platform-specific data available.  Subsequently the
#GApplication:default-quit property will be evaluated.  If it's
%TRUE, then the current process will terminate.  If %FALSE, then
the application remains in the #GApplication:is-remote state, and
you can e.g. call g_application_invoke_action(). Note that proxy
instances should not call g_application_add_action().
This function may do synchronous I/O to obtain unique ownership
of the application id, and will block the calling thread in this
case.
If the environment does not support the basic functionality of
#GApplication, this function will invoke g_error(), which by
default is a fatal operation.  This may arise for example on
UNIX systems using D-Bus when the session bus is not available.
As a convenience, this function is defined to call g_type_init() as
its very first action.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">An application instance</doc>
          <type name="Application" c:type="GApplication*"/>
        </return-value>
        <parameters>
          <parameter name="appid" transfer-ownership="none">
            <doc xml:whitespace="preserve">System-dependent application identifier</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="argc" transfer-ownership="none">
            <doc xml:whitespace="preserve">Number of arguments in @argv</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="argv" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">Argument vector, usually from the &lt;parameter&gt;argv&lt;/parameter&gt; parameter of main()</doc>
            <array length="1" c:type="char**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="try_new"
                   c:identifier="g_application_try_new"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">This function is similar to g_application_new(), but allows for
more graceful fallback if the environment doesn't support the
basic #GApplication functionality.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">An application instance</doc>
          <type name="Application" c:type="GApplication*"/>
        </return-value>
        <parameters>
          <parameter name="appid" transfer-ownership="none">
            <doc xml:whitespace="preserve">System-dependent application identifier</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="argc" transfer-ownership="none">
            <doc xml:whitespace="preserve">Number of arguments in @argv</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="argv" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">Argument vector, usually from the &lt;parameter&gt;argv&lt;/parameter&gt; parameter of main()</doc>
            <array length="1" c:type="char**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="unregistered_try_new"
                   c:identifier="g_application_unregistered_try_new"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">This function is similar to g_application_try_new(), but also
sets the GApplication:register property to %FALSE.  You can later
call g_application_register() to complete initialization.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">An application instance</doc>
          <type name="Application" c:type="GApplication*"/>
        </return-value>
        <parameters>
          <parameter name="appid" transfer-ownership="none">
            <doc xml:whitespace="preserve">System-dependent application identifier</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="argc" transfer-ownership="none">
            <doc xml:whitespace="preserve">Number of arguments in @argv</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="argv" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">Argument vector, usually from the &lt;parameter&gt;argv&lt;/parameter&gt; parameter of main()</doc>
            <array length="1" c:type="char**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_instance"
                c:identifier="g_application_get_instance"
                version="2.26">
        <doc xml:whitespace="preserve">In the normal case where there is exactly one #GApplication instance
in this process, return that instance.  If there are multiple, the
first one created will be returned.  Otherwise, return %NULL.
or %NULL if none is set</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The primary instance of #GApplication,</doc>
          <type name="Application" c:type="GApplication*"/>
        </return-value>
      </function>
      <virtual-method name="run" invoker="run" version="2.26">
        <doc xml:whitespace="preserve">Starts the application.
The default implementation of this virtual function will simply run
a main loop.
It is an error to call this function if @application is a proxy for
a remote application.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <method name="add_action"
              c:identifier="g_application_add_action"
              version="2.26">
        <doc xml:whitespace="preserve">Adds an action @name to the list of exported actions of @application.
It is an error to call this function if @application is a proxy for
a remote application.
You can invoke an action using g_application_invoke_action().
The newly added action is enabled by default; you can call
g_application_set_action_enabled() to disable it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the action name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:whitespace="preserve">the action description; can be a translatable string</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_description"
              c:identifier="g_application_get_action_description"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the description of the action @name.
It is an error to call this function if @application is a proxy for
a remote application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Description for the given action named @name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">Action name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_action_enabled"
              c:identifier="g_application_get_action_enabled"
              version="2.26">
        <doc xml:whitespace="preserve">Retrieves whether the action @name is enabled or not.
See g_application_set_action_enabled().
It is an error to call this function if @application is a proxy for
a remote application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the action was enabled, and %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="g_application_get_id" version="2.26">
        <doc xml:whitespace="preserve">Retrieves the platform-specific identifier for the #GApplication.
is owned by the #GApplication instance and it should never be
modified or freed</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The platform-specific identifier. The returned string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="invoke_action"
              c:identifier="g_application_invoke_action"
              version="2.26">
        <doc xml:whitespace="preserve">Invokes the action @name of the passed #GApplication.
This function has different behavior depending on whether @application
is acting as a proxy for another process.  In the normal case where
the current process is hosting the application, and the specified
action exists and is enabled, the #GApplication::action signal will
be emitted.
If @application is a proxy, then the specified action will be invoked
in the remote process. It is not necessary to call
g_application_add_action() in the current process in order to invoke
one remotely.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to invoke</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="platform_data"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">platform-specific event data</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_remote" c:identifier="g_application_is_remote">
        <doc xml:whitespace="preserve">Returns whether the object represents a proxy for a remote application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this object represents a proxy for a remote application.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="list_actions"
              c:identifier="g_application_list_actions"
              version="2.26">
        <doc xml:whitespace="preserve">Retrieves the list of action names currently exported by @application.
It is an error to call this function if @application is a proxy for
a remote application.
of strings containing action names; use g_strfreev() to free the
resources used by the returned array</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocation, %NULL-terminated array</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="quit_with_data"
              c:identifier="g_application_quit_with_data"
              version="2.26">
        <doc xml:whitespace="preserve">Request that the application quits.
This function has different behavior depending on whether @application
is acting as a proxy for another process.  In the normal case where
the current process is hosting the application, the default
implementation will quit the main loop created by g_application_run().
If @application is a proxy, then the remote process will be asked
to quit.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the application accepted the request, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="platform_data"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">platform-specific data</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register" c:identifier="g_application_register">
        <doc xml:whitespace="preserve">By default, #GApplication ensures process uniqueness when
initialized, but this behavior is controlled by the
GApplication:register property.  If it was given as %FALSE at
construction time, this function allows you to later attempt
to ensure uniqueness.  Note that the GApplication:default-quit
property no longer applies at this point; if this function returns
%FALSE, platform activation will occur, but the current process
will not be terminated.
It is an error to call this function more than once.  It is
also an error to call this function if the GApplication:register
property was %TRUE at construction time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if registration was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="remove_action"
              c:identifier="g_application_remove_action"
              version="2.26">
        <doc xml:whitespace="preserve">Removes the action @name from the list of exported actions of @application.
It is an error to call this function if @application is a proxy for
a remote application.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action to remove</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run" c:identifier="g_application_run" version="2.26">
        <doc xml:whitespace="preserve">Starts the application.
The default implementation of this virtual function will simply run
a main loop.
It is an error to call this function if @application is a proxy for
a remote application.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_action_enabled"
              c:identifier="g_application_set_action_enabled"
              version="2.26">
        <doc xml:whitespace="preserve">Sets whether the action @name inside @application should be enabled
or disabled.
It is an error to call this function if @application is a proxy for
a remote application.
Invoking a disabled action will not result in the #GApplication::action
signal being emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the application</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to enable or disable the action @name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="application-id"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The unique identifier for this application.  See the documentation for
#GApplication for more information about this property.</doc>
        <type name="utf8"/>
      </property>
      <property name="argv"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The argument vector given to this application.  It must be a #GVariant
with a type signature "aay".</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="default-quit"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">By default, if the GApplication:register property is %TRUE, and a
different process is running this application, the process will
be exited.  Set this property to %FALSE to allow custom
interaction with the remote process.</doc>
        <type name="gboolean"/>
      </property>
      <property name="is-remote" transfer-ownership="none">
        <doc xml:whitespace="preserve">This property is %TRUE if this application instance represents a proxy
to the instance of this application in another process.</doc>
        <type name="gboolean"/>
      </property>
      <property name="platform-data"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Platform-specific data retrieved from the operating system
environment.  It must be a #GVariant with type signature "a{sv}".</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="register"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this property is %FALSE, the application construction will not attempt
to ensure process uniqueness, and the application is guaranteed to be in the
remote state.  See GApplication:is-remote.</doc>
        <type name="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ApplicationPrivate" c:type="GApplicationPrivate*"/>
      </field>
      <glib:signal name="action-with-data">
        <doc xml:whitespace="preserve">This signal is emitted when an action is activated. The action name
is passed as the first argument, but also as signal detail, so it
is possible to connect to this signal for individual actions.
The signal is never emitted for disabled actions.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the activated action</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">Platform-specific data, or %NULL</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="prepare-activation">
        <doc xml:whitespace="preserve">This signal is emitted when a non-primary process for a given
application is invoked while your application is running; for
example, when a file browser launches your program to open a
file.  The raw operating system arguments are passed in the
stored in @platform_data.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GVariant with the signature "aay"</doc>
            <type name="GLib.Variant"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GVariant with the signature "a{sv}", or %NULL</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="quit-with-data">
        <doc xml:whitespace="preserve">This signal is emitted when the Quit action is invoked on the
application.
The default handler for this signal exits the mainloop of the
application.
signal emission</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the signal has been handled, %FALSE to continue</doc>
          <type name="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">Platform-specific data, or %NULL</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ApplicationClass"
            c:type="GApplicationClass"
            glib:is-gtype-struct-for="Application"
            version="2.26">
      <doc xml:whitespace="preserve">The &lt;structname&gt;GApplicationClass&lt;/structname&gt; structure contains
private data only</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="action_with_data">
        <callback name="action_with_data">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="action_name" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="quit_with_data">
        <callback name="quit_with_data">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare_activation">
        <callback name="prepare_activation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
            <parameter name="arguments" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="platform_data" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="run">
        <callback name="run">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none">
              <type name="Application" c:type="GApplication*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ApplicationPrivate"
            c:type="GApplicationPrivate"
            disguised="1">
    </record>
    <bitfield name="AskPasswordFlags"
              glib:type-name="GAskPasswordFlags"
              glib:get-type="g_ask_password_flags_get_type"
              c:type="GAskPasswordFlags">
      <doc xml:whitespace="preserve">#GAskPasswordFlags are used to request specific information from the
user, or to notify the user of their choices in an authentication
situation.</doc>
      <member name="need_password"
              value="1"
              c:identifier="G_ASK_PASSWORD_NEED_PASSWORD"
              glib:nick="need-password"/>
      <member name="need_username"
              value="2"
              c:identifier="G_ASK_PASSWORD_NEED_USERNAME"
              glib:nick="need-username"/>
      <member name="need_domain"
              value="4"
              c:identifier="G_ASK_PASSWORD_NEED_DOMAIN"
              glib:nick="need-domain"/>
      <member name="saving_supported"
              value="8"
              c:identifier="G_ASK_PASSWORD_SAVING_SUPPORTED"
              glib:nick="saving-supported"/>
      <member name="anonymous_supported"
              value="16"
              c:identifier="G_ASK_PASSWORD_ANONYMOUS_SUPPORTED"
              glib:nick="anonymous-supported"/>
    </bitfield>
    <interface name="AsyncInitable"
               c:symbol-prefix="async_initable"
               c:type="GAsyncInitable"
               version="2.22"
               glib:type-name="GAsyncInitable"
               glib:get-type="g_async_initable_get_type"
               glib:type-struct="AsyncInitableIface">
      <doc xml:whitespace="preserve">Interface for asynchronously initializable objects.</doc>
      <virtual-method name="init_async" invoker="init_async" version="2.22">
        <doc xml:whitespace="preserve">Starts asynchronous initialization of the object implementing the
interface. This must be done before any real use of the object after
initial construction. If the object also implements #GInitable you can
optionally call g_initable_init() instead.
When the initialization is finished, @callback will be called. You can
then call g_async_initable_init_finish() to get the result of the
initialization.
Implementations may also support cancellation. If @cancellable is not
%NULL, then initialization can be cancelled by triggering the cancellable
object from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
the object doesn't support cancellable initialization, the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.
If this function is not called, or returns with an error, then all
operations on the object should fail, generally returning the
error %G_IO_ERROR_NOT_INITIALIZED.
to this function with the same argument should return the same results.
Only the first call initializes the object; further calls return the result
of the first call. This is so that it's safe to implement the singleton
pattern in the GObject constructor function.
For classes that also support the #GInitable interface, the default
implementation of this method will run the g_initable_init() function
in a thread, so if you want to support asynchronous initialization via
threads, just implement the #GAsyncInitable interface without overriding
any interface methods.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the operation.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="init_finish"
                      invoker="init_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes asynchronous initialization and returns the result.
See g_async_initable_init_async().
will return %FALSE and set @error appropriately if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful. If an error has occurred, this function</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="init_async"
              c:identifier="g_async_initable_init_async"
              version="2.22">
        <doc xml:whitespace="preserve">Starts asynchronous initialization of the object implementing the
interface. This must be done before any real use of the object after
initial construction. If the object also implements #GInitable you can
optionally call g_initable_init() instead.
When the initialization is finished, @callback will be called. You can
then call g_async_initable_init_finish() to get the result of the
initialization.
Implementations may also support cancellation. If @cancellable is not
%NULL, then initialization can be cancelled by triggering the cancellable
object from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
the object doesn't support cancellable initialization, the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.
If this function is not called, or returns with an error, then all
operations on the object should fail, generally returning the
error %G_IO_ERROR_NOT_INITIALIZED.
to this function with the same argument should return the same results.
Only the first call initializes the object; further calls return the result
of the first call. This is so that it's safe to implement the singleton
pattern in the GObject constructor function.
For classes that also support the #GInitable interface, the default
implementation of this method will run the g_initable_init() function
in a thread, so if you want to support asynchronous initialization via
threads, just implement the #GAsyncInitable interface without overriding
any interface methods.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the operation.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_finish"
              c:identifier="g_async_initable_init_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes asynchronous initialization and returns the result.
See g_async_initable_init_async().
will return %FALSE and set @error appropriately if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful. If an error has occurred, this function</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_finish"
              c:identifier="g_async_initable_new_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes the async construction for the various g_async_initable_new calls,
returning the created object or %NULL on error.
g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #GObject, or %NULL on error. Free with</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult.from the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="AsyncInitableIface"
            c:type="GAsyncInitableIface"
            glib:is-gtype-struct-for="AsyncInitable"
            version="2.22">
      <doc xml:whitespace="preserve">Provides an interface for asynchronous initializing object such that
initialization may fail.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="init_async">
        <callback name="init_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="initable" transfer-ownership="none">
              <type name="AsyncInitable" c:type="GAsyncInitable*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the operation.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="init_finish">
        <callback name="init_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if successful. If an error has occurred, this function</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="initable" transfer-ownership="none">
              <type name="AsyncInitable" c:type="GAsyncInitable*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="AsyncReadyCallback" c:type="GAsyncReadyCallback">
      <doc xml:whitespace="preserve">Type definition for a function that will be called back when an asynchronous
operation within GIO has been completed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object the asynchronous operation was started with.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="res" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
          <type name="AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data passed to the callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <interface name="AsyncResult"
               c:symbol-prefix="async_result"
               c:type="GAsyncResult"
               glib:type-name="GAsyncResult"
               glib:get-type="g_async_result_get_type"
               glib:type-struct="AsyncResultIface">
      <doc xml:whitespace="preserve">Holds results information for an asynchronous operation,
usually passed directly to a asynchronous _finish() operation.</doc>
      <virtual-method name="get_source_object" invoker="get_source_object">
        <doc xml:whitespace="preserve">Gets the source object from a #GAsyncResult.
or %NULL if there is none.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to the source object for the @res,</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_user_data" invoker="get_user_data">
        <doc xml:whitespace="preserve">Gets the user data from a #GAsyncResult.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the user data for @res.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </virtual-method>
      <method name="get_source_object"
              c:identifier="g_async_result_get_source_object">
        <doc xml:whitespace="preserve">Gets the source object from a #GAsyncResult.
or %NULL if there is none.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to the source object for the @res,</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
      </method>
      <method name="get_user_data" c:identifier="g_async_result_get_user_data">
        <doc xml:whitespace="preserve">Gets the user data from a #GAsyncResult.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the user data for @res.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
    </interface>
    <record name="AsyncResultIface"
            c:type="GAsyncResultIface"
            glib:is-gtype-struct-for="AsyncResult">
      <doc xml:whitespace="preserve">Interface definition for #GAsyncResult.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_user_data">
        <callback name="get_user_data">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the user data for @res.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="async_result" transfer-ownership="none">
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_source_object">
        <callback name="get_source_object">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a new reference to the source object for the @res,</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </return-value>
          <parameters>
            <parameter name="async_result" transfer-ownership="none">
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="BufferedInputStream"
           c:symbol-prefix="buffered_input_stream"
           c:type="GBufferedInputStream"
           parent="FilterInputStream"
           glib:type-name="GBufferedInputStream"
           glib:get-type="g_buffered_input_stream_get_type"
           glib:type-struct="BufferedInputStreamClass">
      <doc xml:whitespace="preserve">Implements #GFilterInputStream with a sized input buffer.</doc>
      <constructor name="new" c:identifier="g_buffered_input_stream_new">
        <doc xml:whitespace="preserve">Creates a new #GInputStream from the given @base_stream, with
a buffer set to the default size (4 kilobytes).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GInputStream for the given @base_stream.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GInputStream</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sized"
                   c:identifier="g_buffered_input_stream_new_sized">
        <doc xml:whitespace="preserve">Creates a new #GBufferedInputStream from the given @base_stream,
with a buffer set to @size.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GInputStream.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GInputStream</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="fill" invoker="fill" throws="1">
        <doc xml:whitespace="preserve">Tries to read @count bytes from the stream into the buffer.
Will block during this read.
If @count is zero, returns zero and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
On success, the number of bytes read into the buffer is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file. Zero is returned on end of file
(or if @count is zero),  but never otherwise.
If @count is -1 then the attempted read size is equal to the number of
bytes that are required to fill the buffer.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.
On error -1 is returned and @error is set accordingly.
For the asynchronous, non-blocking, version of this function, see
g_buffered_input_stream_fill_async().
or -1 on error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes read into @stream's buffer, up to @count,</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be read from the stream</doc>
            <type name="glong" c:type="gssize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fill_async" invoker="fill_async">
        <doc xml:whitespace="preserve">Reads data into @stream's buffer asynchronously, up to @count size.
version of this function, see g_buffered_input_stream_fill().
If @count is -1 then the attempted read size is equal to the number
of bytes that are required to fill the buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be read from the stream</doc>
            <type name="glong" c:type="gssize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">a #gpointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fill_finish" invoker="fill_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous read.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gssize of the read stream, or %-1 on an error.</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="fill"
              c:identifier="g_buffered_input_stream_fill"
              throws="1">
        <doc xml:whitespace="preserve">Tries to read @count bytes from the stream into the buffer.
Will block during this read.
If @count is zero, returns zero and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
On success, the number of bytes read into the buffer is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file. Zero is returned on end of file
(or if @count is zero),  but never otherwise.
If @count is -1 then the attempted read size is equal to the number of
bytes that are required to fill the buffer.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.
On error -1 is returned and @error is set accordingly.
For the asynchronous, non-blocking, version of this function, see
g_buffered_input_stream_fill_async().
or -1 on error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes read into @stream's buffer, up to @count,</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be read from the stream</doc>
            <type name="glong" c:type="gssize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fill_async"
              c:identifier="g_buffered_input_stream_fill_async">
        <doc xml:whitespace="preserve">Reads data into @stream's buffer asynchronously, up to @count size.
version of this function, see g_buffered_input_stream_fill().
If @count is -1 then the attempted read size is equal to the number
of bytes that are required to fill the buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be read from the stream</doc>
            <type name="glong" c:type="gssize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gpointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="fill_finish"
              c:identifier="g_buffered_input_stream_fill_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous read.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gssize of the read stream, or %-1 on an error.</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_available"
              c:identifier="g_buffered_input_stream_get_available">
        <doc xml:whitespace="preserve">Gets the size of the available data within the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">size of the available stream.</doc>
          <type name="gulong" c:type="gsize"/>
        </return-value>
      </method>
      <method name="get_buffer_size"
              c:identifier="g_buffered_input_stream_get_buffer_size">
        <doc xml:whitespace="preserve">Gets the size of the input buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the current buffer size.</doc>
          <type name="gulong" c:type="gsize"/>
        </return-value>
      </method>
      <method name="peek" c:identifier="g_buffered_input_stream_peek">
        <doc xml:whitespace="preserve">Peeks in the buffer, copying data of size @count into @buffer,
offset @offset bytes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gsize of the number of bytes peeked, or -1 on error.</doc>
          <type name="gulong" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to an allocated chunk of memory</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_buffer"
              c:identifier="g_buffered_input_stream_peek_buffer">
        <doc xml:whitespace="preserve">Returns the buffer with the currently available bytes. The returned
buffer must not be modified and will become invalid when reading from
the stream or filling the buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">read-only buffer</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize to get the number of bytes available in the buffer</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_byte"
              c:identifier="g_buffered_input_stream_read_byte"
              throws="1">
        <doc xml:whitespace="preserve">Tries to read a single byte from the stream or the buffer. Will block
during this read.
On success, the byte read from the stream is returned. On end of stream
-1 is returned but it's not an exceptional error and @error is not set.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.
On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the byte read from the @stream, or -1 on end of stream or error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffer_size"
              c:identifier="g_buffered_input_stream_set_buffer_size">
        <doc xml:whitespace="preserve">Sets the size of the internal buffer of @stream to @size, or to the
size of the contents of the buffer. The buffer can never be resized
smaller than its current contents.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <property name="buffer-size"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint"/>
      </property>
      <field name="parent_instance">
        <type name="FilterInputStream" c:type="GFilterInputStream"/>
      </field>
      <field name="priv">
        <type name="BufferedInputStreamPrivate"
              c:type="GBufferedInputStreamPrivate*"/>
      </field>
    </class>
    <record name="BufferedInputStreamClass"
            c:type="GBufferedInputStreamClass"
            glib:is-gtype-struct-for="BufferedInputStream">
      <field name="parent_class">
        <type name="FilterInputStreamClass" c:type="GFilterInputStreamClass"/>
      </field>
      <field name="fill">
        <callback name="fill" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes read into @stream's buffer, up to @count,</doc>
            <type name="glong" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:whitespace="preserve">the number of bytes that will be read from the stream</doc>
              <type name="glong" c:type="gssize"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fill_async">
        <callback name="fill_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:whitespace="preserve">the number of bytes that will be read from the stream</doc>
              <type name="glong" c:type="gssize"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">a #gpointer</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fill_finish">
        <callback name="fill_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gssize of the read stream, or %-1 on an error.</doc>
            <type name="glong" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="BufferedInputStream" c:type="GBufferedInputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="BufferedInputStreamPrivate"
            c:type="GBufferedInputStreamPrivate"
            disguised="1">
    </record>
    <class name="BufferedOutputStream"
           c:symbol-prefix="buffered_output_stream"
           c:type="GBufferedOutputStream"
           parent="FilterOutputStream"
           glib:type-name="GBufferedOutputStream"
           glib:get-type="g_buffered_output_stream_get_type"
           glib:type-struct="BufferedOutputStreamClass">
      <doc xml:whitespace="preserve">An implementation of #GFilterOutputStream with a sized buffer.</doc>
      <constructor name="new" c:identifier="g_buffered_output_stream_new">
        <doc xml:whitespace="preserve">Creates a new buffered output stream for a base stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GOutputStream for the given @base_stream.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sized"
                   c:identifier="g_buffered_output_stream_new_sized">
        <doc xml:whitespace="preserve">Creates a new buffered output stream with a given buffer size.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GOutputStream with an internal buffer set to @size.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize.</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_auto_grow"
              c:identifier="g_buffered_output_stream_get_auto_grow">
        <doc xml:whitespace="preserve">Checks if the buffer automatically grows as data is added.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @stream's buffer automatically grows,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_buffer_size"
              c:identifier="g_buffered_output_stream_get_buffer_size">
        <doc xml:whitespace="preserve">Gets the size of the buffer in the @stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the current size of the buffer.</doc>
          <type name="gulong" c:type="gsize"/>
        </return-value>
      </method>
      <method name="set_auto_grow"
              c:identifier="g_buffered_output_stream_set_auto_grow">
        <doc xml:whitespace="preserve">Sets whether or not the @stream's buffer should automatically grow.
If @auto_grow is true, then each write will just make the buffer
larger, and you must manually flush the buffer to actually write out
the data to the underlying stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="auto_grow" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffer_size"
              c:identifier="g_buffered_output_stream_set_buffer_size">
        <doc xml:whitespace="preserve">Sets the size of the internal buffer to @size.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize.</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <property name="auto-grow" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="buffer-size"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint"/>
      </property>
      <field name="parent_instance">
        <type name="FilterOutputStream" c:type="GFilterOutputStream"/>
      </field>
      <field name="priv">
        <type name="BufferedOutputStreamPrivate"
              c:type="GBufferedOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="BufferedOutputStreamClass"
            c:type="GBufferedOutputStreamClass"
            glib:is-gtype-struct-for="BufferedOutputStream">
      <field name="parent_class">
        <type name="FilterOutputStreamClass"
              c:type="GFilterOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="BufferedOutputStreamPrivate"
            c:type="GBufferedOutputStreamPrivate"
            disguised="1">
    </record>
    <callback name="BusAcquiredCallback"
              c:type="GBusAcquiredCallback"
              version="2.26">
      <doc xml:whitespace="preserve">Invoked when a connection to a message bus has been obtained.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GDBusConnection to a message bus.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name that is requested to be owned.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">User data passed to g_bus_own_name().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BusNameAcquiredCallback"
              c:type="GBusNameAcquiredCallback"
              version="2.26">
      <doc xml:whitespace="preserve">Invoked when the name is acquired.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GDBusConnection on which to acquired the name.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name being owned.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">User data passed to g_bus_own_name() or g_bus_own_name_on_connection().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BusNameAppearedCallback"
              c:type="GBusNameAppearedCallback"
              version="2.26">
      <doc xml:whitespace="preserve">Invoked when the name being watched is known to have to have a owner.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GDBusConnection the name is being watched on.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name being watched.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="name_owner" transfer-ownership="none">
          <doc xml:whitespace="preserve">Unique name of the owner of the name being watched.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">User data passed to g_bus_watch_name().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BusNameLostCallback"
              c:type="GBusNameLostCallback"
              version="2.26">
      <doc xml:whitespace="preserve">Invoked when the name is lost or @connection has been closed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GDBusConnection on which to acquire the name or %NULL if the connection was disconnected.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name being owned.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">User data passed to g_bus_own_name() or g_bus_own_name_on_connection().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="BusNameOwnerFlags"
              version="2.26"
              glib:type-name="GBusNameOwnerFlags"
              glib:get-type="g_bus_name_owner_flags_get_type"
              c:type="GBusNameOwnerFlags">
      <doc xml:whitespace="preserve">Flags used in g_bus_own_name().</doc>
      <member name="none"
              value="0"
              c:identifier="G_BUS_NAME_OWNER_FLAGS_NONE"
              glib:nick="none"/>
      <member name="allow_replacement"
              value="1"
              c:identifier="G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT"
              glib:nick="allow-replacement"/>
      <member name="replace"
              value="2"
              c:identifier="G_BUS_NAME_OWNER_FLAGS_REPLACE"
              glib:nick="replace"/>
    </bitfield>
    <callback name="BusNameVanishedCallback"
              c:type="GBusNameVanishedCallback"
              version="2.26">
      <doc xml:whitespace="preserve">Invoked when the name being watched is known not to have to have a owner.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GDBusConnection the name is being watched on.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name being watched.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">User data passed to g_bus_watch_name().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="BusNameWatcherFlags"
              version="2.26"
              glib:type-name="GBusNameWatcherFlags"
              glib:get-type="g_bus_name_watcher_flags_get_type"
              c:type="GBusNameWatcherFlags">
      <doc xml:whitespace="preserve">Flags used in g_bus_watch_name().</doc>
      <member name="none"
              value="0"
              c:identifier="G_BUS_NAME_WATCHER_FLAGS_NONE"
              glib:nick="none"/>
      <member name="auto_start"
              value="1"
              c:identifier="G_BUS_NAME_WATCHER_FLAGS_AUTO_START"
              glib:nick="auto-start"/>
    </bitfield>
    <enumeration name="BusType"
                 version="2.26"
                 glib:type-name="GBusType"
                 glib:get-type="g_bus_type_get_type"
                 c:type="GBusType">
      <doc xml:whitespace="preserve">An enumeration for well-known message buses.</doc>
      <member name="starter"
              value="-1"
              c:identifier="G_BUS_TYPE_STARTER"
              glib:nick="starter"/>
      <member name="none"
              value="0"
              c:identifier="G_BUS_TYPE_NONE"
              glib:nick="none"/>
      <member name="system"
              value="1"
              c:identifier="G_BUS_TYPE_SYSTEM"
              glib:nick="system"/>
      <member name="session"
              value="2"
              c:identifier="G_BUS_TYPE_SESSION"
              glib:nick="session"/>
    </enumeration>
    <class name="Cancellable"
           c:symbol-prefix="cancellable"
           c:type="GCancellable"
           parent="GObject.Object"
           glib:type-name="GCancellable"
           glib:get-type="g_cancellable_get_type"
           glib:type-struct="CancellableClass">
      <doc xml:whitespace="preserve">Allows actions to be cancelled.</doc>
      <constructor name="new" c:identifier="g_cancellable_new">
        <doc xml:whitespace="preserve">Creates a new #GCancellable object.
Applications that want to start one or more operations
that should be cancellable should create a #GCancellable
and pass it to the operations.
One #GCancellable can be used in multiple consecutive
operations, but not in multiple concurrent operations.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GCancellable.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </return-value>
      </constructor>
      <function name="get_current" c:identifier="g_cancellable_get_current">
        <doc xml:whitespace="preserve">Gets the top cancellable from the stack.
if the stack is empty.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GCancellable from the top of the stack, or %NULL</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </return-value>
      </function>
      <method name="cancel" c:identifier="g_cancellable_cancel">
        <doc xml:whitespace="preserve">Will set @cancellable to cancelled, and will emit the
#GCancellable::cancelled signal. (However, see the warning about
race conditions in the documentation for that signal if you are
planning to connect to it.)
This function is thread-safe. In other words, you can safely call
it from a thread other than the one running the operation that was
passed the @cancellable.
The convention within gio is that cancelling an asynchronous
operation causes it to complete asynchronously. That is, if you
cancel the operation from the same thread in which it is running,
then the operation's #GAsyncReadyCallback will not be invoked until
the application returns to the main loop.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="connect"
              c:identifier="g_cancellable_connect"
              version="2.22">
        <doc xml:whitespace="preserve">Convenience function to connect to the #GCancellable::cancelled
signal. Also handles the race condition that may happen
if the cancellable is cancelled right before connecting.
time of the connect if @cancellable is already cancelled,
or when @cancellable is cancelled in some thread.
disconnected, or immediately if the cancellable is already
cancelled.
See #GCancellable::cancelled for details on how to use this.
been cancelled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The id of the signal handler or 0 if @cancellable has already</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">The #GCallback to connect.</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="data_destroy_func"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">Free function for @data or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect"
              c:identifier="g_cancellable_disconnect"
              version="2.22">
        <doc xml:whitespace="preserve">Disconnects a handler from a cancellable instance similar to
g_signal_handler_disconnect().  Additionally, in the event that a
signal handler is currently running, this call will block until the
handler has finished.  Calling this function from a
#GCancellable::cancelled signal handler will therefore result in a
deadlock.
This avoids a race condition where a thread cancels at the
same time as the cancellable operation is finished and the
signal handler is removed. See #GCancellable::cancelled for
details on how to use this.
If @cancellable is %NULL or @handler_id is %0 this function does
nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handler_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">Handler id of the handler to be disconnected, or %0.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fd" c:identifier="g_cancellable_get_fd">
        <doc xml:whitespace="preserve">Gets the file descriptor for a cancellable job. This can be used to
implement cancellable operations on Unix systems. The returned fd will
turn readable when @cancellable is cancelled.
You are not supposed to read from the fd yourself, just check for
readable status. Reading to unset the readable status is done
with g_cancellable_reset().
After a successful return from this function, you should use
g_cancellable_release_fd() to free up resources allocated for
the returned file descriptor.
See also g_cancellable_make_pollfd().
is not supported, or on errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A valid file descriptor. %-1 if the file descriptor</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="is_cancelled" c:identifier="g_cancellable_is_cancelled">
        <doc xml:whitespace="preserve">Checks if a cancellable job has been cancelled.
FALSE if called with %NULL or if item is not cancelled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @cancellable is cancelled,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="make_pollfd"
              c:identifier="g_cancellable_make_pollfd"
              version="2.22">
        <doc xml:whitespace="preserve">Creates a #GPollFD corresponding to @cancellable; this can be passed
to g_poll() and used to poll for cancellation. This is useful both
for unix systems without a native poll and for portability to
windows.
When this function returns %TRUE, you should use
g_cancellable_release_fd() to free up resources allocated for the
If this function returns %FALSE, either no @cancellable was given or
resource limits prevent this function from allocating the necessary
structures for polling. (On Linux, you will likely have reached
the maximum number of file descriptors.) The suggested way to handle
these cases is to ignore the @cancellable.
You are not supposed to read from the fd yourself, just check for
readable status. Reading to unset the readable status is done
with g_cancellable_reset().
failure to prepare the cancellable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @pollfd was successfully initialized, %FALSE on</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pollfd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a #GPollFD</doc>
            <type name="GLib.PollFD" c:type="GPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop_current" c:identifier="g_cancellable_pop_current">
        <doc xml:whitespace="preserve">Pops @cancellable off the cancellable stack (verifying that @cancellable
is on the top of the stack).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="push_current" c:identifier="g_cancellable_push_current">
        <doc xml:whitespace="preserve">Pushes @cancellable onto the cancellable stack. The current
cancllable can then be recieved using g_cancellable_get_current().
This is useful when implementing cancellable operations in
code that does not allow you to pass down the cancellable object.
This is typically called automatically by e.g. #GFile operations,
so you rarely have to call this yourself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="release_fd"
              c:identifier="g_cancellable_release_fd"
              version="2.22">
        <doc xml:whitespace="preserve">Releases a resources previously allocated by g_cancellable_get_fd()
or g_cancellable_make_pollfd().
For compatibility reasons with older releases, calling this function
is not strictly required, the resources will be automatically freed
when the @cancellable is finalized. However, the @cancellable will
block scarce file descriptors until it is finalized if this function
is not called. This can cause the application to run out of file
descriptors when many #GCancellables are used at the same time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="reset" c:identifier="g_cancellable_reset">
        <doc xml:whitespace="preserve">Resets @cancellable to its uncancelled state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_error_if_cancelled"
              c:identifier="g_cancellable_set_error_if_cancelled"
              throws="1">
        <doc xml:whitespace="preserve">If the @cancellable is cancelled, sets the error to notify
that the operation was cancelled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @cancellable was cancelled, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="CancellablePrivate" c:type="GCancellablePrivate*"/>
      </field>
      <glib:signal name="cancelled">
        <doc xml:whitespace="preserve">Emitted when the operation has been cancelled.
Can be used by implementations of cancellable operations. If the
operation is cancelled from another thread, the signal will be
emitted in the thread that cancelled the operation, not the
thread that is running the operation.
Note that disconnecting from this signal (or any signal) in a
multi-threaded program is prone to race conditions. For instance
it is possible that a signal handler may be invoked even
&lt;emphasis&gt;after&lt;/emphasis&gt; a call to
g_signal_handler_disconnect() for that handler has already
returned.
There is also a problem when cancellation happen
right before connecting to the signal. If this happens the
signal will unexpectedly not be emitted, and checking before
connecting to the signal leaves a race condition where this is
still happening.
In order to make it safe and easy to connect handlers there
g_cancellable_disconnect() which protect against problems
like this.
An example of how to us this:
|[
/&lt;!-- --&gt;* Make sure we don't do any unnecessary work if already cancelled *&lt;!-- --&gt;/
if (g_cancellable_set_error_if_cancelled (cancellable))
return;
/&lt;!-- --&gt;* Set up all the data needed to be able to
* handle cancellation of the operation *&lt;!-- --&gt;/
my_data = my_data_new (...);
id = 0;
if (cancellable)
id = g_cancellable_connect (cancellable,
G_CALLBACK (cancelled_handler)
data, NULL);
/&lt;!-- --&gt;* cancellable operation here... *&lt;!-- --&gt;/
g_cancellable_disconnect (cancellable, id);
/&lt;!-- --&gt;* cancelled_handler is never called after this, it
* is now safe to free the data *&lt;!-- --&gt;/
my_data_free (my_data);
]|
Note that the cancelled signal is emitted in the thread that
the user cancelled from, which may be the main thread. So, the
cancellable signal should not do something that can block.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="CancellableClass"
            c:type="GCancellableClass"
            glib:is-gtype-struct-for="Cancellable">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="cancelled">
        <callback name="cancelled">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="CancellablePrivate"
            c:type="GCancellablePrivate"
            disguised="1">
    </record>
    <class name="CharsetConverter"
           c:symbol-prefix="charset_converter"
           c:type="GCharsetConverter"
           parent="GObject.Object"
           glib:type-name="GCharsetConverter"
           glib:get-type="g_charset_converter_get_type"
           glib:type-struct="CharsetConverterClass">
      <doc xml:whitespace="preserve">Conversions between character sets.</doc>
      <implements name="Converter"/>
      <implements name="Initable"/>
      <constructor name="new"
                   c:identifier="g_charset_converter_new"
                   version="2.24"
                   throws="1">
        <doc xml:whitespace="preserve">Creates a new #GCharsetConverter.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GCharsetConverter or %NULL on error.</doc>
          <type name="CharsetConverter" c:type="GCharsetConverter*"/>
        </return-value>
        <parameters>
          <parameter name="to_charset" transfer-ownership="none">
            <doc xml:whitespace="preserve">destination charset</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="from_charset" transfer-ownership="none">
            <doc xml:whitespace="preserve">source charset</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_num_fallbacks"
              c:identifier="g_charset_converter_get_num_fallbacks"
              version="2.24">
        <doc xml:whitespace="preserve">Gets the number of fallbacks that @converter has applied so far.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of fallbacks that @converter has applied</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_use_fallback"
              c:identifier="g_charset_converter_get_use_fallback"
              version="2.24">
        <doc xml:whitespace="preserve">Gets the #GCharsetConverter:use-fallback property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if fallbacks are used by @converter</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_use_fallback"
              c:identifier="g_charset_converter_set_use_fallback"
              version="2.24">
        <doc xml:whitespace="preserve">Sets the #GCharsetConverter:use-fallback property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="use_fallback" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to use fallbacks</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="from-charset"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="to-charset"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="use-fallback"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
    </class>
    <record name="CharsetConverterClass"
            c:type="GCharsetConverterClass"
            glib:is-gtype-struct-for="CharsetConverter">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <interface name="Converter"
               c:symbol-prefix="converter"
               c:type="GConverter"
               version="2.24"
               glib:type-name="GConverter"
               glib:get-type="g_converter_get_type"
               glib:type-struct="ConverterIface">
      <doc xml:whitespace="preserve">Seek object for streaming operations.</doc>
      <virtual-method name="convert"
                      invoker="convert"
                      version="2.24"
                      throws="1">
        <doc xml:whitespace="preserve">This is the main operation used when converting data. It is to be called
multiple times in a loop, and each time it will do some work, i.e.
producing some output (in @outbuf) or consuming some input (from @inbuf) or
both. If its not possible to do any work an error is returned.
Note that a single call may not consume all input (or any input at all).
Also a call may produce output even if given no input, due to state stored
in the converter producing output.
If any data was either produced or consumed, and then an error happens, then
only the successful conversion is reported and the error is returned on the
next call.
A full conversion loop involves calling this method repeatedly, each time
giving it new input and space output space. When there is no more input
data after the data in @inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
each time until all data is consumed and all output is produced, then
%G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
in a decompression converter where the end of data is detectable from the
data (and there might even be other data after the end of the compressed data).
When some data has successfully been converted @bytes_read and is set to
the number of bytes read from @inbuf, and @bytes_written is set to indicate
how many bytes was written to @outbuf. If there are more data to output
or consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified) then
G_CONVERTER_CONVERTED is returned, and if no more data is to be output
then G_CONVERTER_FINISHED is returned.
On error %G_CONVERTER_ERROR is returned and @error is set accordingly.
Some errors need special handling:
%G_IO_ERROR_NO_SPACE is returned if there is not enough space
to write the resulting converted data, the application should
call the function again with a larger @outbuf to continue.
%G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
input to fully determine what the conversion should produce,
and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
example with an incomplete multibyte sequence when converting text,
or when a regexp matches up to the end of the input (and may match
further input). It may also happen when @inbuf_size is zero and
there is no more data to produce.
When this happens the application should read more input and then
call the function again. If further input shows that there is no
more data call the function again with the same data but with
the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
to finish as e.g. in the regexp match case (or, to fail again with
%G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
input is actually partial).
After g_converter_convert() has returned %G_CONVERTER_FINISHED the
converter object is in an invalid state where its not allowed
to call g_converter_convert() anymore. At this time you can only
free the object or call g_converter_reset() to reset it to the
initial state.
If the flag %G_CONVERTER_FLUSH is set then conversion is modified
to try to write out all internal state to the output. The application
has to call the function multiple times with the flag set, and when
the availible input has been consumed and all internal state has
been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
really at the end) is returned instead of %G_CONVERTER_CONVERTED.
This is somewhat similar to what happens at the end of the input stream,
but done in the middle of the data.
This has different meanings for different conversions. For instance
in a compression converter it would mean that we flush all the
compression state into output such that if you uncompress the
compressed data you get back all the input data. Doing this may
make the final file larger due to padding though. Another example
is a regexp conversion, where if you at the end of the flushed data
have a match, but there is also a potential longer match. In the
non-flushed case we would ask for more input, but when flushing we
treat this as the end of input and do the match.
Flushing is not always possible (like if a charset converter flushes
at a partial multibyte sequence). Converters are supposed to try
to produce as much output as possible and then return an error
(typically %G_IO_ERROR_PARTIAL_INPUT).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GConverterResult, %G_CONVERTER_ERROR on error.</doc>
          <type name="ConverterResult" c:type="GConverterResult"/>
        </return-value>
        <parameters>
          <parameter name="inbuf" transfer-ownership="none">
            <doc xml:whitespace="preserve">the buffer containing the data to convert.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="inbuf_size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes in @inbuf</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffer to write converted data in.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="outbuf_size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes in @outbuf, must be at least one</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GConvertFlags controlling the conversion details</doc>
            <type name="ConverterFlags" c:type="GConverterFlags"/>
          </parameter>
          <parameter name="bytes_read" transfer-ownership="none">
            <doc xml:whitespace="preserve">will be set to the number of bytes read from @inbuf on success</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
          <parameter name="bytes_written" transfer-ownership="none">
            <doc xml:whitespace="preserve">will be set to the number of bytes written to @outbuf on success</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset" invoker="reset" version="2.24">
        <doc xml:whitespace="preserve">Resets all internal state in the converter, making it behave
as if it was just created. If the converter has any internal
state that would produce output then that output is lost.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <method name="convert"
              c:identifier="g_converter_convert"
              version="2.24"
              throws="1">
        <doc xml:whitespace="preserve">This is the main operation used when converting data. It is to be called
multiple times in a loop, and each time it will do some work, i.e.
producing some output (in @outbuf) or consuming some input (from @inbuf) or
both. If its not possible to do any work an error is returned.
Note that a single call may not consume all input (or any input at all).
Also a call may produce output even if given no input, due to state stored
in the converter producing output.
If any data was either produced or consumed, and then an error happens, then
only the successful conversion is reported and the error is returned on the
next call.
A full conversion loop involves calling this method repeatedly, each time
giving it new input and space output space. When there is no more input
data after the data in @inbuf, the flag %G_CONVERTER_INPUT_AT_END must be set.
The loop will be (unless some error happens) returning %G_CONVERTER_CONVERTED
each time until all data is consumed and all output is produced, then
%G_CONVERTER_FINISHED is returned instead. Note, that %G_CONVERTER_FINISHED
may be returned even if %G_CONVERTER_INPUT_AT_END is not set, for instance
in a decompression converter where the end of data is detectable from the
data (and there might even be other data after the end of the compressed data).
When some data has successfully been converted @bytes_read and is set to
the number of bytes read from @inbuf, and @bytes_written is set to indicate
how many bytes was written to @outbuf. If there are more data to output
or consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified) then
G_CONVERTER_CONVERTED is returned, and if no more data is to be output
then G_CONVERTER_FINISHED is returned.
On error %G_CONVERTER_ERROR is returned and @error is set accordingly.
Some errors need special handling:
%G_IO_ERROR_NO_SPACE is returned if there is not enough space
to write the resulting converted data, the application should
call the function again with a larger @outbuf to continue.
%G_IO_ERROR_PARTIAL_INPUT is returned if there is not enough
input to fully determine what the conversion should produce,
and the %G_CONVERTER_INPUT_AT_END flag is not set. This happens for
example with an incomplete multibyte sequence when converting text,
or when a regexp matches up to the end of the input (and may match
further input). It may also happen when @inbuf_size is zero and
there is no more data to produce.
When this happens the application should read more input and then
call the function again. If further input shows that there is no
more data call the function again with the same data but with
the %G_CONVERTER_INPUT_AT_END flag set. This may cause the conversion
to finish as e.g. in the regexp match case (or, to fail again with
%G_IO_ERROR_PARTIAL_INPUT in e.g. a charset conversion where the
input is actually partial).
After g_converter_convert() has returned %G_CONVERTER_FINISHED the
converter object is in an invalid state where its not allowed
to call g_converter_convert() anymore. At this time you can only
free the object or call g_converter_reset() to reset it to the
initial state.
If the flag %G_CONVERTER_FLUSH is set then conversion is modified
to try to write out all internal state to the output. The application
has to call the function multiple times with the flag set, and when
the availible input has been consumed and all internal state has
been produced then %G_CONVERTER_FLUSHED (or %G_CONVERTER_FINISHED if
really at the end) is returned instead of %G_CONVERTER_CONVERTED.
This is somewhat similar to what happens at the end of the input stream,
but done in the middle of the data.
This has different meanings for different conversions. For instance
in a compression converter it would mean that we flush all the
compression state into output such that if you uncompress the
compressed data you get back all the input data. Doing this may
make the final file larger due to padding though. Another example
is a regexp conversion, where if you at the end of the flushed data
have a match, but there is also a potential longer match. In the
non-flushed case we would ask for more input, but when flushing we
treat this as the end of input and do the match.
Flushing is not always possible (like if a charset converter flushes
at a partial multibyte sequence). Converters are supposed to try
to produce as much output as possible and then return an error
(typically %G_IO_ERROR_PARTIAL_INPUT).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GConverterResult, %G_CONVERTER_ERROR on error.</doc>
          <type name="ConverterResult" c:type="GConverterResult"/>
        </return-value>
        <parameters>
          <parameter name="inbuf" transfer-ownership="none">
            <doc xml:whitespace="preserve">the buffer containing the data to convert.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="inbuf_size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes in @inbuf</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffer to write converted data in.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="outbuf_size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes in @outbuf, must be at least one</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GConvertFlags controlling the conversion details</doc>
            <type name="ConverterFlags" c:type="GConverterFlags"/>
          </parameter>
          <parameter name="bytes_read" transfer-ownership="none">
            <doc xml:whitespace="preserve">will be set to the number of bytes read from @inbuf on success</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
          <parameter name="bytes_written" transfer-ownership="none">
            <doc xml:whitespace="preserve">will be set to the number of bytes written to @outbuf on success</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="g_converter_reset" version="2.24">
        <doc xml:whitespace="preserve">Resets all internal state in the converter, making it behave
as if it was just created. If the converter has any internal
state that would produce output then that output is lost.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </interface>
    <bitfield name="ConverterFlags"
              version="2.24"
              glib:type-name="GConverterFlags"
              glib:get-type="g_converter_flags_get_type"
              c:type="GConverterFlags">
      <doc xml:whitespace="preserve">Flags used when calling a g_converter_convert().</doc>
      <member name="none"
              value="0"
              c:identifier="G_CONVERTER_NO_FLAGS"
              glib:nick="none"/>
      <member name="input_at_end"
              value="1"
              c:identifier="G_CONVERTER_INPUT_AT_END"
              glib:nick="input-at-end"/>
      <member name="flush"
              value="2"
              c:identifier="G_CONVERTER_FLUSH"
              glib:nick="flush"/>
    </bitfield>
    <record name="ConverterIface"
            c:type="GConverterIface"
            glib:is-gtype-struct-for="Converter"
            version="2.24">
      <doc xml:whitespace="preserve">Provides an interface for converting data from one type
to another type. The conversion can be stateful
and may fail at any place.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="convert">
        <callback name="convert" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GConverterResult, %G_CONVERTER_ERROR on error.</doc>
            <type name="ConverterResult" c:type="GConverterResult"/>
          </return-value>
          <parameters>
            <parameter name="converter" transfer-ownership="none">
              <type name="Converter" c:type="GConverter*"/>
            </parameter>
            <parameter name="inbuf" transfer-ownership="none">
              <doc xml:whitespace="preserve">the buffer containing the data to convert.</doc>
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="inbuf_size" transfer-ownership="none">
              <doc xml:whitespace="preserve">the number of bytes in @inbuf</doc>
              <type name="gulong" c:type="gsize"/>
            </parameter>
            <parameter name="outbuf" transfer-ownership="none">
              <doc xml:whitespace="preserve">a buffer to write converted data in.</doc>
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="outbuf_size" transfer-ownership="none">
              <doc xml:whitespace="preserve">the number of bytes in @outbuf, must be at least one</doc>
              <type name="gulong" c:type="gsize"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GConvertFlags controlling the conversion details</doc>
              <type name="ConverterFlags" c:type="GConverterFlags"/>
            </parameter>
            <parameter name="bytes_read" transfer-ownership="none">
              <doc xml:whitespace="preserve">will be set to the number of bytes read from @inbuf on success</doc>
              <type name="gulong" c:type="gsize*"/>
            </parameter>
            <parameter name="bytes_written" transfer-ownership="none">
              <doc xml:whitespace="preserve">will be set to the number of bytes written to @outbuf on success</doc>
              <type name="gulong" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="converter" transfer-ownership="none">
              <type name="Converter" c:type="GConverter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="ConverterInputStream"
           c:symbol-prefix="converter_input_stream"
           c:type="GConverterInputStream"
           parent="FilterInputStream"
           glib:type-name="GConverterInputStream"
           glib:get-type="g_converter_input_stream_get_type"
           glib:type-struct="ConverterInputStreamClass">
      <doc xml:whitespace="preserve">An implementation of #GFilterInputStream that allows data
conversion.</doc>
      <constructor name="new" c:identifier="g_converter_input_stream_new">
        <doc xml:whitespace="preserve">Creates a new converter input stream for the @base_stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GInputStream.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GInputStream</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="converter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GConverter</doc>
            <type name="Converter" c:type="GConverter*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_converter"
              c:identifier="g_converter_input_stream_get_converter"
              version="2.24">
        <doc xml:whitespace="preserve">Gets the #GConverter that is used by @converter_stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the converter of the converter input stream</doc>
          <type name="Converter" c:type="GConverter*"/>
        </return-value>
      </method>
      <property name="converter"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Converter"/>
      </property>
      <field name="parent_instance">
        <type name="FilterInputStream" c:type="GFilterInputStream"/>
      </field>
      <field name="priv">
        <type name="ConverterInputStreamPrivate"
              c:type="GConverterInputStreamPrivate*"/>
      </field>
    </class>
    <record name="ConverterInputStreamClass"
            c:type="GConverterInputStreamClass"
            glib:is-gtype-struct-for="ConverterInputStream">
      <field name="parent_class">
        <type name="FilterInputStreamClass" c:type="GFilterInputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ConverterInputStreamPrivate"
            c:type="GConverterInputStreamPrivate"
            disguised="1">
    </record>
    <class name="ConverterOutputStream"
           c:symbol-prefix="converter_output_stream"
           c:type="GConverterOutputStream"
           parent="FilterOutputStream"
           glib:type-name="GConverterOutputStream"
           glib:get-type="g_converter_output_stream_get_type"
           glib:type-struct="ConverterOutputStreamClass">
      <doc xml:whitespace="preserve">An implementation of #GFilterOutputStream that allows data
conversion.</doc>
      <constructor name="new" c:identifier="g_converter_output_stream_new">
        <doc xml:whitespace="preserve">Creates a new converter output stream for the @base_stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GOutputStream.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GOutputStream</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="converter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GConverter</doc>
            <type name="Converter" c:type="GConverter*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_converter"
              c:identifier="g_converter_output_stream_get_converter"
              version="2.24">
        <doc xml:whitespace="preserve">Gets the #GConverter that is used by @converter_stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the converter of the converter output stream</doc>
          <type name="Converter" c:type="GConverter*"/>
        </return-value>
      </method>
      <property name="converter"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Converter"/>
      </property>
      <field name="parent_instance">
        <type name="FilterOutputStream" c:type="GFilterOutputStream"/>
      </field>
      <field name="priv">
        <type name="ConverterOutputStreamPrivate"
              c:type="GConverterOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="ConverterOutputStreamClass"
            c:type="GConverterOutputStreamClass"
            glib:is-gtype-struct-for="ConverterOutputStream">
      <field name="parent_class">
        <type name="FilterOutputStreamClass"
              c:type="GFilterOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ConverterOutputStreamPrivate"
            c:type="GConverterOutputStreamPrivate"
            disguised="1">
    </record>
    <enumeration name="ConverterResult"
                 version="2.24"
                 glib:type-name="GConverterResult"
                 glib:get-type="g_converter_result_get_type"
                 c:type="GConverterResult">
      <doc xml:whitespace="preserve">Results returned from g_converter_convert().</doc>
      <member name="error"
              value="0"
              c:identifier="G_CONVERTER_ERROR"
              glib:nick="error"/>
      <member name="converted"
              value="1"
              c:identifier="G_CONVERTER_CONVERTED"
              glib:nick="converted"/>
      <member name="finished"
              value="2"
              c:identifier="G_CONVERTER_FINISHED"
              glib:nick="finished"/>
      <member name="flushed"
              value="3"
              c:identifier="G_CONVERTER_FLUSHED"
              glib:nick="flushed"/>
    </enumeration>
    <class name="Credentials"
           c:symbol-prefix="credentials"
           c:type="GCredentials"
           version="2.26"
           parent="GObject.Object"
           glib:type-name="GCredentials"
           glib:get-type="g_credentials_get_type"
           glib:type-struct="CredentialsClass">
      <doc xml:whitespace="preserve">The #GCredentials structure contains only private data and
should only be accessed using the provided API.</doc>
      <constructor name="new" c:identifier="g_credentials_new" version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GCredentials object with credentials matching the
the current process.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GCredentials. Free with g_object_unref().</doc>
          <type name="Credentials" c:type="GCredentials*"/>
        </return-value>
      </constructor>
      <method name="get_native"
              c:identifier="g_credentials_get_native"
              version="2.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets a pointer to native credentials of type @native_type from
It is a programming error (which will cause an warning to be
logged) to use this method if there is no #GCredentials support for
the OS or if @native_type isn't supported by the OS.
operation there is no #GCredentials support for the OS or if
data, it is owned by @credentials.</doc>
        <return-value>
          <doc xml:whitespace="preserve">The pointer to native credentials or %NULL if the</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="native_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type of native credentials to get.</doc>
            <type name="CredentialsType" c:type="GCredentialsType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_unix_user"
              c:identifier="g_credentials_get_unix_user"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Tries to get the UNIX user identifier from @credentials. This
method is only available on UNIX platforms.
This operation can fail if #GCredentials is not supported on the
OS or if the native credentials type does not contain information
about the UNIX user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The UNIX user identifier or -1 if @error is set.</doc>
          <type name="guint" c:type="uid_t"/>
        </return-value>
      </method>
      <method name="is_same_user"
              c:identifier="g_credentials_is_same_user"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Checks if @credentials and @other_credentials is the same user.
This operation can fail if #GCredentials is not supported on the
the OS.
user, %FALSE otherwise or if @error is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @credentials and @other_credentials has the same</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="other_credentials" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GCredentials.</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_native"
              c:identifier="g_credentials_set_native"
              version="2.26">
        <doc xml:whitespace="preserve">Copies the native credentials of type @native_type from @native
into @credentials.
It is a programming error (which will cause an warning to be
logged) to use this method if there is no #GCredentials support for
the OS or if @native_type isn't supported by the OS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="native_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type of native credentials to set.</doc>
            <type name="CredentialsType" c:type="GCredentialsType"/>
          </parameter>
          <parameter name="native" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to native credentials.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_unix_user"
              c:identifier="g_credentials_set_unix_user"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Tries to set the UNIX user identifier on @credentials. This method
is only available on UNIX platforms.
This operation can fail if #GCredentials is not supported on the
OS or if the native credentials type does not contain information
about the UNIX user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @uid was set, %FALSE if error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:whitespace="preserve">The UNIX user identifier to set.</doc>
            <type name="guint" c:type="uid_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string"
              c:identifier="g_credentials_to_string"
              version="2.26">
        <doc xml:whitespace="preserve">Creates a human-readable textual representation of @credentials
that can be used in logging and debug messages. The format of the
returned string may change in future GLib release.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A string that should be freed with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
    </class>
    <record name="CredentialsClass"
            c:type="GCredentialsClass"
            disguised="1"
            glib:is-gtype-struct-for="Credentials"
            version="2.26">
      <doc xml:whitespace="preserve">Class structure for #GCredentials.</doc>
    </record>
    <enumeration name="CredentialsType"
                 version="2.26"
                 glib:type-name="GCredentialsType"
                 glib:get-type="g_credentials_type_get_type"
                 c:type="GCredentialsType">
      <doc xml:whitespace="preserve">Enumeration describing different kinds of native credential types.</doc>
      <member name="invalid"
              value="0"
              c:identifier="G_CREDENTIALS_TYPE_INVALID"
              glib:nick="invalid"/>
      <member name="linux_ucred"
              value="1"
              c:identifier="G_CREDENTIALS_TYPE_LINUX_UCRED"
              glib:nick="linux-ucred"/>
      <member name="freebsd_cmsgcred"
              value="2"
              c:identifier="G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED"
              glib:nick="freebsd-cmsgcred"/>
    </enumeration>
    <record name="DBusAnnotationInfo"
            c:type="GDBusAnnotationInfo"
            version="2.26"
            glib:type-name="GDBusAnnotationInfo"
            glib:get-type="g_dbus_annotation_info_get_type"
            c:symbol-prefix="dbus_annotation_info">
      <doc xml:whitespace="preserve">Information about an annotation.</doc>
      <field name="ref_count" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="key" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="value" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="annotations" writable="1">
        <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo**"/>
      </field>
      <method name="ref"
              c:identifier="g_dbus_annotation_info_ref"
              version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The same @info.</doc>
          <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo*"/>
        </return-value>
      </method>
      <method name="unref"
              c:identifier="g_dbus_annotation_info_unref"
              version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="DBusArgInfo"
            c:type="GDBusArgInfo"
            version="2.26"
            glib:type-name="GDBusArgInfo"
            glib:get-type="g_dbus_arg_info_get_type"
            c:symbol-prefix="dbus_arg_info">
      <doc xml:whitespace="preserve">Information about an argument for a method or a signal.</doc>
      <field name="ref_count" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="signature" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="annotations" writable="1">
        <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo**"/>
      </field>
      <method name="ref" c:identifier="g_dbus_arg_info_ref" version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The same @info.</doc>
          <type name="DBusArgInfo" c:type="GDBusArgInfo*"/>
        </return-value>
      </method>
      <method name="unref" c:identifier="g_dbus_arg_info_unref" version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <class name="DBusAuthObserver"
           c:symbol-prefix="dbus_auth_observer"
           c:type="GDBusAuthObserver"
           version="2.26"
           parent="GObject.Object"
           glib:type-name="GDBusAuthObserver"
           glib:get-type="g_dbus_auth_observer_get_type">
      <doc xml:whitespace="preserve">The #GDBusAuthObserver structure contains only private data and
should only be accessed using the provided API.</doc>
      <constructor name="new"
                   c:identifier="g_dbus_auth_observer_new"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GDBusAuthObserver object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusAuthObserver. Free with g_object_unref().</doc>
          <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
        </return-value>
      </constructor>
      <method name="authorize_authenticated_peer"
              c:identifier="g_dbus_auth_observer_authorize_authenticated_peer"
              version="2.26">
        <doc xml:whitespace="preserve">Emits the #GDBusAuthObserver::authorize-authenticated-peer signal on @observer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the peer is authorized, %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GIOStream for the #GDBusConnection.</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="credentials" transfer-ownership="none">
            <doc xml:whitespace="preserve">Credentials received from the peer or %NULL.</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="authorize-authenticated-peer" version="2.26">
        <doc xml:whitespace="preserve">Emitted to check if a peer that is successfully authenticated
is authorized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the peer is authorized, %FALSE if not.</doc>
          <type name="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GIOStream for the #GDBusConnection.</doc>
            <type name="IOStream"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">Credentials received from the peer or %NULL.</doc>
            <type name="Credentials"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="DBusCallFlags"
              version="2.26"
              glib:type-name="GDBusCallFlags"
              glib:get-type="g_dbus_call_flags_get_type"
              c:type="GDBusCallFlags">
      <doc xml:whitespace="preserve">Flags used in g_dbus_connection_call() and similar APIs.</doc>
      <member name="none"
              value="0"
              c:identifier="G_DBUS_CALL_FLAGS_NONE"
              glib:nick="none"/>
      <member name="no_auto_start"
              value="1"
              c:identifier="G_DBUS_CALL_FLAGS_NO_AUTO_START"
              glib:nick="no-auto-start"/>
    </bitfield>
    <bitfield name="DBusCapabilityFlags"
              version="2.26"
              glib:type-name="GDBusCapabilityFlags"
              glib:get-type="g_dbus_capability_flags_get_type"
              c:type="GDBusCapabilityFlags">
      <doc xml:whitespace="preserve">Capabilities negotiated with the remote peer.</doc>
      <member name="none"
              value="0"
              c:identifier="G_DBUS_CAPABILITY_FLAGS_NONE"
              glib:nick="none"/>
      <member name="unix_fd_passing"
              value="1"
              c:identifier="G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING"
              glib:nick="unix-fd-passing"/>
    </bitfield>
    <class name="DBusConnection"
           c:symbol-prefix="dbus_connection"
           c:type="GDBusConnection"
           version="2.26"
           parent="GObject.Object"
           glib:type-name="GDBusConnection"
           glib:get-type="g_dbus_connection_get_type">
      <doc xml:whitespace="preserve">The #GDBusConnection structure contains only private data and
should only be accessed using the provided API.</doc>
      <implements name="AsyncInitable"/>
      <implements name="Initable"/>
      <constructor name="new_finish"
                   c:identifier="g_dbus_connection_new_finish"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">Finishes an operation started with g_dbus_connection_new().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusConnection or %NULL if @error is set. Free with g_object_unref().</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_new().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_address_finish"
                   c:identifier="g_dbus_connection_new_for_address_finish"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">Finishes an operation started with g_dbus_connection_new_for_address().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusConnection or %NULL if @error is set. Free with g_object_unref().</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_new().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_address_sync"
                   c:identifier="g_dbus_connection_new_for_address_sync"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">Synchronously connects and sets up a D-Bus client connection for
exchanging D-Bus messages with an endpoint specified by @address
which must be in the D-Bus address format.
This constructor can only be used to initiate client-side
connections - use g_dbus_connection_new_sync() if you need to act
as the server. In particular, @flags cannot contain the
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.
This is a synchronous failable constructor. See
g_dbus_connection_new_for_address() for the asynchronous version.
If @observer is not %NULL it may be used to control the
authentication process.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusConnection or %NULL if @error is set. Free with g_object_unref().</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus address.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags describing how to make the connection.</doc>
            <type name="DBusConnectionFlags" c:type="GDBusConnectionFlags"/>
          </parameter>
          <parameter name="observer" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusAuthObserver or %NULL.</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sync"
                   c:identifier="g_dbus_connection_new_sync"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">Synchronously sets up a D-Bus connection for exchanging D-Bus messages
with the end represented by @stream.
If @observer is not %NULL it may be used to control the
authentication process.
This is a synchronous failable constructor. See
g_dbus_connection_new() for the asynchronous version.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusConnection or %NULL if @error is set. Free with g_object_unref().</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GIOStream.</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="guid" transfer-ownership="none">
            <doc xml:whitespace="preserve">The GUID to use if a authenticating as a server or %NULL.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags describing how to make the connection.</doc>
            <type name="DBusConnectionFlags" c:type="GDBusConnectionFlags"/>
          </parameter>
          <parameter name="observer" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusAuthObserver or %NULL.</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new" c:identifier="g_dbus_connection_new" version="2.26">
        <doc xml:whitespace="preserve">Asynchronously sets up a D-Bus connection for exchanging D-Bus messages
with the end represented by @stream.
If @observer is not %NULL it may be used to control the
authentication process.
When the operation is finished, @callback will be invoked. You can
then call g_dbus_connection_new_finish() to get the result of the
operation.
This is a asynchronous failable constructor. See
g_dbus_connection_new_sync() for the synchronous
version.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GIOStream.</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="guid" transfer-ownership="none">
            <doc xml:whitespace="preserve">The GUID to use if a authenticating as a server or %NULL.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags describing how to make the connection.</doc>
            <type name="DBusConnectionFlags" c:type="GDBusConnectionFlags"/>
          </parameter>
          <parameter name="observer" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusAuthObserver or %NULL.</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="6">
            <doc xml:whitespace="preserve">A #GAsyncReadyCallback to call when the request is satisfied.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_address"
                c:identifier="g_dbus_connection_new_for_address"
                version="2.26">
        <doc xml:whitespace="preserve">Asynchronously connects and sets up a D-Bus client connection for
exchanging D-Bus messages with an endpoint specified by @address
which must be in the D-Bus address format.
This constructor can only be used to initiate client-side
connections - use g_dbus_connection_new() if you need to act as the
server. In particular, @flags cannot contain the
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.
When the operation is finished, @callback will be invoked. You can
then call g_dbus_connection_new_finish() to get the result of the
operation.
If @observer is not %NULL it may be used to control the
authentication process.
This is a asynchronous failable constructor. See
g_dbus_connection_new_for_address_sync() for the synchronous
version.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus address.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags describing how to make the connection.</doc>
            <type name="DBusConnectionFlags" c:type="GDBusConnectionFlags"/>
          </parameter>
          <parameter name="observer" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusAuthObserver or %NULL.</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">A #GAsyncReadyCallback to call when the request is satisfied.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_filter"
              c:identifier="g_dbus_connection_add_filter"
              version="2.26">
        <doc xml:whitespace="preserve">Adds a message filter. Filters are handlers that are run on all
incoming and outgoing messages, prior to standard dispatch. Filters
are run in the order that they were added.  The same handler can be
added as a filter more than once, in which case it will be run more
than once.  Filters added during a filter callback won't be run on
the message being processed. Filter functions are allowed to modify
and even drop messages - see the #GDBusMessageFilterResult
enumeration for details.
Note that filters are run in a dedicated message handling thread so
they can't block and, generally, can't do anything but signal a
worker thread. Also note that filters are rarely needed - use API
such as g_dbus_connection_send_message_with_reply(),
g_dbus_connection_signal_subscribe() or
g_dbus_connection_call() instead.
If a filter consumes an incoming message the message is not
dispatched anywhere else - not even the standard dispatch machinery
(that API such as g_dbus_connection_signal_subscribe() and
g_dbus_connection_send_message_with_reply() relies on) will see the
message. Similary, if a filter consumes an outgoing message, the
message will not be sent to the other peer.
g_dbus_connection_remove_filter().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A filter identifier that can be used with</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="filter_function"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">A filter function.</doc>
            <type name="DBusMessageFilterFunction"
                  c:type="GDBusMessageFilterFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">User data to pass to @filter_function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_free_func"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">Function to free @user_data with when filter is removed or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="call" c:identifier="g_dbus_connection_call" version="2.26">
        <doc xml:whitespace="preserve">Asynchronously invokes the @method_name method on the
If @connection is closed then the operation will fail with
%G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
fail with %G_IO_ERROR_CANCELLED. If @parameters contains a value
not compatible with the D-Bus protocol, the operation fails with
%G_IO_ERROR_INVALID_ARGUMENT.
If @reply_type is non-%NULL then the reply will be checked for having this type and an
error will be raised if it does not match.  Said another way, if you give a @reply_type
then any non-%NULL return value will be of this type.
If the @parameters #GVariant is floating, it is consumed. This allows
convenient 'inline' use of g_variant_new(), e.g.:
|[
g_dbus_connection_call (connection,
"org.freedesktop.StringThings",
"/org/freedesktop/StringThings",
"org.freedesktop.StringThings",
"TwoStrings",
g_variant_new ("(ss)",
"Thing One",
"Thing Two"),
NULL,
G_DBUS_CALL_FLAGS_NONE,
-1,
NULL,
(GAsyncReadyCallback) two_strings_done,
NULL);
]|
This is an asynchronous method. When the operation is finished, @callback will be invoked
in the &lt;link linkend="g-main-context-push-thread-default"&gt;thread-default main loop&lt;/link&gt;
of the thread you are calling this method from. You can then call
g_dbus_connection_call_finish() to get the result of the operation.
See g_dbus_connection_call_sync() for the synchronous version of this
function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bus_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A unique or well-known bus name or %NULL if @connection is not a message bus connection.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">Path of remote object.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">D-Bus interface to invoke method on.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the method to invoke.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GVariant tuple with parameters for the method or %NULL if not passing parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="reply_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The expected type of the reply, or %NULL.</doc>
            <type name="GLib.VariantType" c:type="GVariantType*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags from the #GDBusCallFlags enumeration.</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:whitespace="preserve">The timeout in milliseconds or -1 to use the default timeout.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="10">
            <doc xml:whitespace="preserve">A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't care about the result of the method invocation.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_finish"
              c:identifier="g_dbus_connection_call_finish"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an operation started with g_dbus_connection_call().
return values. Free with g_variant_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_call().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_sync"
              c:identifier="g_dbus_connection_call_sync"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Synchronously invokes the @method_name method on the
If @connection is closed then the operation will fail with
%G_IO_ERROR_CLOSED. If @cancellable is canceled, the
operation will fail with %G_IO_ERROR_CANCELLED. If @parameters
contains a value not compatible with the D-Bus protocol, the operation
fails with %G_IO_ERROR_INVALID_ARGUMENT.
If @reply_type is non-%NULL then the reply will be checked for having
this type and an error will be raised if it does not match.  Said
another way, if you give a @reply_type then any non-%NULL return
value will be of this type.
If the @parameters #GVariant is floating, it is consumed.
This allows convenient 'inline' use of g_variant_new(), e.g.:
|[
g_dbus_connection_call_sync (connection,
"org.freedesktop.StringThings",
"/org/freedesktop/StringThings",
"org.freedesktop.StringThings",
"TwoStrings",
g_variant_new ("(ss)",
"Thing One",
"Thing Two"),
NULL,
G_DBUS_CALL_FLAGS_NONE,
-1,
NULL,
&amp;amp;error);
]|
The calling thread is blocked until a reply is received. See
g_dbus_connection_call() for the asynchronous version of
this method.
return values. Free with g_variant_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="bus_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A unique or well-known bus name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">Path of remote object.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">D-Bus interface to invoke method on.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the method to invoke.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GVariant tuple with parameters for the method or %NULL if not passing parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="reply_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The expected type of the reply, or %NULL.</doc>
            <type name="GLib.VariantType" c:type="GVariantType*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags from the #GDBusCallFlags enumeration.</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:whitespace="preserve">The timeout in milliseconds or -1 to use the default timeout.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close"
              c:identifier="g_dbus_connection_close"
              version="2.26">
        <doc xml:whitespace="preserve">Closes @connection. Note that this never causes the process to
exit (this might only happen if the other end of a shared message
bus connection disconnects, see #GDBusConnection:exit-on-close).
Once the connection is closed, operations such as sending a message
will return with the error %G_IO_ERROR_CLOSED. Closing a connection
will not automatically flush the connection so queued messages may
be lost. Use g_dbus_connection_flush() if you need such guarantees.
If @connection is already closed, this method fails with
%G_IO_ERROR_CLOSED.
When @connection has been closed, the #GDBusConnection::closed
signal is emitted in the &lt;link
linkend="g-main-context-push-thread-default"&gt;thread-default main
loop&lt;/link&gt; of the thread that @connection was constructed in.
This is an asynchronous method. When the operation is finished,
linkend="g-main-context-push-thread-default"&gt;thread-default main
loop&lt;/link&gt; of the thread you are calling this method from. You can
then call g_dbus_connection_close_finish() to get the result of the
operation.  See g_dbus_connection_close_sync() for the synchronous
version.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't care about the result.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish"
              c:identifier="g_dbus_connection_close_finish"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an operation started with g_dbus_connection_close().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation succeeded, %FALSE if @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_close().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_sync"
              c:identifier="g_dbus_connection_close_sync"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Synchronously closees @connection. The calling thread is blocked
until this is done. See g_dbus_connection_close() for the
asynchronous version of this method and more details about what it
does.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation succeeded, %FALSE if @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="emit_signal"
              c:identifier="g_dbus_connection_emit_signal"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Emits a signal.
If the parameters GVariant is floating, it is consumed.
This can only fail if @parameters is not compatible with the D-Bus protocol.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE unless @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="destination_bus_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The unique bus name for the destination for the signal or %NULL to emit to all listeners.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">Path of remote object.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">D-Bus interface to emit a signal on.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="signal_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the signal to emit.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush"
              c:identifier="g_dbus_connection_flush"
              version="2.26">
        <doc xml:whitespace="preserve">Asynchronously flushes @connection, that is, writes all queued
outgoing message to the transport and then flushes the transport
(using g_output_stream_flush_async()). This is useful in programs
that wants to emit a D-Bus signal and then exit
immediately. Without flushing the connection, there is no guarantee
that the message has been sent to the networking buffers in the OS
kernel.
This is an asynchronous method. When the operation is finished,
linkend="g-main-context-push-thread-default"&gt;thread-default main
loop&lt;/link&gt; of the thread you are calling this method from. You can
then call g_dbus_connection_flush_finish() to get the result of the
operation.  See g_dbus_connection_flush_sync() for the synchronous
version.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't care about the result.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush_finish"
              c:identifier="g_dbus_connection_flush_finish"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an operation started with g_dbus_connection_flush().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation succeeded, %FALSE if @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_flush().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush_sync"
              c:identifier="g_dbus_connection_flush_sync"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Synchronously flushes @connection. The calling thread is blocked
until this is done. See g_dbus_connection_flush() for the
asynchronous version of this method and more details about what it
does.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation succeeded, %FALSE if @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_capabilities"
              c:identifier="g_dbus_connection_get_capabilities"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the capabilities negotiated with the remote peer</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Zero or more flags from the #GDBusCapabilityFlags enumeration.</doc>
          <type name="DBusCapabilityFlags" c:type="GDBusCapabilityFlags"/>
        </return-value>
      </method>
      <method name="get_exit_on_close"
              c:identifier="g_dbus_connection_get_exit_on_close"
              version="2.26">
        <doc xml:whitespace="preserve">Gets whether the process is terminated when @connection is
closed by the remote peer. See
#GDBusConnection:exit-on-close for more details.
closed by the remote peer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether the process is terminated when @connection is</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_guid"
              c:identifier="g_dbus_connection_get_guid"
              version="2.26">
        <doc xml:whitespace="preserve">The GUID of the peer performing the role of server when
authenticating. See #GDBusConnection:guid for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The GUID. Do not free this string, it is owned by</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_peer_credentials"
              c:identifier="g_dbus_connection_get_peer_credentials"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the credentials of the authenticated peer. This will always
return %NULL unless @connection acted as a server
(e.g. %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)
when set up and the client passed credentials as part of the
authentication process.
In a message bus setup, the message bus is always the server and
each application is a client. So this method will always return
%NULL for message bus clients.
this object, it is owned by @connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GCredentials or %NULL if not available. Do not free</doc>
          <type name="Credentials" c:type="GCredentials*"/>
        </return-value>
      </method>
      <method name="get_stream"
              c:identifier="g_dbus_connection_get_stream"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the underlying stream used for IO.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the stream used for IO</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
      </method>
      <method name="get_unique_name"
              c:identifier="g_dbus_connection_get_unique_name"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the unique name of @connection as assigned by the message
bus. This can also be used to figure out if @connection is a
message bus connection.
bus connection. Do not free this string, it is owned by</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique name or %NULL if @connection is not a message</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="is_closed"
              c:identifier="g_dbus_connection_is_closed"
              version="2.26">
        <doc xml:whitespace="preserve">Gets whether @connection is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection is closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="register_object"
              c:identifier="g_dbus_connection_register_object"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Registers callbacks for exported objects at @object_path with the
D-Bus interface that is described in @interface_info.
Calls to functions in @vtable (and @user_data_free_func) will
happen in the &lt;link linkend="g-main-context-push-thread-default"&gt;thread-default main
loop&lt;/link&gt; of the thread you are calling this method from.
Note that all #GVariant values passed to functions in @vtable will match
the signature given in @interface_info - if a remote caller passes
incorrect values, the &lt;literal&gt;org.freedesktop.DBus.Error.InvalidArgs&lt;/literal&gt;
is returned to the remote caller.
Additionally, if the remote caller attempts to invoke methods or
access properties not mentioned in @interface_info the
&lt;literal&gt;org.freedesktop.DBus.Error.UnknownMethod&lt;/literal&gt; resp.
&lt;literal&gt;org.freedesktop.DBus.Error.InvalidArgs&lt;/literal&gt; errors
are returned to the caller.
It is considered a programming error if the
#GDBusInterfaceGetPropertyFunc function in @vtable returns a
#GVariant of incorrect type.
If an existing callback is already registered at @object_path and
GDBus automatically implements the standard D-Bus interfaces
org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable
and org.freedesktop.Peer, so you don't have to implement those for
the objects you export. You &lt;emphasis&gt;can&lt;/emphasis&gt; implement
org.freedesktop.DBus.Properties yourself, e.g. to handle getting
and setting of properties asynchronously.
Note that the reference count on @interface_info will be
incremented by 1 (unless allocated statically, e.g. if the
reference count is -1, see g_dbus_interface_info_ref()) for as long
as the object is exported. Also note that @vtable will be copied.
See &lt;xref linkend="gdbus-server"/&gt; for an example of how to use this method.
that can be used with g_dbus_connection_unregister_object() .</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 if @error is set, otherwise a registration id (never 0)</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object path to register at.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="interface_info" transfer-ownership="none">
            <doc xml:whitespace="preserve">Introspection data for the interface.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
          <parameter name="vtable" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusInterfaceVTable to call into or %NULL.</doc>
            <type name="DBusInterfaceVTable" c:type="GDBusInterfaceVTable*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to functions in @vtable.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_free_func"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">Function to call when the object path is unregistered.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_subtree"
              c:identifier="g_dbus_connection_register_subtree"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Registers a whole subtree of &lt;quote&gt;dynamic&lt;/quote&gt; objects.
The @enumerate and @introspection functions in @vtable are used to
convey, to remote callers, what nodes exist in the subtree rooted
by @object_path.
When handling remote calls into any node in the subtree, first the
or the #G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set
the @introspection function is used to check if the node supports the
requested method. If so, the @dispatch function is used to determine
where to dispatch the call. The collected #GDBusInterfaceVTable and
#gpointer will be used to call into the interface vtable for processing
the request.
All calls into user-provided code will be invoked in the &lt;link
linkend="g-main-context-push-thread-default"&gt;thread-default main
loop&lt;/link&gt; of the thread you are calling this method from.
If an existing subtree is already registered at @object_path or
then @error is set to #G_IO_ERROR_EXISTS.
Note that it is valid to register regular objects (using
g_dbus_connection_register_object()) in a subtree registered with
g_dbus_connection_register_subtree() - if so, the subtree handler
is tried as the last resort. One way to think about a subtree
handler is to consider it a &lt;quote&gt;fallback handler&lt;/quote&gt;
for object paths not registered via g_dbus_connection_register_object()
or other bindings.
Note that @vtable will be copied so you cannot change it after
registration.
See &lt;xref linkend="gdbus-subtree-server"/&gt; for an example of how to use this method.
that can be used with g_dbus_connection_unregister_subtree() .</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 if @error is set, otherwise a subtree registration id (never 0)</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object path to register the subtree at.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="vtable" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusSubtreeVTable to enumerate, introspect and dispatch nodes in the subtree.</doc>
            <type name="DBusSubtreeVTable" c:type="GDBusSubtreeVTable*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags used to fine tune the behavior of the subtree.</doc>
            <type name="DBusSubtreeFlags" c:type="GDBusSubtreeFlags"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to functions in @vtable.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_free_func"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">Function to call when the subtree is unregistered.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_filter"
              c:identifier="g_dbus_connection_remove_filter"
              version="2.26">
        <doc xml:whitespace="preserve">Removes a filter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">an identifier obtained from g_dbus_connection_add_filter()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message"
              c:identifier="g_dbus_connection_send_message"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Asynchronously sends @message to the peer represented by @connection.
Unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
will be assigned by @connection and set on @message via
g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
serial number used will be written to this location prior to
submitting the message to the underlying transport.
If @connection is closed then the operation will fail with
%G_IO_ERROR_CLOSED. If @message is not well-formed,
the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
See &lt;xref linkend="gdbus-server"/&gt; and &lt;xref
linkend="gdbus-unix-fd-client"/&gt; for an example of how to use this
low-level API to send and receive UNIX file descriptors.
Note that @message must be unlocked, unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
transmission, %FALSE if @error is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the message was well-formed and queued for</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusMessage</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags affecting how the message is sent.</doc>
            <type name="DBusSendMessageFlags" c:type="GDBusSendMessageFlags"/>
          </parameter>
          <parameter name="out_serial" transfer-ownership="none">
            <doc xml:whitespace="preserve">Return location for serial number assigned to @message when sending it or %NULL.</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message_with_reply"
              c:identifier="g_dbus_connection_send_message_with_reply"
              version="2.26">
        <doc xml:whitespace="preserve">Asynchronously sends @message to the peer represented by @connection.
Unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
will be assigned by @connection and set on @message via
g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
serial number used will be written to this location prior to
submitting the message to the underlying transport.
If @connection is closed then the operation will fail with
%G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,
the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
This is an asynchronous method. When the operation is finished, @callback will be invoked
in the &lt;link linkend="g-main-context-push-thread-default"&gt;thread-default main loop&lt;/link&gt;
of the thread you are calling this method from. You can then call
g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.
See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.
Note that @message must be unlocked, unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.
See &lt;xref linkend="gdbus-server"/&gt; and &lt;xref
linkend="gdbus-unix-fd-client"/&gt; for an example of how to use this
low-level API to send and receive UNIX file descriptors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags affecting how the message is sent.</doc>
            <type name="DBusSendMessageFlags" c:type="GDBusSendMessageFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:whitespace="preserve">The timeout in milliseconds or -1 to use the default timeout.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_serial" transfer-ownership="none">
            <doc xml:whitespace="preserve">Return location for serial number assigned to @message when sending it or %NULL.</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="6">
            <doc xml:whitespace="preserve">A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't care about the result.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message_with_reply_finish"
              c:identifier="g_dbus_connection_send_message_with_reply_finish"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an operation started with g_dbus_connection_send_message_with_reply().
Note that @error is only set if a local in-process error
occured. That is to say that the returned #GDBusMessage object may
be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
g_dbus_message_to_gerror() to transcode this to a #GError.
See &lt;xref linkend="gdbus-server"/&gt; and &lt;xref
linkend="gdbus-unix-fd-client"/&gt; for an example of how to use this
low-level API to send and receive UNIX file descriptors.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A locked #GDBusMessage or %NULL if @error is set.</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_connection_send_message_with_reply().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message_with_reply_sync"
              c:identifier="g_dbus_connection_send_message_with_reply_sync"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Synchronously sends @message to the peer represented by @connection
and blocks the calling thread until a reply is received or the
timeout is reached. See g_dbus_connection_send_message_with_reply()
for the asynchronous version of this method.
Unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number
will be assigned by @connection and set on @message via
g_dbus_message_set_serial(). If @out_serial is not %NULL, then the
serial number used will be written to this location prior to
submitting the message to the underlying transport.
If @connection is closed then the operation will fail with
%G_IO_ERROR_CLOSED. If @cancellable is canceled, the operation will
fail with %G_IO_ERROR_CANCELLED. If @message is not well-formed,
the operation fails with %G_IO_ERROR_INVALID_ARGUMENT.
Note that @error is only set if a local in-process error
occured. That is to say that the returned #GDBusMessage object may
be of type %G_DBUS_MESSAGE_TYPE_ERROR. Use
g_dbus_message_to_gerror() to transcode this to a #GError.
See &lt;xref linkend="gdbus-server"/&gt; and &lt;xref
linkend="gdbus-unix-fd-client"/&gt; for an example of how to use this
low-level API to send and receive UNIX file descriptors.
Note that @message must be unlocked, unless @flags contain the
%G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A locked #GDBusMessage that is the reply to @message or %NULL if @error is set.</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusMessage.</doc>
            <type name="DBusMessage" c:type="GDBusMessage*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags affecting how the message is sent.</doc>
            <type name="DBusSendMessageFlags" c:type="GDBusSendMessageFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:whitespace="preserve">The timeout in milliseconds or -1 to use the default timeout.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_serial" transfer-ownership="none">
            <doc xml:whitespace="preserve">Return location for serial number assigned to @message when sending it or %NULL.</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_exit_on_close"
              c:identifier="g_dbus_connection_set_exit_on_close"
              version="2.26">
        <doc xml:whitespace="preserve">Sets whether the process should be terminated when @connection is
closed by the remote peer. See #GDBusConnection:exit-on-close for
more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="exit_on_close" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether the process should be terminated when @connection is closed by the remote peer.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="signal_subscribe"
              c:identifier="g_dbus_connection_signal_subscribe"
              version="2.26">
        <doc xml:whitespace="preserve">Subscribes to signals on @connection and invokes @callback with a
whenever the signal is received. Note that @callback
will be invoked in the &lt;link
linkend="g-main-context-push-thread-default"&gt;thread-default main
loop&lt;/link&gt; of the thread you are calling this method from.
If @connection is not a message bus connection, @sender must be
%NULL.
If @sender is a well-known name note that @callback is invoked with
the unique name for the owner of @sender, not the well-known name
as one would expect. This is because the message bus rewrites the
name. As such, to avoid certain race conditions, users should be
tracking the name owner of the well-known name and use that when
processing the received signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A subscription identifier that can be used with g_dbus_connection_signal_unsubscribe().</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="sender" transfer-ownership="none">
            <doc xml:whitespace="preserve">Sender name to match on (unique or well-known name) or %NULL to listen from all senders.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">D-Bus interface name to match on or %NULL to match on all interfaces.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="member" transfer-ownership="none">
            <doc xml:whitespace="preserve">D-Bus signal name to match on or %NULL to match on all signals.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">Object path to match on or %NULL to match on all object paths.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="arg0" transfer-ownership="none">
            <doc xml:whitespace="preserve">Contents of first string argument to match on or %NULL to match on all kinds of arguments.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags describing how to subscribe to the signal (currently unused).</doc>
            <type name="DBusSignalFlags" c:type="GDBusSignalFlags"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="7"
                     destroy="8">
            <doc xml:whitespace="preserve">Callback to invoke when there is a signal matching the requested data.</doc>
            <type name="DBusSignalCallback" c:type="GDBusSignalCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">User data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_free_func"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">Function to free @user_data with when subscription is removed or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="signal_unsubscribe"
              c:identifier="g_dbus_connection_signal_unsubscribe"
              version="2.26">
        <doc xml:whitespace="preserve">Unsubscribes from signals.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="subscription_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">A subscription id obtained from g_dbus_connection_signal_subscribe().</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_message_processing"
              c:identifier="g_dbus_connection_start_message_processing"
              version="2.26">
        <doc xml:whitespace="preserve">If @connection was created with
%G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method
starts processing messages. Does nothing on if @connection wasn't
created with this flag or if the method has already been called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="unregister_object"
              c:identifier="g_dbus_connection_unregister_object"
              version="2.26">
        <doc xml:whitespace="preserve">Unregisters an object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the object was unregistered, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="registration_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">A registration id obtained from g_dbus_connection_register_object().</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister_subtree"
              c:identifier="g_dbus_connection_unregister_subtree"
              version="2.26">
        <doc xml:whitespace="preserve">Unregisters a subtree.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the subtree was unregistered, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="registration_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">A subtree registration id obtained from g_dbus_connection_register_subtree().</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <property name="address"
                version="2.26"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A D-Bus address specifying potential endpoints that can be used
when establishing the connection.</doc>
        <type name="utf8"/>
      </property>
      <property name="authentication-observer"
                version="2.26"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GDBusAuthObserver object to assist in the authentication process or %NULL.</doc>
        <type name="DBusAuthObserver"/>
      </property>
      <property name="capabilities" version="2.26" transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags from the #GDBusCapabilityFlags enumeration
representing connection features negotiated with the other peer.</doc>
        <type name="DBusCapabilityFlags"/>
      </property>
      <property name="closed" version="2.26" transfer-ownership="none">
        <doc xml:whitespace="preserve">A boolean specifying whether the connection has been closed.</doc>
        <type name="gboolean"/>
      </property>
      <property name="exit-on-close"
                version="2.26"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A boolean specifying whether the process will be terminated (by
calling &lt;literal&gt;raise(SIGTERM)&lt;/literal&gt;) if the connection
is closed by the remote peer.</doc>
        <type name="gboolean"/>
      </property>
      <property name="flags"
                version="2.26"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags from the #GDBusConnectionFlags enumeration.</doc>
        <type name="DBusConnectionFlags"/>
      </property>
      <property name="guid"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The GUID of the peer performing the role of server when
authenticating.
If you are constructing a #GDBusConnection and pass
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
#GDBusConnection:flags property then you MUST also set this
property to a valid guid.
If you are constructing a #GDBusConnection and pass
%G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
#GDBusConnection:flags property you will be able to read the GUID
of the other peer here after the connection has been successfully
initialized.</doc>
        <type name="utf8"/>
      </property>
      <property name="stream"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The underlying #GIOStream used for I/O.</doc>
        <type name="IOStream"/>
      </property>
      <property name="unique-name" version="2.26" transfer-ownership="none">
        <doc xml:whitespace="preserve">The unique name as assigned by the message bus or %NULL if the
connection is not open or not a message bus connection.</doc>
        <type name="utf8"/>
      </property>
      <glib:signal name="closed" version="2.26">
        <doc xml:whitespace="preserve">Emitted when the connection is closed.
The cause of this event can be
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;
If g_dbus_connection_close() is called. In this case
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
If the remote peer closes the connection. In this case
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
If the remote peer sends invalid or malformed data. In this
case @remote_peer_vanished is set to %FALSE and @error
is set.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
Upon receiving this signal, you should give up your reference to
once.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if @connection is closed because the remote peer closed its end of the connection.</doc>
            <type name="gboolean"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GError with more details about the event or %NULL.</doc>
            <type name="GObject.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="DBusConnectionFlags"
              version="2.26"
              glib:type-name="GDBusConnectionFlags"
              glib:get-type="g_dbus_connection_flags_get_type"
              c:type="GDBusConnectionFlags">
      <doc xml:whitespace="preserve">Flags used when creating a new #GDBusConnection.</doc>
      <member name="none"
              value="0"
              c:identifier="G_DBUS_CONNECTION_FLAGS_NONE"
              glib:nick="none"/>
      <member name="authentication_client"
              value="1"
              c:identifier="G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT"
              glib:nick="authentication-client"/>
      <member name="authentication_server"
              value="2"
              c:identifier="G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER"
              glib:nick="authentication-server"/>
      <member name="authentication_allow_anonymous"
              value="4"
              c:identifier="G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS"
              glib:nick="authentication-allow-anonymous"/>
      <member name="message_bus_connection"
              value="8"
              c:identifier="G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION"
              glib:nick="message-bus-connection"/>
      <member name="delay_message_processing"
              value="16"
              c:identifier="G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING"
              glib:nick="delay-message-processing"/>
    </bitfield>
    <enumeration name="DBusError"
                 version="2.26"
                 glib:type-name="GDBusError"
                 glib:get-type="g_dbus_error_get_type"
                 c:type="GDBusError">
      <doc xml:whitespace="preserve">A generic error; "something went wrong" - see the error message for
more.
There was not enough memory to complete an operation.
The bus doesn't know how to launch a service to supply the bus name
you wanted.
The bus name you referenced doesn't exist (i.e. no application owns
it).
No reply to a message expecting one, usually means a timeout occurred.
Something went wrong reading or writing to a socket, for example.
A D-Bus bus address was malformed.
Requested operation isn't supported (like ENOSYS on UNIX).
Some limited resource is exhausted.
Security restrictions don't allow doing what you're trying to do.
Authentication didn't work.
Unable to connect to server (probably caused by ECONNREFUSED on a
socket).
Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that
%G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:
this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also
exists. We can't fix it for compatibility reasons so just be
careful.
No network access (probably ENETUNREACH on a socket).
Can't bind a socket since its address is in use (i.e. EADDRINUSE).
The connection is disconnected and you're trying to use it.
Invalid arguments passed to a method call.
Missing file.
Existing file and the operation you're using does not silently overwrite.
Method name you invoked isn't known by the object you invoked it on.
confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We
can't fix it for compatibility reasons so just be careful.
Tried to remove or modify a match rule that didn't exist.
The match rule isn't syntactically valid.
While starting a new process, the exec() call failed.
While starting a new process, the fork() call failed.
While starting a new process, the child exited with a status code.
While starting a new process, the child exited on a signal.
While starting a new process, something went wrong.
We failed to setup the environment correctly.
We failed to setup the config parser correctly.
Bus name was not valid.
Service file not found in system-services directory.
Permissions are incorrect on the setuid helper.
Service file invalid (Name, User or Exec missing).
Tried to get a UNIX process ID and it wasn't available.
Tried to get a UNIX process ID and it wasn't available.
A type signature is not valid.
A file contains invalid syntax or is otherwise broken.
Asked for SELinux security context and it wasn't available.
Asked for ADT audit data and it wasn't available.
There's already an object with the requested object path.
Error codes for the %G_DBUS_ERROR error domain.</doc>
      <member name="failed"
              value="0"
              c:identifier="G_DBUS_ERROR_FAILED"
              glib:nick="failed"/>
      <member name="no_memory"
              value="1"
              c:identifier="G_DBUS_ERROR_NO_MEMORY"
              glib:nick="no-memory"/>
      <member name="service_unknown"
              value="2"
              c:identifier="G_DBUS_ERROR_SERVICE_UNKNOWN"
              glib:nick="service-unknown"/>
      <member name="name_has_no_owner"
              value="3"
              c:identifier="G_DBUS_ERROR_NAME_HAS_NO_OWNER"
              glib:nick="name-has-no-owner"/>
      <member name="no_reply"
              value="4"
              c:identifier="G_DBUS_ERROR_NO_REPLY"
              glib:nick="no-reply"/>
      <member name="io_error"
              value="5"
              c:identifier="G_DBUS_ERROR_IO_ERROR"
              glib:nick="io-error"/>
      <member name="bad_address"
              value="6"
              c:identifier="G_DBUS_ERROR_BAD_ADDRESS"
              glib:nick="bad-address"/>
      <member name="not_supported"
              value="7"
              c:identifier="G_DBUS_ERROR_NOT_SUPPORTED"
              glib:nick="not-supported"/>
      <member name="limits_exceeded"
              value="8"
              c:identifier="G_DBUS_ERROR_LIMITS_EXCEEDED"
              glib:nick="limits-exceeded"/>
      <member name="access_denied"
              value="9"
              c:identifier="G_DBUS_ERROR_ACCESS_DENIED"
              glib:nick="access-denied"/>
      <member name="auth_failed"
              value="10"
              c:identifier="G_DBUS_ERROR_AUTH_FAILED"
              glib:nick="auth-failed"/>
      <member name="no_server"
              value="11"
              c:identifier="G_DBUS_ERROR_NO_SERVER"
              glib:nick="no-server"/>
      <member name="timeout"
              value="12"
              c:identifier="G_DBUS_ERROR_TIMEOUT"
              glib:nick="timeout"/>
      <member name="no_network"
              value="13"
              c:identifier="G_DBUS_ERROR_NO_NETWORK"
              glib:nick="no-network"/>
      <member name="address_in_use"
              value="14"
              c:identifier="G_DBUS_ERROR_ADDRESS_IN_USE"
              glib:nick="address-in-use"/>
      <member name="disconnected"
              value="15"
              c:identifier="G_DBUS_ERROR_DISCONNECTED"
              glib:nick="disconnected"/>
      <member name="invalid_args"
              value="16"
              c:identifier="G_DBUS_ERROR_INVALID_ARGS"
              glib:nick="invalid-args"/>
      <member name="file_not_found"
              value="17"
              c:identifier="G_DBUS_ERROR_FILE_NOT_FOUND"
              glib:nick="file-not-found"/>
      <member name="file_exists"
              value="18"
              c:identifier="G_DBUS_ERROR_FILE_EXISTS"
              glib:nick="file-exists"/>
      <member name="unknown_method"
              value="19"
              c:identifier="G_DBUS_ERROR_UNKNOWN_METHOD"
              glib:nick="unknown-method"/>
      <member name="timed_out"
              value="20"
              c:identifier="G_DBUS_ERROR_TIMED_OUT"
              glib:nick="timed-out"/>
      <member name="match_rule_not_found"
              value="21"
              c:identifier="G_DBUS_ERROR_MATCH_RULE_NOT_FOUND"
              glib:nick="match-rule-not-found"/>
      <member name="match_rule_invalid"
              value="22"
              c:identifier="G_DBUS_ERROR_MATCH_RULE_INVALID"
              glib:nick="match-rule-invalid"/>
      <member name="spawn_exec_failed"
              value="23"
              c:identifier="G_DBUS_ERROR_SPAWN_EXEC_FAILED"
              glib:nick="spawn-exec-failed"/>
      <member name="spawn_fork_failed"
              value="24"
              c:identifier="G_DBUS_ERROR_SPAWN_FORK_FAILED"
              glib:nick="spawn-fork-failed"/>
      <member name="spawn_child_exited"
              value="25"
              c:identifier="G_DBUS_ERROR_SPAWN_CHILD_EXITED"
              glib:nick="spawn-child-exited"/>
      <member name="spawn_child_signaled"
              value="26"
              c:identifier="G_DBUS_ERROR_SPAWN_CHILD_SIGNALED"
              glib:nick="spawn-child-signaled"/>
      <member name="spawn_failed"
              value="27"
              c:identifier="G_DBUS_ERROR_SPAWN_FAILED"
              glib:nick="spawn-failed"/>
      <member name="spawn_setup_failed"
              value="28"
              c:identifier="G_DBUS_ERROR_SPAWN_SETUP_FAILED"
              glib:nick="spawn-setup-failed"/>
      <member name="spawn_config_invalid"
              value="29"
              c:identifier="G_DBUS_ERROR_SPAWN_CONFIG_INVALID"
              glib:nick="spawn-config-invalid"/>
      <member name="spawn_service_invalid"
              value="30"
              c:identifier="G_DBUS_ERROR_SPAWN_SERVICE_INVALID"
              glib:nick="spawn-service-invalid"/>
      <member name="spawn_service_not_found"
              value="31"
              c:identifier="G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND"
              glib:nick="spawn-service-not-found"/>
      <member name="spawn_permissions_invalid"
              value="32"
              c:identifier="G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID"
              glib:nick="spawn-permissions-invalid"/>
      <member name="spawn_file_invalid"
              value="33"
              c:identifier="G_DBUS_ERROR_SPAWN_FILE_INVALID"
              glib:nick="spawn-file-invalid"/>
      <member name="spawn_no_memory"
              value="34"
              c:identifier="G_DBUS_ERROR_SPAWN_NO_MEMORY"
              glib:nick="spawn-no-memory"/>
      <member name="unix_process_id_unknown"
              value="35"
              c:identifier="G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN"
              glib:nick="unix-process-id-unknown"/>
      <member name="invalid_signature"
              value="36"
              c:identifier="G_DBUS_ERROR_INVALID_SIGNATURE"
              glib:nick="invalid-signature"/>
      <member name="invalid_file_content"
              value="37"
              c:identifier="G_DBUS_ERROR_INVALID_FILE_CONTENT"
              glib:nick="invalid-file-content"/>
      <member name="selinux_security_context_unknown"
              value="38"
              c:identifier="G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN"
              glib:nick="selinux-security-context-unknown"/>
      <member name="adt_audit_data_unknown"
              value="39"
              c:identifier="G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN"
              glib:nick="adt-audit-data-unknown"/>
      <member name="object_path_in_use"
              value="40"
              c:identifier="G_DBUS_ERROR_OBJECT_PATH_IN_USE"
              glib:nick="object-path-in-use"/>
    </enumeration>
    <record name="DBusErrorEntry" c:type="GDBusErrorEntry" version="2.26">
      <doc xml:whitespace="preserve">Struct used in g_dbus_error_register_error_domain().</doc>
      <field name="error_code" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="dbus_error_name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
    </record>
    <callback name="DBusInterfaceGetPropertyFunc"
              c:type="GDBusInterfaceGetPropertyFunc"
              version="2.26">
      <doc xml:whitespace="preserve">The type of the @get_property function in #GDBusInterfaceVTable.
consumed - otherwise its reference count is decreased by one.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A #GVariant with the value for @property_name or %NULL if</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:whitespace="preserve">The object path that the method was invoked on.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus interface name for the property.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the property to get the value of.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">Return location for error.</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">The @user_data #gpointer passed to g_dbus_connection_register_object().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusInterfaceInfo"
            c:type="GDBusInterfaceInfo"
            version="2.26"
            glib:type-name="GDBusInterfaceInfo"
            glib:get-type="g_dbus_interface_info_get_type"
            c:symbol-prefix="dbus_interface_info">
      <doc xml:whitespace="preserve">Information about a D-Bus interface.</doc>
      <field name="ref_count" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="methods" writable="1">
        <type name="DBusMethodInfo" c:type="GDBusMethodInfo**"/>
      </field>
      <field name="signals" writable="1">
        <type name="DBusSignalInfo" c:type="GDBusSignalInfo**"/>
      </field>
      <field name="properties" writable="1">
        <type name="DBusPropertyInfo" c:type="GDBusPropertyInfo**"/>
      </field>
      <field name="annotations" writable="1">
        <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo**"/>
      </field>
      <method name="generate_xml"
              c:identifier="g_dbus_interface_info_generate_xml"
              version="2.26">
        <doc xml:whitespace="preserve">Appends an XML representation of @info (and its children) to @string_builder.
This function is typically used for generating introspection XML
documents at run-time for handling the
&lt;literal&gt;org.freedesktop.DBus.Introspectable.Introspect&lt;/literal&gt;
method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="indent" transfer-ownership="none">
            <doc xml:whitespace="preserve">Indentation level.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="string_builder" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GString to to append XML data to.</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_method"
              c:identifier="g_dbus_interface_info_lookup_method"
              version="2.26">
        <doc xml:whitespace="preserve">Looks up information about a method.
This cost of this function is O(n) in number of methods.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusMethodInfo or %NULL if not found. Do not free, it is owned by @info.</doc>
          <type name="DBusMethodInfo" c:type="GDBusMethodInfo*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus method name (typically in CamelCase)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_property"
              c:identifier="g_dbus_interface_info_lookup_property"
              version="2.26">
        <doc xml:whitespace="preserve">Looks up information about a property.
This cost of this function is O(n) in number of properties.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusPropertyInfo or %NULL if not found. Do not free, it is owned by @info.</doc>
          <type name="DBusPropertyInfo" c:type="GDBusPropertyInfo*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus property name (typically in CamelCase).</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_signal"
              c:identifier="g_dbus_interface_info_lookup_signal"
              version="2.26">
        <doc xml:whitespace="preserve">Looks up information about a signal.
This cost of this function is O(n) in number of signals.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusSignalInfo or %NULL if not found. Do not free, it is owned by @info.</doc>
          <type name="DBusSignalInfo" c:type="GDBusSignalInfo*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus signal name (typically in CamelCase)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref"
              c:identifier="g_dbus_interface_info_ref"
              version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The same @info.</doc>
          <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
        </return-value>
      </method>
      <method name="unref"
              c:identifier="g_dbus_interface_info_unref"
              version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <callback name="DBusInterfaceMethodCallFunc"
              c:type="GDBusInterfaceMethodCallFunc"
              version="2.26">
      <doc xml:whitespace="preserve">The type of the @method_call function in #GDBusInterfaceVTable.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:whitespace="preserve">The object path that the method was invoked on.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus interface name the method was invoked on.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="method_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the method that was invoked.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="parameters" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GVariant tuple with parameters.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="invocation" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusMethodInvocation object that can be used to return a value or error.</doc>
          <type name="DBusMethodInvocation" c:type="GDBusMethodInvocation*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="7">
          <doc xml:whitespace="preserve">The @user_data #gpointer passed to g_dbus_connection_register_object().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DBusInterfaceSetPropertyFunc"
              c:type="GDBusInterfaceSetPropertyFunc"
              version="2.26">
      <doc xml:whitespace="preserve">The type of the @set_property function in #GDBusInterfaceVTable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the property was set to @value, %FALSE if @error is set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:whitespace="preserve">The object path that the method was invoked on.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus interface name for the property.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the property to get the value of.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">The value to set the property to.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">Return location for error.</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="7">
          <doc xml:whitespace="preserve">The @user_data #gpointer passed to g_dbus_connection_register_object().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusInterfaceVTable"
            c:type="GDBusInterfaceVTable"
            version="2.26">
      <doc xml:whitespace="preserve">Virtual table for handling properties and method calls for a D-Bus
interface.
If you want to handle getting/setting D-Bus properties asynchronously, simply
register an object with the &lt;literal&gt;org.freedesktop.DBus.Properties&lt;/literal&gt;
D-Bus interface using g_dbus_connection_register_object().</doc>
      <field name="method_call" writable="1">
        <type name="DBusInterfaceMethodCallFunc"
              c:type="GDBusInterfaceMethodCallFunc"/>
      </field>
      <field name="get_property" writable="1">
        <type name="DBusInterfaceGetPropertyFunc"
              c:type="GDBusInterfaceGetPropertyFunc"/>
      </field>
      <field name="set_property" writable="1">
        <type name="DBusInterfaceSetPropertyFunc"
              c:type="GDBusInterfaceSetPropertyFunc"/>
      </field>
      <field name="padding" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="DBusMessage"
           c:symbol-prefix="dbus_message"
           c:type="GDBusMessage"
           version="2.26"
           parent="GObject.Object"
           glib:type-name="GDBusMessage"
           glib:get-type="g_dbus_message_get_type">
      <doc xml:whitespace="preserve">The #GDBusMessage structure contains only private data and should
only be accessed using the provided API.</doc>
      <constructor name="new" c:identifier="g_dbus_message_new" version="2.26">
        <doc xml:whitespace="preserve">Creates a new empty #GDBusMessage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_blob"
                   c:identifier="g_dbus_message_new_from_blob"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">Creates a new #GDBusMessage from the data stored at @blob. The byte
order that the message was in can be retrieved using
g_dbus_message_get_byte_order().
g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #GDBusMessage or %NULL if @error is set. Free with</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <parameter name="blob" transfer-ownership="none">
            <doc xml:whitespace="preserve">A blob represent a binary D-Bus message.</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="blob_len" transfer-ownership="none">
            <doc xml:whitespace="preserve">The length of @blob.</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="capabilities" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusCapabilityFlags describing what protocol features are supported.</doc>
            <type name="DBusCapabilityFlags" c:type="GDBusCapabilityFlags"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_method_call"
                   c:identifier="g_dbus_message_new_method_call"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GDBusMessage for a method call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid D-Bus name or %NULL.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid object path.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="interface_" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid D-Bus interface name or %NULL.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid method name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_signal"
                   c:identifier="g_dbus_message_new_signal"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GDBusMessage for a signal emission.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid object path.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="interface_" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid D-Bus interface name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="signal" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid signal name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="bytes_needed"
                c:identifier="g_dbus_message_bytes_needed"
                version="2.26"
                throws="1">
        <doc xml:whitespace="preserve">Utility function to calculate how many bytes are needed to
completely deserialize the D-Bus message stored at @blob.
determine the size).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes needed or -1 if @error is set (e.g. if</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="blob" transfer-ownership="none">
            <doc xml:whitespace="preserve">A blob represent a binary D-Bus message.</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="blob_len" transfer-ownership="none">
            <doc xml:whitespace="preserve">The length of @blob (must be at least 16).</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <method name="copy"
              c:identifier="g_dbus_message_copy"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Copies @message. The copy is a deep copy and the returned
#GDBusMessage is completely identical except that it is guaranteed
to not be locked.
This operation can fail if e.g. @message contains file descriptors
and the per-process or system-wide open files limit is reached.
g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #GDBusMessage or %NULL if @error is set. Free with</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
      </method>
      <method name="get_arg0"
              c:identifier="g_dbus_message_get_arg0"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience to get the first item in the body of @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The string item or %NULL if the first item in the body of</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_body"
              c:identifier="g_dbus_message_get_body"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the body of a message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GVariant or %NULL if the body is empty. Do not free, it is owned by @message.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="get_byte_order"
              c:identifier="g_dbus_message_get_byte_order">
        <doc xml:whitespace="preserve">Gets the byte order of @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte order.</doc>
          <type name="DBusMessageByteOrder" c:type="GDBusMessageByteOrder"/>
        </return-value>
      </method>
      <method name="get_destination"
              c:identifier="g_dbus_message_get_destination"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The value.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_error_name"
              c:identifier="g_dbus_message_get_error_name"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The value.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_flags"
              c:identifier="g_dbus_message_get_flags"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the flags for @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags that are set (typically values from the #GDBusMessageFlags enumeration bitwise ORed together).</doc>
          <type name="DBusMessageFlags" c:type="GDBusMessageFlags"/>
        </return-value>
      </method>
      <method name="get_header"
              c:identifier="g_dbus_message_get_header"
              version="2.26">
        <doc xml:whitespace="preserve">Gets a header field on @message.
otherwise. Do not free, it is owned by @message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GVariant with the value if the header was found, %NULL</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="header_field" transfer-ownership="none">
            <doc xml:whitespace="preserve">A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)</doc>
            <type name="DBusMessageHeaderField"
                  c:type="GDBusMessageHeaderField"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_header_fields"
              c:identifier="g_dbus_message_get_header_fields"
              version="2.26">
        <doc xml:whitespace="preserve">Gets an array of all header fields on @message that are set.
%G_DBUS_MESSAGE_HEADER_FIELD_INVALID.  Each element is a
#guchar. Free with g_free().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of header fields terminated by</doc>
          <type name="guint8" c:type="guchar*"/>
        </return-value>
      </method>
      <method name="get_interface"
              c:identifier="g_dbus_message_get_interface"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The value.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_locked"
              c:identifier="g_dbus_message_get_locked"
              version="2.26">
        <doc xml:whitespace="preserve">Checks whether @message is locked. To monitor changes to this
value, conncet to the #GObject::notify signal to listen for changes
on the #GDBusMessage:locked property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @message is locked, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_member"
              c:identifier="g_dbus_message_get_member"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The value.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_message_type"
              c:identifier="g_dbus_message_get_message_type"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the type of @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).</doc>
          <type name="DBusMessageType" c:type="GDBusMessageType"/>
        </return-value>
      </method>
      <method name="get_num_unix_fds"
              c:identifier="g_dbus_message_get_num_unix_fds"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The value.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_path"
              c:identifier="g_dbus_message_get_path"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The value.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_reply_serial"
              c:identifier="g_dbus_message_get_reply_serial"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The value.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_sender"
              c:identifier="g_dbus_message_get_sender"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The value.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_serial"
              c:identifier="g_dbus_message_get_serial"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the serial for @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #guint32.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_signature"
              c:identifier="g_dbus_message_get_signature"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience getter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The value.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_unix_fd_list"
              c:identifier="g_dbus_message_get_unix_fd_list"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the UNIX file descriptors associated with @message, if any.
This method is only available on UNIX.
associated. Do not free, this object is owned by @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GUnixFDList or %NULL if no file descriptors are</doc>
          <type name="UnixFDList" c:type="GUnixFDList*"/>
        </return-value>
      </method>
      <method name="lock" c:identifier="g_dbus_message_lock" version="2.26">
        <doc xml:whitespace="preserve">If @message is locked, does nothing. Otherwise locks the message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="new_method_error"
              c:identifier="g_dbus_message_new_method_error"
              version="2.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GDBusMessage that is an error reply to @method_call_message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid D-Bus error name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="error_message_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The D-Bus error message in a printf() format.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="new_method_error_literal"
              c:identifier="g_dbus_message_new_method_error_literal"
              version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GDBusMessage that is an error reply to @method_call_message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid D-Bus error name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="error_message" transfer-ownership="none">
            <doc xml:whitespace="preserve">The D-Bus error message.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_method_error_valist"
              c:identifier="g_dbus_message_new_method_error_valist"
              version="2.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Like g_dbus_message_new_method_error() but intended for language bindings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
        <parameters>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid D-Bus error name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="error_message_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The D-Bus error message in a printf() format.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">Arguments for @error_message_format.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_method_reply"
              c:identifier="g_dbus_message_new_method_reply"
              version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GDBusMessage that is a reply to @method_call_message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GDBusMessage. Free with g_object_unref().</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
      </method>
      <method name="print" c:identifier="g_dbus_message_print" version="2.26">
        <doc xml:whitespace="preserve">Produces a human-readable multi-line description of @message.
The contents of the description has no ABI guarantees, the contents
and formatting is subject to change at any time. Typical output
looks something like this:
&lt;programlisting&gt;
Headers:
path -&gt; objectpath '/org/gtk/GDBus/TestObject'
interface -&gt; 'org.gtk.GDBus.TestInterface'
member -&gt; 'GimmeStdout'
destination -&gt; ':1.146'
UNIX File Descriptors:
(none)
&lt;/programlisting&gt;
or
&lt;programlisting&gt;
Headers:
reply-serial -&gt; uint32 4
destination -&gt; ':1.159'
sender -&gt; ':1.146'
num-unix-fds -&gt; uint32 1
UNIX File Descriptors:
&lt;/programlisting&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A string that should be freed with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="indent" transfer-ownership="none">
            <doc xml:whitespace="preserve">Indentation level.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_body"
              c:identifier="g_dbus_message_set_body"
              version="2.26">
        <doc xml:whitespace="preserve">Sets the body @message. As a side-effect the
%G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the
type string of @body (or cleared if @body is %NULL).
If @body is floating, @message assumes ownership of @body.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="body" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either %NULL or a #GVariant that is a tuple.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_byte_order"
              c:identifier="g_dbus_message_set_byte_order">
        <doc xml:whitespace="preserve">Sets the byte order of @message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="byte_order" transfer-ownership="none">
            <doc xml:whitespace="preserve">The byte order.</doc>
            <type name="DBusMessageByteOrder" c:type="GDBusMessageByteOrder"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_destination"
              c:identifier="g_dbus_message_set_destination"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value to set.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_error_name"
              c:identifier="g_dbus_message_set_error_name"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value to set.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags"
              c:identifier="g_dbus_message_set_flags"
              version="2.26">
        <doc xml:whitespace="preserve">Sets the flags to set on @message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags for @message that are set (typically values from the #GDBusMessageFlags enumeration bitwise ORed together).</doc>
            <type name="DBusMessageFlags" c:type="GDBusMessageFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_header"
              c:identifier="g_dbus_message_set_header"
              version="2.26">
        <doc xml:whitespace="preserve">Sets a header field on @message.
If @value is floating, @message assumes ownership of @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="header_field" transfer-ownership="none">
            <doc xml:whitespace="preserve">A 8-bit unsigned integer (typically a value from the #GDBusMessageHeaderField enumeration)</doc>
            <type name="DBusMessageHeaderField"
                  c:type="GDBusMessageHeaderField"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GVariant to set the header field or %NULL to clear the header field.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_interface"
              c:identifier="g_dbus_message_set_interface"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value to set.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_member"
              c:identifier="g_dbus_message_set_member"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value to set.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_message_type"
              c:identifier="g_dbus_message_set_message_type"
              version="2.26">
        <doc xml:whitespace="preserve">Sets @message to be of @type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">A 8-bit unsigned integer (typically a value from the #GDBusMessageType enumeration).</doc>
            <type name="DBusMessageType" c:type="GDBusMessageType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_num_unix_fds"
              c:identifier="g_dbus_message_set_num_unix_fds"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value to set.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_path"
              c:identifier="g_dbus_message_set_path"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value to set.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_reply_serial"
              c:identifier="g_dbus_message_set_reply_serial"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value to set.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sender"
              c:identifier="g_dbus_message_set_sender"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value to set.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_serial"
              c:identifier="g_dbus_message_set_serial"
              version="2.26">
        <doc xml:whitespace="preserve">Sets the serial for @message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="serial" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #guint32.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_signature"
              c:identifier="g_dbus_message_set_signature"
              version="2.26">
        <doc xml:whitespace="preserve">Convenience setter for the %G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value to set.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_unix_fd_list"
              c:identifier="g_dbus_message_set_unix_fd_list"
              version="2.26">
        <doc xml:whitespace="preserve">Sets the UNIX file descriptors associated with @message. As a
side-effect the %G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header
field is set to the number of fds in @fd_list (or cleared if
This method is only available on UNIX.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fd_list" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">A #GUnixFDList or %NULL.</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_blob"
              c:identifier="g_dbus_message_to_blob"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Serializes @message to a blob. The byte order returned by
g_dbus_message_get_byte_order() will be used.
generated by @message or %NULL if @error is set. Free with g_free().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to a valid binary D-Bus message of @out_size bytes</doc>
          <type name="guint8" c:type="guchar*"/>
        </return-value>
        <parameters>
          <parameter name="out_size" transfer-ownership="none">
            <doc xml:whitespace="preserve">Return location for size of generated blob.</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
          <parameter name="capabilities" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusCapabilityFlags describing what protocol features are supported.</doc>
            <type name="DBusCapabilityFlags" c:type="GDBusCapabilityFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_gerror"
              c:identifier="g_dbus_message_to_gerror"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">If @message is not of type %G_DBUS_MESSAGE_TYPE_ERROR does
nothing and returns %FALSE.
Otherwise this method encodes the error in @message as a #GError
using g_dbus_error_set_dbus_error() using the information in the
%G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of @message as
well as the first string item in @message's body.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @error was set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="locked" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
    </class>
    <enumeration name="DBusMessageByteOrder"
                 version="2.26"
                 glib:type-name="GDBusMessageByteOrder"
                 glib:get-type="g_dbus_message_byte_order_get_type"
                 c:type="GDBusMessageByteOrder">
      <doc xml:whitespace="preserve">Enumeration used to describe the byte order of a D-Bus message.</doc>
      <member name="big_endian"
              value="66"
              c:identifier="G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN"
              glib:nick="big-endian"/>
      <member name="little_endian"
              value="108"
              c:identifier="G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN"
              glib:nick="little-endian"/>
    </enumeration>
    <callback name="DBusMessageFilterFunction"
              c:type="GDBusMessageFilterFunction"
              version="2.26">
      <doc xml:whitespace="preserve">Signature for function used in g_dbus_connection_add_filter().
A filter function is passed a #GDBusMessage and expected to return
a #GDBusMessage too. Passive filter functions that don't modify the
message can simply return the @message object:
|[
static GDBusMessage *
passive_filter (GDBusConnection *connection
GDBusMessage    *message,
gboolean         incoming,
gpointer         user_data)
{
/&lt;!-- --&gt;* inspect @message *&lt;!-- --&gt;/
return message;
}
]|
Filter functions that wants to drop a message can simply return %NULL:
|[
static GDBusMessage *
drop_filter (GDBusConnection *connection
GDBusMessage    *message,
gboolean         incoming,
gpointer         user_data)
{
if (should_drop_message)
{
g_object_unref (message);
message = NULL;
}
return message;
}
]|
Finally, a filter function may modify a message by copying it:
|[
static GDBusMessage *
modifying_filter (GDBusConnection *connection
GDBusMessage    *message,
gboolean         incoming,
gpointer         user_data)
{
GDBusMessage *copy;
GError *error;
error = NULL;
copy = g_dbus_message_copy (message, &amp;error);
/&lt;!-- --&gt;* handle @error being is set *&lt;!-- --&gt;/
g_object_unref (message);
/&lt;!-- --&gt;* modify @copy *&lt;!-- --&gt;/
return copy;
}
]|
If the returned #GDBusMessage is different from @message and cannot
be sent on @connection (it could use features, such as file
descriptors, not compatible with @connection), then a warning is
logged to &lt;emphasis&gt;standard error&lt;/emphasis&gt;. Applications can
check this ahead of time using g_dbus_message_to_blob() passing a
#GDBusCapabilityFlags value obtained from @connection.
g_object_unref() or %NULL to drop the message. Passive filter
functions can simply return the passed @message object.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A #GDBusMessage that will be freed with</doc>
        <type name="DBusMessage" c:type="GDBusMessage*"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="message" transfer-ownership="full">
          <doc xml:whitespace="preserve">A locked #GDBusMessage that the filter function takes ownership of.</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </parameter>
        <parameter name="incoming" transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if it is a message received from the other peer, %FALSE if it is a message to be sent to the other peer.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">User data passed when adding the filter.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="DBusMessageFlags"
              version="2.26"
              glib:type-name="GDBusMessageFlags"
              glib:get-type="g_dbus_message_flags_get_type"
              c:type="GDBusMessageFlags">
      <doc xml:whitespace="preserve">Message flags used in #GDBusMessage.</doc>
      <member name="none"
              value="0"
              c:identifier="G_DBUS_MESSAGE_FLAGS_NONE"
              glib:nick="none"/>
      <member name="no_reply_expected"
              value="1"
              c:identifier="G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED"
              glib:nick="no-reply-expected"/>
      <member name="no_auto_start"
              value="2"
              c:identifier="G_DBUS_MESSAGE_FLAGS_NO_AUTO_START"
              glib:nick="no-auto-start"/>
    </bitfield>
    <enumeration name="DBusMessageHeaderField"
                 version="2.26"
                 glib:type-name="GDBusMessageHeaderField"
                 glib:get-type="g_dbus_message_header_field_get_type"
                 c:type="GDBusMessageHeaderField">
      <doc xml:whitespace="preserve">Header fields used in #GDBusMessage.</doc>
      <member name="invalid"
              value="0"
              c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_INVALID"
              glib:nick="invalid"/>
      <member name="path"
              value="1"
              c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_PATH"
              glib:nick="path"/>
      <member name="interface"
              value="2"
              c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE"
              glib:nick="interface"/>
      <member name="member"
              value="3"
              c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_MEMBER"
              glib:nick="member"/>
      <member name="error_name"
              value="4"
              c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME"
              glib:nick="error-name"/>
      <member name="reply_serial"
              value="5"
              c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL"
              glib:nick="reply-serial"/>
      <member name="destination"
              value="6"
              c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION"
              glib:nick="destination"/>
      <member name="sender"
              value="7"
              c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_SENDER"
              glib:nick="sender"/>
      <member name="signature"
              value="8"
              c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE"
              glib:nick="signature"/>
      <member name="num_unix_fds"
              value="9"
              c:identifier="G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS"
              glib:nick="num-unix-fds"/>
    </enumeration>
    <enumeration name="DBusMessageType"
                 version="2.26"
                 glib:type-name="GDBusMessageType"
                 glib:get-type="g_dbus_message_type_get_type"
                 c:type="GDBusMessageType">
      <doc xml:whitespace="preserve">Message types used in #GDBusMessage.</doc>
      <member name="invalid"
              value="0"
              c:identifier="G_DBUS_MESSAGE_TYPE_INVALID"
              glib:nick="invalid"/>
      <member name="method_call"
              value="1"
              c:identifier="G_DBUS_MESSAGE_TYPE_METHOD_CALL"
              glib:nick="method-call"/>
      <member name="method_return"
              value="2"
              c:identifier="G_DBUS_MESSAGE_TYPE_METHOD_RETURN"
              glib:nick="method-return"/>
      <member name="error"
              value="3"
              c:identifier="G_DBUS_MESSAGE_TYPE_ERROR"
              glib:nick="error"/>
      <member name="signal"
              value="4"
              c:identifier="G_DBUS_MESSAGE_TYPE_SIGNAL"
              glib:nick="signal"/>
    </enumeration>
    <record name="DBusMethodInfo"
            c:type="GDBusMethodInfo"
            version="2.26"
            glib:type-name="GDBusMethodInfo"
            glib:get-type="g_dbus_method_info_get_type"
            c:symbol-prefix="dbus_method_info">
      <doc xml:whitespace="preserve">Information about a method on an D-Bus interface.</doc>
      <field name="ref_count" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="in_args" writable="1">
        <type name="DBusArgInfo" c:type="GDBusArgInfo**"/>
      </field>
      <field name="out_args" writable="1">
        <type name="DBusArgInfo" c:type="GDBusArgInfo**"/>
      </field>
      <field name="annotations" writable="1">
        <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo**"/>
      </field>
      <method name="ref" c:identifier="g_dbus_method_info_ref" version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The same @info.</doc>
          <type name="DBusMethodInfo" c:type="GDBusMethodInfo*"/>
        </return-value>
      </method>
      <method name="unref"
              c:identifier="g_dbus_method_info_unref"
              version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <class name="DBusMethodInvocation"
           c:symbol-prefix="dbus_method_invocation"
           c:type="GDBusMethodInvocation"
           version="2.26"
           parent="GObject.Object"
           glib:type-name="GDBusMethodInvocation"
           glib:get-type="g_dbus_method_invocation_get_type">
      <doc xml:whitespace="preserve">The #GDBusMethodInvocation structure contains only private data and
should only be accessed using the provided API.</doc>
      <method name="get_connection"
              c:identifier="g_dbus_method_invocation_get_connection"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the #GDBusConnection the method was invoked on.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection. Do not free, it is owned by @invocation.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
      </method>
      <method name="get_interface_name"
              c:identifier="g_dbus_method_invocation_get_interface_name"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the name of the D-Bus interface the method was invoked on.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A string. Do not free, it is owned by @invocation.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_message"
              c:identifier="g_dbus_method_invocation_get_message"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the #GDBusMessage for the method invocation. This is useful if
you need to use low-level protocol features, such as UNIX file
descriptor passing, that cannot be properly expressed in the
#GVariant API.
See &lt;xref linkend="gdbus-server"/&gt; and &lt;xref
linkend="gdbus-unix-fd-client"/&gt; for an example of how to use this
low-level API to send and receive UNIX file descriptors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GDBusMessage. Do not free, it is owned by @invocation.</doc>
          <type name="DBusMessage" c:type="GDBusMessage*"/>
        </return-value>
      </method>
      <method name="get_method_info"
              c:identifier="g_dbus_method_invocation_get_method_info"
              version="2.26">
        <doc xml:whitespace="preserve">Gets information about the method call, if any.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusMethodInfo or %NULL. Do not free, it is owned by @invocation.</doc>
          <type name="DBusMethodInfo" c:type="GDBusMethodInfo*"/>
        </return-value>
      </method>
      <method name="get_method_name"
              c:identifier="g_dbus_method_invocation_get_method_name"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the name of the method that was invoked.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A string. Do not free, it is owned by @invocation.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_object_path"
              c:identifier="g_dbus_method_invocation_get_object_path"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the object path the method was invoked on.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A string. Do not free, it is owned by @invocation.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_parameters"
              c:identifier="g_dbus_method_invocation_get_parameters"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the parameters of the method invocation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GVariant. Do not free, it is owned by @invocation.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="get_sender"
              c:identifier="g_dbus_method_invocation_get_sender"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the bus name that invoked the method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A string. Do not free, it is owned by @invocation.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_user_data"
              c:identifier="g_dbus_method_invocation_get_user_data"
              version="2.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets the @user_data #gpointer passed to g_dbus_connection_register_object().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A #gpointer.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="return_dbus_error"
              c:identifier="g_dbus_method_invocation_return_dbus_error"
              version="2.26">
        <doc xml:whitespace="preserve">Finishes handling a D-Bus method call by returning an error.
This method will free @invocation, you cannot use it afterwards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid D-Bus error name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="error_message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A valid D-Bus error message.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_error"
              c:identifier="g_dbus_method_invocation_return_error"
              version="2.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Finishes handling a D-Bus method call by returning an error.
See g_dbus_error_encode_gerror() for details about what error name
will be returned on the wire. In a nutshell, if the given error is
registered using g_dbus_error_register_error() the name given
during registration is used. Otherwise, a name of the form
&lt;literal&gt;org.gtk.GDBus.UnmappedGError.Quark...&lt;/literal&gt; is
used. This provides transparent mapping of #GError between
applications using GDBus.
If you are writing an application intended to be portable,
&lt;emphasis&gt;always&lt;/emphasis&gt; register errors with g_dbus_error_register_error()
or use g_dbus_method_invocation_return_dbus_error().
This method will free @invocation, you cannot use it afterwards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GQuark for the #GError error domain.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">The error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">printf()-style format.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="return_error_literal"
              c:identifier="g_dbus_method_invocation_return_error_literal"
              version="2.26">
        <doc xml:whitespace="preserve">Like g_dbus_method_invocation_return_error() but without printf()-style formatting.
This method will free @invocation, you cannot use it afterwards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GQuark for the #GError error domain.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">The error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">The error message.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_error_valist"
              c:identifier="g_dbus_method_invocation_return_error_valist"
              version="2.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Like g_dbus_method_invocation_return_error() but intended for
language bindings.
This method will free @invocation, you cannot use it afterwards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GQuark for the #GError error domain.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">The error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">printf()-style format.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">#va_list of parameters for @format.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_gerror"
              c:identifier="g_dbus_method_invocation_return_gerror"
              version="2.26">
        <doc xml:whitespace="preserve">Like g_dbus_method_invocation_return_error() but takes a #GError
instead of the error domain, error code and message.
This method will free @invocation, you cannot use it afterwards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GError.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="return_value"
              c:identifier="g_dbus_method_invocation_return_value"
              version="2.26">
        <doc xml:whitespace="preserve">Finishes handling a D-Bus method call by returning @parameters.
If the @parameters GVariant is floating, it is consumed.
It is an error if @parameters is not of the right format.
This method will free @invocation, you cannot use it afterwards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GVariant tuple with out parameters for the method or %NULL if not passing any parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="DBusNodeInfo"
            c:type="GDBusNodeInfo"
            version="2.26"
            glib:type-name="GDBusNodeInfo"
            glib:get-type="g_dbus_node_info_get_type"
            c:symbol-prefix="dbus_node_info">
      <doc xml:whitespace="preserve">Information about nodes in a remote object hierarchy.</doc>
      <field name="ref_count" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="path" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="interfaces" writable="1">
        <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo**"/>
      </field>
      <field name="nodes" writable="1">
        <type name="DBusNodeInfo" c:type="GDBusNodeInfo**"/>
      </field>
      <field name="annotations" writable="1">
        <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo**"/>
      </field>
      <constructor name="new_for_xml"
                   c:identifier="g_dbus_node_info_new_for_xml"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">Parses @xml_data and returns a #GDBusNodeInfo representing the data.
with g_dbus_node_info_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusNodeInfo structure or %NULL if @error is set. Free</doc>
          <type name="DBusNodeInfo" c:type="GDBusNodeInfo*"/>
        </return-value>
        <parameters>
          <parameter name="xml_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Valid D-Bus introspection XML.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="generate_xml"
              c:identifier="g_dbus_node_info_generate_xml"
              version="2.26">
        <doc xml:whitespace="preserve">Appends an XML representation of @info (and its children) to @string_builder.
This function is typically used for generating introspection XML documents at run-time for
handling the &lt;literal&gt;org.freedesktop.DBus.Introspectable.Introspect&lt;/literal&gt; method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="indent" transfer-ownership="none">
            <doc xml:whitespace="preserve">Indentation level.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="string_builder" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GString to to append XML data to.</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_interface"
              c:identifier="g_dbus_node_info_lookup_interface"
              version="2.26">
        <doc xml:whitespace="preserve">Looks up information about an interface.
This cost of this function is O(n) in number of interfaces.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusInterfaceInfo or %NULL if not found. Do not free, it is owned by @info.</doc>
          <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_dbus_node_info_ref" version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The same @info.</doc>
          <type name="DBusNodeInfo" c:type="GDBusNodeInfo*"/>
        </return-value>
      </method>
      <method name="unref"
              c:identifier="g_dbus_node_info_unref"
              version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="DBusPropertyInfo"
            c:type="GDBusPropertyInfo"
            version="2.26"
            glib:type-name="GDBusPropertyInfo"
            glib:get-type="g_dbus_property_info_get_type"
            c:symbol-prefix="dbus_property_info">
      <doc xml:whitespace="preserve">Information about a D-Bus property on a D-Bus interface.</doc>
      <field name="ref_count" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="signature" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="flags" writable="1">
        <type name="DBusPropertyInfoFlags" c:type="GDBusPropertyInfoFlags"/>
      </field>
      <field name="annotations" writable="1">
        <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo**"/>
      </field>
      <method name="ref"
              c:identifier="g_dbus_property_info_ref"
              version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The same @info.</doc>
          <type name="DBusPropertyInfo" c:type="GDBusPropertyInfo*"/>
        </return-value>
      </method>
      <method name="unref"
              c:identifier="g_dbus_property_info_unref"
              version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <bitfield name="DBusPropertyInfoFlags"
              version="2.26"
              glib:type-name="GDBusPropertyInfoFlags"
              glib:get-type="g_dbus_property_info_flags_get_type"
              c:type="GDBusPropertyInfoFlags">
      <doc xml:whitespace="preserve">Flags describing the access control of a D-Bus property.</doc>
      <member name="none"
              value="0"
              c:identifier="G_DBUS_PROPERTY_INFO_FLAGS_NONE"
              glib:nick="none"/>
      <member name="readable"
              value="1"
              c:identifier="G_DBUS_PROPERTY_INFO_FLAGS_READABLE"
              glib:nick="readable"/>
      <member name="writable"
              value="2"
              c:identifier="G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE"
              glib:nick="writable"/>
    </bitfield>
    <class name="DBusProxy"
           c:symbol-prefix="dbus_proxy"
           c:type="GDBusProxy"
           version="2.26"
           parent="GObject.Object"
           glib:type-name="GDBusProxy"
           glib:get-type="g_dbus_proxy_get_type"
           glib:type-struct="DBusProxyClass">
      <doc xml:whitespace="preserve">The #GDBusProxy structure contains only private data and
should only be accessed using the provided API.</doc>
      <implements name="AsyncInitable"/>
      <implements name="Initable"/>
      <constructor name="new_finish"
                   c:identifier="g_dbus_proxy_new_finish"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">Finishes creating a #GDBusProxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusProxy or %NULL if @error is set. Free with g_object_unref().</doc>
          <type name="DBusProxy" c:type="GDBusProxy*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_bus_finish"
                   c:identifier="g_dbus_proxy_new_for_bus_finish"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">Finishes creating a #GDBusProxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusProxy or %NULL if @error is set. Free with g_object_unref().</doc>
          <type name="DBusProxy" c:type="GDBusProxy*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback function passed to g_dbus_proxy_new_for_bus().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_bus_sync"
                   c:identifier="g_dbus_proxy_new_for_bus_sync"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">Like g_dbus_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
See &lt;xref linkend="gdbus-wellknown-proxy"/&gt; for an example of how #GDBusProxy can be used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusProxy or %NULL if error is set. Free with g_object_unref().</doc>
          <type name="DBusProxy" c:type="GDBusProxy*"/>
        </return-value>
        <parameters>
          <parameter name="bus_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GBusType.</doc>
            <type name="BusType" c:type="GBusType"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags used when constructing the proxy.</doc>
            <type name="DBusProxyFlags" c:type="GDBusProxyFlags"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusInterfaceInfo specifying the minimal interface that @proxy conforms to or %NULL.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A bus name (well-known or unique).</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object path.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sync"
                   c:identifier="g_dbus_proxy_new_sync"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">Creates a proxy for accessing @interface_name on the remote object
at @object_path owned by @name at @connection and synchronously
loads D-Bus properties unless the
%G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.
If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
match rules for signals. Connect to the #GDBusProxy::g-signal signal
to handle signals from the remote object.
If @name is a well-known name and the
%G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START flag isn't set and no name
owner currently exists, the message bus will be requested to launch
a name owner for the name.
This is a synchronous failable constructor. See g_dbus_proxy_new()
and g_dbus_proxy_new_finish() for the asynchronous version.
See &lt;xref linkend="gdbus-wellknown-proxy"/&gt; for an example of how #GDBusProxy can be used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusProxy or %NULL if error is set. Free with g_object_unref().</doc>
          <type name="DBusProxy" c:type="GDBusProxy*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags used when constructing the proxy.</doc>
            <type name="DBusProxyFlags" c:type="GDBusProxyFlags"/>
          </parameter>
          <parameter name="info" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">A #GDBusInterfaceInfo specifying the minimal interface that @proxy conforms to or %NULL.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object path.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new" c:identifier="g_dbus_proxy_new" version="2.26">
        <doc xml:whitespace="preserve">Creates a proxy for accessing @interface_name on the remote object
at @object_path owned by @name at @connection and asynchronously
loads D-Bus properties unless the
%G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to
the #GDBusProxy::g-properties-changed signal to get notified about
property changes.
If the %G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up
match rules for signals. Connect to the #GDBusProxy::g-signal signal
to handle signals from the remote object.
If @name is a well-known name and the
%G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START flag isn't set and no name
owner currently exists, the message bus will be requested to launch
a name owner for the name.
This is a failable asynchronous constructor - when the proxy is
ready, @callback will be invoked and you can use
g_dbus_proxy_new_finish() to get the result.
See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.
See &lt;xref linkend="gdbus-wellknown-proxy"/&gt; for an example of how #GDBusProxy can be used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
            <type name="DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags used when constructing the proxy.</doc>
            <type name="DBusProxyFlags" c:type="GDBusProxyFlags"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusInterfaceInfo specifying the minimal interface that @proxy conforms to or %NULL.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object path.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="8">
            <doc xml:whitespace="preserve">Callback function to invoke when the proxy is ready.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">User data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_bus"
                c:identifier="g_dbus_proxy_new_for_bus"
                version="2.26">
        <doc xml:whitespace="preserve">Like g_dbus_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
See &lt;xref linkend="gdbus-wellknown-proxy"/&gt; for an example of how #GDBusProxy can be used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bus_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GBusType.</doc>
            <type name="BusType" c:type="GBusType"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags used when constructing the proxy.</doc>
            <type name="DBusProxyFlags" c:type="GDBusProxyFlags"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusInterfaceInfo specifying the minimal interface that @proxy conforms to or %NULL.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A bus name (well-known or unique).</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object path.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="interface_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus interface name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="8">
            <doc xml:whitespace="preserve">Callback function to invoke when the proxy is ready.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">User data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="call" c:identifier="g_dbus_proxy_call" version="2.26">
        <doc xml:whitespace="preserve">Asynchronously invokes the @method_name method on @proxy.
If @method_name contains any dots, then @name is split into interface and
method name parts. This allows using @proxy for invoking methods on
other interfaces.
If the #GDBusConnection associated with @proxy is closed then
the operation will fail with %G_IO_ERROR_CLOSED. If
%G_IO_ERROR_CANCELLED. If @parameters contains a value not
compatible with the D-Bus protocol, the operation fails with
%G_IO_ERROR_INVALID_ARGUMENT.
If the @parameters #GVariant is floating, it is consumed. This allows
convenient 'inline' use of g_variant_new(), e.g.:
|[
g_dbus_proxy_call (proxy,
"TwoStrings",
g_variant_new ("(ss)",
"Thing One",
"Thing Two"),
G_DBUS_CALL_FLAGS_NONE,
-1,
NULL,
(GAsyncReadyCallback) two_strings_done,
&amp;amp;data);
]|
This is an asynchronous method. When the operation is finished,
&lt;link linkend="g-main-context-push-thread-default"&gt;thread-default
main loop&lt;/link&gt; of the thread you are calling this method from.
You can then call g_dbus_proxy_call_finish() to get the result of
the operation. See g_dbus_proxy_call_sync() for the synchronous
version of this method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">Name of method to invoke.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags from the #GDBusCallFlags enumeration.</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:whitespace="preserve">The timeout in milliseconds or -1 to use the proxy default timeout.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="6">
            <doc xml:whitespace="preserve">A #GAsyncReadyCallback to call when the request is satisfied or %NULL if you don't care about the result of the method invocation.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">The data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_finish"
              c:identifier="g_dbus_proxy_call_finish"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an operation started with g_dbus_proxy_call().
return values. Free with g_variant_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_dbus_proxy_call().</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_sync"
              c:identifier="g_dbus_proxy_call_sync"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Synchronously invokes the @method_name method on @proxy.
If @method_name contains any dots, then @name is split into interface and
method name parts. This allows using @proxy for invoking methods on
other interfaces.
If the #GDBusConnection associated with @proxy is disconnected then
the operation will fail with %G_IO_ERROR_CLOSED. If
%G_IO_ERROR_CANCELLED. If @parameters contains a value not
compatible with the D-Bus protocol, the operation fails with
%G_IO_ERROR_INVALID_ARGUMENT.
If the @parameters #GVariant is floating, it is consumed. This allows
convenient 'inline' use of g_variant_new(), e.g.:
|[
g_dbus_proxy_call_sync (proxy,
"TwoStrings",
g_variant_new ("(ss)",
"Thing One",
"Thing Two"),
G_DBUS_CALL_FLAGS_NONE,
-1,
NULL,
&amp;amp;error);
]|
The calling thread is blocked until a reply is received. See
g_dbus_proxy_call() for the asynchronous version of this
method.
return values. Free with g_variant_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">%NULL if @error is set. Otherwise a #GVariant tuple with</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="method_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">Name of method to invoke.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GVariant tuple with parameters for the signal or %NULL if not passing parameters.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags from the #GDBusCallFlags enumeration.</doc>
            <type name="DBusCallFlags" c:type="GDBusCallFlags"/>
          </parameter>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:whitespace="preserve">The timeout in milliseconds or -1 to use the proxy default timeout.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cached_property"
              c:identifier="g_dbus_proxy_get_cached_property"
              version="2.26">
        <doc xml:whitespace="preserve">Looks up the value for a property from the cache. This call does no
blocking IO.
If @proxy has an expected interface (see
#GDBusProxy:g-interface-info), then @property_name (for existence)
is checked against it.
for @property_name or %NULL if the value is not in the cache. The
returned reference must be freed with g_variant_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A reference to the #GVariant instance that holds the value</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">Property name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cached_property_names"
              c:identifier="g_dbus_proxy_get_cached_property_names"
              version="2.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets the names of all cached properties on @proxy.
no cached properties. Free the returned array with g_strfreev().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A %NULL-terminated array of strings or %NULL if @proxy has</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_connection"
              c:identifier="g_dbus_proxy_get_connection"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the connection @proxy is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection owned by @proxy. Do not free.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
      </method>
      <method name="get_default_timeout"
              c:identifier="g_dbus_proxy_get_default_timeout"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the timeout to use if -1 (specifying default timeout) is
passed as @timeout_msec in the g_dbus_proxy_call() and
g_dbus_proxy_call_sync() functions.
See the #GDBusProxy:g-default-timeout property for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Timeout to use for @proxy.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_flags"
              c:identifier="g_dbus_proxy_get_flags"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the flags that @proxy was constructed with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags from the #GDBusProxyFlags enumeration.</doc>
          <type name="DBusProxyFlags" c:type="GDBusProxyFlags"/>
        </return-value>
      </method>
      <method name="get_interface_info"
              c:identifier="g_dbus_proxy_get_interface_info"
              version="2.26">
        <doc xml:whitespace="preserve">Returns the #GDBusInterfaceInfo, if any, specifying the minimal
interface that @proxy conforms to.
See the #GDBusProxy:g-interface-info property for more details.
object, it is owned by @proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusInterfaceInfo or %NULL. Do not unref the returned</doc>
          <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
        </return-value>
      </method>
      <method name="get_interface_name"
              c:identifier="g_dbus_proxy_get_interface_name"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the D-Bus interface name @proxy is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A string owned by @proxy. Do not free.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_name"
              c:identifier="g_dbus_proxy_get_name"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the name that @proxy was constructed for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A string owned by @proxy. Do not free.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_name_owner"
              c:identifier="g_dbus_proxy_get_name_owner"
              version="2.26">
        <doc xml:whitespace="preserve">The unique name that owns the name that @proxy is for or %NULL if
no-one currently owns that name. You may connect to the
#GObject::notify signal to track changes to the
#GDBusProxy:g-name-owner property.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The name owner or %NULL if no name owner exists. Free with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_object_path"
              c:identifier="g_dbus_proxy_get_object_path"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the object path @proxy is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A string owned by @proxy. Do not free.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="set_cached_property"
              c:identifier="g_dbus_proxy_set_cached_property"
              version="2.26">
        <doc xml:whitespace="preserve">If @value is not %NULL, sets the cached value for the property with
name @property_name to the value in @value.
If @value is %NULL, then the cached value is removed from the
property cache.
If @proxy has an expected interface (see
#GDBusProxy:g-interface-info), then @property_name (for existence)
and @value (for the type) is checked against it.
If the @value #GVariant is floating, it is consumed. This allows
convenient 'inline' use of g_variant_new(), e.g.
|[
g_dbus_proxy_set_cached_property (proxy,
"SomeProperty",
g_variant_new ("(si)",
"A String",
42));
]|
Normally you will not need to use this method since @proxy is
tracking changes using the
&lt;literal&gt;org.freedesktop.DBus.Properties.PropertiesChanged&lt;/literal&gt;
D-Bus signal. However, for performance reasons an object may decide
to not use this signal for some properties and instead use a
proprietary out-of-band mechanism to transmit changes.
As a concrete example, consider an object with a property
&lt;literal&gt;ChatroomParticipants&lt;/literal&gt; which is an array of
strings. Instead of transmitting the same (long) array every time
the property changes, it is more efficient to only transmit the
delta using e.g. signals &lt;literal&gt;ChatroomParticipantJoined(String
name)&lt;/literal&gt; and &lt;literal&gt;ChatroomParticipantParted(String
name)&lt;/literal&gt;.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">Property name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value for the property or %NULL to remove it from the cache.</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default_timeout"
              c:identifier="g_dbus_proxy_set_default_timeout"
              version="2.26">
        <doc xml:whitespace="preserve">Sets the timeout to use if -1 (specifying default timeout) is
passed as @timeout_msec in the g_dbus_proxy_call() and
g_dbus_proxy_call_sync() functions.
See the #GDBusProxy:g-default-timeout property for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_msec" transfer-ownership="none">
            <doc xml:whitespace="preserve">Timeout in milliseconds.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_interface_info"
              c:identifier="g_dbus_proxy_set_interface_info"
              version="2.26">
        <doc xml:whitespace="preserve">Ensure that interactions with @proxy conform to the given
interface.  For example, when completing a method call, if the type
signature of the message isn't what's expected, the given #GError
is set.  Signals that have a type signature mismatch are simply
dropped.
See the #GDBusProxy:g-interface-info property for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">Minimum interface this proxy conforms to or %NULL to unset.</doc>
            <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo*"/>
          </parameter>
        </parameters>
      </method>
      <property name="g-bus-type"
                version="2.26"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this property is not %G_BUS_TYPE_NONE, then
#GDBusProxy:g-connection must be %NULL and will be set to the
#GDBusConnection obtained by calling g_bus_get() with the value
of this property.</doc>
        <type name="BusType"/>
      </property>
      <property name="g-connection"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GDBusConnection the proxy is for.</doc>
        <type name="DBusConnection"/>
      </property>
      <property name="g-default-timeout"
                version="2.26"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The timeout to use if -1 (specifying default timeout) is passed
as @timeout_msec in the g_dbus_proxy_call() and
g_dbus_proxy_call_sync() functions.
This allows applications to set a proxy-wide timeout for all
remote method invocations on the proxy. If this property is -1,
the default timeout (typically 25 seconds) is used. If set to
%G_MAXINT, then no timeout is used.</doc>
        <type name="gint"/>
      </property>
      <property name="g-flags"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags from the #GDBusProxyFlags enumeration.</doc>
        <type name="DBusProxyFlags"/>
      </property>
      <property name="g-interface-info"
                version="2.26"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Ensure that interactions with this proxy conform to the given
interface.  For example, when completing a method call, if the
type signature of the message isn't what's expected, the given
#GError is set.  Signals that have a type signature mismatch are
simply dropped.</doc>
        <type name="DBusInterfaceInfo"/>
      </property>
      <property name="g-interface-name"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus interface name the proxy is for.</doc>
        <type name="utf8"/>
      </property>
      <property name="g-name"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The well-known or unique name that the proxy is for.</doc>
        <type name="utf8"/>
      </property>
      <property name="g-name-owner" version="2.26" transfer-ownership="none">
        <doc xml:whitespace="preserve">The unique name that owns #GDBusProxy:name or %NULL if no-one
currently owns that name. You may connect to #GObject::notify signal to
track changes to this property.</doc>
        <type name="utf8"/>
      </property>
      <property name="g-object-path"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The object path the proxy is for.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="DBusProxyPrivate" c:type="GDBusProxyPrivate*"/>
      </field>
      <glib:signal name="g-properties-changed"
                   version="2.26"
                   introspectable="0">
        <doc xml:whitespace="preserve">Emitted when one or more D-Bus properties on @proxy changes. The
local cache has already been updated when this signal fires. Note
that both @changed_properties and @invalidated_properties are
guaranteed to never be %NULL (either may be empty though).
This signal corresponds to the
&lt;literal&gt;PropertiesChanged&lt;/literal&gt; D-Bus signal on the
&lt;literal&gt;org.freedesktop.DBus.Properties&lt;/literal&gt; interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GVariant containing the properties that changed</doc>
            <type name="GLib.Variant"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">A %NULL terminated array of properties that was invalidated</doc>
            <type/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="g-signal" version="2.26">
        <doc xml:whitespace="preserve">Emitted when a signal from the remote object and interface that @proxy is for, has been received.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">The sender of the signal or %NULL if the connection is not a bus connection.</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the signal.</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GVariant tuple with parameters for the signal.</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DBusProxyClass"
            c:type="GDBusProxyClass"
            glib:is-gtype-struct-for="DBusProxy"
            version="2.26">
      <doc xml:whitespace="preserve">Class structure for #GDBusProxy.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="g_properties_changed">
        <callback name="g_properties_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="DBusProxy" c:type="GDBusProxy*"/>
            </parameter>
            <parameter name="changed_properties" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="invalidated_properties" transfer-ownership="none">
              <type name="utf8" c:type="gchar**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="g_signal">
        <callback name="g_signal">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="DBusProxy" c:type="GDBusProxy*"/>
            </parameter>
            <parameter name="sender_name" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="signal_name" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="parameters" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="gpointer" fixed-size="32">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="DBusProxyFlags"
              version="2.26"
              glib:type-name="GDBusProxyFlags"
              glib:get-type="g_dbus_proxy_flags_get_type"
              c:type="GDBusProxyFlags">
      <doc xml:whitespace="preserve">Flags used when constructing an instance of a #GDBusProxy derived class.</doc>
      <member name="none"
              value="0"
              c:identifier="G_DBUS_PROXY_FLAGS_NONE"
              glib:nick="none"/>
      <member name="do_not_load_properties"
              value="1"
              c:identifier="G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES"
              glib:nick="do-not-load-properties"/>
      <member name="do_not_connect_signals"
              value="2"
              c:identifier="G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS"
              glib:nick="do-not-connect-signals"/>
      <member name="do_not_auto_start"
              value="4"
              c:identifier="G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START"
              glib:nick="do-not-auto-start"/>
    </bitfield>
    <record name="DBusProxyPrivate" c:type="GDBusProxyPrivate" disguised="1">
    </record>
    <bitfield name="DBusSendMessageFlags"
              version="2.26"
              glib:type-name="GDBusSendMessageFlags"
              glib:get-type="g_dbus_send_message_flags_get_type"
              c:type="GDBusSendMessageFlags">
      <doc xml:whitespace="preserve">Flags used when sending #GDBusMessage&lt;!-- --&gt;s on a #GDBusConnection.</doc>
      <member name="none"
              value="0"
              c:identifier="G_DBUS_SEND_MESSAGE_FLAGS_NONE"
              glib:nick="none"/>
      <member name="preserve_serial"
              value="1"
              c:identifier="G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL"
              glib:nick="preserve-serial"/>
    </bitfield>
    <class name="DBusServer"
           c:symbol-prefix="dbus_server"
           c:type="GDBusServer"
           version="2.26"
           parent="GObject.Object"
           glib:type-name="GDBusServer"
           glib:get-type="g_dbus_server_get_type">
      <doc xml:whitespace="preserve">The #GDBusServer structure contains only private data and
should only be accessed using the provided API.</doc>
      <implements name="Initable"/>
      <constructor name="new_sync"
                   c:identifier="g_dbus_server_new_sync"
                   version="2.26"
                   throws="1">
        <doc xml:whitespace="preserve">Creates a new D-Bus server that listens on the first address in
Once constructed, you can use g_dbus_server_get_client_address() to
get a D-Bus address string that clients can use to connect.
Connect to the #GDBusServer::new-connection signal to handle
incoming connections.
The returned #GDBusServer isn't active - you have to start it with
g_dbus_server_start().
See &lt;xref linkend="gdbus-peer-to-peer"/&gt; for how #GDBusServer can
be used.
This is a synchronous failable constructor. See
g_dbus_server_new() for the asynchronous version.
g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GDBusServer or %NULL if @error is set. Free with</doc>
          <type name="DBusServer" c:type="GDBusServer*"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus address.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags from the #GDBusServerFlags enumeration.</doc>
            <type name="DBusServerFlags" c:type="GDBusServerFlags"/>
          </parameter>
          <parameter name="guid" transfer-ownership="none">
            <doc xml:whitespace="preserve">A D-Bus GUID.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="observer" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusAuthObserver or %NULL.</doc>
            <type name="DBusAuthObserver" c:type="GDBusAuthObserver*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_client_address"
              c:identifier="g_dbus_server_get_client_address"
              version="2.26">
        <doc xml:whitespace="preserve">Gets a D-Bus address string that can be used by clients to connect
to @server.
by @server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A D-Bus address string. Do not free, the string is owned</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_flags"
              c:identifier="g_dbus_server_get_flags"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the flags for @server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of flags from the #GDBusServerFlags enumeration.</doc>
          <type name="DBusServerFlags" c:type="GDBusServerFlags"/>
        </return-value>
      </method>
      <method name="get_guid"
              c:identifier="g_dbus_server_get_guid"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the GUID for @server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A D-Bus GUID. Do not free this string, it is owned by @server.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="is_active"
              c:identifier="g_dbus_server_is_active"
              version="2.26">
        <doc xml:whitespace="preserve">Gets whether @server is active.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if server is active, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="start" c:identifier="g_dbus_server_start" version="2.26">
        <doc xml:whitespace="preserve">Starts @server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="stop" c:identifier="g_dbus_server_stop" version="2.26">
        <doc xml:whitespace="preserve">Stops @server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <property name="active" version="2.26" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the server is currently active.</doc>
        <type name="gboolean"/>
      </property>
      <property name="address"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus address to listen on.</doc>
        <type name="utf8"/>
      </property>
      <property name="authentication-observer"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GDBusAuthObserver object to assist in the authentication process or %NULL.</doc>
        <type name="DBusAuthObserver"/>
      </property>
      <property name="client-address" version="2.26" transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus address that clients can use.</doc>
        <type name="utf8"/>
      </property>
      <property name="flags"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags from the #GDBusServerFlags enumeration.</doc>
        <type name="DBusServerFlags"/>
      </property>
      <property name="guid"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The guid of the server.</doc>
        <type name="utf8"/>
      </property>
      <glib:signal name="new-connection" version="2.26">
        <doc xml:whitespace="preserve">Emitted when a new authenticated connection has been made. Use
g_dbus_connection_get_peer_credentials() to figure out what
identity (if any), was authenticated.
If you want to accept the connection, take a reference to the
connection call g_dbus_connection_close() and give up your
reference. Note that the other peer may disconnect at any time -
a typical thing to do when accepting a connection is to listen to
the #GDBusConnection::closed signal.
If #GDBusServer:flags contains %G_DBUS_SERVER_FLAGS_RUN_IN_THREAD
then the signal is emitted in a new thread dedicated to the
connection. Otherwise the signal is emitted in the &lt;link
linkend="g-main-context-push-thread-default"&gt;thread-default main
loop&lt;/link&gt; of the thread that @server was constructed in.
You are guaranteed that signal handlers for this signal runs
before incoming messages on @connection are processed. This means
that it's suitable to call g_dbus_connection_register_object() or
similar from the signal handler.
run.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE to claim @connection, %FALSE to let other handlers</doc>
          <type name="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GDBusConnection for the new connection.</doc>
            <type name="DBusConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="DBusServerFlags"
              version="2.26"
              glib:type-name="GDBusServerFlags"
              glib:get-type="g_dbus_server_flags_get_type"
              c:type="GDBusServerFlags">
      <doc xml:whitespace="preserve">Flags used when creating a #GDBusServer.</doc>
      <member name="none"
              value="0"
              c:identifier="G_DBUS_SERVER_FLAGS_NONE"
              glib:nick="none"/>
      <member name="run_in_thread"
              value="1"
              c:identifier="G_DBUS_SERVER_FLAGS_RUN_IN_THREAD"
              glib:nick="run-in-thread"/>
      <member name="authentication_allow_anonymous"
              value="2"
              c:identifier="G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS"
              glib:nick="authentication-allow-anonymous"/>
    </bitfield>
    <callback name="DBusSignalCallback"
              c:type="GDBusSignalCallback"
              version="2.26">
      <doc xml:whitespace="preserve">Signature for callback function used in g_dbus_connection_signal_subscribe().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique bus name of the sender of the signal.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:whitespace="preserve">The object path that the signal was emitted on.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the interface.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the signal.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="parameters" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GVariant tuple with parameters for the signal.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">User data passed when subscribing to the signal.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="DBusSignalFlags"
              version="2.26"
              glib:type-name="GDBusSignalFlags"
              glib:get-type="g_dbus_signal_flags_get_type"
              c:type="GDBusSignalFlags">
      <doc xml:whitespace="preserve">Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().</doc>
      <member name="none"
              value="0"
              c:identifier="G_DBUS_SIGNAL_FLAGS_NONE"
              glib:nick="none"/>
    </bitfield>
    <record name="DBusSignalInfo"
            c:type="GDBusSignalInfo"
            version="2.26"
            glib:type-name="GDBusSignalInfo"
            glib:get-type="g_dbus_signal_info_get_type"
            c:symbol-prefix="dbus_signal_info">
      <doc xml:whitespace="preserve">Information about a signal on a D-Bus interface.</doc>
      <field name="ref_count" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="args" writable="1">
        <type name="DBusArgInfo" c:type="GDBusArgInfo**"/>
      </field>
      <field name="annotations" writable="1">
        <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo**"/>
      </field>
      <method name="ref" c:identifier="g_dbus_signal_info_ref" version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated does nothing. Otherwise increases
the reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The same @info.</doc>
          <type name="DBusSignalInfo" c:type="GDBusSignalInfo*"/>
        </return-value>
      </method>
      <method name="unref"
              c:identifier="g_dbus_signal_info_unref"
              version="2.26">
        <doc xml:whitespace="preserve">If @info is statically allocated, does nothing. Otherwise decreases
the reference count of @info. When its reference count drops to 0,
the memory used is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <callback name="DBusSubtreeDispatchFunc"
              c:type="GDBusSubtreeDispatchFunc"
              version="2.26">
      <doc xml:whitespace="preserve">The type of the @dispatch function in #GDBusSubtreeVTable.
Subtrees are flat.  @node, if non-%NULL, is always exactly one</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GDBusInterfaceVTable or %NULL if you don't want to handle the methods.</doc>
        <type name="DBusInterfaceVTable" c:type="GDBusInterfaceVTable*"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:whitespace="preserve">The object path that was registered with g_dbus_connection_register_subtree().</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus interface name that the method call or property access is for.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="node" transfer-ownership="none">
          <doc xml:whitespace="preserve">A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="out_user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Return location for user data to pass to functions in the returned #GDBusInterfaceVTable (never %NULL).</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">The @user_data #gpointer passed to g_dbus_connection_register_subtree().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DBusSubtreeEnumerateFunc"
              c:type="GDBusSubtreeEnumerateFunc"
              version="2.26"
              introspectable="0">
      <doc xml:whitespace="preserve">The type of the @enumerate function in #GDBusSubtreeVTable.
This function is called when generating introspection data and also
when preparing to dispatch incoming messages in the event that the
%G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not
Hierarchies are not supported; the items that you return should not
contain the '/' character.
The return value will be freed with g_strfreev().</doc>
      <return-value>
        <doc xml:whitespace="preserve">A newly allocated array of strings for node names that are children of @object_path.</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:whitespace="preserve">The object path that was registered with g_dbus_connection_register_subtree().</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">The @user_data #gpointer passed to g_dbus_connection_register_subtree().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="DBusSubtreeFlags"
              version="2.26"
              glib:type-name="GDBusSubtreeFlags"
              glib:get-type="g_dbus_subtree_flags_get_type"
              c:type="GDBusSubtreeFlags">
      <doc xml:whitespace="preserve">Flags passed to g_dbus_connection_register_subtree().</doc>
      <member name="none"
              value="0"
              c:identifier="G_DBUS_SUBTREE_FLAGS_NONE"
              glib:nick="none"/>
      <member name="dispatch_to_unenumerated_nodes"
              value="1"
              c:identifier="G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES"
              glib:nick="dispatch-to-unenumerated-nodes"/>
    </bitfield>
    <callback name="DBusSubtreeIntrospectFunc"
              c:type="GDBusSubtreeIntrospectFunc"
              version="2.26">
      <doc xml:whitespace="preserve">The type of the @introspect function in #GDBusSubtreeVTable.
Subtrees are flat.  @node, if non-%NULL, is always exactly one
This function should return %NULL to indicate that there is no object
at this node.
If this function returns non-%NULL, the return value is expected to
be a %NULL-terminated array of pointers to #GDBusInterfaceInfo
structures describing the interfaces implemented by @node.  This
array will have g_dbus_interface_info_unref() called on each item
before being freed with g_free().
The difference between returning %NULL and an array containing zero
items is that the standard DBus interfaces will returned to the
remote introspector in the empty array case, but not in the %NULL
case.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A %NULL-terminated array of pointers to #GDBusInterfaceInfo, or %NULL.</doc>
        <type name="DBusInterfaceInfo" c:type="GDBusInterfaceInfo**"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique bus name of the remote caller.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="object_path" transfer-ownership="none">
          <doc xml:whitespace="preserve">The object path that was registered with g_dbus_connection_register_subtree().</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="node" transfer-ownership="none">
          <doc xml:whitespace="preserve">A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:whitespace="preserve">The @user_data #gpointer passed to g_dbus_connection_register_subtree().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusSubtreeVTable"
            c:type="GDBusSubtreeVTable"
            version="2.26">
      <doc xml:whitespace="preserve">Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().</doc>
      <field name="enumerate" introspectable="0" writable="1">
        <type name="DBusSubtreeEnumerateFunc"
              c:type="GDBusSubtreeEnumerateFunc"/>
      </field>
      <field name="introspect" writable="1">
        <type name="DBusSubtreeIntrospectFunc"
              c:type="GDBusSubtreeIntrospectFunc"/>
      </field>
      <field name="dispatch" writable="1">
        <type name="DBusSubtreeDispatchFunc"
              c:type="GDBusSubtreeDispatchFunc"/>
      </field>
      <field name="padding" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <constant name="DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME"
              value="gio-desktop-app-info-lookup">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="DataInputStream"
           c:symbol-prefix="data_input_stream"
           c:type="GDataInputStream"
           parent="BufferedInputStream"
           glib:type-name="GDataInputStream"
           glib:get-type="g_data_input_stream_get_type"
           glib:type-struct="DataInputStreamClass">
      <doc xml:whitespace="preserve">An implementation of #GBufferedInputStream that allows for high-level
data manipulation of arbitrary data (including binary operations).</doc>
      <constructor name="new" c:identifier="g_data_input_stream_new">
        <doc xml:whitespace="preserve">Creates a new data input stream for the @base_stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GDataInputStream.</doc>
          <type name="DataInputStream" c:type="GDataInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_byte_order"
              c:identifier="g_data_input_stream_get_byte_order">
        <doc xml:whitespace="preserve">Gets the byte order for the data input stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the @stream's current #GDataStreamByteOrder.</doc>
          <type name="DataStreamByteOrder" c:type="GDataStreamByteOrder"/>
        </return-value>
      </method>
      <method name="get_newline_type"
              c:identifier="g_data_input_stream_get_newline_type">
        <doc xml:whitespace="preserve">Gets the current newline type for the @stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GDataStreamNewlineType for the given @stream.</doc>
          <type name="DataStreamNewlineType" c:type="GDataStreamNewlineType"/>
        </return-value>
      </method>
      <method name="read_byte"
              c:identifier="g_data_input_stream_read_byte"
              throws="1">
        <doc xml:whitespace="preserve">Reads an unsigned 8-bit/1-byte value from @stream.
if an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an unsigned 8-bit/1-byte value read from the @stream or %0</doc>
          <type name="guint8" c:type="guchar"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_int16"
              c:identifier="g_data_input_stream_read_int16"
              throws="1">
        <doc xml:whitespace="preserve">Reads a 16-bit/2-byte value from @stream.
In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a signed 16-bit/2-byte value read from @stream or %0 if</doc>
          <type name="gint16" c:type="gint16"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_int32"
              c:identifier="g_data_input_stream_read_int32"
              throws="1">
        <doc xml:whitespace="preserve">Reads a signed 32-bit/4-byte value from @stream.
In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a signed 32-bit/4-byte value read from the @stream or %0 if</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_int64"
              c:identifier="g_data_input_stream_read_int64"
              throws="1">
        <doc xml:whitespace="preserve">Reads a 64-bit/8-byte value from @stream.
In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a signed 64-bit/8-byte value read from @stream or %0 if</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_line"
              c:identifier="g_data_input_stream_read_line"
              throws="1">
        <doc xml:whitespace="preserve">Reads a line from the data input stream.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Set @length to a #gsize to get the length of the read line.
On an error, it will return %NULL and @error will be set. If there's no
content to read, it will still return %NULL, but @error won't be set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string with the line that was read in (without the newlines).</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize to get the length of the data read in.</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_line_async"
              c:identifier="g_data_input_stream_read_line_async"
              version="2.20">
        <doc xml:whitespace="preserve">The asynchronous version of g_data_input_stream_read_line().  It is
an error to have two outstanding calls to this function.
When the operation is finished, @callback will be called. You
can then call g_data_input_stream_read_line_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_line_finish"
              c:identifier="g_data_input_stream_read_line_finish"
              version="2.20"
              throws="1">
        <doc xml:whitespace="preserve">Finish an asynchronous call started by
g_data_input_stream_read_line_async().
Set @length to a #gsize to get the length of the read line.
On an error, it will return %NULL and @error will be set. If there's no
content to read, it will still return %NULL, but @error won't be set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string with the line that was read in (without the newlines).</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult that was provided to the callback.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize to get the length of the data read in.</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_uint16"
              c:identifier="g_data_input_stream_read_uint16"
              throws="1">
        <doc xml:whitespace="preserve">Reads an unsigned 16-bit/2-byte value from @stream.
In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an unsigned 16-bit/2-byte value read from the @stream or %0 if</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_uint32"
              c:identifier="g_data_input_stream_read_uint32"
              throws="1">
        <doc xml:whitespace="preserve">Reads an unsigned 32-bit/4-byte value from @stream.
In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an unsigned 32-bit/4-byte value read from the @stream or %0 if</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_uint64"
              c:identifier="g_data_input_stream_read_uint64"
              throws="1">
        <doc xml:whitespace="preserve">Reads an unsigned 64-bit/8-byte value from @stream.
In order to get the correct byte order for this read operation,
see g_data_input_stream_get_byte_order().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an unsigned 64-bit/8-byte read from @stream or %0 if</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_until"
              c:identifier="g_data_input_stream_read_until"
              throws="1">
        <doc xml:whitespace="preserve">Reads a string from the data input stream, up to the first
occurrence of any of the stop characters.
Note that, in contrast to g_data_input_stream_read_until_async(),
this function consumes the stop character that it finds.
Don't use this function in new code.  Its functionality is
inconsistent with g_data_input_stream_read_until_async().  Both
functions will be marked as deprecated in a future release.  Use
g_data_input_stream_read_upto() instead, but note that that function
does not consume the stop character.
any of the stop characters. Set @length to a #gsize to get the length
of the string. This function will return %NULL on an error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string with the data that was read before encountering</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="stop_chars" transfer-ownership="none">
            <doc xml:whitespace="preserve">characters to terminate the read.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize to get the length of the data read in.</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_until_async"
              c:identifier="g_data_input_stream_read_until_async"
              version="2.20">
        <doc xml:whitespace="preserve">The asynchronous version of g_data_input_stream_read_until().
It is an error to have two outstanding calls to this function.
Note that, in contrast to g_data_input_stream_read_until(),
this function does not consume the stop character that it finds.  You
must read it for yourself.
When the operation is finished, @callback will be called. You
can then call g_data_input_stream_read_until_finish() to get
the result of the operation.
Don't use this function in new code.  Its functionality is
inconsistent with g_data_input_stream_read_until().  Both functions
will be marked as deprecated in a future release.  Use
g_data_input_stream_read_upto_async() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stop_chars" transfer-ownership="none">
            <doc xml:whitespace="preserve">characters to terminate the read.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_until_finish"
              c:identifier="g_data_input_stream_read_until_finish"
              version="2.20"
              throws="1">
        <doc xml:whitespace="preserve">Finish an asynchronous call started by
g_data_input_stream_read_until_async().
any of the stop characters. Set @length to a #gsize to get the length
of the string. This function will return %NULL on an error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string with the data that was read before encountering</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult that was provided to the callback.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize to get the length of the data read in.</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_upto"
              c:identifier="g_data_input_stream_read_upto"
              version="2.24"
              throws="1">
        <doc xml:whitespace="preserve">Reads a string from the data input stream, up to the first
occurrence of any of the stop characters.
In contrast to g_data_input_stream_read_until(), this function
does &lt;emphasis&gt;not&lt;/emphasis&gt; consume the stop character. You have
to use g_data_input_stream_read_byte() to get it before calling
g_data_input_stream_read_upto() again.
Note that @stop_chars may contain '\0' if @stop_chars_len is
specified.
any of the stop characters. Set @length to a #gsize to get the length
of the string. This function will return %NULL on an error</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string with the data that was read before encountering</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="stop_chars" transfer-ownership="none">
            <doc xml:whitespace="preserve">characters to terminate the read</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="stop_chars_len" transfer-ownership="none">
            <doc xml:whitespace="preserve">length of @stop_chars. May be -1 if @stop_chars is nul-terminated</doc>
            <type name="glong" c:type="gssize"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize to get the length of the data read in</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_upto_async"
              c:identifier="g_data_input_stream_read_upto_async"
              version="2.24">
        <doc xml:whitespace="preserve">The asynchronous version of g_data_input_stream_read_upto().
It is an error to have two outstanding calls to this function.
In contrast to g_data_input_stream_read_until(), this function
does &lt;emphasis&gt;not&lt;/emphasis&gt; consume the stop character. You have
to use g_data_input_stream_read_byte() to get it before calling
g_data_input_stream_read_upto() again.
Note that @stop_chars may contain '\0' if @stop_chars_len is
specified.
When the operation is finished, @callback will be called. You
can then call g_data_input_stream_read_upto_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stop_chars" transfer-ownership="none">
            <doc xml:whitespace="preserve">characters to terminate the read</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="stop_chars_len" transfer-ownership="none">
            <doc xml:whitespace="preserve">length of @stop_chars. May be -1 if @stop_chars is nul-terminated</doc>
            <type name="glong" c:type="gssize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_upto_finish"
              c:identifier="g_data_input_stream_read_upto_finish"
              version="2.24"
              throws="1">
        <doc xml:whitespace="preserve">Finish an asynchronous call started by
g_data_input_stream_read_upto_async().
Note that this function does &lt;emphasis&gt;not&lt;/emphasis&gt; consume the
stop character. You have to use g_data_input_stream_read_byte() to
get it before calling g_data_input_stream_read_upto_async() again.
any of the stop characters. Set @length to a #gsize to get the length
of the string. This function will return %NULL on an error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string with the data that was read before encountering</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult that was provided to the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gsize to get the length of the data read in</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_byte_order"
              c:identifier="g_data_input_stream_set_byte_order">
        <doc xml:whitespace="preserve">This function sets the byte order for the given @stream. All subsequent
reads from the @stream will be read in the given @order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="order" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GDataStreamByteOrder to set.</doc>
            <type name="DataStreamByteOrder" c:type="GDataStreamByteOrder"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_newline_type"
              c:identifier="g_data_input_stream_set_newline_type">
        <doc xml:whitespace="preserve">Sets the newline type for the @stream.
Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read
chunk ends in "CR" we must read an additional byte to know if this is "CR" or
"CR LF", and this might block if there is no more data availible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of new line return as #GDataStreamNewlineType.</doc>
            <type name="DataStreamNewlineType"
                  c:type="GDataStreamNewlineType"/>
          </parameter>
        </parameters>
      </method>
      <property name="byte-order" writable="1" transfer-ownership="none">
        <type name="DataStreamByteOrder"/>
      </property>
      <property name="newline-type" writable="1" transfer-ownership="none">
        <type name="DataStreamNewlineType"/>
      </property>
      <field name="parent_instance">
        <type name="BufferedInputStream" c:type="GBufferedInputStream"/>
      </field>
      <field name="priv">
        <type name="DataInputStreamPrivate" c:type="GDataInputStreamPrivate*"/>
      </field>
    </class>
    <record name="DataInputStreamClass"
            c:type="GDataInputStreamClass"
            glib:is-gtype-struct-for="DataInputStream">
      <field name="parent_class">
        <type name="BufferedInputStreamClass"
              c:type="GBufferedInputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="DataInputStreamPrivate"
            c:type="GDataInputStreamPrivate"
            disguised="1">
    </record>
    <class name="DataOutputStream"
           c:symbol-prefix="data_output_stream"
           c:type="GDataOutputStream"
           parent="FilterOutputStream"
           glib:type-name="GDataOutputStream"
           glib:get-type="g_data_output_stream_get_type"
           glib:type-struct="DataOutputStreamClass">
      <doc xml:whitespace="preserve">An implementation of #GBufferedOutputStream that allows for high-level
data manipulation of arbitrary data (including binary operations).</doc>
      <constructor name="new" c:identifier="g_data_output_stream_new">
        <doc xml:whitespace="preserve">Creates a new data output stream for @base_stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GDataOutputStream.</doc>
          <type name="DataOutputStream" c:type="GDataOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_byte_order"
              c:identifier="g_data_output_stream_get_byte_order">
        <doc xml:whitespace="preserve">Gets the byte order for the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GDataStreamByteOrder for the @stream.</doc>
          <type name="DataStreamByteOrder" c:type="GDataStreamByteOrder"/>
        </return-value>
      </method>
      <method name="put_byte"
              c:identifier="g_data_output_stream_put_byte"
              throws="1">
        <doc xml:whitespace="preserve">Puts a byte into the output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #guchar.</doc>
            <type name="guint8" c:type="guchar"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int16"
              c:identifier="g_data_output_stream_put_int16"
              throws="1">
        <doc xml:whitespace="preserve">Puts a signed 16-bit integer into the output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gint16.</doc>
            <type name="gint16" c:type="gint16"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int32"
              c:identifier="g_data_output_stream_put_int32"
              throws="1">
        <doc xml:whitespace="preserve">Puts a signed 32-bit integer into the output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gint32.</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int64"
              c:identifier="g_data_output_stream_put_int64"
              throws="1">
        <doc xml:whitespace="preserve">Puts a signed 64-bit integer into the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gint64.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_string"
              c:identifier="g_data_output_stream_put_string"
              throws="1">
        <doc xml:whitespace="preserve">Puts a string into the output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @string was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="str" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint16"
              c:identifier="g_data_output_stream_put_uint16"
              throws="1">
        <doc xml:whitespace="preserve">Puts an unsigned 16-bit integer into the output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #guint16.</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint32"
              c:identifier="g_data_output_stream_put_uint32"
              throws="1">
        <doc xml:whitespace="preserve">Puts an unsigned 32-bit integer into the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #guint32.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint64"
              c:identifier="g_data_output_stream_put_uint64"
              throws="1">
        <doc xml:whitespace="preserve">Puts an unsigned 64-bit integer into the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @data was successfully added to the @stream.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #guint64.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_byte_order"
              c:identifier="g_data_output_stream_set_byte_order">
        <doc xml:whitespace="preserve">Sets the byte order of the data output stream to @order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="order" transfer-ownership="none">
            <doc xml:whitespace="preserve">a %GDataStreamByteOrder.</doc>
            <type name="DataStreamByteOrder" c:type="GDataStreamByteOrder"/>
          </parameter>
        </parameters>
      </method>
      <property name="byte-order" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Determines the byte ordering that is used when writing
multi-byte entities (such as integers) to the stream.</doc>
        <type name="DataStreamByteOrder"/>
      </property>
      <field name="parent_instance">
        <type name="FilterOutputStream" c:type="GFilterOutputStream"/>
      </field>
      <field name="priv">
        <type name="DataOutputStreamPrivate"
              c:type="GDataOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="DataOutputStreamClass"
            c:type="GDataOutputStreamClass"
            glib:is-gtype-struct-for="DataOutputStream">
      <field name="parent_class">
        <type name="FilterOutputStreamClass"
              c:type="GFilterOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="DataOutputStreamPrivate"
            c:type="GDataOutputStreamPrivate"
            disguised="1">
    </record>
    <enumeration name="DataStreamByteOrder"
                 glib:type-name="GDataStreamByteOrder"
                 glib:get-type="g_data_stream_byte_order_get_type"
                 c:type="GDataStreamByteOrder">
      <doc xml:whitespace="preserve">#GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
across various machine architectures.</doc>
      <member name="big_endian"
              value="0"
              c:identifier="G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN"
              glib:nick="big-endian"/>
      <member name="little_endian"
              value="1"
              c:identifier="G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN"
              glib:nick="little-endian"/>
      <member name="host_endian"
              value="2"
              c:identifier="G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN"
              glib:nick="host-endian"/>
    </enumeration>
    <enumeration name="DataStreamNewlineType"
                 glib:type-name="GDataStreamNewlineType"
                 glib:get-type="g_data_stream_newline_type_get_type"
                 c:type="GDataStreamNewlineType">
      <doc xml:whitespace="preserve">#GDataStreamNewlineType is used when checking for or setting the line endings for a given file.</doc>
      <member name="lf"
              value="0"
              c:identifier="G_DATA_STREAM_NEWLINE_TYPE_LF"
              glib:nick="lf"/>
      <member name="cr"
              value="1"
              c:identifier="G_DATA_STREAM_NEWLINE_TYPE_CR"
              glib:nick="cr"/>
      <member name="cr_lf"
              value="2"
              c:identifier="G_DATA_STREAM_NEWLINE_TYPE_CR_LF"
              glib:nick="cr-lf"/>
      <member name="any"
              value="3"
              c:identifier="G_DATA_STREAM_NEWLINE_TYPE_ANY"
              glib:nick="any"/>
    </enumeration>
    <class name="DesktopAppInfo"
           c:symbol-prefix="desktop_app_info"
           c:type="GDesktopAppInfo"
           parent="GObject.Object"
           glib:type-name="GDesktopAppInfo"
           glib:get-type="g_desktop_app_info_get_type"
           glib:type-struct="DesktopAppInfoClass">
      <doc xml:whitespace="preserve">Information about an installed application from a desktop file.</doc>
      <implements name="AppInfo"/>
      <constructor name="new" c:identifier="g_desktop_app_info_new">
        <doc xml:whitespace="preserve">Creates a new #GDesktopAppInfo based on a desktop file id.
A desktop file id is the basename of the desktop file, including the
.desktop extension. GIO is looking for a desktop file with this name
in the &lt;filename&gt;applications&lt;/filename&gt; subdirectories of the XDG data
directories (i.e. the directories specified in the
&lt;envar&gt;XDG_DATA_HOME&lt;/envar&gt; and &lt;envar&gt;XDG_DATA_DIRS&lt;/envar&gt; environment
variables). GIO also supports the prefix-to-subdirectory mapping that is
described in the &lt;ulink url="http://standards.freedesktop.org/menu-spec/latest/"&gt;Menu Spec&lt;/ulink&gt;
(i.e. a desktop id of kde-foo.desktop will match
&lt;filename&gt;/usr/share/applications/kde/foo.desktop&lt;/filename&gt;).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GDesktopAppInfo, or %NULL if no desktop file with that id</doc>
          <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="desktop_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the desktop file id</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_filename"
                   c:identifier="g_desktop_app_info_new_from_filename">
        <doc xml:whitespace="preserve">Creates a new #GDesktopAppInfo.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GDesktopAppInfo or %NULL on error.</doc>
          <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">the path of a desktop file, in the GLib filename encoding</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_keyfile"
                   c:identifier="g_desktop_app_info_new_from_keyfile"
                   version="2.18">
        <doc xml:whitespace="preserve">Creates a new #GDesktopAppInfo.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GDesktopAppInfo or %NULL on error.</doc>
          <type name="DesktopAppInfo" c:type="GDesktopAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="key_file" transfer-ownership="none">
            <doc xml:whitespace="preserve">an opened #GKeyFile</doc>
            <type name="GLib.KeyFile" c:type="GKeyFile*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="set_desktop_env"
                c:identifier="g_desktop_app_info_set_desktop_env">
        <doc xml:whitespace="preserve">Sets the name of the desktop that the application is running in.
This is used by g_app_info_should_show() to evaluate the
&lt;literal&gt;OnlyShowIn&lt;/literal&gt; and &lt;literal&gt;NotShowIn&lt;/literal&gt;
desktop entry fields.
The &lt;ulink url="http://standards.freedesktop.org/menu-spec/latest/"&gt;Desktop
Menu specification&lt;/ulink&gt; recognizes the following:
&lt;simplelist&gt;
&lt;member&gt;GNOME&lt;/member&gt;
&lt;member&gt;KDE&lt;/member&gt;
&lt;member&gt;ROX&lt;/member&gt;
&lt;member&gt;XFCE&lt;/member&gt;
&lt;member&gt;Old&lt;/member&gt;
&lt;/simplelist&gt;
Should be called only once; subsequent calls are ignored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="desktop_env" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string specifying what desktop this is</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_filename"
              c:identifier="g_desktop_app_info_get_filename"
              version="2.24">
        <doc xml:whitespace="preserve">When @info was created from a known filename, return it.  In some
situations such as the #GDesktopAppInfo returned from
g_desktop_app_info_new_from_keyfile(), this function will return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The full path to the file for @info, or %NULL if not known.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_is_hidden"
              c:identifier="g_desktop_app_info_get_is_hidden">
        <doc xml:whitespace="preserve">A desktop file is hidden if the Hidden key in it is
set to True.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if hidden, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </class>
    <record name="DesktopAppInfoClass"
            c:type="GDesktopAppInfoClass"
            glib:is-gtype-struct-for="DesktopAppInfo">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <interface name="DesktopAppInfoLookup"
               c:symbol-prefix="desktop_app_info_lookup"
               c:type="GDesktopAppInfoLookup"
               glib:type-name="GDesktopAppInfoLookup"
               glib:get-type="g_desktop_app_info_lookup_get_type"
               glib:type-struct="DesktopAppInfoLookupIface">
      <doc xml:whitespace="preserve">Interface that is used by backends to associate default
handlers with URI schemes.</doc>
      <virtual-method name="get_default_for_uri_scheme"
                      invoker="get_default_for_uri_scheme">
        <doc xml:whitespace="preserve">Gets the default application for launching applications
using this URI scheme for a particular GDesktopAppInfoLookup
implementation.
The GDesktopAppInfoLookup interface and this function is used
to implement g_app_info_get_default_for_uri_scheme() backends
in a GIO module. There is no reason for applications to use it
directly. Applications should use g_app_info_get_default_for_uri_scheme().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GAppInfo for given @uri_scheme or %NULL on error.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a URI scheme.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_default_for_uri_scheme"
              c:identifier="g_desktop_app_info_lookup_get_default_for_uri_scheme">
        <doc xml:whitespace="preserve">Gets the default application for launching applications
using this URI scheme for a particular GDesktopAppInfoLookup
implementation.
The GDesktopAppInfoLookup interface and this function is used
to implement g_app_info_get_default_for_uri_scheme() backends
in a GIO module. There is no reason for applications to use it
directly. Applications should use g_app_info_get_default_for_uri_scheme().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GAppInfo for given @uri_scheme or %NULL on error.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a URI scheme.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="DesktopAppInfoLookupIface"
            c:type="GDesktopAppInfoLookupIface"
            glib:is-gtype-struct-for="DesktopAppInfoLookup">
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_default_for_uri_scheme">
        <callback name="get_default_for_uri_scheme">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">#GAppInfo for given @uri_scheme or %NULL on error.</doc>
            <type name="AppInfo" c:type="GAppInfo*"/>
          </return-value>
          <parameters>
            <parameter name="lookup" transfer-ownership="none">
              <type name="DesktopAppInfoLookup"
                    c:type="GDesktopAppInfoLookup*"/>
            </parameter>
            <parameter name="uri_scheme" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string containing a URI scheme.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="Drive"
               c:symbol-prefix="drive"
               c:type="GDrive"
               glib:type-name="GDrive"
               glib:get-type="g_drive_get_type"
               glib:type-struct="DriveIface">
      <doc xml:whitespace="preserve">Opaque drive object.</doc>
      <virtual-method name="can_eject" invoker="can_eject">
        <doc xml:whitespace="preserve">Checks if a drive can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive can be ejected, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="can_poll_for_media" invoker="can_poll_for_media">
        <doc xml:whitespace="preserve">Checks if a drive can be polled for media changes.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive can be polled for media changes,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="can_start" invoker="can_start" version="2.22">
        <doc xml:whitespace="preserve">Checks if a drive can be started.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive can be started, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="can_start_degraded"
                      invoker="can_start_degraded"
                      version="2.22">
        <doc xml:whitespace="preserve">Checks if a drive can be started degraded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive can be started degraded, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="can_stop" invoker="can_stop" version="2.22">
        <doc xml:whitespace="preserve">Checks if a drive can be stopped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive can be stopped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="eject"
                      invoker="eject"
                      deprecated="Use g_drive_eject_with_operation() instead."
                      deprecated-version="2.22">
        <doc xml:whitespace="preserve">Asynchronously ejects a drive.
When the operation is finished, @callback will be called.
You can then call g_drive_eject_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_finish"
                      invoker="eject_finish"
                      deprecated="Use g_drive_eject_with_operation_finish() instead."
                      deprecated-version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a drive.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the drive has been ejected successfully,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation"
                      invoker="eject_with_operation"
                      version="2.22">
        <doc xml:whitespace="preserve">Ejects a drive. This is an asynchronous operation, and is
finished by calling g_drive_eject_with_operation_finish() with the @drive
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation_finish"
                      invoker="eject_with_operation_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a drive. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the drive was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="enumerate_identifiers"
                      invoker="enumerate_identifiers">
        <doc xml:whitespace="preserve">Gets the kinds of identifiers that @drive has.
Use g_drive_get_identifer() to obtain the identifiers
themselves.
kinds of identifiers. Use g_strfreev() to free.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a %NULL-terminated array of strings containing</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
      </virtual-method>
      <virtual-method name="get_icon" invoker="get_icon">
        <doc xml:whitespace="preserve">Gets the icon for @drive.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GIcon for the @drive.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_identifier" invoker="get_identifier">
        <doc xml:whitespace="preserve">Gets the identifier of the given kind for @drive.
requested identfier, or %NULL if the #GDrive
doesn't have this kind of identifier.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated string containing the</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="kind" transfer-ownership="none">
            <doc xml:whitespace="preserve">the kind of identifier to return</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name">
        <doc xml:whitespace="preserve">Gets the name of @drive.
string should be freed when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string containing @drive's name. The returned</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_start_stop_type"
                      invoker="get_start_stop_type"
                      version="2.22">
        <doc xml:whitespace="preserve">Gets a hint about how a drive can be started/stopped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A value from the #GDriveStartStopType enumeration.</doc>
          <type name="DriveStartStopType" c:type="GDriveStartStopType"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_volumes" invoker="get_volumes">
        <doc xml:whitespace="preserve">Get a list of mountable volumes for @drive.
The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GList containing any #GVolume objects on the given @drive.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Volume"/>
          </type>
        </return-value>
      </virtual-method>
      <virtual-method name="has_media" invoker="has_media">
        <doc xml:whitespace="preserve">Checks if the @drive has media. Note that the OS may not be polling
the drive for media changes; see g_drive_is_media_check_automatic()
for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @drive has media, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="has_volumes" invoker="has_volumes">
        <doc xml:whitespace="preserve">Check if @drive has any mountable volumes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive contains volumes, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="is_media_check_automatic"
                      invoker="is_media_check_automatic">
        <doc xml:whitespace="preserve">Checks if @drive is capabable of automatically detecting media changes.
media changes, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive is capabable of automatically detecting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="is_media_removable" invoker="is_media_removable">
        <doc xml:whitespace="preserve">Checks if the @drive supports removable media.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @drive supports removable media, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="poll_for_media" invoker="poll_for_media">
        <doc xml:whitespace="preserve">Asynchronously polls @drive to see if media has been inserted or removed.
When the operation is finished, @callback will be called.
You can then call g_drive_poll_for_media_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="poll_for_media_finish"
                      invoker="poll_for_media_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an operation started with g_drive_poll_for_media() on a drive.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the drive has been poll_for_mediaed successfully,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start" invoker="start" version="2.22">
        <doc xml:whitespace="preserve">Asynchronously starts a drive.
When the operation is finished, @callback will be called.
You can then call g_drive_start_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the start operation.</doc>
            <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start_finish"
                      invoker="start_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes starting a drive.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the drive has been started successfully,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop" invoker="stop" version="2.22">
        <doc xml:whitespace="preserve">Asynchronously stops a drive.
When the operation is finished, @callback will be called.
You can then call g_drive_stop_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for stopping.</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop_finish"
                      invoker="stop_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes stopping a drive.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the drive has been stopped successfully,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="can_eject" c:identifier="g_drive_can_eject">
        <doc xml:whitespace="preserve">Checks if a drive can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive can be ejected, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="can_poll_for_media"
              c:identifier="g_drive_can_poll_for_media">
        <doc xml:whitespace="preserve">Checks if a drive can be polled for media changes.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive can be polled for media changes,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="can_start" c:identifier="g_drive_can_start" version="2.22">
        <doc xml:whitespace="preserve">Checks if a drive can be started.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive can be started, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="can_start_degraded"
              c:identifier="g_drive_can_start_degraded"
              version="2.22">
        <doc xml:whitespace="preserve">Checks if a drive can be started degraded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive can be started degraded, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="can_stop" c:identifier="g_drive_can_stop" version="2.22">
        <doc xml:whitespace="preserve">Checks if a drive can be stopped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive can be stopped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="eject"
              c:identifier="g_drive_eject"
              deprecated="Use g_drive_eject_with_operation() instead."
              deprecated-version="2.22">
        <doc xml:whitespace="preserve">Asynchronously ejects a drive.
When the operation is finished, @callback will be called.
You can then call g_drive_eject_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_finish"
              c:identifier="g_drive_eject_finish"
              deprecated="Use g_drive_eject_with_operation_finish() instead."
              deprecated-version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a drive.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the drive has been ejected successfully,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation"
              c:identifier="g_drive_eject_with_operation"
              version="2.22">
        <doc xml:whitespace="preserve">Ejects a drive. This is an asynchronous operation, and is
finished by calling g_drive_eject_with_operation_finish() with the @drive
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation_finish"
              c:identifier="g_drive_eject_with_operation_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a drive. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the drive was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_identifiers"
              c:identifier="g_drive_enumerate_identifiers">
        <doc xml:whitespace="preserve">Gets the kinds of identifiers that @drive has.
Use g_drive_get_identifer() to obtain the identifiers
themselves.
kinds of identifiers. Use g_strfreev() to free.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a %NULL-terminated array of strings containing</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_icon" c:identifier="g_drive_get_icon">
        <doc xml:whitespace="preserve">Gets the icon for @drive.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GIcon for the @drive.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </method>
      <method name="get_identifier" c:identifier="g_drive_get_identifier">
        <doc xml:whitespace="preserve">Gets the identifier of the given kind for @drive.
requested identfier, or %NULL if the #GDrive
doesn't have this kind of identifier.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated string containing the</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="kind" transfer-ownership="none">
            <doc xml:whitespace="preserve">the kind of identifier to return</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_drive_get_name">
        <doc xml:whitespace="preserve">Gets the name of @drive.
string should be freed when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string containing @drive's name. The returned</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_start_stop_type"
              c:identifier="g_drive_get_start_stop_type"
              version="2.22">
        <doc xml:whitespace="preserve">Gets a hint about how a drive can be started/stopped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A value from the #GDriveStartStopType enumeration.</doc>
          <type name="DriveStartStopType" c:type="GDriveStartStopType"/>
        </return-value>
      </method>
      <method name="get_volumes" c:identifier="g_drive_get_volumes">
        <doc xml:whitespace="preserve">Get a list of mountable volumes for @drive.
The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GList containing any #GVolume objects on the given @drive.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Volume"/>
          </type>
        </return-value>
      </method>
      <method name="has_media" c:identifier="g_drive_has_media">
        <doc xml:whitespace="preserve">Checks if the @drive has media. Note that the OS may not be polling
the drive for media changes; see g_drive_is_media_check_automatic()
for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @drive has media, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="has_volumes" c:identifier="g_drive_has_volumes">
        <doc xml:whitespace="preserve">Check if @drive has any mountable volumes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive contains volumes, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_media_check_automatic"
              c:identifier="g_drive_is_media_check_automatic">
        <doc xml:whitespace="preserve">Checks if @drive is capabable of automatically detecting media changes.
media changes, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @drive is capabable of automatically detecting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_media_removable"
              c:identifier="g_drive_is_media_removable">
        <doc xml:whitespace="preserve">Checks if the @drive supports removable media.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @drive supports removable media, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="poll_for_media" c:identifier="g_drive_poll_for_media">
        <doc xml:whitespace="preserve">Asynchronously polls @drive to see if media has been inserted or removed.
When the operation is finished, @callback will be called.
You can then call g_drive_poll_for_media_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="poll_for_media_finish"
              c:identifier="g_drive_poll_for_media_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an operation started with g_drive_poll_for_media() on a drive.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the drive has been poll_for_mediaed successfully,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="g_drive_start" version="2.22">
        <doc xml:whitespace="preserve">Asynchronously starts a drive.
When the operation is finished, @callback will be called.
You can then call g_drive_start_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the start operation.</doc>
            <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_finish"
              c:identifier="g_drive_start_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes starting a drive.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the drive has been started successfully,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="g_drive_stop" version="2.22">
        <doc xml:whitespace="preserve">Asynchronously stops a drive.
When the operation is finished, @callback will be called.
You can then call g_drive_stop_finish() to obtain the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for stopping.</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop_finish"
              c:identifier="g_drive_stop_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes stopping a drive.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the drive has been stopped successfully,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="changed">
        <doc xml:whitespace="preserve">Emitted when the drive's state has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="disconnected">
        <doc xml:whitespace="preserve">This signal is emitted when the #GDrive have been
disconnected. If the recipient is holding references to the
object they should release them so the object can be
finalized.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="eject-button">
        <doc xml:whitespace="preserve">Emitted when the physical eject button (if any) of a drive has
been pressed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="stop-button" version="2.22">
        <doc xml:whitespace="preserve">Emitted when the physical stop button (if any) of a drive has
been pressed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </interface>
    <record name="DriveIface"
            c:type="GDriveIface"
            glib:is-gtype-struct-for="Drive">
      <doc xml:whitespace="preserve">Interface for creating #GDrive implementations.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="disconnected">
        <callback name="disconnected">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_button">
        <callback name="eject_button">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_name">
        <callback name="get_name">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a string containing @drive's name. The returned</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_icon">
        <callback name="get_icon">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">#GIcon for the @drive.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_volumes">
        <callback name="has_volumes">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @drive contains volumes, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_volumes">
        <callback name="get_volumes">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">#GList containing any #GVolume objects on the given @drive.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Volume"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_media_removable">
        <callback name="is_media_removable">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if @drive supports removable media, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_media">
        <callback name="has_media">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if @drive has media, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_media_check_automatic">
        <callback name="is_media_check_automatic">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @drive is capabable of automatically detecting</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_eject">
        <callback name="can_eject">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @drive can be ejected, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_poll_for_media">
        <callback name="can_poll_for_media">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @drive can be polled for media changes,</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject">
        <callback name="eject">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_finish">
        <callback name="eject_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the drive has been ejected successfully,</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="poll_for_media">
        <callback name="poll_for_media">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:whitespace="preserve">user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="poll_for_media_finish">
        <callback name="poll_for_media_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the drive has been poll_for_mediaed successfully,</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_identifier">
        <callback name="get_identifier">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a newly allocated string containing the</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="kind" transfer-ownership="none">
              <doc xml:whitespace="preserve">the kind of identifier to return</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enumerate_identifiers">
        <callback name="enumerate_identifiers">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a %NULL-terminated array of strings containing</doc>
            <array c:type="char**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_start_stop_type">
        <callback name="get_start_stop_type">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">A value from the #GDriveStartStopType enumeration.</doc>
            <type name="DriveStartStopType" c:type="GDriveStartStopType"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_start">
        <callback name="can_start">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @drive can be started, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_start_degraded">
        <callback name="can_start_degraded">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @drive can be started degraded, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the start operation.</doc>
              <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start_finish">
        <callback name="start_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the drive has been started successfully,</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_stop">
        <callback name="can_stop">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @drive can be stopped, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the unmount if required for stopping.</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop_finish">
        <callback name="stop_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the drive has been stopped successfully,</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop_button">
        <callback name="stop_button">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation">
        <callback name="eject_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation_finish">
        <callback name="eject_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the drive was successfully ejected. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="DriveStartFlags"
                 version="2.22"
                 glib:type-name="GDriveStartFlags"
                 glib:get-type="g_drive_start_flags_get_type"
                 c:type="GDriveStartFlags">
      <doc xml:whitespace="preserve">Flags used when starting a drive.</doc>
      <member name="none"
              value="0"
              c:identifier="G_DRIVE_START_NONE"
              glib:nick="none"/>
    </enumeration>
    <enumeration name="DriveStartStopType"
                 version="2.22"
                 glib:type-name="GDriveStartStopType"
                 glib:get-type="g_drive_start_stop_type_get_type"
                 c:type="GDriveStartStopType">
      <doc xml:whitespace="preserve">Enumeration describing how a drive can be started/stopped.</doc>
      <member name="unknown"
              value="0"
              c:identifier="G_DRIVE_START_STOP_TYPE_UNKNOWN"
              glib:nick="unknown"/>
      <member name="shutdown"
              value="1"
              c:identifier="G_DRIVE_START_STOP_TYPE_SHUTDOWN"
              glib:nick="shutdown"/>
      <member name="network"
              value="2"
              c:identifier="G_DRIVE_START_STOP_TYPE_NETWORK"
              glib:nick="network"/>
      <member name="multidisk"
              value="3"
              c:identifier="G_DRIVE_START_STOP_TYPE_MULTIDISK"
              glib:nick="multidisk"/>
      <member name="password"
              value="4"
              c:identifier="G_DRIVE_START_STOP_TYPE_PASSWORD"
              glib:nick="password"/>
    </enumeration>
    <class name="Emblem"
           c:symbol-prefix="emblem"
           c:type="GEmblem"
           parent="GObject.Object"
           glib:type-name="GEmblem"
           glib:get-type="g_emblem_get_type"
           glib:type-struct="EmblemClass">
      <doc xml:whitespace="preserve">An object for Emblems</doc>
      <implements name="Icon"/>
      <constructor name="new" c:identifier="g_emblem_new" version="2.18">
        <doc xml:whitespace="preserve">Creates a new emblem for @icon.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GEmblem.</doc>
          <type name="Emblem" c:type="GEmblem*"/>
        </return-value>
        <parameters>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:whitespace="preserve">a GIcon containing the icon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_origin"
                   c:identifier="g_emblem_new_with_origin"
                   version="2.18">
        <doc xml:whitespace="preserve">Creates a new emblem for @icon.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GEmblem.</doc>
          <type name="Emblem" c:type="GEmblem*"/>
        </return-value>
        <parameters>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:whitespace="preserve">a GIcon containing the icon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
          <parameter name="origin" transfer-ownership="none">
            <doc xml:whitespace="preserve">a GEmblemOrigin enum defining the emblem's origin</doc>
            <type name="EmblemOrigin" c:type="GEmblemOrigin"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_icon" c:identifier="g_emblem_get_icon" version="2.18">
        <doc xml:whitespace="preserve">Gives back the icon from @emblem.
and should not be modified or freed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIcon. The returned object belongs to the emblem</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </method>
      <method name="get_origin"
              c:identifier="g_emblem_get_origin"
              version="2.18">
        <doc xml:whitespace="preserve">Gets the origin of the emblem.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the origin of the emblem</doc>
          <type name="EmblemOrigin" c:type="GEmblemOrigin"/>
        </return-value>
      </method>
      <property name="icon"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="GObject.Object"/>
      </property>
      <property name="origin"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="EmblemOrigin"/>
      </property>
    </class>
    <record name="EmblemClass"
            c:type="GEmblemClass"
            disguised="1"
            glib:is-gtype-struct-for="Emblem">
    </record>
    <enumeration name="EmblemOrigin"
                 version="2.18"
                 glib:type-name="GEmblemOrigin"
                 glib:get-type="g_emblem_origin_get_type"
                 c:type="GEmblemOrigin">
      <doc xml:whitespace="preserve">GEmblemOrigin is used to add information about the origin of the emblem
to #GEmblem.</doc>
      <member name="unknown"
              value="0"
              c:identifier="G_EMBLEM_ORIGIN_UNKNOWN"
              glib:nick="unknown"/>
      <member name="device"
              value="1"
              c:identifier="G_EMBLEM_ORIGIN_DEVICE"
              glib:nick="device"/>
      <member name="livemetadata"
              value="2"
              c:identifier="G_EMBLEM_ORIGIN_LIVEMETADATA"
              glib:nick="livemetadata"/>
      <member name="tag"
              value="3"
              c:identifier="G_EMBLEM_ORIGIN_TAG"
              glib:nick="tag"/>
    </enumeration>
    <class name="EmblemedIcon"
           c:symbol-prefix="emblemed_icon"
           c:type="GEmblemedIcon"
           parent="GObject.Object"
           glib:type-name="GEmblemedIcon"
           glib:get-type="g_emblemed_icon_get_type"
           glib:type-struct="EmblemedIconClass">
      <doc xml:whitespace="preserve">An implementation of #GIcon for icons with emblems.</doc>
      <implements name="Icon"/>
      <function name="new" c:identifier="g_emblemed_icon_new" version="2.18">
        <doc xml:whitespace="preserve">Creates a new emblemed icon for @icon with the emblem @emblem.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GIcon</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GIcon</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
          <parameter name="emblem" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GEmblem</doc>
            <type name="Emblem" c:type="GEmblem*"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_emblem"
              c:identifier="g_emblemed_icon_add_emblem"
              version="2.18">
        <doc xml:whitespace="preserve">Adds @emblem to the #GList of #GEmblem &lt;!-- --&gt;s.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="emblem" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GEmblem</doc>
            <type name="Emblem" c:type="GEmblem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_emblems"
              c:identifier="g_emblemed_icon_get_emblems"
              version="2.18">
        <doc xml:whitespace="preserve">Gets the list of emblems for the @icon.
is owned by @emblemed</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #GEmblem &lt;!-- --&gt;s that</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="utf8"/>
          </type>
        </return-value>
      </method>
      <method name="get_icon"
              c:identifier="g_emblemed_icon_get_icon"
              version="2.18">
        <doc xml:whitespace="preserve">Gets the main icon for @emblemed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIcon that is owned by @emblemed</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </method>
    </class>
    <record name="EmblemedIconClass"
            c:type="GEmblemedIconClass"
            disguised="1"
            glib:is-gtype-struct-for="EmblemedIcon">
    </record>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_DELETE"
              value="access::can-delete">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE"
              value="access::can-execute">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_READ" value="access::can-read">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_RENAME"
              value="access::can-rename">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_TRASH" value="access::can-trash">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ACCESS_CAN_WRITE" value="access::can-write">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_DOS_IS_ARCHIVE" value="dos::is-archive">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_DOS_IS_SYSTEM" value="dos::is-system">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ETAG_VALUE" value="etag::value">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_FREE" value="filesystem::free">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_READONLY"
              value="filesystem::readonly">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_SIZE" value="filesystem::size">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_TYPE" value="filesystem::type">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW"
              value="filesystem::use-preview">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_GVFS_BACKEND" value="gvfs::backend">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ID_FILE" value="id::file">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_ID_FILESYSTEM" value="id::filesystem">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT"
              value="mountable::can-eject">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT"
              value="mountable::can-mount">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL"
              value="mountable::can-poll">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_START"
              value="mountable::can-start">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED"
              value="mountable::can-start-degraded">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP"
              value="mountable::can-stop">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT"
              value="mountable::can-unmount">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI"
              value="mountable::hal-udi">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC"
              value="mountable::is-media-check-automatic">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE"
              value="mountable::start-stop-type">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE"
              value="mountable::unix-device">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE"
              value="mountable::unix-device-file">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_OWNER_GROUP" value="owner::group">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_OWNER_USER" value="owner::user">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_OWNER_USER_REAL" value="owner::user-real">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_PREVIEW_ICON" value="preview::icon">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_SELINUX_CONTEXT" value="selinux::context">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE"
              value="standard::allocated-size">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE"
              value="standard::content-type">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_COPY_NAME"
              value="standard::copy-name">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_DESCRIPTION"
              value="standard::description">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME"
              value="standard::display-name">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_EDIT_NAME"
              value="standard::edit-name">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE"
              value="standard::fast-content-type">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_ICON" value="standard::icon">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_IS_BACKUP"
              value="standard::is-backup">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_IS_HIDDEN"
              value="standard::is-hidden">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_IS_SYMLINK"
              value="standard::is-symlink">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL"
              value="standard::is-virtual">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_NAME" value="standard::name">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_SIZE" value="standard::size">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_SORT_ORDER"
              value="standard::sort-order">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET"
              value="standard::symlink-target">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_TARGET_URI"
              value="standard::target-uri">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_STANDARD_TYPE" value="standard::type">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_THUMBNAILING_FAILED"
              value="thumbnail::failed">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_THUMBNAIL_PATH" value="thumbnail::path">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_ACCESS" value="time::access">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_ACCESS_USEC" value="time::access-usec">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_CHANGED" value="time::changed">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_CHANGED_USEC"
              value="time::changed-usec">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_CREATED" value="time::created">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_CREATED_USEC"
              value="time::created-usec">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_MODIFIED" value="time::modified">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TIME_MODIFIED_USEC"
              value="time::modified-usec">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TRASH_DELETION_DATE"
              value="trash::deletion-date">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TRASH_ITEM_COUNT" value="trash::item-count">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_TRASH_ORIG_PATH" value="trash::orig-path">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_BLOCKS" value="unix::blocks">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_BLOCK_SIZE" value="unix::block-size">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_DEVICE" value="unix::device">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_GID" value="unix::gid">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_INODE" value="unix::inode">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT"
              value="unix::is-mountpoint">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_MODE" value="unix::mode">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_NLINK" value="unix::nlink">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_RDEV" value="unix::rdev">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FILE_ATTRIBUTE_UNIX_UID" value="unix::uid">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <interface name="File"
               c:symbol-prefix="file"
               c:type="GFile"
               glib:type-name="GFile"
               glib:get-type="g_file_get_type"
               glib:type-struct="FileIface">
      <doc xml:whitespace="preserve">A handle to an object implementing the #GFileIface interface.
Generally stores a location within the file system. Handles do not
necessarily represent files or directories that currently exist.</doc>
      <virtual-method name="append_to" invoker="append_to" throws="1">
        <doc xml:whitespace="preserve">Gets an output stream for appending data to the file. If
the file doesn't already exist it is created.
By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Some file systems don't allow all file names, and may
return an %G_IO_ERROR_INVALID_FILENAME error.
If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will be
returned. Other errors are possible too, and depend on what kind of
filesystem the file is on.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileOutputStream, or %NULL on error.</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="append_to_async" invoker="append_to_async">
        <doc xml:whitespace="preserve">Asynchronously opens @file for appending.
For more details, see g_file_append_to() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_append_to_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="append_to_finish"
                      invoker="append_to_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file append operation started with
g_file_append_to_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a valid #GFileOutputStream or %NULL on error.</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="copy" invoker="copy" introspectable="0" throws="1">
        <doc xml:whitespace="preserve">Copies the file @source to the location specified by @destination.
Can not handle recursive copies of directories.
If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.
If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
will be copied as symlinks, otherwise the target of the
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If @progress_callback is not %NULL, then the operation can be monitored by
setting this to a #GFileProgressCallback function. @progress_callback_data
will be passed to this function. It is guaranteed that this callback will
be called after all data has been transferred with the total number of bytes
copied during the operation.
If the @source file does not exist then the G_IO_ERROR_NOT_FOUND
error is returned, independent on the status of the @destination.
If #G_FILE_COPY_OVERWRITE is not specified and the target exists, then the
error G_IO_ERROR_EXISTS is returned.
If trying to overwrite a file over a directory the G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
G_IO_ERROR_WOULD_MERGE error is returned.
If the source is a directory and the target does not exist, or #G_FILE_COPY_OVERWRITE is
specified and the target is a file, then the G_IO_ERROR_WOULD_RECURSE error
is returned.
If you are interested in copying the #GFile object itself (not the on-disk
file), see g_file_dup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:whitespace="preserve">destination #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback"
                     transfer-ownership="none"
                     closure="4">
            <doc xml:whitespace="preserve">function to callback with progress information</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="copy_async"
                      invoker="copy_async"
                      introspectable="0">
        <doc xml:whitespace="preserve">Copies the file @source to the location specified by @destination
asynchronously. For details of the behaviour, see g_file_copy().
If @progress_callback is not %NULL, then that function that will be called
just like in g_file_copy(), however the callback will run in the main loop,
not in the thread that is doing the I/O operation.
When the operation is finished, @callback will be called. You can then call
g_file_copy_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:whitespace="preserve">destination #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback"
                     transfer-ownership="none"
                     closure="5">
            <doc xml:whitespace="preserve">function to callback with progress information</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="7">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="7">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="copy_finish" invoker="copy_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes copying the file started with
g_file_copy_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a %TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create" invoker="create" throws="1">
        <doc xml:whitespace="preserve">Creates a new file and returns an output stream for writing to it.
The file must not already exist.
By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If a file or directory with this name already exists the G_IO_ERROR_EXISTS
error will be returned.
Some file systems don't allow all file names, and may
return an G_IO_ERROR_INVALID_FILENAME error, and if the name
is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
Other errors are possible too, and depend on what kind of
filesystem the file is on.
%NULL on error.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileOutputStream for the newly created file, or</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_async" invoker="create_async">
        <doc xml:whitespace="preserve">Asynchronously creates a new file and returns an output stream for writing to it.
The file must not already exist.
For more details, see g_file_create() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_create_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_finish" invoker="create_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file create operation started with
g_file_create_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileOutputStream or %NULL on error.</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_readwrite"
                      invoker="create_readwrite"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Creates a new file and returns a stream for reading and writing to it.
The file must not already exist.
By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If a file or directory with this name already exists the %G_IO_ERROR_EXISTS
error will be returned. Some file systems don't allow all file names,
and may return an %G_IO_ERROR_INVALID_FILENAME error, and if the name
is too long, %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors
are possible too, and depend on what kind of filesystem the file is on.
Note that in many non-local file cases read and write streams are not
supported, so make sure you really need to do read and write streaming,
rather than just opening for reading or writing.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileIOStream for the newly created file, or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_readwrite_async"
                      invoker="create_readwrite_async"
                      version="2.22">
        <doc xml:whitespace="preserve">Asynchronously creates a new file and returns a stream for reading and
writing to it. The file must not already exist.
For more details, see g_file_create_readwrite() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then
call g_file_create_readwrite_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_readwrite_finish"
                      invoker="create_readwrite_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file create operation started with
g_file_create_readwrite_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileIOStream or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delete_file" invoker="delete" throws="1">
        <doc xml:whitespace="preserve">Deletes a file. If the @file is a directory, it will only be deleted if it
is empty.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file was deleted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup" invoker="dup">
        <doc xml:whitespace="preserve">Duplicates a #GFile handle. This operation does not duplicate
the actual file or directory represented by the #GFile; see
g_file_copy() if attempting to copy a file.
This call does no blocking i/o.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GFile that is a duplicate of the given #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="eject_mountable"
                      invoker="eject_mountable"
                      deprecated="Use g_file_eject_mountable_with_operation() instead."
                      deprecated-version="2.22">
        <doc xml:whitespace="preserve">Starts an asynchronous eject on a mountable.
When this operation has completed, @callback will be called with
g_file_eject_mountable_finish().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_mountable_finish"
                      invoker="eject_mountable_finish"
                      deprecated="Use g_file_eject_mountable_with_operation_finish() instead."
                      deprecated-version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous eject operation started by
g_file_eject_mountable().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @file was ejected successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_mountable_with_operation"
                      invoker="eject_mountable_with_operation"
                      version="2.22">
        <doc xml:whitespace="preserve">Starts an asynchronous eject on a mountable.
When this operation has completed, @callback will be called with
g_file_eject_mountable_with_operation_finish().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_mountable_with_operation_finish"
                      invoker="eject_mountable_with_operation_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous eject operation started by
g_file_eject_mountable_with_operation().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @file was ejected successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="enumerate_children"
                      invoker="enumerate_children"
                      throws="1">
        <doc xml:whitespace="preserve">Gets the requested information about the files in a directory. The result
is a #GFileEnumerator object that will give out #GFileInfo objects for
all the files in the directory.
The @attributes value is a string that specifies the file attributes that
should be gathered. It is not an error if it's not possible to read a particular
requested attribute from a file - it just won't be set. @attributes should
be a comma-separated list of attributes or attribute wildcards. The wildcard "*"
means all attributes, and a wildcard like "standard::*" means all attributes in the standard
namespace. An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like #G_FILE_ATTRIBUTE_STANDARD_NAME.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
If the file is not a directory, the G_FILE_ERROR_NOTDIR error will be returned.
Other errors are possible too.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GFileEnumerator if successful, %NULL on error.</doc>
          <type name="FileEnumerator" c:type="GFileEnumerator*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="enumerate_children_async"
                      invoker="enumerate_children_async">
        <doc xml:whitespace="preserve">Asynchronously gets the requested information about the files in a directory. The result
is a #GFileEnumerator object that will give out #GFileInfo objects for
all the files in the directory.
For more details, see g_file_enumerate_children() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_enumerate_children_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="5">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="enumerate_children_finish"
                      invoker="enumerate_children_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an async enumerate children operation.
See g_file_enumerate_children_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileEnumerator or %NULL if an error occurred.</doc>
          <type name="FileEnumerator" c:type="GFileEnumerator*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="equal" invoker="equal">
        <doc xml:whitespace="preserve">Checks equality of two given #GFile&lt;!-- --&gt;s. Note that two
#GFile&lt;!-- --&gt;s that differ can still refer to the same
file on the filesystem due to various forms of filename
aliasing.
This call does no blocking i/o.
%FALSE if either is not a #GFile.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @file1 and @file2 are equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="file2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="find_enclosing_mount"
                      invoker="find_enclosing_mount"
                      throws="1">
        <doc xml:whitespace="preserve">Gets a #GMount for the #GFile.
If the #GFileIface for @file does not have a mount (e.g. possibly a
remote share), @error will be set to %G_IO_ERROR_NOT_FOUND and %NULL
will be returned.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GMount where the @file is located or %NULL on error.</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="find_enclosing_mount_async"
                      invoker="find_enclosing_mount_async">
        <doc xml:whitespace="preserve">Asynchronously gets the mount for the file.
For more details, see g_file_find_enclosing_mount() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_find_enclosing_mount_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="find_enclosing_mount_finish"
                      invoker="find_enclosing_mount_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous find mount request.
See g_file_find_enclosing_mount_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GMount for given @file or %NULL on error.</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_basename" invoker="get_basename">
        <doc xml:whitespace="preserve">Gets the base name (the last component of the path) for a given #GFile.
If called for the top level of a system (such as the filesystem root
or a uri like sftp://host/) it will return a single directory separator
(and on Windows, possibly a drive letter).
The base name is a byte string (*not* UTF-8). It has no defined encoding
or rules other than it may not contain zero bytes.  If you want to use
filenames in a user interface you should use the display name that you
can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
attribute with g_file_query_info().
This call does no blocking i/o.
if given #GFile is invalid. The returned string should be
freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">string containing the #GFile's base name, or %NULL</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_child_for_display_name"
                      invoker="get_child_for_display_name"
                      throws="1">
        <doc xml:whitespace="preserve">Gets the child of @file for a given @display_name (i.e. a UTF8
version of the name). If this function fails, it returns %NULL and @error will be
set. This is very useful when constructing a GFile for a new file
and the user entered the filename in the user interface, for instance
when you select a directory and type a filename in the file selector.
This call does no blocking i/o.
%NULL if the display name couldn't be converted.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile to the specified child, or</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">string to a possible child.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_parent" invoker="get_parent">
        <doc xml:whitespace="preserve">Gets the parent directory for the @file.
If the @file represents the root directory of the
file system, then %NULL will be returned.
This call does no blocking i/o.
#GFile or %NULL if there is no parent.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile structure to the parent of the given</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_parse_name" invoker="get_parse_name">
        <doc xml:whitespace="preserve">Gets the parse name of the @file.
A parse name is a UTF-8 string that describes the
file such that one can get the #GFile back using
g_file_parse_name().
This is generally used to show the #GFile as a nice
full-pathname kind of string in a user interface,
like in a location entry.
For local files with names that can safely be converted
to UTF8 the pathname is used, otherwise the IRI is used
(a form of URI that allows UTF8 characters unescaped).
This call does no blocking i/o.
string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string containing the #GFile's parse name. The returned</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_path" invoker="get_path">
        <doc xml:whitespace="preserve">Gets the local pathname for #GFile, if one exists.
This call does no blocking i/o.
no such path exists. The returned string should be
freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">string containing the #GFile's path, or %NULL if</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_relative_path" invoker="get_relative_path">
        <doc xml:whitespace="preserve">Gets the path for @descendant relative to @parent.
This call does no blocking i/o.
to @parent, or %NULL if @descendant doesn't have @parent as prefix.
The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">string with the relative path from @descendant</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="descendant" transfer-ownership="none">
            <doc xml:whitespace="preserve">input #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_uri" invoker="get_uri">
        <doc xml:whitespace="preserve">Gets the URI for the @file.
This call does no blocking i/o.
The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string containing the #GFile's URI.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_uri_scheme" invoker="get_uri_scheme">
        <doc xml:whitespace="preserve">Gets the URI scheme for a #GFile.
RFC 3986 decodes the scheme as:
&lt;programlisting&gt;
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
&lt;/programlisting&gt;
Common schemes include "file", "http", "ftp", etc.
This call does no blocking i/o.
#GFile. The returned string should be freed with g_free()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string containing the URI scheme for the given</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="has_uri_scheme" invoker="has_uri_scheme">
        <doc xml:whitespace="preserve">Checks to see if a #GFile has a given URI scheme.
This call does no blocking i/o.
given URI scheme, %FALSE if URI scheme is %NULL,
not supported, or #GFile is invalid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if #GFile's backend supports the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a URI scheme.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="hash">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
      </virtual-method>
      <virtual-method name="is_native" invoker="is_native">
        <doc xml:whitespace="preserve">Checks to see if a file is native to the platform.
A native file s one expressed in the platform-native filename format,
e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
as it might be on a locally mounted remote filesystem.
On some systems non-native files may be available using
the native filesystem via a userspace filesystem (FUSE), in
these cases this call will return %FALSE, but g_file_get_path()
will still return a native path.
This call does no blocking i/o.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if file is native.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="make_directory"
                      invoker="make_directory"
                      throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="make_symbolic_link"
                      invoker="make_symbolic_link"
                      throws="1">
        <doc xml:whitespace="preserve">Creates a symbolic link named @file which contains the string
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on the creation of a new symlink, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="symlink_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string with the path for the target of the new symlink</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="monitor_dir"
                      invoker="monitor_directory"
                      throws="1">
        <doc xml:whitespace="preserve">Obtains a directory monitor for the given file.
This may fail if directory monitoring is not supported.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileMonitor for the given @file, or %NULL on error.</doc>
          <type name="FileMonitor" c:type="GFileMonitor*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileMonitorFlags.</doc>
            <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="monitor_file" invoker="monitor_file" throws="1">
        <doc xml:whitespace="preserve">Obtains a file monitor for the given file. If no file notification
mechanism exists, then regular polling of the file is used.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileMonitor for the given @file, or %NULL on error.</doc>
          <type name="FileMonitor" c:type="GFileMonitor*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileMonitorFlags.</doc>
            <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_enclosing_volume"
                      invoker="mount_enclosing_volume">
        <doc xml:whitespace="preserve">Starts a @mount_operation, mounting the volume that contains the file @location.
When this operation has completed, @callback will be called with
g_file_mount_enclosing_volume_finish().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_enclosing_volume_finish"
                      invoker="mount_enclosing_volume_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes a mount operation started by g_file_mount_enclosing_volume().
has occurred, this function will return %FALSE and set @error
appropriately if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful. If an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_mountable" invoker="mount_mountable">
        <doc xml:whitespace="preserve">Mounts a file of type G_FILE_TYPE_MOUNTABLE.
Using @mount_operation, you can request callbacks when, for instance,
passwords are needed during authentication.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_mount_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_mountable_finish"
                      invoker="mount_mountable_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes a mount operation. See g_file_mount_mountable() for details.
Finish an asynchronous mount operation that was started
with g_file_mount_mountable().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile or %NULL on error.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="move" invoker="move" introspectable="0" throws="1">
        <doc xml:whitespace="preserve">Tries to move the file or directory @source to the location specified by @destination.
If native move operations are supported then this is used, otherwise a copy + delete
fallback is used. The native implementation may support moving directories (for instance
on moves inside the same filesystem), but the fallback code does not.
If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.
If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
will be copied as symlinks, otherwise the target of the
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If @progress_callback is not %NULL, then the operation can be monitored by
setting this to a #GFileProgressCallback function. @progress_callback_data
will be passed to this function. It is guaranteed that this callback will
be called after all data has been transferred with the total number of bytes
copied during the operation.
If the @source file does not exist then the G_IO_ERROR_NOT_FOUND
error is returned, independent on the status of the @destination.
If #G_FILE_COPY_OVERWRITE is not specified and the target exists, then the
error G_IO_ERROR_EXISTS is returned.
If trying to overwrite a file over a directory the G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
G_IO_ERROR_WOULD_MERGE error is returned.
If the source is a directory and the target does not exist, or #G_FILE_COPY_OVERWRITE is
specified and the target is a file, then the G_IO_ERROR_WOULD_RECURSE error
may be returned (if the native move operation isn't available).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on successful move, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GFile pointing to the destination location.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">set of #GFileCopyFlags.</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback"
                     transfer-ownership="none"
                     closure="4">
            <doc xml:whitespace="preserve">#GFileProgressCallback function for updates.</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">gpointer to user data for the callback function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open_readwrite"
                      invoker="open_readwrite"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Opens an existing file for reading and writing. The result is
a #GFileIOStream that can be used to read and write the contents of the file.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be returned.
Other errors are possible too, and depend on what kind of filesystem the file is on.
Note that in many non-local file cases read and write streams are not supported,
so make sure you really need to do read and write streaming, rather than
just opening for reading or writing.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFileIOStream or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open_readwrite_async"
                      invoker="open_readwrite_async"
                      version="2.22">
        <doc xml:whitespace="preserve">Asynchronously opens @file for reading and writing.
For more details, see g_file_open_readwrite() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_open_readwrite_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open_readwrite_finish"
                      invoker="open_readwrite_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file read operation started with
g_file_open_readwrite_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileIOStream or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="poll_mountable"
                      invoker="poll_mountable"
                      version="2.22">
        <doc xml:whitespace="preserve">Polls a file of type G_FILE_TYPE_MOUNTABLE.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_mount_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="poll_mountable_finish"
                      invoker="poll_mountable_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes a poll operation. See g_file_poll_mountable() for details.
Finish an asynchronous poll operation that was polled
with g_file_poll_mountable().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prefix_matches" invoker="has_prefix">
        <doc xml:whitespace="preserve">Checks whether @file has the prefix specified by @prefix. In other word,
if the names of inital elements of @file&lt;!-- --&gt;s pathname match @prefix.
Only full pathname elements are matched, so a path like /foo is not
considered a prefix of /foobar, only of /foo/bar.
This call does no i/o, as it works purely on names. As such it can
sometimes return %FALSE even if @file is inside a @prefix (from a
filesystem point of view), because the prefix of @file is an alias
of @prefix.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @files's parent, grandparent, etc is @prefix.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:whitespace="preserve">input #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_filesystem_info"
                      invoker="query_filesystem_info"
                      throws="1">
        <doc xml:whitespace="preserve">Similar to g_file_query_info(), but obtains information
about the filesystem the @file is on, rather than the file itself.
For instance the amount of space available and the type of
the filesystem.
The @attributes value is a string that specifies the file attributes that
should be gathered. It is not an error if it's not possible to read a particular
requested attribute from a file - it just won't be set. @attributes should
be a comma-separated list of attributes or attribute wildcards. The wildcard "*"
means all attributes, and a wildcard like "fs:*" means all attributes in the fs
namespace. The standard namespace for filesystem attributes is "fs".
Common attributes of interest are #G_FILE_ATTRIBUTE_FILESYSTEM_SIZE
(the total size of the filesystem in bytes), #G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of
bytes available), and #G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
Other errors are possible too, and depend on what kind of filesystem the file is on.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInfo or %NULL if there was an error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_filesystem_info_async"
                      invoker="query_filesystem_info_async">
        <doc xml:whitespace="preserve">Asynchronously gets the requested information about the filesystem
that the specified @file is on. The result is a #GFileInfo object
that contains key-value attributes (such as type or size for the
file).
For more details, see g_file_query_filesystem_info() which is the
synchronous version of this call.
When the operation is finished, @callback will be called. You can
then call g_file_query_info_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_filesystem_info_finish"
                      invoker="query_filesystem_info_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous filesystem info query.  See
g_file_query_filesystem_info_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFileInfo for given @file or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info" invoker="query_info" throws="1">
        <doc xml:whitespace="preserve">Gets the requested information about specified @file. The result
is a #GFileInfo object that contains key-value attributes (such as
the type or size of the file).
The @attributes value is a string that specifies the file attributes that
should be gathered. It is not an error if it's not possible to read a particular
requested attribute from a file - it just won't be set. @attributes should
be a comma-separated list of attributes or attribute wildcards. The wildcard "*"
means all attributes, and a wildcard like "standard::*" means all attributes in the standard
namespace. An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like #G_FILE_ATTRIBUTE_STANDARD_NAME.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
For symlinks, normally the information about the target of the
symlink is returned, rather than information about the symlink itself.
However if you pass #G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in @flags the
information about the symlink itself will be returned. Also, for symlinks
that point to non-existing files the information about the symlink itself
will be returned.
If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
Other errors are possible too, and depend on what kind of filesystem the file is on.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInfo for the given @file, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_async" invoker="query_info_async">
        <doc xml:whitespace="preserve">Asynchronously gets the requested information about specified @file. The result
is a #GFileInfo object that contains key-value attributes (such as type or size
for the file).
For more details, see g_file_query_info() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_query_info_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="5">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_finish"
                      invoker="query_info_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file info query.
See g_file_query_info_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFileInfo for given @file or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_settable_attributes"
                      invoker="query_settable_attributes"
                      throws="1">
        <doc xml:whitespace="preserve">Obtain the list of settable attributes for the file.
Returns the type and full attribute name of all the attributes
that can be set on this file. This doesn't mean setting it will always
succeed though, you might get an access failure, or some specific
file may not support a specific attribute.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When you are done with it, release it with g_file_attribute_info_list_unref()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileAttributeInfoList describing the settable attributes.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_writable_namespaces"
                      invoker="query_writable_namespaces"
                      throws="1">
        <doc xml:whitespace="preserve">Obtain the list of attribute namespaces where new attributes
can be created by a user. An example of this is extended
attributes (in the "xattr" namespace).
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When you are done with it, release it with g_file_attribute_info_list_unref()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileAttributeInfoList describing the writable namespaces.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_async" invoker="read_async">
        <doc xml:whitespace="preserve">Asynchronously opens @file for reading.
For more details, see g_file_read() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_read_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_finish" invoker="read_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file read operation started with
g_file_read_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInputStream or %NULL on error.</doc>
          <type name="FileInputStream" c:type="GFileInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_fn" invoker="read" throws="1">
        <doc xml:whitespace="preserve">Opens a file for reading. The result is a #GFileInputStream that
can be used to read the contents of the file.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be returned.
Other errors are possible too, and depend on what kind of filesystem the file is on.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFileInputStream or %NULL on error.</doc>
          <type name="FileInputStream" c:type="GFileInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace" invoker="replace" throws="1">
        <doc xml:whitespace="preserve">Returns an output stream for overwriting the file, possibly
creating a backup copy of the file first. If the file doesn't exist,
it will be created.
This will try to replace the file in the safest way possible so
that any errors during the writing will not affect an already
existing copy of the file. For instance, for local files it
may write to a temporary file and then atomically rename over
the destination when the stream is closed.
By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If you pass in a non-#NULL @etag value, then this value is
compared to the current entity tag of the file, and if they differ
an G_IO_ERROR_WRONG_ETAG error is returned. This generally means
that the file has been changed since you last read it. You can get
the new etag from g_file_output_stream_get_etag() after you've
finished writing and closed the #GFileOutputStream. When you load
a new file you can use g_file_input_stream_query_info() to get
the etag of the file.
If @make_backup is %TRUE, this function will attempt to make a backup
of the current file before overwriting it. If this fails a G_IO_ERROR_CANT_CREATE_BACKUP
error will be returned. If you want to replace anyway, try again with
If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be returned,
and if the file is some other form of non-regular file then a
G_IO_ERROR_NOT_REGULAR_FILE error will be returned.
Some file systems don't allow all file names, and may
return an G_IO_ERROR_INVALID_FILENAME error, and if the name
is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
Other errors are possible too, and depend on what kind of
filesystem the file is on.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileOutputStream or %NULL on error.</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="etag" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an optional &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or #NULL to ignore.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if a backup should be created.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace_async" invoker="replace_async">
        <doc xml:whitespace="preserve">Asynchronously overwrites the file, replacing the contents, possibly
creating a backup copy of the file first.
For more details, see g_file_replace() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_replace_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="etag" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or NULL to ignore.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if a backup should be created.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="6">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="6">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace_finish"
                      invoker="replace_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file replace operation started with
g_file_replace_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileOutputStream, or %NULL on error.</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace_readwrite"
                      invoker="replace_readwrite"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Returns an output stream for overwriting the file in readwrite mode,
possibly creating a backup copy of the file first. If the file doesn't
exist, it will be created.
For details about the behaviour, see g_file_replace() which does the same
thing but returns an output stream only.
Note that in many non-local file cases read and write streams are not
supported, so make sure you really need to do read and write streaming,
rather than just opening for reading or writing.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileIOStream or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="etag" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an optional &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace_readwrite_async"
                      invoker="replace_readwrite_async"
                      version="2.22">
        <doc xml:whitespace="preserve">Asynchronously overwrites the file in read-write mode, replacing the
contents, possibly creating a backup copy of the file first.
For more details, see g_file_replace_readwrite() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then
call g_file_replace_readwrite_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="etag" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or NULL to ignore.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if a backup should be created.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="6">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="6">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="replace_readwrite_finish"
                      invoker="replace_readwrite_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file replace operation started with
g_file_replace_readwrite_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileIOStream, or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="resolve_relative_path"
                      invoker="resolve_relative_path">
        <doc xml:whitespace="preserve">Resolves a relative path for @file to an absolute path.
This call does no blocking i/o.
is %NULL or if @file is invalid.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFile to the resolved path. %NULL if @relative_path</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="relative_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">a given relative path string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_attribute" invoker="set_attribute" throws="1">
        <doc xml:whitespace="preserve">Sets an attribute in the file with attribute name @attribute to @value.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the attribute was set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the attribute's name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type of the attribute</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType"/>
          </parameter>
          <parameter name="value_p" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to the value (or the pointer itself if the type is a pointer type)</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_attributes_async"
                      invoker="set_attributes_async">
        <doc xml:whitespace="preserve">Asynchronously sets the attributes of @file with @info.
For more details, see g_file_set_attributes_from_info() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_set_attributes_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="5">
            <doc xml:whitespace="preserve">a #gpointer.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_attributes_finish"
                      invoker="set_attributes_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes setting an attribute started in g_file_set_attributes_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the attributes were set correctly, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="info"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_attributes_from_info"
                      invoker="set_attributes_from_info"
                      throws="1">
        <doc xml:whitespace="preserve">Tries to set all attributes in the #GFileInfo on the target values,
not stopping on the first error.
If there is any error during this operation then @error will be set to
the first error. Error on particular fields are flagged by setting
the "status" field in the attribute value to
%G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect
further errors.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if there was any error, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_display_name"
                      invoker="set_display_name"
                      throws="1">
        <doc xml:whitespace="preserve">Renames @file to the specified display name.
The display name is converted from UTF8 to the correct encoding for the target
filesystem if possible and the @file is renamed to this.
If you want to implement a rename operation in the user interface the edit name
(#G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial value in the rename
widget, and then the result after editing should be passed to g_file_set_display_name().
On success the resulting converted filename is returned.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
if there was an error.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile specifying what @file was renamed to, or %NULL</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_display_name_async"
                      invoker="set_display_name_async">
        <doc xml:whitespace="preserve">Asynchronously sets the display name for a given #GFile.
For more details, see g_file_set_display_name() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_set_display_name_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_display_name_finish"
                      invoker="set_display_name_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes setting a display name started with
g_file_set_display_name_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile or %NULL on error.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start_mountable"
                      invoker="start_mountable"
                      version="2.22">
        <doc xml:whitespace="preserve">Starts a file of type G_FILE_TYPE_MOUNTABLE.
Using @start_operation, you can request callbacks when, for instance,
passwords are needed during authentication.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_mount_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
          </parameter>
          <parameter name="start_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start_mountable_finish"
                      invoker="start_mountable_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes a start operation. See g_file_start_mountable() for details.
Finish an asynchronous start operation that was started
with g_file_start_mountable().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop_mountable"
                      invoker="stop_mountable"
                      version="2.22">
        <doc xml:whitespace="preserve">Stops a file of type G_FILE_TYPE_MOUNTABLE.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_stop_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop_mountable_finish"
                      invoker="stop_mountable_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an stop operation, see g_file_stop_mountable() for details.
Finish an asynchronous stop operation that was started
with g_file_stop_mountable().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="trash" invoker="trash" throws="1">
        <doc xml:whitespace="preserve">Sends @file to the "Trashcan", if possible. This is similar to
deleting it, but the user can recover it before emptying the trashcan.
Not all file systems support trashing, so this call can return the
%G_IO_ERROR_NOT_SUPPORTED error.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on successful trash, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_mountable"
                      invoker="unmount_mountable"
                      deprecated="Use g_file_unmount_mountable_with_operation() instead."
                      deprecated-version="2.22">
        <doc xml:whitespace="preserve">Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_unmount_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_mountable_finish"
                      invoker="unmount_mountable_finish"
                      deprecated="Use g_file_unmount_mountable_with_operation_finish() instead."
                      deprecated-version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an unmount operation, see g_file_unmount_mountable() for details.
Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_mountable_with_operation"
                      invoker="unmount_mountable_with_operation"
                      version="2.22">
        <doc xml:whitespace="preserve">Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_unmount_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_mountable_with_operation_finish"
                      invoker="unmount_mountable_with_operation_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details.
Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable_with_operation().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="append_to" c:identifier="g_file_append_to" throws="1">
        <doc xml:whitespace="preserve">Gets an output stream for appending data to the file. If
the file doesn't already exist it is created.
By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Some file systems don't allow all file names, and may
return an %G_IO_ERROR_INVALID_FILENAME error.
If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will be
returned. Other errors are possible too, and depend on what kind of
filesystem the file is on.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileOutputStream, or %NULL on error.</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_to_async" c:identifier="g_file_append_to_async">
        <doc xml:whitespace="preserve">Asynchronously opens @file for appending.
For more details, see g_file_append_to() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_append_to_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_to_finish"
              c:identifier="g_file_append_to_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file append operation started with
g_file_append_to_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a valid #GFileOutputStream or %NULL on error.</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy"
              c:identifier="g_file_copy"
              introspectable="0"
              throws="1">
        <doc xml:whitespace="preserve">Copies the file @source to the location specified by @destination.
Can not handle recursive copies of directories.
If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.
If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
will be copied as symlinks, otherwise the target of the
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If @progress_callback is not %NULL, then the operation can be monitored by
setting this to a #GFileProgressCallback function. @progress_callback_data
will be passed to this function. It is guaranteed that this callback will
be called after all data has been transferred with the total number of bytes
copied during the operation.
If the @source file does not exist then the G_IO_ERROR_NOT_FOUND
error is returned, independent on the status of the @destination.
If #G_FILE_COPY_OVERWRITE is not specified and the target exists, then the
error G_IO_ERROR_EXISTS is returned.
If trying to overwrite a file over a directory the G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
G_IO_ERROR_WOULD_MERGE error is returned.
If the source is a directory and the target does not exist, or #G_FILE_COPY_OVERWRITE is
specified and the target is a file, then the G_IO_ERROR_WOULD_RECURSE error
is returned.
If you are interested in copying the #GFile object itself (not the on-disk
file), see g_file_dup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:whitespace="preserve">destination #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback"
                     transfer-ownership="none"
                     closure="4">
            <doc xml:whitespace="preserve">function to callback with progress information</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_async"
              c:identifier="g_file_copy_async"
              introspectable="0">
        <doc xml:whitespace="preserve">Copies the file @source to the location specified by @destination
asynchronously. For details of the behaviour, see g_file_copy().
If @progress_callback is not %NULL, then that function that will be called
just like in g_file_copy(), however the callback will run in the main loop,
not in the thread that is doing the I/O operation.
When the operation is finished, @callback will be called. You can then call
g_file_copy_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:whitespace="preserve">destination #GFile</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback"
                     transfer-ownership="none"
                     closure="5">
            <doc xml:whitespace="preserve">function to callback with progress information</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="7">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_attributes"
              c:identifier="g_file_copy_attributes"
              throws="1">
        <doc xml:whitespace="preserve">Copies the file attributes from @source to @destination.
Normally only a subset of the file attributes are copied,
those that are copies in a normal file copy operation
(which for instance does not include e.g. owner). However
if #G_FILE_COPY_ALL_METADATA is specified in @flags, then
all the metadata that is possible to copy is copied. This
is useful when implementing move by copy + delete source.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the attributes were copied successfully, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFile to copy attributes to.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCopyFlags.</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_finish" c:identifier="g_file_copy_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes copying the file started with
g_file_copy_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a %TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create" c:identifier="g_file_create" throws="1">
        <doc xml:whitespace="preserve">Creates a new file and returns an output stream for writing to it.
The file must not already exist.
By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If a file or directory with this name already exists the G_IO_ERROR_EXISTS
error will be returned.
Some file systems don't allow all file names, and may
return an G_IO_ERROR_INVALID_FILENAME error, and if the name
is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
Other errors are possible too, and depend on what kind of
filesystem the file is on.
%NULL on error.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileOutputStream for the newly created file, or</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_async" c:identifier="g_file_create_async">
        <doc xml:whitespace="preserve">Asynchronously creates a new file and returns an output stream for writing to it.
The file must not already exist.
For more details, see g_file_create() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_create_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_finish"
              c:identifier="g_file_create_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file create operation started with
g_file_create_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileOutputStream or %NULL on error.</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_readwrite"
              c:identifier="g_file_create_readwrite"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Creates a new file and returns a stream for reading and writing to it.
The file must not already exist.
By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If a file or directory with this name already exists the %G_IO_ERROR_EXISTS
error will be returned. Some file systems don't allow all file names,
and may return an %G_IO_ERROR_INVALID_FILENAME error, and if the name
is too long, %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors
are possible too, and depend on what kind of filesystem the file is on.
Note that in many non-local file cases read and write streams are not
supported, so make sure you really need to do read and write streaming,
rather than just opening for reading or writing.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileIOStream for the newly created file, or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_readwrite_async"
              c:identifier="g_file_create_readwrite_async"
              version="2.22">
        <doc xml:whitespace="preserve">Asynchronously creates a new file and returns a stream for reading and
writing to it. The file must not already exist.
For more details, see g_file_create_readwrite() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then
call g_file_create_readwrite_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_readwrite_finish"
              c:identifier="g_file_create_readwrite_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file create operation started with
g_file_create_readwrite_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileIOStream or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="g_file_delete" throws="1">
        <doc xml:whitespace="preserve">Deletes a file. If the @file is a directory, it will only be deleted if it
is empty.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file was deleted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="g_file_dup">
        <doc xml:whitespace="preserve">Duplicates a #GFile handle. This operation does not duplicate
the actual file or directory represented by the #GFile; see
g_file_copy() if attempting to copy a file.
This call does no blocking i/o.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GFile that is a duplicate of the given #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </method>
      <method name="eject_mountable"
              c:identifier="g_file_eject_mountable"
              deprecated="Use g_file_eject_mountable_with_operation() instead."
              deprecated-version="2.22">
        <doc xml:whitespace="preserve">Starts an asynchronous eject on a mountable.
When this operation has completed, @callback will be called with
g_file_eject_mountable_finish().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_mountable_finish"
              c:identifier="g_file_eject_mountable_finish"
              deprecated="Use g_file_eject_mountable_with_operation_finish() instead."
              deprecated-version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous eject operation started by
g_file_eject_mountable().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @file was ejected successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_mountable_with_operation"
              c:identifier="g_file_eject_mountable_with_operation"
              version="2.22">
        <doc xml:whitespace="preserve">Starts an asynchronous eject on a mountable.
When this operation has completed, @callback will be called with
g_file_eject_mountable_with_operation_finish().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_mountable_with_operation_finish"
              c:identifier="g_file_eject_mountable_with_operation_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous eject operation started by
g_file_eject_mountable_with_operation().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @file was ejected successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_children"
              c:identifier="g_file_enumerate_children"
              throws="1">
        <doc xml:whitespace="preserve">Gets the requested information about the files in a directory. The result
is a #GFileEnumerator object that will give out #GFileInfo objects for
all the files in the directory.
The @attributes value is a string that specifies the file attributes that
should be gathered. It is not an error if it's not possible to read a particular
requested attribute from a file - it just won't be set. @attributes should
be a comma-separated list of attributes or attribute wildcards. The wildcard "*"
means all attributes, and a wildcard like "standard::*" means all attributes in the standard
namespace. An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like #G_FILE_ATTRIBUTE_STANDARD_NAME.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
If the file is not a directory, the G_FILE_ERROR_NOTDIR error will be returned.
Other errors are possible too.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GFileEnumerator if successful, %NULL on error.</doc>
          <type name="FileEnumerator" c:type="GFileEnumerator*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_children_async"
              c:identifier="g_file_enumerate_children_async">
        <doc xml:whitespace="preserve">Asynchronously gets the requested information about the files in a directory. The result
is a #GFileEnumerator object that will give out #GFileInfo objects for
all the files in the directory.
For more details, see g_file_enumerate_children() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_enumerate_children_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_children_finish"
              c:identifier="g_file_enumerate_children_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async enumerate children operation.
See g_file_enumerate_children_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileEnumerator or %NULL if an error occurred.</doc>
          <type name="FileEnumerator" c:type="GFileEnumerator*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="g_file_equal">
        <doc xml:whitespace="preserve">Checks equality of two given #GFile&lt;!-- --&gt;s. Note that two
#GFile&lt;!-- --&gt;s that differ can still refer to the same
file on the filesystem due to various forms of filename
aliasing.
This call does no blocking i/o.
%FALSE if either is not a #GFile.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @file1 and @file2 are equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="file2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_enclosing_mount"
              c:identifier="g_file_find_enclosing_mount"
              throws="1">
        <doc xml:whitespace="preserve">Gets a #GMount for the #GFile.
If the #GFileIface for @file does not have a mount (e.g. possibly a
remote share), @error will be set to %G_IO_ERROR_NOT_FOUND and %NULL
will be returned.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GMount where the @file is located or %NULL on error.</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_enclosing_mount_async"
              c:identifier="g_file_find_enclosing_mount_async">
        <doc xml:whitespace="preserve">Asynchronously gets the mount for the file.
For more details, see g_file_find_enclosing_mount() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_find_enclosing_mount_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_enclosing_mount_finish"
              c:identifier="g_file_find_enclosing_mount_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous find mount request.
See g_file_find_enclosing_mount_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GMount for given @file or %NULL on error.</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_basename" c:identifier="g_file_get_basename">
        <doc xml:whitespace="preserve">Gets the base name (the last component of the path) for a given #GFile.
If called for the top level of a system (such as the filesystem root
or a uri like sftp://host/) it will return a single directory separator
(and on Windows, possibly a drive letter).
The base name is a byte string (*not* UTF-8). It has no defined encoding
or rules other than it may not contain zero bytes.  If you want to use
filenames in a user interface you should use the display name that you
can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
attribute with g_file_query_info().
This call does no blocking i/o.
if given #GFile is invalid. The returned string should be
freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">string containing the #GFile's base name, or %NULL</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_child" c:identifier="g_file_get_child">
        <doc xml:whitespace="preserve">Gets a child of @file with basename equal to @name.
Note that the file with that specific name might not exist, but
you can still have a #GFile that points to it. You can use this
for instance to create that file.
This call does no blocking i/o.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile to a child specified by @name.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">string containing the child's basename.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_child_for_display_name"
              c:identifier="g_file_get_child_for_display_name"
              throws="1">
        <doc xml:whitespace="preserve">Gets the child of @file for a given @display_name (i.e. a UTF8
version of the name). If this function fails, it returns %NULL and @error will be
set. This is very useful when constructing a GFile for a new file
and the user entered the filename in the user interface, for instance
when you select a directory and type a filename in the file selector.
This call does no blocking i/o.
%NULL if the display name couldn't be converted.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile to the specified child, or</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">string to a possible child.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parent" c:identifier="g_file_get_parent">
        <doc xml:whitespace="preserve">Gets the parent directory for the @file.
If the @file represents the root directory of the
file system, then %NULL will be returned.
This call does no blocking i/o.
#GFile or %NULL if there is no parent.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile structure to the parent of the given</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </method>
      <method name="get_parse_name" c:identifier="g_file_get_parse_name">
        <doc xml:whitespace="preserve">Gets the parse name of the @file.
A parse name is a UTF-8 string that describes the
file such that one can get the #GFile back using
g_file_parse_name().
This is generally used to show the #GFile as a nice
full-pathname kind of string in a user interface,
like in a location entry.
For local files with names that can safely be converted
to UTF8 the pathname is used, otherwise the IRI is used
(a form of URI that allows UTF8 characters unescaped).
This call does no blocking i/o.
string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string containing the #GFile's parse name. The returned</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_path" c:identifier="g_file_get_path">
        <doc xml:whitespace="preserve">Gets the local pathname for #GFile, if one exists.
This call does no blocking i/o.
no such path exists. The returned string should be
freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">string containing the #GFile's path, or %NULL if</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_relative_path" c:identifier="g_file_get_relative_path">
        <doc xml:whitespace="preserve">Gets the path for @descendant relative to @parent.
This call does no blocking i/o.
to @parent, or %NULL if @descendant doesn't have @parent as prefix.
The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">string with the relative path from @descendant</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="descendant" transfer-ownership="none">
            <doc xml:whitespace="preserve">input #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uri" c:identifier="g_file_get_uri">
        <doc xml:whitespace="preserve">Gets the URI for the @file.
This call does no blocking i/o.
The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string containing the #GFile's URI.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_uri_scheme" c:identifier="g_file_get_uri_scheme">
        <doc xml:whitespace="preserve">Gets the URI scheme for a #GFile.
RFC 3986 decodes the scheme as:
&lt;programlisting&gt;
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
&lt;/programlisting&gt;
Common schemes include "file", "http", "ftp", etc.
This call does no blocking i/o.
#GFile. The returned string should be freed with g_free()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string containing the URI scheme for the given</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="has_parent"
              c:identifier="g_file_has_parent"
              version="2.24">
        <doc xml:whitespace="preserve">Checks if @file has a parent, and optionally, if it is @parent.
If @parent is %NULL then this function returns %TRUE if @file has any
parent at all.  If @parent is non-%NULL then %TRUE is only returned
if @file is a child of @parent.
case that @parent is %NULL).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @file is a child of @parent (or any parent in the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent to check for, or %NULL</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_prefix" c:identifier="g_file_has_prefix">
        <doc xml:whitespace="preserve">Checks whether @file has the prefix specified by @prefix. In other word,
if the names of inital elements of @file&lt;!-- --&gt;s pathname match @prefix.
Only full pathname elements are matched, so a path like /foo is not
considered a prefix of /foobar, only of /foo/bar.
This call does no i/o, as it works purely on names. As such it can
sometimes return %FALSE even if @file is inside a @prefix (from a
filesystem point of view), because the prefix of @file is an alias
of @prefix.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @files's parent, grandparent, etc is @prefix.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:whitespace="preserve">input #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_uri_scheme" c:identifier="g_file_has_uri_scheme">
        <doc xml:whitespace="preserve">Checks to see if a #GFile has a given URI scheme.
This call does no blocking i/o.
given URI scheme, %FALSE if URI scheme is %NULL,
not supported, or #GFile is invalid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if #GFile's backend supports the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri_scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a URI scheme.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="icon_new" c:identifier="g_file_icon_new">
        <doc xml:whitespace="preserve">Creates a new icon for a file.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIcon for the given @file, or %NULL on error.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </method>
      <method name="is_native" c:identifier="g_file_is_native">
        <doc xml:whitespace="preserve">Checks to see if a file is native to the platform.
A native file s one expressed in the platform-native filename format,
e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
as it might be on a locally mounted remote filesystem.
On some systems non-native files may be available using
the native filesystem via a userspace filesystem (FUSE), in
these cases this call will return %FALSE, but g_file_get_path()
will still return a native path.
This call does no blocking i/o.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if file is native.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="load_contents"
              c:identifier="g_file_load_contents"
              throws="1">
        <doc xml:whitespace="preserve">Loads the content of the file into memory. The data is always
zero-terminated, but this is not included in the resultant @length.
The returned @content should be freed with g_free() when no longer
needed.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
%FALSE if there were errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @file's contents were successfully loaded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="contents"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a location to place the contents of the file.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to place the length of the contents of the file, or %NULL if the length is not needed</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
          <parameter name="etag_out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to place the current entity tag for the file, or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_contents_async"
              c:identifier="g_file_load_contents_async">
        <doc xml:whitespace="preserve">Starts an asynchronous load of the @file's contents.
For more details, see g_file_load_contents() which is
the synchronous version of this call.
When the load operation has completed, @callback will be called
with @user data. To finish the operation, call
g_file_load_contents_finish() with the #GAsyncResult returned by
the @callback.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_contents_finish"
              c:identifier="g_file_load_contents_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous load of the @file's contents.
The contents are placed in @contents, and @length is set to the
size of the @contents string. The @content should be freed with
g_free() when no longer needed. If @etag_out is present, it will be
set to the new entity tag for the @file.
present, it will be set appropriately.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the load was successful. If %FALSE and @error is</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="contents"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a location to place the contents of the file.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to place the length of the contents of the file, or %NULL if the length is not needed</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
          <parameter name="etag_out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to place the current entity tag for the file, or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_partial_contents_async"
              c:identifier="g_file_load_partial_contents_async"
              introspectable="0">
        <doc xml:whitespace="preserve">Reads the partial contents of a file. A #GFileReadMoreCallback should be
used to stop reading from the file when appropriate, else this function
will behave exactly as g_file_load_contents_async(). This operation
can be finished by g_file_load_partial_contents_finish().
Users of this function should be aware that @user_data is passed to
both the @read_more_callback and the @callback.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="read_more_callback" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileReadMoreCallback to receive partial data and to specify whether further data should be read.</doc>
            <type name="FileReadMoreCallback" c:type="GFileReadMoreCallback"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to the callback functions.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_partial_contents_finish"
              c:identifier="g_file_load_partial_contents_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous partial load operation that was started
with g_file_load_partial_contents_async(). The data is always
zero-terminated, but this is not included in the resultant @length.
The returned @content should be freed with g_free() when no longer
needed.
present, it will be set appropriately.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the load was successful. If %FALSE and @error is</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="contents"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a location to place the contents of the file.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to place the length of the contents of the file, or %NULL if the length is not needed</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
          <parameter name="etag_out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to place the current entity tag for the file, or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_directory"
              c:identifier="g_file_make_directory"
              throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_directory_with_parents"
              c:identifier="g_file_make_directory_with_parents"
              version="2.18"
              throws="1">
        <doc xml:whitespace="preserve">Creates a directory and any parent directories that may not exist similar to
'mkdir -p'. If the file system does not support creating directories, this
function will fail, setting @error to %G_IO_ERROR_NOT_SUPPORTED.
For a local #GFile the newly created directories will have the default
(current) ownership and permissions of the current process.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if all directories have been successfully created, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_symbolic_link"
              c:identifier="g_file_make_symbolic_link"
              throws="1">
        <doc xml:whitespace="preserve">Creates a symbolic link named @file which contains the string
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on the creation of a new symlink, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="symlink_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string with the path for the target of the new symlink</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="monitor"
              c:identifier="g_file_monitor"
              version="2.18"
              throws="1">
        <doc xml:whitespace="preserve">Obtains a file or directory monitor for the given file, depending
on the type of the file.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileMonitor for the given @file, or %NULL on error.</doc>
          <type name="FileMonitor" c:type="GFileMonitor*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileMonitorFlags</doc>
            <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="monitor_directory"
              c:identifier="g_file_monitor_directory"
              throws="1">
        <doc xml:whitespace="preserve">Obtains a directory monitor for the given file.
This may fail if directory monitoring is not supported.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileMonitor for the given @file, or %NULL on error.</doc>
          <type name="FileMonitor" c:type="GFileMonitor*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileMonitorFlags.</doc>
            <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="monitor_file"
              c:identifier="g_file_monitor_file"
              throws="1">
        <doc xml:whitespace="preserve">Obtains a file monitor for the given file. If no file notification
mechanism exists, then regular polling of the file is used.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileMonitor for the given @file, or %NULL on error.</doc>
          <type name="FileMonitor" c:type="GFileMonitor*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileMonitorFlags.</doc>
            <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="mount_enclosing_volume"
              c:identifier="g_file_mount_enclosing_volume">
        <doc xml:whitespace="preserve">Starts a @mount_operation, mounting the volume that contains the file @location.
When this operation has completed, @callback will be called with
g_file_mount_enclosing_volume_finish().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="mount_enclosing_volume_finish"
              c:identifier="g_file_mount_enclosing_volume_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes a mount operation started by g_file_mount_enclosing_volume().
has occurred, this function will return %FALSE and set @error
appropriately if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful. If an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="mount_mountable" c:identifier="g_file_mount_mountable">
        <doc xml:whitespace="preserve">Mounts a file of type G_FILE_TYPE_MOUNTABLE.
Using @mount_operation, you can request callbacks when, for instance,
passwords are needed during authentication.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_mount_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="mount_mountable_finish"
              c:identifier="g_file_mount_mountable_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes a mount operation. See g_file_mount_mountable() for details.
Finish an asynchronous mount operation that was started
with g_file_mount_mountable().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile or %NULL on error.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="move"
              c:identifier="g_file_move"
              introspectable="0"
              throws="1">
        <doc xml:whitespace="preserve">Tries to move the file or directory @source to the location specified by @destination.
If native move operations are supported then this is used, otherwise a copy + delete
fallback is used. The native implementation may support moving directories (for instance
on moves inside the same filesystem), but the fallback code does not.
If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.
If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
will be copied as symlinks, otherwise the target of the
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If @progress_callback is not %NULL, then the operation can be monitored by
setting this to a #GFileProgressCallback function. @progress_callback_data
will be passed to this function. It is guaranteed that this callback will
be called after all data has been transferred with the total number of bytes
copied during the operation.
If the @source file does not exist then the G_IO_ERROR_NOT_FOUND
error is returned, independent on the status of the @destination.
If #G_FILE_COPY_OVERWRITE is not specified and the target exists, then the
error G_IO_ERROR_EXISTS is returned.
If trying to overwrite a file over a directory the G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
G_IO_ERROR_WOULD_MERGE error is returned.
If the source is a directory and the target does not exist, or #G_FILE_COPY_OVERWRITE is
specified and the target is a file, then the G_IO_ERROR_WOULD_RECURSE error
may be returned (if the native move operation isn't available).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on successful move, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GFile pointing to the destination location.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">set of #GFileCopyFlags.</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="progress_callback"
                     transfer-ownership="none"
                     closure="4">
            <doc xml:whitespace="preserve">#GFileProgressCallback function for updates.</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback"/>
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">gpointer to user data for the callback function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_readwrite"
              c:identifier="g_file_open_readwrite"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Opens an existing file for reading and writing. The result is
a #GFileIOStream that can be used to read and write the contents of the file.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be returned.
Other errors are possible too, and depend on what kind of filesystem the file is on.
Note that in many non-local file cases read and write streams are not supported,
so make sure you really need to do read and write streaming, rather than
just opening for reading or writing.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFileIOStream or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_readwrite_async"
              c:identifier="g_file_open_readwrite_async"
              version="2.22">
        <doc xml:whitespace="preserve">Asynchronously opens @file for reading and writing.
For more details, see g_file_open_readwrite() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_open_readwrite_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_readwrite_finish"
              c:identifier="g_file_open_readwrite_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file read operation started with
g_file_open_readwrite_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileIOStream or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="poll_mountable"
              c:identifier="g_file_poll_mountable"
              version="2.22">
        <doc xml:whitespace="preserve">Polls a file of type G_FILE_TYPE_MOUNTABLE.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_mount_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="poll_mountable_finish"
              c:identifier="g_file_poll_mountable_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes a poll operation. See g_file_poll_mountable() for details.
Finish an asynchronous poll operation that was polled
with g_file_poll_mountable().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_default_handler"
              c:identifier="g_file_query_default_handler"
              throws="1">
        <doc xml:whitespace="preserve">Returns the #GAppInfo that is registered as the default
application to handle the file specified by @file.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When you are done with it, release it with g_object_unref()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GAppInfo if the handle was found, %NULL if there were errors.</doc>
          <type name="AppInfo" c:type="GAppInfo*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_exists" c:identifier="g_file_query_exists">
        <doc xml:whitespace="preserve">Utility function to check if a particular file exists. This is
implemented using g_file_query_info() and as such does blocking I/O.
Note that in many cases it is racy to first check for file existence
and then execute something based on the outcome of that, because the
file might have been created or removed in between the operations. The
general approach to handling that is to not check, but just do the
operation and handle the errors as they come.
As an example of race-free checking, take the case of reading a file, and
can both result in two processes creating the file (with perhaps a partially
written file as the result). The correct approach is to always try to create
the file with g_file_create() which will either atomically create the file
or fail with a G_IO_ERROR_EXISTS error.
However, in many cases an existence check is useful in a user
interface, for instance to make a menu item sensitive/insensitive, so that
you don't have to fool users that something is possible and then just show
and error dialog. If you do this, you should make sure to also handle the
errors that can happen due to races when you execute the operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file exists (and can be detected without error), %FALSE otherwise (or if cancelled).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_file_type"
              c:identifier="g_file_query_file_type"
              version="2.18">
        <doc xml:whitespace="preserve">Utility function to inspect the #GFileType of a file. This is
implemented using g_file_query_info() and as such does blocking I/O.
The primary use case of this method is to check if a file is a regular file,
directory, or symlink.
does not exist</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GFileType of the file and #G_FILE_TYPE_UNKNOWN if the file</doc>
          <type name="FileType" c:type="GFileType"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags passed to g_file_query_info().</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_filesystem_info"
              c:identifier="g_file_query_filesystem_info"
              throws="1">
        <doc xml:whitespace="preserve">Similar to g_file_query_info(), but obtains information
about the filesystem the @file is on, rather than the file itself.
For instance the amount of space available and the type of
the filesystem.
The @attributes value is a string that specifies the file attributes that
should be gathered. It is not an error if it's not possible to read a particular
requested attribute from a file - it just won't be set. @attributes should
be a comma-separated list of attributes or attribute wildcards. The wildcard "*"
means all attributes, and a wildcard like "fs:*" means all attributes in the fs
namespace. The standard namespace for filesystem attributes is "fs".
Common attributes of interest are #G_FILE_ATTRIBUTE_FILESYSTEM_SIZE
(the total size of the filesystem in bytes), #G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of
bytes available), and #G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
Other errors are possible too, and depend on what kind of filesystem the file is on.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInfo or %NULL if there was an error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_filesystem_info_async"
              c:identifier="g_file_query_filesystem_info_async">
        <doc xml:whitespace="preserve">Asynchronously gets the requested information about the filesystem
that the specified @file is on. The result is a #GFileInfo object
that contains key-value attributes (such as type or size for the
file).
For more details, see g_file_query_filesystem_info() which is the
synchronous version of this call.
When the operation is finished, @callback will be called. You can
then call g_file_query_info_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_filesystem_info_finish"
              c:identifier="g_file_query_filesystem_info_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous filesystem info query.  See
g_file_query_filesystem_info_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFileInfo for given @file or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info" c:identifier="g_file_query_info" throws="1">
        <doc xml:whitespace="preserve">Gets the requested information about specified @file. The result
is a #GFileInfo object that contains key-value attributes (such as
the type or size of the file).
The @attributes value is a string that specifies the file attributes that
should be gathered. It is not an error if it's not possible to read a particular
requested attribute from a file - it just won't be set. @attributes should
be a comma-separated list of attributes or attribute wildcards. The wildcard "*"
means all attributes, and a wildcard like "standard::*" means all attributes in the standard
namespace. An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like #G_FILE_ATTRIBUTE_STANDARD_NAME.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
For symlinks, normally the information about the target of the
symlink is returned, rather than information about the symlink itself.
However if you pass #G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in @flags the
information about the symlink itself will be returned. Also, for symlinks
that point to non-existing files the information about the symlink itself
will be returned.
If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
Other errors are possible too, and depend on what kind of filesystem the file is on.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInfo for the given @file, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_async" c:identifier="g_file_query_info_async">
        <doc xml:whitespace="preserve">Asynchronously gets the requested information about specified @file. The result
is a #GFileInfo object that contains key-value attributes (such as type or size
for the file).
For more details, see g_file_query_info() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_query_info_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_finish"
              c:identifier="g_file_query_info_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file info query.
See g_file_query_info_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFileInfo for given @file or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_settable_attributes"
              c:identifier="g_file_query_settable_attributes"
              throws="1">
        <doc xml:whitespace="preserve">Obtain the list of settable attributes for the file.
Returns the type and full attribute name of all the attributes
that can be set on this file. This doesn't mean setting it will always
succeed though, you might get an access failure, or some specific
file may not support a specific attribute.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When you are done with it, release it with g_file_attribute_info_list_unref()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileAttributeInfoList describing the settable attributes.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_writable_namespaces"
              c:identifier="g_file_query_writable_namespaces"
              throws="1">
        <doc xml:whitespace="preserve">Obtain the list of attribute namespaces where new attributes
can be created by a user. An example of this is extended
attributes (in the "xattr" namespace).
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When you are done with it, release it with g_file_attribute_info_list_unref()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileAttributeInfoList describing the writable namespaces.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="g_file_read" throws="1">
        <doc xml:whitespace="preserve">Opens a file for reading. The result is a #GFileInputStream that
can be used to read the contents of the file.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be returned.
Other errors are possible too, and depend on what kind of filesystem the file is on.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFileInputStream or %NULL on error.</doc>
          <type name="FileInputStream" c:type="GFileInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_async" c:identifier="g_file_read_async">
        <doc xml:whitespace="preserve">Asynchronously opens @file for reading.
For more details, see g_file_read() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_read_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_finish" c:identifier="g_file_read_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file read operation started with
g_file_read_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInputStream or %NULL on error.</doc>
          <type name="FileInputStream" c:type="GFileInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace" c:identifier="g_file_replace" throws="1">
        <doc xml:whitespace="preserve">Returns an output stream for overwriting the file, possibly
creating a backup copy of the file first. If the file doesn't exist,
it will be created.
This will try to replace the file in the safest way possible so
that any errors during the writing will not affect an already
existing copy of the file. For instance, for local files it
may write to a temporary file and then atomically rename over
the destination when the stream is closed.
By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If you pass in a non-#NULL @etag value, then this value is
compared to the current entity tag of the file, and if they differ
an G_IO_ERROR_WRONG_ETAG error is returned. This generally means
that the file has been changed since you last read it. You can get
the new etag from g_file_output_stream_get_etag() after you've
finished writing and closed the #GFileOutputStream. When you load
a new file you can use g_file_input_stream_query_info() to get
the etag of the file.
If @make_backup is %TRUE, this function will attempt to make a backup
of the current file before overwriting it. If this fails a G_IO_ERROR_CANT_CREATE_BACKUP
error will be returned. If you want to replace anyway, try again with
If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be returned,
and if the file is some other form of non-regular file then a
G_IO_ERROR_NOT_REGULAR_FILE error will be returned.
Some file systems don't allow all file names, and may
return an G_IO_ERROR_INVALID_FILENAME error, and if the name
is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.
Other errors are possible too, and depend on what kind of
filesystem the file is on.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileOutputStream or %NULL on error.</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="etag" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an optional &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or #NULL to ignore.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if a backup should be created.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_async" c:identifier="g_file_replace_async">
        <doc xml:whitespace="preserve">Asynchronously overwrites the file, replacing the contents, possibly
creating a backup copy of the file first.
For more details, see g_file_replace() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_replace_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="etag" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or NULL to ignore.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if a backup should be created.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="6">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_contents"
              c:identifier="g_file_replace_contents"
              throws="1">
        <doc xml:whitespace="preserve">Replaces the contents of @file with @contents of @length bytes.
If @etag is specified (not %NULL) any existing file must have that etag, or
the error %G_IO_ERROR_WRONG_ETAG will be returned.
If @make_backup is %TRUE, this function will attempt to make a backup of @file.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
The returned @new_etag can be used to verify that the file hasn't changed the
next time it is saved over.
has occurred, this function will return %FALSE and set @error
appropriately if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful. If an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="contents" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the new contents for @file.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of @contents in bytes.</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="etag" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the old &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the document, or %NULL</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if a backup should be created.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="new_etag"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to a new &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the document. This should be freed with g_free() when no longer needed, or %NULL</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_contents_async"
              c:identifier="g_file_replace_contents_async">
        <doc xml:whitespace="preserve">Starts an asynchronous replacement of @file with the given
current entity tag.
When this operation has completed, @callback will be called with
g_file_replace_contents_finish().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
If @make_backup is %TRUE, this function will attempt to
make a backup of @file.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="contents" transfer-ownership="none">
            <doc xml:whitespace="preserve">string of contents to replace the file with.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of @contents in bytes.</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="etag" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a new &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the @file, or %NULL</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if a backup should be created.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="7">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_contents_finish"
              c:identifier="g_file_replace_contents_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous replace of the given @file. See
g_file_replace_contents_async(). Sets @new_etag to the new entity
tag for the document, if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on failure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="new_etag"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location of a new &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the document. This should be freed with g_free() when it is no longer needed, or %NULL</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_finish"
              c:identifier="g_file_replace_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file replace operation started with
g_file_replace_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileOutputStream, or %NULL on error.</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_readwrite"
              c:identifier="g_file_replace_readwrite"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Returns an output stream for overwriting the file in readwrite mode,
possibly creating a backup copy of the file first. If the file doesn't
exist, it will be created.
For details about the behaviour, see g_file_replace() which does the same
thing but returns an output stream only.
Note that in many non-local file cases read and write streams are not
supported, so make sure you really need to do read and write streaming,
rather than just opening for reading or writing.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileIOStream or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="etag" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an optional &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_readwrite_async"
              c:identifier="g_file_replace_readwrite_async"
              version="2.22">
        <doc xml:whitespace="preserve">Asynchronously overwrites the file in read-write mode, replacing the
contents, possibly creating a backup copy of the file first.
For more details, see g_file_replace_readwrite() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then
call g_file_replace_readwrite_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="etag" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or NULL to ignore.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="make_backup" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if a backup should be created.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="6">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_readwrite_finish"
              c:identifier="g_file_replace_readwrite_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous file replace operation started with
g_file_replace_readwrite_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileIOStream, or %NULL on error.</doc>
          <type name="FileIOStream" c:type="GFileIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="resolve_relative_path"
              c:identifier="g_file_resolve_relative_path">
        <doc xml:whitespace="preserve">Resolves a relative path for @file to an absolute path.
This call does no blocking i/o.
is %NULL or if @file is invalid.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFile to the resolved path. %NULL if @relative_path</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="relative_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">a given relative path string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute"
              c:identifier="g_file_set_attribute"
              throws="1">
        <doc xml:whitespace="preserve">Sets an attribute in the file with attribute name @attribute to @value.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the attribute was set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the attribute's name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type of the attribute</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType"/>
          </parameter>
          <parameter name="value_p" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to the value (or the pointer itself if the type is a pointer type)</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_byte_string"
              c:identifier="g_file_set_attribute_byte_string"
              throws="1">
        <doc xml:whitespace="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value.
If @attribute is of a different type, this operation will fail,
returning %FALSE.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
in the @file, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @attribute was successfully set to @value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the attribute's name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the attribute's new value.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_int32"
              c:identifier="g_file_set_attribute_int32"
              throws="1">
        <doc xml:whitespace="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT32 to @value.
If @attribute is of a different type, this operation will fail.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
in the @file, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @attribute was successfully set to @value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the attribute's name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gint32 containing the attribute's new value.</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_int64"
              c:identifier="g_file_set_attribute_int64"
              throws="1">
        <doc xml:whitespace="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT64 to @value.
If @attribute is of a different type, this operation will fail.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @attribute was successfully set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the attribute's name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #guint64 containing the attribute's new value.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_string"
              c:identifier="g_file_set_attribute_string"
              throws="1">
        <doc xml:whitespace="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_STRING to @value.
If @attribute is of a different type, this operation will fail.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @attribute was successfully set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the attribute's name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the attribute's value.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_uint32"
              c:identifier="g_file_set_attribute_uint32"
              throws="1">
        <doc xml:whitespace="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to @value.
If @attribute is of a different type, this operation will fail.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
in the @file, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @attribute was successfully set to @value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the attribute's name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #guint32 containing the attribute's new value.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_uint64"
              c:identifier="g_file_set_attribute_uint64"
              throws="1">
        <doc xml:whitespace="preserve">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to @value.
If @attribute is of a different type, this operation will fail.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
in the @file, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @attribute was successfully set to @value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing the attribute's name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #guint64 containing the attribute's new value.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attributes_async"
              c:identifier="g_file_set_attributes_async">
        <doc xml:whitespace="preserve">Asynchronously sets the attributes of @file with @info.
For more details, see g_file_set_attributes_from_info() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_set_attributes_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileQueryInfoFlags.</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gpointer.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attributes_finish"
              c:identifier="g_file_set_attributes_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes setting an attribute started in g_file_set_attributes_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the attributes were set correctly, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="info"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attributes_from_info"
              c:identifier="g_file_set_attributes_from_info"
              throws="1">
        <doc xml:whitespace="preserve">Tries to set all attributes in the #GFileInfo on the target values,
not stopping on the first error.
If there is any error during this operation then @error will be set to
the first error. Error on particular fields are flagged by setting
the "status" field in the attribute value to
%G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect
further errors.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if there was any error, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name"
              c:identifier="g_file_set_display_name"
              throws="1">
        <doc xml:whitespace="preserve">Renames @file to the specified display name.
The display name is converted from UTF8 to the correct encoding for the target
filesystem if possible and the @file is renamed to this.
If you want to implement a rename operation in the user interface the edit name
(#G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial value in the rename
widget, and then the result after editing should be passed to g_file_set_display_name().
On success the resulting converted filename is returned.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
if there was an error.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile specifying what @file was renamed to, or %NULL</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_async"
              c:identifier="g_file_set_display_name_async">
        <doc xml:whitespace="preserve">Asynchronously sets the display name for a given #GFile.
For more details, see g_file_set_display_name() which is
the synchronous version of this call.
When the operation is finished, @callback will be called. You can then call
g_file_set_display_name_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_finish"
              c:identifier="g_file_set_display_name_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes setting a display name started with
g_file_set_display_name_async().
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile or %NULL on error.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_mountable"
              c:identifier="g_file_start_mountable"
              version="2.22">
        <doc xml:whitespace="preserve">Starts a file of type G_FILE_TYPE_MOUNTABLE.
Using @start_operation, you can request callbacks when, for instance,
passwords are needed during authentication.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_mount_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
          </parameter>
          <parameter name="start_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_mountable_finish"
              c:identifier="g_file_start_mountable_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes a start operation. See g_file_start_mountable() for details.
Finish an asynchronous start operation that was started
with g_file_start_mountable().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop_mountable"
              c:identifier="g_file_stop_mountable"
              version="2.22">
        <doc xml:whitespace="preserve">Stops a file of type G_FILE_TYPE_MOUNTABLE.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_stop_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop_mountable_finish"
              c:identifier="g_file_stop_mountable_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an stop operation, see g_file_stop_mountable() for details.
Finish an asynchronous stop operation that was started
with g_file_stop_mountable().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_thread_contexts"
              c:identifier="g_file_supports_thread_contexts"
              version="2.22">
        <doc xml:whitespace="preserve">Checks if @file supports &lt;link
linkend="g-main-context-push-thread-default-context"&gt;thread-default
contexts&lt;/link&gt;. If this returns %FALSE, you cannot perform
asynchronous operations on @file in a thread that has a
thread-default context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether or not @file supports thread-default contexts.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="trash" c:identifier="g_file_trash" throws="1">
        <doc xml:whitespace="preserve">Sends @file to the "Trashcan", if possible. This is similar to
deleting it, but the user can recover it before emptying the trashcan.
Not all file systems support trashing, so this call can return the
%G_IO_ERROR_NOT_SUPPORTED error.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on successful trash, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_mountable"
              c:identifier="g_file_unmount_mountable"
              deprecated="Use g_file_unmount_mountable_with_operation() instead."
              deprecated-version="2.22">
        <doc xml:whitespace="preserve">Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_unmount_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_mountable_finish"
              c:identifier="g_file_unmount_mountable_finish"
              deprecated="Use g_file_unmount_mountable_with_operation_finish() instead."
              deprecated-version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an unmount operation, see g_file_unmount_mountable() for details.
Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_mountable_with_operation"
              c:identifier="g_file_unmount_mountable_with_operation"
              version="2.22">
        <doc xml:whitespace="preserve">Unmounts a file of type G_FILE_TYPE_MOUNTABLE.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
When the operation is finished, @callback will be called. You can then call
g_file_unmount_mountable_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_mountable_with_operation_finish"
              c:identifier="g_file_unmount_mountable_with_operation_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details.
Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable_with_operation().
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="FileAttributeInfo" c:type="GFileAttributeInfo">
      <doc xml:whitespace="preserve">Information about a specific attribute.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="type" writable="1">
        <type name="FileAttributeType" c:type="GFileAttributeType"/>
      </field>
      <field name="flags" writable="1">
        <type name="FileAttributeInfoFlags" c:type="GFileAttributeInfoFlags"/>
      </field>
    </record>
    <bitfield name="FileAttributeInfoFlags"
              glib:type-name="GFileAttributeInfoFlags"
              glib:get-type="g_file_attribute_info_flags_get_type"
              c:type="GFileAttributeInfoFlags">
      <doc xml:whitespace="preserve">Flags specifying the behaviour of an attribute.</doc>
      <member name="none"
              value="0"
              c:identifier="G_FILE_ATTRIBUTE_INFO_NONE"
              glib:nick="none"/>
      <member name="copy_with_file"
              value="1"
              c:identifier="G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE"
              glib:nick="copy-with-file"/>
      <member name="copy_when_moved"
              value="2"
              c:identifier="G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED"
              glib:nick="copy-when-moved"/>
    </bitfield>
    <record name="FileAttributeInfoList"
            c:type="GFileAttributeInfoList"
            glib:type-name="GFileAttributeInfoList"
            glib:get-type="g_file_attribute_info_list_get_type"
            c:symbol-prefix="file_attribute_info_list">
      <doc xml:whitespace="preserve">Acts as a lightweight registry for possible valid file attributes.
The registry stores Key-Value pair formats as #GFileAttributeInfo&lt;!-- --&gt;s.</doc>
      <field name="infos" writable="1">
        <type name="FileAttributeInfo" c:type="GFileAttributeInfo*"/>
      </field>
      <field name="n_infos" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <constructor name="new" c:identifier="g_file_attribute_info_list_new">
        <doc xml:whitespace="preserve">Creates a new file attribute info list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileAttributeInfoList.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="g_file_attribute_info_list_add">
        <doc xml:whitespace="preserve">Adds a new attribute with @name to the @list, setting
its @type and @flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the attribute to add.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GFileAttributeType for the attribute.</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GFileAttributeInfoFlags for the attribute.</doc>
            <type name="FileAttributeInfoFlags"
                  c:type="GFileAttributeInfoFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="g_file_attribute_info_list_dup">
        <doc xml:whitespace="preserve">Makes a duplicate of a file attribute info list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a copy of the given @list.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
      </method>
      <method name="lookup" c:identifier="g_file_attribute_info_list_lookup">
        <doc xml:whitespace="preserve">Gets the file attribute with the name @name from @list.
attribute isn't found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GFileAttributeInfo for the @name, or %NULL if an</doc>
          <type name="FileAttributeInfo" c:type="GFileAttributeInfo*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the attribute to lookup.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_file_attribute_info_list_ref">
        <doc xml:whitespace="preserve">References a file attribute info list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFileAttributeInfoList or %NULL on error.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*"/>
        </return-value>
      </method>
      <method name="unref" c:identifier="g_file_attribute_info_list_unref">
        <doc xml:whitespace="preserve">Removes a reference from the given @list. If the reference count
falls to zero, the @list is deleted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="FileAttributeMatcher"
            c:type="GFileAttributeMatcher"
            glib:type-name="GFileAttributeMatcher"
            glib:get-type="g_file_attribute_matcher_get_type"
            c:symbol-prefix="file_attribute_matcher">
      <doc xml:whitespace="preserve">Determines if a string matches a file attribute.</doc>
      <constructor name="new" c:identifier="g_file_attribute_matcher_new">
        <doc xml:whitespace="preserve">Creates a new file attribute matcher, which matches attributes
against a given string. #GFileAttributeMatcher&lt;!-- --&gt;s are reference
counted structures, and are created with a reference count of 1. If
the number of references falls to 0, the #GFileAttributeMatcher is
automatically destroyed.
The @attribute string should be formatted with specific keys separated
from namespaces with a double colon. Several "namespace::key" strings may be
concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
The wildcard "*" may be used to match all keys and namespaces, or
"namespace::*" will match all keys in a given namespace.
Examples of strings to use:
&lt;table&gt;
&lt;title&gt;File Attribute Matcher strings and results&lt;/title&gt;
&lt;tgroup cols='2' align='left'&gt;&lt;thead&gt;
&lt;row&gt;&lt;entry&gt; Matcher String &lt;/entry&gt;&lt;entry&gt; Matches &lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;
&lt;tbody&gt;
&lt;row&gt;&lt;entry&gt;"*"&lt;/entry&gt;&lt;entry&gt;matches all attributes.&lt;/entry&gt;&lt;/row&gt;
&lt;row&gt;&lt;entry&gt;"standard::is-hidden"&lt;/entry&gt;&lt;entry&gt;matches only the key is-hidden in the standard namespace.&lt;/entry&gt;&lt;/row&gt;
&lt;row&gt;&lt;entry&gt;"standard::type,unix::*"&lt;/entry&gt;&lt;entry&gt;matches the type key in the standard namespace and
all keys in the unix namespace.&lt;/entry&gt;&lt;/row&gt;
&lt;/tbody&gt;&lt;/tgroup&gt;
&lt;/table&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileAttributeMatcher.</doc>
          <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an attribute string to match.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="enumerate_namespace"
              c:identifier="g_file_attribute_matcher_enumerate_namespace">
        <doc xml:whitespace="preserve">Checks if the matcher will match all of the keys in a given namespace.
This will always return %TRUE if a wildcard character is in use (e.g. if
matcher was created with "standard::*" and @ns is "standard", or if matcher was created
using "*" and namespace is anything.)
in the given @ns, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the matcher matches all of the entries</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="ns" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a file attribute namespace.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_next"
              c:identifier="g_file_attribute_matcher_enumerate_next">
        <doc xml:whitespace="preserve">Gets the next matched attribute from a #GFileAttributeMatcher.
no more attribute exist.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the next attribute or %NULL if</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="matches" c:identifier="g_file_attribute_matcher_matches">
        <doc xml:whitespace="preserve">Checks if an attribute will be matched by an attribute matcher. If
the matcher was created with the "*" matching string, this function
will always return %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @attribute matches @matcher. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="matches_only"
              c:identifier="g_file_attribute_matcher_matches_only">
        <doc xml:whitespace="preserve">Checks if a attribute matcher only matches a given attribute. Always
returns %FALSE if "*" was used when creating the matcher.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the matcher only matches @attribute. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_file_attribute_matcher_ref">
        <doc xml:whitespace="preserve">References a file attribute matcher.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileAttributeMatcher.</doc>
          <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
        </return-value>
      </method>
      <method name="unref" c:identifier="g_file_attribute_matcher_unref">
        <doc xml:whitespace="preserve">Unreferences @matcher. If the reference count falls below 1,
the @matcher is automatically freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <enumeration name="FileAttributeStatus"
                 glib:type-name="GFileAttributeStatus"
                 glib:get-type="g_file_attribute_status_get_type"
                 c:type="GFileAttributeStatus">
      <doc xml:whitespace="preserve">Used by g_file_set_attributes_from_info() when setting file attributes.</doc>
      <member name="unset"
              value="0"
              c:identifier="G_FILE_ATTRIBUTE_STATUS_UNSET"
              glib:nick="unset"/>
      <member name="set"
              value="1"
              c:identifier="G_FILE_ATTRIBUTE_STATUS_SET"
              glib:nick="set"/>
      <member name="error_setting"
              value="2"
              c:identifier="G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING"
              glib:nick="error-setting"/>
    </enumeration>
    <enumeration name="FileAttributeType"
                 glib:type-name="GFileAttributeType"
                 glib:get-type="g_file_attribute_type_get_type"
                 c:type="GFileAttributeType">
      <doc xml:whitespace="preserve">The data types for file attributes.</doc>
      <member name="invalid"
              value="0"
              c:identifier="G_FILE_ATTRIBUTE_TYPE_INVALID"
              glib:nick="invalid"/>
      <member name="string"
              value="1"
              c:identifier="G_FILE_ATTRIBUTE_TYPE_STRING"
              glib:nick="string"/>
      <member name="byte_string"
              value="2"
              c:identifier="G_FILE_ATTRIBUTE_TYPE_BYTE_STRING"
              glib:nick="byte-string"/>
      <member name="boolean"
              value="3"
              c:identifier="G_FILE_ATTRIBUTE_TYPE_BOOLEAN"
              glib:nick="boolean"/>
      <member name="uint32"
              value="4"
              c:identifier="G_FILE_ATTRIBUTE_TYPE_UINT32"
              glib:nick="uint32"/>
      <member name="int32"
              value="5"
              c:identifier="G_FILE_ATTRIBUTE_TYPE_INT32"
              glib:nick="int32"/>
      <member name="uint64"
              value="6"
              c:identifier="G_FILE_ATTRIBUTE_TYPE_UINT64"
              glib:nick="uint64"/>
      <member name="int64"
              value="7"
              c:identifier="G_FILE_ATTRIBUTE_TYPE_INT64"
              glib:nick="int64"/>
      <member name="object"
              value="8"
              c:identifier="G_FILE_ATTRIBUTE_TYPE_OBJECT"
              glib:nick="object"/>
      <member name="stringv"
              value="9"
              c:identifier="G_FILE_ATTRIBUTE_TYPE_STRINGV"
              glib:nick="stringv"/>
    </enumeration>
    <bitfield name="FileCopyFlags"
              glib:type-name="GFileCopyFlags"
              glib:get-type="g_file_copy_flags_get_type"
              c:type="GFileCopyFlags">
      <doc xml:whitespace="preserve">Flags used when copying or moving files.</doc>
      <member name="none"
              value="0"
              c:identifier="G_FILE_COPY_NONE"
              glib:nick="none"/>
      <member name="overwrite"
              value="1"
              c:identifier="G_FILE_COPY_OVERWRITE"
              glib:nick="overwrite"/>
      <member name="backup"
              value="2"
              c:identifier="G_FILE_COPY_BACKUP"
              glib:nick="backup"/>
      <member name="nofollow_symlinks"
              value="4"
              c:identifier="G_FILE_COPY_NOFOLLOW_SYMLINKS"
              glib:nick="nofollow-symlinks"/>
      <member name="all_metadata"
              value="8"
              c:identifier="G_FILE_COPY_ALL_METADATA"
              glib:nick="all-metadata"/>
      <member name="no_fallback_for_move"
              value="16"
              c:identifier="G_FILE_COPY_NO_FALLBACK_FOR_MOVE"
              glib:nick="no-fallback-for-move"/>
      <member name="target_default_perms"
              value="32"
              c:identifier="G_FILE_COPY_TARGET_DEFAULT_PERMS"
              glib:nick="target-default-perms"/>
    </bitfield>
    <bitfield name="FileCreateFlags"
              glib:type-name="GFileCreateFlags"
              glib:get-type="g_file_create_flags_get_type"
              c:type="GFileCreateFlags">
      <doc xml:whitespace="preserve">Flags used when an operation may create a file.</doc>
      <member name="none"
              value="0"
              c:identifier="G_FILE_CREATE_NONE"
              glib:nick="none"/>
      <member name="private"
              value="1"
              c:identifier="G_FILE_CREATE_PRIVATE"
              glib:nick="private"/>
      <member name="replace_destination"
              value="2"
              c:identifier="G_FILE_CREATE_REPLACE_DESTINATION"
              glib:nick="replace-destination"/>
    </bitfield>
    <interface name="FileDescriptorBased"
               c:symbol-prefix="file_descriptor_based"
               c:type="GFileDescriptorBased"
               glib:type-name="GFileDescriptorBased"
               glib:get-type="g_file_descriptor_based_get_type"
               glib:type-struct="FileDescriptorBasedIface">
      <doc xml:whitespace="preserve">An interface for file descriptor based io objects.</doc>
      <virtual-method name="get_fd" invoker="get_fd" version="2.24">
        <doc xml:whitespace="preserve">Gets the underlying file descriptor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The file descriptor</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </virtual-method>
      <method name="get_fd"
              c:identifier="g_file_descriptor_based_get_fd"
              version="2.24">
        <doc xml:whitespace="preserve">Gets the underlying file descriptor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The file descriptor</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
    </interface>
    <record name="FileDescriptorBasedIface"
            c:type="GFileDescriptorBasedIface"
            glib:is-gtype-struct-for="FileDescriptorBased">
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_fd">
        <callback name="get_fd">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">The file descriptor</doc>
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="fd_based" transfer-ownership="none">
              <type name="FileDescriptorBased" c:type="GFileDescriptorBased*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="FileEnumerator"
           c:symbol-prefix="file_enumerator"
           c:type="GFileEnumerator"
           parent="GObject.Object"
           glib:type-name="GFileEnumerator"
           glib:get-type="g_file_enumerator_get_type"
           glib:type-struct="FileEnumeratorClass">
      <doc xml:whitespace="preserve">A per matched file iterator.</doc>
      <virtual-method name="close_async" invoker="close_async">
        <doc xml:whitespace="preserve">Asynchronously closes the file enumerator.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
g_file_enumerator_close_finish().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_finish" invoker="close_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes closing a file enumerator, started from g_file_enumerator_close_async().
If the file enumerator was already closed when g_file_enumerator_close_async()
was called, then this function will report %G_IO_ERROR_CLOSED in @error, and
return %FALSE. If the file enumerator had pending operation when the close
operation was started, then this function will report %G_IO_ERROR_PENDING, and
return %FALSE.  If @cancellable was not %NULL, then the operation may have been
cancelled by triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the close operation has finished successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_file" invoker="next_file" throws="1">
        <doc xml:whitespace="preserve">Returns information for the next file in the enumerated object.
Will block until the information is available. The #GFileInfo
returned from this function will contain attributes that match the
attribute string that was passed when the #GFileEnumerator was created.
On error, returns %NULL and sets @error to the error. If the
enumerator is at the end, %NULL will be returned and @error will
be unset.
Free the returned object with g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GFileInfo or %NULL on error or end of enumerator.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_files_async" invoker="next_files_async">
        <doc xml:whitespace="preserve">Request information for a number of files from the enumerator asynchronously.
When all i/o for the operation is finished the @callback will be called with
the requested information.
The callback can be called with less than @num_files files in case of error
or at the end of the enumerator. In case of a partial error the callback will
be called with any succeeding items and no error, and on the next request the
error will be reported. If a request is cancelled the callback will be called
with %G_IO_ERROR_CANCELLED.
During an async request no other sync and async calls are allowed, and will
result in %G_IO_ERROR_PENDING errors.
Any outstanding i/o request with higher priority (lower numerical value) will
be executed before an outstanding request with lower priority. Default
priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="num_files" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of file info objects to request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="gioscheduler"&gt;io priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_files_finish"
                      invoker="next_files_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
g_list_free() and unref the infos with g_object_unref() when you're
done with them.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GFileInfo&lt;!----&gt;s. You must free the list with</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="FileInfo"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="close" c:identifier="g_file_enumerator_close" throws="1">
        <doc xml:whitespace="preserve">Releases all resources used by this enumerator, making the
enumerator return %G_IO_ERROR_CLOSED on all calls.
This will be automatically called when the last reference
is dropped, but you might want to call this function to make
sure resources are released as early as possible.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE on success or #FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async" c:identifier="g_file_enumerator_close_async">
        <doc xml:whitespace="preserve">Asynchronously closes the file enumerator.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned in
g_file_enumerator_close_finish().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish"
              c:identifier="g_file_enumerator_close_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes closing a file enumerator, started from g_file_enumerator_close_async().
If the file enumerator was already closed when g_file_enumerator_close_async()
was called, then this function will report %G_IO_ERROR_CLOSED in @error, and
return %FALSE. If the file enumerator had pending operation when the close
operation was started, then this function will report %G_IO_ERROR_PENDING, and
return %FALSE.  If @cancellable was not %NULL, then the operation may have been
cancelled by triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %FALSE will be
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the close operation has finished successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_container"
              c:identifier="g_file_enumerator_get_container"
              version="2.18">
        <doc xml:whitespace="preserve">Get the #GFile container which is being enumerated.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GFile which is being enumerated.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </method>
      <method name="has_pending" c:identifier="g_file_enumerator_has_pending">
        <doc xml:whitespace="preserve">Checks if the file enumerator has pending operations.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @enumerator has pending operations.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_closed" c:identifier="g_file_enumerator_is_closed">
        <doc xml:whitespace="preserve">Checks if the file enumerator has been closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @enumerator is closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="next_file"
              c:identifier="g_file_enumerator_next_file"
              throws="1">
        <doc xml:whitespace="preserve">Returns information for the next file in the enumerated object.
Will block until the information is available. The #GFileInfo
returned from this function will contain attributes that match the
attribute string that was passed when the #GFileEnumerator was created.
On error, returns %NULL and sets @error to the error. If the
enumerator is at the end, %NULL will be returned and @error will
be unset.
Free the returned object with g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GFileInfo or %NULL on error or end of enumerator.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_files_async"
              c:identifier="g_file_enumerator_next_files_async">
        <doc xml:whitespace="preserve">Request information for a number of files from the enumerator asynchronously.
When all i/o for the operation is finished the @callback will be called with
the requested information.
The callback can be called with less than @num_files files in case of error
or at the end of the enumerator. In case of a partial error the callback will
be called with any succeeding items and no error, and on the next request the
error will be reported. If a request is cancelled the callback will be called
with %G_IO_ERROR_CANCELLED.
During an async request no other sync and async calls are allowed, and will
result in %G_IO_ERROR_PENDING errors.
Any outstanding i/o request with higher priority (lower numerical value) will
be executed before an outstanding request with lower priority. Default
priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="num_files" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of file info objects to request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="gioscheduler"&gt;io priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_files_finish"
              c:identifier="g_file_enumerator_next_files_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes the asynchronous operation started with g_file_enumerator_next_files_async().
g_list_free() and unref the infos with g_object_unref() when you're
done with them.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GFileInfo&lt;!----&gt;s. You must free the list with</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="FileInfo"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pending" c:identifier="g_file_enumerator_set_pending">
        <doc xml:whitespace="preserve">Sets the file enumerator as having pending operations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a boolean value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="container"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="File"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="FileEnumeratorPrivate" c:type="GFileEnumeratorPrivate*"/>
      </field>
    </class>
    <record name="FileEnumeratorClass"
            c:type="GFileEnumeratorClass"
            glib:is-gtype-struct-for="FileEnumerator">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="next_file">
        <callback name="next_file" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">A #GFileInfo or %NULL on error or end of enumerator.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_fn">
        <callback name="close_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next_files_async">
        <callback name="next_files_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="num_files" transfer-ownership="none">
              <doc xml:whitespace="preserve">the number of file info objects to request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="gioscheduler"&gt;io priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next_files_finish">
        <callback name="next_files_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GList of #GFileInfo&lt;!----&gt;s. You must free the list with</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="FileInfo"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_async">
        <callback name="close_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_finish">
        <callback name="close_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the close operation has finished successfully.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <type name="FileEnumerator" c:type="GFileEnumerator*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="FileEnumeratorPrivate"
            c:type="GFileEnumeratorPrivate"
            disguised="1">
    </record>
    <class name="FileIOStream"
           c:symbol-prefix="file_io_stream"
           c:type="GFileIOStream"
           parent="IOStream"
           glib:type-name="GFileIOStream"
           glib:get-type="g_file_io_stream_get_type"
           glib:type-struct="FileIOStreamClass">
      <doc xml:whitespace="preserve">A subclass of GIOStream for opened files. This adds
a few file-specific operations and seeking and truncating.
#GFileIOStream implements GSeekable.</doc>
      <implements name="Seekable"/>
      <virtual-method name="can_seek">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="can_truncate">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_etag" invoker="get_etag" version="2.22">
        <doc xml:whitespace="preserve">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="query_info"
                      invoker="query_info"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Queries a file io stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_io_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.
Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
all cases of failure, %NULL will be returned.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_async"
                      invoker="query_info_async"
                      version="2.22">
        <doc xml:whitespace="preserve">Asynchronously queries the @stream for a #GFileInfo. When completed,
finish the operation with g_file_io_stream_query_info_finish().
For the synchronous version of this function, see
g_file_io_stream_query_info().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="gio-GIOScheduler"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_finish"
                      invoker="query_info_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finalizes the asynchronous query started
by g_file_io_stream_query_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tell">
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="goffset"/>
        </return-value>
      </virtual-method>
      <virtual-method name="truncate_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_etag"
              c:identifier="g_file_io_stream_get_etag"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="query_info"
              c:identifier="g_file_io_stream_query_info"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Queries a file io stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_io_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.
Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
all cases of failure, %NULL will be returned.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_async"
              c:identifier="g_file_io_stream_query_info_async"
              version="2.22">
        <doc xml:whitespace="preserve">Asynchronously queries the @stream for a #GFileInfo. When completed,
finish the operation with g_file_io_stream_query_info_finish().
For the synchronous version of this function, see
g_file_io_stream_query_info().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="gio-GIOScheduler"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_finish"
              c:identifier="g_file_io_stream_query_info_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finalizes the asynchronous query started
by g_file_io_stream_query_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="IOStream" c:type="GIOStream"/>
      </field>
      <field name="priv">
        <type name="FileIOStreamPrivate" c:type="GFileIOStreamPrivate*"/>
      </field>
    </class>
    <record name="FileIOStreamClass"
            c:type="GFileIOStreamClass"
            glib:is-gtype-struct-for="FileIOStream">
      <field name="parent_class">
        <type name="IOStreamClass" c:type="GIOStreamClass"/>
      </field>
      <field name="tell">
        <callback name="tell">
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_seek">
        <callback name="can_seek">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GLib.SeekType" c:type="GSeekType"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_truncate">
        <callback name="can_truncate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="truncate_fn">
        <callback name="truncate_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info">
        <callback name="query_info" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_async">
        <callback name="query_info_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="gio-GIOScheduler"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_finish">
        <callback name="query_info_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">A #GFileInfo for the finished query.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_etag">
        <callback name="get_etag">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the entity tag for the stream.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileIOStream" c:type="GFileIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="FileIOStreamPrivate"
            c:type="GFileIOStreamPrivate"
            disguised="1">
    </record>
    <class name="FileIcon"
           c:symbol-prefix="file_icon"
           c:type="GFileIcon"
           parent="GObject.Object"
           glib:type-name="GFileIcon"
           glib:get-type="g_file_icon_get_type"
           glib:type-struct="FileIconClass">
      <doc xml:whitespace="preserve">Gets an icon for a #GFile. Implements #GLoadableIcon.</doc>
      <implements name="Icon"/>
      <implements name="LoadableIcon"/>
      <method name="get_file" c:identifier="g_file_icon_get_file">
        <doc xml:whitespace="preserve">Gets the #GFile associated with the given @icon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GFile, or %NULL.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </method>
      <property name="file"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The file containing the icon.</doc>
        <type name="File"/>
      </property>
    </class>
    <record name="FileIconClass"
            c:type="GFileIconClass"
            disguised="1"
            glib:is-gtype-struct-for="FileIcon">
    </record>
    <record name="FileIface"
            c:type="GFileIface"
            glib:is-gtype-struct-for="File">
      <doc xml:whitespace="preserve">An interface for writing VFS file handles.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="dup">
        <callback name="dup">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a new #GFile that is a duplicate of the given #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="hash">
        <callback name="hash">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="equal">
        <callback name="equal">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if @file1 and @file2 are equal.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file1" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="file2" transfer-ownership="none">
              <doc xml:whitespace="preserve">the second #GFile.</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_native">
        <callback name="is_native">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if file is native.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_uri_scheme">
        <callback name="has_uri_scheme">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if #GFile's backend supports the</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="uri_scheme" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string containing a URI scheme.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uri_scheme">
        <callback name="get_uri_scheme">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a string containing the URI scheme for the given</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_basename">
        <callback name="get_basename">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">string containing the #GFile's base name, or %NULL</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_path">
        <callback name="get_path">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">string containing the #GFile's path, or %NULL if</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uri">
        <callback name="get_uri">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a string containing the #GFile's URI.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_parse_name">
        <callback name="get_parse_name">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a string containing the #GFile's parse name. The returned</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_parent">
        <callback name="get_parent">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFile structure to the parent of the given</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prefix_matches">
        <callback name="prefix_matches">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @files's parent, grandparent, etc is @prefix.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="prefix" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="file" transfer-ownership="none">
              <doc xml:whitespace="preserve">input #GFile.</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_relative_path">
        <callback name="get_relative_path">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">string with the relative path from @descendant</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="descendant" transfer-ownership="none">
              <doc xml:whitespace="preserve">input #GFile.</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="resolve_relative_path">
        <callback name="resolve_relative_path">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">#GFile to the resolved path. %NULL if @relative_path</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="relative_path" transfer-ownership="none">
              <doc xml:whitespace="preserve">a given relative path string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_child_for_display_name">
        <callback name="get_child_for_display_name" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFile to the specified child, or</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="display_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">string to a possible child.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enumerate_children">
        <callback name="enumerate_children" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">A #GFileEnumerator if successful, %NULL on error.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">an attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enumerate_children_async">
        <callback name="enumerate_children_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">an attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="6">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="6">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enumerate_children_finish">
        <callback name="enumerate_children_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileEnumerator or %NULL if an error occurred.</doc>
            <type name="FileEnumerator" c:type="GFileEnumerator*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info">
        <callback name="query_info" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileInfo for the given @file, or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">an attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_async">
        <callback name="query_info_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">an attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="6">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="6">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_finish">
        <callback name="query_info_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">#GFileInfo for given @file or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_filesystem_info">
        <callback name="query_filesystem_info" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileInfo or %NULL if there was an error.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">an attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_filesystem_info_async">
        <callback name="query_filesystem_info_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">an attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_filesystem_info_finish">
        <callback name="query_filesystem_info_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">#GFileInfo for given @file or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="find_enclosing_mount">
        <callback name="find_enclosing_mount" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GMount where the @file is located or %NULL on error.</doc>
            <type name="Mount" c:type="GMount*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="find_enclosing_mount_async">
        <callback name="find_enclosing_mount_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="find_enclosing_mount_finish">
        <callback name="find_enclosing_mount_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">#GMount for given @file or %NULL on error.</doc>
            <type name="Mount" c:type="GMount*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_display_name">
        <callback name="set_display_name" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFile specifying what @file was renamed to, or %NULL</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="display_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_display_name_async">
        <callback name="set_display_name_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="display_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_display_name_finish">
        <callback name="set_display_name_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFile or %NULL on error.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_settable_attributes">
        <callback name="query_settable_attributes" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileAttributeInfoList describing the settable attributes.</doc>
            <type name="FileAttributeInfoList"
                  c:type="GFileAttributeInfoList*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_query_settable_attributes_async" introspectable="0">
        <callback name="_query_settable_attributes_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_query_settable_attributes_finish" introspectable="0">
        <callback name="_query_settable_attributes_finish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="query_writable_namespaces">
        <callback name="query_writable_namespaces" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileAttributeInfoList describing the writable namespaces.</doc>
            <type name="FileAttributeInfoList"
                  c:type="GFileAttributeInfoList*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_query_writable_namespaces_async" introspectable="0">
        <callback name="_query_writable_namespaces_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_query_writable_namespaces_finish" introspectable="0">
        <callback name="_query_writable_namespaces_finish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="set_attribute">
        <callback name="set_attribute" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the attribute was set, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="attribute" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string containing the attribute's name.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:whitespace="preserve">The type of the attribute</doc>
              <type name="FileAttributeType" c:type="GFileAttributeType"/>
            </parameter>
            <parameter name="value_p" transfer-ownership="none">
              <doc xml:whitespace="preserve">a pointer to the value (or the pointer itself if the type is a pointer type)</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileQueryInfoFlags.</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_attributes_from_info">
        <callback name="set_attributes_from_info" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if there was any error, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GFileInfo.</doc>
              <type name="FileInfo" c:type="GFileInfo*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">#GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_attributes_async">
        <callback name="set_attributes_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GFileInfo.</doc>
              <type name="FileInfo" c:type="GFileInfo*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GFileQueryInfoFlags.</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="6">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="6">
              <doc xml:whitespace="preserve">a #gpointer.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_attributes_finish">
        <callback name="set_attributes_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the attributes were set correctly, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
            <parameter name="info"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:whitespace="preserve">a #GFileInfo.</doc>
              <type name="FileInfo" c:type="GFileInfo**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_fn">
        <callback name="read_fn" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">#GFileInputStream or %NULL on error.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_async">
        <callback name="read_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_finish">
        <callback name="read_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileInputStream or %NULL on error.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="append_to">
        <callback name="append_to" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileOutputStream, or %NULL on error.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="append_to_async">
        <callback name="append_to_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="append_to_finish">
        <callback name="append_to_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a valid #GFileOutputStream or %NULL on error.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">#GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create">
        <callback name="create" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileOutputStream for the newly created file, or</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_async">
        <callback name="create_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_finish">
        <callback name="create_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileOutputStream or %NULL on error.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace">
        <callback name="replace" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileOutputStream or %NULL on error.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="etag" transfer-ownership="none" allow-none="1">
              <doc xml:whitespace="preserve">an optional &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or #NULL to ignore.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="make_backup" transfer-ownership="none">
              <doc xml:whitespace="preserve">%TRUE if a backup should be created.</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace_async">
        <callback name="replace_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="etag" transfer-ownership="none" allow-none="1">
              <doc xml:whitespace="preserve">an &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or NULL to ignore.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="make_backup" transfer-ownership="none">
              <doc xml:whitespace="preserve">%TRUE if a backup should be created.</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="7">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="7">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace_finish">
        <callback name="replace_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileOutputStream, or %NULL on error.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_file">
        <callback name="delete_file" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the file was deleted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_delete_file_async" introspectable="0">
        <callback name="_delete_file_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_delete_file_finish" introspectable="0">
        <callback name="_delete_file_finish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="trash">
        <callback name="trash" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE on successful trash, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_trash_async" introspectable="0">
        <callback name="_trash_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_trash_finish" introspectable="0">
        <callback name="_trash_finish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="make_directory">
        <callback name="make_directory" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_make_directory_async" introspectable="0">
        <callback name="_make_directory_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_make_directory_finish" introspectable="0">
        <callback name="_make_directory_finish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="make_symbolic_link">
        <callback name="make_symbolic_link" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE on the creation of a new symlink, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="symlink_value" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string with the path for the target of the new symlink</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_make_symbolic_link_async" introspectable="0">
        <callback name="_make_symbolic_link_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_make_symbolic_link_finish" introspectable="0">
        <callback name="_make_symbolic_link_finish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="copy" introspectable="0">
        <callback name="copy" introspectable="0" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE on success, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="destination" transfer-ownership="none">
              <doc xml:whitespace="preserve">destination #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">set of #GFileCopyFlags</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="progress_callback"
                       transfer-ownership="none"
                       closure="5">
              <doc xml:whitespace="preserve">function to callback with progress information</doc>
              <type name="FileProgressCallback"
                    c:type="GFileProgressCallback"/>
            </parameter>
            <parameter name="progress_callback_data" transfer-ownership="none">
              <doc xml:whitespace="preserve">user data to pass to @progress_callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="copy_async" introspectable="0">
        <callback name="copy_async" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="destination" transfer-ownership="none">
              <doc xml:whitespace="preserve">destination #GFile</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">set of #GFileCopyFlags</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="progress_callback"
                       transfer-ownership="none"
                       closure="6">
              <doc xml:whitespace="preserve">function to callback with progress information</doc>
              <type name="FileProgressCallback"
                    c:type="GFileProgressCallback"/>
            </parameter>
            <parameter name="progress_callback_data" transfer-ownership="none">
              <doc xml:whitespace="preserve">user data to pass to @progress_callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="8">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="8">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="copy_finish">
        <callback name="copy_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a %TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="move" introspectable="0">
        <callback name="move" introspectable="0" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE on successful move, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="destination" transfer-ownership="none">
              <doc xml:whitespace="preserve">#GFile pointing to the destination location.</doc>
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">set of #GFileCopyFlags.</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="progress_callback"
                       transfer-ownership="none"
                       closure="5">
              <doc xml:whitespace="preserve">#GFileProgressCallback function for updates.</doc>
              <type name="FileProgressCallback"
                    c:type="GFileProgressCallback"/>
            </parameter>
            <parameter name="progress_callback_data" transfer-ownership="none">
              <doc xml:whitespace="preserve">gpointer to user data for the callback function.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_move_async" introspectable="0">
        <callback name="_move_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_move_finish" introspectable="0">
        <callback name="_move_finish">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="mount_mountable">
        <callback name="mount_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="MountMountFlags" c:type="GMountMountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_mountable_finish">
        <callback name="mount_mountable_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFile or %NULL on error.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_mountable">
        <callback name="unmount_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_mountable_finish">
        <callback name="unmount_mountable_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_mountable">
        <callback name="eject_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_mountable_finish">
        <callback name="eject_mountable_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @file was ejected successfully. %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_enclosing_volume">
        <callback name="mount_enclosing_volume">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="MountMountFlags" c:type="GMountMountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_enclosing_volume_finish">
        <callback name="mount_enclosing_volume_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if successful. If an error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="monitor_dir">
        <callback name="monitor_dir" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileMonitor for the given @file, or %NULL on error.</doc>
            <type name="FileMonitor" c:type="GFileMonitor*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileMonitorFlags.</doc>
              <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="monitor_file">
        <callback name="monitor_file" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileMonitor for the given @file, or %NULL on error.</doc>
            <type name="FileMonitor" c:type="GFileMonitor*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileMonitorFlags.</doc>
              <type name="FileMonitorFlags" c:type="GFileMonitorFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open_readwrite">
        <callback name="open_readwrite" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">#GFileIOStream or %NULL on error.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open_readwrite_async">
        <callback name="open_readwrite_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open_readwrite_finish">
        <callback name="open_readwrite_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileIOStream or %NULL on error.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_readwrite">
        <callback name="create_readwrite" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileIOStream for the newly created file, or %NULL on error.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_readwrite_async">
        <callback name="create_readwrite_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_readwrite_finish">
        <callback name="create_readwrite_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileIOStream or %NULL on error.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace_readwrite">
        <callback name="replace_readwrite" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileIOStream or %NULL on error.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="etag" transfer-ownership="none" allow-none="1">
              <doc xml:whitespace="preserve">an optional &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or #NULL to ignore</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="make_backup" transfer-ownership="none">
              <doc xml:whitespace="preserve">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace_readwrite_async">
        <callback name="replace_readwrite_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="etag" transfer-ownership="none" allow-none="1">
              <doc xml:whitespace="preserve">an &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for the current #GFile, or NULL to ignore.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="make_backup" transfer-ownership="none">
              <doc xml:whitespace="preserve">%TRUE if a backup should be created.</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GFileCreateFlags.</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="7">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="7">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="replace_readwrite_finish">
        <callback name="replace_readwrite_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileIOStream, or %NULL on error.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start_mountable">
        <callback name="start_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="DriveStartFlags" c:type="GDriveStartFlags"/>
            </parameter>
            <parameter name="start_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start_mountable_finish">
        <callback name="start_mountable_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop_mountable">
        <callback name="stop_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop_mountable_finish">
        <callback name="stop_mountable_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supports_thread_contexts">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="unmount_mountable_with_operation">
        <callback name="unmount_mountable_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_mountable_with_operation_finish">
        <callback name="unmount_mountable_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_mountable_with_operation">
        <callback name="eject_mountable_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation, or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_mountable_with_operation_finish">
        <callback name="eject_mountable_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @file was ejected successfully. %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="poll_mountable">
        <callback name="poll_mountable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="poll_mountable_finish">
        <callback name="poll_mountable_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the operation finished successfully. %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="FileInfo"
           c:symbol-prefix="file_info"
           c:type="GFileInfo"
           parent="GObject.Object"
           glib:type-name="GFileInfo"
           glib:get-type="g_file_info_get_type"
           glib:type-struct="FileInfoClass">
      <doc xml:whitespace="preserve">Stores information about a file system object referenced by a #GFile.</doc>
      <constructor name="new" c:identifier="g_file_info_new">
        <doc xml:whitespace="preserve">Creates a new file info structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInfo.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
      </constructor>
      <method name="clear_status" c:identifier="g_file_info_clear_status">
        <doc xml:whitespace="preserve">Clears the status information from @info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="copy_into" c:identifier="g_file_info_copy_into">
        <doc xml:whitespace="preserve">Copies all of the #GFileAttribute&lt;!-- --&gt;s from @src_info to @dest_info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest_info" transfer-ownership="none">
            <doc xml:whitespace="preserve">destination to copy attributes to.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="g_file_info_dup">
        <doc xml:whitespace="preserve">Duplicates a file info structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a duplicate #GFileInfo of @other.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
      </method>
      <method name="get_attribute_as_string"
              c:identifier="g_file_info_get_attribute_as_string">
        <doc xml:whitespace="preserve">Gets the value of a attribute, formated as a string.
This escapes things as needed to make the string valid
utf8.
When you're done with the string it must be freed with g_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a UTF-8 string associated with the given @attribute.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_boolean"
              c:identifier="g_file_info_get_attribute_boolean">
        <doc xml:whitespace="preserve">Gets the value of a boolean attribute. If the attribute does not
contain a boolean value, %FALSE will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the boolean value contained within the attribute.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_byte_string"
              c:identifier="g_file_info_get_attribute_byte_string">
        <doc xml:whitespace="preserve">Gets the value of a byte string attribute. If the attribute does
not contain a byte string, %NULL will be returned.
%NULL otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the contents of the @attribute value as a byte string, or</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_data"
              c:identifier="g_file_info_get_attribute_data">
        <doc xml:whitespace="preserve">Gets the attribute type, value and status for an attribute key.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @info has an attribute named @attribute,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="type"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">return location for the attribute type, or %NULL</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType*"/>
          </parameter>
          <parameter name="value_pp"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">return location for the attribute value, or %NULL</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
          <parameter name="status"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">return location for the attribute status, or %NULL</doc>
            <type name="FileAttributeStatus" c:type="GFileAttributeStatus*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_int32"
              c:identifier="g_file_info_get_attribute_int32">
        <doc xml:whitespace="preserve">Gets a signed 32-bit integer contained within the attribute. If the
attribute does not contain a signed 32-bit integer, or is invalid,
0 will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a signed 32-bit integer from the attribute.</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_int64"
              c:identifier="g_file_info_get_attribute_int64">
        <doc xml:whitespace="preserve">Gets a signed 64-bit integer contained within the attribute. If the
attribute does not contain an signed 64-bit integer, or is invalid,
0 will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a signed 64-bit integer from the attribute.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_object"
              c:identifier="g_file_info_get_attribute_object">
        <doc xml:whitespace="preserve">Gets the value of a #GObject attribute. If the attribute does
not contain a #GObject, %NULL will be returned.
%NULL otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GObject associated with the given @attribute, or</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_status"
              c:identifier="g_file_info_get_attribute_status">
        <return-value transfer-ownership="none">
          <type name="FileAttributeStatus" c:type="GFileAttributeStatus"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_string"
              c:identifier="g_file_info_get_attribute_string">
        <doc xml:whitespace="preserve">Gets the value of a string attribute. If the attribute does
not contain a string, %NULL will be returned.
%NULL otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the contents of the @attribute value as a string, or</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_stringv"
              c:identifier="g_file_info_get_attribute_stringv"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the value of a stringv attribute. If the attribute does
not contain a stringv, %NULL will be returned.
%NULL otherwise. Do not free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the contents of the @attribute value as a stringv, or</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_type"
              c:identifier="g_file_info_get_attribute_type">
        <doc xml:whitespace="preserve">Gets the attribute type for an attribute key.
%G_FILE_ATTRIBUTE_TYPE_INVALID if the key is not set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GFileAttributeType for the given @attribute, or</doc>
          <type name="FileAttributeType" c:type="GFileAttributeType"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_uint32"
              c:identifier="g_file_info_get_attribute_uint32">
        <doc xml:whitespace="preserve">Gets an unsigned 32-bit integer contained within the attribute. If the
attribute does not contain an unsigned 32-bit integer, or is invalid,
0 will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an unsigned 32-bit integer from the attribute.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute_uint64"
              c:identifier="g_file_info_get_attribute_uint64">
        <doc xml:whitespace="preserve">Gets a unsigned 64-bit integer contained within the attribute. If the
attribute does not contain an unsigned 64-bit integer, or is invalid,
0 will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a unsigned 64-bit integer from the attribute.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_content_type"
              c:identifier="g_file_info_get_content_type">
        <doc xml:whitespace="preserve">Gets the file's content type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the file's content type.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_display_name"
              c:identifier="g_file_info_get_display_name">
        <doc xml:whitespace="preserve">Gets a display name for a file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the display name.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_edit_name" c:identifier="g_file_info_get_edit_name">
        <doc xml:whitespace="preserve">Gets the edit name for a file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the edit name.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_etag" c:identifier="g_file_info_get_etag">
        <doc xml:whitespace="preserve">Gets the &lt;link linkend="gfile-etag"&gt;entity tag&lt;/link&gt; for a given
#GFileInfo. See %G_FILE_ATTRIBUTE_ETAG_VALUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the value of the "etag:value" attribute.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_file_type" c:identifier="g_file_info_get_file_type">
        <doc xml:whitespace="preserve">Gets a file's type (whether it is a regular file, symlink, etc).
This is different from the file's content type, see g_file_info_get_content_type().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GFileType for the given file.</doc>
          <type name="FileType" c:type="GFileType"/>
        </return-value>
      </method>
      <method name="get_icon" c:identifier="g_file_info_get_icon">
        <doc xml:whitespace="preserve">Gets the icon for a file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GIcon for the given @info.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </method>
      <method name="get_is_backup" c:identifier="g_file_info_get_is_backup">
        <doc xml:whitespace="preserve">Checks if a file is a backup file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if file is a backup file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_is_hidden" c:identifier="g_file_info_get_is_hidden">
        <doc xml:whitespace="preserve">Checks if a file is hidden.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file is a hidden file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_is_symlink" c:identifier="g_file_info_get_is_symlink">
        <doc xml:whitespace="preserve">Checks if a file is a symlink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the given @info is a symlink.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_modification_time"
              c:identifier="g_file_info_get_modification_time">
        <doc xml:whitespace="preserve">Gets the modification time of the current @info and sets it
in @result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GTimeVal.</doc>
            <type name="GLib.TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_file_info_get_name">
        <doc xml:whitespace="preserve">Gets the name for a file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the file name.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_size" c:identifier="g_file_info_get_size">
        <doc xml:whitespace="preserve">Gets the file's size.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #goffset containing the file's size.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
      </method>
      <method name="get_sort_order" c:identifier="g_file_info_get_sort_order">
        <doc xml:whitespace="preserve">Gets the value of the sort_order attribute from the #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gint32 containing the value of the "standard::sort_order" attribute.</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
      </method>
      <method name="get_symlink_target"
              c:identifier="g_file_info_get_symlink_target">
        <doc xml:whitespace="preserve">Gets the symlink target for a given #GFileInfo.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the symlink target.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="has_attribute" c:identifier="g_file_info_has_attribute">
        <doc xml:whitespace="preserve">Checks if a file info structure has an attribute named @attribute.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @Ginfo has an attribute named @attribute,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_namespace"
              c:identifier="g_file_info_has_namespace"
              version="2.22">
        <doc xml:whitespace="preserve">Checks if a file info structure has an attribute in the
specified @name_space.
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @Ginfo has an attribute in @name_space,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name_space" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute namespace.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_attributes"
              c:identifier="g_file_info_list_attributes">
        <doc xml:whitespace="preserve">Lists the file info structure's attributes.
possible attribute types for the given @name_space, or
%NULL on error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a null-terminated array of strings of all of the</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="name_space" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key's namespace.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_attribute"
              c:identifier="g_file_info_remove_attribute">
        <doc xml:whitespace="preserve">Removes all cases of @attribute from @info if it exists.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute" c:identifier="g_file_info_set_attribute">
        <doc xml:whitespace="preserve">Sets the @attribute to contain the given value, if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileAttributeType</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType"/>
          </parameter>
          <parameter name="value_p" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to the value</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_boolean"
              c:identifier="g_file_info_set_attribute_boolean">
        <doc xml:whitespace="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a boolean value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_byte_string"
              c:identifier="g_file_info_set_attribute_byte_string">
        <doc xml:whitespace="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a byte string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_int32"
              c:identifier="g_file_info_set_attribute_int32">
        <doc xml:whitespace="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a signed 32-bit integer</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_int64"
              c:identifier="g_file_info_set_attribute_int64">
        <doc xml:whitespace="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">attribute name to set.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">int64 value to set attribute to.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_mask"
              c:identifier="g_file_info_set_attribute_mask">
        <doc xml:whitespace="preserve">Sets @mask on @info to match specific attribute types.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_object"
              c:identifier="g_file_info_set_attribute_object">
        <doc xml:whitespace="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_status"
              c:identifier="g_file_info_set_attribute_status"
              version="2.22">
        <doc xml:whitespace="preserve">Sets the attribute status for an attribute key. This is only
needed by external code that implement g_file_set_attributes_from_info()
or similar functions.
The attribute must exist in @info for this to work. Otherwise %FALSE
is returned and @info is unchanged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the status was changed, %FALSE if the key was not set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileAttributeStatus</doc>
            <type name="FileAttributeStatus" c:type="GFileAttributeStatus"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_string"
              c:identifier="g_file_info_set_attribute_string">
        <doc xml:whitespace="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_stringv"
              c:identifier="g_file_info_set_attribute_stringv">
        <doc xml:whitespace="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a %NULL terminated string array</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_uint32"
              c:identifier="g_file_info_set_attribute_uint32">
        <doc xml:whitespace="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">an unsigned 32-bit integer.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute_uint64"
              c:identifier="g_file_info_set_attribute_uint64">
        <doc xml:whitespace="preserve">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="attr_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">an unsigned 64-bit integer.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_type"
              c:identifier="g_file_info_set_content_type">
        <doc xml:whitespace="preserve">Sets the content type attribute for a given #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a content type. See #GContentType.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name"
              c:identifier="g_file_info_set_display_name">
        <doc xml:whitespace="preserve">Sets the display name for the current #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a display name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_edit_name" c:identifier="g_file_info_set_edit_name">
        <doc xml:whitespace="preserve">Sets the edit name for the current file.
See %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="edit_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing an edit name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_file_type" c:identifier="g_file_info_set_file_type">
        <doc xml:whitespace="preserve">Sets the file type in a #GFileInfo to @type.
See %G_FILE_ATTRIBUTE_STANDARD_TYPE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileType.</doc>
            <type name="FileType" c:type="GFileType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon" c:identifier="g_file_info_set_icon">
        <doc xml:whitespace="preserve">Sets the icon for a given #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_ICON.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="icon" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_is_hidden" c:identifier="g_file_info_set_is_hidden">
        <doc xml:whitespace="preserve">Sets the "is_hidden" attribute in a #GFileInfo according to @is_symlink.
See %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="is_hidden" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_is_symlink" c:identifier="g_file_info_set_is_symlink">
        <doc xml:whitespace="preserve">Sets the "is_symlink" attribute in a #GFileInfo according to @is_symlink.
See %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="is_symlink" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_modification_time"
              c:identifier="g_file_info_set_modification_time">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mtime" transfer-ownership="none">
            <type name="GLib.TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="g_file_info_set_name">
        <doc xml:whitespace="preserve">Sets the name attribute for the current #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_NAME.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_size" c:identifier="g_file_info_set_size">
        <doc xml:whitespace="preserve">Sets the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info
to the given size.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #goffset containing the file's size.</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sort_order" c:identifier="g_file_info_set_sort_order">
        <doc xml:whitespace="preserve">Sets the sort order attribute in the file info structure. See
%G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="sort_order" transfer-ownership="none">
            <doc xml:whitespace="preserve">a sort order integer.</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_symlink_target"
              c:identifier="g_file_info_set_symlink_target">
        <doc xml:whitespace="preserve">Sets the %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info
to the given symlink target.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="symlink_target" transfer-ownership="none">
            <doc xml:whitespace="preserve">a static string containing a path to a symlink target.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unset_attribute_mask"
              c:identifier="g_file_info_unset_attribute_mask">
        <doc xml:whitespace="preserve">Unsets a mask set by g_file_info_set_attribute_mask(), if one
is set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </class>
    <record name="FileInfoClass"
            c:type="GFileInfoClass"
            disguised="1"
            glib:is-gtype-struct-for="FileInfo">
    </record>
    <class name="FileInputStream"
           c:symbol-prefix="file_input_stream"
           c:type="GFileInputStream"
           parent="InputStream"
           glib:type-name="GFileInputStream"
           glib:get-type="g_file_input_stream_get_type"
           glib:type-struct="FileInputStreamClass">
      <doc xml:whitespace="preserve">A subclass of GInputStream for opened files. This adds
a few file-specific operations and seeking.
#GFileInputStream implements #GSeekable.</doc>
      <implements name="Seekable"/>
      <virtual-method name="can_seek">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="query_info" invoker="query_info" throws="1">
        <doc xml:whitespace="preserve">Queries a file input stream the given @attributes. This function blocks
while querying the stream. For the asynchronous (non-blocking) version
of this function, see g_file_input_stream_query_info_async(). While the
stream is blocked, the stream will set the pending flag internally, and
any other operations on the stream will fail with %G_IO_ERROR_PENDING.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInfo, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_async" invoker="query_info_async">
        <doc xml:whitespace="preserve">Queries the stream information asynchronously.
When the operation is finished @callback will be called.
You can then call g_file_input_stream_query_info_finish()
to get the result of the operation.
For the synchronous version of this function,
see g_file_input_stream_query_info().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_finish"
                      invoker="query_info_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous info query operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFileInfo.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tell">
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="goffset"/>
        </return-value>
      </virtual-method>
      <method name="query_info"
              c:identifier="g_file_input_stream_query_info"
              throws="1">
        <doc xml:whitespace="preserve">Queries a file input stream the given @attributes. This function blocks
while querying the stream. For the asynchronous (non-blocking) version
of this function, see g_file_input_stream_query_info_async(). While the
stream is blocked, the stream will set the pending flag internally, and
any other operations on the stream will fail with %G_IO_ERROR_PENDING.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInfo, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_async"
              c:identifier="g_file_input_stream_query_info_async">
        <doc xml:whitespace="preserve">Queries the stream information asynchronously.
When the operation is finished @callback will be called.
You can then call g_file_input_stream_query_info_finish()
to get the result of the operation.
For the synchronous version of this function,
see g_file_input_stream_query_info().
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_finish"
              c:identifier="g_file_input_stream_query_info_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous info query operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GFileInfo.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="InputStream" c:type="GInputStream"/>
      </field>
      <field name="priv">
        <type name="FileInputStreamPrivate" c:type="GFileInputStreamPrivate*"/>
      </field>
    </class>
    <record name="FileInputStreamClass"
            c:type="GFileInputStreamClass"
            glib:is-gtype-struct-for="FileInputStream">
      <field name="parent_class">
        <type name="InputStreamClass" c:type="GInputStreamClass"/>
      </field>
      <field name="tell">
        <callback name="tell">
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_seek">
        <callback name="can_seek">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GLib.SeekType" c:type="GSeekType"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info">
        <callback name="query_info" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileInfo, or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_async">
        <callback name="query_info_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_finish">
        <callback name="query_info_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">#GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileInputStream" c:type="GFileInputStream*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="FileInputStreamPrivate"
            c:type="GFileInputStreamPrivate"
            disguised="1">
    </record>
    <class name="FileMonitor"
           c:symbol-prefix="file_monitor"
           c:type="GFileMonitor"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GFileMonitor"
           glib:get-type="g_file_monitor_get_type"
           glib:type-struct="FileMonitorClass">
      <doc xml:whitespace="preserve">Watches for changes to a file.</doc>
      <virtual-method name="cancel" invoker="cancel">
        <doc xml:whitespace="preserve">Cancels a file monitor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if monitor was cancelled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="cancel" c:identifier="g_file_monitor_cancel">
        <doc xml:whitespace="preserve">Cancels a file monitor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if monitor was cancelled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="emit_event" c:identifier="g_file_monitor_emit_event">
        <doc xml:whitespace="preserve">Emits the #GFileMonitor::changed signal if a change
has taken place. Should be called from file monitor
implementations only.
The signal will be emitted from an idle handler (in the &lt;link
linkend="g-main-context-push-thread-default"&gt;thread-default main
context&lt;/link&gt;).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="other_file" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </parameter>
          <parameter name="event_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GFileMonitorEvent flags.</doc>
            <type name="FileMonitorEvent" c:type="GFileMonitorEvent"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_cancelled" c:identifier="g_file_monitor_is_cancelled">
        <doc xml:whitespace="preserve">Returns whether the monitor is canceled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if monitor is canceled. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_rate_limit"
              c:identifier="g_file_monitor_set_rate_limit">
        <doc xml:whitespace="preserve">Sets the rate limit to which the @monitor will report
consecutive change events to the same file.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="limit_msecs" transfer-ownership="none">
            <doc xml:whitespace="preserve">a integer with the limit in milliseconds to poll for changes.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <property name="cancelled" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="rate-limit" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="FileMonitorPrivate" c:type="GFileMonitorPrivate*"/>
      </field>
      <glib:signal name="changed">
        <doc xml:whitespace="preserve">Emitted when a file has been changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFile.</doc>
            <type name="File"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFile.</doc>
            <type name="File"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFileMonitorEvent.</doc>
            <type name="FileMonitorEvent"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="FileMonitorClass"
            c:type="GFileMonitorClass"
            glib:is-gtype-struct-for="FileMonitor">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="monitor" transfer-ownership="none">
              <type name="FileMonitor" c:type="GFileMonitor*"/>
            </parameter>
            <parameter name="file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="other_file" transfer-ownership="none">
              <type name="File" c:type="GFile*"/>
            </parameter>
            <parameter name="event_type" transfer-ownership="none">
              <type name="FileMonitorEvent" c:type="GFileMonitorEvent"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cancel">
        <callback name="cancel">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if monitor was cancelled.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="monitor" transfer-ownership="none">
              <type name="FileMonitor" c:type="GFileMonitor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="FileMonitorEvent"
                 glib:type-name="GFileMonitorEvent"
                 glib:get-type="g_file_monitor_event_get_type"
                 c:type="GFileMonitorEvent">
      <doc xml:whitespace="preserve">Specifies what type of event a monitor event is.</doc>
      <member name="changed"
              value="0"
              c:identifier="G_FILE_MONITOR_EVENT_CHANGED"
              glib:nick="changed"/>
      <member name="changes_done_hint"
              value="1"
              c:identifier="G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT"
              glib:nick="changes-done-hint"/>
      <member name="deleted"
              value="2"
              c:identifier="G_FILE_MONITOR_EVENT_DELETED"
              glib:nick="deleted"/>
      <member name="created"
              value="3"
              c:identifier="G_FILE_MONITOR_EVENT_CREATED"
              glib:nick="created"/>
      <member name="attribute_changed"
              value="4"
              c:identifier="G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED"
              glib:nick="attribute-changed"/>
      <member name="pre_unmount"
              value="5"
              c:identifier="G_FILE_MONITOR_EVENT_PRE_UNMOUNT"
              glib:nick="pre-unmount"/>
      <member name="unmounted"
              value="6"
              c:identifier="G_FILE_MONITOR_EVENT_UNMOUNTED"
              glib:nick="unmounted"/>
      <member name="moved"
              value="7"
              c:identifier="G_FILE_MONITOR_EVENT_MOVED"
              glib:nick="moved"/>
    </enumeration>
    <bitfield name="FileMonitorFlags"
              glib:type-name="GFileMonitorFlags"
              glib:get-type="g_file_monitor_flags_get_type"
              c:type="GFileMonitorFlags">
      <doc xml:whitespace="preserve">Flags used to set what a #GFileMonitor will watch for.</doc>
      <member name="none"
              value="0"
              c:identifier="G_FILE_MONITOR_NONE"
              glib:nick="none"/>
      <member name="watch_mounts"
              value="1"
              c:identifier="G_FILE_MONITOR_WATCH_MOUNTS"
              glib:nick="watch-mounts"/>
      <member name="send_moved"
              value="2"
              c:identifier="G_FILE_MONITOR_SEND_MOVED"
              glib:nick="send-moved"/>
    </bitfield>
    <record name="FileMonitorPrivate"
            c:type="GFileMonitorPrivate"
            disguised="1">
    </record>
    <class name="FileOutputStream"
           c:symbol-prefix="file_output_stream"
           c:type="GFileOutputStream"
           parent="OutputStream"
           glib:type-name="GFileOutputStream"
           glib:get-type="g_file_output_stream_get_type"
           glib:type-struct="FileOutputStreamClass">
      <doc xml:whitespace="preserve">A subclass of GOutputStream for opened files. This adds
a few file-specific operations and seeking and truncating.
#GFileOutputStream implements GSeekable.</doc>
      <implements name="Seekable"/>
      <virtual-method name="can_seek">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="can_truncate">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_etag" invoker="get_etag">
        <doc xml:whitespace="preserve">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="query_info" invoker="query_info" throws="1">
        <doc xml:whitespace="preserve">Queries a file output stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_output_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.
Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
all cases of failure, %NULL will be returned.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_async" invoker="query_info_async">
        <doc xml:whitespace="preserve">Asynchronously queries the @stream for a #GFileInfo. When completed,
finish the operation with g_file_output_stream_query_info_finish().
For the synchronous version of this function, see
g_file_output_stream_query_info().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="gio-GIOScheduler"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_info_finish"
                      invoker="query_info_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finalizes the asynchronous query started
by g_file_output_stream_query_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="seek" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tell">
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="goffset"/>
        </return-value>
      </virtual-method>
      <virtual-method name="truncate_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_etag" c:identifier="g_file_output_stream_get_etag">
        <doc xml:whitespace="preserve">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="query_info"
              c:identifier="g_file_output_stream_query_info"
              throws="1">
        <doc xml:whitespace="preserve">Queries a file output stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_output_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.
Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
all cases of failure, %NULL will be returned.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_async"
              c:identifier="g_file_output_stream_query_info_async">
        <doc xml:whitespace="preserve">Asynchronously queries the @stream for a #GFileInfo. When completed,
finish the operation with g_file_output_stream_query_info_finish().
For the synchronous version of this function, see
g_file_output_stream_query_info().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file attribute query string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="gio-GIOScheduler"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_info_finish"
              c:identifier="g_file_output_stream_query_info_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finalizes the asynchronous query started
by g_file_output_stream_query_info_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="OutputStream" c:type="GOutputStream"/>
      </field>
      <field name="priv">
        <type name="FileOutputStreamPrivate"
              c:type="GFileOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="FileOutputStreamClass"
            c:type="GFileOutputStreamClass"
            glib:is-gtype-struct-for="FileOutputStream">
      <field name="parent_class">
        <type name="OutputStreamClass" c:type="GOutputStreamClass"/>
      </field>
      <field name="tell">
        <callback name="tell">
          <return-value transfer-ownership="none">
            <type name="gint64" c:type="goffset"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_seek">
        <callback name="can_seek">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GLib.SeekType" c:type="GSeekType"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_truncate">
        <callback name="can_truncate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="truncate_fn">
        <callback name="truncate_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info">
        <callback name="query_info" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFileInfo for the @stream, or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_async">
        <callback name="query_info_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:whitespace="preserve">a file attribute query string.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="gio-GIOScheduler"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_info_finish">
        <callback name="query_info_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">A #GFileInfo for the finished query.</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_etag">
        <callback name="get_etag">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the entity tag for the stream.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="FileOutputStream" c:type="GFileOutputStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="FileOutputStreamPrivate"
            c:type="GFileOutputStreamPrivate"
            disguised="1">
    </record>
    <callback name="FileProgressCallback" c:type="GFileProgressCallback">
      <doc xml:whitespace="preserve">When doing file operations that may take a while, such as moving
a file or copying a file, a progress callback is used to pass how
far along that operation is to the application.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="current_num_bytes" transfer-ownership="none">
          <doc xml:whitespace="preserve">the current number of bytes in the operation.</doc>
          <type name="gint64" c:type="goffset"/>
        </parameter>
        <parameter name="total_num_bytes" transfer-ownership="none">
          <doc xml:whitespace="preserve">the total number of bytes in the operation.</doc>
          <type name="gint64" c:type="goffset"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data passed to the callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="FileQueryInfoFlags"
              glib:type-name="GFileQueryInfoFlags"
              glib:get-type="g_file_query_info_flags_get_type"
              c:type="GFileQueryInfoFlags">
      <doc xml:whitespace="preserve">Flags used when querying a #GFileInfo.</doc>
      <member name="none"
              value="0"
              c:identifier="G_FILE_QUERY_INFO_NONE"
              glib:nick="none"/>
      <member name="nofollow_symlinks"
              value="1"
              c:identifier="G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS"
              glib:nick="nofollow-symlinks"/>
    </bitfield>
    <callback name="FileReadMoreCallback" c:type="GFileReadMoreCallback">
      <doc xml:whitespace="preserve">When loading the partial contents of a file with g_file_load_partial_contents_async(),
it may become necessary to determine if any more data from the file should be loaded.
A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data
should be read, or %FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if more data should be read back. %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="file_contents" transfer-ownership="none">
          <doc xml:whitespace="preserve">the data as currently read.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="file_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the data currently read.</doc>
          <type name="gint64" c:type="goffset"/>
        </parameter>
        <parameter name="callback_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data passed to the callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="FileType"
                 glib:type-name="GFileType"
                 glib:get-type="g_file_type_get_type"
                 c:type="GFileType">
      <doc xml:whitespace="preserve">Indicates the file's on-disk type.</doc>
      <member name="unknown"
              value="0"
              c:identifier="G_FILE_TYPE_UNKNOWN"
              glib:nick="unknown"/>
      <member name="regular"
              value="1"
              c:identifier="G_FILE_TYPE_REGULAR"
              glib:nick="regular"/>
      <member name="directory"
              value="2"
              c:identifier="G_FILE_TYPE_DIRECTORY"
              glib:nick="directory"/>
      <member name="symbolic_link"
              value="3"
              c:identifier="G_FILE_TYPE_SYMBOLIC_LINK"
              glib:nick="symbolic-link"/>
      <member name="special"
              value="4"
              c:identifier="G_FILE_TYPE_SPECIAL"
              glib:nick="special"/>
      <member name="shortcut"
              value="5"
              c:identifier="G_FILE_TYPE_SHORTCUT"
              glib:nick="shortcut"/>
      <member name="mountable"
              value="6"
              c:identifier="G_FILE_TYPE_MOUNTABLE"
              glib:nick="mountable"/>
    </enumeration>
    <class name="FilenameCompleter"
           c:symbol-prefix="filename_completer"
           c:type="GFilenameCompleter"
           parent="GObject.Object"
           glib:type-name="GFilenameCompleter"
           glib:get-type="g_filename_completer_get_type"
           glib:type-struct="FilenameCompleterClass">
      <doc xml:whitespace="preserve">Completes filenames based on files that exist within the file system.</doc>
      <constructor name="new" c:identifier="g_filename_completer_new">
        <doc xml:whitespace="preserve">Creates a new filename completer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFilenameCompleter.</doc>
          <type name="FilenameCompleter" c:type="GFilenameCompleter*"/>
        </return-value>
      </constructor>
      <method name="get_completion_suffix"
              c:identifier="g_filename_completer_get_completion_suffix">
        <doc xml:whitespace="preserve">Obtains a completion for @initial_text from @completer.
This string is not owned by GIO, so remember to g_free() it
when finished.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a completed string, or %NULL if no completion exists.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="initial_text" transfer-ownership="none">
            <doc xml:whitespace="preserve">text to be completed.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_completions"
              c:identifier="g_filename_completer_get_completions">
        <doc xml:whitespace="preserve">Gets an array of completion strings for a given initial text.
This array must be freed by g_strfreev() when finished.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">array of strings with possible completions for @initial_text.</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="initial_text" transfer-ownership="none">
            <doc xml:whitespace="preserve">text to be completed.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dirs_only"
              c:identifier="g_filename_completer_set_dirs_only">
        <doc xml:whitespace="preserve">If @dirs_only is %TRUE, @completer will only
complete directory names, and not file names.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dirs_only" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="got-completion-data">
        <doc xml:whitespace="preserve">Emitted when the file name completion information comes available.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="FilenameCompleterClass"
            c:type="GFilenameCompleterClass"
            glib:is-gtype-struct-for="FilenameCompleter">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="got_completion_data">
        <callback name="got_completion_data">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="filename_completer" transfer-ownership="none">
              <type name="FilenameCompleter" c:type="GFilenameCompleter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="FilesystemPreviewType"
                 glib:type-name="GFilesystemPreviewType"
                 glib:get-type="g_filesystem_preview_type_get_type"
                 c:type="GFilesystemPreviewType">
      <doc xml:whitespace="preserve">Indicates a hint from the file system whether files should be
previewed in a file manager. Returned as the value of the key
#G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.</doc>
      <member name="if_always"
              value="0"
              c:identifier="G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS"
              glib:nick="if-always"/>
      <member name="if_local"
              value="1"
              c:identifier="G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL"
              glib:nick="if-local"/>
      <member name="never"
              value="2"
              c:identifier="G_FILESYSTEM_PREVIEW_TYPE_NEVER"
              glib:nick="never"/>
    </enumeration>
    <class name="FilterInputStream"
           c:symbol-prefix="filter_input_stream"
           c:type="GFilterInputStream"
           parent="InputStream"
           abstract="1"
           glib:type-name="GFilterInputStream"
           glib:get-type="g_filter_input_stream_get_type"
           glib:type-struct="FilterInputStreamClass">
      <doc xml:whitespace="preserve">A base class for all input streams that work on an underlying stream.</doc>
      <method name="get_base_stream"
              c:identifier="g_filter_input_stream_get_base_stream">
        <doc xml:whitespace="preserve">Gets the base stream for the filter stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GInputStream.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
      </method>
      <method name="get_close_base_stream"
              c:identifier="g_filter_input_stream_get_close_base_stream">
        <doc xml:whitespace="preserve">Returns whether the base stream will be closed when @stream is
closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the base stream will be closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_close_base_stream"
              c:identifier="g_filter_input_stream_set_close_base_stream">
        <doc xml:whitespace="preserve">Sets whether the base stream will be closed when @stream is closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="close_base" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to close the base stream.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="base-stream"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="InputStream"/>
      </property>
      <property name="close-base-stream"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="InputStream" c:type="GInputStream"/>
      </field>
      <field name="base_stream">
        <type name="InputStream" c:type="GInputStream*"/>
      </field>
    </class>
    <record name="FilterInputStreamClass"
            c:type="GFilterInputStreamClass"
            glib:is-gtype-struct-for="FilterInputStream">
      <field name="parent_class">
        <type name="InputStreamClass" c:type="GInputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="FilterOutputStream"
           c:symbol-prefix="filter_output_stream"
           c:type="GFilterOutputStream"
           parent="OutputStream"
           abstract="1"
           glib:type-name="GFilterOutputStream"
           glib:get-type="g_filter_output_stream_get_type"
           glib:type-struct="FilterOutputStreamClass">
      <doc xml:whitespace="preserve">A base class for all output streams that work on an underlying stream.</doc>
      <method name="get_base_stream"
              c:identifier="g_filter_output_stream_get_base_stream">
        <doc xml:whitespace="preserve">Gets the base stream for the filter stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GOutputStream.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
      </method>
      <method name="get_close_base_stream"
              c:identifier="g_filter_output_stream_get_close_base_stream">
        <doc xml:whitespace="preserve">Returns whether the base stream will be closed when @stream is
closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the base stream will be closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_close_base_stream"
              c:identifier="g_filter_output_stream_set_close_base_stream">
        <doc xml:whitespace="preserve">Sets whether the base stream will be closed when @stream is closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="close_base" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to close the base stream.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="base-stream"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="OutputStream"/>
      </property>
      <property name="close-base-stream"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="OutputStream" c:type="GOutputStream"/>
      </field>
      <field name="base_stream">
        <type name="OutputStream" c:type="GOutputStream*"/>
      </field>
    </class>
    <record name="FilterOutputStreamClass"
            c:type="GFilterOutputStreamClass"
            glib:is-gtype-struct-for="FilterOutputStream">
      <field name="parent_class">
        <type name="OutputStreamClass" c:type="GOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="IOErrorEnum"
                 glib:type-name="GIOErrorEnum"
                 glib:get-type="g_io_error_enum_get_type"
                 c:type="GIOErrorEnum"
                 glib:error-quark="g_io_error_quark">
      <doc xml:whitespace="preserve">Error codes returned by GIO functions.</doc>
      <member name="failed"
              value="0"
              c:identifier="G_IO_ERROR_FAILED"
              glib:nick="failed"/>
      <member name="not_found"
              value="1"
              c:identifier="G_IO_ERROR_NOT_FOUND"
              glib:nick="not-found"/>
      <member name="exists"
              value="2"
              c:identifier="G_IO_ERROR_EXISTS"
              glib:nick="exists"/>
      <member name="is_directory"
              value="3"
              c:identifier="G_IO_ERROR_IS_DIRECTORY"
              glib:nick="is-directory"/>
      <member name="not_directory"
              value="4"
              c:identifier="G_IO_ERROR_NOT_DIRECTORY"
              glib:nick="not-directory"/>
      <member name="not_empty"
              value="5"
              c:identifier="G_IO_ERROR_NOT_EMPTY"
              glib:nick="not-empty"/>
      <member name="not_regular_file"
              value="6"
              c:identifier="G_IO_ERROR_NOT_REGULAR_FILE"
              glib:nick="not-regular-file"/>
      <member name="not_symbolic_link"
              value="7"
              c:identifier="G_IO_ERROR_NOT_SYMBOLIC_LINK"
              glib:nick="not-symbolic-link"/>
      <member name="not_mountable_file"
              value="8"
              c:identifier="G_IO_ERROR_NOT_MOUNTABLE_FILE"
              glib:nick="not-mountable-file"/>
      <member name="filename_too_long"
              value="9"
              c:identifier="G_IO_ERROR_FILENAME_TOO_LONG"
              glib:nick="filename-too-long"/>
      <member name="invalid_filename"
              value="10"
              c:identifier="G_IO_ERROR_INVALID_FILENAME"
              glib:nick="invalid-filename"/>
      <member name="too_many_links"
              value="11"
              c:identifier="G_IO_ERROR_TOO_MANY_LINKS"
              glib:nick="too-many-links"/>
      <member name="no_space"
              value="12"
              c:identifier="G_IO_ERROR_NO_SPACE"
              glib:nick="no-space"/>
      <member name="invalid_argument"
              value="13"
              c:identifier="G_IO_ERROR_INVALID_ARGUMENT"
              glib:nick="invalid-argument"/>
      <member name="permission_denied"
              value="14"
              c:identifier="G_IO_ERROR_PERMISSION_DENIED"
              glib:nick="permission-denied"/>
      <member name="not_supported"
              value="15"
              c:identifier="G_IO_ERROR_NOT_SUPPORTED"
              glib:nick="not-supported"/>
      <member name="not_mounted"
              value="16"
              c:identifier="G_IO_ERROR_NOT_MOUNTED"
              glib:nick="not-mounted"/>
      <member name="already_mounted"
              value="17"
              c:identifier="G_IO_ERROR_ALREADY_MOUNTED"
              glib:nick="already-mounted"/>
      <member name="closed"
              value="18"
              c:identifier="G_IO_ERROR_CLOSED"
              glib:nick="closed"/>
      <member name="cancelled"
              value="19"
              c:identifier="G_IO_ERROR_CANCELLED"
              glib:nick="cancelled"/>
      <member name="pending"
              value="20"
              c:identifier="G_IO_ERROR_PENDING"
              glib:nick="pending"/>
      <member name="read_only"
              value="21"
              c:identifier="G_IO_ERROR_READ_ONLY"
              glib:nick="read-only"/>
      <member name="cant_create_backup"
              value="22"
              c:identifier="G_IO_ERROR_CANT_CREATE_BACKUP"
              glib:nick="cant-create-backup"/>
      <member name="wrong_etag"
              value="23"
              c:identifier="G_IO_ERROR_WRONG_ETAG"
              glib:nick="wrong-etag"/>
      <member name="timed_out"
              value="24"
              c:identifier="G_IO_ERROR_TIMED_OUT"
              glib:nick="timed-out"/>
      <member name="would_recurse"
              value="25"
              c:identifier="G_IO_ERROR_WOULD_RECURSE"
              glib:nick="would-recurse"/>
      <member name="busy"
              value="26"
              c:identifier="G_IO_ERROR_BUSY"
              glib:nick="busy"/>
      <member name="would_block"
              value="27"
              c:identifier="G_IO_ERROR_WOULD_BLOCK"
              glib:nick="would-block"/>
      <member name="host_not_found"
              value="28"
              c:identifier="G_IO_ERROR_HOST_NOT_FOUND"
              glib:nick="host-not-found"/>
      <member name="would_merge"
              value="29"
              c:identifier="G_IO_ERROR_WOULD_MERGE"
              glib:nick="would-merge"/>
      <member name="failed_handled"
              value="30"
              c:identifier="G_IO_ERROR_FAILED_HANDLED"
              glib:nick="failed-handled"/>
      <member name="too_many_open_files"
              value="31"
              c:identifier="G_IO_ERROR_TOO_MANY_OPEN_FILES"
              glib:nick="too-many-open-files"/>
      <member name="not_initialized"
              value="32"
              c:identifier="G_IO_ERROR_NOT_INITIALIZED"
              glib:nick="not-initialized"/>
      <member name="address_in_use"
              value="33"
              c:identifier="G_IO_ERROR_ADDRESS_IN_USE"
              glib:nick="address-in-use"/>
      <member name="partial_input"
              value="34"
              c:identifier="G_IO_ERROR_PARTIAL_INPUT"
              glib:nick="partial-input"/>
      <member name="invalid_data"
              value="35"
              c:identifier="G_IO_ERROR_INVALID_DATA"
              glib:nick="invalid-data"/>
      <member name="dbus_error"
              value="36"
              c:identifier="G_IO_ERROR_DBUS_ERROR"
              glib:nick="dbus-error"/>
      <member name="host_unreachable"
              value="37"
              c:identifier="G_IO_ERROR_HOST_UNREACHABLE"
              glib:nick="host-unreachable"/>
      <member name="network_unreachable"
              value="38"
              c:identifier="G_IO_ERROR_NETWORK_UNREACHABLE"
              glib:nick="network-unreachable"/>
      <member name="connection_refused"
              value="39"
              c:identifier="G_IO_ERROR_CONNECTION_REFUSED"
              glib:nick="connection-refused"/>
      <member name="proxy_failed"
              value="40"
              c:identifier="G_IO_ERROR_PROXY_FAILED"
              glib:nick="proxy-failed"/>
      <member name="proxy_auth_failed"
              value="41"
              c:identifier="G_IO_ERROR_PROXY_AUTH_FAILED"
              glib:nick="proxy-auth-failed"/>
      <member name="proxy_need_auth"
              value="42"
              c:identifier="G_IO_ERROR_PROXY_NEED_AUTH"
              glib:nick="proxy-need-auth"/>
      <member name="proxy_not_allowed"
              value="43"
              c:identifier="G_IO_ERROR_PROXY_NOT_ALLOWED"
              glib:nick="proxy-not-allowed"/>
    </enumeration>
    <record name="IOExtension" c:type="GIOExtension" disguised="1">
      <method name="get_name" c:identifier="g_io_extension_get_name">
        <doc xml:whitespace="preserve">Gets the name under which @extension was registered.
Note that the same type may be registered as extension
for multiple extension points, under different names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of @extension.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_priority" c:identifier="g_io_extension_get_priority">
        <doc xml:whitespace="preserve">Gets the priority with which @extension was registered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the priority of @extension</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="ref_class"
              c:identifier="g_io_extension_ref_class"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets a reference to the class for the type that is
associated with @extension.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GTypeClass for the type of @extension</doc>
          <type name="GObject.TypeClass" c:type="GTypeClass*"/>
        </return-value>
      </method>
    </record>
    <record name="IOExtensionPoint" c:type="GIOExtensionPoint" disguised="1">
      <method name="get_extension_by_name"
              c:identifier="g_io_extension_point_get_extension_by_name">
        <doc xml:whitespace="preserve">Finds a #GIOExtension for an extension point by name.
given name, or %NULL if there is no extension with that name</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GIOExtension for @extension_point that has the</doc>
          <type name="IOExtension" c:type="GIOExtension*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the extension to get</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_extensions"
              c:identifier="g_io_extension_point_get_extensions">
        <doc xml:whitespace="preserve">Gets a list of all extensions that implement this extension point.
The list is sorted by priority, beginning with the highest priority.
#GIOExtension&lt;!-- --&gt;s. The list is owned by GIO and should not be
modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="IOExtension"/>
          </type>
        </return-value>
      </method>
      <method name="get_required_type"
              c:identifier="g_io_extension_point_get_required_type">
        <doc xml:whitespace="preserve">Gets the required type for @extension_point.
or #G_TYPE_INVALID if the extension point has no required type</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType that all implementations must have,</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
      </method>
      <method name="set_required_type"
              c:identifier="g_io_extension_point_set_required_type">
        <doc xml:whitespace="preserve">Sets the required type for @extension_point to @type.
All implementations must henceforth have this type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType to require</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="IOModule"
           c:symbol-prefix="io_module"
           c:type="GIOModule"
           parent="GObject.TypeModule"
           glib:type-name="GIOModule"
           glib:get-type="g_io_module_get_type"
           glib:type-struct="IOModuleClass">
      <doc xml:whitespace="preserve">Opaque module base class for extending GIO.</doc>
      <implements name="GObject.TypePlugin"/>
      <constructor name="new" c:identifier="g_io_module_new">
        <doc xml:whitespace="preserve">Creates a new GIOModule that will load the specific
shared library when in use.
or %NULL on error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIOModule from given @filename,</doc>
          <type name="IOModule" c:type="GIOModule*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">filename of the shared library module.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="query"
                c:identifier="g_io_module_query"
                version="2.24"
                introspectable="0">
        <doc xml:whitespace="preserve">Optional API for GIO modules to implement.
Should return a list of all the extension points that may be
implemented in this module.
This method will not be called in normal use, however it may be
called when probing existing modules and recording which extension
points that this modle is used for. This means we won't have to
load and initialze this module unless its needed.
If this function is not implemented by the module the module will
always be loaded, initialized and then unloaded on application startup
so that it can register its extension points during init.
Note that a module need not actually implement all the extension points
that g_io_module_query returns, since the exact list of extension may
depend on runtime issues. However all extension points actually implemented
must be returned by g_io_module_query() (if defined).
When installing a module that implements g_io_module_query you must
run gio-querymodules in order to build the cache files required for
lazy loading.
extension points of the module. The array must be suitable for
freeing with g_strfreev().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A %NULL-terminated array of strings, listing the supported</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
      </function>
      <method name="load" c:identifier="g_io_module_load">
        <doc xml:whitespace="preserve">Required API for GIO modules to implement.
This function is ran after the module has been loaded into GIO,
to initialize the module.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="unload" c:identifier="g_io_module_unload">
        <doc xml:whitespace="preserve">Required API for GIO modules to implement.
This function is ran when the module is being unloaded from GIO,
to finalize the module.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </class>
    <record name="IOModuleClass"
            c:type="GIOModuleClass"
            disguised="1"
            glib:is-gtype-struct-for="IOModule">
    </record>
    <record name="IOSchedulerJob" c:type="GIOSchedulerJob" disguised="1">
      <doc xml:whitespace="preserve">Opaque class for definining and scheduling IO jobs.</doc>
      <method name="send_to_mainloop"
              c:identifier="g_io_scheduler_job_send_to_mainloop">
        <doc xml:whitespace="preserve">Used from an I/O job to send a callback to be run in the thread
that the job was started from, waiting for the result (and thus
blocking the I/O job).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The return value of @func</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">a #GSourceFunc callback that will be called in the original thread</doc>
            <type name="GLib.SourceFunc" c:type="GSourceFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">a #GDestroyNotify for @user_data, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_to_mainloop_async"
              c:identifier="g_io_scheduler_job_send_to_mainloop_async">
        <doc xml:whitespace="preserve">Used from an I/O job to send a callback to be run asynchronously in
the thread that the job was started from. The callback will be run
when the main loop is available, but at that time the I/O job might
have finished. The return value from the callback is ignored.
Note that if you are passing the @user_data from g_io_scheduler_push_job()
on to this function you have to ensure that it is not freed before
g_io_scheduler_push_job() or by using refcounting for @user_data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">a #GSourceFunc callback that will be called in the original thread</doc>
            <type name="GLib.SourceFunc" c:type="GSourceFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">a #GDestroyNotify for @user_data, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="IOSchedulerJobFunc" c:type="GIOSchedulerJobFunc">
      <doc xml:whitespace="preserve">I/O Job function.
Note that depending on whether threads are available, the
#GIOScheduler may run jobs in separate threads or in an idle
in the mainloop.
Long-running jobs should periodically check the @cancellable
to see if they have been cancelled.
complete the job, %FALSE if the job is complete (or cancelled)</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if this function should be called again to</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="job" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GIOSchedulerJob.</doc>
          <type name="IOSchedulerJob" c:type="GIOSchedulerJob*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">the data to pass to callback function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="IOStream"
           c:symbol-prefix="io_stream"
           c:type="GIOStream"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GIOStream"
           glib:get-type="g_io_stream_get_type"
           glib:type-struct="IOStreamClass">
      <doc xml:whitespace="preserve">Base class for read-write streams.</doc>
      <virtual-method name="close_async" invoker="close_async" version="2.22">
        <doc xml:whitespace="preserve">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_io_stream_close_finish() to get
the result of the operation.
For behaviour details see g_io_stream_close().
The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the io priority of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_finish"
                      invoker="close_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Closes a stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_input_stream"
                      invoker="get_input_stream"
                      version="2.22">
        <doc xml:whitespace="preserve">Gets the input stream for this object. This is used
for reading.
Do not free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GInputStream, owned by the #GIOStream.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_output_stream"
                      invoker="get_output_stream"
                      version="2.22">
        <doc xml:whitespace="preserve">Gets the output stream for this object. This is used for
writing.
Do not free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GOutputStream, owned by the #GIOStream.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
      </virtual-method>
      <method name="clear_pending"
              c:identifier="g_io_stream_clear_pending"
              version="2.22">
        <doc xml:whitespace="preserve">Clears the pending flag on @stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="close"
              c:identifier="g_io_stream_close"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Closes the stream, releasing resources related to it. This will also
closes the individual input and output streams, if they are not already
closed.
Once the stream is closed, all other operations will return
%G_IO_ERROR_CLOSED. Closing a stream multiple times will not
return an error.
Closing a stream will automatically flush any outstanding buffers
in the stream.
Streams will be automatically closed when the last reference
is dropped, but you might want to call this function to make sure
resources are released as early as possible.
Some streams might keep the backing store of the stream (e.g. a file
descriptor) open after the stream is closed. See the documentation for
the individual stream for details.
On failure the first error that happened will be reported, but the
close operation will finish as much as possible. A stream that failed
to close will still return %G_IO_ERROR_CLOSED for all operations.
Still, it is important to check and report the error to the user,
otherwise there might be a loss of data as all data might not be written.
If @cancellable is not NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Cancelling a close will still leave the stream closed, but some streams
can use a faster close that doesn't block to e.g. check errors.
The default implementation of this method just calls close on the
individual input/output streams.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async"
              c:identifier="g_io_stream_close_async"
              version="2.22">
        <doc xml:whitespace="preserve">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_io_stream_close_finish() to get
the result of the operation.
For behaviour details see g_io_stream_close().
The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the io priority of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish"
              c:identifier="g_io_stream_close_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Closes a stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_input_stream"
              c:identifier="g_io_stream_get_input_stream"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the input stream for this object. This is used
for reading.
Do not free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GInputStream, owned by the #GIOStream.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
      </method>
      <method name="get_output_stream"
              c:identifier="g_io_stream_get_output_stream"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the output stream for this object. This is used for
writing.
Do not free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GOutputStream, owned by the #GIOStream.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
      </method>
      <method name="has_pending"
              c:identifier="g_io_stream_has_pending"
              version="2.22">
        <doc xml:whitespace="preserve">Checks if a stream has pending actions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @stream has pending actions.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_closed"
              c:identifier="g_io_stream_is_closed"
              version="2.22">
        <doc xml:whitespace="preserve">Checks if a stream is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the stream is closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_pending"
              c:identifier="g_io_stream_set_pending"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Sets @stream to have actions pending. If the pending flag is
already set or @stream is closed, it will return %FALSE and set</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if pending was previously unset and is now set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="closed" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="input-stream" transfer-ownership="none">
        <type name="InputStream"/>
      </property>
      <property name="output-stream" transfer-ownership="none">
        <type name="OutputStream"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="IOStreamPrivate" c:type="GIOStreamPrivate*"/>
      </field>
    </class>
    <record name="IOStreamClass"
            c:type="GIOStreamClass"
            glib:is-gtype-struct-for="IOStream">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_input_stream">
        <callback name="get_input_stream">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GInputStream, owned by the #GIOStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_output_stream">
        <callback name="get_output_stream">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GOutputStream, owned by the #GIOStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_fn">
        <callback name="close_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_async">
        <callback name="close_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the io priority of the request</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_finish">
        <callback name="close_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved8" introspectable="0">
        <callback name="_g_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved9" introspectable="0">
        <callback name="_g_reserved9">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved10" introspectable="0">
        <callback name="_g_reserved10">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="IOStreamPrivate" c:type="GIOStreamPrivate" disguised="1">
    </record>
    <interface name="Icon"
               c:symbol-prefix="icon"
               c:type="GIcon"
               glib:type-name="GIcon"
               glib:get-type="g_icon_get_type"
               glib:type-struct="IconIface">
      <doc xml:whitespace="preserve">An abstract type that specifies an icon.</doc>
      <virtual-method name="equal" invoker="equal">
        <doc xml:whitespace="preserve">Checks if two icons are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @icon1 is equal to @icon2. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="icon2" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to the second #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="hash">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
      </virtual-method>
      <virtual-method name="to_tokens" invoker="to_string" version="2.20">
        <doc xml:whitespace="preserve">Generates a textual representation of @icon that can be used for
serialization such as when passing @icon to a different process or
saving it to persistent storage. Use g_icon_new_for_string() to
get @icon back from the returned string.
The encoding of the returned string is proprietary to #GIcon except
in the following two cases
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;
If @icon is a #GFileIcon, the returned string is a native path
(such as &lt;literal&gt;/path/to/my icon.png&lt;/literal&gt;) without escaping
if the #GFile for @icon is a native file.  If the file is not
native, the returned string is the result of g_file_get_uri()
(such as &lt;literal&gt;sftp://path/to/my%%20icon.png&lt;/literal&gt;).
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
If @icon is a #GThemedIcon with exactly one name, the encoding is
simply the name (such as &lt;literal&gt;network-server&lt;/literal&gt;).
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
be serialized. Use g_free() to free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">An allocated NUL-terminated UTF8 string or %NULL if @icon can't</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tokens" transfer-ownership="none">
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="out_version" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="equal" c:identifier="g_icon_equal">
        <doc xml:whitespace="preserve">Checks if two icons are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @icon1 is equal to @icon2. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="icon2" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to the second #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="g_icon_to_string" version="2.20">
        <doc xml:whitespace="preserve">Generates a textual representation of @icon that can be used for
serialization such as when passing @icon to a different process or
saving it to persistent storage. Use g_icon_new_for_string() to
get @icon back from the returned string.
The encoding of the returned string is proprietary to #GIcon except
in the following two cases
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;
If @icon is a #GFileIcon, the returned string is a native path
(such as &lt;literal&gt;/path/to/my icon.png&lt;/literal&gt;) without escaping
if the #GFile for @icon is a native file.  If the file is not
native, the returned string is the result of g_file_get_uri()
(such as &lt;literal&gt;sftp://path/to/my%%20icon.png&lt;/literal&gt;).
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
If @icon is a #GThemedIcon with exactly one name, the encoding is
simply the name (such as &lt;literal&gt;network-server&lt;/literal&gt;).
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
be serialized. Use g_free() to free.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">An allocated NUL-terminated UTF8 string or %NULL if @icon can't</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
    </interface>
    <record name="IconIface"
            c:type="GIconIface"
            glib:is-gtype-struct-for="Icon">
      <doc xml:whitespace="preserve">GIconIface is used to implement GIcon types for various
different systems. See #GThemedIcon and #GLoadableIcon for
examples of how to implement this interface.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="hash">
        <callback name="hash">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none">
              <type name="Icon" c:type="GIcon*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="equal">
        <callback name="equal">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if @icon1 is equal to @icon2. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="icon1" transfer-ownership="none">
              <type name="Icon" c:type="GIcon*"/>
            </parameter>
            <parameter name="icon2" transfer-ownership="none">
              <doc xml:whitespace="preserve">pointer to the second #GIcon.</doc>
              <type name="Icon" c:type="GIcon*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="to_tokens">
        <callback name="to_tokens">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">An allocated NUL-terminated UTF8 string or %NULL if @icon can't</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none">
              <type name="Icon" c:type="GIcon*"/>
            </parameter>
            <parameter name="tokens" transfer-ownership="none">
              <array name="GLib.PtrArray" c:type="GPtrArray*">
                <type name="gpointer" c:type="gpointer"/>
              </array>
            </parameter>
            <parameter name="out_version" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="from_tokens" introspectable="0">
        <callback name="from_tokens" introspectable="0" throws="1">
          <return-value>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="tokens" transfer-ownership="none">
              <type name="utf8" c:type="gchar**"/>
            </parameter>
            <parameter name="num_tokens" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="version" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="InetAddress"
           c:symbol-prefix="inet_address"
           c:type="GInetAddress"
           parent="GObject.Object"
           glib:type-name="GInetAddress"
           glib:get-type="g_inet_address_get_type"
           glib:type-struct="InetAddressClass">
      <doc xml:whitespace="preserve">An IPv4 or IPv6 internet address.</doc>
      <constructor name="new_any"
                   c:identifier="g_inet_address_new_any"
                   version="2.22">
        <doc xml:whitespace="preserve">Creates a #GInetAddress for the "any" address (unassigned/"don't
care") for @family.
for @family.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GInetAddress corresponding to the "any" address</doc>
          <type name="InetAddress" c:type="GInetAddress*"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:whitespace="preserve">the address family</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_bytes"
                   c:identifier="g_inet_address_new_from_bytes"
                   version="2.22">
        <doc xml:whitespace="preserve">Creates a new #GInetAddress from the given @family and @bytes.
%G_INET_ADDRESS_IPV6.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GInetAddress corresponding to @family and @bytes.</doc>
          <type name="InetAddress" c:type="GInetAddress*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">raw address data</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="family" transfer-ownership="none">
            <doc xml:whitespace="preserve">the address family of @bytes</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_string"
                   c:identifier="g_inet_address_new_from_string"
                   version="2.22">
        <doc xml:whitespace="preserve">Parses @string as an IP address and creates a new #GInetAddress.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GInetAddress corresponding to @string, or %NULL if</doc>
          <type name="InetAddress" c:type="GInetAddress*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string representation of an IP address</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_loopback"
                   c:identifier="g_inet_address_new_loopback"
                   version="2.22">
        <doc xml:whitespace="preserve">Creates a #GInetAddress for the loopback address for @family.
for @family.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GInetAddress corresponding to the loopback address</doc>
          <type name="InetAddress" c:type="GInetAddress*"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:whitespace="preserve">the address family</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="to_bytes" invoker="to_bytes" version="2.22">
        <doc xml:whitespace="preserve">Gets the raw binary address data from @address.
which should not be modified, stored, or freed. The size of this
array can be gotten with g_inet_address_get_native_size().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to an internal array of the bytes in @address,</doc>
          <type name="guint8" c:type="guint8*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="to_string" invoker="to_string" version="2.22">
        <doc xml:whitespace="preserve">Converts @address to string form.
freed after use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a representation of @address as a string, which should be</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </virtual-method>
      <method name="get_family"
              c:identifier="g_inet_address_get_family"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @address's family</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@address's family</doc>
          <type name="SocketFamily" c:type="GSocketFamily"/>
        </return-value>
      </method>
      <method name="get_is_any"
              c:identifier="g_inet_address_get_is_any"
              version="2.22">
        <doc xml:whitespace="preserve">Tests whether @address is the "any" address for its family.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @address is the "any" address for its family.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_is_link_local"
              c:identifier="g_inet_address_get_is_link_local"
              version="2.22">
        <doc xml:whitespace="preserve">Tests whether @address is a link-local address (that is, if it
identifies a host on a local network that is not connected to the
Internet).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @address is a link-local address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_is_loopback"
              c:identifier="g_inet_address_get_is_loopback"
              version="2.22">
        <doc xml:whitespace="preserve">Tests whether @address is the loopback address for its family.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @address is the loopback address for its family.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_is_mc_global"
              c:identifier="g_inet_address_get_is_mc_global"
              version="2.22">
        <doc xml:whitespace="preserve">Tests whether @address is a global multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @address is a global multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_is_mc_link_local"
              c:identifier="g_inet_address_get_is_mc_link_local"
              version="2.22">
        <doc xml:whitespace="preserve">Tests whether @address is a link-local multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @address is a link-local multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_is_mc_node_local"
              c:identifier="g_inet_address_get_is_mc_node_local"
              version="2.22">
        <doc xml:whitespace="preserve">Tests whether @address is a node-local multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @address is a node-local multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_is_mc_org_local"
              c:identifier="g_inet_address_get_is_mc_org_local"
              version="2.22">
        <doc xml:whitespace="preserve">Tests whether @address is an organization-local multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @address is an organization-local multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_is_mc_site_local"
              c:identifier="g_inet_address_get_is_mc_site_local"
              version="2.22">
        <doc xml:whitespace="preserve">Tests whether @address is a site-local multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @address is a site-local multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_is_multicast"
              c:identifier="g_inet_address_get_is_multicast"
              version="2.22">
        <doc xml:whitespace="preserve">Tests whether @address is a multicast address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @address is a multicast address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_is_site_local"
              c:identifier="g_inet_address_get_is_site_local"
              version="2.22">
        <doc xml:whitespace="preserve">Tests whether @address is a site-local address such as 10.0.0.1
(that is, the address identifies a host on a local network that can
not be reached directly from the Internet, but which may have
outgoing Internet connectivity via a NAT or firewall).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @address is a site-local address.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_native_size"
              c:identifier="g_inet_address_get_native_size"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the size of the native raw binary address for @address. This
is the size of the data that you get from g_inet_address_to_bytes().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes used for the native version of @address.</doc>
          <type name="gulong" c:type="gsize"/>
        </return-value>
      </method>
      <method name="to_bytes"
              c:identifier="g_inet_address_to_bytes"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the raw binary address data from @address.
which should not be modified, stored, or freed. The size of this
array can be gotten with g_inet_address_get_native_size().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to an internal array of the bytes in @address,</doc>
          <type name="guint8" c:type="guint8*"/>
        </return-value>
      </method>
      <method name="to_string"
              c:identifier="g_inet_address_to_string"
              version="2.22">
        <doc xml:whitespace="preserve">Converts @address to string form.
freed after use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a representation of @address as a string, which should be</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <property name="bytes"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer"/>
      </property>
      <property name="family"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="SocketFamily"/>
      </property>
      <property name="is-any" version="2.22" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this is the "any" address for its family.
See g_inet_address_get_is_any().</doc>
        <type name="gboolean"/>
      </property>
      <property name="is-link-local" version="2.22" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this is a link-local address.
See g_inet_address_get_is_link_local().</doc>
        <type name="gboolean"/>
      </property>
      <property name="is-loopback" version="2.22" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this is the loopback address for its family.
See g_inet_address_get_is_loopback().</doc>
        <type name="gboolean"/>
      </property>
      <property name="is-mc-global" version="2.22" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this is a global multicast address.
See g_inet_address_get_is_mc_global().</doc>
        <type name="gboolean"/>
      </property>
      <property name="is-mc-link-local"
                version="2.22"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this is a link-local multicast address.
See g_inet_address_get_is_mc_link_local().</doc>
        <type name="gboolean"/>
      </property>
      <property name="is-mc-node-local"
                version="2.22"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this is a node-local multicast address.
See g_inet_address_get_is_mc_node_local().</doc>
        <type name="gboolean"/>
      </property>
      <property name="is-mc-org-local"
                version="2.22"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this is an organization-local multicast address.
See g_inet_address_get_is_mc_org_local().</doc>
        <type name="gboolean"/>
      </property>
      <property name="is-mc-site-local"
                version="2.22"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this is a site-local multicast address.
See g_inet_address_get_is_mc_site_local().</doc>
        <type name="gboolean"/>
      </property>
      <property name="is-multicast" version="2.22" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this is a multicast address.
See g_inet_address_get_is_multicast().</doc>
        <type name="gboolean"/>
      </property>
      <property name="is-site-local" version="2.22" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this is a site-local address.
See g_inet_address_get_is_loopback().</doc>
        <type name="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="InetAddressPrivate" c:type="GInetAddressPrivate*"/>
      </field>
    </class>
    <record name="InetAddressClass"
            c:type="GInetAddressClass"
            glib:is-gtype-struct-for="InetAddress">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="to_string">
        <callback name="to_string">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a representation of @address as a string, which should be</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="address" transfer-ownership="none">
              <type name="InetAddress" c:type="GInetAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="to_bytes">
        <callback name="to_bytes">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to an internal array of the bytes in @address,</doc>
            <type name="guint8" c:type="guint8*"/>
          </return-value>
          <parameters>
            <parameter name="address" transfer-ownership="none">
              <type name="InetAddress" c:type="GInetAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="InetAddressPrivate"
            c:type="GInetAddressPrivate"
            disguised="1">
    </record>
    <class name="InetSocketAddress"
           c:symbol-prefix="inet_socket_address"
           c:type="GInetSocketAddress"
           parent="SocketAddress"
           glib:type-name="GInetSocketAddress"
           glib:get-type="g_inet_socket_address_get_type"
           glib:type-struct="InetSocketAddressClass">
      <doc xml:whitespace="preserve">An IPv4 or IPv6 socket address, corresponding to a &lt;type&gt;struct
sockaddr_in&lt;/type&gt; or &lt;type&gt;struct sockaddr_in6&lt;/type&gt;.</doc>
      <implements name="SocketConnectable"/>
      <constructor name="new"
                   c:identifier="g_inet_socket_address_new"
                   version="2.22">
        <doc xml:whitespace="preserve">Creates a new #GInetSocketAddress for @address and @port.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GInetSocketAddress</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GInetAddress</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:whitespace="preserve">a port number</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_address"
              c:identifier="g_inet_socket_address_get_address"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @address's #GInetAddress.
g_object_ref()'d if it will be stored</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GInetAddress for @address, which must be</doc>
          <type name="InetAddress" c:type="GInetAddress*"/>
        </return-value>
      </method>
      <method name="get_port"
              c:identifier="g_inet_socket_address_get_port"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @address's port.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the port for @address</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
      </method>
      <property name="address"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="InetAddress"/>
      </property>
      <property name="port"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint"/>
      </property>
      <field name="parent_instance">
        <type name="SocketAddress" c:type="GSocketAddress"/>
      </field>
      <field name="priv">
        <type name="InetSocketAddressPrivate"
              c:type="GInetSocketAddressPrivate*"/>
      </field>
    </class>
    <record name="InetSocketAddressClass"
            c:type="GInetSocketAddressClass"
            glib:is-gtype-struct-for="InetSocketAddress">
      <field name="parent_class">
        <type name="SocketAddressClass" c:type="GSocketAddressClass"/>
      </field>
    </record>
    <record name="InetSocketAddressPrivate"
            c:type="GInetSocketAddressPrivate"
            disguised="1">
    </record>
    <interface name="Initable"
               c:symbol-prefix="initable"
               c:type="GInitable"
               version="2.22"
               glib:type-name="GInitable"
               glib:get-type="g_initable_get_type"
               glib:type-struct="InitableIface">
      <doc xml:whitespace="preserve">Interface for initializable objects.</doc>
      <virtual-method name="init" invoker="init" version="2.22" throws="1">
        <doc xml:whitespace="preserve">Initializes the object implementing the interface. This must be
done before any real use of the object after initial construction.
Implementations may also support cancellation. If @cancellable is not %NULL,
then initialization can be cancelled by triggering the cancellable object
from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
the object doesn't support cancellable initialization the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.
If this function is not called, or returns with an error then all
operations on the object should fail, generally returning the
error %G_IO_ERROR_NOT_INITIALIZED.
Implementations of this method must be idempotent, i.e. multiple calls
to this function with the same argument should return the same results.
Only the first call initializes the object, further calls return the result
of the first call. This is so that its safe to implement the singleton
pattern in the GObject constructor function.
return %FALSE and set @error appropriately if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful. If an error has occurred, this function will</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="init"
              c:identifier="g_initable_init"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Initializes the object implementing the interface. This must be
done before any real use of the object after initial construction.
Implementations may also support cancellation. If @cancellable is not %NULL,
then initialization can be cancelled by triggering the cancellable object
from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
the object doesn't support cancellable initialization the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.
If this function is not called, or returns with an error then all
operations on the object should fail, generally returning the
error %G_IO_ERROR_NOT_INITIALIZED.
Implementations of this method must be idempotent, i.e. multiple calls
to this function with the same argument should return the same results.
Only the first call initializes the object, further calls return the result
of the first call. This is so that its safe to implement the singleton
pattern in the GObject constructor function.
return %FALSE and set @error appropriately if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful. If an error has occurred, this function will</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="InitableIface"
            c:type="GInitableIface"
            glib:is-gtype-struct-for="Initable"
            version="2.22">
      <doc xml:whitespace="preserve">Provides an interface for initializing object such that initialization
may fail.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="init">
        <callback name="init" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if successful. If an error has occurred, this function will</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="initable" transfer-ownership="none">
              <type name="Initable" c:type="GInitable*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="InputStream"
           c:symbol-prefix="input_stream"
           c:type="GInputStream"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GInputStream"
           glib:get-type="g_input_stream_get_type"
           glib:type-struct="InputStreamClass">
      <doc xml:whitespace="preserve">Base class for streaming input operations.</doc>
      <virtual-method name="close_async" invoker="close_async">
        <doc xml:whitespace="preserve">Requests an asynchronous closes of the stream, releasing resources related to it.
When the operation is finished @callback will be called.
You can then call g_input_stream_close_finish() to get the result of the
operation.
For behaviour details see g_input_stream_close().
The asyncronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_finish" invoker="close_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes closing a stream asynchronously, started from g_input_stream_close_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the stream was closed successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_async" invoker="read_async">
        <doc xml:whitespace="preserve">Request an asynchronous read of @count bytes from the stream into the buffer
starting at @buffer. When the operation is finished @callback will be called.
You can then call g_input_stream_read_finish() to get the result of the
operation.
During an async request no other sync and async calls are allowed on @stream, and will
result in %G_IO_ERROR_PENDING errors.
A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
On success, the number of bytes read into the buffer will be passed to the
callback. It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to read
as many bytes as requested. Zero is returned on end of file
(or if @count is zero),  but never otherwise.
Any outstanding i/o request with higher priority (lower numerical value) will
be executed before an outstanding request with lower priority. Default
priority is %G_PRIORITY_DEFAULT.
The asyncronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffer to read data into (which should be at least count bytes long).</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="5">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_finish" invoker="read_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous stream read operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">number of bytes read in, or -1 on error.</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="skip" invoker="skip" throws="1">
        <doc xml:whitespace="preserve">Tries to skip @count bytes from the stream. Will block during the operation.
This is identical to g_input_stream_read(), from a behaviour standpoint,
but the bytes that are skipped are not returned to the user. Some
streams have an implementation that is more efficient than reading the data.
This function is optional for inherited classes, as the default implementation
emulates it using read.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes skipped, or -1 on error</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be skipped from the stream</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="skip_async" invoker="skip_async">
        <doc xml:whitespace="preserve">Request an asynchronous skip of @count bytes from the stream.
When the operation is finished @callback will be called.
You can then call g_input_stream_skip_finish() to get the result
of the operation.
During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.
A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
On success, the number of bytes skipped will be passed to the callback.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to skip
as many bytes as requested. Zero is returned on end of file
(or if @count is zero), but never otherwise.
Any outstanding i/o request with higher priority (lower numerical value)
will be executed before an outstanding request with lower priority.
Default priority is %G_PRIORITY_DEFAULT.
The asynchronous methods have a default fallback that uses threads to
implement asynchronicity, so they are optional for inheriting classes.
However, if you override one, you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be skipped from the stream</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="skip_finish" invoker="skip_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes a stream skip operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the bytes skipped, or %-1 on error.</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clear_pending" c:identifier="g_input_stream_clear_pending">
        <doc xml:whitespace="preserve">Clears the pending flag on @stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="close" c:identifier="g_input_stream_close" throws="1">
        <doc xml:whitespace="preserve">Closes the stream, releasing resources related to it.
Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
Closing a stream multiple times will not return an error.
Streams will be automatically closed when the last reference
is dropped, but you might want to call this function to make sure
resources are released as early as possible.
Some streams might keep the backing store of the stream (e.g. a file descriptor)
open after the stream is closed. See the documentation for the individual
stream for details.
On failure the first error that happened will be reported, but the close
operation will finish as much as possible. A stream that failed to
close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
is important to check and report the error to the user.
If @cancellable is not NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Cancelling a close will still leave the stream closed, but some streams
can use a faster close that doesn't block to e.g. check errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async" c:identifier="g_input_stream_close_async">
        <doc xml:whitespace="preserve">Requests an asynchronous closes of the stream, releasing resources related to it.
When the operation is finished @callback will be called.
You can then call g_input_stream_close_finish() to get the result of the
operation.
For behaviour details see g_input_stream_close().
The asyncronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish"
              c:identifier="g_input_stream_close_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes closing a stream asynchronously, started from g_input_stream_close_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the stream was closed successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_pending" c:identifier="g_input_stream_has_pending">
        <doc xml:whitespace="preserve">Checks if an input stream has pending actions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @stream has pending actions.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_closed" c:identifier="g_input_stream_is_closed">
        <doc xml:whitespace="preserve">Checks if an input stream is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the stream is closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="read" c:identifier="g_input_stream_read" throws="1">
        <doc xml:whitespace="preserve">Tries to read @count bytes from the stream into the buffer starting at
If count is zero returns zero and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
On success, the number of bytes read into the buffer is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file. Zero is returned on end of file
(or if @count is zero),  but never otherwise.
If @cancellable is not NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.
On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes read, or -1 on error</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffer to read data into (which should be at least count bytes long).</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_all"
              c:identifier="g_input_stream_read_all"
              throws="1">
        <doc xml:whitespace="preserve">Tries to read @count bytes from the stream into the buffer starting at
This function is similar to g_input_stream_read(), except it tries to
read as many bytes as requested, only stopping on an error or end of stream.
On a successful read of @count bytes, or if we reached the end of the
stream,  %TRUE is returned, and @bytes_read is set to the number of bytes
read into @buffer.
If there is an error during the operation %FALSE is returned and @error
is set to indicate the error status, @bytes_read is updated to contain
the number of bytes read into @buffer before the error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffer to read data into (which should be at least count bytes long).</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="bytes_read" transfer-ownership="none">
            <doc xml:whitespace="preserve">location to store the number of bytes that was read from the stream</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_async" c:identifier="g_input_stream_read_async">
        <doc xml:whitespace="preserve">Request an asynchronous read of @count bytes from the stream into the buffer
starting at @buffer. When the operation is finished @callback will be called.
You can then call g_input_stream_read_finish() to get the result of the
operation.
During an async request no other sync and async calls are allowed on @stream, and will
result in %G_IO_ERROR_PENDING errors.
A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
On success, the number of bytes read into the buffer will be passed to the
callback. It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to read
as many bytes as requested. Zero is returned on end of file
(or if @count is zero),  but never otherwise.
Any outstanding i/o request with higher priority (lower numerical value) will
be executed before an outstanding request with lower priority. Default
priority is %G_PRIORITY_DEFAULT.
The asyncronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffer to read data into (which should be at least count bytes long).</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be read from the stream</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_finish"
              c:identifier="g_input_stream_read_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous stream read operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">number of bytes read in, or -1 on error.</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pending"
              c:identifier="g_input_stream_set_pending"
              throws="1">
        <doc xml:whitespace="preserve">Sets @stream to have actions pending. If the pending flag is
already set or @stream is closed, it will return %FALSE and set</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if pending was previously unset and is now set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="skip" c:identifier="g_input_stream_skip" throws="1">
        <doc xml:whitespace="preserve">Tries to skip @count bytes from the stream. Will block during the operation.
This is identical to g_input_stream_read(), from a behaviour standpoint,
but the bytes that are skipped are not returned to the user. Some
streams have an implementation that is more efficient than reading the data.
This function is optional for inherited classes, as the default implementation
emulates it using read.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes skipped, or -1 on error</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be skipped from the stream</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip_async" c:identifier="g_input_stream_skip_async">
        <doc xml:whitespace="preserve">Request an asynchronous skip of @count bytes from the stream.
When the operation is finished @callback will be called.
You can then call g_input_stream_skip_finish() to get the result
of the operation.
During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.
A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
On success, the number of bytes skipped will be passed to the callback.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to skip
as many bytes as requested. Zero is returned on end of file
(or if @count is zero), but never otherwise.
Any outstanding i/o request with higher priority (lower numerical value)
will be executed before an outstanding request with lower priority.
Default priority is %G_PRIORITY_DEFAULT.
The asynchronous methods have a default fallback that uses threads to
implement asynchronicity, so they are optional for inheriting classes.
However, if you override one, you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes that will be skipped from the stream</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip_finish"
              c:identifier="g_input_stream_skip_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes a stream skip operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the bytes skipped, or %-1 on error.</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="InputStreamPrivate" c:type="GInputStreamPrivate*"/>
      </field>
    </class>
    <record name="InputStreamClass"
            c:type="GInputStreamClass"
            glib:is-gtype-struct-for="InputStream">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="read_fn">
        <callback name="read_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="glong" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="gulong" c:type="gsize"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="skip">
        <callback name="skip" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">Number of bytes skipped, or -1 on error</doc>
            <type name="glong" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:whitespace="preserve">the number of bytes that will be skipped from the stream</doc>
              <type name="gulong" c:type="gsize"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_fn">
        <callback name="close_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_async">
        <callback name="read_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:whitespace="preserve">a buffer to read data into (which should be at least count bytes long).</doc>
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:whitespace="preserve">the number of bytes that will be read from the stream</doc>
              <type name="gulong" c:type="gsize"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="6">
              <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="6">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_finish">
        <callback name="read_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bytes read in, or -1 on error.</doc>
            <type name="glong" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="skip_async">
        <callback name="skip_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:whitespace="preserve">the number of bytes that will be skipped from the stream</doc>
              <type name="gulong" c:type="gsize"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="skip_finish">
        <callback name="skip_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the bytes skipped, or %-1 on error.</doc>
            <type name="glong" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_async">
        <callback name="close_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_finish">
        <callback name="close_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the stream was closed successfully.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="InputStreamPrivate"
            c:type="GInputStreamPrivate"
            disguised="1">
    </record>
    <record name="InputVector" c:type="GInputVector" version="2.22">
      <doc xml:whitespace="preserve">Structure used for scatter/gather data input.
You generally pass in an array of #GInputVector&lt;!-- --&gt;s
and the operation will store the read data starting in the
first buffer, switching to the next as needed.</doc>
      <field name="buffer" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="size" writable="1">
        <type name="gulong" c:type="gsize"/>
      </field>
    </record>
    <interface name="LoadableIcon"
               c:symbol-prefix="loadable_icon"
               c:type="GLoadableIcon"
               glib:type-name="GLoadableIcon"
               glib:get-type="g_loadable_icon_get_type"
               glib:type-struct="LoadableIconIface">
      <doc xml:whitespace="preserve">Generic type for all kinds of icons that can be loaded
as a stream.</doc>
      <prerequisite name="Icon"/>
      <virtual-method name="load" invoker="load" throws="1">
        <doc xml:whitespace="preserve">Loads a loadable icon. For the asynchronous version of this function,
see g_loadable_icon_load_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">an integer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store the type of the loaded icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="load_async" invoker="load_async">
        <doc xml:whitespace="preserve">Loads an icon asynchronously. To finish this function, see
g_loadable_icon_load_finish(). For the synchronous, blocking
version of this function, see g_loadable_icon_load().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">an integer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="load_finish" invoker="load_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous icon load started in g_loadable_icon_load_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store the type of the loaded icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="load" c:identifier="g_loadable_icon_load" throws="1">
        <doc xml:whitespace="preserve">Loads a loadable icon. For the asynchronous version of this function,
see g_loadable_icon_load_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">an integer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store the type of the loaded icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_async" c:identifier="g_loadable_icon_load_async">
        <doc xml:whitespace="preserve">Loads an icon asynchronously. To finish this function, see
g_loadable_icon_load_finish(). For the synchronous, blocking
version of this function, see g_loadable_icon_load().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">an integer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_finish"
              c:identifier="g_loadable_icon_load_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous icon load started in g_loadable_icon_load_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store the type of the loaded icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="LoadableIconIface"
            c:type="GLoadableIconIface"
            glib:is-gtype-struct-for="LoadableIcon">
      <doc xml:whitespace="preserve">Interface for icons that can be loaded as a stream.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="load">
        <callback name="load" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GInputStream to read the icon from.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none">
              <type name="LoadableIcon" c:type="GLoadableIcon*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <doc xml:whitespace="preserve">an integer.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:whitespace="preserve">a location to store the type of the loaded icon, %NULL to ignore.</doc>
              <type name="utf8" c:type="char**"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="load_async">
        <callback name="load_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none">
              <type name="LoadableIcon" c:type="GLoadableIcon*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <doc xml:whitespace="preserve">an integer.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="load_finish">
        <callback name="load_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GInputStream to read the icon from.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none">
              <type name="LoadableIcon" c:type="GLoadableIcon*"/>
            </parameter>
            <parameter name="res" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:whitespace="preserve">a location to store the type of the loaded icon, %NULL to ignore.</doc>
              <type name="utf8" c:type="char**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="MemoryInputStream"
           c:symbol-prefix="memory_input_stream"
           c:type="GMemoryInputStream"
           parent="InputStream"
           glib:type-name="GMemoryInputStream"
           glib:get-type="g_memory_input_stream_get_type"
           glib:type-struct="MemoryInputStreamClass">
      <doc xml:whitespace="preserve">Implements #GInputStream for arbitrary memory chunks.</doc>
      <implements name="Seekable"/>
      <constructor name="new" c:identifier="g_memory_input_stream_new">
        <doc xml:whitespace="preserve">Creates a new empty #GMemoryInputStream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GInputStream</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_data"
                   c:identifier="g_memory_input_stream_new_from_data">
        <doc xml:whitespace="preserve">Creates a new #GMemoryInputStream with data in memory of a given size.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">new #GInputStream read from @data of @len bytes.</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">input data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">length of the data, may be -1 if @data is a nul-terminated string</doc>
            <type name="glong" c:type="gssize"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">function that is called to free @data, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_data" c:identifier="g_memory_input_stream_add_data">
        <doc xml:whitespace="preserve">Appends @data to data that can be read from the input stream</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">input data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">length of the data, may be -1 if @data is a nul-terminated string</doc>
            <type name="glong" c:type="gssize"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">function that is called to free @data, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="InputStream" c:type="GInputStream"/>
      </field>
      <field name="priv">
        <type name="MemoryInputStreamPrivate"
              c:type="GMemoryInputStreamPrivate*"/>
      </field>
    </class>
    <record name="MemoryInputStreamClass"
            c:type="GMemoryInputStreamClass"
            glib:is-gtype-struct-for="MemoryInputStream">
      <field name="parent_class">
        <type name="InputStreamClass" c:type="GInputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="MemoryInputStreamPrivate"
            c:type="GMemoryInputStreamPrivate"
            disguised="1">
    </record>
    <class name="MemoryOutputStream"
           c:symbol-prefix="memory_output_stream"
           c:type="GMemoryOutputStream"
           parent="OutputStream"
           glib:type-name="GMemoryOutputStream"
           glib:get-type="g_memory_output_stream_get_type"
           glib:type-struct="MemoryOutputStreamClass">
      <doc xml:whitespace="preserve">Implements #GOutputStream for arbitrary memory chunks.</doc>
      <implements name="Seekable"/>
      <constructor name="new"
                   c:identifier="g_memory_output_stream_new"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GMemoryOutputStream.
If @data is non-%NULL, the stream  will use that for its internal storage.
If @realloc_fn is non-%NULL, it will be used for resizing the internal
storage when necessary. To construct a fixed-size output stream,
pass %NULL as @realloc_fn.
|[
/&amp;ast; a stream that can grow &amp;ast;/
stream = g_memory_output_stream_new (NULL, 0, realloc, free);
/&amp;ast; another stream that can grow &amp;ast;/
stream2 = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);
/&amp;ast; a fixed-size stream &amp;ast;/
data = malloc (200);
stream3 = g_memory_output_stream_new (data, 200, NULL, free);
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A newly created #GMemoryOutputStream object.</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to a chunk of memory to use, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of @data</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="realloc_function"
                     transfer-ownership="none"
                     scope="notified"
                     destroy="3">
            <doc xml:whitespace="preserve">a function with realloc() semantics (like g_realloc()) to be called when @data needs to be grown, or %NULL</doc>
            <type name="ReallocFunc" c:type="GReallocFunc"/>
          </parameter>
          <parameter name="destroy_function"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">a function to be called on @data when the stream is finalized, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_data"
              c:identifier="g_memory_output_stream_get_data"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets any loaded data from the @ostream.
Note that the returned pointer may become invalid on the next
write or truncate operation on the stream.</doc>
        <return-value>
          <doc xml:whitespace="preserve">pointer to the stream's data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="get_data_size"
              c:identifier="g_memory_output_stream_get_data_size"
              version="2.18">
        <doc xml:whitespace="preserve">Returns the number of bytes from the start up
to including the last byte written in the stream
that has not been truncated away.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes written to the stream</doc>
          <type name="gulong" c:type="gsize"/>
        </return-value>
      </method>
      <method name="get_size" c:identifier="g_memory_output_stream_get_size">
        <doc xml:whitespace="preserve">Gets the size of the currently allocated data area (availible from
g_memory_output_stream_get_data()). If the stream isn't
growable (no realloc was passed to g_memory_output_stream_new()) then
this is the maximum size of the stream and further writes
will return %G_IO_ERROR_NO_SPACE.
Note that for growable streams the returned size may become invalid on
the next write or truncate operation on the stream.
If you want the number of bytes currently written to the stream, use
g_memory_output_stream_get_data_size().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes allocated for the data buffer</doc>
          <type name="gulong" c:type="gsize"/>
        </return-value>
      </method>
      <method name="steal_data"
              c:identifier="g_memory_output_stream_steal_data"
              version="2.26">
        <doc xml:whitespace="preserve">Gets any loaded data from the @ostream. Ownership of the data
is transferred to the caller; when no longer needed it must be
freed using the free function set in @ostream's
#GMemoryOutputStream:destroy-function property.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the stream's data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <property name="data"
                version="2.24"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Pointer to buffer where data will be written.</doc>
        <type name="gpointer"/>
      </property>
      <property name="data-size" version="2.24" transfer-ownership="none">
        <doc xml:whitespace="preserve">Size of data written to the buffer.</doc>
        <type name="gulong"/>
      </property>
      <property name="destroy-function"
                version="2.24"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Function called with the buffer as argument when the stream is destroyed.</doc>
        <type name="gpointer"/>
      </property>
      <property name="realloc-function"
                version="2.24"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Function with realloc semantics called to enlarge the buffer.</doc>
        <type name="gpointer"/>
      </property>
      <property name="size"
                version="2.24"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Current size of the data buffer.</doc>
        <type name="gulong"/>
      </property>
      <field name="parent_instance">
        <type name="OutputStream" c:type="GOutputStream"/>
      </field>
      <field name="priv">
        <type name="MemoryOutputStreamPrivate"
              c:type="GMemoryOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="MemoryOutputStreamClass"
            c:type="GMemoryOutputStreamClass"
            glib:is-gtype-struct-for="MemoryOutputStream">
      <field name="parent_class">
        <type name="OutputStreamClass" c:type="GOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="MemoryOutputStreamPrivate"
            c:type="GMemoryOutputStreamPrivate"
            disguised="1">
    </record>
    <interface name="Mount"
               c:symbol-prefix="mount"
               c:type="GMount"
               glib:type-name="GMount"
               glib:get-type="g_mount_get_type"
               glib:type-struct="MountIface">
      <doc xml:whitespace="preserve">A handle to an object implementing the #GMountIface interface.</doc>
      <virtual-method name="can_eject" invoker="can_eject">
        <doc xml:whitespace="preserve">Checks if @mount can be eject.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @mount can be ejected.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="can_unmount" invoker="can_unmount">
        <doc xml:whitespace="preserve">Checks if @mount can be mounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @mount can be unmounted.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="eject"
                      invoker="eject"
                      deprecated="Use g_mount_eject_with_operation() instead."
                      deprecated-version="2.22">
        <doc xml:whitespace="preserve">Ejects a mount. This is an asynchronous operation, and is
finished by calling g_mount_eject_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_finish"
                      invoker="eject_finish"
                      deprecated="Use g_mount_eject_with_operation_finish() instead."
                      deprecated-version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a mount. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation"
                      invoker="eject_with_operation"
                      version="2.22">
        <doc xml:whitespace="preserve">Ejects a mount. This is an asynchronous operation, and is
finished by calling g_mount_eject_with_operation_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation_finish"
                      invoker="eject_with_operation_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a mount. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_default_location"
                      invoker="get_default_location">
        <doc xml:whitespace="preserve">Gets the default location of @mount. The default location of the given
the home directory, or the root of the volume).
The returned object should be unreffed with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_drive" invoker="get_drive">
        <doc xml:whitespace="preserve">Gets the drive for the @mount.
This is a convenience method for getting the #GVolume and then
using that object to get the #GDrive.
The returned object should be unreffed with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GDrive or %NULL if @mount is not associated with a volume or a drive.</doc>
          <type name="Drive" c:type="GDrive*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_icon" invoker="get_icon">
        <doc xml:whitespace="preserve">Gets the icon for @mount.
The returned object should be unreffed with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIcon.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name">
        <doc xml:whitespace="preserve">Gets the name of @mount.
The returned string should be freed with g_free()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the name for the given @mount.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_root" invoker="get_root">
        <doc xml:whitespace="preserve">Gets the root directory on @mount.
The returned object should be unreffed with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_uuid" invoker="get_uuid">
        <doc xml:whitespace="preserve">Gets the UUID for the @mount. The reference is typically based on
the file system UUID for the mount in question and should be
considered an opaque string. Returns %NULL if there is no UUID
available.
The returned string should be freed with g_free()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the UUID for @mount or %NULL if no UUID can be computed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_volume" invoker="get_volume">
        <doc xml:whitespace="preserve">Gets the volume for the @mount.
The returned object should be unreffed with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GVolume or %NULL if @mount is not associated with a volume.</doc>
          <type name="Volume" c:type="GVolume*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="guess_content_type"
                      invoker="guess_content_type"
                      version="2.18">
        <doc xml:whitespace="preserve">Tries to guess the type of content stored on @mount. Returns one or
more textual identifiers of well-known content types (typically
prefixed with "x-content/"), e.g. x-content/image-dcf for camera
memory cards. See the &lt;ulink url="http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec"&gt;shared-mime-info&lt;/ulink&gt;
specification for more on x-content types.
This is an asynchronous operation (see
g_mount_guess_content_type_sync() for the synchronous version), and
is finished by calling g_mount_guess_content_type_finish() with the</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="force_rescan" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether to force a rescan of the content. Otherwise a cached result will be used if available</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">user data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="guess_content_type_finish"
                      invoker="guess_content_type_finish"
                      version="2.18"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes guessing content types of @mount. If any errors occured
during the operation, @error will be set to contain the errors and
%FALSE will be returned. In particular, you may get an
%G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
guessing.
Caller should free this array with g_strfreev() when done with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a %NULL-terminated array of content types or %NULL on error.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="guess_content_type_sync"
                      invoker="guess_content_type_sync"
                      version="2.18"
                      throws="1">
        <doc xml:whitespace="preserve">Tries to guess the type of content stored on @mount. Returns one or
more textual identifiers of well-known content types (typically
prefixed with "x-content/"), e.g. x-content/image-dcf for camera
memory cards. See the &lt;ulink url="http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec"&gt;shared-mime-info&lt;/ulink&gt;
specification for more on x-content types.
This is an synchronous operation and as such may block doing IO;
see g_mount_guess_content_type() for the asynchronous version.
Caller should free this array with g_strfreev() when done with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a %NULL-terminated array of content types or %NULL on error.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="force_rescan" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether to force a rescan of the content. Otherwise a cached result will be used if available</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remount" invoker="remount">
        <doc xml:whitespace="preserve">Remounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_remount_finish() with the @mount
and #GAsyncResults data returned in the @callback.
Remounting is useful when some setting affecting the operation
of the volume has been changed, as these may need a remount to
take affect. While this is semantically equivalent with unmounting
and then remounting not all backends might need to actually be
unmounted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remount_finish"
                      invoker="remount_finish"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes remounting a mount. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount was successfully remounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount"
                      invoker="unmount"
                      deprecated="Use g_mount_unmount_with_operation() instead."
                      deprecated-version="2.22">
        <doc xml:whitespace="preserve">Unmounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_unmount_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_finish"
                      invoker="unmount_finish"
                      deprecated="Use g_mount_unmount_with_operation_finish() instead."
                      deprecated-version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes unmounting a mount. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_with_operation"
                      invoker="unmount_with_operation"
                      version="2.22">
        <doc xml:whitespace="preserve">Unmounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_unmount_with_operation_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unmount_with_operation_finish"
                      invoker="unmount_with_operation_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes unmounting a mount. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="can_eject" c:identifier="g_mount_can_eject">
        <doc xml:whitespace="preserve">Checks if @mount can be eject.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @mount can be ejected.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="can_unmount" c:identifier="g_mount_can_unmount">
        <doc xml:whitespace="preserve">Checks if @mount can be mounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @mount can be unmounted.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="eject"
              c:identifier="g_mount_eject"
              deprecated="Use g_mount_eject_with_operation() instead."
              deprecated-version="2.22">
        <doc xml:whitespace="preserve">Ejects a mount. This is an asynchronous operation, and is
finished by calling g_mount_eject_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_finish"
              c:identifier="g_mount_eject_finish"
              deprecated="Use g_mount_eject_with_operation_finish() instead."
              deprecated-version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a mount. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation"
              c:identifier="g_mount_eject_with_operation"
              version="2.22">
        <doc xml:whitespace="preserve">Ejects a mount. This is an asynchronous operation, and is
finished by calling g_mount_eject_with_operation_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation_finish"
              c:identifier="g_mount_eject_with_operation_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a mount. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_default_location"
              c:identifier="g_mount_get_default_location">
        <doc xml:whitespace="preserve">Gets the default location of @mount. The default location of the given
the home directory, or the root of the volume).
The returned object should be unreffed with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </method>
      <method name="get_drive" c:identifier="g_mount_get_drive">
        <doc xml:whitespace="preserve">Gets the drive for the @mount.
This is a convenience method for getting the #GVolume and then
using that object to get the #GDrive.
The returned object should be unreffed with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GDrive or %NULL if @mount is not associated with a volume or a drive.</doc>
          <type name="Drive" c:type="GDrive*"/>
        </return-value>
      </method>
      <method name="get_icon" c:identifier="g_mount_get_icon">
        <doc xml:whitespace="preserve">Gets the icon for @mount.
The returned object should be unreffed with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIcon.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </method>
      <method name="get_name" c:identifier="g_mount_get_name">
        <doc xml:whitespace="preserve">Gets the name of @mount.
The returned string should be freed with g_free()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the name for the given @mount.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_root" c:identifier="g_mount_get_root">
        <doc xml:whitespace="preserve">Gets the root directory on @mount.
The returned object should be unreffed with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </method>
      <method name="get_uuid" c:identifier="g_mount_get_uuid">
        <doc xml:whitespace="preserve">Gets the UUID for the @mount. The reference is typically based on
the file system UUID for the mount in question and should be
considered an opaque string. Returns %NULL if there is no UUID
available.
The returned string should be freed with g_free()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the UUID for @mount or %NULL if no UUID can be computed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_volume" c:identifier="g_mount_get_volume">
        <doc xml:whitespace="preserve">Gets the volume for the @mount.
The returned object should be unreffed with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GVolume or %NULL if @mount is not associated with a volume.</doc>
          <type name="Volume" c:type="GVolume*"/>
        </return-value>
      </method>
      <method name="guess_content_type"
              c:identifier="g_mount_guess_content_type"
              version="2.18">
        <doc xml:whitespace="preserve">Tries to guess the type of content stored on @mount. Returns one or
more textual identifiers of well-known content types (typically
prefixed with "x-content/"), e.g. x-content/image-dcf for camera
memory cards. See the &lt;ulink url="http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec"&gt;shared-mime-info&lt;/ulink&gt;
specification for more on x-content types.
This is an asynchronous operation (see
g_mount_guess_content_type_sync() for the synchronous version), and
is finished by calling g_mount_guess_content_type_finish() with the</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="force_rescan" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether to force a rescan of the content. Otherwise a cached result will be used if available</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="guess_content_type_finish"
              c:identifier="g_mount_guess_content_type_finish"
              version="2.18"
              throws="1">
        <doc xml:whitespace="preserve">Finishes guessing content types of @mount. If any errors occured
during the operation, @error will be set to contain the errors and
%FALSE will be returned. In particular, you may get an
%G_IO_ERROR_NOT_SUPPORTED if the mount does not support content
guessing.
Caller should free this array with g_strfreev() when done with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a %NULL-terminated array of content types or %NULL on error.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="guess_content_type_sync"
              c:identifier="g_mount_guess_content_type_sync"
              version="2.18"
              throws="1">
        <doc xml:whitespace="preserve">Tries to guess the type of content stored on @mount. Returns one or
more textual identifiers of well-known content types (typically
prefixed with "x-content/"), e.g. x-content/image-dcf for camera
memory cards. See the &lt;ulink url="http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec"&gt;shared-mime-info&lt;/ulink&gt;
specification for more on x-content types.
This is an synchronous operation and as such may block doing IO;
see g_mount_guess_content_type() for the asynchronous version.
Caller should free this array with g_strfreev() when done with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a %NULL-terminated array of content types or %NULL on error.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="force_rescan" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether to force a rescan of the content. Otherwise a cached result will be used if available</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_shadowed"
              c:identifier="g_mount_is_shadowed"
              version="2.20">
        <doc xml:whitespace="preserve">Determines if @mount is shadowed. Applications or libraries should
avoid displaying @mount in the user interface if it is shadowed.
A mount is said to be shadowed if there exists one or more user
visible objects (currently #GMount objects) with a root that is
inside the root of @mount.
One application of shadow mounts is when exposing a single file
system that is used to address several logical volumes. In this
situation, a #GVolumeMonitor implementation would create two
#GVolume objects (for example, one for the camera functionality of
the device and one for a SD card reader on the device) with
activation URIs &lt;literal&gt;gphoto2://[usb:001,002]/store1/&lt;/literal&gt;
and &lt;literal&gt;gphoto2://[usb:001,002]/store2/&lt;/literal&gt;. When the
underlying mount (with root
&lt;literal&gt;gphoto2://[usb:001,002]/&lt;/literal&gt;) is mounted, said
#GVolumeMonitor implementation would create two #GMount objects
(each with their root matching the corresponding volume activation
root) that would shadow the original mount.
The proxy monitor in GVfs 2.26 and later, automatically creates and
manage shadow mounts (and shadows the underlying mount) if the
activation root on a #GVolume is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @mount is shadowed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="remount" c:identifier="g_mount_remount">
        <doc xml:whitespace="preserve">Remounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_remount_finish() with the @mount
and #GAsyncResults data returned in the @callback.
Remounting is useful when some setting affecting the operation
of the volume has been changed, as these may need a remount to
take affect. While this is semantically equivalent with unmounting
and then remounting not all backends might need to actually be
unmounted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remount_finish"
              c:identifier="g_mount_remount_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes remounting a mount. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount was successfully remounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="shadow" c:identifier="g_mount_shadow" version="2.20">
        <doc xml:whitespace="preserve">Increments the shadow count on @mount. Usually used by
#GVolumeMonitor implementations when creating a shadow mount for
will need to emit the #GMount::changed signal on @mount manually.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="unmount"
              c:identifier="g_mount_unmount"
              deprecated="Use g_mount_unmount_with_operation() instead."
              deprecated-version="2.22">
        <doc xml:whitespace="preserve">Unmounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_unmount_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_finish"
              c:identifier="g_mount_unmount_finish"
              deprecated="Use g_mount_unmount_with_operation_finish() instead."
              deprecated-version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes unmounting a mount. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_with_operation"
              c:identifier="g_mount_unmount_with_operation"
              version="2.22">
        <doc xml:whitespace="preserve">Unmounts a mount. This is an asynchronous operation, and is
finished by calling g_mount_unmount_with_operation_finish() with the @mount
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmount_with_operation_finish"
              c:identifier="g_mount_unmount_with_operation_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes unmounting a mount. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unshadow" c:identifier="g_mount_unshadow" version="2.20">
        <doc xml:whitespace="preserve">Decrements the shadow count on @mount. Usually used by
#GVolumeMonitor implementations when destroying a shadow mount for
will need to emit the #GMount::changed signal on @mount manually.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <glib:signal name="changed">
        <doc xml:whitespace="preserve">Emitted when the mount has been changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="pre-unmount" version="2.22">
        <doc xml:whitespace="preserve">This signal is emitted when the #GMount is about to be
unmounted.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="unmounted">
        <doc xml:whitespace="preserve">This signal is emitted when the #GMount have been
unmounted. If the recipient is holding references to the
object they should release them so the object can be
finalized.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </interface>
    <record name="MountIface"
            c:type="GMountIface"
            glib:is-gtype-struct-for="Mount">
      <doc xml:whitespace="preserve">Interface for implementing operations for mounts.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmounted">
        <callback name="unmounted">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_root">
        <callback name="get_root">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_name">
        <callback name="get_name">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the name for the given @mount.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_icon">
        <callback name="get_icon">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uuid">
        <callback name="get_uuid">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the UUID for @mount or %NULL if no UUID can be computed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_volume">
        <callback name="get_volume">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GVolume or %NULL if @mount is not associated with a volume.</doc>
            <type name="Volume" c:type="GVolume*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_drive">
        <callback name="get_drive">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GDrive or %NULL if @mount is not associated with a volume or a drive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_unmount">
        <callback name="can_unmount">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @mount can be unmounted.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_eject">
        <callback name="can_eject">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @mount can be ejected.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount">
        <callback name="unmount">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_finish">
        <callback name="unmount_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject">
        <callback name="eject">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_finish">
        <callback name="eject_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remount">
        <callback name="remount">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="MountMountFlags" c:type="GMountMountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remount_finish">
        <callback name="remount_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the mount was successfully remounted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="guess_content_type">
        <callback name="guess_content_type">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="force_rescan" transfer-ownership="none">
              <doc xml:whitespace="preserve">Whether to force a rescan of the content. Otherwise a cached result will be used if available</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">user data passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="guess_content_type_finish">
        <callback name="guess_content_type_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a %NULL-terminated array of content types or %NULL on error.</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="guess_content_type_sync">
        <callback name="guess_content_type_sync" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a %NULL-terminated array of content types or %NULL on error.</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="force_rescan" transfer-ownership="none">
              <doc xml:whitespace="preserve">Whether to force a rescan of the content. Otherwise a cached result will be used if available</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pre_unmount">
        <callback name="pre_unmount">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_with_operation">
        <callback name="unmount_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unmount_with_operation_finish">
        <callback name="unmount_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the mount was successfully unmounted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation">
        <callback name="eject_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation_finish">
        <callback name="eject_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the mount was successfully ejected. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_default_location">
        <callback name="get_default_location">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="MountMountFlags"
                 glib:type-name="GMountMountFlags"
                 glib:get-type="g_mount_mount_flags_get_type"
                 c:type="GMountMountFlags">
      <doc xml:whitespace="preserve">Flags used when mounting a mount.</doc>
      <member name="none"
              value="0"
              c:identifier="G_MOUNT_MOUNT_NONE"
              glib:nick="none"/>
    </enumeration>
    <class name="MountOperation"
           c:symbol-prefix="mount_operation"
           c:type="GMountOperation"
           parent="GObject.Object"
           glib:type-name="GMountOperation"
           glib:get-type="g_mount_operation_get_type"
           glib:type-struct="MountOperationClass">
      <doc xml:whitespace="preserve">Class for providing authentication methods for mounting operations,
such as mounting a file locally, or authenticating with a server.</doc>
      <constructor name="new" c:identifier="g_mount_operation_new">
        <doc xml:whitespace="preserve">Creates a new mount operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GMountOperation.</doc>
          <type name="MountOperation" c:type="GMountOperation*"/>
        </return-value>
      </constructor>
      <method name="get_anonymous"
              c:identifier="g_mount_operation_get_anonymous">
        <doc xml:whitespace="preserve">Check to see whether the mount operation is being used
for an anonymous user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if mount operation is anonymous.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_choice" c:identifier="g_mount_operation_get_choice">
        <doc xml:whitespace="preserve">Gets a choice from the mount operation.
the choice's list, or %0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an integer containing an index of the user's choice from</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_domain" c:identifier="g_mount_operation_get_domain">
        <doc xml:whitespace="preserve">Gets the domain of the mount operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string set to the domain.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_password"
              c:identifier="g_mount_operation_get_password">
        <doc xml:whitespace="preserve">Gets a password from the mount operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the password within @op.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_password_save"
              c:identifier="g_mount_operation_get_password_save">
        <doc xml:whitespace="preserve">Gets the state of saving passwords for the mount operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GPasswordSave flag.</doc>
          <type name="PasswordSave" c:type="GPasswordSave"/>
        </return-value>
      </method>
      <method name="get_username"
              c:identifier="g_mount_operation_get_username">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="reply" c:identifier="g_mount_operation_reply">
        <doc xml:whitespace="preserve">Emits the #GMountOperation::reply signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperationResult</doc>
            <type name="MountOperationResult" c:type="GMountOperationResult"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_anonymous"
              c:identifier="g_mount_operation_set_anonymous">
        <doc xml:whitespace="preserve">Sets the mount operation to use an anonymous user if @anonymous is %TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="anonymous" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_choice" c:identifier="g_mount_operation_set_choice">
        <doc xml:whitespace="preserve">Sets a default choice for the mount operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="choice" transfer-ownership="none">
            <doc xml:whitespace="preserve">an integer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_domain" c:identifier="g_mount_operation_set_domain">
        <doc xml:whitespace="preserve">Sets the mount operation's domain.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">the domain to set.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_password"
              c:identifier="g_mount_operation_set_password">
        <doc xml:whitespace="preserve">Sets the mount operation's password to @password.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="password" transfer-ownership="none">
            <doc xml:whitespace="preserve">password to set.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_password_save"
              c:identifier="g_mount_operation_set_password_save">
        <doc xml:whitespace="preserve">Sets the state of saving passwords for the mount operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="save" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GPasswordSave flags.</doc>
            <type name="PasswordSave" c:type="GPasswordSave"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_username"
              c:identifier="g_mount_operation_set_username">
        <doc xml:whitespace="preserve">Sets the user name within @op to @username.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="username" transfer-ownership="none">
            <doc xml:whitespace="preserve">input username.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="anonymous" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether to use an anonymous user when authenticating.</doc>
        <type name="gboolean"/>
      </property>
      <property name="choice" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The index of the user's choice when a question is asked during the
mount operation. See the #GMountOperation::ask-question signal.</doc>
        <type name="gint"/>
      </property>
      <property name="domain" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The domain to use for the mount operation.</doc>
        <type name="utf8"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The password that is used for authentication when carrying out
the mount operation.</doc>
        <type name="utf8"/>
      </property>
      <property name="password-save" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Determines if and how the password information should be saved.</doc>
        <type name="PasswordSave"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The user name that is used for authentication when carrying out
the mount operation.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="MountOperationPrivate" c:type="GMountOperationPrivate*"/>
      </field>
      <glib:signal name="aborted" version="2.20">
        <doc xml:whitespace="preserve">Emitted by the backend when e.g. a device becomes unavailable
while a mount operation is in progress.
Implementations of GMountOperation should handle this signal
by dismissing open password dialogs.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="ask-password">
        <doc xml:whitespace="preserve">Emitted when a mount operation asks the user for a password.
If the message contains a line break, the first line should be
presented as a heading. For example, it may be used as the
primary text in a #GtkMessageDialog.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">string containing a message to display to the user.</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">string containing the default user name.</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:whitespace="preserve">string containing the default domain.</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GAskPasswordFlags.</doc>
            <type name="AskPasswordFlags"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="ask-question" introspectable="0">
        <doc xml:whitespace="preserve">Emitted when asking the user a question and gives a list of
choices for the user to choose from.
If the message contains a line break, the first line should be
presented as a heading. For example, it may be used as the
primary text in a #GtkMessageDialog.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">string containing a message to display to the user.</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of strings for each possible choice.</doc>
            <type/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="reply">
        <doc xml:whitespace="preserve">Emitted when the user has replied to the mount operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperationResult indicating how the request was handled</doc>
            <type name="MountOperationResult"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="show-processes" version="2.22" introspectable="0">
        <doc xml:whitespace="preserve">Emitted when one or more processes are blocking an operation
e.g. unmounting/ejecting a #GMount or stopping a #GDrive.
Note that this signal may be emitted several times to update the
list of blocking processes as processes close files. The
application should only respond with g_mount_operation_reply() to
the latest signal (setting #GMountOperation:choice to the choice
the user made).
If the message contains a line break, the first line should be
presented as a heading. For example, it may be used as the
primary text in a #GtkMessageDialog.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">string containing a message to display to the user.</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of #GPid for processes blocking the operation.</doc>
            <array name="GLib.Array">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of strings for each possible choice.</doc>
            <type/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="MountOperationClass"
            c:type="GMountOperationClass"
            glib:is-gtype-struct-for="MountOperation">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="ask_password">
        <callback name="ask_password">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="default_user" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="default_domain" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="AskPasswordFlags" c:type="GAskPasswordFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="ask_question">
        <callback name="ask_question">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="choices" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reply">
        <callback name="reply">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="MountOperationResult"
                    c:type="GMountOperationResult"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="aborted">
        <callback name="aborted">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="show_processes">
        <callback name="show_processes">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="op" transfer-ownership="none">
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="processes" transfer-ownership="none">
              <array name="GLib.Array" c:type="GArray*">
                <type name="gpointer" c:type="gpointer"/>
              </array>
            </parameter>
            <parameter name="choices" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved8" introspectable="0">
        <callback name="_g_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved9" introspectable="0">
        <callback name="_g_reserved9">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved10" introspectable="0">
        <callback name="_g_reserved10">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="MountOperationPrivate"
            c:type="GMountOperationPrivate"
            disguised="1">
    </record>
    <enumeration name="MountOperationResult"
                 glib:type-name="GMountOperationResult"
                 glib:get-type="g_mount_operation_result_get_type"
                 c:type="GMountOperationResult">
      <doc xml:whitespace="preserve">#GMountOperationResult is returned as a result when a request for
information is send by the mounting operation.</doc>
      <member name="handled"
              value="0"
              c:identifier="G_MOUNT_OPERATION_HANDLED"
              glib:nick="handled"/>
      <member name="aborted"
              value="1"
              c:identifier="G_MOUNT_OPERATION_ABORTED"
              glib:nick="aborted"/>
      <member name="unhandled"
              value="2"
              c:identifier="G_MOUNT_OPERATION_UNHANDLED"
              glib:nick="unhandled"/>
    </enumeration>
    <bitfield name="MountUnmountFlags"
              glib:type-name="GMountUnmountFlags"
              glib:get-type="g_mount_unmount_flags_get_type"
              c:type="GMountUnmountFlags">
      <doc xml:whitespace="preserve">Flags used when an unmounting a mount.</doc>
      <member name="none"
              value="0"
              c:identifier="G_MOUNT_UNMOUNT_NONE"
              glib:nick="none"/>
      <member name="force"
              value="1"
              c:identifier="G_MOUNT_UNMOUNT_FORCE"
              glib:nick="force"/>
    </bitfield>
    <constant name="NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME"
              value="gio-native-volume-monitor">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="NativeVolumeMonitor"
           c:symbol-prefix="native_volume_monitor"
           c:type="GNativeVolumeMonitor"
           parent="VolumeMonitor"
           abstract="1"
           glib:type-name="GNativeVolumeMonitor"
           glib:get-type="g_native_volume_monitor_get_type"
           glib:type-struct="NativeVolumeMonitorClass">
      <field name="parent_instance">
        <type name="VolumeMonitor" c:type="GVolumeMonitor"/>
      </field>
    </class>
    <record name="NativeVolumeMonitorClass"
            c:type="GNativeVolumeMonitorClass"
            glib:is-gtype-struct-for="NativeVolumeMonitor">
      <field name="parent_class">
        <type name="VolumeMonitorClass" c:type="GVolumeMonitorClass"/>
      </field>
      <field name="get_mount_for_mount_path" introspectable="0">
        <callback name="get_mount_for_mount_path" introspectable="0">
          <return-value>
            <type name="Mount" c:type="GMount*"/>
          </return-value>
          <parameters>
            <parameter name="mount_path" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="NetworkAddress"
           c:symbol-prefix="network_address"
           c:type="GNetworkAddress"
           parent="GObject.Object"
           glib:type-name="GNetworkAddress"
           glib:get-type="g_network_address_get_type"
           glib:type-struct="NetworkAddressClass">
      <doc xml:whitespace="preserve">A #GSocketConnectable for resolving a hostname and connecting to
that host.</doc>
      <implements name="SocketConnectable"/>
      <function name="new" c:identifier="g_network_address_new" version="2.22">
        <doc xml:whitespace="preserve">Creates a new #GSocketConnectable for connecting to the given</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GNetworkAddress</doc>
          <type name="SocketConnectable" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the hostname</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:whitespace="preserve">the port</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse"
                c:identifier="g_network_address_parse"
                version="2.22"
                throws="1">
        <doc xml:whitespace="preserve">Creates a new #GSocketConnectable for connecting to the given
parsing @host_and_port fails.
address, an IPv4 address, or a domain name (in which case a DNS
lookup is performed). Quoting with [] is supported for all address
types. A port override may be specified in the usual way with a
colon. Ports may be given as decimal numbers or symbolic names (in
which case an /etc/services lookup is performed).
If no port is specified in @host_and_port then @default_port will be
used as the port number to connect to.
In general, @host_and_port is expected to be provided by the user
(allowing them to give the hostname, and a port overide if necessary)
and @default_port is expected to be provided by the application.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GNetworkAddress, or %NULL on error</doc>
          <type name="SocketConnectable" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <parameter name="host_and_port" transfer-ownership="none">
            <doc xml:whitespace="preserve">the hostname and optionally a port</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:whitespace="preserve">the default port if not in @host_and_port</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_uri"
                c:identifier="g_network_address_parse_uri"
                version="2.26"
                throws="1">
        <doc xml:whitespace="preserve">Creates a new #GSocketConnectable for connecting to the given
Using this rather than g_network_address_new() or
g_network_address_parse_host() allows #GSocketClient to determine
when to use application-specific proxy protocols.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GNetworkAddress, or %NULL on error</doc>
          <type name="SocketConnectable" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the hostname and optionally a port</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:whitespace="preserve">The default port if none is found in the URI</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_hostname"
              c:identifier="g_network_address_get_hostname"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @addr's hostname. This might be either UTF-8 or ASCII-encoded,
depending on what @addr was created with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@addr's hostname</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_port"
              c:identifier="g_network_address_get_port"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @addr's port number</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@addr's port (which may be 0)</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
      </method>
      <method name="get_scheme"
              c:identifier="g_network_address_get_scheme"
              version="2.26">
        <doc xml:whitespace="preserve">Gets @addr's scheme</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@addr's scheme (%NULL if not built from URI)</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <property name="hostname"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="port"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint"/>
      </property>
      <property name="scheme"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="NetworkAddressPrivate" c:type="GNetworkAddressPrivate*"/>
      </field>
    </class>
    <record name="NetworkAddressClass"
            c:type="GNetworkAddressClass"
            glib:is-gtype-struct-for="NetworkAddress">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="NetworkAddressPrivate"
            c:type="GNetworkAddressPrivate"
            disguised="1">
    </record>
    <class name="NetworkService"
           c:symbol-prefix="network_service"
           c:type="GNetworkService"
           parent="GObject.Object"
           glib:type-name="GNetworkService"
           glib:get-type="g_network_service_get_type"
           glib:type-struct="NetworkServiceClass">
      <doc xml:whitespace="preserve">A #GSocketConnectable for resolving a SRV record and connecting to
that service.</doc>
      <implements name="SocketConnectable"/>
      <function name="new" c:identifier="g_network_service_new" version="2.22">
        <doc xml:whitespace="preserve">Creates a new #GNetworkService representing the given @service,
#GSocketConnectable interface to resolve it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GNetworkService</doc>
          <type name="SocketConnectable" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <parameter name="service" transfer-ownership="none">
            <doc xml:whitespace="preserve">the service type to look up (eg, "ldap")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the networking protocol to use for @service (eg, "tcp")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DNS domain to look up the service in</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_domain"
              c:identifier="g_network_service_get_domain"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the domain that @srv serves. This might be either UTF-8 or
ASCII-encoded, depending on what @srv was created with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@srv's domain name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_protocol"
              c:identifier="g_network_service_get_protocol"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @srv's protocol name (eg, "tcp").</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@srv's protocol name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_scheme"
              c:identifier="g_network_service_get_scheme"
              version="2.26">
        <doc xml:whitespace="preserve">Get's the URI scheme used to resolve proxies. By default, the service name
is used as scheme.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@srv's scheme name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_service"
              c:identifier="g_network_service_get_service"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @srv's service name (eg, "ldap").</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@srv's service name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="set_scheme"
              c:identifier="g_network_service_set_scheme"
              version="2.26">
        <doc xml:whitespace="preserve">Set's the URI scheme used to resolve proxies. By default, the service name
is used as scheme.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">a URI scheme</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="domain"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="protocol"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="scheme" writable="1" transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="service"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="NetworkServicePrivate" c:type="GNetworkServicePrivate*"/>
      </field>
    </class>
    <record name="NetworkServiceClass"
            c:type="GNetworkServiceClass"
            glib:is-gtype-struct-for="NetworkService">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="NetworkServicePrivate"
            c:type="GNetworkServicePrivate"
            disguised="1">
    </record>
    <class name="OutputStream"
           c:symbol-prefix="output_stream"
           c:type="GOutputStream"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GOutputStream"
           glib:get-type="g_output_stream_get_type"
           glib:type-struct="OutputStreamClass">
      <doc xml:whitespace="preserve">Base class for writing output.
All classes derived from GOutputStream should implement synchronous
writing, splicing, flushing and closing streams, but may implement
asynchronous versions.</doc>
      <virtual-method name="close_async" invoker="close_async">
        <doc xml:whitespace="preserve">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_output_stream_close_finish() to get
the result of the operation.
For behaviour details see g_output_stream_close().
The asyncronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_finish" invoker="close_finish" throws="1">
        <doc xml:whitespace="preserve">Closes an output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush" invoker="flush" throws="1">
        <doc xml:whitespace="preserve">Flushed any outstanding buffers in the stream. Will block during
the operation. Closing the stream will implicitly cause a flush.
This function is optional for inherited classes.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush_async" invoker="flush_async">
        <doc xml:whitespace="preserve">Flushes a stream asynchronously.
For behaviour details see g_output_stream_flush().
When the operation is finished @callback will be
called. You can then call g_output_stream_flush_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush_finish" invoker="flush_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes flushing an output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if flush operation suceeded, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="splice" invoker="splice" throws="1">
        <doc xml:whitespace="preserve">Splices an input stream into an output stream.
-1 if an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gssize containing the size of the data spliced, or</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags"
                  c:type="GOutputStreamSpliceFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="splice_async" invoker="splice_async">
        <doc xml:whitespace="preserve">Splices a stream asynchronously.
When the operation is finished @callback will be called.
You can then call g_output_stream_splice_finish() to get the
result of the operation.
For the synchronous, blocking version of this function, see
g_output_stream_splice().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags"
                  c:type="GOutputStreamSpliceFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="splice_finish" invoker="splice_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous stream splice operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gssize of the number of bytes spliced.</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_async" invoker="write_async">
        <doc xml:whitespace="preserve">Request an asynchronous write of @count bytes from @buffer into
the stream. When the operation is finished @callback will be called.
You can then call g_output_stream_write_finish() to get the result of the
operation.
During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.
A value of @count larger than %G_MAXSSIZE will cause a
%G_IO_ERROR_INVALID_ARGUMENT error.
On success, the number of bytes written will be passed to the
requested size, as it can happen e.g. on a partial I/O error,
but generally we try to write as many bytes as requested.
You are guaranteed that this method will never fail with
%G_IO_ERROR_WOULD_BLOCK - if @stream can't accept more data, the
method will just wait until this changes.
Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.
The asyncronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.
For the synchronous, blocking version of this function, see
g_output_stream_write().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the buffer containing the data to write.</doc>
            <array length="1" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to write</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="5">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_finish" invoker="write_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes a stream write operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gssize containing the number of bytes written to the stream.</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_fn" throws="1">
        <return-value transfer-ownership="none">
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clear_pending"
              c:identifier="g_output_stream_clear_pending">
        <doc xml:whitespace="preserve">Clears the pending flag on @stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="close" c:identifier="g_output_stream_close" throws="1">
        <doc xml:whitespace="preserve">Closes the stream, releasing resources related to it.
Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
Closing a stream multiple times will not return an error.
Closing a stream will automatically flush any outstanding buffers in the
stream.
Streams will be automatically closed when the last reference
is dropped, but you might want to call this function to make sure
resources are released as early as possible.
Some streams might keep the backing store of the stream (e.g. a file descriptor)
open after the stream is closed. See the documentation for the individual
stream for details.
On failure the first error that happened will be reported, but the close
operation will finish as much as possible. A stream that failed to
close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
is important to check and report the error to the user, otherwise
there might be a loss of data as all data might not be written.
If @cancellable is not NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Cancelling a close will still leave the stream closed, but there some streams
can use a faster close that doesn't block to e.g. check errors. On
cancellation (as with any error) there is no guarantee that all written
data will reach the target.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async" c:identifier="g_output_stream_close_async">
        <doc xml:whitespace="preserve">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_output_stream_close_finish() to get
the result of the operation.
For behaviour details see g_output_stream_close().
The asyncronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish"
              c:identifier="g_output_stream_close_finish"
              throws="1">
        <doc xml:whitespace="preserve">Closes an output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="g_output_stream_flush" throws="1">
        <doc xml:whitespace="preserve">Flushed any outstanding buffers in the stream. Will block during
the operation. Closing the stream will implicitly cause a flush.
This function is optional for inherited classes.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush_async" c:identifier="g_output_stream_flush_async">
        <doc xml:whitespace="preserve">Flushes a stream asynchronously.
For behaviour details see g_output_stream_flush().
When the operation is finished @callback will be
called. You can then call g_output_stream_flush_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush_finish"
              c:identifier="g_output_stream_flush_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes flushing an output stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if flush operation suceeded, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_pending" c:identifier="g_output_stream_has_pending">
        <doc xml:whitespace="preserve">Checks if an ouput stream has pending actions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @stream has pending actions.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_closed" c:identifier="g_output_stream_is_closed">
        <doc xml:whitespace="preserve">Checks if an output stream has already been closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @stream is closed. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_closing"
              c:identifier="g_output_stream_is_closing"
              version="2.24">
        <doc xml:whitespace="preserve">Checks if an output stream is being closed. This can be
used inside e.g. a flush implementation to see if the
flush (or other i/o operation) is called from within
the closing operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @stream is being closed. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_pending"
              c:identifier="g_output_stream_set_pending"
              throws="1">
        <doc xml:whitespace="preserve">Sets @stream to have actions pending. If the pending flag is
already set or @stream is closed, it will return %FALSE and set</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if pending was previously unset and is now set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="splice" c:identifier="g_output_stream_splice" throws="1">
        <doc xml:whitespace="preserve">Splices an input stream into an output stream.
-1 if an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gssize containing the size of the data spliced, or</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags"
                  c:type="GOutputStreamSpliceFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="splice_async" c:identifier="g_output_stream_splice_async">
        <doc xml:whitespace="preserve">Splices a stream asynchronously.
When the operation is finished @callback will be called.
You can then call g_output_stream_splice_finish() to get the
result of the operation.
For the synchronous, blocking version of this function, see
g_output_stream_splice().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags"
                  c:type="GOutputStreamSpliceFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="splice_finish"
              c:identifier="g_output_stream_splice_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous stream splice operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gssize of the number of bytes spliced.</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="g_output_stream_write" throws="1">
        <doc xml:whitespace="preserve">Tries to write @count bytes from @buffer into the stream. Will block
during the operation.
If count is 0, returns 0 and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
On success, the number of bytes written to the stream is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. on a partial I/O error, or if there is not enough
storage in the stream. All writes block until at least one byte
is written or an error occurs; 0 is never returned (unless
If @cancellable is not NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.
On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes written, or -1 on error</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the buffer containing the data to write.</doc>
            <array length="1" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to write</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_all"
              c:identifier="g_output_stream_write_all"
              throws="1">
        <doc xml:whitespace="preserve">Tries to write @count bytes from @buffer into the stream. Will block
during the operation.
This function is similar to g_output_stream_write(), except it tries to
write as many bytes as requested, only stopping on an error.
On a successful write of @count bytes, %TRUE is returned, and @bytes_written
is set to @count.
If there is an error during the operation FALSE is returned and @error
is set to indicate the error status, @bytes_written is updated to contain
the number of bytes written into the stream before the error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the buffer containing the data to write.</doc>
            <array length="1" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to write</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="bytes_written" transfer-ownership="none">
            <doc xml:whitespace="preserve">location to store the number of bytes that was written to the stream</doc>
            <type name="gulong" c:type="gsize*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_async" c:identifier="g_output_stream_write_async">
        <doc xml:whitespace="preserve">Request an asynchronous write of @count bytes from @buffer into
the stream. When the operation is finished @callback will be called.
You can then call g_output_stream_write_finish() to get the result of the
operation.
During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.
A value of @count larger than %G_MAXSSIZE will cause a
%G_IO_ERROR_INVALID_ARGUMENT error.
On success, the number of bytes written will be passed to the
requested size, as it can happen e.g. on a partial I/O error,
but generally we try to write as many bytes as requested.
You are guaranteed that this method will never fail with
%G_IO_ERROR_WOULD_BLOCK - if @stream can't accept more data, the
method will just wait until this changes.
Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.
The asyncronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.
For the synchronous, blocking version of this function, see
g_output_stream_write().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the buffer containing the data to write.</doc>
            <array length="1" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to write</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_finish"
              c:identifier="g_output_stream_write_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes a stream write operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gssize containing the number of bytes written to the stream.</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="OutputStreamPrivate" c:type="GOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="OutputStreamClass"
            c:type="GOutputStreamClass"
            glib:is-gtype-struct-for="OutputStream">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="write_fn">
        <callback name="write_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="glong" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="gpointer" c:type="void*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="gulong" c:type="gsize"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="splice">
        <callback name="splice" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gssize containing the size of the data spliced, or</doc>
            <type name="glong" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="source" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GOutputStreamSpliceFlags.</doc>
              <type name="OutputStreamSpliceFlags"
                    c:type="GOutputStreamSpliceFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush">
        <callback name="flush" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_fn">
        <callback name="close_fn" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write_async">
        <callback name="write_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:whitespace="preserve">the buffer containing the data to write.</doc>
              <array length="2" c:type="void*">
                <type name="guint8"/>
              </array>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <doc xml:whitespace="preserve">the number of bytes to write</doc>
              <type name="gulong" c:type="gsize"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the io priority of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="6">
              <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="6">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write_finish">
        <callback name="write_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gssize containing the number of bytes written to the stream.</doc>
            <type name="glong" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="splice_async">
        <callback name="splice_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="source" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">a set of #GOutputStreamSpliceFlags.</doc>
              <type name="OutputStreamSpliceFlags"
                    c:type="GOutputStreamSpliceFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the io priority of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="6">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="splice_finish">
        <callback name="splice_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gssize of the number of bytes spliced.</doc>
            <type name="glong" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush_async">
        <callback name="flush_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the io priority of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush_finish">
        <callback name="flush_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if flush operation suceeded, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_async">
        <callback name="close_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:whitespace="preserve">the io priority of the request.</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_finish">
        <callback name="close_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <type name="OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved8" introspectable="0">
        <callback name="_g_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="OutputStreamPrivate"
            c:type="GOutputStreamPrivate"
            disguised="1">
    </record>
    <bitfield name="OutputStreamSpliceFlags"
              glib:type-name="GOutputStreamSpliceFlags"
              glib:get-type="g_output_stream_splice_flags_get_type"
              c:type="GOutputStreamSpliceFlags">
      <doc xml:whitespace="preserve">GOutputStreamSpliceFlags determine how streams should be spliced.</doc>
      <member name="none"
              value="0"
              c:identifier="G_OUTPUT_STREAM_SPLICE_NONE"
              glib:nick="none"/>
      <member name="close_source"
              value="1"
              c:identifier="G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE"
              glib:nick="close-source"/>
      <member name="close_target"
              value="2"
              c:identifier="G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET"
              glib:nick="close-target"/>
    </bitfield>
    <record name="OutputVector" c:type="GOutputVector" version="2.22">
      <doc xml:whitespace="preserve">Structure used for scatter/gather data output.
You generally pass in an array of #GOutputVector&lt;!-- --&gt;s
and the operation will use all the buffers as if they were
one buffer.</doc>
      <field name="buffer" writable="1">
        <type name="gpointer" c:type="gconstpointer"/>
      </field>
      <field name="size" writable="1">
        <type name="gulong" c:type="gsize"/>
      </field>
    </record>
    <constant name="PROXY_EXTENSION_POINT_NAME" value="gio-proxy">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROXY_RESOLVER_EXTENSION_POINT_NAME"
              value="gio-proxy-resolver">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="PasswordSave"
                 glib:type-name="GPasswordSave"
                 glib:get-type="g_password_save_get_type"
                 c:type="GPasswordSave">
      <doc xml:whitespace="preserve">#GPasswordSave is used to indicate the lifespan of a saved password.
#Gvfs stores passwords in the Gnome keyring when this flag allows it
to, and later retrieves it again from there.</doc>
      <member name="never"
              value="0"
              c:identifier="G_PASSWORD_SAVE_NEVER"
              glib:nick="never"/>
      <member name="for_session"
              value="1"
              c:identifier="G_PASSWORD_SAVE_FOR_SESSION"
              glib:nick="for-session"/>
      <member name="permanently"
              value="2"
              c:identifier="G_PASSWORD_SAVE_PERMANENTLY"
              glib:nick="permanently"/>
    </enumeration>
    <class name="Permission"
           c:symbol-prefix="permission"
           c:type="GPermission"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GPermission"
           glib:get-type="g_permission_get_type"
           glib:type-struct="PermissionClass">
      <doc xml:whitespace="preserve">#GPermission is an opaque data structure and can only be accessed
using the following functions.</doc>
      <virtual-method name="acquire"
                      invoker="acquire"
                      version="2.26"
                      throws="1">
        <doc xml:whitespace="preserve">Attempts to acquire the permission represented by @permission.
The precise method by which this happens depends on the permission
and the underlying authentication mechanism.  A simple example is
that a dialog may appear asking the user to enter their password.
You should check with g_permission_get_can_acquire() before calling
this function.
If the permission is acquired then %TRUE is returned.  Otherwise,
%FALSE is returned and @error is set appropriately.
This call is blocking, likely for a very long time (in the case that
user interaction is required).  See g_permission_acquire_async() for
the non-blocking version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the permission was successfully acquired</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="acquire_async"
                      invoker="acquire_async"
                      version="2.26">
        <doc xml:whitespace="preserve">Attempts to acquire the permission represented by @permission.
This is the first half of the asynchronous version of
g_permission_acquire().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">the #GAsyncReadyCallback to call when done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">the user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="acquire_finish"
                      invoker="acquire_finish"
                      version="2.26"
                      throws="1">
        <doc xml:whitespace="preserve">Collects the result of attempting to acquire the permission
represented by @permission.
This is the second half of the asynchronous version of
g_permission_acquire().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the permission was successfully acquired</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="release"
                      invoker="release"
                      version="2.26"
                      throws="1">
        <doc xml:whitespace="preserve">Attempts to release the permission represented by @permission.
The precise method by which this happens depends on the permission
and the underlying authentication mechanism.  In most cases the
permission will be dropped immediately without further action.
You should check with g_permission_get_can_release() before calling
this function.
If the permission is released then %TRUE is returned.  Otherwise,
%FALSE is returned and @error is set appropriately.
This call is blocking, likely for a very long time (in the case that
user interaction is required).  See g_permission_release_async() for
the non-blocking version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the permission was successfully released</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="release_async"
                      invoker="release_async"
                      version="2.26">
        <doc xml:whitespace="preserve">Attempts to release the permission represented by @permission.
This is the first half of the asynchronous version of
g_permission_release().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">the #GAsyncReadyCallback to call when done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">the user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="release_finish"
                      invoker="release_finish"
                      version="2.26"
                      throws="1">
        <doc xml:whitespace="preserve">Collects the result of attempting to release the permission
represented by @permission.
This is the second half of the asynchronous version of
g_permission_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the permission was successfully released</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="acquire"
              c:identifier="g_permission_acquire"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Attempts to acquire the permission represented by @permission.
The precise method by which this happens depends on the permission
and the underlying authentication mechanism.  A simple example is
that a dialog may appear asking the user to enter their password.
You should check with g_permission_get_can_acquire() before calling
this function.
If the permission is acquired then %TRUE is returned.  Otherwise,
%FALSE is returned and @error is set appropriately.
This call is blocking, likely for a very long time (in the case that
user interaction is required).  See g_permission_acquire_async() for
the non-blocking version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the permission was successfully acquired</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="acquire_async"
              c:identifier="g_permission_acquire_async"
              version="2.26">
        <doc xml:whitespace="preserve">Attempts to acquire the permission represented by @permission.
This is the first half of the asynchronous version of
g_permission_acquire().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">the #GAsyncReadyCallback to call when done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="acquire_finish"
              c:identifier="g_permission_acquire_finish"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Collects the result of attempting to acquire the permission
represented by @permission.
This is the second half of the asynchronous version of
g_permission_acquire().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the permission was successfully acquired</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_allowed"
              c:identifier="g_permission_get_allowed"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the value of the 'allowed' property.  This property is %TRUE if
the caller currently has permission to perform the action that</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the 'allowed' property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_can_acquire"
              c:identifier="g_permission_get_can_acquire"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the value of the 'can-acquire' property.  This property is %TRUE
if it is generally possible to acquire the permission by calling
g_permission_acquire().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the 'can-acquire' property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_can_release"
              c:identifier="g_permission_get_can_release"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the value of the 'can-release' property.  This property is %TRUE
if it is generally possible to release the permission by calling
g_permission_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the 'can-release' property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="impl_update"
              c:identifier="g_permission_impl_update"
              version="2.26">
        <doc xml:whitespace="preserve">This function is called by the #GPermission implementation to update
the properties of the permission.  You should never call this
function except from a #GPermission implementation.
GObject notify signals are generated, as appropriate.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="allowed" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value for the 'allowed' property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="can_acquire" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value for the 'can-acquire' property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="can_release" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value for the 'can-release' property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="release"
              c:identifier="g_permission_release"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Attempts to release the permission represented by @permission.
The precise method by which this happens depends on the permission
and the underlying authentication mechanism.  In most cases the
permission will be dropped immediately without further action.
You should check with g_permission_get_can_release() before calling
this function.
If the permission is released then %TRUE is returned.  Otherwise,
%FALSE is returned and @error is set appropriately.
This call is blocking, likely for a very long time (in the case that
user interaction is required).  See g_permission_release_async() for
the non-blocking version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the permission was successfully released</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_async"
              c:identifier="g_permission_release_async"
              version="2.26">
        <doc xml:whitespace="preserve">Attempts to release the permission represented by @permission.
This is the first half of the asynchronous version of
g_permission_release().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">the #GAsyncReadyCallback to call when done</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_finish"
              c:identifier="g_permission_release_finish"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Collects the result of attempting to release the permission
represented by @permission.
This is the second half of the asynchronous version of
g_permission_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the permission was successfully released</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="allowed" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the caller currently has permission to perform the action that</doc>
        <type name="gboolean"/>
      </property>
      <property name="can-acquire" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if it is generally possible to acquire the permission by calling
g_permission_acquire().</doc>
        <type name="gboolean"/>
      </property>
      <property name="can-release" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if it is generally possible to release the permission by calling
g_permission_release().</doc>
        <type name="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="PermissionPrivate" c:type="GPermissionPrivate*"/>
      </field>
    </class>
    <record name="PermissionClass"
            c:type="GPermissionClass"
            glib:is-gtype-struct-for="Permission">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="acquire">
        <callback name="acquire" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the permission was successfully acquired</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acquire_async">
        <callback name="acquire_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:whitespace="preserve">the #GAsyncReadyCallback to call when done</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:whitespace="preserve">the user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acquire_finish">
        <callback name="acquire_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the permission was successfully acquired</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release">
        <callback name="release" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the permission was successfully released</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release_async">
        <callback name="release_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:whitespace="preserve">the #GAsyncReadyCallback to call when done</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:whitespace="preserve">the user data to pass to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release_finish">
        <callback name="release_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the permission was successfully released</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="permission" transfer-ownership="none">
              <type name="Permission" c:type="GPermission*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">the #GAsyncResult given to the #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="16">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="PermissionPrivate" c:type="GPermissionPrivate" disguised="1">
    </record>
    <interface name="Proxy"
               c:symbol-prefix="proxy"
               c:type="GProxy"
               version="2.26"
               glib:type-name="GProxy"
               glib:get-type="g_proxy_get_type"
               glib:type-struct="ProxyInterface">
      <doc xml:whitespace="preserve">Interface that handles proxy connection and payload.</doc>
      <virtual-method name="connect"
                      invoker="connect"
                      version="2.26"
                      throws="1">
        <doc xml:whitespace="preserve">Given @connection to communicate with a proxy (eg, a
#GSocketConnection that is connected to the proxy server), this
does the necessary handshake to connect to @proxy_address, and if
required, wraps the #GIOStream to handle proxy payload.
be the same as @connection, in which case a reference
will be added.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIOStream that will replace @connection. This might</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="proxy_address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connect_async"
                      invoker="connect_async"
                      version="2.26">
        <doc xml:whitespace="preserve">Asynchronous version of g_proxy_connect().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="proxy_address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">callback data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connect_finish"
                      invoker="connect_finish"
                      version="2.26"
                      throws="1">
        <doc xml:whitespace="preserve">See g_proxy_connect().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIOStream.</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncRetult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supports_hostname"
                      invoker="supports_hostname"
                      version="2.26">
        <doc xml:whitespace="preserve">Some proxy protocols expect to be passed a hostname, which they
will resolve to an IP address themselves. Others, like SOCKS4, do
not allow this. This function will return %FALSE if @proxy is
implementing such a protocol. When %FALSE is returned, the caller
should resolve the destination hostname first, and then pass a
#GProxyAddress containing the stringified IP address to
g_proxy_connect() or g_proxy_connect_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if hostname resolution is supported.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="connect"
              c:identifier="g_proxy_connect"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Given @connection to communicate with a proxy (eg, a
#GSocketConnection that is connected to the proxy server), this
does the necessary handshake to connect to @proxy_address, and if
required, wraps the #GIOStream to handle proxy payload.
be the same as @connection, in which case a reference
will be added.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIOStream that will replace @connection. This might</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="proxy_address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_async"
              c:identifier="g_proxy_connect_async"
              version="2.26">
        <doc xml:whitespace="preserve">Asynchronous version of g_proxy_connect().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="proxy_address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GProxyAddress</doc>
            <type name="ProxyAddress" c:type="GProxyAddress*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">callback data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_finish"
              c:identifier="g_proxy_connect_finish"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">See g_proxy_connect().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIOStream.</doc>
          <type name="IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncRetult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_hostname"
              c:identifier="g_proxy_supports_hostname"
              version="2.26">
        <doc xml:whitespace="preserve">Some proxy protocols expect to be passed a hostname, which they
will resolve to an IP address themselves. Others, like SOCKS4, do
not allow this. This function will return %FALSE if @proxy is
implementing such a protocol. When %FALSE is returned, the caller
should resolve the destination hostname first, and then pass a
#GProxyAddress containing the stringified IP address to
g_proxy_connect() or g_proxy_connect_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if hostname resolution is supported.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </interface>
    <class name="ProxyAddress"
           c:symbol-prefix="proxy_address"
           c:type="GProxyAddress"
           version="2.26"
           parent="InetSocketAddress"
           glib:type-name="GProxyAddress"
           glib:get-type="g_proxy_address_get_type"
           glib:type-struct="ProxyAddressClass">
      <doc xml:whitespace="preserve">A #GInetSocketAddress representing a connection via a proxy server</doc>
      <implements name="SocketConnectable"/>
      <constructor name="new"
                   c:identifier="g_proxy_address_new"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GProxyAddress for @inetaddr with @protocol that should
tunnel through @dest_hostname and @dest_port.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GProxyAddress</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="inetaddr" transfer-ownership="none">
            <doc xml:whitespace="preserve">The proxy server #GInetAddress.</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:whitespace="preserve">The proxy server port.</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">The proxy protocol to support, in lower case (e.g. socks, http).</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="dest_hostname" transfer-ownership="none">
            <doc xml:whitespace="preserve">The destination hostname the the proxy should tunnel to.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="dest_port" transfer-ownership="none">
            <doc xml:whitespace="preserve">The destination port to tunnel to.</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:whitespace="preserve">The username to authenticate to the proxy server (or %NULL).</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:whitespace="preserve">The password to authenticate to the proxy server (or %NULL).</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_destination_hostname"
              c:identifier="g_proxy_address_get_destination_hostname">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_destination_port"
              c:identifier="g_proxy_address_get_destination_port">
        <return-value transfer-ownership="none">
          <type name="guint16" c:type="guint16"/>
        </return-value>
      </method>
      <method name="get_password" c:identifier="g_proxy_address_get_password">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_protocol"
              c:identifier="g_proxy_address_get_protocol"
              version="2.26">
        <doc xml:whitespace="preserve">Gets @proxy's protocol.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the @proxy's protocol</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_username" c:identifier="g_proxy_address_get_username">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <property name="destination-hostname"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="destination-port"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint"/>
      </property>
      <property name="password"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="protocol"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="username"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <field name="parent_instance">
        <type name="InetSocketAddress" c:type="GInetSocketAddress"/>
      </field>
      <field name="priv">
        <type name="ProxyAddressPrivate" c:type="GProxyAddressPrivate*"/>
      </field>
    </class>
    <record name="ProxyAddressClass"
            c:type="GProxyAddressClass"
            glib:is-gtype-struct-for="ProxyAddress">
      <field name="parent_class">
        <type name="InetSocketAddressClass" c:type="GInetSocketAddressClass"/>
      </field>
    </record>
    <class name="ProxyAddressEnumerator"
           c:symbol-prefix="proxy_address_enumerator"
           c:type="GProxyAddressEnumerator"
           parent="SocketAddressEnumerator"
           glib:type-name="GProxyAddressEnumerator"
           glib:get-type="g_proxy_address_enumerator_get_type"
           glib:type-struct="ProxyAddressEnumeratorClass">
      <doc xml:whitespace="preserve">A subclass of #GSocketAddressEnumerator that takes another address
enumerator and wraps its results in #GProxyAddress&lt;!-- --&gt;es as
directed by the default #GProxyResolver.</doc>
      <property name="connectable"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="SocketConnectable"/>
      </property>
      <property name="uri"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <field name="parent_instance">
        <type name="SocketAddressEnumerator"
              c:type="GSocketAddressEnumerator"/>
      </field>
      <field name="priv">
        <type name="ProxyAddressEnumeratorPrivate"
              c:type="GProxyAddressEnumeratorPrivate*"/>
      </field>
    </class>
    <record name="ProxyAddressEnumeratorClass"
            c:type="GProxyAddressEnumeratorClass"
            glib:is-gtype-struct-for="ProxyAddressEnumerator">
      <field name="parent_class">
        <type name="SocketAddressEnumeratorClass"
              c:type="GSocketAddressEnumeratorClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ProxyAddressEnumeratorPrivate"
            c:type="GProxyAddressEnumeratorPrivate"
            disguised="1">
    </record>
    <record name="ProxyAddressPrivate"
            c:type="GProxyAddressPrivate"
            disguised="1">
    </record>
    <record name="ProxyInterface"
            c:type="GProxyInterface"
            glib:is-gtype-struct-for="Proxy"
            version="2.26">
      <doc xml:whitespace="preserve">Provides an interface for handling proxy connection and payload.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="connect">
        <callback name="connect" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GIOStream that will replace @connection. This might</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="Proxy" c:type="GProxy*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
            <parameter name="proxy_address" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GProxyAddress</doc>
              <type name="ProxyAddress" c:type="GProxyAddress*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connect_async">
        <callback name="connect_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="Proxy" c:type="GProxy*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*"/>
            </parameter>
            <parameter name="proxy_address" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GProxyAddress</doc>
              <type name="ProxyAddress" c:type="GProxyAddress*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">callback data</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connect_finish">
        <callback name="connect_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GIOStream.</doc>
            <type name="IOStream" c:type="GIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="Proxy" c:type="GProxy*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncRetult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supports_hostname">
        <callback name="supports_hostname">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if hostname resolution is supported.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="Proxy" c:type="GProxy*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <interface name="ProxyResolver"
               c:symbol-prefix="proxy_resolver"
               c:type="GProxyResolver"
               glib:type-name="GProxyResolver"
               glib:get-type="g_proxy_resolver_get_type"
               glib:type-struct="ProxyResolverInterface">
      <doc xml:whitespace="preserve">Interface that can be used to resolve proxy address.</doc>
      <virtual-method name="is_supported"
                      invoker="is_supported"
                      version="2.26">
        <doc xml:whitespace="preserve">Checks if @resolver can be used on this system. (This is used
internally; g_proxy_resolver_get_default() will only return a proxy
resolver that returns %TRUE for this method.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @resolver is supported.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="lookup" invoker="lookup" version="2.26" throws="1">
        <doc xml:whitespace="preserve">Looks into the system proxy configuration to determine what proxy,
if any, to use to connect to @uri. The returned proxy URIs are of the
form &lt;literal&gt;&amp;lt;protocol&amp;gt;://[user[:password]@]host:port&lt;/literal&gt;
or &lt;literal&gt;direct://&lt;/literal&gt;, where &amp;lt;protocol&amp;gt; could be
http, rtsp, socks or other proxying protocol.
If you don't know what network protocol is being used on the
socket, you should use &lt;literal&gt;none&lt;/literal&gt; as the URI protocol.
In this case, the resolver might still return a generic proxy type
(such as SOCKS), but would not return protocol-specific proxy types
(such as http).
&lt;literal&gt;direct://&lt;/literal&gt; is used when no proxy is needed.
Direct connection should not be attempted unless it is part of the
returned array of proxies.
g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A NULL-terminated array of proxy URIs. Must be freed with</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">a URI representing the destination to connect to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_async"
                      invoker="lookup_async"
                      version="2.26">
        <doc xml:whitespace="preserve">Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">a URI representing the destination to connect to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_finish"
                      invoker="lookup_finish"
                      version="2.26"
                      throws="1">
        <doc xml:whitespace="preserve">Call this function to obtain the array of proxy URIs when
g_proxy_resolver_lookup_async() is complete. See
g_proxy_resolver_lookup() for more details.
g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A NULL-terminated array of proxy URIs. Must be freed with</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="is_supported"
              c:identifier="g_proxy_resolver_is_supported"
              version="2.26">
        <doc xml:whitespace="preserve">Checks if @resolver can be used on this system. (This is used
internally; g_proxy_resolver_get_default() will only return a proxy
resolver that returns %TRUE for this method.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @resolver is supported.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="lookup"
              c:identifier="g_proxy_resolver_lookup"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Looks into the system proxy configuration to determine what proxy,
if any, to use to connect to @uri. The returned proxy URIs are of the
form &lt;literal&gt;&amp;lt;protocol&amp;gt;://[user[:password]@]host:port&lt;/literal&gt;
or &lt;literal&gt;direct://&lt;/literal&gt;, where &amp;lt;protocol&amp;gt; could be
http, rtsp, socks or other proxying protocol.
If you don't know what network protocol is being used on the
socket, you should use &lt;literal&gt;none&lt;/literal&gt; as the URI protocol.
In this case, the resolver might still return a generic proxy type
(such as SOCKS), but would not return protocol-specific proxy types
(such as http).
&lt;literal&gt;direct://&lt;/literal&gt; is used when no proxy is needed.
Direct connection should not be attempted unless it is part of the
returned array of proxies.
g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A NULL-terminated array of proxy URIs. Must be freed with</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">a URI representing the destination to connect to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_async"
              c:identifier="g_proxy_resolver_lookup_async"
              version="2.26">
        <doc xml:whitespace="preserve">Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more
details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">a URI representing the destination to connect to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_finish"
              c:identifier="g_proxy_resolver_lookup_finish"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Call this function to obtain the array of proxy URIs when
g_proxy_resolver_lookup_async() is complete. See
g_proxy_resolver_lookup() for more details.
g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A NULL-terminated array of proxy URIs. Must be freed with</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="ProxyResolverInterface"
            c:type="GProxyResolverInterface"
            glib:is-gtype-struct-for="ProxyResolver">
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="is_supported">
        <callback name="is_supported">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if @resolver is supported.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="ProxyResolver" c:type="GProxyResolver*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup">
        <callback name="lookup" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">A NULL-terminated array of proxy URIs. Must be freed with</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="ProxyResolver" c:type="GProxyResolver*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <doc xml:whitespace="preserve">a URI representing the destination to connect to</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_async">
        <callback name="lookup_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="ProxyResolver" c:type="GProxyResolver*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <doc xml:whitespace="preserve">a URI representing the destination to connect to</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">callback to call after resolution completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">data for @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_finish">
        <callback name="lookup_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">A NULL-terminated array of proxy URIs. Must be freed with</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="ProxyResolver" c:type="GProxyResolver*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="ReallocFunc" c:type="GReallocFunc" introspectable="0">
      <doc xml:whitespace="preserve">Changes the size of the memory block pointed to by @data to
The function should have the same semantics as realloc().</doc>
      <return-value>
        <doc xml:whitespace="preserve">a pointer to the reallocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">memory block to reallocate</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">size to reallocate @data to</doc>
          <type name="gulong" c:type="gsize"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Resolver"
           c:symbol-prefix="resolver"
           c:type="GResolver"
           parent="GObject.Object"
           glib:type-name="GResolver"
           glib:get-type="g_resolver_get_type"
           glib:type-struct="ResolverClass">
      <doc xml:whitespace="preserve">The object that handles DNS resolution. Use g_resolver_get_default()
to get the default resolver.</doc>
      <function name="free_addresses"
                c:identifier="g_resolver_free_addresses"
                version="2.22">
        <doc xml:whitespace="preserve">Frees @addresses (which should be the return value from
g_resolver_lookup_by_name() or g_resolver_lookup_by_name_finish()).
(This is a convenience method; you can also simply free the results
by hand.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="addresses" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #GInetAddress</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free_targets"
                c:identifier="g_resolver_free_targets"
                version="2.22">
        <doc xml:whitespace="preserve">Frees @targets (which should be the return value from
g_resolver_lookup_service() or g_resolver_lookup_service_finish()).
(This is a convenience method; you can also simply free the
results by hand.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="targets" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #GSrvTarget</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="get_default"
                c:identifier="g_resolver_get_default"
                version="2.22">
        <doc xml:whitespace="preserve">Gets the default #GResolver. You should unref it when you are done
with it. #GResolver may use its reference count as a hint about how
many threads/processes, etc it should allocate for concurrent DNS
resolutions.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the default #GResolver.</doc>
          <type name="Resolver" c:type="GResolver*"/>
        </return-value>
      </function>
      <virtual-method name="lookup_by_address"
                      invoker="lookup_by_address"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Synchronously reverse-resolves @address to determine its
associated hostname.
If the DNS resolution fails, @error (if non-%NULL) will be set to
a value from #GResolverError.
If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.
form), or %NULL on error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a hostname (either ASCII-only, or in ASCII-encoded</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">the address to reverse-resolve</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_by_address_async"
                      invoker="lookup_by_address_async"
                      version="2.22">
        <doc xml:whitespace="preserve">Begins asynchronously reverse-resolving @address to determine its
associated hostname, and eventually calls @callback, which must
call g_resolver_lookup_by_address_finish() to get the final result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">the address to reverse-resolve</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_by_address_finish"
                      invoker="lookup_by_address_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Retrieves the result of a previous call to
g_resolver_lookup_by_address_async().
If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
form), or %NULL on error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a hostname (either ASCII-only, or in ASCII-encoded</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_by_name"
                      invoker="lookup_by_name"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Synchronously resolves @hostname to determine its associated IP
address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
the textual form of an IP address (in which case this just becomes
a wrapper around g_inet_address_new_from_string()).
On success, g_resolver_lookup_by_name() will return a #GList of
#GInetAddress, sorted in order of preference. (That is, you should
attempt to connect to the first address first, then the second if
the first fails, etc.)
If the DNS resolution fails, @error (if non-%NULL) will be set to a
value from #GResolverError.
If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.
If you are planning to connect to a socket on the resolved IP
address, it may be easier to create a #GNetworkAddress and use its
#GSocketConnectable interface.
of #GInetAddress, or %NULL on error. You
must unref each of the addresses and free the list when you are
done with it. (You can use g_resolver_free_addresses() to do this.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="InetAddress"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the hostname to look up</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_by_name_async"
                      invoker="lookup_by_name_async"
                      version="2.22">
        <doc xml:whitespace="preserve">Begins asynchronously resolving @hostname to determine its
associated IP address(es), and eventually calls @callback, which
must call g_resolver_lookup_by_name_finish() to get the result.
See g_resolver_lookup_by_name() for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the hostname to look up the address of</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_by_name_finish"
                      invoker="lookup_by_name_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Retrieves the result of a call to
g_resolver_lookup_by_name_async().
If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name()
for more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="InetAddress"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_service" introspectable="0" throws="1">
        <return-value>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="rrname" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_service_async">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="rrname" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_service_finish"
                      invoker="lookup_service_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Retrieves the result of a previous call to
g_resolver_lookup_service_async().
If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
or %NULL on error. See g_resolver_lookup_service() for more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GSrvTarget,</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="SrvTarget"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="lookup_by_address"
              c:identifier="g_resolver_lookup_by_address"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Synchronously reverse-resolves @address to determine its
associated hostname.
If the DNS resolution fails, @error (if non-%NULL) will be set to
a value from #GResolverError.
If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.
form), or %NULL on error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a hostname (either ASCII-only, or in ASCII-encoded</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">the address to reverse-resolve</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_by_address_async"
              c:identifier="g_resolver_lookup_by_address_async"
              version="2.22">
        <doc xml:whitespace="preserve">Begins asynchronously reverse-resolving @address to determine its
associated hostname, and eventually calls @callback, which must
call g_resolver_lookup_by_address_finish() to get the final result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">the address to reverse-resolve</doc>
            <type name="InetAddress" c:type="GInetAddress*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_by_address_finish"
              c:identifier="g_resolver_lookup_by_address_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Retrieves the result of a previous call to
g_resolver_lookup_by_address_async().
If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
form), or %NULL on error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a hostname (either ASCII-only, or in ASCII-encoded</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_by_name"
              c:identifier="g_resolver_lookup_by_name"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Synchronously resolves @hostname to determine its associated IP
address(es). @hostname may be an ASCII-only or UTF-8 hostname, or
the textual form of an IP address (in which case this just becomes
a wrapper around g_inet_address_new_from_string()).
On success, g_resolver_lookup_by_name() will return a #GList of
#GInetAddress, sorted in order of preference. (That is, you should
attempt to connect to the first address first, then the second if
the first fails, etc.)
If the DNS resolution fails, @error (if non-%NULL) will be set to a
value from #GResolverError.
If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.
If you are planning to connect to a socket on the resolved IP
address, it may be easier to create a #GNetworkAddress and use its
#GSocketConnectable interface.
of #GInetAddress, or %NULL on error. You
must unref each of the addresses and free the list when you are
done with it. (You can use g_resolver_free_addresses() to do this.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="InetAddress"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the hostname to look up</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_by_name_async"
              c:identifier="g_resolver_lookup_by_name_async"
              version="2.22">
        <doc xml:whitespace="preserve">Begins asynchronously resolving @hostname to determine its
associated IP address(es), and eventually calls @callback, which
must call g_resolver_lookup_by_name_finish() to get the result.
See g_resolver_lookup_by_name() for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the hostname to look up the address of</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_by_name_finish"
              c:identifier="g_resolver_lookup_by_name_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Retrieves the result of a call to
g_resolver_lookup_by_name_async().
If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
of #GInetAddress, or %NULL on error. See g_resolver_lookup_by_name()
for more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="InetAddress"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_service"
              c:identifier="g_resolver_lookup_service"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Synchronously performs a DNS SRV lookup for the given @service and
include the leading underscore that appears in the actual DNS
entry.
On success, g_resolver_lookup_service() will return a #GList of
#GSrvTarget, sorted in order of preference. (That is, you should
attempt to connect to the first target first, then the second if
the first fails, etc.)
If the DNS resolution fails, @error (if non-%NULL) will be set to
a value from #GResolverError.
If @cancellable is non-%NULL, it can be used to cancel the
operation, in which case @error (if non-%NULL) will be set to
%G_IO_ERROR_CANCELLED.
If you are planning to connect to the service, it is usually easier
to create a #GNetworkService and use its #GSocketConnectable
interface.
or %NULL on error. You must free each of the targets and the list when you are
done with it. (You can use g_resolver_free_targets() to do this.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GSrvTarget,</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="SrvTarget"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="service" transfer-ownership="none">
            <doc xml:whitespace="preserve">the service type to look up (eg, "ldap")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the networking protocol to use for @service (eg, "tcp")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DNS domain to look up the service in</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_service_async"
              c:identifier="g_resolver_lookup_service_async"
              version="2.22">
        <doc xml:whitespace="preserve">Begins asynchronously performing a DNS SRV lookup for the given
get the final result. See g_resolver_lookup_service() for more
details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service" transfer-ownership="none">
            <doc xml:whitespace="preserve">the service type to look up (eg, "ldap")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the networking protocol to use for @service (eg, "tcp")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DNS domain to look up the service in</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">callback to call after resolution completes</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_service_finish"
              c:identifier="g_resolver_lookup_service_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Retrieves the result of a previous call to
g_resolver_lookup_service_async().
If the DNS resolution failed, @error (if non-%NULL) will be set to
a value from #GResolverError. If the operation was cancelled,
or %NULL on error. See g_resolver_lookup_service() for more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GSrvTarget,</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="SrvTarget"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default"
              c:identifier="g_resolver_set_default"
              version="2.22">
        <doc xml:whitespace="preserve">Sets @resolver to be the application's default resolver (reffing
Future calls to g_resolver_get_default() will return this resolver.
This can be used if an application wants to perform any sort of DNS
caching or "pinning"; it can implement its own #GResolver that
calls the original default resolver for DNS operations, and
implements its own cache policies on top of that, and then set
itself as the default resolver for all later code to use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ResolverPrivate" c:type="GResolverPrivate*"/>
      </field>
      <glib:signal name="reload">
        <doc xml:whitespace="preserve">Emitted when the resolver notices that the system resolver
configuration has changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ResolverClass"
            c:type="GResolverClass"
            glib:is-gtype-struct-for="Resolver">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reload">
        <callback name="reload">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_name">
        <callback name="lookup_by_name" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GList</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="InetAddress"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="hostname" transfer-ownership="none">
              <doc xml:whitespace="preserve">the hostname to look up</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_name_async">
        <callback name="lookup_by_name_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="hostname" transfer-ownership="none">
              <doc xml:whitespace="preserve">the hostname to look up the address of</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">callback to call after resolution completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">data for @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_name_finish">
        <callback name="lookup_by_name_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GList</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="InetAddress"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_address">
        <callback name="lookup_by_address" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a hostname (either ASCII-only, or in ASCII-encoded</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="address" transfer-ownership="none">
              <doc xml:whitespace="preserve">the address to reverse-resolve</doc>
              <type name="InetAddress" c:type="GInetAddress*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_address_async">
        <callback name="lookup_by_address_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="address" transfer-ownership="none">
              <doc xml:whitespace="preserve">the address to reverse-resolve</doc>
              <type name="InetAddress" c:type="GInetAddress*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">callback to call after resolution completes</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">data for @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_by_address_finish">
        <callback name="lookup_by_address_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a hostname (either ASCII-only, or in ASCII-encoded</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_service" introspectable="0">
        <callback name="lookup_service" introspectable="0" throws="1">
          <return-value>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="rrname" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_service_async">
        <callback name="lookup_service_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="rrname" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_service_finish">
        <callback name="lookup_service_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GList of #GSrvTarget,</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="SrvTarget"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="resolver" transfer-ownership="none">
              <type name="Resolver" c:type="GResolver*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">the result passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="ResolverError"
                 version="2.22"
                 glib:type-name="GResolverError"
                 glib:get-type="g_resolver_error_get_type"
                 c:type="GResolverError"
                 glib:error-quark="g_resolver_error_quark">
      <doc xml:whitespace="preserve">An error code used with %G_RESOLVER_ERROR in a #GError returned
from a #GResolver routine.</doc>
      <member name="not_found"
              value="0"
              c:identifier="G_RESOLVER_ERROR_NOT_FOUND"
              glib:nick="not-found"/>
      <member name="temporary_failure"
              value="1"
              c:identifier="G_RESOLVER_ERROR_TEMPORARY_FAILURE"
              glib:nick="temporary-failure"/>
      <member name="internal"
              value="2"
              c:identifier="G_RESOLVER_ERROR_INTERNAL"
              glib:nick="internal"/>
    </enumeration>
    <record name="ResolverPrivate" c:type="GResolverPrivate" disguised="1">
    </record>
    <constant name="SETTINGS_BACKEND_EXTENSION_POINT_NAME"
              value="gsettings-backend">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <interface name="Seekable"
               c:symbol-prefix="seekable"
               c:type="GSeekable"
               glib:type-name="GSeekable"
               glib:get-type="g_seekable_get_type"
               glib:type-struct="SeekableIface">
      <doc xml:whitespace="preserve">Seek object for streaming operations.</doc>
      <virtual-method name="can_seek" invoker="can_seek">
        <doc xml:whitespace="preserve">Tests if the stream supports the #GSeekableIface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @seekable can be seeked. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="can_truncate" invoker="can_truncate">
        <doc xml:whitespace="preserve">Tests if the stream can be truncated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the stream can be truncated, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="seek" invoker="seek" throws="1">
        <doc xml:whitespace="preserve">Seeks in the stream by the given @offset, modified by @type.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
has occurred, this function will return %FALSE and set @error
appropriately if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful. If an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #goffset.</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSeekType.</doc>
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="tell" invoker="tell">
        <doc xml:whitespace="preserve">Tells the current position within the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset from the beginning of the buffer.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
      </virtual-method>
      <virtual-method name="truncate_fn" invoker="truncate" throws="1">
        <doc xml:whitespace="preserve">Truncates a stream with a given #offset.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.
has occurred, this function will return %FALSE and set @error
appropriately if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful. If an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #goffset.</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="can_seek" c:identifier="g_seekable_can_seek">
        <doc xml:whitespace="preserve">Tests if the stream supports the #GSeekableIface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @seekable can be seeked. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="can_truncate" c:identifier="g_seekable_can_truncate">
        <doc xml:whitespace="preserve">Tests if the stream can be truncated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the stream can be truncated, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="seek" c:identifier="g_seekable_seek" throws="1">
        <doc xml:whitespace="preserve">Seeks in the stream by the given @offset, modified by @type.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
has occurred, this function will return %FALSE and set @error
appropriately if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful. If an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #goffset.</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSeekType.</doc>
            <type name="GLib.SeekType" c:type="GSeekType"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="tell" c:identifier="g_seekable_tell">
        <doc xml:whitespace="preserve">Tells the current position within the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset from the beginning of the buffer.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
      </method>
      <method name="truncate" c:identifier="g_seekable_truncate" throws="1">
        <doc xml:whitespace="preserve">Truncates a stream with a given #offset.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.
has occurred, this function will return %FALSE and set @error
appropriately if present.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if successful. If an error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #goffset.</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="SeekableIface"
            c:type="GSeekableIface"
            glib:is-gtype-struct-for="Seekable">
      <doc xml:whitespace="preserve">Provides an interface for implementing seekable functionality on I/O Streams.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="tell">
        <callback name="tell">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset from the beginning of the buffer.</doc>
            <type name="gint64" c:type="goffset"/>
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none">
              <type name="Seekable" c:type="GSeekable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_seek">
        <callback name="can_seek">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if @seekable can be seeked. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none">
              <type name="Seekable" c:type="GSeekable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek">
        <callback name="seek" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if successful. If an error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none">
              <type name="Seekable" c:type="GSeekable*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #goffset.</doc>
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GSeekType.</doc>
              <type name="GLib.SeekType" c:type="GSeekType"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_truncate">
        <callback name="can_truncate">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the stream can be truncated, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none">
              <type name="Seekable" c:type="GSeekable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="truncate_fn">
        <callback name="truncate_fn" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if successful. If an error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none">
              <type name="Seekable" c:type="GSeekable*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #goffset.</doc>
              <type name="gint64" c:type="goffset"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="Settings"
           c:symbol-prefix="settings"
           c:type="GSettings"
           parent="GObject.Object"
           glib:type-name="GSettings"
           glib:get-type="g_settings_get_type"
           glib:type-struct="SettingsClass">
      <constructor name="new" c:identifier="g_settings_new" version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GSettings object with a given schema.
Signals on the newly created #GSettings object will be dispatched
via the thread-default #GMainContext in effect at the time of the
call to g_settings_new().  The new #GSettings will hold a reference
on the context.  See g_main_context_push_thread_default().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSettings object</doc>
          <type name="Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <parameter name="schema" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the schema</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_backend"
                   c:identifier="g_settings_new_with_backend"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GSettings object with a given schema and backend.
Creating settings objects with an different backend allows accessing settings
from a database other than the usual one.  For example, it may make
sense to pass a backend corresponding to the "defaults" settings database on
the system to get a settings object that modifies the system default
settings instead of the settings for this user.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSettings object</doc>
          <type name="Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <parameter name="schema" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the schema</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="backend" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GSettingsBackend to use</doc>
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_backend_and_path"
                   c:identifier="g_settings_new_with_backend_and_path"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GSettings object with a given schema, backend and
path.
This is a mix of g_settings_new_with_backend() and
g_settings_new_with_path().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSettings object</doc>
          <type name="Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <parameter name="schema" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the schema</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="backend" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GSettingsBackend to use</doc>
            <type name="SettingsBackend" c:type="GSettingsBackend*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the path to use</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_path"
                   c:identifier="g_settings_new_with_path"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GSettings object with a given schema and path.
You only need to do this if you want to directly create a settings
object with a schema that doesn't have a specified path of its own.
That's quite rare.
It is a programmer error to call this function for a schema that
has an explicitly specified path.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSettings object</doc>
          <type name="Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <parameter name="schema" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the schema</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the path to use</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="list_schemas" c:identifier="g_settings_list_schemas">
        <doc xml:whitespace="preserve">must not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a list of GSettings schemas that are available.  The list</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </function>
      <function name="sync" c:identifier="g_settings_sync">
        <doc xml:whitespace="preserve">Ensures that all pending operations for the given are complete for
the default backend.
Writes made to a #GSettings are handled asynchronously.  For this
reason, it is very unlikely that the changes have it to disk by the
time g_settings_set() returns.
This call will block until all of the writes have made it to the
backend.  Since the mainloop is not running, no change notifications
will be dispatched during this call (but some may be queued by the
time the call is done).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="unbind" c:identifier="g_settings_unbind" version="2.26">
        <doc xml:whitespace="preserve">Removes an existing binding for @property on @object.
Note that bindings are automatically removed when the
object is finalized, so it is rarely necessary to call this
function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property whose binding is removed</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="apply" c:identifier="g_settings_apply">
        <doc xml:whitespace="preserve">Applies any changes that have been made to the settings.  This
function does nothing unless @settings is in 'delay-apply' mode;
see g_settings_delay().  In the normal case settings are always
applied immediately.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="bind" c:identifier="g_settings_bind" version="2.26">
        <doc xml:whitespace="preserve">Create a binding between the @key in the @settings object
and the property @property of @object.
The binding uses the default GIO mapping functions to map
between the settings and property values. These functions
handle booleans, numeric types and string types in a
straightforward way. Use g_settings_bind_with_mapping() if
you need a custom mapping, or map between types that are not
supported by the default mapping functions.
Unless the @flags include %G_SETTINGS_BIND_NO_SENSITIVITY, this
function also establishes a binding between the writability of
a boolean property by that name). See g_settings_bind_writable()
for more details about writable bindings.
Note that the lifecycle of the binding is tied to the object,
and that you can have only one binding per object property.
If you bind the same property twice on the same object, the second
binding overrides the first one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the property to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags for the binding</doc>
            <type name="SettingsBindFlags" c:type="GSettingsBindFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_with_mapping"
              c:identifier="g_settings_bind_with_mapping"
              version="2.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Create a binding between the @key in the @settings object
and the property @property of @object.
The binding uses the provided mapping functions to map between
settings and property values.
Note that the lifecycle of the binding is tied to the object,
and that you can have only one binding per object property.
If you bind the same property twice on the same object, the second
binding overrides the first one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the property to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags for the binding</doc>
            <type name="SettingsBindFlags" c:type="GSettingsBindFlags"/>
          </parameter>
          <parameter name="get_mapping" transfer-ownership="none">
            <doc xml:whitespace="preserve">a function that gets called to convert values from @settings to @object, or %NULL to use the default GIO mapping</doc>
            <type name="SettingsBindGetMapping"
                  c:type="GSettingsBindGetMapping"/>
          </parameter>
          <parameter name="set_mapping"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:whitespace="preserve">a function that gets called to convert values from @object to @settings, or %NULL to use the default GIO mapping</doc>
            <type name="SettingsBindSetMapping"
                  c:type="GSettingsBindSetMapping"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data that gets passed to @get_mapping and @set_mapping</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">#GDestroyNotify function for @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_writable"
              c:identifier="g_settings_bind_writable"
              version="2.26">
        <doc xml:whitespace="preserve">Create a binding between the writability of @key in the
The property must be boolean; "sensitive" or "visible"
properties of widgets are the most likely candidates.
Writable bindings are always uni-directional; changes of the
writability of the setting will be propagated to the object
property, not the other way.
When the @inverted argument is %TRUE, the binding inverts the
value as it passes from the setting to the object, i.e. @property
will be set to %TRUE if the key is &lt;emphasis&gt;not&lt;/emphasis&gt;
writable.
Note that the lifecycle of the binding is tied to the object,
and that you can have only one binding per object property.
If you bind the same property twice on the same object, the second
binding overrides the first one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a boolean property to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="inverted" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to 'invert' the value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="delay" c:identifier="g_settings_delay" version="2.26">
        <doc xml:whitespace="preserve">Changes the #GSettings object into 'delay-apply' mode. In this
mode, changes to @settings are not immediately propagated to the
backend, but kept locally until g_settings_apply() is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get"
              c:identifier="g_settings_get"
              version="2.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets the value that is stored at @key in @settings.
A convenience function that combines g_settings_get_value() with
g_variant_get().
It is a programmer error to give a @key that isn't contained in the
schema for @settings or for the #GVariantType of @format to mismatch
the type given in the schema.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GVariant format string</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean"
              c:identifier="g_settings_get_boolean"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the value that is stored at @key in @settings.
A convenience variant of g_settings_get() for booleans.
It is a programmer error to give a @key that isn't specified as
having a boolean type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a boolean</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_child"
              c:identifier="g_settings_get_child"
              version="2.26">
        <doc xml:whitespace="preserve">Creates a 'child' settings object which has a base path of
&lt;replaceable&gt;base-path&lt;/replaceable&gt;/@name", where
&lt;replaceable&gt;base-path&lt;/replaceable&gt; is the base path of @settings.
The schema for the child settings object must have been declared
in the schema of @settings using a &lt;tag class="starttag"&gt;child&lt;/tag&gt; element.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a 'child' settings object</doc>
          <type name="Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the 'child' schema</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double"
              c:identifier="g_settings_get_double"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the value that is stored at @key in @settings.
A convenience variant of g_settings_get() for doubles.
It is a programmer error to give a @key that isn't specified as
having a 'double' type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a double</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_enum"
              c:identifier="g_settings_get_enum"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the value that is stored in @settings for @key and converts it
to the enum value that it represents.
In order to use this function the type of the value must be a string
and it must be marked in the schema file as an enumerated type.
It is a programmer error to give a @key that isn't contained in the
schema for @settings or is not marked as an enumerated type.
If the value stored in the configuration database is not a valid
value for the enumerated type then this function will return the
default value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the enum value</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_flags"
              c:identifier="g_settings_get_flags"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the value that is stored in @settings for @key and converts it
to the flags value that it represents.
In order to use this function the type of the value must be an array
of strings and it must be marked in the schema file as an flags type.
It is a programmer error to give a @key that isn't contained in the
schema for @settings or is not marked as a flags type.
If the value stored in the configuration database is not a valid
value for the flags type then this function will return the default
value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the flags value</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_has_unapplied"
              c:identifier="g_settings_get_has_unapplied"
              version="2.26">
        <doc xml:whitespace="preserve">Returns whether the #GSettings object has any unapplied
changes.  This can only be the case if it is in 'delayed-apply' mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @settings has unapplied changes</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_int" c:identifier="g_settings_get_int" version="2.26">
        <doc xml:whitespace="preserve">Gets the value that is stored at @key in @settings.
A convenience variant of g_settings_get() for 32-bit integers.
It is a programmer error to give a @key that isn't specified as
having a int32 type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an integer</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mapped"
              c:identifier="g_settings_get_mapped"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets the value that is stored at @key in @settings, subject to
application-level validation/mapping.
You should use this function when the application needs to perform
some processing on the value of the key (for example, parsing).  The
indicates that the processing was unsuccessful (due to a parse error,
for example) then the mapping is tried again with another value.
This allows a robust 'fall back to defaults' behaviour to be
implemented somewhat automatically.
The first value that is tried is the user's setting for the key.  If
the mapping function fails to map this value, other values may be
tried in an unspecified order (system or site defaults, translated
schema default values, untranslated schema default values, etc).
If the mapping function fails for all possible values, one additional
If the mapping function still indicates failure at this point then
the application will be aborted.
The result parameter for the @mapping function is pointed to a
#gpointer which is initially set to %NULL.  The same pointer is given
to each invocation of @mapping.  The final value of that #gpointer is
what is returned by this function.  %NULL is valid; it is returned
just as any other value would be.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the result, which may be %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="mapping" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">the function to map the value in the settings database to the value used by the application</doc>
            <type name="SettingsGetMapping" c:type="GSettingsGetMapping"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for @mapping</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string"
              c:identifier="g_settings_get_string"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the value that is stored at @key in @settings.
A convenience variant of g_settings_get() for strings.
It is a programmer error to give a @key that isn't specified as
having a string type in the schema for @settings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly-allocated string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_strv"
              c:identifier="g_settings_get_strv"
              version="2.26">
        <doc xml:whitespace="preserve">A convenience variant of g_settings_get() for string arrays.
It is a programmer error to give a @key that isn't specified as
having an array of strings type in the schema for @settings.
stored at @key in @settings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the value that is</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value"
              c:identifier="g_settings_get_value"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the value that is stored in @settings for @key.
It is a programmer error to give a @key that isn't contained in the
schema for @settings.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GVariant</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to get the value for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_writable"
              c:identifier="g_settings_is_writable"
              version="2.26">
        <doc xml:whitespace="preserve">Finds out if a key can be written or not</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the key @name is writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a key</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_children" c:identifier="g_settings_list_children">
        <doc xml:whitespace="preserve">Gets the list of children on @settings.
The list is exactly the list of strings for which it is not an error
to call g_settings_get_child().
For GSettings objects that are lists, this value can change at any
time and you should connect to the "children-changed" signal to watch
request a child after listing it only for it to have been destroyed
in the meantime.  For this reason, g_settings_get_chuld() may return
%NULL even for a child that was listed by this function.
For GSettings objects that are not lists, you should probably not be
calling this function from "normal" code (since you should already
know what children are in your schema).  This function may still be
useful there for introspection reasons, however.
You should free the return value with g_strfreev() when you are done
with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a list of the children on @settings</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="list_keys" c:identifier="g_settings_list_keys">
        <doc xml:whitespace="preserve">Introspects the list of keys on @settings.
You should probably not be calling this function from "normal" code
(since you should already know what keys are in your schema).  This
function is intended for introspection reasons.
You should free the return value with g_strfreev() when you are done
with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a list of the keys on @settings</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="reset" c:identifier="g_settings_reset">
        <doc xml:whitespace="preserve">Resets @key to its default value.
This call resets the key, as much as possible, to its default value.
That might the value specified in the schema or the one set by the
administrator.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a key</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="revert" c:identifier="g_settings_revert">
        <doc xml:whitespace="preserve">Reverts all non-applied changes to the settings.  This function
does nothing unless @settings is in 'delay-apply' mode; see
g_settings_delay().  In the normal case settings are always applied
immediately.
Change notifications will be emitted for affected keys.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set"
              c:identifier="g_settings_set"
              version="2.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets @key in @settings to @value.
A convenience function that combines g_settings_set_value() with
g_variant_new().
It is a programmer error to give a @key that isn't contained in the
schema for @settings or for the #GVariantType of @format to mismatch
the type given in the schema.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if setting the key succeeded, %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GVariant format string</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_boolean"
              c:identifier="g_settings_set_boolean"
              version="2.26">
        <doc xml:whitespace="preserve">Sets @key in @settings to @value.
A convenience variant of g_settings_set() for booleans.
It is a programmer error to give a @key that isn't specified as
having a boolean type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if setting the key succeeded, %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to set it to</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double"
              c:identifier="g_settings_set_double"
              version="2.26">
        <doc xml:whitespace="preserve">Sets @key in @settings to @value.
A convenience variant of g_settings_set() for doubles.
It is a programmer error to give a @key that isn't specified as
having a 'double' type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if setting the key succeeded, %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to set it to</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enum" c:identifier="g_settings_set_enum">
        <doc xml:whitespace="preserve">Looks up the enumerated type nick for @value and writes it to @key,
within @settings.
It is a programmer error to give a @key that isn't contained in the
schema for @settings or is not marked as an enumerated type, or for
After performing the write, accessing @key directly with
g_settings_get_string() will return the 'nick' associated with</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE, if the set succeeds</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key, within @settings</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">an enumerated value</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="g_settings_set_flags">
        <doc xml:whitespace="preserve">Looks up the flags type nicks for the bits specified by @value, puts
them in an array of strings and writes the array to @key, withing
It is a programmer error to give a @key that isn't contained in the
schema for @settings or is not marked as a flags type, or for @value
to contain any bits that are not value for the named type.
After performing the write, accessing @key directly with
g_settings_get_strv() will return an array of 'nicks'; one for each
bit in @value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE, if the set succeeds</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key, within @settings</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a flags value</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="g_settings_set_int" version="2.26">
        <doc xml:whitespace="preserve">Sets @key in @settings to @value.
A convenience variant of g_settings_set() for 32-bit integers.
It is a programmer error to give a @key that isn't specified as
having a int32 type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if setting the key succeeded, %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to set it to</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string"
              c:identifier="g_settings_set_string"
              version="2.26">
        <doc xml:whitespace="preserve">Sets @key in @settings to @value.
A convenience variant of g_settings_set() for strings.
It is a programmer error to give a @key that isn't specified as
having a string type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if setting the key succeeded, %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to set it to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_strv"
              c:identifier="g_settings_set_strv"
              version="2.26">
        <doc xml:whitespace="preserve">Sets @key in @settings to @value.
A convenience variant of g_settings_set() for string arrays.  If
It is a programmer error to give a @key that isn't specified as
having an array of strings type in the schema for @settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if setting the key succeeded, %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the value to set it to, or %NULL</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_value"
              c:identifier="g_settings_set_value"
              version="2.26">
        <doc xml:whitespace="preserve">Sets @key in @settings to @value.
It is a programmer error to give a @key that isn't contained in the
schema for @settings or for @value to have the incorrect type, per
the schema.
If @value is floating then this function consumes the reference.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if setting the key succeeded, %FALSE if the key was not writable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the key to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GVariant of the correct type</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <property name="backend"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="SettingsBackend"/>
      </property>
      <property name="has-unapplied" transfer-ownership="none">
        <doc xml:whitespace="preserve">If this property is %TRUE, the #GSettings object has outstanding
changes that will be applied when g_settings_apply() is called.</doc>
        <type name="gboolean"/>
      </property>
      <property name="path"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The path within the backend where the settings are stored.</doc>
        <type name="utf8"/>
      </property>
      <property name="schema"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the schema that describes the types of keys
for this #GSettings object.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SettingsPrivate" c:type="GSettingsPrivate*"/>
      </field>
      <glib:signal name="change-event">
        <doc xml:whitespace="preserve">The "change-event" signal is emitted once per change event that
affects this settings object.  You should connect to this signal
only if you are interested in viewing groups of changes before they
are split out into multiple emissions of the "changed" signal.
For most use cases it is more appropriate to use the "changed" signal.
In the event that the change event applies to one or more specified
keys, @keys will be an array of #GQuark of length @n_keys.  In the
event that the change event applies to the #GSettings object as a
be %NULL and @n_keys will be 0.
The default handler for this signal invokes the "changed" signal
for each affected key.  If any other connected handler returns
%TRUE then this default functionality will be supressed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE to stop other handlers from being invoked for the event. FALSE to propagate the event further.</doc>
          <type name="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of #GQuark&lt;!-- --&gt;s for the changed keys, or %NULL</doc>
            <type name="gpointer"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of the @keys array, or 0</doc>
            <type name="gint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="changed">
        <doc xml:whitespace="preserve">The "changed" signal is emitted when a key has potentially changed.
You should call one of the g_settings_get() calls to check the new
value.
This signal supports detailed connections.  You can connect to the
detailed signal "changed::x" in order to only receive callbacks
when key "x" changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the key that changed</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="writable-change-event">
        <doc xml:whitespace="preserve">The "writable-change-event" signal is emitted once per writability
change event that affects this settings object.  You should connect
to this signal if you are interested in viewing groups of changes
before they are split out into multiple emissions of the
"writable-changed" signal.  For most use cases it is more
appropriate to use the "writable-changed" signal.
In the event that the writability change applies only to a single
key, @key will be set to the #GQuark for that key.  In the event
that the writability change affects the entire settings object,
The default handler for this signal invokes the "writable-changed"
and "changed" signals for each affected key.  This is done because
changes in writability might also imply changes in value (if for
example, a new mandatory setting is introduced).  If any other
connected handler returns %TRUE then this default functionality
will be supressed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE to stop other handlers from being invoked for the event. FALSE to propagate the event further.</doc>
          <type name="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the quark of the key, or 0</doc>
            <type name="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="writable-changed">
        <doc xml:whitespace="preserve">The "writable-changed" signal is emitted when the writability of a
key has potentially changed.  You should call
g_settings_is_writable() in order to determine the new status.
This signal supports detailed connections.  You can connect to the
detailed signal "writable-changed::x" in order to only receive
callbacks when the writability of "x" changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="SettingsBackend"
           c:symbol-prefix="settings_backend"
           c:type="GSettingsBackend"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GSettingsBackend"
           glib:get-type="g_settings_backend_get_type"
           glib:type-struct="SettingsBackendClass">
      <doc xml:whitespace="preserve">An implementation of a settings storage repository.</doc>
      <function name="flatten_tree"
                c:identifier="g_settings_backend_flatten_tree"
                version="2.26">
        <doc xml:whitespace="preserve">Calculate the longest common prefix of all keys in a tree and write
out an array of the key names relative to that prefix and,
optionally, the value to store at each of those keys.
You must free the value returned in @path, @keys and @values using
g_free().  You should not attempt to free or unref the contents of</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tree" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GTree containing the changes</doc>
            <type name="GLib.Tree" c:type="GTree*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the location to save the path</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="keys" transfer-ownership="none">
            <doc xml:whitespace="preserve">the location to save the relative keys</doc>
            <type name="utf8" c:type="gchar***"/>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:whitespace="preserve">the location to save the values, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant***"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="get_permission" introspectable="0">
        <return-value>
          <type name="Permission" c:type="GPermission*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_writable">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read">
        <return-value transfer-ownership="full">
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="expected_type" transfer-ownership="none">
            <type name="GLib.VariantType" c:type="GVariantType*"/>
          </parameter>
          <parameter name="default_value" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="subscribe">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sync">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unsubscribe">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_tree">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tree" transfer-ownership="none">
            <type name="GLib.Tree" c:type="GTree*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="changed"
              c:identifier="g_settings_backend_changed"
              version="2.26">
        <doc xml:whitespace="preserve">Signals that a single key has possibly changed.  Backend
implementations should call this if a key has possibly changed its
value.
'//', and not ending with a slash).
The implementation must call this function during any call to
g_settings_backend_write(), before the call returns (except in the
case that no keys are actually changed and it cares to detect this
fact).  It may not rely on the existence of a mainloop for
dispatching the signal later.
The implementation may call this function at any other time it likes
in response to other events (such as changes occuring outside of the
program).  These calls may originate from a mainloop or may originate
in response to any other action (including from calls to
g_settings_backend_write()).
In the case that this call is in response to a call to
g_settings_backend_write() then @origin_tag must be set to the same
value that was passed to that call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the key</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">the origin tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="changed_tree"
              c:identifier="g_settings_backend_changed_tree"
              version="2.26">
        <doc xml:whitespace="preserve">This call is a convenience wrapper.  It gets the list of changes from
g_settings_backend_changed().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tree" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GTree containing the changes</doc>
            <type name="GLib.Tree" c:type="GTree*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">the origin tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="keys_changed"
              c:identifier="g_settings_backend_keys_changed"
              version="2.26">
        <doc xml:whitespace="preserve">Signals that a list of keys have possibly changed.  Backend
implementations should call this if keys have possibly changed their
values.
not containing '//').  Each string in @items must form a valid key
end with '/' and must not contain '//').
The meaning of this signal is that any of the key names resulting
from the contatenation of @path with each item in @items may have
changed.
The same rules for when notifications must occur apply as per
g_settings_backend_changed().  These two calls can be used
interchangeably if exactly one item has changed (although in that
case g_settings_backend_changed() is definitely preferred).
For efficiency reasons, the implementation should strive for @path to
keys that were changed) but this is not strictly required.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the path containing the changes</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="items" transfer-ownership="none">
            <doc xml:whitespace="preserve">the %NULL-terminated list of changed keys</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">the origin tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="path_changed"
              c:identifier="g_settings_backend_path_changed"
              version="2.26">
        <doc xml:whitespace="preserve">Signals that all keys below a given path may have possibly changed.
Backend implementations should call this if an entire path of keys
have possibly changed their values.
not containing '//').
The meaning of this signal is that any of the key which has a name
starting with @path may have changed.
The same rules for when notifications must occur apply as per
g_settings_backend_changed().  This call might be an appropriate
reasponse to a 'reset' call but implementations are also free to
explicitly list the keys that were affected by that call if they can
easily do so.
For efficiency reasons, the implementation should strive for @path to
keys that were changed) but this is not strictly required.  As an
example, if this function is called with the path of "/" then every
single key in the application will be notified of a possible change.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the path containing the changes</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="origin_tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">the origin tag</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="path_writable_changed"
              c:identifier="g_settings_backend_path_writable_changed"
              version="2.26">
        <doc xml:whitespace="preserve">Signals that the writability of all keys below a given path may have
changed.
Since GSettings performs no locking operations for itself, this call
will always be made in response to external events.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the path</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="writable_changed"
              c:identifier="g_settings_backend_writable_changed"
              version="2.26">
        <doc xml:whitespace="preserve">Signals that the writability of a single key has possibly changed.
Since GSettings performs no locking operations for itself, this call
will always be made in response to external events.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the key</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SettingsBackendPrivate" c:type="GSettingsBackendPrivate*"/>
      </field>
    </class>
    <record name="SettingsBackendClass"
            c:type="GSettingsBackendClass"
            glib:is-gtype-struct-for="SettingsBackend">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="read">
        <callback name="read">
          <return-value transfer-ownership="full">
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="expected_type" transfer-ownership="none">
              <type name="GLib.VariantType" c:type="GVariantType*"/>
            </parameter>
            <parameter name="default_value" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_writable">
        <callback name="get_writable">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write">
        <callback name="write">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
            <parameter name="origin_tag" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write_tree">
        <callback name="write_tree">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="tree" transfer-ownership="none">
              <type name="GLib.Tree" c:type="GTree*"/>
            </parameter>
            <parameter name="origin_tag" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="origin_tag" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="subscribe">
        <callback name="subscribe">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unsubscribe">
        <callback name="unsubscribe">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sync">
        <callback name="sync">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_permission" introspectable="0">
        <callback name="get_permission" introspectable="0">
          <return-value>
            <type name="Permission" c:type="GPermission*"/>
          </return-value>
          <parameters>
            <parameter name="backend" transfer-ownership="none">
              <type name="SettingsBackend" c:type="GSettingsBackend*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="gpointer" fixed-size="24">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SettingsBackendPrivate"
            c:type="GSettingsBackendPrivate"
            disguised="1">
    </record>
    <bitfield name="SettingsBindFlags"
              glib:type-name="GSettingsBindFlags"
              glib:get-type="g_settings_bind_flags_get_type"
              c:type="GSettingsBindFlags">
      <doc xml:whitespace="preserve">Flags used when creating a binding. These flags determine in which
direction the binding works. The default is to synchronize in both
directions.</doc>
      <member name="default"
              value="0"
              c:identifier="G_SETTINGS_BIND_DEFAULT"
              glib:nick="default"/>
      <member name="get"
              value="1"
              c:identifier="G_SETTINGS_BIND_GET"
              glib:nick="get"/>
      <member name="set"
              value="2"
              c:identifier="G_SETTINGS_BIND_SET"
              glib:nick="set"/>
      <member name="no_sensitivity"
              value="4"
              c:identifier="G_SETTINGS_BIND_NO_SENSITIVITY"
              glib:nick="no-sensitivity"/>
      <member name="get_no_changes"
              value="8"
              c:identifier="G_SETTINGS_BIND_GET_NO_CHANGES"
              glib:nick="get-no-changes"/>
      <member name="invert_boolean"
              value="16"
              c:identifier="G_SETTINGS_BIND_INVERT_BOOLEAN"
              glib:nick="invert-boolean"/>
    </bitfield>
    <callback name="SettingsBindGetMapping" c:type="GSettingsBindGetMapping">
      <doc xml:whitespace="preserve">The type for the function that is used to convert from #GSettings to
an object property. The @value is already initialized to hold values
of the appropriate type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the conversion succeeded, %FALSE in case of an error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">return location for the property value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="variant" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GVariant</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data that was specified when the binding was created</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SettingsBindSetMapping" c:type="GSettingsBindSetMapping">
      <doc xml:whitespace="preserve">The type for the function that is used to convert an object property
value to a #GVariant for storing it in #GSettings.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GVariant holding the data from @value, or %NULL in case of an error</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue containing the property value to map</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="expected_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GVariantType to create</doc>
          <type name="GLib.VariantType" c:type="GVariantType*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data that was specified when the binding was created</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SettingsClass"
            c:type="GSettingsClass"
            glib:is-gtype-struct-for="Settings">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="writable_changed">
        <callback name="writable_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="Settings" c:type="GSettings*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="Settings" c:type="GSettings*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="writable_change_event">
        <callback name="writable_change_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="Settings" c:type="GSettings*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="GLib.Quark" c:type="GQuark"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="change_event">
        <callback name="change_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="Settings" c:type="GSettings*"/>
            </parameter>
            <parameter name="keys" transfer-ownership="none">
              <type name="GLib.Quark" c:type="GQuark*"/>
            </parameter>
            <parameter name="n_keys" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="SettingsGetMapping" c:type="GSettingsGetMapping">
      <doc xml:whitespace="preserve">The type of the function that is used to convert from a value stored
in a #GSettings to a value that is useful to the application.
If the value is successfully mapped, the result should be stored at
is not in the right format) then %FALSE should be returned.
If @value is %NULL then it means that the mapping function is being
given a "last chance" to successfully return a valid value.  %TRUE
must be returned in this case.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the conversion succeeded, %FALSE in case of an error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GVariant to map, or %NULL</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="result" transfer-ownership="none">
          <doc xml:whitespace="preserve">the result of the mapping</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">the user data that was passed to g_settings_get_mapped()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SettingsPrivate" c:type="GSettingsPrivate" disguised="1">
    </record>
    <class name="SimpleAction"
           c:symbol-prefix="simple_action"
           c:type="GSimpleAction"
           version="2.26"
           parent="GObject.Object"
           glib:type-name="GSimpleAction"
           glib:get-type="g_simple_action_get_type"
           glib:type-struct="SimpleActionClass">
      <doc xml:whitespace="preserve">The &lt;structname&gt;GSimpleAction&lt;/structname&gt; structure contains private
data and should only be accessed using the provided API</doc>
      <implements name="Action"/>
      <constructor name="new"
                   c:identifier="g_simple_action_new"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new action.
The created action is stateless.  See g_simple_action_new_stateful().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSimpleAction</doc>
          <type name="SimpleAction" c:type="GSimpleAction*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameter_type"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the type of parameter to the activate function</doc>
            <type name="GLib.VariantType" c:type="GVariantType*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_stateful"
                   c:identifier="g_simple_action_new_stateful"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new stateful action.
must have the same #GVariantType as the initial state.
If the @state GVariant is floating, it is consumed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSimpleAction</doc>
          <type name="SimpleAction" c:type="GSimpleAction*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameter_type"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the type of the parameter to the activate function</doc>
            <type name="GLib.VariantType" c:type="GVariantType*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the initial state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="set_enabled"
              c:identifier="g_simple_action_set_enabled"
              version="2.26">
        <doc xml:whitespace="preserve">Sets the action as enabled or not.
An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the action is enabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="enabled"
                version="2.26"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If @action is currently enabled.
If the action is disabled then calls to g_simple_action_activate() and
g_simple_action_set_state() have no effect.</doc>
        <type name="gboolean"/>
      </property>
      <property name="name"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the action.  This is mostly meaningful for identifying
the action once it has been added to a #GSimpleActionGroup.</doc>
        <type name="utf8"/>
      </property>
      <property name="parameter-type"
                version="2.26"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The type of the parameter that must be given when activating the
action.</doc>
        <type/>
      </property>
      <property name="state"
                version="2.26"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The state of the action, or %NULL if the action is stateless.</doc>
        <type name="GLib.Variant"/>
      </property>
      <property name="state-type"
                version="2.26"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GVariantType of the state that the action has, or %NULL if the
action is stateless.</doc>
        <type/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SimpleActionPrivate" c:type="GSimpleActionPrivate*"/>
      </field>
      <glib:signal name="activate" version="2.26">
        <doc xml:whitespace="preserve">Indicates that the action was just activated.
an incorrect type was given, no signal will be emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the parameter to the activation</doc>
            <type name="GLib.Variant"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SimpleActionClass"
            c:type="GSimpleActionClass"
            glib:is-gtype-struct-for="SimpleAction"
            version="2.26">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="simple" transfer-ownership="none">
              <type name="SimpleAction" c:type="GSimpleAction*"/>
            </parameter>
            <parameter name="parameter" transfer-ownership="none">
              <type name="GLib.Variant" c:type="GVariant*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="gpointer" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SimpleActionGroup"
           c:symbol-prefix="simple_action_group"
           c:type="GSimpleActionGroup"
           version="2.26"
           parent="GObject.Object"
           glib:type-name="GSimpleActionGroup"
           glib:get-type="g_simple_action_group_get_type"
           glib:type-struct="SimpleActionGroupClass">
      <doc xml:whitespace="preserve">The #GSimpleActionGroup structure contains private data and should only be accessed using the provided API.</doc>
      <implements name="ActionGroup"/>
      <constructor name="new"
                   c:identifier="g_simple_action_group_new"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new, empty, #GSimpleActionGroup.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSimpleActionGroup</doc>
          <type name="SimpleActionGroup" c:type="GSimpleActionGroup*"/>
        </return-value>
      </constructor>
      <method name="insert"
              c:identifier="g_simple_action_group_insert"
              version="2.26">
        <doc xml:whitespace="preserve">Adds an action to the action group.
If the action group already contains an action with the same name as
The action group takes its own reference on @action.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAction</doc>
            <type name="Action" c:type="GAction*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup"
              c:identifier="g_simple_action_group_lookup"
              version="2.26">
        <doc xml:whitespace="preserve">Looks up the action with the name @action_name in the group.
If no such action exists, returns %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GAction, or %NULL</doc>
          <type name="Action" c:type="GAction*"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of an action</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove"
              c:identifier="g_simple_action_group_remove"
              version="2.26">
        <doc xml:whitespace="preserve">Removes the named action from the action group.
If no action of this name is in the group then nothing happens.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the action</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SimpleActionGroupPrivate"
              c:type="GSimpleActionGroupPrivate*"/>
      </field>
    </class>
    <record name="SimpleActionGroupClass"
            c:type="GSimpleActionGroupClass"
            glib:is-gtype-struct-for="SimpleActionGroup">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="gpointer" fixed-size="12">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SimpleActionGroupPrivate"
            c:type="GSimpleActionGroupPrivate"
            disguised="1">
    </record>
    <record name="SimpleActionPrivate"
            c:type="GSimpleActionPrivate"
            disguised="1">
    </record>
    <class name="SimpleAsyncResult"
           c:symbol-prefix="simple_async_result"
           c:type="GSimpleAsyncResult"
           parent="GObject.Object"
           glib:type-name="GSimpleAsyncResult"
           glib:get-type="g_simple_async_result_get_type"
           glib:type-struct="SimpleAsyncResultClass">
      <doc xml:whitespace="preserve">A simple implementation of #GAsyncResult.</doc>
      <implements name="AsyncResult"/>
      <constructor name="new" c:identifier="g_simple_async_result_new">
        <doc xml:whitespace="preserve">Creates a #GSimpleAsyncResult.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSimpleAsyncResult.</doc>
          <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject the asynchronous function was called with, or %NULL.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="source_tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">the asynchronous function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_error"
                   c:identifier="g_simple_async_result_new_error"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GSimpleAsyncResult with a set error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSimpleAsyncResult.</doc>
          <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject, or %NULL.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GQuark.</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">an error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string with format characters.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_error"
                   c:identifier="g_simple_async_result_new_from_error">
        <doc xml:whitespace="preserve">Creates a #GSimpleAsyncResult from an error condition.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSimpleAsyncResult.</doc>
          <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject, or %NULL.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GError location.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="is_valid" c:identifier="g_simple_async_result_is_valid">
        <doc xml:whitespace="preserve">Ensures that the data passed to the _finish function of an async
operation is consistent.  Three checks are performed.
First, @result is checked to ensure that it is really a
#GSimpleAsyncResult.  Second, @source is checked to ensure that it
matches the source object of @result.  Third, @source_tag is
checked to ensure that it is either %NULL (as it is when the result was
created by g_simple_async_report_error_in_idle() or
g_simple_async_report_gerror_in_idle()) or equal to the
convention, is a pointer to the _async function corresponding to the
_finish function from which this function is called).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if all checks passed or #FALSE if any failed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult passed to the _finish function.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GObject passed to the _finish function.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="source_tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">the asynchronous function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="complete" c:identifier="g_simple_async_result_complete">
        <doc xml:whitespace="preserve">Completes an asynchronous I/O job immediately. Must be called in
the thread where the asynchronous result was to be delivered, as it
invokes the callback directly. If you are in a different thread use
g_simple_async_result_complete_in_idle().
Calling this function takes a reference to @simple for as long as
is needed to complete the call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="complete_in_idle"
              c:identifier="g_simple_async_result_complete_in_idle">
        <doc xml:whitespace="preserve">Completes an asynchronous function in an idle handler in the &lt;link
linkend="g-main-context-push-thread-default"&gt;thread-default main
loop&lt;/link&gt; of the thread that @simple was initially created in.
Calling this function takes a reference to @simple for as long as
is needed to complete the call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_op_res_gboolean"
              c:identifier="g_simple_async_result_get_op_res_gboolean">
        <doc xml:whitespace="preserve">Gets the operation result boolean from within the asynchronous result.
if the operation's result was %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation's result was %TRUE, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_op_res_gpointer"
              c:identifier="g_simple_async_result_get_op_res_gpointer"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets a pointer result as returned by the asynchronous function.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a pointer from the result.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="get_op_res_gssize"
              c:identifier="g_simple_async_result_get_op_res_gssize">
        <doc xml:whitespace="preserve">Gets a gssize from the asynchronous result.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a gssize returned from the asynchronous function.</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
      </method>
      <method name="get_source_tag"
              c:identifier="g_simple_async_result_get_source_tag"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets the source tag for the #GSimpleAsyncResult.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a #gpointer to the source object for the #GSimpleAsyncResult.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="propagate_error"
              c:identifier="g_simple_async_result_propagate_error"
              throws="1">
        <doc xml:whitespace="preserve">Propagates an error from within the simple asynchronous result to
a given destination.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the error was propagated to @dest. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="run_in_thread"
              c:identifier="g_simple_async_result_run_in_thread"
              introspectable="0">
        <doc xml:whitespace="preserve">Runs the asynchronous job in a separate thread and then calls
g_simple_async_result_complete_in_idle() on @simple to return
the result to the appropriate main loop.
Calling this function takes a reference to @simple for as long as
is needed to run the job and report its completion.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSimpleAsyncThreadFunc.</doc>
            <type name="SimpleAsyncThreadFunc"
                  c:type="GSimpleAsyncThreadFunc"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the io priority of the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_error"
              c:identifier="g_simple_async_result_set_error"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets an error within the asynchronous result without a #GError.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GQuark (usually #G_IO_ERROR).</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">an error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">a formatted error reporting string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_error_va"
              c:identifier="g_simple_async_result_set_error_va"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets an error within the asynchronous result without a #GError.
Unless writing a binding, see g_simple_async_result_set_error().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GQuark (usually #G_IO_ERROR).</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">an error code.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">a formatted error reporting string.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:whitespace="preserve">va_list of arguments.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_error"
              c:identifier="g_simple_async_result_set_from_error">
        <doc xml:whitespace="preserve">Sets the result from a #GError.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GError.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handle_cancellation"
              c:identifier="g_simple_async_result_set_handle_cancellation">
        <doc xml:whitespace="preserve">Sets whether to handle cancellation within the asynchronous operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handle_cancellation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_op_res_gboolean"
              c:identifier="g_simple_async_result_set_op_res_gboolean">
        <doc xml:whitespace="preserve">Sets the operation result to a boolean within the asynchronous result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="op_res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_op_res_gpointer"
              c:identifier="g_simple_async_result_set_op_res_gpointer">
        <doc xml:whitespace="preserve">Sets the operation result within the asynchronous result to a pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="op_res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer result from an asynchronous function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_op_res"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">a #GDestroyNotify function.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_op_res_gssize"
              c:identifier="g_simple_async_result_set_op_res_gssize">
        <doc xml:whitespace="preserve">Sets the operation result within the asynchronous result to
the given @op_res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="op_res" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #gssize.</doc>
            <type name="glong" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="SimpleAsyncResultClass"
            c:type="GSimpleAsyncResultClass"
            disguised="1"
            glib:is-gtype-struct-for="SimpleAsyncResult">
    </record>
    <callback name="SimpleAsyncThreadFunc" c:type="GSimpleAsyncThreadFunc">
      <doc xml:whitespace="preserve">Simple thread function that runs an asynchronous operation and
checks for cancellation.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="res" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GSimpleAsyncResult.</doc>
          <type name="SimpleAsyncResult" c:type="GSimpleAsyncResult*"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GObject.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="SimplePermission"
           c:symbol-prefix="simple_permission"
           c:type="GSimplePermission"
           parent="Permission"
           glib:type-name="GSimplePermission"
           glib:get-type="g_simple_permission_get_type">
      <doc xml:whitespace="preserve">#GSimplePermission is an opaque data structure.  There are no methods
except for those defined by #GPermission.</doc>
      <constructor name="new"
                   c:identifier="g_simple_permission_new"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GPermission instance that represents an action that is
either always or never allowed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GSimplePermission, as a #GPermission</doc>
          <type name="Permission" c:type="GPermission*"/>
        </return-value>
        <parameters>
          <parameter name="allowed" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the action is allowed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <class name="Socket"
           c:symbol-prefix="socket"
           c:type="GSocket"
           version="2.22"
           parent="GObject.Object"
           glib:type-name="GSocket"
           glib:get-type="g_socket_get_type"
           glib:type-struct="SocketClass">
      <doc xml:whitespace="preserve">A lowlevel network socket object.</doc>
      <implements name="Initable"/>
      <constructor name="new"
                   c:identifier="g_socket_new"
                   version="2.22"
                   throws="1">
        <doc xml:whitespace="preserve">Creates a new #GSocket with the defined family, type and protocol.
If @protocol is 0 (%G_SOCKET_PROTOCOL_DEFAULT) the default protocol type
for the family and type is used.
The @protocol is a family and type specific int that specifies what
kind of protocol to use. #GSocketProtocol lists several common ones.
Many families only support one protocol, and use 0 for this, others
support several and using 0 means to use the default protocol for
the family and type.
The protocol id is passed directly to the operating
system, so you can use protocols not listed in #GSocketProtocol if you
know the protocol number used for it.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocket or %NULL on error.</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:whitespace="preserve">the socket family to use, e.g. %G_SOCKET_FAMILY_IPV4.</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the socket type to use.</doc>
            <type name="SocketType" c:type="GSocketType"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id of the protocol to use, or 0 for default.</doc>
            <type name="SocketProtocol" c:type="GSocketProtocol"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_fd"
                   c:identifier="g_socket_new_from_fd"
                   version="2.22"
                   throws="1">
        <doc xml:whitespace="preserve">Creates a new #GSocket from a native file descriptor
or winsock SOCKET handle.
This reads all the settings from the file descriptor so that
all properties should work. Note that the file descriptor
will be set to non-blocking mode, independent on the blocking
mode of the #GSocket.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocket or %NULL on error.</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a native socket file descriptor.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="accept"
              c:identifier="g_socket_accept"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Accept incoming connections on a connection-based socket. This removes
the first outstanding connection request from the listening socket and
creates a #GSocket object for it.
The @socket must be bound to a local address with g_socket_bind() and
must be listening for incoming connections (g_socket_listen()).
If there are no outstanding connections then the operation will block
or return %G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled.
To be notified of an incoming connection, wait for the %G_IO_IN condition.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSocket, or %NULL on error.</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind"
              c:identifier="g_socket_bind"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">When a socket is created it is attached to an address family, but it
doesn't have an address in this family. g_socket_bind() assigns the
address (sometimes called name) of the socket.
It is generally required to bind to a local address before you can
receive connections. (See g_socket_listen() and g_socket_accept() ).
In certain situations, you may also want to bind a socket that will be
used to initiate connections, though this is not normally required.
eventually call g_socket_accept() on), and %FALSE for client sockets.
(Specifically, if it is %TRUE, then g_socket_bind() will set the
%SO_REUSEADDR flag on the socket, allowing it to bind @address even if
that address was previously used by another socket that has not yet been
fully cleaned-up by the kernel. Failing to set this flag on a server
socket may cause the bind call to return %G_IO_ERROR_ADDRESS_IN_USE if
the server program is stopped and then immediately restarted.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketAddress specifying the local address.</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="allow_reuse" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to allow reusing this address</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_connect_result"
              c:identifier="g_socket_check_connect_result"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Checks and resets the pending connect error for the socket.
This is used to check for errors when g_socket_connect() is
used in non-blocking mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if no error, %FALSE otherwise, setting @error to the error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="close"
              c:identifier="g_socket_close"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Closes the socket, shutting down any active connection.
Closing a socket does not wait for all outstanding I/O operations
to finish, so the caller should not rely on them to be guaranteed
to complete even if the close returns with no error.
Once the socket is closed, all other operations will return
%G_IO_ERROR_CLOSED. Closing a socket multiple times will not
return an error.
Sockets will be automatically closed when the last reference
is dropped, but you might want to call this function to make sure
resources are released as early as possible.
Beware that due to the way that TCP works, it is possible for
recently-sent data to be lost if either you close a socket while the
%G_IO_IN condition is set, or else if the remote connection tries to
send something to you after you close the socket but before it has
finished reading all of the data you sent. There is no easy generic
way to avoid this problem; the easiest fix is to design the network
protocol such that the client will never send data "out of turn".
Another solution is for the server to half-close the connection by
calling g_socket_shutdown() with only the @shutdown_write flag set,
and then wait for the client to notice this and close its side of the
connection, after which the server can safely call g_socket_close().
(This is what #GTcpConnection does if you call
g_tcp_connection_set_graceful_disconnect(). But of course, this
only works if the client will close its connection after the server
does.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="condition_check"
              c:identifier="g_socket_condition_check"
              version="2.22">
        <doc xml:whitespace="preserve">Checks on the readiness of @socket to perform operations.
The operations specified in @condition are checked for and masked
against the currently-satisfied conditions on @socket. The result
is returned.
Note that on Windows, it is possible for an operation to return
%G_IO_ERROR_WOULD_BLOCK even immediately after
g_socket_condition_check() has claimed that the socket is ready for
writing. Rather than calling g_socket_condition_check() and then
writing to the socket if it succeeds, it is generally better to
simply try writing to the socket right away, and try again later if
the initial attempt returns %G_IO_ERROR_WOULD_BLOCK.
It is meaningless to specify %G_IO_ERR or %G_IO_HUP in condition;
these conditions will always be set in the output if they are true.
This call never blocks.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the @GIOCondition mask of the current state</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </return-value>
        <parameters>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GIOCondition mask to check</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
        </parameters>
      </method>
      <method name="condition_wait"
              c:identifier="g_socket_condition_wait"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Waits for @condition to become true on @socket. When the condition
is met, %TRUE is returned.
If @cancellable is cancelled before the condition is met, or if the
socket has a timeout set and it is reached before the condition is
met, then %FALSE is returned and @error, if non-%NULL, is set to
the appropriate value (%G_IO_ERROR_CANCELLED or
%G_IO_ERROR_TIMED_OUT).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the condition was met, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GIOCondition mask to wait for</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect"
              c:identifier="g_socket_connect"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Connect the socket to the specified remote address.
For connection oriented socket this generally means we attempt to make
a connection to the @address. For a connection-less socket it sets
the default address for g_socket_send() and discards all incoming datagrams
from other sources.
Generally connection oriented sockets can only connect once, but
connection-less sockets can connect multiple times to change the
default address.
If the connect call needs to do network I/O it will block, unless
non-blocking I/O is enabled. Then %G_IO_ERROR_PENDING is returned
and the user can be notified of the connection finishing by waiting
for the G_IO_OUT condition. The result of the connection can then be
checked with g_socket_check_connect_result().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if connected, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketAddress specifying the remote address.</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connection_factory_create_connection"
              c:identifier="g_socket_connection_factory_create_connection"
              version="2.22">
        <doc xml:whitespace="preserve">Creates a #GSocketConnection subclass of the right type for</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketConnection</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
      </method>
      <method name="create_source"
              c:identifier="g_socket_create_source"
              version="2.22"
              introspectable="0">
        <doc xml:whitespace="preserve">Creates a %GSource that can be attached to a %GMainContext to monitor
for the availibility of the specified @condition on the socket.
The callback on the source is of the #GSocketSourceFunc type.
It is meaningless to specify %G_IO_ERR or %G_IO_HUP in @condition;
these conditions will always be reported output if they are true.
cause the source to trigger, reporting the current condition (which
is likely 0 unless cancellation happened at the same time as a
condition change). You can check for this in the callback using
g_cancellable_is_cancelled().
If @socket has a timeout set, and it is reached before @condition
occurs, the source will then trigger anyway, reporting %G_IO_IN or
%G_IO_OUT depending on @condition. However, @socket will have been
marked as having had a timeout, and so the next #GSocket I/O method
you call will then fail with a %G_IO_ERROR_TIMED_OUT.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated %GSource, free with g_source_unref().</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <parameter name="condition" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GIOCondition mask to monitor</doc>
            <type name="GLib.IOCondition" c:type="GIOCondition"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_blocking"
              c:identifier="g_socket_get_blocking"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the blocking mode of the socket. For details on blocking I/O,
see g_socket_set_blocking().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if blocking I/O is used, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_credentials"
              c:identifier="g_socket_get_credentials"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Returns the credentials of the foreign process connected to this
socket, if any (e.g. it is only supported for %G_SOCKET_FAMILY_UNIX
sockets).
If this operation isn't supported on the OS, the method fails with
the %G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented
by reading the %SO_PEERCRED option on the underlying socket.
Other ways to obtain credentials from a foreign peer includes the
#GUnixCredentialsMessage type and
g_unix_connection_send_credentials() /
g_unix_connection_receive_credentials() functions.
that must be freed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">%NULL if @error is set, otherwise a #GCredentials object</doc>
          <type name="Credentials" c:type="GCredentials*"/>
        </return-value>
      </method>
      <method name="get_family"
              c:identifier="g_socket_get_family"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the socket family of the socket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GSocketFamily</doc>
          <type name="SocketFamily" c:type="GSocketFamily"/>
        </return-value>
      </method>
      <method name="get_fd" c:identifier="g_socket_get_fd" version="2.22">
        <doc xml:whitespace="preserve">Returns the underlying OS socket object. On unix this
is a socket file descriptor, and on windows this is
a Winsock2 SOCKET handle. This may be useful for
doing platform specific or otherwise unusual operations
on the socket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the file descriptor of the socket.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_keepalive"
              c:identifier="g_socket_get_keepalive"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the keepalive mode of the socket. For details on this,
see g_socket_set_keepalive().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if keepalive is active, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_listen_backlog"
              c:identifier="g_socket_get_listen_backlog"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the listen backlog setting of the socket. For details on this,
see g_socket_set_listen_backlog().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the maximum number of pending connections.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_local_address"
              c:identifier="g_socket_get_local_address"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Try to get the local address of a bound socket. This is only
useful if the socket has been bound to a local address,
either explicitly or implicitly when connecting.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketAddress or %NULL on error.</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
      </method>
      <method name="get_protocol"
              c:identifier="g_socket_get_protocol"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the socket protocol id the socket was created with.
In case the protocol is unknown, -1 is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a protocol id, or -1 if unknown</doc>
          <type name="SocketProtocol" c:type="GSocketProtocol"/>
        </return-value>
      </method>
      <method name="get_remote_address"
              c:identifier="g_socket_get_remote_address"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Try to get the remove address of a connected socket. This is only
useful for connection oriented sockets that have been connected.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketAddress or %NULL on error.</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
      </method>
      <method name="get_socket_type"
              c:identifier="g_socket_get_socket_type"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the socket type of the socket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GSocketType</doc>
          <type name="SocketType" c:type="GSocketType"/>
        </return-value>
      </method>
      <method name="get_timeout"
              c:identifier="g_socket_get_timeout"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the timeout setting of the socket. For details on this, see
g_socket_set_timeout().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the timeout in seconds</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="is_closed"
              c:identifier="g_socket_is_closed"
              version="2.22">
        <doc xml:whitespace="preserve">Checks whether a socket is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if socket is closed, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_connected"
              c:identifier="g_socket_is_connected"
              version="2.22">
        <doc xml:whitespace="preserve">Check whether the socket is connected. This is only useful for
connection-oriented sockets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if socket is connected, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="listen"
              c:identifier="g_socket_listen"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Marks the socket as a server socket, i.e. a socket that is used
to accept incoming requests using g_socket_accept().
Before calling this the socket must be bound to a local address using
g_socket_bind().
To set the maximum amount of outstanding clients, use
g_socket_set_listen_backlog().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="receive"
              c:identifier="g_socket_receive"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Receive data (up to @size bytes) from a socket. This is mainly used by
connection-oriented sockets; it is identical to g_socket_receive_from()
with @address set to %NULL.
For %G_SOCKET_TYPE_DATAGRAM and %G_SOCKET_TYPE_SEQPACKET sockets,
g_socket_receive() will always read either 0 or 1 complete messages from
the socket. If the received message is too large to fit in @buffer, then
the data beyond @size bytes will be discarded, without any explicit
indication that this has occurred.
For %G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any
number of bytes, up to @size. If more than @size bytes have been
received, the additional data will be returned in future calls to
g_socket_receive().
If the socket is in blocking mode the call will block until there is
some data to receive or there is an error. If there is no data available
and the socket is in non-blocking mode, a %G_IO_ERROR_WOULD_BLOCK error
will be returned. To be notified when data is available, wait for the
%G_IO_IN condition.
On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes read, or -1 on error</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffer to read data into (which should be at least @size bytes long).</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes you want to read from the socket</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_from"
              c:identifier="g_socket_receive_from"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Receive data (up to @size bytes) from a socket.
If @address is non-%NULL then @address will be set equal to the
source address of the received packet.
See g_socket_receive() for additional information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes read, or -1 on error</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a #GSocketAddress pointer, or %NULL</doc>
            <type name="SocketAddress" c:type="GSocketAddress**"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffer to read data into (which should be at least @size bytes long).</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes you want to read from the socket</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_message"
              c:identifier="g_socket_receive_message"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Receive data from a socket.  This is the most complicated and
fully-featured version of this call. For easier use, see
g_socket_receive() and g_socket_receive_from().
If @address is non-%NULL then @address will be set equal to the
source address of the received packet.
describe the buffers that received data will be scattered into.
If @num_vectors is -1, then @vectors is assumed to be terminated
by a #GInputVector with a %NULL buffer pointer.
As a special case, if @num_vectors is 0 (in which case, @vectors
may of course be %NULL), then a single byte is received and
discarded. This is to facilitate the common practice of sending a
single '\0' byte for the purposes of transferring ancillary data.
array of #GSocketControlMessage instances or %NULL if no such
messages was received. These correspond to the control messages
received from the kernel, one #GSocketControlMessage per message
from the kernel. This array is %NULL-terminated and must be freed
by the caller using g_free() after calling g_object_unref() on each
element. If @messages is %NULL, any control messages received will
be discarded.
messages received.
If both @messages and @num_messages are non-%NULL, then
for this are available in the #GSocketMsgFlags enum, but the
values there are the same as the system values, and the flags
are passed in as-is, so you can pass in system-specific flags too
(and g_socket_receive_message() may pass system-specific flags out).
As with g_socket_receive(), data may be discarded if @socket is
%G_SOCKET_TYPE_DATAGRAM or %G_SOCKET_TYPE_SEQPACKET and you do not
provide enough buffer space to read a complete message. You can pass
%G_SOCKET_MSG_PEEK in @flags to peek at the current message without
removing it from the receive queue, but there is no portable way to find
out the length of the message other than by reading it into a
sufficiently-large buffer.
If the socket is in blocking mode the call will block until there
is some data to receive or there is an error. If there is no data
available and the socket is in non-blocking mode, a
%G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when
data is available, wait for the %G_IO_IN condition.
On error -1 is returned and @error is set accordingly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes read, or -1 on error</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a #GSocketAddress pointer, or %NULL</doc>
            <type name="SocketAddress" c:type="GSocketAddress**"/>
          </parameter>
          <parameter name="vectors" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of #GInputVector structs</doc>
            <type name="InputVector" c:type="GInputVector*"/>
          </parameter>
          <parameter name="num_vectors" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of elements in @vectors, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer which may be filled with an array of #GSocketControlMessages, or %NULL</doc>
            <type name="SocketControlMessage"
                  c:type="GSocketControlMessage***"/>
          </parameter>
          <parameter name="num_messages" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer which will be filled with the number of elements in @messages, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to an int containing #GSocketMsgFlags flags</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_with_blocking"
              c:identifier="g_socket_receive_with_blocking"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">This behaves exactly the same as g_socket_receive(), except that
the choice of blocking or non-blocking behavior is determined by
the @blocking argument rather than by @socket's properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes read, or -1 on error</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffer to read data into (which should be at least @size bytes long).</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes you want to read from the socket</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="blocking" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to do blocking or non-blocking I/O</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send"
              c:identifier="g_socket_send"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Tries to send @size bytes from @buffer on the socket. This is
mainly used by connection-oriented sockets; it is identical to
g_socket_send_to() with @address set to %NULL.
If the socket is in blocking mode the call will block until there is
space for the data in the socket queue. If there is no space available
and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
will be returned. To be notified when space is available, wait for the
%G_IO_OUT condition. Note though that you may still receive
%G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
notified of a %G_IO_OUT condition. (On Windows in particular, this is
very common due to the way the underlying APIs work.)
On error -1 is returned and @error is set accordingly.
on error</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes written (which may be less than @size), or -1</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the buffer containing the data to send.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to send</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message"
              c:identifier="g_socket_send_message"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Send data to @address on @socket.  This is the most complicated and
fully-featured version of this call. For easier use, see
g_socket_send() and g_socket_send_to().
If @address is %NULL then the message is sent to the default receiver
(set by g_socket_connect()).
then @vectors is assumed to be terminated by a #GOutputVector with a
%NULL buffer pointer.) The #GOutputVector structs describe the buffers
that the sent data will be gathered from. Using multiple
#GOutputVector&lt;!-- --&gt;s is more memory-efficient than manually copying
data from multiple sources into a single buffer, and more
network-efficient than making multiple calls to g_socket_send().
#GSocketControlMessage instances. These correspond to the control
messages to be sent on the socket.
If @num_messages is -1 then @messages is treated as a %NULL-terminated
array.
for this are available in the #GSocketMsgFlags enum, but the
values there are the same as the system values, and the flags
are passed in as-is, so you can pass in system-specific flags too.
If the socket is in blocking mode the call will block until there is
space for the data in the socket queue. If there is no space available
and the socket is in non-blocking mode a %G_IO_ERROR_WOULD_BLOCK error
will be returned. To be notified when space is available, wait for the
%G_IO_OUT condition. Note though that you may still receive
%G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
notified of a %G_IO_OUT condition. (On Windows in particular, this is
very common due to the way the underlying APIs work.)
On error -1 is returned and @error is set accordingly.
on error</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes written (which may be less than @size), or -1</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketAddress, or %NULL</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="vectors" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of #GOutputVector structs</doc>
            <type name="OutputVector" c:type="GOutputVector*"/>
          </parameter>
          <parameter name="num_vectors" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of elements in @vectors, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to an array of #GSocketControlMessages, or %NULL.</doc>
            <type name="SocketControlMessage"
                  c:type="GSocketControlMessage**"/>
          </parameter>
          <parameter name="num_messages" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of elements in @messages, or -1.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">an int containing #GSocketMsgFlags flags</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_to"
              c:identifier="g_socket_send_to"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Tries to send @size bytes from @buffer to @address. If @address is
%NULL then the message is sent to the default receiver (set by
g_socket_connect()).
See g_socket_send() for additional information.
on error</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes written (which may be less than @size), or -1</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketAddress, or %NULL</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the buffer containing the data to send.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to send</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_with_blocking"
              c:identifier="g_socket_send_with_blocking"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">This behaves exactly the same as g_socket_send(), except that
the choice of blocking or non-blocking behavior is determined by
the @blocking argument rather than by @socket's properties.
on error</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of bytes written (which may be less than @size), or -1</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the buffer containing the data to send.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to send</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="blocking" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to do blocking or non-blocking I/O</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a %GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blocking"
              c:identifier="g_socket_set_blocking"
              version="2.22">
        <doc xml:whitespace="preserve">Sets the blocking mode of the socket. In blocking mode
all operations block until they succeed or there is an error. In
non-blocking mode all functions return results immediately or
with a %G_IO_ERROR_WOULD_BLOCK error.
All sockets are created in blocking mode. However, note that the
platform level socket is always non-blocking, and blocking mode
is a GSocket level feature.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="blocking" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether to use blocking I/O or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_keepalive"
              c:identifier="g_socket_set_keepalive"
              version="2.22">
        <doc xml:whitespace="preserve">Sets or unsets the %SO_KEEPALIVE flag on the underlying socket. When
this flag is set on a socket, the system will attempt to verify that the
remote socket endpoint is still present if a sufficiently long period of
time passes with no data being exchanged. If the system is unable to
verify the presence of the remote endpoint, it will automatically close
the connection.
This option is only functional on certain kinds of sockets. (Notably,
%G_SOCKET_PROTOCOL_TCP sockets.)
The exact time between pings is system- and protocol-dependent, but will
normally be at least two hours. Most commonly, you would set this flag
on a server socket if you want to allow clients to remain idle for long
periods of time, but also want to ensure that connections are eventually
garbage-collected if clients crash or become unreachable.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="keepalive" transfer-ownership="none">
            <doc xml:whitespace="preserve">Value for the keepalive flag</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_listen_backlog"
              c:identifier="g_socket_set_listen_backlog"
              version="2.22">
        <doc xml:whitespace="preserve">Sets the maximum number of outstanding connections allowed
when listening on this socket. If more clients than this are
connecting to the socket and the application is not handling them
on time then the new connections will be refused.
Note that this must be called before g_socket_listen() and has no
effect if called after that.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="backlog" transfer-ownership="none">
            <doc xml:whitespace="preserve">the maximum number of pending connections.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_timeout"
              c:identifier="g_socket_set_timeout"
              version="2.26">
        <doc xml:whitespace="preserve">Sets the time in seconds after which I/O operations on @socket will
time out if they have not yet completed.
On a blocking socket, this means that any blocking #GSocket
operation will time out after @timeout seconds of inactivity,
returning %G_IO_ERROR_TIMED_OUT.
On a non-blocking socket, calls to g_socket_condition_wait() will
also fail with %G_IO_ERROR_TIMED_OUT after the given time. Sources
created with g_socket_create_source() will trigger after
set, at which point calling g_socket_receive(), g_socket_send(),
g_socket_check_connect_result(), etc, will fail with
%G_IO_ERROR_TIMED_OUT.
If @timeout is 0 (the default), operations will never time out
on their own.
Note that if an I/O operation is interrupted by a signal, this may
cause the timeout to be reset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout for @socket, in seconds, or 0 for none</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="shutdown"
              c:identifier="g_socket_shutdown"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Shut down part of a full-duplex connection.
If @shutdown_read is %TRUE then the recieving side of the connection
is shut down, and further reading is disallowed.
If @shutdown_write is %TRUE then the sending side of the connection
is shut down, and further writing is disallowed.
It is allowed for both @shutdown_read and @shutdown_write to be %TRUE.
One example where this is used is graceful disconnect for TCP connections
where you close the sending side, then wait for the other side to close
the connection, thus ensuring that the other side saw all sent data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="shutdown_read" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to shut down the read side</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="shutdown_write" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to shut down the write side</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="speaks_ipv4"
              c:identifier="g_socket_speaks_ipv4"
              version="2.22">
        <doc xml:whitespace="preserve">Checks if a socket is capable of speaking IPv4.
IPv4 sockets are capable of speaking IPv4.  On some operating systems
and under some combinations of circumstances IPv6 sockets are also
capable of speaking IPv4.  See RFC 3493 section 3.7 for more
information.
No other types of sockets are currently considered as being capable
of speaking IPv4.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this socket can be used with IPv4.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="blocking" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="family"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="SocketFamily"/>
      </property>
      <property name="fd"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint"/>
      </property>
      <property name="keepalive" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="listen-backlog" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <property name="local-address" transfer-ownership="none">
        <type name="SocketAddress"/>
      </property>
      <property name="protocol"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="SocketProtocol"/>
      </property>
      <property name="remote-address" transfer-ownership="none">
        <type name="SocketAddress"/>
      </property>
      <property name="timeout"
                version="2.26"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The timeout in seconds on socket I/O</doc>
        <type name="guint"/>
      </property>
      <property name="type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="SocketType"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SocketPrivate" c:type="GSocketPrivate*"/>
      </field>
    </class>
    <class name="SocketAddress"
           c:symbol-prefix="socket_address"
           c:type="GSocketAddress"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GSocketAddress"
           glib:get-type="g_socket_address_get_type"
           glib:type-struct="SocketAddressClass">
      <doc xml:whitespace="preserve">A socket endpoint address, corresponding to &lt;type&gt;struct sockaddr&lt;/type&gt;
or one of its subtypes.</doc>
      <implements name="SocketConnectable"/>
      <constructor name="new_from_native"
                   c:identifier="g_socket_address_new_from_native"
                   version="2.22">
        <doc xml:whitespace="preserve">Creates a #GSocketAddress subclass corresponding to the native
&lt;type&gt;struct sockaddr&lt;/type&gt; @native.
otherwise %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSocketAddress if @native could successfully be converted,</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="native" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a &lt;type&gt;struct sockaddr&lt;/type&gt;</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the memory location pointed to by @native</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="get_family" invoker="get_family" version="2.22">
        <doc xml:whitespace="preserve">Gets the socket family type of @address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the socket family type of @address.</doc>
          <type name="SocketFamily" c:type="GSocketFamily"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_native_size"
                      invoker="get_native_size"
                      version="2.22">
        <doc xml:whitespace="preserve">Gets the size of @address's native &lt;type&gt;struct sockaddr&lt;/type&gt;.
You can use this to allocate memory to pass to
g_socket_address_to_native().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the native &lt;type&gt;struct sockaddr&lt;/type&gt; that</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
      </virtual-method>
      <virtual-method name="to_native"
                      invoker="to_native"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Converts a #GSocketAddress to a native &lt;type&gt;struct
sockaddr&lt;/type&gt;, which can be passed to low-level functions like
connect() or bind().
If not enough space is availible, a %G_IO_ERROR_NO_SPACE error is
returned. If the address type is not known on the system
then a %G_IO_ERROR_NOT_SUPPORTED error is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @dest was filled in, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a memory location that will contain the native &lt;type&gt;struct sockaddr&lt;/type&gt;.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destlen" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of @dest. Must be at least as large as g_socket_address_get_native_size().</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_family"
              c:identifier="g_socket_address_get_family"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the socket family type of @address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the socket family type of @address.</doc>
          <type name="SocketFamily" c:type="GSocketFamily"/>
        </return-value>
      </method>
      <method name="get_native_size"
              c:identifier="g_socket_address_get_native_size"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the size of @address's native &lt;type&gt;struct sockaddr&lt;/type&gt;.
You can use this to allocate memory to pass to
g_socket_address_to_native().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the native &lt;type&gt;struct sockaddr&lt;/type&gt; that</doc>
          <type name="glong" c:type="gssize"/>
        </return-value>
      </method>
      <method name="to_native"
              c:identifier="g_socket_address_to_native"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Converts a #GSocketAddress to a native &lt;type&gt;struct
sockaddr&lt;/type&gt;, which can be passed to low-level functions like
connect() or bind().
If not enough space is availible, a %G_IO_ERROR_NO_SPACE error is
returned. If the address type is not known on the system
then a %G_IO_ERROR_NOT_SUPPORTED error is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @dest was filled in, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a memory location that will contain the native &lt;type&gt;struct sockaddr&lt;/type&gt;.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destlen" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of @dest. Must be at least as large as g_socket_address_get_native_size().</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <property name="family" transfer-ownership="none">
        <type name="SocketFamily"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="SocketAddressClass"
            c:type="GSocketAddressClass"
            glib:is-gtype-struct-for="SocketAddress">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_family">
        <callback name="get_family">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the socket family type of @address.</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </return-value>
          <parameters>
            <parameter name="address" transfer-ownership="none">
              <type name="SocketAddress" c:type="GSocketAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_native_size">
        <callback name="get_native_size">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the native &lt;type&gt;struct sockaddr&lt;/type&gt; that</doc>
            <type name="glong" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="address" transfer-ownership="none">
              <type name="SocketAddress" c:type="GSocketAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="to_native">
        <callback name="to_native" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if @dest was filled in, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="address" transfer-ownership="none">
              <type name="SocketAddress" c:type="GSocketAddress*"/>
            </parameter>
            <parameter name="dest" transfer-ownership="none">
              <doc xml:whitespace="preserve">a pointer to a memory location that will contain the native &lt;type&gt;struct sockaddr&lt;/type&gt;.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="destlen" transfer-ownership="none">
              <doc xml:whitespace="preserve">the size of @dest. Must be at least as large as g_socket_address_get_native_size().</doc>
              <type name="gulong" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="SocketAddressEnumerator"
           c:symbol-prefix="socket_address_enumerator"
           c:type="GSocketAddressEnumerator"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GSocketAddressEnumerator"
           glib:get-type="g_socket_address_enumerator_get_type"
           glib:type-struct="SocketAddressEnumeratorClass">
      <doc xml:whitespace="preserve">Enumerator type for objects that contain or generate
#GSocketAddress&lt;!-- --&gt;es.</doc>
      <virtual-method name="next" invoker="next" throws="1">
        <doc xml:whitespace="preserve">Retrieves the next #GSocketAddress from @enumerator. Note that this
may block for some amount of time. (Eg, a #GNetworkAddress may need
to do a DNS lookup before it can return an address.) Use
g_socket_address_enumerator_next_async() if you need to avoid
blocking.
If @enumerator is expected to yield addresses, but for some reason
is unable to (eg, because of a DNS error), then the first call to
g_socket_address_enumerator_next() will return an appropriate error
in *@error. However, if the first call to
g_socket_address_enumerator_next() succeeds, then any further
internal errors (other than @cancellable being triggered) will be
ignored.
error (in which case *@error will be set) or if there are no
more addresses.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketAddress (owned by the caller), or %NULL on</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_async" invoker="next_async">
        <doc xml:whitespace="preserve">Asynchronously retrieves the next #GSocketAddress from @enumerator
and then calls @callback, which must call
g_socket_address_enumerator_next_finish() to get the result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_finish" invoker="next_finish" throws="1">
        <doc xml:whitespace="preserve">Retrieves the result of a completed call to
g_socket_address_enumerator_next_async(). See
g_socket_address_enumerator_next() for more information about
error handling.
error (in which case *@error will be set) or if there are no
more addresses.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketAddress (owned by the caller), or %NULL on</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="next"
              c:identifier="g_socket_address_enumerator_next"
              throws="1">
        <doc xml:whitespace="preserve">Retrieves the next #GSocketAddress from @enumerator. Note that this
may block for some amount of time. (Eg, a #GNetworkAddress may need
to do a DNS lookup before it can return an address.) Use
g_socket_address_enumerator_next_async() if you need to avoid
blocking.
If @enumerator is expected to yield addresses, but for some reason
is unable to (eg, because of a DNS error), then the first call to
g_socket_address_enumerator_next() will return an appropriate error
in *@error. However, if the first call to
g_socket_address_enumerator_next() succeeds, then any further
internal errors (other than @cancellable being triggered) will be
ignored.
error (in which case *@error will be set) or if there are no
more addresses.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketAddress (owned by the caller), or %NULL on</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_async"
              c:identifier="g_socket_address_enumerator_next_async">
        <doc xml:whitespace="preserve">Asynchronously retrieves the next #GSocketAddress from @enumerator
and then calls @callback, which must call
g_socket_address_enumerator_next_finish() to get the result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_finish"
              c:identifier="g_socket_address_enumerator_next_finish"
              throws="1">
        <doc xml:whitespace="preserve">Retrieves the result of a completed call to
g_socket_address_enumerator_next_async(). See
g_socket_address_enumerator_next() for more information about
error handling.
error (in which case *@error will be set) or if there are no
more addresses.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketAddress (owned by the caller), or %NULL on</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="SocketAddressEnumeratorClass"
            c:type="GSocketAddressEnumeratorClass"
            glib:is-gtype-struct-for="SocketAddressEnumerator">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="next">
        <callback name="next" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GSocketAddress (owned by the caller), or %NULL on</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <type name="SocketAddressEnumerator"
                    c:type="GSocketAddressEnumerator*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next_async">
        <callback name="next_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <type name="SocketAddressEnumerator"
                    c:type="GSocketAddressEnumerator*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="3">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:whitespace="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next_finish">
        <callback name="next_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GSocketAddress (owned by the caller), or %NULL on</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <type name="SocketAddressEnumerator"
                    c:type="GSocketAddressEnumerator*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="SocketClass"
            c:type="GSocketClass"
            glib:is-gtype-struct-for="Socket">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved8" introspectable="0">
        <callback name="_g_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved9" introspectable="0">
        <callback name="_g_reserved9">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved10" introspectable="0">
        <callback name="_g_reserved10">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="SocketClient"
           c:symbol-prefix="socket_client"
           c:type="GSocketClient"
           version="2.22"
           parent="GObject.Object"
           glib:type-name="GSocketClient"
           glib:get-type="g_socket_client_get_type"
           glib:type-struct="SocketClientClass">
      <doc xml:whitespace="preserve">A helper class for network servers to listen for and accept connections.</doc>
      <constructor name="new"
                   c:identifier="g_socket_client_new"
                   version="2.22">
        <doc xml:whitespace="preserve">Creates a new #GSocketClient with the default options.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketClient.</doc>
          <type name="SocketClient" c:type="GSocketClient*"/>
        </return-value>
      </constructor>
      <method name="add_application_proxy"
              c:identifier="g_socket_client_add_application_proxy">
        <doc xml:whitespace="preserve">Enable proxy protocols to be handled by the application. When the
indicated proxy protocol is returned by the #GProxyResolver,
#GSocketClient will consider this protocol as supported but will
not try find a #GProxy instance to handle handshaking. The
application must check for this case by calling
g_socket_connection_get_remote_address() on the returned
#GSocketConnection, and seeing if it's a #GProxyAddress of the
appropriate type, to determine whether or not it needs to handle
the proxy handshaking itself.
This should be used for proxy protocols that are dialects of
another protocol such as HTTP proxy. It also allows cohabitation of
proxy protocols that are reused between protocols. A good example
is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also
be use as generic socket proxy through the HTTP CONNECT method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">The proxy protocol</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect"
              c:identifier="g_socket_client_connect"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Tries to resolve the @connectable and make a network connection to it..
Upon a successful connection, a new #GSocketConnection is constructed
and returned.  The caller owns this new object and must drop their
reference to it when finished with it.
The type of the #GSocketConnection object returned depends on the type of
the underlying socket that is used. For instance, for a TCP/IP connection
it will be a #GTcpConnection.
The socket created will be the same family as the the address that the
or indirectly via g_socket_client_set_local_address(). The socket type
defaults to %G_SOCKET_TYPE_STREAM but can be set with
g_socket_client_set_socket_type().
If a local address is specified with g_socket_client_set_local_address() the
socket will be bound to this address before connecting.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="connectable" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketConnectable specifying the remote address.</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_async"
              c:identifier="g_socket_client_connect_async"
              version="2.22">
        <doc xml:whitespace="preserve">This is the asynchronous version of g_socket_client_connect().
When the operation is finished @callback will be
called. You can then call g_socket_client_connect_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connectable" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketConnectable specifying the remote address.</doc>
            <type name="SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_finish"
              c:identifier="g_socket_client_connect_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async connect operation. See g_socket_client_connect_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_host"
              c:identifier="g_socket_client_connect_to_host"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">This is a helper function for g_socket_client_connect().
Attempts to create a TCP connection to the named host.
address, an IPv4 address, or a domain name (in which case a DNS
lookup is performed).  Quoting with [] is supported for all address
types.  A port override may be specified in the usual way with a
colon.  Ports may be given as decimal numbers or symbolic names (in
which case an /etc/services lookup is performed).
If no port override is given in @host_and_port then @default_port will be
used as the port number to connect to.
In general, @host_and_port is expected to be provided by the user (allowing
them to give the hostname, and a port overide if necessary) and
In the case that an IP address is given, a single connection
attempt is made.  In the case that a name is given, multiple
connection attempts may be made, in turn and according to the
number of address records in DNS, until a connection succeeds.
Upon a successful connection, a new #GSocketConnection is constructed
and returned.  The caller owns this new object and must drop their
reference to it when finished with it.
In the event of any failure (DNS error, service not found, no hosts
connectable) %NULL is returned and @error (if non-%NULL) is set
accordingly.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="host_and_port" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name and optionally port of the host to connect to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:whitespace="preserve">the default port to connect to</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_host_async"
              c:identifier="g_socket_client_connect_to_host_async"
              version="2.22">
        <doc xml:whitespace="preserve">This is the asynchronous version of g_socket_client_connect_to_host().
When the operation is finished @callback will be
called. You can then call g_socket_client_connect_to_host_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="host_and_port" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name and optionally the port of the host to connect to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:whitespace="preserve">the default port to connect to</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_host_finish"
              c:identifier="g_socket_client_connect_to_host_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async connect operation. See g_socket_client_connect_to_host_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_service"
              c:identifier="g_socket_client_connect_to_service"
              throws="1">
        <doc xml:whitespace="preserve">Attempts to create a TCP connection to a service.
This call looks up the SRV record for @service at @domain for the
"tcp" protocol.  It then attempts to connect, in turn, to each of
the hosts providing the service until either a connection succeeds
or there are no hosts remaining.
Upon a successful connection, a new #GSocketConnection is constructed
and returned.  The caller owns this new object and must drop their
reference to it when finished with it.
In the event of any failure (DNS error, service not found, no hosts
connectable) %NULL is returned and @error (if non-%NULL) is set
accordingly.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketConnection if successful, or %NULL on error</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">a domain name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the service to connect to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_service_async"
              c:identifier="g_socket_client_connect_to_service_async"
              version="2.22">
        <doc xml:whitespace="preserve">This is the asynchronous version of
g_socket_client_connect_to_service().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">a domain name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the service to connect to</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_service_finish"
              c:identifier="g_socket_client_connect_to_service_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async connect operation. See g_socket_client_connect_to_service_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_uri"
              c:identifier="g_socket_client_connect_to_uri"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">This is a helper function for g_socket_client_connect().
Attempts to create a TCP connection with a network URI.
component. If a port is not specified in the URI, @default_port
will be used.
Using this rather than g_socket_client_connect() or
g_socket_client_connect_to_host() allows #GSocketClient to
determine when to use application-specific proxy protocols.
Upon a successful connection, a new #GSocketConnection is constructed
and returned.  The caller owns this new object and must drop their
reference to it when finished with it.
In the event of any failure (DNS error, service not found, no hosts
connectable) %NULL is returned and @error (if non-%NULL) is set
accordingly.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">A network URI</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:whitespace="preserve">the default port to connect to</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_uri_async"
              c:identifier="g_socket_client_connect_to_uri_async"
              version="2.26">
        <doc xml:whitespace="preserve">This is the asynchronous version of g_socket_client_connect_to_uri().
When the operation is finished @callback will be
called. You can then call g_socket_client_connect_to_uri_finish() to get
the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">a network uri</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="default_port" transfer-ownership="none">
            <doc xml:whitespace="preserve">the default port to connect to</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to_uri_finish"
              c:identifier="g_socket_client_connect_to_uri_finish"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async connect operation. See g_socket_client_connect_to_uri_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_enable_proxy"
              c:identifier="g_socket_client_get_enable_proxy"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the proxy enable state; see g_socket_client_set_enable_proxy()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether proxying is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_family"
              c:identifier="g_socket_client_get_family"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the socket family of the socket client.
See g_socket_client_set_family() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GSocketFamily</doc>
          <type name="SocketFamily" c:type="GSocketFamily"/>
        </return-value>
      </method>
      <method name="get_local_address"
              c:identifier="g_socket_client_get_local_address"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the local address of the socket client.
See g_socket_client_set_local_address() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GSocketAddres or %NULL. don't free</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
      </method>
      <method name="get_protocol"
              c:identifier="g_socket_client_get_protocol"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the protocol name type of the socket client.
See g_socket_client_set_protocol() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GSocketProtocol</doc>
          <type name="SocketProtocol" c:type="GSocketProtocol"/>
        </return-value>
      </method>
      <method name="get_socket_type"
              c:identifier="g_socket_client_get_socket_type"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the socket type of the socket client.
See g_socket_client_set_socket_type() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GSocketFamily</doc>
          <type name="SocketType" c:type="GSocketType"/>
        </return-value>
      </method>
      <method name="get_timeout"
              c:identifier="g_socket_client_get_timeout"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the I/O timeout time for sockets created by @client.
See g_socket_client_set_timeout() for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the timeout in seconds</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="set_enable_proxy"
              c:identifier="g_socket_client_set_enable_proxy"
              version="2.26">
        <doc xml:whitespace="preserve">Sets whether or not @client attempts to make connections via a
proxy server. When enabled (the default), #GSocketClient will use a
#GProxyResolver to determine if a proxy protocol such as SOCKS is
needed, and automatically do the necessary proxy negotiation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to enable proxies</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_family"
              c:identifier="g_socket_client_set_family"
              version="2.22">
        <doc xml:whitespace="preserve">Sets the socket family of the socket client.
If this is set to something other than %G_SOCKET_FAMILY_INVALID
then the sockets created by this object will be of the specified
family.
This might be useful for instance if you want to force the local
connection to be an ipv4 socket, even though the address might
be an ipv6 mapped to ipv4 address.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketFamily</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_local_address"
              c:identifier="g_socket_client_set_local_address"
              version="2.22">
        <doc xml:whitespace="preserve">Sets the local address of the socket client.
The sockets created by this object will bound to the
specified address (if not %NULL) before connecting.
This is useful if you want to ensure the the local
side of the connection is on a specific port, or on
a specific interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketAddress, or %NULL</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_protocol"
              c:identifier="g_socket_client_set_protocol"
              version="2.22">
        <doc xml:whitespace="preserve">Sets the protocol of the socket client.
The sockets created by this object will use of the specified
protocol.
If @protocol is %0 that means to use the default
protocol for the socket family and type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketProtocol</doc>
            <type name="SocketProtocol" c:type="GSocketProtocol"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_socket_type"
              c:identifier="g_socket_client_set_socket_type"
              version="2.22">
        <doc xml:whitespace="preserve">Sets the socket type of the socket client.
The sockets created by this object will be of the specified
type.
It doesn't make sense to specify a type of %G_SOCKET_TYPE_DATAGRAM,
as GSocketClient is used for connection oriented services.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketType</doc>
            <type name="SocketType" c:type="GSocketType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_timeout"
              c:identifier="g_socket_client_set_timeout"
              version="2.26">
        <doc xml:whitespace="preserve">Sets the I/O timeout for sockets created by @client. @timeout is a
time in seconds, or 0 for no timeout (the default).
The timeout value affects the initial connection attempt as well,
so setting this may cause calls to g_socket_client_connect(), etc,
to fail with %G_IO_ERROR_TIMED_OUT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <property name="enable-proxy"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="family"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="SocketFamily"/>
      </property>
      <property name="local-address"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="SocketAddress"/>
      </property>
      <property name="protocol"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="SocketProtocol"/>
      </property>
      <property name="timeout"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint"/>
      </property>
      <property name="type"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="SocketType"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SocketClientPrivate" c:type="GSocketClientPrivate*"/>
      </field>
    </class>
    <record name="SocketClientClass"
            c:type="GSocketClientClass"
            glib:is-gtype-struct-for="SocketClient">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="SocketClientPrivate"
            c:type="GSocketClientPrivate"
            disguised="1">
    </record>
    <interface name="SocketConnectable"
               c:symbol-prefix="socket_connectable"
               c:type="GSocketConnectable"
               glib:type-name="GSocketConnectable"
               glib:get-type="g_socket_connectable_get_type"
               glib:type-struct="SocketConnectableIface">
      <doc xml:whitespace="preserve">Interface for objects that contain or generate #GSocketAddress&lt;!-- --&gt;es.</doc>
      <virtual-method name="enumerate" invoker="enumerate" version="2.22">
        <doc xml:whitespace="preserve">Creates a #GSocketAddressEnumerator for @connectable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSocketAddressEnumerator.</doc>
          <type name="SocketAddressEnumerator"
                c:type="GSocketAddressEnumerator*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="proxy_enumerate"
                      invoker="proxy_enumerate"
                      version="2.26">
        <doc xml:whitespace="preserve">Creates a #GSocketAddressEnumerator for @connectable that will
return #GProxyAddress&lt;!-- --&gt;es for addresses that you must connect
to via a proxy.
If @connectable does not implement
g_socket_connectable_proxy_enumerate(), this will fall back to
calling g_socket_connectable_enumerate().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSocketAddressEnumerator.</doc>
          <type name="SocketAddressEnumerator"
                c:type="GSocketAddressEnumerator*"/>
        </return-value>
      </virtual-method>
      <method name="enumerate"
              c:identifier="g_socket_connectable_enumerate"
              version="2.22">
        <doc xml:whitespace="preserve">Creates a #GSocketAddressEnumerator for @connectable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSocketAddressEnumerator.</doc>
          <type name="SocketAddressEnumerator"
                c:type="GSocketAddressEnumerator*"/>
        </return-value>
      </method>
      <method name="proxy_enumerate"
              c:identifier="g_socket_connectable_proxy_enumerate"
              version="2.26">
        <doc xml:whitespace="preserve">Creates a #GSocketAddressEnumerator for @connectable that will
return #GProxyAddress&lt;!-- --&gt;es for addresses that you must connect
to via a proxy.
If @connectable does not implement
g_socket_connectable_proxy_enumerate(), this will fall back to
calling g_socket_connectable_enumerate().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSocketAddressEnumerator.</doc>
          <type name="SocketAddressEnumerator"
                c:type="GSocketAddressEnumerator*"/>
        </return-value>
      </method>
    </interface>
    <record name="SocketConnectableIface"
            c:type="GSocketConnectableIface"
            glib:is-gtype-struct-for="SocketConnectable">
      <doc xml:whitespace="preserve">Provides an interface for returning a #GSocketAddressEnumerator
and #GProxyAddressEnumerator</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="enumerate">
        <callback name="enumerate">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a new #GSocketAddressEnumerator.</doc>
            <type name="SocketAddressEnumerator"
                  c:type="GSocketAddressEnumerator*"/>
          </return-value>
          <parameters>
            <parameter name="connectable" transfer-ownership="none">
              <type name="SocketConnectable" c:type="GSocketConnectable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="proxy_enumerate">
        <callback name="proxy_enumerate">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a new #GSocketAddressEnumerator.</doc>
            <type name="SocketAddressEnumerator"
                  c:type="GSocketAddressEnumerator*"/>
          </return-value>
          <parameters>
            <parameter name="connectable" transfer-ownership="none">
              <type name="SocketConnectable" c:type="GSocketConnectable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="SocketConnection"
           c:symbol-prefix="socket_connection"
           c:type="GSocketConnection"
           version="2.22"
           parent="IOStream"
           glib:type-name="GSocketConnection"
           glib:get-type="g_socket_connection_get_type"
           glib:type-struct="SocketConnectionClass">
      <doc xml:whitespace="preserve">A socket connection GIOStream object for connection-oriented sockets.</doc>
      <function name="factory_lookup_type"
                c:identifier="g_socket_connection_factory_lookup_type"
                version="2.22">
        <doc xml:whitespace="preserve">Looks up the #GType to be used when creating socket connections on
sockets with the specified @family,@type and @protocol_id.
If no type is registered, the #GSocketConnection base type is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="family" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketFamily</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketType</doc>
            <type name="SocketType" c:type="GSocketType"/>
          </parameter>
          <parameter name="protocol_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">a protocol id</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="factory_register_type"
                c:identifier="g_socket_connection_factory_register_type"
                version="2.22">
        <doc xml:whitespace="preserve">Looks up the #GType to be used when creating socket connections on
sockets with the specified @family,@type and @protocol.
If no type is registered, the #GSocketConnection base type is returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GType, inheriting from %G_TYPE_SOCKET_CONNECTION</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="family" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketFamily</doc>
            <type name="SocketFamily" c:type="GSocketFamily"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketType</doc>
            <type name="SocketType" c:type="GSocketType"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">a protocol id</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_local_address"
              c:identifier="g_socket_connection_get_local_address"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Try to get the local address of a socket connection.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketAddress or %NULL on error.</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
      </method>
      <method name="get_remote_address"
              c:identifier="g_socket_connection_get_remote_address"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Try to get the remote address of a socket connection.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketAddress or %NULL on error.</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
      </method>
      <method name="get_socket"
              c:identifier="g_socket_connection_get_socket"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the underlying #GSocket object of the connection.
This can be useful if you want to do something unusual on it
not supported by the #GSocketConnection APIs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GSocketAddress or %NULL on error.</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
      </method>
      <property name="socket"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Socket"/>
      </property>
      <field name="parent_instance">
        <type name="IOStream" c:type="GIOStream"/>
      </field>
      <field name="priv">
        <type name="SocketConnectionPrivate"
              c:type="GSocketConnectionPrivate*"/>
      </field>
    </class>
    <record name="SocketConnectionClass"
            c:type="GSocketConnectionClass"
            glib:is-gtype-struct-for="SocketConnection">
      <field name="parent_class">
        <type name="IOStreamClass" c:type="GIOStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="SocketConnectionPrivate"
            c:type="GSocketConnectionPrivate"
            disguised="1">
    </record>
    <class name="SocketControlMessage"
           c:symbol-prefix="socket_control_message"
           c:type="GSocketControlMessage"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GSocketControlMessage"
           glib:get-type="g_socket_control_message_get_type"
           glib:type-struct="SocketControlMessageClass">
      <doc xml:whitespace="preserve">Base class for socket-type specific control messages that can be sent and
received over #GSocket.</doc>
      <function name="deserialize"
                c:identifier="g_socket_control_message_deserialize"
                version="2.22">
        <doc xml:whitespace="preserve">Tries to deserialize a socket control message of a given
of #GSocketControlMessage if they can understand this kind
of message and if so deserialize it into a #GSocketControlMessage.
If there is no implementation for this kind of control message, %NULL
will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the deserialized message or %NULL</doc>
          <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
        </return-value>
        <parameters>
          <parameter name="level" transfer-ownership="none">
            <doc xml:whitespace="preserve">a socket level</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a socket control message type for the given @level</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the data in bytes</doc>
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to the message data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="get_level" invoker="get_level" version="2.22">
        <doc xml:whitespace="preserve">Returns the "level" (i.e. the originating protocol) of the control message.
This is often SOL_SOCKET.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an integer describing the level</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_size" invoker="get_size" version="2.22">
        <doc xml:whitespace="preserve">Returns the space required for the control message, not including
headers or alignment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of bytes required.</doc>
          <type name="gulong" c:type="gsize"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_type">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </virtual-method>
      <virtual-method name="serialize" invoker="serialize" version="2.22">
        <doc xml:whitespace="preserve">Converts the data in the message to bytes placed in the
message.
returned by g_socket_control_message_get_size() on this
object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">A buffer to write data to</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_level"
              c:identifier="g_socket_control_message_get_level"
              version="2.22">
        <doc xml:whitespace="preserve">Returns the "level" (i.e. the originating protocol) of the control message.
This is often SOL_SOCKET.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an integer describing the level</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_msg_type"
              c:identifier="g_socket_control_message_get_msg_type"
              version="2.22">
        <doc xml:whitespace="preserve">Returns the protocol specific type of the control message.
For instance, for UNIX fd passing this would be SCM_RIGHTS.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an integer describing the type of control message</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_size"
              c:identifier="g_socket_control_message_get_size"
              version="2.22">
        <doc xml:whitespace="preserve">Returns the space required for the control message, not including
headers or alignment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of bytes required.</doc>
          <type name="gulong" c:type="gsize"/>
        </return-value>
      </method>
      <method name="serialize"
              c:identifier="g_socket_control_message_serialize"
              version="2.22">
        <doc xml:whitespace="preserve">Converts the data in the message to bytes placed in the
message.
returned by g_socket_control_message_get_size() on this
object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">A buffer to write data to</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SocketControlMessagePrivate"
              c:type="GSocketControlMessagePrivate*"/>
      </field>
    </class>
    <record name="SocketControlMessageClass"
            c:type="GSocketControlMessageClass"
            glib:is-gtype-struct-for="SocketControlMessage">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_size">
        <callback name="get_size">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of bytes required.</doc>
            <type name="gulong" c:type="gsize"/>
          </return-value>
          <parameters>
            <parameter name="message" transfer-ownership="none">
              <type name="SocketControlMessage"
                    c:type="GSocketControlMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_level">
        <callback name="get_level">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">an integer describing the level</doc>
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="message" transfer-ownership="none">
              <type name="SocketControlMessage"
                    c:type="GSocketControlMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_type">
        <callback name="get_type">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="message" transfer-ownership="none">
              <type name="SocketControlMessage"
                    c:type="GSocketControlMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="serialize">
        <callback name="serialize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="message" transfer-ownership="none">
              <type name="SocketControlMessage"
                    c:type="GSocketControlMessage*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <doc xml:whitespace="preserve">A buffer to write data to</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="deserialize" introspectable="0">
        <callback name="deserialize" introspectable="0">
          <return-value>
            <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
          </return-value>
          <parameters>
            <parameter name="level" transfer-ownership="none">
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gulong" c:type="gsize"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="SocketControlMessagePrivate"
            c:type="GSocketControlMessagePrivate"
            disguised="1">
    </record>
    <enumeration name="SocketFamily"
                 version="2.22"
                 glib:type-name="GSocketFamily"
                 glib:get-type="g_socket_family_get_type"
                 c:type="GSocketFamily">
      <doc xml:whitespace="preserve">The protocol family of a #GSocketAddress. (These values are
identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
if available.)</doc>
      <member name="invalid"
              value="0"
              c:identifier="G_SOCKET_FAMILY_INVALID"
              glib:nick="invalid"/>
      <member name="unix"
              value="1"
              c:identifier="G_SOCKET_FAMILY_UNIX"
              glib:nick="unix"/>
      <member name="ipv4"
              value="2"
              c:identifier="G_SOCKET_FAMILY_IPV4"
              glib:nick="ipv4"/>
      <member name="ipv6"
              value="10"
              c:identifier="G_SOCKET_FAMILY_IPV6"
              glib:nick="ipv6"/>
    </enumeration>
    <class name="SocketListener"
           c:symbol-prefix="socket_listener"
           c:type="GSocketListener"
           parent="GObject.Object"
           glib:type-name="GSocketListener"
           glib:get-type="g_socket_listener_get_type"
           glib:type-struct="SocketListenerClass">
      <constructor name="new"
                   c:identifier="g_socket_listener_new"
                   version="2.22">
        <doc xml:whitespace="preserve">Creates a new #GSocketListener with no sockets to listen for.
New listeners can be added with e.g. g_socket_listener_add_address()
or g_socket_listener_add_inet_port().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSocketListener.</doc>
          <type name="SocketListener" c:type="GSocketListener*"/>
        </return-value>
      </constructor>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <method name="accept"
              c:identifier="g_socket_listener_accept"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Blocks waiting for a client to connect to any of the sockets added
to the listener. Returns a #GSocketConnection for the socket that was
accepted.
If @source_object is not %NULL it will be filled out with the source
object specified when the corresponding socket or address was added
to the listener.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="source_object"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">location where #GObject pointer will be stored, or %NULL</doc>
            <type name="GObject.Object" c:type="GObject**"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_async"
              c:identifier="g_socket_listener_accept_async"
              version="2.22">
        <doc xml:whitespace="preserve">This is the asynchronous version of g_socket_listener_accept().
When the operation is finished @callback will be
called. You can then call g_socket_listener_accept_socket()
to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_finish"
              c:identifier="g_socket_listener_accept_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async accept operation. See g_socket_listener_accept_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocketConnection on success, %NULL on error.</doc>
          <type name="SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject**"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_socket"
              c:identifier="g_socket_listener_accept_socket"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Blocks waiting for a client to connect to any of the sockets added
to the listener. Returns the #GSocket that was accepted.
If you want to accept the high-level #GSocketConnection, not a #GSocket,
which is often the case, then you should use g_socket_listener_accept()
instead.
If @source_object is not %NULL it will be filled out with the source
object specified when the corresponding socket or address was added
to the listener.
If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocket on success, %NULL on error.</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <parameter name="source_object"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">location where #GObject pointer will be stored, or %NULL.</doc>
            <type name="GObject.Object" c:type="GObject**"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_socket_async"
              c:identifier="g_socket_listener_accept_socket_async"
              version="2.22">
        <doc xml:whitespace="preserve">This is the asynchronous version of g_socket_listener_accept_socket().
When the operation is finished @callback will be
called. You can then call g_socket_listener_accept_socket_finish()
to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_socket_finish"
              c:identifier="g_socket_listener_accept_socket_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async accept operation. See g_socket_listener_accept_socket_async()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSocket on success, %NULL on error.</doc>
          <type name="Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject**"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_address"
              c:identifier="g_socket_listener_add_address"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Creates a socket of type @type and protocol @protocol, binds
it to @address and adds it to the set of sockets we're accepting
sockets from.
Note that adding an IPv6 address, depending on the platform,
may or may not result in a listener that also accepts IPv4
connections.  For more determinstic behaviour, see
g_socket_listener_add_inet_port().
to accept to identify this particular source, which is
useful if you're listening on multiple addresses and do
different things depending on what address is connected to.
If successful and @effective_address is non-%NULL then it will
be set to the address that the binding actually occured at.  This
is helpful for determining the port number that was used for when
requested, belongs to the caller and must be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketAddress</doc>
            <type name="SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketType</doc>
            <type name="SocketType" c:type="GSocketType"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSocketProtocol</doc>
            <type name="SocketProtocol" c:type="GSocketProtocol"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="effective_address"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location to store the address that was bound to, or %NULL.</doc>
            <type name="SocketAddress" c:type="GSocketAddress**"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_any_inet_port"
              c:identifier="g_socket_listener_add_any_inet_port"
              version="2.24"
              throws="1">
        <doc xml:whitespace="preserve">Listens for TCP connections on any available port number for both
IPv6 and IPv4 (if each are available).
This is useful if you need to have a socket for incoming connections
but don't care about the specific port number.
to accept to identify this particular source, which is
useful if you're listening on multiple addresses and do
different things depending on what address is connected to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the port number, or 0 in case of failure.</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_inet_port"
              c:identifier="g_socket_listener_add_inet_port"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Helper function for g_socket_listener_add_address() that
creates a TCP/IP socket listening on IPv4 and IPv6 (if
supported) on the specified port on all interfaces.
to accept to identify this particular source, which is
useful if you're listening on multiple addresses and do
different things depending on what address is connected to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="port" transfer-ownership="none">
            <doc xml:whitespace="preserve">an IP port number (non-zero)</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_socket"
              c:identifier="g_socket_listener_add_socket"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Adds @socket to the set of sockets that we try to accept
new clients from. The socket must be bound to a local
address and listened to.
to accept to identify this particular source, which is
useful if you're listening on multiple addresses and do
different things depending on what address is connected to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="socket" transfer-ownership="none">
            <doc xml:whitespace="preserve">a listening #GSocket</doc>
            <type name="Socket" c:type="GSocket*"/>
          </parameter>
          <parameter name="source_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional #GObject identifying this source</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close"
              c:identifier="g_socket_listener_close"
              version="2.22">
        <doc xml:whitespace="preserve">Closes all the sockets in the listener.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_backlog"
              c:identifier="g_socket_listener_set_backlog"
              version="2.22">
        <doc xml:whitespace="preserve">Sets the listen backlog on the sockets in the listener.
See g_socket_set_listen_backlog() for details</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="listen_backlog" transfer-ownership="none">
            <doc xml:whitespace="preserve">an integer</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <property name="listen-backlog"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SocketListenerPrivate" c:type="GSocketListenerPrivate*"/>
      </field>
    </class>
    <record name="SocketListenerClass"
            c:type="GSocketListenerClass"
            glib:is-gtype-struct-for="SocketListener">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="listener" transfer-ownership="none">
              <type name="SocketListener" c:type="GSocketListener*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="SocketListenerPrivate"
            c:type="GSocketListenerPrivate"
            disguised="1">
    </record>
    <enumeration name="SocketMsgFlags"
                 version="2.22"
                 glib:type-name="GSocketMsgFlags"
                 glib:get-type="g_socket_msg_flags_get_type"
                 c:type="GSocketMsgFlags">
      <doc xml:whitespace="preserve">Flags used in g_socket_receive_message() and g_socket_send_message().
The flags listed in the enum are some commonly available flags, but the
values used for them are the same as on the platform, and any other flags
are passed in/out as is. So to use a platform specific flag, just include
the right system header and pass in the flag.</doc>
      <member name="none"
              value="0"
              c:identifier="G_SOCKET_MSG_NONE"
              glib:nick="none"/>
      <member name="oob"
              value="1"
              c:identifier="G_SOCKET_MSG_OOB"
              glib:nick="oob"/>
      <member name="peek"
              value="2"
              c:identifier="G_SOCKET_MSG_PEEK"
              glib:nick="peek"/>
      <member name="dontroute"
              value="4"
              c:identifier="G_SOCKET_MSG_DONTROUTE"
              glib:nick="dontroute"/>
    </enumeration>
    <record name="SocketPrivate" c:type="GSocketPrivate" disguised="1">
    </record>
    <enumeration name="SocketProtocol"
                 version="2.22"
                 glib:type-name="GSocketProtocol"
                 glib:get-type="g_socket_protocol_get_type"
                 c:type="GSocketProtocol">
      <doc xml:whitespace="preserve">A protocol identifier is specified when creating a #GSocket, which is a
family/type specific identifier, where 0 means the default protocol for
the particular family/type.
This enum contains a set of commonly available and used protocols. You
can also pass any other identifiers handled by the platform in order to
use protocols not listed here.</doc>
      <member name="unknown"
              value="-1"
              c:identifier="G_SOCKET_PROTOCOL_UNKNOWN"
              glib:nick="unknown"/>
      <member name="default"
              value="0"
              c:identifier="G_SOCKET_PROTOCOL_DEFAULT"
              glib:nick="default"/>
      <member name="tcp"
              value="6"
              c:identifier="G_SOCKET_PROTOCOL_TCP"
              glib:nick="tcp"/>
      <member name="udp"
              value="17"
              c:identifier="G_SOCKET_PROTOCOL_UDP"
              glib:nick="udp"/>
      <member name="sctp"
              value="132"
              c:identifier="G_SOCKET_PROTOCOL_SCTP"
              glib:nick="sctp"/>
    </enumeration>
    <class name="SocketService"
           c:symbol-prefix="socket_service"
           c:type="GSocketService"
           version="2.22"
           parent="SocketListener"
           glib:type-name="GSocketService"
           glib:get-type="g_socket_service_get_type"
           glib:type-struct="SocketServiceClass">
      <doc xml:whitespace="preserve">A helper class for handling accepting incomming connections in the
glib mainloop.</doc>
      <constructor name="new"
                   c:identifier="g_socket_service_new"
                   version="2.22">
        <doc xml:whitespace="preserve">Creates a new #GSocketService with no sockets to listen for.
New listeners can be added with e.g. g_socket_listener_add_address()
or g_socket_listener_add_inet_port().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSocketService.</doc>
          <type name="SocketService" c:type="GSocketService*"/>
        </return-value>
      </constructor>
      <method name="is_active"
              c:identifier="g_socket_service_is_active"
              version="2.22">
        <doc xml:whitespace="preserve">Check whether the service is active or not. An active
service will accept new clients that connect, while
a non-active service will let connecting clients queue
up until the service is started.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the service is active, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="start"
              c:identifier="g_socket_service_start"
              version="2.22">
        <doc xml:whitespace="preserve">Starts the service, i.e. start accepting connections
from the added sockets when the mainloop runs.
This call is threadsafe, so it may be called from a thread
handling an incomming client request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="stop" c:identifier="g_socket_service_stop" version="2.22">
        <doc xml:whitespace="preserve">Stops the service, i.e. stops accepting connections
from the added sockets when the mainloop runs.
This call is threadsafe, so it may be called from a thread
handling an incomming client request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <field name="parent_instance">
        <type name="SocketListener" c:type="GSocketListener"/>
      </field>
      <field name="priv">
        <type name="SocketServicePrivate" c:type="GSocketServicePrivate*"/>
      </field>
      <glib:signal name="incoming" version="2.22">
        <doc xml:whitespace="preserve">The ::incoming signal is emitted when a new incoming connection
to @service needs to be handled. The handler must initiate the
handling of @connection, but may not block; in essence,
asynchronous operations must be used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE to stop other handlers from being called</doc>
          <type name="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new #GSocketConnection object.</doc>
            <type name="SocketConnection"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source_object passed to g_socket_listener_add_address().</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SocketServiceClass"
            c:type="GSocketServiceClass"
            glib:is-gtype-struct-for="SocketService">
      <field name="parent_class">
        <type name="SocketListenerClass" c:type="GSocketListenerClass"/>
      </field>
      <field name="incoming">
        <callback name="incoming">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <type name="SocketService" c:type="GSocketService*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="SocketConnection" c:type="GSocketConnection*"/>
            </parameter>
            <parameter name="source_object" transfer-ownership="none">
              <type name="GObject.Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="SocketServicePrivate"
            c:type="GSocketServicePrivate"
            disguised="1">
    </record>
    <callback name="SocketSourceFunc"
              c:type="GSocketSourceFunc"
              version="2.22">
      <doc xml:whitespace="preserve">This is the function type of the callback used for the #GSource
returned by g_socket_create_source().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">it should return %FALSE if the source should be removed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="socket" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GSocket</doc>
          <type name="Socket" c:type="GSocket*"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:whitespace="preserve">the current condition at the source fired.</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">data passed in by the user.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SocketType"
                 version="2.22"
                 glib:type-name="GSocketType"
                 glib:get-type="g_socket_type_get_type"
                 c:type="GSocketType">
      <doc xml:whitespace="preserve">Flags used when creating a #GSocket. Some protocols may not implement
all the socket types.</doc>
      <member name="invalid"
              value="0"
              c:identifier="G_SOCKET_TYPE_INVALID"
              glib:nick="invalid"/>
      <member name="stream"
              value="1"
              c:identifier="G_SOCKET_TYPE_STREAM"
              glib:nick="stream"/>
      <member name="datagram"
              value="2"
              c:identifier="G_SOCKET_TYPE_DATAGRAM"
              glib:nick="datagram"/>
      <member name="seqpacket"
              value="3"
              c:identifier="G_SOCKET_TYPE_SEQPACKET"
              glib:nick="seqpacket"/>
    </enumeration>
    <record name="SrvTarget"
            c:type="GSrvTarget"
            glib:type-name="GSrvTarget"
            glib:get-type="g_srv_target_get_type"
            c:symbol-prefix="srv_target">
      <doc xml:whitespace="preserve">A single target host/port that a network service is running on.</doc>
      <constructor name="new" c:identifier="g_srv_target_new" version="2.22">
        <doc xml:whitespace="preserve">Creates a new #GSrvTarget with the given parameters.
You should not need to use this; normally #GSrvTarget&lt;!-- --&gt;s are
created by #GResolver.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSrvTarget.</doc>
          <type name="SrvTarget" c:type="GSrvTarget*"/>
        </return-value>
        <parameters>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the host that the service is running on</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:whitespace="preserve">the port that the service is running on</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target's priority</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="weight" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target's weight</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="g_srv_target_copy" version="2.22">
        <doc xml:whitespace="preserve">Copies @target</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a copy of @target</doc>
          <type name="SrvTarget" c:type="GSrvTarget*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="g_srv_target_free" version="2.22">
        <doc xml:whitespace="preserve">Frees @target</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_hostname"
              c:identifier="g_srv_target_get_hostname"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @target's hostname (in ASCII form; if you are going to present
this to the user, you should use g_hostname_is_ascii_encoded() to
check if it contains encoded Unicode segments, and use
g_hostname_to_unicode() to convert it if it does.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@target's hostname</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_port"
              c:identifier="g_srv_target_get_port"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @target's port</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@target's port</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
      </method>
      <method name="get_priority"
              c:identifier="g_srv_target_get_priority"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @target's priority. You should not need to look at this;
#GResolver already sorts the targets according to the algorithm in
RFC 2782.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@target's priority</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
      </method>
      <method name="get_weight"
              c:identifier="g_srv_target_get_weight"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @target's weight. You should not need to look at this;
#GResolver already sorts the targets according to the algorithm in
RFC 2782.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@target's weight</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
      </method>
    </record>
    <class name="TcpConnection"
           c:symbol-prefix="tcp_connection"
           c:type="GTcpConnection"
           version="2.22"
           parent="SocketConnection"
           glib:type-name="GTcpConnection"
           glib:get-type="g_tcp_connection_get_type"
           glib:type-struct="TcpConnectionClass">
      <doc xml:whitespace="preserve">A #GSocketConnection for UNIX domain socket connections.</doc>
      <method name="get_graceful_disconnect"
              c:identifier="g_tcp_connection_get_graceful_disconnect"
              version="2.22">
        <doc xml:whitespace="preserve">Checks if graceful disconnects are used. See
g_tcp_connection_set_graceful_disconnect().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if graceful disconnect is used on close, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_graceful_disconnect"
              c:identifier="g_tcp_connection_set_graceful_disconnect"
              version="2.22">
        <doc xml:whitespace="preserve">This enabled graceful disconnects on close. A graceful disconnect
means that we signal the recieving end that the connection is terminated
and wait for it to close the connection before closing the connection.
A graceful disconnect means that we can be sure that we successfully sent
all the outstanding data to the other end, or get an error reported.
However, it also means we have to wait for all the data to reach the
other side and for it to acknowledge this by closing the socket, which may
take a while. For this reason it is disabled by default.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="graceful_disconnect" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether to do graceful disconnects or not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="graceful-disconnect"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="SocketConnection" c:type="GSocketConnection"/>
      </field>
      <field name="priv">
        <type name="TcpConnectionPrivate" c:type="GTcpConnectionPrivate*"/>
      </field>
    </class>
    <record name="TcpConnectionClass"
            c:type="GTcpConnectionClass"
            glib:is-gtype-struct-for="TcpConnection">
      <field name="parent_class">
        <type name="SocketConnectionClass" c:type="GSocketConnectionClass"/>
      </field>
    </record>
    <record name="TcpConnectionPrivate"
            c:type="GTcpConnectionPrivate"
            disguised="1">
    </record>
    <class name="ThemedIcon"
           c:symbol-prefix="themed_icon"
           c:type="GThemedIcon"
           parent="GObject.Object"
           glib:type-name="GThemedIcon"
           glib:get-type="g_themed_icon_get_type"
           glib:type-struct="ThemedIconClass">
      <doc xml:whitespace="preserve">An implementation of #GIcon for themed icons.</doc>
      <implements name="Icon"/>
      <function name="new" c:identifier="g_themed_icon_new">
        <doc xml:whitespace="preserve">Creates a new themed icon for @iconname.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GThemedIcon.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="iconname" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing an icon name.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_names"
                c:identifier="g_themed_icon_new_from_names">
        <doc xml:whitespace="preserve">Creates a new themed icon for @iconnames.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GThemedIcon</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="iconnames" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of strings containing icon names.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of the @iconnames array, or -1 if @iconnames is %NULL-terminated</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_with_default_fallbacks"
                c:identifier="g_themed_icon_new_with_default_fallbacks">
        <doc xml:whitespace="preserve">Creates a new themed icon for @iconname, and all the names
that can be created by shortening @iconname at '-' characters.
In the following example, @icon1 and @icon2 are equivalent:
|[
const char *names[] = {
"gnome-dev-cdrom-audio",
"gnome-dev-cdrom",
"gnome-dev",
"gnome"
};
icon1 = g_themed_icon_new_from_names (names, 4);
icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GThemedIcon.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <parameter name="iconname" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing an icon name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <method name="append_name" c:identifier="g_themed_icon_append_name">
        <doc xml:whitespace="preserve">Append a name to the list of icons from within @icon.
&lt;note&gt;&lt;para&gt;
Note that doing so invalidates the hash computed by prior calls
to g_icon_hash().
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iconname" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of icon to append to list of icons from within @icon.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_names" c:identifier="g_themed_icon_get_names">
        <doc xml:whitespace="preserve">Gets the names of icons from within @icon.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a list of icon names.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="prepend_name"
              c:identifier="g_themed_icon_prepend_name"
              version="2.18">
        <doc xml:whitespace="preserve">Prepend a name to the list of icons from within @icon.
&lt;note&gt;&lt;para&gt;
Note that doing so invalidates the hash computed by prior calls
to g_icon_hash().
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iconname" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of icon to prepend to list of icons from within @icon.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="name"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The icon name.</doc>
        <type name="utf8"/>
      </property>
      <property name="names"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A %NULL-terminated array of icon names.</doc>
        <type/>
      </property>
      <property name="use-default-fallbacks"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether to use the default fallbacks found by shortening the icon name
at '-' characters. If the "names" array has more than one element,
ignores any past the first.
For example, if the icon name was "gnome-dev-cdrom-audio", the array
would become
|[
{
"gnome-dev-cdrom-audio",
"gnome-dev-cdrom",
"gnome-dev",
"gnome",
NULL
};
]|</doc>
        <type name="gboolean"/>
      </property>
    </class>
    <record name="ThemedIconClass"
            c:type="GThemedIconClass"
            disguised="1"
            glib:is-gtype-struct-for="ThemedIcon">
    </record>
    <class name="ThreadedSocketService"
           c:symbol-prefix="threaded_socket_service"
           c:type="GThreadedSocketService"
           version="2.22"
           parent="SocketService"
           glib:type-name="GThreadedSocketService"
           glib:get-type="g_threaded_socket_service_get_type"
           glib:type-struct="ThreadedSocketServiceClass">
      <doc xml:whitespace="preserve">A helper class for handling accepting incomming connections in the
glib mainloop and handling them in a thread.</doc>
      <constructor name="new"
                   c:identifier="g_threaded_socket_service_new"
                   version="2.22">
        <doc xml:whitespace="preserve">Creates a new #GThreadedSocketService with no listeners. Listeners
must be added with g_socket_service_add_listeners().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GSocketService.</doc>
          <type name="SocketService" c:type="GSocketService*"/>
        </return-value>
        <parameters>
          <parameter name="max_threads" transfer-ownership="none">
            <doc xml:whitespace="preserve">the maximal number of threads to execute concurrently handling incoming clients, -1 means no limit</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="max-threads"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint"/>
      </property>
      <field name="parent_instance">
        <type name="SocketService" c:type="GSocketService"/>
      </field>
      <field name="priv">
        <type name="ThreadedSocketServicePrivate"
              c:type="GThreadedSocketServicePrivate*"/>
      </field>
      <glib:signal name="run">
        <doc xml:whitespace="preserve">The ::run signal is emitted in a worker thread in response to an
incoming connection. This thread is dedicated to handling
not return until the connection is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE to stope further signal handlers from being called</doc>
          <type name="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new #GSocketConnection object.</doc>
            <type name="SocketConnection"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source_object passed to g_socket_listener_add_address().</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ThreadedSocketServiceClass"
            c:type="GThreadedSocketServiceClass"
            glib:is-gtype-struct-for="ThreadedSocketService">
      <field name="parent_class">
        <type name="SocketServiceClass" c:type="GSocketServiceClass"/>
      </field>
      <field name="run">
        <callback name="run">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <type name="ThreadedSocketService"
                    c:type="GThreadedSocketService*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="SocketConnection" c:type="GSocketConnection*"/>
            </parameter>
            <parameter name="source_object" transfer-ownership="none">
              <type name="GObject.Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="ThreadedSocketServicePrivate"
            c:type="GThreadedSocketServicePrivate"
            disguised="1">
    </record>
    <class name="UnixConnection"
           c:symbol-prefix="unix_connection"
           c:type="GUnixConnection"
           parent="SocketConnection"
           glib:type-name="GUnixConnection"
           glib:get-type="g_unix_connection_get_type"
           glib:type-struct="UnixConnectionClass">
      <method name="receive_credentials"
              c:identifier="g_unix_connection_receive_credentials"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Receives credentials from the sending end of the connection.  The
sending end has to call g_unix_connection_send_credentials() (or
similar) for this to work.
As well as reading the credentials this also reads (and discards) a
single byte from the stream, as this is required for credentials
passing to work on some implementations.
Other ways to exchange credentials with a foreign peer includes the
#GUnixCredentialsMessage type and g_socket_get_credentials() function.
g_object_unref()), %NULL if @error is set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">Received credentials on success (free with</doc>
          <type name="Credentials" c:type="GCredentials*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive_fd"
              c:identifier="g_unix_connection_receive_fd"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Receives a file descriptor from the sending end of the connection.
The sending end has to call g_unix_connection_send_fd() for this
to work.
As well as reading the fd this also reads a single byte from the
stream, as this is required for fd passing to work on some
implementations.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a file descriptor on success, -1 on error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_credentials"
              c:identifier="g_unix_connection_send_credentials"
              version="2.26"
              throws="1">
        <doc xml:whitespace="preserve">Passes the credentials of the current user the receiving side
of the connection. The recieving end has to call
g_unix_connection_receive_credentials() (or similar) to accept the
credentials.
As well as sending the credentials this also writes a single NUL
byte to the stream, as this is required for credentials passing to
work on some implementations.
Other ways to exchange credentials with a foreign peer includes the
#GUnixCredentialsMessage type and g_socket_get_credentials() function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE if @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_fd"
              c:identifier="g_unix_connection_send_fd"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Passes a file descriptor to the recieving side of the
connection. The recieving end has to call g_unix_connection_receive_fd()
to accept the file descriptor.
As well as sending the fd this also writes a single byte to the
stream, as this is required for fd passing to work on some
implementations.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a %TRUE on success, %NULL on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="SocketConnection" c:type="GSocketConnection"/>
      </field>
      <field name="priv">
        <type name="UnixConnectionPrivate" c:type="GUnixConnectionPrivate*"/>
      </field>
    </class>
    <record name="UnixConnectionClass"
            c:type="GUnixConnectionClass"
            glib:is-gtype-struct-for="UnixConnection">
      <field name="parent_class">
        <type name="SocketConnectionClass" c:type="GSocketConnectionClass"/>
      </field>
    </record>
    <record name="UnixConnectionPrivate"
            c:type="GUnixConnectionPrivate"
            disguised="1">
    </record>
    <class name="UnixCredentialsMessage"
           c:symbol-prefix="unix_credentials_message"
           c:type="GUnixCredentialsMessage"
           version="2.26"
           parent="SocketControlMessage"
           glib:type-name="GUnixCredentialsMessage"
           glib:get-type="g_unix_credentials_message_get_type"
           glib:type-struct="UnixCredentialsMessageClass">
      <doc xml:whitespace="preserve">The #GUnixCredentialsMessage structure contains only private data
and should only be accessed using the provided API.</doc>
      <constructor name="new"
                   c:identifier="g_unix_credentials_message_new"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GUnixCredentialsMessage with credentials matching the current processes.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GUnixCredentialsMessage</doc>
          <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_credentials"
                   c:identifier="g_unix_credentials_message_new_with_credentials"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GUnixCredentialsMessage holding @credentials.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GUnixCredentialsMessage</doc>
          <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
        </return-value>
        <parameters>
          <parameter name="credentials" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GCredentials object.</doc>
            <type name="Credentials" c:type="GCredentials*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="is_supported"
                c:identifier="g_unix_credentials_message_is_supported"
                version="2.26">
        <doc xml:whitespace="preserve">Checks if passing a #GCredential on a #GSocket is supported on this platform.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if supported, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </function>
      <method name="get_credentials"
              c:identifier="g_unix_credentials_message_get_credentials"
              version="2.26">
        <doc xml:whitespace="preserve">Gets the credentials stored in @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GCredentials instance. Do not free, it is owned by @message.</doc>
          <type name="Credentials" c:type="GCredentials*"/>
        </return-value>
      </method>
      <property name="credentials"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The credentials stored in the message.</doc>
        <type name="Credentials"/>
      </property>
      <field name="parent_instance">
        <type name="SocketControlMessage" c:type="GSocketControlMessage"/>
      </field>
      <field name="priv">
        <type name="UnixCredentialsMessagePrivate"
              c:type="GUnixCredentialsMessagePrivate*"/>
      </field>
    </class>
    <record name="UnixCredentialsMessageClass"
            c:type="GUnixCredentialsMessageClass"
            glib:is-gtype-struct-for="UnixCredentialsMessage"
            version="2.26">
      <doc xml:whitespace="preserve">Class structure for #GUnixCredentialsMessage.</doc>
      <field name="parent_class">
        <type name="SocketControlMessageClass"
              c:type="GSocketControlMessageClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="UnixCredentialsMessagePrivate"
            c:type="GUnixCredentialsMessagePrivate"
            disguised="1">
    </record>
    <class name="UnixFDList"
           c:symbol-prefix="unix_fd_list"
           c:type="GUnixFDList"
           parent="GObject.Object"
           glib:type-name="GUnixFDList"
           glib:get-type="g_unix_fd_list_get_type"
           glib:type-struct="UnixFDListClass">
      <constructor name="new" c:identifier="g_unix_fd_list_new" version="2.24">
        <doc xml:whitespace="preserve">Creates a new #GUnixFDList containing no file descriptors.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GUnixFDList</doc>
          <type name="UnixFDList" c:type="GUnixFDList*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_array"
                   c:identifier="g_unix_fd_list_new_from_array"
                   version="2.24">
        <doc xml:whitespace="preserve">Creates a new #GUnixFDList containing the file descriptors given in
may no longer be used by the caller.  The array itself is owned by
the caller.
Each file descriptor in the array should be set to close-on-exec.
If @n_fds is -1 then @fds must be terminated with -1.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GUnixFDList</doc>
          <type name="UnixFDList" c:type="GUnixFDList*"/>
        </return-value>
        <parameters>
          <parameter name="fds" transfer-ownership="none">
            <doc xml:whitespace="preserve">the initial list of file descriptors</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="n_fds" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of #fds, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append"
              c:identifier="g_unix_fd_list_append"
              version="2.24"
              throws="1">
        <doc xml:whitespace="preserve">Adds a file descriptor to @list.
The file descriptor is duplicated using dup(). You keep your copy
of the descriptor and the copy contained in @list will be closed
when @list is finalized.
A possible cause of failure is exceeding the per-process or
system-wide file descriptor limit.
The index of the file descriptor in the list is returned.  If you use
this index with g_unix_fd_list_get() then you will receive back a
duplicated copy of the same file descriptor.
(and @error is set)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the index of the appended fd in case of success, else -1</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a valid open file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get"
              c:identifier="g_unix_fd_list_get"
              version="2.24"
              throws="1">
        <doc xml:whitespace="preserve">Gets a file descriptor out of @list.
programmer error for @index_ to be out of range; see
g_unix_fd_list_get_length().
The file descriptor is duplicated using dup() and set as
close-on-exec before being returned.  You must call close() on it
when you are done.
A possible cause of failure is exceeding the per-process or
system-wide file descriptor limit.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the file descriptor, or -1 in case of error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index into the list</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_length"
              c:identifier="g_unix_fd_list_get_length"
              version="2.24">
        <doc xml:whitespace="preserve">contained within).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of @list</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="peek_fds"
              c:identifier="g_unix_fd_list_peek_fds"
              version="2.24">
        <doc xml:whitespace="preserve">Returns the array of file descriptors that is contained in this
object.
After this call, the descriptors remain the property of @list.  The
caller must not close them and must not free the array.  The array is
valid only until @list is changed in any way.
If @length is non-%NULL then it is set to the number of file
descriptors in the returned array. The returned array is also
terminated with -1.
This function never returns %NULL. In case there are no file
descriptors contained in @list, an empty array is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of file descriptors</doc>
          <type name="gint" c:type="gint*"/>
        </return-value>
        <parameters>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to the length of the returned array, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_fds"
              c:identifier="g_unix_fd_list_steal_fds"
              version="2.24">
        <doc xml:whitespace="preserve">Returns the array of file descriptors that is contained in this
object.
After this call, the descriptors are no longer contained in
descriptors have been added).
The return result of this function must be freed with g_free().
The caller is also responsible for closing all of the file
descriptors.  The file descriptors in the array are set to
close-on-exec.
If @length is non-%NULL then it is set to the number of file
descriptors in the returned array. The returned array is also
terminated with -1.
This function never returns %NULL. In case there are no file
descriptors contained in @list, an empty array is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of file descriptors</doc>
          <type name="gint" c:type="gint*"/>
        </return-value>
        <parameters>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to the length of the returned array, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="UnixFDListPrivate" c:type="GUnixFDListPrivate*"/>
      </field>
    </class>
    <record name="UnixFDListClass"
            c:type="GUnixFDListClass"
            glib:is-gtype-struct-for="UnixFDList">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="UnixFDListPrivate" c:type="GUnixFDListPrivate" disguised="1">
    </record>
    <class name="UnixFDMessage"
           c:symbol-prefix="unix_fd_message"
           c:type="GUnixFDMessage"
           parent="SocketControlMessage"
           glib:type-name="GUnixFDMessage"
           glib:get-type="g_unix_fd_message_get_type"
           glib:type-struct="UnixFDMessageClass">
      <constructor name="new"
                   c:identifier="g_unix_fd_message_new"
                   version="2.22">
        <doc xml:whitespace="preserve">Creates a new #GUnixFDMessage containing an empty file descriptor
list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GUnixFDMessage</doc>
          <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_fd_list"
                   c:identifier="g_unix_fd_message_new_with_fd_list"
                   version="2.24">
        <doc xml:whitespace="preserve">Creates a new #GUnixFDMessage containing @list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GUnixFDMessage</doc>
          <type name="SocketControlMessage" c:type="GSocketControlMessage*"/>
        </return-value>
        <parameters>
          <parameter name="fd_list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GUnixFDList</doc>
            <type name="UnixFDList" c:type="GUnixFDList*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append_fd"
              c:identifier="g_unix_fd_message_append_fd"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Adds a file descriptor to @message.
The file descriptor is duplicated using dup(). You keep your copy
of the descriptor and the copy contained in @message will be closed
when @message is finalized.
A possible cause of failure is exceeding the per-process or
system-wide file descriptor limit.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE in case of success, else %FALSE (and @error is set)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a valid open file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fd_list"
              c:identifier="g_unix_fd_message_get_fd_list"
              version="2.24">
        <doc xml:whitespace="preserve">Gets the #GUnixFDList contained in @message.  This function does not
return a reference to the caller, but the returned list is valid for
the lifetime of @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GUnixFDList from @message</doc>
          <type name="UnixFDList" c:type="GUnixFDList*"/>
        </return-value>
      </method>
      <method name="steal_fds"
              c:identifier="g_unix_fd_message_steal_fds"
              version="2.22">
        <doc xml:whitespace="preserve">Returns the array of file descriptors that is contained in this
object.
After this call, the descriptors are no longer contained in
descriptors have been added).
The return result of this function must be freed with g_free().
The caller is also responsible for closing all of the file
descriptors.
If @length is non-%NULL then it is set to the number of file
descriptors in the returned array. The returned array is also
terminated with -1.
This function never returns %NULL. In case there are no file
descriptors contained in @message, an empty array is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of file descriptors</doc>
          <type name="gint" c:type="gint*"/>
        </return-value>
        <parameters>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to the length of the returned array, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <property name="fd-list"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="UnixFDList"/>
      </property>
      <field name="parent_instance">
        <type name="SocketControlMessage" c:type="GSocketControlMessage"/>
      </field>
      <field name="priv">
        <type name="UnixFDMessagePrivate" c:type="GUnixFDMessagePrivate*"/>
      </field>
    </class>
    <record name="UnixFDMessageClass"
            c:type="GUnixFDMessageClass"
            glib:is-gtype-struct-for="UnixFDMessage">
      <field name="parent_class">
        <type name="SocketControlMessageClass"
              c:type="GSocketControlMessageClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="UnixFDMessagePrivate"
            c:type="GUnixFDMessagePrivate"
            disguised="1">
    </record>
    <class name="UnixInputStream"
           c:symbol-prefix="unix_input_stream"
           c:type="GUnixInputStream"
           parent="InputStream"
           glib:type-name="GUnixInputStream"
           glib:get-type="g_unix_input_stream_get_type"
           glib:type-struct="UnixInputStreamClass">
      <doc xml:whitespace="preserve">Implements #GInputStream for reading from selectable unix file descriptors</doc>
      <constructor name="new" c:identifier="g_unix_input_stream_new">
        <doc xml:whitespace="preserve">Creates a new #GUnixInputStream for the given @fd.
If @close_fd is %TRUE, the file descriptor will be closed
when the stream is closed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GUnixInputStream</doc>
          <type name="InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a UNIX file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="close_fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to close the file descriptor when done</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_close_fd"
              c:identifier="g_unix_input_stream_get_close_fd"
              version="2.20">
        <doc xml:whitespace="preserve">Returns whether the file descriptor of @stream will be
closed when the stream is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file descriptor is closed when done</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_fd"
              c:identifier="g_unix_input_stream_get_fd"
              version="2.20">
        <doc xml:whitespace="preserve">Return the UNIX file descriptor that the stream reads from.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The file descriptor of @stream</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="set_close_fd"
              c:identifier="g_unix_input_stream_set_close_fd"
              version="2.20">
        <doc xml:whitespace="preserve">Sets whether the file descriptor of @stream shall be closed
when the stream is closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="close_fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to close the file descriptor when done</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="close-fd"
                version="2.20"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether to close the file descriptor when the stream is closed.</doc>
        <type name="gboolean"/>
      </property>
      <property name="fd"
                version="2.20"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The file descriptor that the stream reads from.</doc>
        <type name="gint"/>
      </property>
      <field name="parent_instance">
        <type name="InputStream" c:type="GInputStream"/>
      </field>
      <field name="priv">
        <type name="UnixInputStreamPrivate" c:type="GUnixInputStreamPrivate*"/>
      </field>
    </class>
    <record name="UnixInputStreamClass"
            c:type="GUnixInputStreamClass"
            glib:is-gtype-struct-for="UnixInputStream">
      <field name="parent_class">
        <type name="InputStreamClass" c:type="GInputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="UnixInputStreamPrivate"
            c:type="GUnixInputStreamPrivate"
            disguised="1">
    </record>
    <record name="UnixMountEntry" c:type="GUnixMountEntry" disguised="1">
      <doc xml:whitespace="preserve">Defines a Unix mount entry (e.g. &lt;filename&gt;/media/cdrom&lt;/filename&gt;).
This corresponds roughly to a mtab entry.</doc>
    </record>
    <class name="UnixMountMonitor"
           c:symbol-prefix="unix_mount_monitor"
           c:type="GUnixMountMonitor"
           parent="GObject.Object"
           glib:type-name="GUnixMountMonitor"
           glib:get-type="g_unix_mount_monitor_get_type"
           glib:type-struct="UnixMountMonitorClass">
      <doc xml:whitespace="preserve">Watches #GUnixMount&lt;!-- --&gt;s for changes.</doc>
      <constructor name="new" c:identifier="g_unix_mount_monitor_new">
        <doc xml:whitespace="preserve">Gets a new #GUnixMountMonitor. The default rate limit for which the
monitor will report consecutive changes for the mount and mount
point entry files is the default for a #GFileMonitor. Use
g_unix_mount_monitor_set_rate_limit() to change this.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GUnixMountMonitor.</doc>
          <type name="UnixMountMonitor" c:type="GUnixMountMonitor*"/>
        </return-value>
      </constructor>
      <method name="set_rate_limit"
              c:identifier="g_unix_mount_monitor_set_rate_limit"
              version="2.18">
        <doc xml:whitespace="preserve">Sets the rate limit to which the @mount_monitor will report
consecutive change events to the mount and mount point entry files.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="limit_msec" transfer-ownership="none">
            <doc xml:whitespace="preserve">a integer with the limit in milliseconds to poll for changes.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="mountpoints-changed">
        <doc xml:whitespace="preserve">Emitted when the unix mount points have changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="mounts-changed">
        <doc xml:whitespace="preserve">Emitted when the unix mounts have changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="UnixMountMonitorClass"
            c:type="GUnixMountMonitorClass"
            disguised="1"
            glib:is-gtype-struct-for="UnixMountMonitor">
    </record>
    <record name="UnixMountPoint" c:type="GUnixMountPoint" disguised="1">
      <doc xml:whitespace="preserve">Defines a Unix mount point (e.g. &lt;filename&gt;/dev&lt;/filename&gt;).
This corresponds roughly to a fstab entry.</doc>
      <method name="compare" c:identifier="g_unix_mount_point_compare">
        <doc xml:whitespace="preserve">Compares two unix mount points.
or less than @mount2, respectively.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">1, 0 or -1 if @mount1 is greater than, equal to,</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="mount2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GUnixMount.</doc>
            <type name="UnixMountPoint" c:type="GUnixMountPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_unix_mount_point_free">
        <doc xml:whitespace="preserve">Frees a unix mount point.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_device_path"
              c:identifier="g_unix_mount_point_get_device_path">
        <doc xml:whitespace="preserve">Gets the device path for a unix mount point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the device path.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_fs_type" c:identifier="g_unix_mount_point_get_fs_type">
        <doc xml:whitespace="preserve">Gets the file system type for the mount point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the file system type.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_mount_path"
              c:identifier="g_unix_mount_point_get_mount_path">
        <doc xml:whitespace="preserve">Gets the mount path for a unix mount point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the mount path.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="guess_can_eject"
              c:identifier="g_unix_mount_point_guess_can_eject">
        <doc xml:whitespace="preserve">Guesses whether a Unix mount point can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @mount_point is deemed to be ejectable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="guess_icon" c:identifier="g_unix_mount_point_guess_icon">
        <doc xml:whitespace="preserve">Guesses the icon of a Unix mount point.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIcon</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </method>
      <method name="guess_name" c:identifier="g_unix_mount_point_guess_name">
        <doc xml:whitespace="preserve">Guesses the name of a Unix mount point.
The result is a translated string.
be freed with g_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A newly allocated string that must</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="is_loopback" c:identifier="g_unix_mount_point_is_loopback">
        <doc xml:whitespace="preserve">Checks if a unix mount point is a loopback device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount point is a loopback. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_readonly" c:identifier="g_unix_mount_point_is_readonly">
        <doc xml:whitespace="preserve">Checks if a unix mount point is read only.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a mount point is read only.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_user_mountable"
              c:identifier="g_unix_mount_point_is_user_mountable">
        <doc xml:whitespace="preserve">Checks if a unix mount point is mountable by the user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the mount point is user mountable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </record>
    <class name="UnixOutputStream"
           c:symbol-prefix="unix_output_stream"
           c:type="GUnixOutputStream"
           parent="OutputStream"
           glib:type-name="GUnixOutputStream"
           glib:get-type="g_unix_output_stream_get_type"
           glib:type-struct="UnixOutputStreamClass">
      <doc xml:whitespace="preserve">Implements #GOutputStream for outputting to selectable unix file descriptors</doc>
      <constructor name="new" c:identifier="g_unix_output_stream_new">
        <doc xml:whitespace="preserve">Creates a new #GUnixOutputStream for the given @fd.
If @close_fd, is %TRUE, the file descriptor will be closed when
the output stream is destroyed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GOutputStream</doc>
          <type name="OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a UNIX file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="close_fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to close the file descriptor when done</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_close_fd"
              c:identifier="g_unix_output_stream_get_close_fd"
              version="2.20">
        <doc xml:whitespace="preserve">Returns whether the file descriptor of @stream will be
closed when the stream is closed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file descriptor is closed when done</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_fd"
              c:identifier="g_unix_output_stream_get_fd"
              version="2.20">
        <doc xml:whitespace="preserve">Return the UNIX file descriptor that the stream writes to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The file descriptor of @stream</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="set_close_fd"
              c:identifier="g_unix_output_stream_set_close_fd"
              version="2.20">
        <doc xml:whitespace="preserve">Sets whether the file descriptor of @stream shall be closed
when the stream is closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="close_fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to close the file descriptor when done</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="close-fd"
                version="2.20"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether to close the file descriptor when the stream is closed.</doc>
        <type name="gboolean"/>
      </property>
      <property name="fd"
                version="2.20"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The file descriptor that the stream writes to.</doc>
        <type name="gint"/>
      </property>
      <field name="parent_instance">
        <type name="OutputStream" c:type="GOutputStream"/>
      </field>
      <field name="priv">
        <type name="UnixOutputStreamPrivate"
              c:type="GUnixOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="UnixOutputStreamClass"
            c:type="GUnixOutputStreamClass"
            glib:is-gtype-struct-for="UnixOutputStream">
      <field name="parent_class">
        <type name="OutputStreamClass" c:type="GOutputStreamClass"/>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <record name="UnixOutputStreamPrivate"
            c:type="GUnixOutputStreamPrivate"
            disguised="1">
    </record>
    <class name="UnixSocketAddress"
           c:symbol-prefix="unix_socket_address"
           c:type="GUnixSocketAddress"
           parent="SocketAddress"
           glib:type-name="GUnixSocketAddress"
           glib:get-type="g_unix_socket_address_get_type"
           glib:type-struct="UnixSocketAddressClass">
      <doc xml:whitespace="preserve">A UNIX-domain (local) socket address, corresponding to a
&lt;type&gt;struct sockaddr_un&lt;/type&gt;.</doc>
      <implements name="SocketConnectable"/>
      <constructor name="new"
                   c:identifier="g_unix_socket_address_new"
                   version="2.22">
        <doc xml:whitespace="preserve">Creates a new #GUnixSocketAddress for @path.
To create abstract socket addresses, on systems that support that,
use g_unix_socket_address_new_abstract().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GUnixSocketAddress</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the socket path</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_abstract"
                   c:identifier="g_unix_socket_address_new_abstract"
                   deprecated="Use g_unix_socket_address_new_with_type().">
        <doc xml:whitespace="preserve">Creates a new %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED
#GUnixSocketAddress for @path.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GUnixSocketAddress</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the abstract name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="path_len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of @path, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_type"
                   c:identifier="g_unix_socket_address_new_with_type"
                   version="2.26">
        <doc xml:whitespace="preserve">Creates a new #GUnixSocketAddress of type @type with name @path.
If @type is %G_UNIX_SOCKET_ADDRESS_PATH, this is equivalent to
calling g_unix_socket_address_new().
If @path_type is %G_UNIX_SOCKET_ADDRESS_ABSTRACT, then @path_len
bytes of @path will be copied to the socket's path, and only those
bytes will be considered part of the name. (If @path_len is -1,
then @path is assumed to be NUL-terminated.) For example, if @path
was "test", then calling g_socket_address_get_native_size() on the
returned socket would return 7 (2 bytes of overhead, 1 byte for the
abstract-socket indicator byte, and 4 bytes for the name "test").
If @path_type is %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED, then
rest of the path will be padded with 0 bytes, and the entire
zero-padded buffer will be considered the name. (As above, if
this case, g_socket_address_get_native_size() will always return
the full size of a &lt;literal&gt;struct sockaddr_un&lt;/literal&gt;, although
g_unix_socket_address_get_path_len() will still return just the
length of @path.
%G_UNIX_SOCKET_ADDRESS_ABSTRACT is preferred over
%G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED for new programs. Of course,
when connecting to a server created by another process, you must
use the appropriate type corresponding to how that process created
its listening socket.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GUnixSocketAddress</doc>
          <type name="SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="path_len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of @path, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GUnixSocketAddressType</doc>
            <type name="UnixSocketAddressType"
                  c:type="GUnixSocketAddressType"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="abstract_names_supported"
                c:identifier="g_unix_socket_address_abstract_names_supported"
                version="2.22">
        <doc xml:whitespace="preserve">Checks if abstract unix domain socket names are supported.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if supported, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </function>
      <method name="get_address_type"
              c:identifier="g_unix_socket_address_get_address_type"
              version="2.26">
        <doc xml:whitespace="preserve">Gets @address's type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GUnixSocketAddressType</doc>
          <type name="UnixSocketAddressType" c:type="GUnixSocketAddressType"/>
        </return-value>
      </method>
      <method name="get_is_abstract"
              c:identifier="g_unix_socket_address_get_is_abstract"
              version="2.22"
              deprecated="Use g_unix_socket_address_get_address_type()">
        <doc xml:whitespace="preserve">Tests if @address is abstract.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the address is abstract, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_path"
              c:identifier="g_unix_socket_address_get_path"
              version="2.22">
        <doc xml:whitespace="preserve">Gets @address's path, or for abstract sockets the "name".
Guaranteed to be zero-terminated, but an abstract socket
may contain embedded zeros, and thus you should use
g_unix_socket_address_get_path_len() to get the true length
of this string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the path for @address</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_path_len"
              c:identifier="g_unix_socket_address_get_path_len"
              version="2.22">
        <doc xml:whitespace="preserve">Gets the length of @address's path.
For details, see g_unix_socket_address_get_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of the path</doc>
          <type name="gulong" c:type="gsize"/>
        </return-value>
      </method>
      <property name="abstract"
                deprecated="Use #GUnixSocketAddress:address-type, which"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether or not this is an abstract address
distinguishes between zero-padded and non-zero-padded
abstract addresses.</doc>
        <type name="gboolean"/>
      </property>
      <property name="address-type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="UnixSocketAddressType"/>
      </property>
      <property name="path"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="path-as-array"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <array name="GLib.ByteArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <field name="parent_instance">
        <type name="SocketAddress" c:type="GSocketAddress"/>
      </field>
      <field name="priv">
        <type name="UnixSocketAddressPrivate"
              c:type="GUnixSocketAddressPrivate*"/>
      </field>
    </class>
    <record name="UnixSocketAddressClass"
            c:type="GUnixSocketAddressClass"
            glib:is-gtype-struct-for="UnixSocketAddress">
      <field name="parent_class">
        <type name="SocketAddressClass" c:type="GSocketAddressClass"/>
      </field>
    </record>
    <record name="UnixSocketAddressPrivate"
            c:type="GUnixSocketAddressPrivate"
            disguised="1">
    </record>
    <enumeration name="UnixSocketAddressType"
                 version="2.26"
                 glib:type-name="GUnixSocketAddressType"
                 glib:get-type="g_unix_socket_address_type_get_type"
                 c:type="GUnixSocketAddressType">
      <doc xml:whitespace="preserve">The type of name used by a #GUnixSocketAddress.
%G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS
indicates a socket not bound to any name (eg, a client-side socket,
or a socket created with socketpair()).
For abstract sockets, there are two incompatible ways of naming
sockaddr_un&lt;/literal&gt; as the name, padding the unused parts of the
%sun_path field with zeroes; this corresponds to
%G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED. However, many programs
instead just use a portion of %sun_path, and pass an appropriate
smaller length to bind() or connect(). This is
%G_UNIX_SOCKET_ADDRESS_ABSTRACT.</doc>
      <member name="invalid"
              value="0"
              c:identifier="G_UNIX_SOCKET_ADDRESS_INVALID"
              glib:nick="invalid"/>
      <member name="anonymous"
              value="1"
              c:identifier="G_UNIX_SOCKET_ADDRESS_ANONYMOUS"
              glib:nick="anonymous"/>
      <member name="path"
              value="2"
              c:identifier="G_UNIX_SOCKET_ADDRESS_PATH"
              glib:nick="path"/>
      <member name="abstract"
              value="3"
              c:identifier="G_UNIX_SOCKET_ADDRESS_ABSTRACT"
              glib:nick="abstract"/>
      <member name="abstract_padded"
              value="4"
              c:identifier="G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED"
              glib:nick="abstract-padded"/>
    </enumeration>
    <constant name="VFS_EXTENSION_POINT_NAME" value="gio-vfs">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_IDENTIFIER_KIND_HAL_UDI" value="hal-udi">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_IDENTIFIER_KIND_LABEL" value="label">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_IDENTIFIER_KIND_NFS_MOUNT" value="nfs-mount">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_IDENTIFIER_KIND_UNIX_DEVICE" value="unix-device">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_IDENTIFIER_KIND_UUID" value="uuid">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VOLUME_MONITOR_EXTENSION_POINT_NAME"
              value="gio-volume-monitor">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Vfs"
           c:symbol-prefix="vfs"
           c:type="GVfs"
           parent="GObject.Object"
           glib:type-name="GVfs"
           glib:get-type="g_vfs_get_type"
           glib:type-struct="VfsClass">
      <doc xml:whitespace="preserve">Virtual File System object.</doc>
      <function name="get_default" c:identifier="g_vfs_get_default">
        <doc xml:whitespace="preserve">Gets the default #GVfs for the system.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GVfs.</doc>
          <type name="Vfs" c:type="GVfs*"/>
        </return-value>
      </function>
      <function name="get_local" c:identifier="g_vfs_get_local">
        <doc xml:whitespace="preserve">Gets the local #GVfs for the system.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GVfs.</doc>
          <type name="Vfs" c:type="GVfs*"/>
        </return-value>
      </function>
      <virtual-method name="add_writable_namespaces">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <type name="FileAttributeInfoList"
                  c:type="GFileAttributeInfoList*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_file_for_path" invoker="get_file_for_path">
        <doc xml:whitespace="preserve">Gets a #GFile for @path.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a VFS path.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_file_for_uri" invoker="get_file_for_uri">
        <doc xml:whitespace="preserve">Gets a #GFile for @uri.
This operation never fails, but the returned object
might not support any I/O operation if the URI
is malformed or if the URI scheme is not supported.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a URI</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_supported_uri_schemes"
                      invoker="get_supported_uri_schemes">
        <doc xml:whitespace="preserve">Gets a list of URI schemes supported by @vfs.
The returned array belongs to GIO and must
not be freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a %NULL-terminated array of strings.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </virtual-method>
      <virtual-method name="is_active" invoker="is_active">
        <doc xml:whitespace="preserve">Checks if the VFS is active.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if construction of the @vfs was successful and it is now active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="local_file_add_info">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="attribute_matcher" transfer-ownership="none">
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="extra_data" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
          <parameter name="free_extra_data"
                     transfer-ownership="none"
                     scope="async">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="local_file_moved">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="local_file_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="local_file_set_attributes" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none">
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parse_name" invoker="parse_name">
        <doc xml:whitespace="preserve">This operation never fails, but the returned object might
not support any I/O operations if the @parse_name cannot
be parsed by the #GVfs module.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile for the given @parse_name.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="parse_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string to be parsed by the VFS module.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_file_for_path" c:identifier="g_vfs_get_file_for_path">
        <doc xml:whitespace="preserve">Gets a #GFile for @path.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a VFS path.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_file_for_uri" c:identifier="g_vfs_get_file_for_uri">
        <doc xml:whitespace="preserve">Gets a #GFile for @uri.
This operation never fails, but the returned object
might not support any I/O operation if the URI
is malformed or if the URI scheme is not supported.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string containing a URI</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_supported_uri_schemes"
              c:identifier="g_vfs_get_supported_uri_schemes">
        <doc xml:whitespace="preserve">Gets a list of URI schemes supported by @vfs.
The returned array belongs to GIO and must
not be freed or modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a %NULL-terminated array of strings.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="is_active" c:identifier="g_vfs_is_active">
        <doc xml:whitespace="preserve">Checks if the VFS is active.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if construction of the @vfs was successful and it is now active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="parse_name" c:identifier="g_vfs_parse_name">
        <doc xml:whitespace="preserve">This operation never fails, but the returned object might
not support any I/O operations if the @parse_name cannot
be parsed by the #GVfs module.
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GFile for the given @parse_name.</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <parameter name="parse_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string to be parsed by the VFS module.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="VfsClass" c:type="GVfsClass" glib:is-gtype-struct-for="Vfs">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="is_active">
        <callback name="is_active">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if construction of the @vfs was successful and it is now active.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_file_for_path">
        <callback name="get_file_for_path">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string containing a VFS path.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_file_for_uri">
        <callback name="get_file_for_uri">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFile.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string containing a URI</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_supported_uri_schemes">
        <callback name="get_supported_uri_schemes">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a %NULL-terminated array of strings.</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parse_name">
        <callback name="parse_name">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GFile for the given @parse_name.</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="parse_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">a string to be parsed by the VFS module.</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="local_file_add_info">
        <callback name="local_file_add_info">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="filename" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
            <parameter name="attribute_matcher" transfer-ownership="none">
              <type name="FileAttributeMatcher"
                    c:type="GFileAttributeMatcher*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="FileInfo" c:type="GFileInfo*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="extra_data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer*"/>
            </parameter>
            <parameter name="free_extra_data"
                       transfer-ownership="none"
                       scope="async">
              <type name="GLib.DestroyNotify" c:type="GDestroyNotify*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_writable_namespaces">
        <callback name="add_writable_namespaces">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="list" transfer-ownership="none">
              <type name="FileAttributeInfoList"
                    c:type="GFileAttributeInfoList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="local_file_set_attributes">
        <callback name="local_file_set_attributes" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="filename" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="FileInfo" c:type="GFileInfo*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none">
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="local_file_removed">
        <callback name="local_file_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="filename" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="local_file_moved">
        <callback name="local_file_moved">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfs" transfer-ownership="none">
              <type name="Vfs" c:type="GVfs*"/>
            </parameter>
            <parameter name="source" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="dest" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved7" introspectable="0">
        <callback name="_g_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <interface name="Volume"
               c:symbol-prefix="volume"
               c:type="GVolume"
               glib:type-name="GVolume"
               glib:get-type="g_volume_get_type"
               glib:type-struct="VolumeIface">
      <doc xml:whitespace="preserve">Opaque mountable volume object.</doc>
      <virtual-method name="can_eject" invoker="can_eject">
        <doc xml:whitespace="preserve">Checks if a volume can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @volume can be ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="can_mount" invoker="can_mount">
        <doc xml:whitespace="preserve">Checks if a volume can be mounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @volume can be mounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="eject"
                      invoker="eject"
                      deprecated="Use g_volume_eject_with_operation() instead."
                      deprecated-version="2.22">
        <doc xml:whitespace="preserve">Ejects a volume. This is an asynchronous operation, and is
finished by calling g_volume_eject_finish() with the @volume
and #GAsyncResult returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">user data that gets passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_finish"
                      invoker="eject_finish"
                      deprecated="Use g_volume_eject_with_operation_finish() instead."
                      deprecated-version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a volume. If any errors occured during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE, %FALSE if operation failed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation"
                      invoker="eject_with_operation"
                      version="2.22">
        <doc xml:whitespace="preserve">Ejects a volume. This is an asynchronous operation, and is
finished by calling g_volume_eject_with_operation_finish() with the @volume
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eject_with_operation_finish"
                      invoker="eject_with_operation_finish"
                      version="2.22"
                      throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a volume. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the volume was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="enumerate_identifiers"
                      invoker="enumerate_identifiers">
        <doc xml:whitespace="preserve">Gets the kinds of &lt;link linkend="volume-identifier"&gt;identifiers&lt;/link&gt;
that @volume has. Use g_volume_get_identifer() to obtain
the identifiers themselves.
of strings containing kinds of identifiers. Use g_strfreev() to free.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a %NULL-terminated array</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
      </virtual-method>
      <virtual-method name="get_activation_root"
                      invoker="get_activation_root"
                      version="2.18">
        <doc xml:whitespace="preserve">Gets the activation root for a #GVolume if it is known ahead of
mount time. Returns %NULL otherwise. If not %NULL and if @volume
is mounted, then the result of g_mount_get_root() on the
#GMount object obtained from g_volume_get_mount() will always
either be equal or a prefix of what this function returns. In
other words, in code
&lt;programlisting&gt;
GMount *mount;
GFile *mount_root
GFile *volume_activation_root;
mount = g_volume_get_mount (volume); /&amp;ast; mounted, so never NULL &amp;ast;/
mount_root = g_mount_get_root (mount);
volume_activation_root = g_volume_get_activation_root(volume); /&amp;ast; assume not NULL &amp;ast;/
&lt;/programlisting&gt;
then the expression
&lt;programlisting&gt;
(g_file_has_prefix (volume_activation_root, mount_root) ||
&lt;/programlisting&gt;
will always be %TRUE.
Activation roots are typically used in #GVolumeMonitor
implementations to find the underlying mount to shadow, see
g_mount_is_shadowed() for more details.
g_object_unref() to free.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the activation root of @volume or %NULL. Use</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_drive" invoker="get_drive">
        <doc xml:whitespace="preserve">Gets the drive for the @volume.
The returned object should be unreffed with g_object_unref()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GDrive or %NULL if @volume is not associated with a drive.</doc>
          <type name="Drive" c:type="GDrive*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_icon" invoker="get_icon">
        <doc xml:whitespace="preserve">Gets the icon for @volume.
The returned object should be unreffed with g_object_unref()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIcon.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_identifier" invoker="get_identifier">
        <doc xml:whitespace="preserve">Gets the identifier of the given kind for @volume.
See the &lt;link linkend="volume-identifier"&gt;introduction&lt;/link&gt;
for more information about volume identifiers.
requested identfier, or %NULL if the #GVolume
doesn't have this kind of identifier</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated string containing the</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="kind" transfer-ownership="none">
            <doc xml:whitespace="preserve">the kind of identifier to return</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_mount" invoker="get_mount">
        <doc xml:whitespace="preserve">Gets the mount for the @volume.
The returned object should be unreffed with g_object_unref()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GMount or %NULL if @volume isn't mounted.</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name">
        <doc xml:whitespace="preserve">Gets the name of @volume.
be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the name for the given @volume. The returned string should</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_uuid" invoker="get_uuid">
        <doc xml:whitespace="preserve">Gets the UUID for the @volume. The reference is typically based on
the file system UUID for the volume in question and should be
considered an opaque string. Returns %NULL if there is no UUID
available.
The returned string should be freed with g_free()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the UUID for @volume or %NULL if no UUID can be computed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="mount_finish" invoker="mount_finish" throws="1">
        <doc xml:whitespace="preserve">Finishes mounting a volume. If any errors occured during the operation,
If the mount operation succeeded, g_volume_get_mount() on @volume
is guaranteed to return the mount right after calling this
function; there's no need to listen for the 'mount-added' signal on
#GVolumeMonitor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE, %FALSE if operation failed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="mount_fn" invoker="mount">
        <doc xml:whitespace="preserve">Mounts a volume. This is an asynchronous operation, and is
finished by calling g_volume_mount_finish() with the @volume
and #GAsyncResult returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">user data that gets passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="should_automount" invoker="should_automount">
        <doc xml:whitespace="preserve">Returns whether the volume should be automatically mounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the volume should be automatically mounted.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="can_eject" c:identifier="g_volume_can_eject">
        <doc xml:whitespace="preserve">Checks if a volume can be ejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @volume can be ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="can_mount" c:identifier="g_volume_can_mount">
        <doc xml:whitespace="preserve">Checks if a volume can be mounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the @volume can be mounted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="eject"
              c:identifier="g_volume_eject"
              deprecated="Use g_volume_eject_with_operation() instead."
              deprecated-version="2.22">
        <doc xml:whitespace="preserve">Ejects a volume. This is an asynchronous operation, and is
finished by calling g_volume_eject_finish() with the @volume
and #GAsyncResult returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data that gets passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_finish"
              c:identifier="g_volume_eject_finish"
              deprecated="Use g_volume_eject_with_operation_finish() instead."
              deprecated-version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a volume. If any errors occured during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE, %FALSE if operation failed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation"
              c:identifier="g_volume_eject_with_operation"
              version="2.22">
        <doc xml:whitespace="preserve">Ejects a volume. This is an asynchronous operation, and is
finished by calling g_volume_eject_with_operation_finish() with the @volume
and #GAsyncResult data returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
            <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
          </parameter>
          <parameter name="mount_operation" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="eject_with_operation_finish"
              c:identifier="g_volume_eject_with_operation_finish"
              version="2.22"
              throws="1">
        <doc xml:whitespace="preserve">Finishes ejecting a volume. If any errors occurred during the operation,</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the volume was successfully ejected. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enumerate_identifiers"
              c:identifier="g_volume_enumerate_identifiers">
        <doc xml:whitespace="preserve">Gets the kinds of &lt;link linkend="volume-identifier"&gt;identifiers&lt;/link&gt;
that @volume has. Use g_volume_get_identifer() to obtain
the identifiers themselves.
of strings containing kinds of identifiers. Use g_strfreev() to free.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a %NULL-terminated array</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_activation_root"
              c:identifier="g_volume_get_activation_root"
              version="2.18">
        <doc xml:whitespace="preserve">Gets the activation root for a #GVolume if it is known ahead of
mount time. Returns %NULL otherwise. If not %NULL and if @volume
is mounted, then the result of g_mount_get_root() on the
#GMount object obtained from g_volume_get_mount() will always
either be equal or a prefix of what this function returns. In
other words, in code
&lt;programlisting&gt;
GMount *mount;
GFile *mount_root
GFile *volume_activation_root;
mount = g_volume_get_mount (volume); /&amp;ast; mounted, so never NULL &amp;ast;/
mount_root = g_mount_get_root (mount);
volume_activation_root = g_volume_get_activation_root(volume); /&amp;ast; assume not NULL &amp;ast;/
&lt;/programlisting&gt;
then the expression
&lt;programlisting&gt;
(g_file_has_prefix (volume_activation_root, mount_root) ||
&lt;/programlisting&gt;
will always be %TRUE.
Activation roots are typically used in #GVolumeMonitor
implementations to find the underlying mount to shadow, see
g_mount_is_shadowed() for more details.
g_object_unref() to free.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the activation root of @volume or %NULL. Use</doc>
          <type name="File" c:type="GFile*"/>
        </return-value>
      </method>
      <method name="get_drive" c:identifier="g_volume_get_drive">
        <doc xml:whitespace="preserve">Gets the drive for the @volume.
The returned object should be unreffed with g_object_unref()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GDrive or %NULL if @volume is not associated with a drive.</doc>
          <type name="Drive" c:type="GDrive*"/>
        </return-value>
      </method>
      <method name="get_icon" c:identifier="g_volume_get_icon">
        <doc xml:whitespace="preserve">Gets the icon for @volume.
The returned object should be unreffed with g_object_unref()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GIcon.</doc>
          <type name="Icon" c:type="GIcon*"/>
        </return-value>
      </method>
      <method name="get_identifier" c:identifier="g_volume_get_identifier">
        <doc xml:whitespace="preserve">Gets the identifier of the given kind for @volume.
See the &lt;link linkend="volume-identifier"&gt;introduction&lt;/link&gt;
for more information about volume identifiers.
requested identfier, or %NULL if the #GVolume
doesn't have this kind of identifier</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated string containing the</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="kind" transfer-ownership="none">
            <doc xml:whitespace="preserve">the kind of identifier to return</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mount" c:identifier="g_volume_get_mount">
        <doc xml:whitespace="preserve">Gets the mount for the @volume.
The returned object should be unreffed with g_object_unref()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GMount or %NULL if @volume isn't mounted.</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
      </method>
      <method name="get_name" c:identifier="g_volume_get_name">
        <doc xml:whitespace="preserve">Gets the name of @volume.
be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the name for the given @volume. The returned string should</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_uuid" c:identifier="g_volume_get_uuid">
        <doc xml:whitespace="preserve">Gets the UUID for the @volume. The reference is typically based on
the file system UUID for the volume in question and should be
considered an opaque string. Returns %NULL if there is no UUID
available.
The returned string should be freed with g_free()
when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the UUID for @volume or %NULL if no UUID can be computed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="mount" c:identifier="g_volume_mount">
        <doc xml:whitespace="preserve">Mounts a volume. This is an asynchronous operation, and is
finished by calling g_volume_mount_finish() with the @volume
and #GAsyncResult returned in the @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting the operation</doc>
            <type name="MountMountFlags" c:type="GMountMountFlags"/>
          </parameter>
          <parameter name="mount_operation"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
            <type name="MountOperation" c:type="GMountOperation*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data that gets passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="mount_finish"
              c:identifier="g_volume_mount_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes mounting a volume. If any errors occured during the operation,
If the mount operation succeeded, g_volume_get_mount() on @volume
is guaranteed to return the mount right after calling this
function; there's no need to listen for the 'mount-added' signal on
#GVolumeMonitor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE, %FALSE if operation failed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="should_automount" c:identifier="g_volume_should_automount">
        <doc xml:whitespace="preserve">Returns whether the volume should be automatically mounted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the volume should be automatically mounted.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <glib:signal name="changed">
        <doc xml:whitespace="preserve">Emitted when the volume has been changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="removed">
        <doc xml:whitespace="preserve">This signal is emitted when the #GVolume have been removed. If
the recipient is holding references to the object they should
release them so the object can be finalized.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </interface>
    <record name="VolumeIface"
            c:type="GVolumeIface"
            glib:is-gtype-struct-for="Volume">
      <doc xml:whitespace="preserve">Interface for implementing operations for mountable volumes.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="removed">
        <callback name="removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_name">
        <callback name="get_name">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the name for the given @volume. The returned string should</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_icon">
        <callback name="get_icon">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uuid">
        <callback name="get_uuid">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the UUID for @volume or %NULL if no UUID can be computed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_drive">
        <callback name="get_drive">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GDrive or %NULL if @volume is not associated with a drive.</doc>
            <type name="Drive" c:type="GDrive*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_mount">
        <callback name="get_mount">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GMount or %NULL if @volume isn't mounted.</doc>
            <type name="Mount" c:type="GMount*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_mount">
        <callback name="can_mount">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @volume can be mounted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_eject">
        <callback name="can_eject">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the @volume can be ejected. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_fn">
        <callback name="mount_fn">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the operation</doc>
              <type name="MountMountFlags" c:type="GMountMountFlags"/>
            </parameter>
            <parameter name="mount_operation"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">user data that gets passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_finish">
        <callback name="mount_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE, %FALSE if operation failed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject">
        <callback name="eject">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:whitespace="preserve">user data that gets passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_finish">
        <callback name="eject_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE, %FALSE if operation failed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_identifier">
        <callback name="get_identifier">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a newly allocated string containing the</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="kind" transfer-ownership="none">
              <doc xml:whitespace="preserve">the kind of identifier to return</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enumerate_identifiers">
        <callback name="enumerate_identifiers">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a %NULL-terminated array</doc>
            <array c:type="char**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="should_automount">
        <callback name="should_automount">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the volume should be automatically mounted.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_activation_root">
        <callback name="get_activation_root">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the activation root of @volume or %NULL. Use</doc>
            <type name="File" c:type="GFile*"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation">
        <callback name="eject_with_operation">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:whitespace="preserve">flags affecting the unmount if required for eject</doc>
              <type name="MountUnmountFlags" c:type="GMountUnmountFlags"/>
            </parameter>
            <parameter name="mount_operation" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GMountOperation or %NULL to avoid user interaction.</doc>
              <type name="MountOperation" c:type="GMountOperation*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       allow-none="1">
              <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="5">
              <doc xml:whitespace="preserve">a #GAsyncReadyCallback, or %NULL.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="5">
              <doc xml:whitespace="preserve">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eject_with_operation_finish">
        <callback name="eject_with_operation_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the volume was successfully ejected. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="VolumeMonitor"
           c:symbol-prefix="volume_monitor"
           c:type="GVolumeMonitor"
           parent="GObject.Object"
           glib:type-name="GVolumeMonitor"
           glib:get-type="g_volume_monitor_get_type"
           glib:type-struct="VolumeMonitorClass">
      <doc xml:whitespace="preserve">A Volume Monitor that watches for volume events.</doc>
      <function name="adopt_orphan_mount"
                c:identifier="g_volume_monitor_adopt_orphan_mount"
                deprecated="Instead of using this function, #GVolumeMonitor"
                deprecated-version="2.20">
        <doc xml:whitespace="preserve">This function should be called by any #GVolumeMonitor
implementation when a new #GMount object is created that is not
associated with a #GVolume object. It must be called just before
emitting the @mount_added signal.
If the return value is not %NULL, the caller must associate the
returned #GVolume object with the #GMount. This involves returning
it in its g_mount_get_volume() implementation. The caller must
also listen for the "removed" signal on the returned object
and give up its reference when handling that signal
Similary, if implementing g_volume_monitor_adopt_orphan_mount(),
the implementor must take a reference to @mount and return it in
its g_volume_get_mount() implemented. Also, the implementor must
listen for the "unmounted" signal on @mount and give up its
reference upon handling that signal.
There are two main use cases for this function.
One is when implementing a user space file system driver that reads
blocks of a block device that is already represented by the native
volume monitor (for example a CD Audio file system driver). Such
a driver will generate its own #GMount object that needs to be
assoicated with the #GVolume object that represents the volume.
The other is for implementing a #GVolumeMonitor whose sole purpose
is to return #GVolume objects representing entries in the users
"favorite servers" list or similar.
if no wants to adopt the #GMount.
implementations should instead create shadow mounts with the URI of
the mount they intend to adopt. See the proxy volume monitor in
gvfs for an example of this. Also see g_mount_is_shadowed(),
g_mount_shadow() and g_mount_unshadow() functions.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GVolume object that is the parent for @mount or %NULL</doc>
          <type name="Volume" c:type="GVolume*"/>
        </return-value>
        <parameters>
          <parameter name="mount" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMount object to find a parent for</doc>
            <type name="Mount" c:type="GMount*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get" c:identifier="g_volume_monitor_get">
        <doc xml:whitespace="preserve">Gets the volume monitor used by gio.
g_object_unref() when done with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to the #GVolumeMonitor used by gio. Call</doc>
          <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
        </return-value>
      </function>
      <virtual-method name="get_connected_drives"
                      invoker="get_connected_drives">
        <doc xml:whitespace="preserve">Gets a list of drives connected to the system.
The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of connected #GDrive objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Drive"/>
          </type>
        </return-value>
      </virtual-method>
      <virtual-method name="get_mount_for_uuid" invoker="get_mount_for_uuid">
        <doc xml:whitespace="preserve">Finds a #GMount object by its UUID (see g_mount_get_uuid())
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GMount or %NULL if no such mount is available.</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <parameter name="uuid" transfer-ownership="none">
            <doc xml:whitespace="preserve">the UUID to look for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_mounts" invoker="get_mounts">
        <doc xml:whitespace="preserve">Gets a list of the mounts on the system.
The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GMount objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Mount"/>
          </type>
        </return-value>
      </virtual-method>
      <virtual-method name="get_volume_for_uuid" invoker="get_volume_for_uuid">
        <doc xml:whitespace="preserve">Finds a #GVolume object by its UUID (see g_volume_get_uuid())
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GVolume or %NULL if no such volume is available.</doc>
          <type name="Volume" c:type="GVolume*"/>
        </return-value>
        <parameters>
          <parameter name="uuid" transfer-ownership="none">
            <doc xml:whitespace="preserve">the UUID to look for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_volumes" invoker="get_volumes">
        <doc xml:whitespace="preserve">Gets a list of the volumes on the system.
The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GVolume objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Volume"/>
          </type>
        </return-value>
      </virtual-method>
      <method name="get_connected_drives"
              c:identifier="g_volume_monitor_get_connected_drives">
        <doc xml:whitespace="preserve">Gets a list of drives connected to the system.
The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of connected #GDrive objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Drive"/>
          </type>
        </return-value>
      </method>
      <method name="get_mount_for_uuid"
              c:identifier="g_volume_monitor_get_mount_for_uuid">
        <doc xml:whitespace="preserve">Finds a #GMount object by its UUID (see g_mount_get_uuid())
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GMount or %NULL if no such mount is available.</doc>
          <type name="Mount" c:type="GMount*"/>
        </return-value>
        <parameters>
          <parameter name="uuid" transfer-ownership="none">
            <doc xml:whitespace="preserve">the UUID to look for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mounts" c:identifier="g_volume_monitor_get_mounts">
        <doc xml:whitespace="preserve">Gets a list of the mounts on the system.
The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GMount objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Mount"/>
          </type>
        </return-value>
      </method>
      <method name="get_volume_for_uuid"
              c:identifier="g_volume_monitor_get_volume_for_uuid">
        <doc xml:whitespace="preserve">Finds a #GVolume object by its UUID (see g_volume_get_uuid())
Free the returned object with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GVolume or %NULL if no such volume is available.</doc>
          <type name="Volume" c:type="GVolume*"/>
        </return-value>
        <parameters>
          <parameter name="uuid" transfer-ownership="none">
            <doc xml:whitespace="preserve">the UUID to look for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_volumes" c:identifier="g_volume_monitor_get_volumes">
        <doc xml:whitespace="preserve">Gets a list of the volumes on the system.
The returned list should be freed with g_list_free(), after
its elements have been unreffed with g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GVolume objects.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Volume"/>
          </type>
        </return-value>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="drive-changed">
        <doc xml:whitespace="preserve">Emitted when a drive changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the drive that changed</doc>
            <type name="Drive"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="drive-connected">
        <doc xml:whitespace="preserve">Emitted when a drive is connected to the system.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GDrive that was connected.</doc>
            <type name="Drive"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="drive-disconnected">
        <doc xml:whitespace="preserve">Emitted when a drive is disconnected from the system.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GDrive that was disconnected.</doc>
            <type name="Drive"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="drive-eject-button" version="2.18">
        <doc xml:whitespace="preserve">Emitted when the eject button is pressed on @drive.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the drive where the eject button was pressed</doc>
            <type name="Drive"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="drive-stop-button" version="2.22">
        <doc xml:whitespace="preserve">Emitted when the stop button is pressed on @drive.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the drive where the stop button was pressed</doc>
            <type name="Drive"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="mount-added">
        <doc xml:whitespace="preserve">Emitted when a mount is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMount that was added.</doc>
            <type name="Mount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="mount-changed">
        <doc xml:whitespace="preserve">Emitted when a mount changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMount that changed.</doc>
            <type name="Mount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="mount-pre-unmount">
        <doc xml:whitespace="preserve">Emitted when a mount is about to be removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMount that is being unmounted.</doc>
            <type name="Mount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="mount-removed">
        <doc xml:whitespace="preserve">Emitted when a mount is removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GMount that was removed.</doc>
            <type name="Mount"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="volume-added">
        <doc xml:whitespace="preserve">Emitted when a mountable volume is added to the system.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GVolume that was added.</doc>
            <type name="Volume"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="volume-changed">
        <doc xml:whitespace="preserve">Emitted when mountable volume is changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GVolume that changed.</doc>
            <type name="Volume"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="volume-removed">
        <doc xml:whitespace="preserve">Emitted when a mountable volume is removed from the system.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GVolume that was removed.</doc>
            <type name="Volume"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="VolumeMonitorClass"
            c:type="GVolumeMonitorClass"
            glib:is-gtype-struct-for="VolumeMonitor">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="volume_added">
        <callback name="volume_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="volume_removed">
        <callback name="volume_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="volume_changed">
        <callback name="volume_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="volume" transfer-ownership="none">
              <type name="Volume" c:type="GVolume*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_added">
        <callback name="mount_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_removed">
        <callback name="mount_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_pre_unmount">
        <callback name="mount_pre_unmount">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mount_changed">
        <callback name="mount_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="drive_connected">
        <callback name="drive_connected">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="drive_disconnected">
        <callback name="drive_disconnected">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="drive_changed">
        <callback name="drive_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_supported">
        <callback name="is_supported">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
        </callback>
      </field>
      <field name="get_connected_drives">
        <callback name="get_connected_drives">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GList of connected #GDrive objects.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Drive"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_volumes">
        <callback name="get_volumes">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GList of #GVolume objects.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Volume"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_mounts">
        <callback name="get_mounts">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GList of #GMount objects.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Mount"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_volume_for_uuid">
        <callback name="get_volume_for_uuid">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GVolume or %NULL if no such volume is available.</doc>
            <type name="Volume" c:type="GVolume*"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="uuid" transfer-ownership="none">
              <doc xml:whitespace="preserve">the UUID to look for</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_mount_for_uuid">
        <callback name="get_mount_for_uuid">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GMount or %NULL if no such mount is available.</doc>
            <type name="Mount" c:type="GMount*"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="uuid" transfer-ownership="none">
              <doc xml:whitespace="preserve">the UUID to look for</doc>
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="adopt_orphan_mount" introspectable="0">
        <callback name="adopt_orphan_mount" introspectable="0">
          <return-value>
            <type name="Volume" c:type="GVolume*"/>
          </return-value>
          <parameters>
            <parameter name="mount" transfer-ownership="none">
              <type name="Mount" c:type="GMount*"/>
            </parameter>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="drive_eject_button">
        <callback name="drive_eject_button">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="drive_stop_button">
        <callback name="drive_stop_button">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="volume_monitor" transfer-ownership="none">
              <type name="VolumeMonitor" c:type="GVolumeMonitor*"/>
            </parameter>
            <parameter name="drive" transfer-ownership="none">
              <type name="Drive" c:type="GDrive*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="0">
        <callback name="_g_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved2" introspectable="0">
        <callback name="_g_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved3" introspectable="0">
        <callback name="_g_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="0">
        <callback name="_g_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved5" introspectable="0">
        <callback name="_g_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_g_reserved6" introspectable="0">
        <callback name="_g_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="ZlibCompressor"
           c:symbol-prefix="zlib_compressor"
           c:type="GZlibCompressor"
           parent="GObject.Object"
           glib:type-name="GZlibCompressor"
           glib:get-type="g_zlib_compressor_get_type"
           glib:type-struct="ZlibCompressorClass">
      <doc xml:whitespace="preserve">Zlib decompression</doc>
      <implements name="Converter"/>
      <constructor name="new"
                   c:identifier="g_zlib_compressor_new"
                   version="2.24">
        <doc xml:whitespace="preserve">Creates a new #GZlibCompressor.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GZlibCompressor</doc>
          <type name="ZlibCompressor" c:type="GZlibCompressor*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format to use for the compressed data</doc>
            <type name="ZlibCompressorFormat" c:type="GZlibCompressorFormat"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:whitespace="preserve">compression level (0-9), -1 for default</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_file_info"
              c:identifier="g_zlib_compressor_get_file_info"
              version="2.26">
        <doc xml:whitespace="preserve">Returns the #GZlibCompressor:file-info property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GFileInfo, or %NULL</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
      </method>
      <method name="set_file_info"
              c:identifier="g_zlib_compressor_set_file_info"
              version="2.26">
        <doc xml:whitespace="preserve">Sets @file_info in @compressor. If non-%NULL, and @compressor's
#GZlibCompressor:format property is %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
it will be used to set the file name and modification time in
the GZIP header of the compressed data.
progress; it may only be called immediately after creation of @compressor,
or after resetting it with g_converter_reset().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="file_info" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*"/>
          </parameter>
        </parameters>
      </method>
      <property name="file-info"
                version="2.26"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If set to a non-%NULL #GFileInfo object, and #GZlibCompressor:format is
%G_ZLIB_COMPRESSOR_FORMAT_GZIP, the compressor will write the file name
and modification time from the file info to the the GZIP header.</doc>
        <type name="FileInfo"/>
      </property>
      <property name="format"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="ZlibCompressorFormat"/>
      </property>
      <property name="level"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint"/>
      </property>
    </class>
    <record name="ZlibCompressorClass"
            c:type="GZlibCompressorClass"
            glib:is-gtype-struct-for="ZlibCompressor">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="ZlibCompressorFormat"
                 version="2.24"
                 glib:type-name="GZlibCompressorFormat"
                 glib:get-type="g_zlib_compressor_format_get_type"
                 c:type="GZlibCompressorFormat">
      <doc xml:whitespace="preserve">Used to select the type of data format to use for #GZlibDecompressor
and #GZlibCompressor.</doc>
      <member name="zlib"
              value="0"
              c:identifier="G_ZLIB_COMPRESSOR_FORMAT_ZLIB"
              glib:nick="zlib"/>
      <member name="gzip"
              value="1"
              c:identifier="G_ZLIB_COMPRESSOR_FORMAT_GZIP"
              glib:nick="gzip"/>
      <member name="raw"
              value="2"
              c:identifier="G_ZLIB_COMPRESSOR_FORMAT_RAW"
              glib:nick="raw"/>
    </enumeration>
    <class name="ZlibDecompressor"
           c:symbol-prefix="zlib_decompressor"
           c:type="GZlibDecompressor"
           parent="GObject.Object"
           glib:type-name="GZlibDecompressor"
           glib:get-type="g_zlib_decompressor_get_type"
           glib:type-struct="ZlibDecompressorClass">
      <doc xml:whitespace="preserve">Zlib decompression</doc>
      <implements name="Converter"/>
      <constructor name="new"
                   c:identifier="g_zlib_decompressor_new"
                   version="2.24">
        <doc xml:whitespace="preserve">Creates a new #GZlibDecompressor.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GZlibDecompressor</doc>
          <type name="ZlibDecompressor" c:type="GZlibDecompressor*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format to use for the compressed data</doc>
            <type name="ZlibCompressorFormat" c:type="GZlibCompressorFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_file_info"
              c:identifier="g_zlib_decompressor_get_file_info"
              version="2.26">
        <doc xml:whitespace="preserve">Retrieves the #GFileInfo constructed from the GZIP header data
of compressed data processed by @compressor, or %NULL if @decompressor's
#GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP,
or the header data was not fully processed yet, or it not present in the
data stream at all.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GFileInfo, or %NULL</doc>
          <type name="FileInfo" c:type="GFileInfo*"/>
        </return-value>
      </method>
      <property name="file-info" version="2.26" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GFileInfo containing the information found in the GZIP header
of the data stream processed, or %NULL if the header was not yet
fully processed, is not present at all, or the compressor's
#GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP.</doc>
        <type name="FileInfo"/>
      </property>
      <property name="format"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="ZlibCompressorFormat"/>
      </property>
    </class>
    <record name="ZlibDecompressorClass"
            c:type="GZlibDecompressorClass"
            glib:is-gtype-struct-for="ZlibDecompressor">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <function name="app_info_create_from_commandline"
              c:identifier="g_app_info_create_from_commandline"
              throws="1">
      <doc xml:whitespace="preserve">Creates a new #GAppInfo from the given information.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">new #GAppInfo for given command.</doc>
        <type name="AppInfo" c:type="GAppInfo*"/>
      </return-value>
      <parameters>
        <parameter name="commandline" transfer-ownership="none">
          <doc xml:whitespace="preserve">the commandline to use</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="application_name"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">the application name, or %NULL to use @commandline</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags that can specify details of the created #GAppInfo</doc>
          <type name="AppInfoCreateFlags" c:type="GAppInfoCreateFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_get_all" c:identifier="g_app_info_get_all">
      <doc xml:whitespace="preserve">Gets a list of all of the applications currently registered
on this system.
For desktop files, this includes applications that have
&lt;literal&gt;NoDisplay=true&lt;/literal&gt; set or are excluded from
display by means of &lt;literal&gt;OnlyShowIn&lt;/literal&gt; or
&lt;literal&gt;NotShowIn&lt;/literal&gt;. See g_app_info_should_show().
The returned list does not include applications which have
the &lt;literal&gt;Hidden&lt;/literal&gt; key set.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated #GList of references to #GAppInfo&lt;!----&gt;s.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="AppInfo"/>
        </type>
      </return-value>
    </function>
    <function name="app_info_get_all_for_type"
              c:identifier="g_app_info_get_all_for_type">
      <doc xml:whitespace="preserve">Gets a list of all #GAppInfo&lt;!-- --&gt;s for a given content type.
or %NULL on error.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">#GList of #GAppInfo&lt;!-- --&gt;s for given @content_type</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="AppInfo"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="content_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the content type to find a #GAppInfo for</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_get_default_for_type"
              c:identifier="g_app_info_get_default_for_type"
              introspectable="0">
      <doc xml:whitespace="preserve">Gets the #GAppInfo that corresponds to a given content type.</doc>
      <return-value>
        <doc xml:whitespace="preserve">#GAppInfo for given @content_type or %NULL on error.</doc>
        <type name="AppInfo" c:type="GAppInfo*"/>
      </return-value>
      <parameters>
        <parameter name="content_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the content type to find a #GAppInfo for</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="must_support_uris" transfer-ownership="none">
          <doc xml:whitespace="preserve">if %TRUE, the #GAppInfo is expected to support URIs</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_get_default_for_uri_scheme"
              c:identifier="g_app_info_get_default_for_uri_scheme"
              introspectable="0">
      <doc xml:whitespace="preserve">Gets the default application for launching applications
using this URI scheme. A URI scheme is the initial part
of the URI, up to but not including the ':', e.g. "http",
"ftp" or "sip".</doc>
      <return-value>
        <doc xml:whitespace="preserve">#GAppInfo for given @uri_scheme or %NULL on error.</doc>
        <type name="AppInfo" c:type="GAppInfo*"/>
      </return-value>
      <parameters>
        <parameter name="uri_scheme" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing a URI scheme.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_launch_default_for_uri"
              c:identifier="g_app_info_launch_default_for_uri"
              throws="1">
      <doc xml:whitespace="preserve">Utility function that launches the default application
registered to handle the specified uri. Synchronous I/O
is done on the uri to detect the type of the file if
required.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">the uri to show</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="launch_context" transfer-ownership="none">
          <doc xml:whitespace="preserve">an optional #GAppLaunchContext.</doc>
          <type name="AppLaunchContext" c:type="GAppLaunchContext*"/>
        </parameter>
      </parameters>
    </function>
    <function name="app_info_reset_type_associations"
              c:identifier="g_app_info_reset_type_associations"
              version="2.20">
      <doc xml:whitespace="preserve">Removes all changes to the type associations done by
g_app_info_set_as_default_for_type(),
g_app_info_set_as_default_for_extension(),
g_app_info_add_supports_type() or g_app_info_remove_supports_type().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="content_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a content type</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="async_initable_new_async"
              c:identifier="g_async_initable_new_async"
              version="2.22"
              introspectable="0">
      <doc xml:whitespace="preserve">Helper function for constructing #GAsyncInitiable object. This is
similar to g_object_new() but also initializes the object asynchronously.
When the initialization is finished, @callback will be called. You can
then call g_async_initable_new_finish() to get the new object and check
for any errors.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType supporting #GAsyncInitable.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="io_priority" transfer-ownership="none">
          <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the operation.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="async"
                   closure="4">
          <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the initialization is finished</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">the data to pass to callback function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="first_property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first property, or %NULL if no properties</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="async_initable_new_valist_async"
              c:identifier="g_async_initable_new_valist_async"
              version="2.22"
              introspectable="0">
      <doc xml:whitespace="preserve">Helper function for constructing #GAsyncInitiable object. This is
similar to g_object_new_valist() but also initializes the object
asynchronously.
When the initialization is finished, @callback will be called. You can
then call g_async_initable_new_finish() to get the new object and check
for any errors.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType supporting #GAsyncInitable.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="first_property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first property, followed by the value, and other property value pairs, and ended by %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:whitespace="preserve">The var args list generated from @first_property_name.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
        <parameter name="io_priority" transfer-ownership="none">
          <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the operation.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="async"
                   closure="6">
          <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the initialization is finished</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">the data to pass to callback function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="async_initable_newv_async"
              c:identifier="g_async_initable_newv_async"
              version="2.22">
      <doc xml:whitespace="preserve">Helper function for constructing #GAsyncInitiable object. This is
similar to g_object_newv() but also initializes the object asynchronously.
When the initialization is finished, @callback will be called. You can
then call g_async_initable_new_finish() to get the new object and check
for any errors.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType supporting #GAsyncInitable.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_parameters" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of parameters in @parameters</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="parameters" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parameters to use to construct the object</doc>
          <type name="GObject.Parameter" c:type="GParameter*"/>
        </parameter>
        <parameter name="io_priority" transfer-ownership="none">
          <doc xml:whitespace="preserve">the &lt;link linkend="io-priority"&gt;I/O priority&lt;/link&gt; of the operation.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="async"
                   closure="6">
          <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the initialization is finished</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">the data to pass to callback function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_get" c:identifier="g_bus_get" version="2.26">
      <doc xml:whitespace="preserve">Asynchronously connects to the message bus specified by @bus_type.
When the operation is finished, @callback will be invoked. You can
then call g_bus_get_finish() to get the result of the operation.
This is a asynchronous failable function. See g_bus_get_sync() for
the synchronous version.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GBusType.</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="async"
                   closure="3">
          <doc xml:whitespace="preserve">A #GAsyncReadyCallback to call when the request is satisfied.</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The data to pass to @callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_get_finish"
              c:identifier="g_bus_get_finish"
              version="2.26"
              throws="1">
      <doc xml:whitespace="preserve">Finishes an operation started with g_bus_get().
The returned object is a singleton, that is, shared with other
callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the
event that you need a private message bus connection, use
g_dbus_address_get_for_bus() and
g_dbus_connection_new_for_address().
Note that the returned #GDBusConnection object will (usually) have
the #GDBusConnection:exit-on-close property set to %TRUE.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A #GDBusConnection or %NULL if @error is set. Free with g_object_unref().</doc>
        <type name="DBusConnection" c:type="GDBusConnection*"/>
      </return-value>
      <parameters>
        <parameter name="res" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GAsyncResult obtained from the #GAsyncReadyCallback passed to g_bus_get().</doc>
          <type name="AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_get_sync"
              c:identifier="g_bus_get_sync"
              version="2.26"
              throws="1">
      <doc xml:whitespace="preserve">Synchronously connects to the message bus specified by @bus_type.
Note that the returned object may shared with other callers,
e.g. if two separate parts of a process calls this function with
the same @bus_type, they will share the same object.
This is a synchronous failable function. See g_bus_get() and
g_bus_get_finish() for the asynchronous version.
The returned object is a singleton, that is, shared with other
callers of g_bus_get() and g_bus_get_sync() for @bus_type. In the
event that you need a private message bus connection, use
g_dbus_address_get_for_bus_sync() and
g_dbus_connection_new_for_address().
Note that the returned #GDBusConnection object will (usually) have
the #GDBusConnection:exit-on-close property set to %TRUE.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A #GDBusConnection or %NULL if @error is set. Free with g_object_unref().</doc>
        <type name="DBusConnection" c:type="GDBusConnection*"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GBusType.</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_own_name"
              c:identifier="g_bus_own_name"
              shadowed-by="bus_own_name_with_closures"
              version="2.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Starts acquiring @name on the bus specified by @bus_type and calls
acquired respectively lost. Callbacks will be invoked in the &lt;link
linkend="g-main-context-push-thread-default"&gt;thread-default main
loop&lt;/link&gt; of the thread you are calling this function from.
You are guaranteed that one of the @name_acquired_handler and @name_lost_handler
callbacks will be invoked after calling this function - there are three
possible cases:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
When you are done owning the name, just call g_bus_unown_name()
with the owner id this function returns.
If the name is acquired or lost (for example another application
could acquire the name if you allow replacement or the application
currently owning the name exits), the handlers are also invoked. If the
#GDBusConnection that is used for attempting to own the name
closes, then @name_lost_handler is invoked since it is no
longer possible for other processes to access the process.
You cannot use g_bus_own_name() several times for the same name (unless
interleaved with calls to g_bus_unown_name()) - only the first call
will work.
Another guarantee is that invocations of @name_acquired_handler
and @name_lost_handler are guaranteed to alternate; that
is, if @name_acquired_handler is invoked then you are
guaranteed that the next time one of the handlers is invoked, it
will be @name_lost_handler. The reverse is also true.
If you plan on exporting objects (using e.g.
g_dbus_connection_register_object()), note that it is generally too late
to export the objects in @name_acquired_handler. Instead, you can do this
in @bus_acquired_handler since you are guaranteed that this will run
before @name is requested from the bus.
This behavior makes it very simple to write applications that wants
to own names and export objects, see &lt;xref linkend="gdbus-owning-names"/&gt;.
Simply register objects to be exported in @bus_acquired_handler and
unregister the objects (if any) in @name_lost_handler.
g_bus_unown_name() to stop owning the name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">An identifier (never 0) that an be used with</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type of bus to own a name on.</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The well-known name to own.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of flags from the #GBusNameOwnerFlags enumeration.</doc>
          <type name="BusNameOwnerFlags" c:type="GBusNameOwnerFlags"/>
        </parameter>
        <parameter name="bus_acquired_handler" transfer-ownership="none">
          <doc xml:whitespace="preserve">Handler to invoke when connected to the bus of type @bus_type or %NULL.</doc>
          <type name="BusAcquiredCallback" c:type="GBusAcquiredCallback"/>
        </parameter>
        <parameter name="name_acquired_handler" transfer-ownership="none">
          <doc xml:whitespace="preserve">Handler to invoke when @name is acquired or %NULL.</doc>
          <type name="BusNameAcquiredCallback"
                c:type="GBusNameAcquiredCallback"/>
        </parameter>
        <parameter name="name_lost_handler"
                   transfer-ownership="none"
                   scope="notified"
                   closure="6"
                   destroy="7">
          <doc xml:whitespace="preserve">Handler to invoke when @name is lost or %NULL.</doc>
          <type name="BusNameLostCallback" c:type="GBusNameLostCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">User data to pass to handlers.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data_free_func"
                   transfer-ownership="none"
                   scope="async">
          <doc xml:whitespace="preserve">Function for freeing @user_data or %NULL.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_own_name_on_connection"
              c:identifier="g_bus_own_name_on_connection"
              shadowed-by="bus_own_name_on_connection_with_closures"
              version="2.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Like g_bus_own_name() but takes a #GDBusConnection instead of a
#GBusType.
g_bus_unown_name() to stop owning the name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">An identifier (never 0) that an be used with</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The well-known name to own.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of flags from the #GBusNameOwnerFlags enumeration.</doc>
          <type name="BusNameOwnerFlags" c:type="GBusNameOwnerFlags"/>
        </parameter>
        <parameter name="name_acquired_handler" transfer-ownership="none">
          <doc xml:whitespace="preserve">Handler to invoke when @name is acquired or %NULL.</doc>
          <type name="BusNameAcquiredCallback"
                c:type="GBusNameAcquiredCallback"/>
        </parameter>
        <parameter name="name_lost_handler"
                   transfer-ownership="none"
                   scope="notified"
                   closure="5"
                   destroy="6">
          <doc xml:whitespace="preserve">Handler to invoke when @name is lost or %NULL.</doc>
          <type name="BusNameLostCallback" c:type="GBusNameLostCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">User data to pass to handlers.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data_free_func"
                   transfer-ownership="none"
                   scope="async">
          <doc xml:whitespace="preserve">Function for freeing @user_data or %NULL.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_own_name_on_connection_with_closures"
              c:identifier="g_bus_own_name_on_connection_with_closures"
              shadows="bus_own_name_on_connection"
              version="2.26">
      <doc xml:whitespace="preserve">Version of g_bus_own_name_on_connection() using closures instead of callbacks for
easier binding in other languages.
g_bus_unown_name() to stop owning the name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">An identifier (never 0) that an be used with</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The well-known name to own.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of flags from the #GBusNameOwnerFlags enumeration.</doc>
          <type name="BusNameOwnerFlags" c:type="GBusNameOwnerFlags"/>
        </parameter>
        <parameter name="name_acquired_closure"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">#GClosure to invoke when @name is acquired or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="name_lost_closure"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">#GClosure to invoke when @name is lost or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_own_name_with_closures"
              c:identifier="g_bus_own_name_with_closures"
              shadows="bus_own_name"
              version="2.26">
      <doc xml:whitespace="preserve">Version of g_bus_own_name() using closures instead of callbacks for
easier binding in other languages.
g_bus_unown_name() to stop owning the name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">An identifier (never 0) that an be used with</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type of bus to own a name on.</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The well-known name to own.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of flags from the #GBusNameOwnerFlags enumeration.</doc>
          <type name="BusNameOwnerFlags" c:type="GBusNameOwnerFlags"/>
        </parameter>
        <parameter name="bus_acquired_closure"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">#GClosure to invoke when connected to the bus of type @bus_type or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="name_acquired_closure"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">#GClosure to invoke when @name is acquired or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="name_lost_closure"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">#GClosure to invoke when @name is lost or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_unown_name"
              c:identifier="g_bus_unown_name"
              version="2.26">
      <doc xml:whitespace="preserve">Stops owning a name.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="owner_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">An identifier obtained from g_bus_own_name()</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_unwatch_name"
              c:identifier="g_bus_unwatch_name"
              version="2.26">
      <doc xml:whitespace="preserve">Stops watching a name.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="watcher_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">An identifier obtained from g_bus_watch_name()</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_watch_name"
              c:identifier="g_bus_watch_name"
              shadowed-by="bus_watch_name_with_closures"
              version="2.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Starts watching @name on the bus specified by @bus_type and calls
known to have a owner respectively known to lose its
owner. Callbacks will be invoked in the &lt;link
linkend="g-main-context-push-thread-default"&gt;thread-default main
loop&lt;/link&gt; of the thread you are calling this function from.
You are guaranteed that one of the handlers will be invoked after
calling this function. When you are done watching the name, just
call g_bus_unwatch_name() with the watcher id this function
returns.
If the name vanishes or appears (for example the application owning
the name could restart), the handlers are also invoked. If the
#GDBusConnection that is used for watching the name disconnects, then
possible to access the name.
Another guarantee is that invocations of @name_appeared_handler
and @name_vanished_handler are guaranteed to alternate; that
is, if @name_appeared_handler is invoked then you are
guaranteed that the next time one of the handlers is invoked, it
will be @name_vanished_handler. The reverse is also true.
This behavior makes it very simple to write applications that wants
to take action when a certain name exists, see &lt;xref
linkend="gdbus-watching-names"/&gt;. Basically, the application
should create object proxies in @name_appeared_handler and destroy
them again (if any) in @name_vanished_handler.
g_bus_unwatch_name() to stop watching the name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">An identifier (never 0) that an be used with</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type of bus to watch a name on.</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name (well-known or unique) to watch.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags from the #GBusNameWatcherFlags enumeration.</doc>
          <type name="BusNameWatcherFlags" c:type="GBusNameWatcherFlags"/>
        </parameter>
        <parameter name="name_appeared_handler" transfer-ownership="none">
          <doc xml:whitespace="preserve">Handler to invoke when @name is known to exist or %NULL.</doc>
          <type name="BusNameAppearedCallback"
                c:type="GBusNameAppearedCallback"/>
        </parameter>
        <parameter name="name_vanished_handler"
                   transfer-ownership="none"
                   scope="notified"
                   closure="5"
                   destroy="6">
          <doc xml:whitespace="preserve">Handler to invoke when @name is known to not exist or %NULL.</doc>
          <type name="BusNameVanishedCallback"
                c:type="GBusNameVanishedCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">User data to pass to handlers.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data_free_func"
                   transfer-ownership="none"
                   scope="async">
          <doc xml:whitespace="preserve">Function for freeing @user_data or %NULL.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_watch_name_on_connection"
              c:identifier="g_bus_watch_name_on_connection"
              shadowed-by="bus_watch_name_on_connection_with_closures"
              version="2.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Like g_bus_watch_name() but takes a #GDBusConnection instead of a
#GBusType.
g_bus_unwatch_name() to stop watching the name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">An identifier (never 0) that an be used with</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name (well-known or unique) to watch.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags from the #GBusNameWatcherFlags enumeration.</doc>
          <type name="BusNameWatcherFlags" c:type="GBusNameWatcherFlags"/>
        </parameter>
        <parameter name="name_appeared_handler" transfer-ownership="none">
          <doc xml:whitespace="preserve">Handler to invoke when @name is known to exist or %NULL.</doc>
          <type name="BusNameAppearedCallback"
                c:type="GBusNameAppearedCallback"/>
        </parameter>
        <parameter name="name_vanished_handler"
                   transfer-ownership="none"
                   scope="notified"
                   closure="5"
                   destroy="6">
          <doc xml:whitespace="preserve">Handler to invoke when @name is known to not exist or %NULL.</doc>
          <type name="BusNameVanishedCallback"
                c:type="GBusNameVanishedCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">User data to pass to handlers.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data_free_func"
                   transfer-ownership="none"
                   scope="async">
          <doc xml:whitespace="preserve">Function for freeing @user_data or %NULL.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_watch_name_on_connection_with_closures"
              c:identifier="g_bus_watch_name_on_connection_with_closures"
              shadows="bus_watch_name_on_connection"
              version="2.26">
      <doc xml:whitespace="preserve">Version of g_bus_watch_name_on_connection() using closures instead of callbacks for
easier binding in other languages.
g_bus_unwatch_name() to stop watching the name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">An identifier (never 0) that an be used with</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GDBusConnection.</doc>
          <type name="DBusConnection" c:type="GDBusConnection*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name (well-known or unique) to watch.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags from the #GBusNameWatcherFlags enumeration.</doc>
          <type name="BusNameWatcherFlags" c:type="GBusNameWatcherFlags"/>
        </parameter>
        <parameter name="name_appeared_closure"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">#GClosure to invoke when @name is known to exist or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="name_vanished_closure"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">#GClosure to invoke when @name is known to not exist or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bus_watch_name_with_closures"
              c:identifier="g_bus_watch_name_with_closures"
              shadows="bus_watch_name"
              version="2.26">
      <doc xml:whitespace="preserve">Version of g_bus_watch_name() using closures instead of callbacks for
easier binding in other languages.
g_bus_unwatch_name() to stop watching the name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">An identifier (never 0) that an be used with</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type of bus to watch a name on.</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name (well-known or unique) to watch.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags from the #GBusNameWatcherFlags enumeration.</doc>
          <type name="BusNameWatcherFlags" c:type="GBusNameWatcherFlags"/>
        </parameter>
        <parameter name="name_appeared_closure"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">#GClosure to invoke when @name is known to exist or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="name_vanished_closure"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">#GClosure to invoke when @name is known to not exist or %NULL.</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_can_be_executable"
              c:identifier="g_content_type_can_be_executable">
      <doc xml:whitespace="preserve">Checks if a content type can be executable. Note that for instance
things like text files can be executables (i.e. scripts and batch files).
can be executable, %FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the file type corresponds to a type that</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a content type string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_equals" c:identifier="g_content_type_equals">
      <doc xml:whitespace="preserve">Compares two content types for equality.
%FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the two strings are identical or equivalent,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a content type string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="type2" transfer-ownership="none">
          <doc xml:whitespace="preserve">a content type string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_from_mime_type"
              c:identifier="g_content_type_from_mime_type"
              version="2.18">
      <doc xml:whitespace="preserve">Tries to find a content type based on the mime type name.
or %NULL. Free with g_free()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">Newly allocated string with content type</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="mime_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a mime type string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_get_description"
              c:identifier="g_content_type_get_description">
      <doc xml:whitespace="preserve">Gets the human readable description of the content type.
returned string with g_free()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a short description of the content type @type. Free the</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a content type string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_get_icon"
              c:identifier="g_content_type_get_icon">
      <doc xml:whitespace="preserve">Gets the icon for a content type.
object with g_object_unref()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">#GIcon corresponding to the content type. Free the returned</doc>
        <type name="Icon" c:type="GIcon*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a content type string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_get_mime_type"
              c:identifier="g_content_type_get_mime_type">
      <doc xml:whitespace="preserve">Gets the mime type for the content type, if one is registered.
or %NULL if unknown.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the registered mime type for the given @type,</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a content type string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_guess" c:identifier="g_content_type_guess">
      <doc xml:whitespace="preserve">Guesses the content type based on example data. If the function is
uncertain, @result_uncertain will be set to %TRUE. Either @filename
or @data may be %NULL, in which case the guess will be based solely
on the other argument.
given data. Free with g_free()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a string indicating a guessed content type for the</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a string, or %NULL</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a stream of data, or %NULL</doc>
          <array length="2" c:type="guchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="data_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of @data</doc>
          <type name="gulong" c:type="gsize"/>
        </parameter>
        <parameter name="result_uncertain"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">return location for the certainty of the result, or %NULL</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_guess_for_tree"
              c:identifier="g_content_type_guess_for_tree"
              version="2.18">
      <doc xml:whitespace="preserve">Tries to guess the type of the tree with root @root, by
looking at the files it contains. The result is an array
of content types, with the best guess coming first.
The types returned all have the form x-content/foo, e.g.
x-content/audio-cdda (for audio CDs) or x-content/image-dcf
(for a camera memory card). See the &lt;ulink url="http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec"&gt;shared-mime-info&lt;/ulink&gt;
specification for more on x-content types.
This function is useful in the implementation of
g_mount_guess_content_type().
or %NULL. Free with g_strfreev()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">an %NULL-terminated array of zero or more content types,</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="root" transfer-ownership="none">
          <doc xml:whitespace="preserve">the root of the tree to guess a type for</doc>
          <type name="File" c:type="GFile*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_is_a" c:identifier="g_content_type_is_a">
      <doc xml:whitespace="preserve">Determines if @type is a subset of @supertype.
%FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @type is a kind of @supertype,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a content type string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="supertype" transfer-ownership="none">
          <doc xml:whitespace="preserve">a content type string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_is_unknown"
              c:identifier="g_content_type_is_unknown">
      <doc xml:whitespace="preserve">Checks if the content type is the generic "unknown" type.
On UNIX this is the "application/octet-stream" mimetype,
while on win32 it is "*".</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the type is the unknown type.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a content type string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_types_get_registered"
              c:identifier="g_content_types_get_registered">
      <doc xml:whitespace="preserve">Gets a list of strings containing all the registered content types
known to the system. The list and its data should be freed using
&lt;programlisting&gt;
g_list_foreach (list, g_free, NULL);
g_list_free (list);
&lt;/programlisting&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">#GList of the registered content types</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="utf8"/>
        </type>
      </return-value>
    </function>
    <function name="dbus_address_get_for_bus_sync"
              c:identifier="g_dbus_address_get_for_bus_sync"
              version="2.26"
              throws="1">
      <doc xml:whitespace="preserve">Synchronously looks up the D-Bus address for the well-known message
bus instance specified by @bus_type. This may involve using various
platform specific mechanisms.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A valid D-Bus address string for @bus_type or %NULL if @error is set.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="bus_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GBusType.</doc>
          <type name="BusType" c:type="GBusType"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_address_get_stream"
              c:identifier="g_dbus_address_get_stream"
              version="2.26">
      <doc xml:whitespace="preserve">Asynchronously connects to an endpoint specified by @address and
sets up the connection so it is in a state to run the client-side
of the D-Bus authentication conversation.
When the operation is finished, @callback will be invoked. You can
then call g_dbus_address_get_stream_finish() to get the result of
the operation.
This is an asynchronous failable function. See
g_dbus_address_get_stream_sync() for the synchronous version.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none">
          <doc xml:whitespace="preserve">A valid D-Bus address.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="async"
                   closure="3">
          <doc xml:whitespace="preserve">A #GAsyncReadyCallback to call when the request is satisfied.</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Data to pass to @callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_address_get_stream_finish"
              c:identifier="g_dbus_address_get_stream_finish"
              version="2.26"
              throws="1">
      <doc xml:whitespace="preserve">Finishes an operation started with g_dbus_address_get_stream().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A #GIOStream or %NULL if @error is set.</doc>
        <type name="IOStream" c:type="GIOStream*"/>
      </return-value>
      <parameters>
        <parameter name="res" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_address_get_stream().</doc>
          <type name="AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
        <parameter name="out_guid" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL or return location to store the GUID extracted from @address, if any.</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_address_get_stream_sync"
              c:identifier="g_dbus_address_get_stream_sync"
              version="2.26"
              throws="1">
      <doc xml:whitespace="preserve">Synchronously connects to an endpoint specified by @address and
sets up the connection so it is in a state to run the client-side
of the D-Bus authentication conversation.
This is a synchronous failable function. See
g_dbus_address_get_stream() for the asynchronous version.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A #GIOStream or %NULL if @error is set.</doc>
        <type name="IOStream" c:type="GIOStream*"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none">
          <doc xml:whitespace="preserve">A valid D-Bus address.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="out_guid" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL or return location to store the GUID extracted from @address, if any.</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">A #GCancellable or %NULL.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_annotation_info_lookup"
              c:identifier="g_dbus_annotation_info_lookup"
              version="2.26">
      <doc xml:whitespace="preserve">Looks up the value of an annotation.
This cost of this function is O(n) in number of annotations.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The value or %NULL if not found. Do not free, it is owned by @annotations.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="annotations" transfer-ownership="none">
          <doc xml:whitespace="preserve">A %NULL-terminated array of annotations or %NULL.</doc>
          <type name="DBusAnnotationInfo" c:type="GDBusAnnotationInfo**"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the annotation to look up.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_encode_gerror"
              c:identifier="g_dbus_error_encode_gerror"
              version="2.26">
      <doc xml:whitespace="preserve">Creates a D-Bus error name to use for @error. If @error matches
a registered error (cf. g_dbus_error_register_error()), the corresponding
D-Bus error name will be returned.
Otherwise the a name of the form
&lt;literal&gt;org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE&lt;/literal&gt;
will be used. This allows other GDBus applications to map the error
on the wire back to a #GError using g_dbus_error_new_for_dbus_error().
This function is typically only used in object mappings to put a
#GError on the wire. Regular applications should not use it.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A D-Bus error name (never %NULL). Free with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GError.</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_get_remote_error"
              c:identifier="g_dbus_error_get_remote_error"
              version="2.26">
      <doc xml:whitespace="preserve">Gets the D-Bus error name used for @error, if any.
This function is guaranteed to return a D-Bus error name for all
#GError&lt;!-- --&gt;s returned from functions handling remote method
calls (e.g. g_dbus_connection_call_finish()) unless
g_dbus_error_strip_remote_error() has been used on @error.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">An allocated string or %NULL if the D-Bus error name could not be found. Free with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GError.</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_is_remote_error"
              c:identifier="g_dbus_error_is_remote_error"
              version="2.26">
      <doc xml:whitespace="preserve">Checks if @error represents an error received via D-Bus from a remote peer. If so,
use g_dbus_error_get_remote_error() to get the name of the error.
%FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @error represents an error from a remote peer,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GError.</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_new_for_dbus_error"
              c:identifier="g_dbus_error_new_for_dbus_error"
              version="2.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a #GError based on the contents of @dbus_error_name and
Errors registered with g_dbus_error_register_error() will be looked
up using @dbus_error_name and if a match is found, the error domain
and code is used. Applications can use g_dbus_error_get_remote_error()
to recover @dbus_error_name.
If a match against a registered error is not found and the D-Bus
error name is in a form as returned by g_dbus_error_encode_gerror()
the error domain and code encoded in the name is used to
create the #GError. Also, @dbus_error_name is added to the error message
such that it can be recovered with g_dbus_error_get_remote_error().
Otherwise, a #GError with the error code %G_IO_ERROR_DBUS_ERROR
in the #G_IO_ERROR error domain is returned. Also, @dbus_error_name is
added to the error message such that it can be recovered with
g_dbus_error_get_remote_error().
In all three cases, @dbus_error_name can always be recovered from the
returned #GError using the g_dbus_error_get_remote_error() function
(unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).
This function is typically only used in object mappings to prepare
#GError instances for applications. Regular applications should not use
it.</doc>
      <return-value>
        <doc xml:whitespace="preserve">An allocated #GError. Free with g_error_free().</doc>
        <type name="GLib.Error" c:type="GError*"/>
      </return-value>
      <parameters>
        <parameter name="dbus_error_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">D-Bus error name.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="dbus_error_message" transfer-ownership="none">
          <doc xml:whitespace="preserve">D-Bus error message.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_quark" c:identifier="g_dbus_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="dbus_error_register_error"
              c:identifier="g_dbus_error_register_error"
              version="2.26">
      <doc xml:whitespace="preserve">Creates an association to map between @dbus_error_name and
#GError&lt;!-- --&gt;s specified by @error_domain and @error_code.
This is typically done in the routine that returns the #GQuark for
an error domain.
exists.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the association was created, %FALSE if it already</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="error_domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GQuark for a error domain.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="error_code" transfer-ownership="none">
          <doc xml:whitespace="preserve">An error code.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="dbus_error_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A D-Bus error name.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_register_error_domain"
              c:identifier="g_dbus_error_register_error_domain"
              version="2.26">
      <doc xml:whitespace="preserve">Helper function for associating a #GError error domain with D-Bus error names.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="error_domain_quark_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The error domain name.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="quark_volatile" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer where to store the #GQuark.</doc>
          <type name="gulong" c:type="gsize*"/>
        </parameter>
        <parameter name="entries" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to @num_entries #GDBusErrorEntry struct items.</doc>
          <type name="DBusErrorEntry" c:type="GDBusErrorEntry*"/>
        </parameter>
        <parameter name="num_entries" transfer-ownership="none">
          <doc xml:whitespace="preserve">Number of items to register.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_set_dbus_error"
              c:identifier="g_dbus_error_set_dbus_error"
              version="2.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Does nothing if @error is %NULL. Otherwise sets *@error to
a new #GError created with g_dbus_error_new_for_dbus_error()
with @dbus_error_message prepend with @format (unless %NULL).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to a #GError or %NULL.</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="dbus_error_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">D-Bus error name.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="dbus_error_message" transfer-ownership="none">
          <doc xml:whitespace="preserve">D-Bus error message.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format to prepend to @dbus_error_message or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_set_dbus_error_valist"
              c:identifier="g_dbus_error_set_dbus_error_valist"
              version="2.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Like g_dbus_error_set_dbus_error() but intended for language bindings.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to a #GError or %NULL.</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="dbus_error_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">D-Bus error name.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="dbus_error_message" transfer-ownership="none">
          <doc xml:whitespace="preserve">D-Bus error message.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format to prepend to @dbus_error_message or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:whitespace="preserve">Arguments for @format.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_strip_remote_error"
              c:identifier="g_dbus_error_strip_remote_error"
              version="2.26">
      <doc xml:whitespace="preserve">Looks for extra information in the error message used to recover
the D-Bus error name and strips it if found. If stripped, the
message field in @error will correspond exactly to what was
received on the wire.
This is typically used when presenting errors to the end user.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if information was stripped, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GError.</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_error_unregister_error"
              c:identifier="g_dbus_error_unregister_error"
              version="2.26">
      <doc xml:whitespace="preserve">Destroys an association previously set up with g_dbus_error_register_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the association was destroyed, %FALSE if it wasn't found.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="error_domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GQuark for a error domain.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="error_code" transfer-ownership="none">
          <doc xml:whitespace="preserve">An error code.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="dbus_error_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A D-Bus error name.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_generate_guid"
              c:identifier="g_dbus_generate_guid"
              version="2.26">
      <doc xml:whitespace="preserve">Generate a D-Bus GUID that can be used with
e.g. g_dbus_connection_new().
See the D-Bus specification regarding what strings are valid D-Bus
GUID (for example, D-Bus GUIDs are not RFC-4122 compliant).</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A valid D-Bus GUID. Free with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
    </function>
    <function name="dbus_is_address"
              c:identifier="g_dbus_is_address"
              version="2.26">
      <doc xml:whitespace="preserve">Checks if @string is a D-Bus address.
This doesn't check if @string is actually supported by #GDBusServer
or #GDBusConnection - use g_dbus_is_supported_address() to do more
checks.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @string is a valid D-Bus address, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_guid" c:identifier="g_dbus_is_guid" version="2.26">
      <doc xml:whitespace="preserve">Checks if @string is a D-Bus GUID.
See the D-Bus specification regarding what strings are valid D-Bus
GUID (for example, D-Bus GUIDs are not RFC-4122 compliant).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @string is a guid, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The string to check.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_interface_name"
              c:identifier="g_dbus_is_interface_name"
              version="2.26">
      <doc xml:whitespace="preserve">Checks if @string is a valid D-Bus interface name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if valid, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The string to check.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_member_name"
              c:identifier="g_dbus_is_member_name"
              version="2.26">
      <doc xml:whitespace="preserve">Checks if @string is a valid D-Bus member (e.g. signal or method) name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if valid, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The string to check.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_name" c:identifier="g_dbus_is_name" version="2.26">
      <doc xml:whitespace="preserve">Checks if @string is a valid D-Bus bus name (either unique or well-known).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if valid, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The string to check.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_supported_address"
              c:identifier="g_dbus_is_supported_address"
              version="2.26"
              throws="1">
      <doc xml:whitespace="preserve">Like g_dbus_is_address() but also checks if the library suppors the
transports in @string and that key/value pairs for each transport
are valid.
supported by this library, %FALSE if @error is set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @string is a valid D-Bus address that is</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_is_unique_name"
              c:identifier="g_dbus_is_unique_name"
              version="2.26">
      <doc xml:whitespace="preserve">Checks if @string is a valid D-Bus unique bus name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if valid, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The string to check.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_hash" c:identifier="g_file_hash">
      <doc xml:whitespace="preserve">Creates a hash value for a #GFile.
This call does no blocking i/o.
integer that can be used as hash value for the #GFile.
This function is intended for easily hashing a #GFile to
add to a #GHashTable or similar data structure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if @file is not a valid #GFile, otherwise an</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="file" transfer-ownership="none">
          <doc xml:whitespace="preserve">#gconstpointer to a #GFile.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_new_for_commandline_arg"
              c:identifier="g_file_new_for_commandline_arg">
      <doc xml:whitespace="preserve">Creates a #GFile with the given argument from the command line. The value of
relative to the current working directory.
This operation never fails, but the returned object might not support any
I/O operation if @arg points to a malformed path.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GFile.</doc>
        <type name="File" c:type="GFile*"/>
      </return-value>
      <parameters>
        <parameter name="arg" transfer-ownership="none">
          <doc xml:whitespace="preserve">a command line string.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_new_for_path" c:identifier="g_file_new_for_path">
      <doc xml:whitespace="preserve">Constructs a #GFile for a given path. This operation never
fails, but the returned object might not support any I/O
operation if @path is malformed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GFile for the given @path.</doc>
        <type name="File" c:type="GFile*"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing a relative or absolute path. The string must be encoded in the glib filename encoding.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_new_for_uri" c:identifier="g_file_new_for_uri">
      <doc xml:whitespace="preserve">Constructs a #GFile for a given URI. This operation never
fails, but the returned object might not support any I/O
operation if @uri is malformed or if the uri type is
not supported.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #GFile for the given @uri.</doc>
        <type name="File" c:type="GFile*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">a UTF8 string containing a URI.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_parse_name" c:identifier="g_file_parse_name">
      <doc xml:whitespace="preserve">Constructs a #GFile with the given @parse_name (i.e. something given by g_file_get_parse_name()).
This operation never fails, but the returned object might not support any I/O
operation if the @parse_name cannot be parsed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GFile.</doc>
        <type name="File" c:type="GFile*"/>
      </return-value>
      <parameters>
        <parameter name="parse_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a file name or path to be parsed.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="icon_hash" c:identifier="g_icon_hash">
      <doc xml:whitespace="preserve">Gets a hash for an icon.
use in a #GHashTable or similar data structure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a #guint containing a hash for the @icon, suitable for</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="icon" transfer-ownership="none">
          <doc xml:whitespace="preserve">#gconstpointer to an icon object.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="icon_new_for_string"
              c:identifier="g_icon_new_for_string"
              version="2.20"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Generate a #GIcon instance from @str. This function can fail if
If your application or library provides one or more #GIcon
implementations you need to ensure that each #GType is registered
with the type system prior to calling g_icon_new_for_string().</doc>
      <return-value>
        <doc xml:whitespace="preserve">An object implementing the #GIcon interface or %NULL if</doc>
        <type name="Icon" c:type="GIcon*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string obtained via g_icon_to_string().</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="initable_new"
              c:identifier="g_initable_new"
              version="2.22"
              introspectable="0">
      <doc xml:whitespace="preserve">Helper function for constructing #GInitiable object. This is
similar to g_object_new() but also initializes the object
and returns %NULL, setting an error on failure.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated #GObject, or %NULL on error</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="object_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType supporting #GInitable.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GError location to store the error occuring, or %NULL to ignore.</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="first_property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first property, or %NULL if no properties</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="initable_new_valist"
              c:identifier="g_initable_new_valist"
              version="2.22"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Helper function for constructing #GInitiable object. This is
similar to g_object_new_valist() but also initializes the object
and returns %NULL, setting an error on failure.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated #GObject, or %NULL on error</doc>
        <type name="GObject.Object" c:type="GObject*"/>
      </return-value>
      <parameters>
        <parameter name="object_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType supporting #GInitable.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="first_property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first property, followed by the value, and other property value pairs, and ended by %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:whitespace="preserve">The var args list generated from @first_property_name.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="initable_newv"
              c:identifier="g_initable_newv"
              version="2.22"
              throws="1">
      <doc xml:whitespace="preserve">Helper function for constructing #GInitiable object. This is
similar to g_object_newv() but also initializes the object
and returns %NULL, setting an error on failure.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated #GObject, or %NULL on error</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="object_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType supporting #GInitable.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_parameters" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of parameters in @parameters</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="parameters" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parameters to use to construct the object</doc>
          <type name="GObject.Parameter" c:type="GParameter*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_error_from_errno" c:identifier="g_io_error_from_errno">
      <doc xml:whitespace="preserve">Converts errno.h error codes into GIO error codes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GIOErrorEnum value for the given errno.h error number.</doc>
        <type name="IOErrorEnum" c:type="GIOErrorEnum"/>
      </return-value>
      <parameters>
        <parameter name="err_no" transfer-ownership="none">
          <doc xml:whitespace="preserve">Error number as defined in errno.h.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_error_quark" c:identifier="g_io_error_quark">
      <doc xml:whitespace="preserve">Gets the GIO Error Quark.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a #GQuark.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="io_extension_get_type"
              c:identifier="g_io_extension_get_type">
      <doc xml:whitespace="preserve">Gets the type associated with @extension.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the type of @extension</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="extension" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GIOExtension</doc>
          <type name="IOExtension" c:type="GIOExtension*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_extension_point_implement"
              c:identifier="g_io_extension_point_implement"
              introspectable="0">
      <doc xml:whitespace="preserve">Registers @type as extension for the extension point with name
If @type has already been registered as an extension for this
extension point, the existing #GIOExtension object is returned.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a #GIOExtension object for #GType</doc>
        <type name="IOExtension" c:type="GIOExtension*"/>
      </return-value>
      <parameters>
        <parameter name="extension_point_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the extension point</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType to register as extension</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="extension_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name for the extension</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:whitespace="preserve">the priority for the extension</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_extension_point_lookup"
              c:identifier="g_io_extension_point_lookup"
              introspectable="0">
      <doc xml:whitespace="preserve">Looks up an existing extension point.
registered extension point with the given name</doc>
      <return-value>
        <doc xml:whitespace="preserve">the #GIOExtensionPoint, or %NULL if there is no</doc>
        <type name="IOExtensionPoint" c:type="GIOExtensionPoint*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the extension point</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_extension_point_register"
              c:identifier="g_io_extension_point_register"
              introspectable="0">
      <doc xml:whitespace="preserve">Registers an extension point.
and should not be freed</doc>
      <return-value>
        <doc xml:whitespace="preserve">the new #GIOExtensionPoint. This object is owned by GIO</doc>
        <type name="IOExtensionPoint" c:type="GIOExtensionPoint*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the extension point</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_modules_load_all_in_directory"
              c:identifier="g_io_modules_load_all_in_directory">
      <doc xml:whitespace="preserve">Loads all the modules in the specified directory.
If don't require all modules to be initialized (and thus registering
all gtypes) then you can use g_io_modules_scan_all_in_directory()
which allows delayed/lazy loading of modules.
from the directory,
All the modules are loaded into memory, if you want to
unload them (enabling on-demand loading) you must call
g_type_module_unuse() on all the modules. Free the list
with g_list_free().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a list of #GIOModules loaded</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="IOModule"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="dirname" transfer-ownership="none">
          <doc xml:whitespace="preserve">pathname for a directory containing modules to load.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_modules_scan_all_in_directory"
              c:identifier="g_io_modules_scan_all_in_directory"
              version="2.24">
      <doc xml:whitespace="preserve">Scans all the modules in the specified directory, ensuring that
any extension point implemented by a module is registered.
This may not actually load and initialize all the types in each
module, some modules may be lazily loaded and initialized when
an extension point it implementes is used with e.g.
g_io_extension_point_get_extensions() or
g_io_extension_point_get_extension_by_name().
If you need to guarantee that all types are loaded in all the modules,
use g_io_modules_scan_all_in_directory().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dirname" transfer-ownership="none">
          <doc xml:whitespace="preserve">pathname for a directory containing modules to scan.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_scheduler_cancel_all_jobs"
              c:identifier="g_io_scheduler_cancel_all_jobs">
      <doc xml:whitespace="preserve">Cancels all cancellable I/O jobs.
A job is cancellable if a #GCancellable was passed into
g_io_scheduler_push_job().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="io_scheduler_push_job"
              c:identifier="g_io_scheduler_push_job">
      <doc xml:whitespace="preserve">Schedules the I/O job to run.
regardless whether the job was cancelled or has run to completion.
If @cancellable is not %NULL, it can be used to cancel the I/O job
by calling g_cancellable_cancel() or by calling
g_io_scheduler_cancel_all_jobs().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="job_func"
                   transfer-ownership="none"
                   scope="notified"
                   closure="1"
                   destroy="2">
          <doc xml:whitespace="preserve">a #GIOSchedulerJobFunc.</doc>
          <type name="IOSchedulerJobFunc" c:type="GIOSchedulerJobFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data to pass to @job_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">a #GDestroyNotify for @user_data, or %NULL</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="io_priority" transfer-ownership="none">
          <doc xml:whitespace="preserve">the &lt;link linkend="gioscheduler"&gt;I/O priority&lt;/link&gt; of the request.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
          <type name="Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="keyfile_settings_backend_new"
              c:identifier="g_keyfile_settings_backend_new">
      <doc xml:whitespace="preserve">Creates a keyfile-backed #GSettingsBackend.
The filename of the keyfile to use is given by @filename.
All settings read to or written from the backend must fall under the
path given in @root_path (which must start and end with a slash and
not contain two consecutive slashes).  @root_path may be "/".
If @root_group is non-%NULL then it specifies the name of the keyfile
group used for keys that are written directly below @root_path.  For
example, if @root_path is "/apps/example/" and @root_group is
"toplevel", then settings the key "/apps/example/enabled" to a value
of %TRUE will cause the following to appear in the keyfile:
|[
[toplevel]
enabled=true
]|
If @root_group is %NULL then it is not permitted to store keys
directly below the @root_path.
the name of the subpath (with the final slash stripped) is used as
the name of the keyfile group.  To continue the example, if
"/apps/example/profiles/default/font-size" were set to
12 then the following would appear in the keyfile:
|[
[profiles/default]
font-size=12
]|
The backend will refuse writes (and return writability as being
%FALSE) for keys outside of @root_path and, in the event that
Writes will also be refused if the backend detects that it has the
writable).
There is no checking done for your key namespace clashing with the
syntax of the key file format.  For example, if you have '[' or ']'
characters in your path names or '=' in your key names you may be in
trouble.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a keyfile-backed #GSettingsBackend</doc>
        <type name="SettingsBackend" c:type="GSettingsBackend*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">the filename of the keyfile</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="root_path" transfer-ownership="none">
          <doc xml:whitespace="preserve">the path under which all settings keys appear</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="root_group" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">the group name corresponding to</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="proxy_get_default_for_protocol"
              c:identifier="g_proxy_get_default_for_protocol"
              version="2.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Lookup "gio-proxy" extension point for a proxy implementation that supports
specified protocol.</doc>
      <return-value>
        <doc xml:whitespace="preserve">return a #GProxy or NULL if protocol is not supported.</doc>
        <type name="Proxy" c:type="GProxy*"/>
      </return-value>
      <parameters>
        <parameter name="protocol" transfer-ownership="none">
          <doc xml:whitespace="preserve">the proxy protocol name (e.g. http, socks, etc)</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="proxy_resolver_get_default"
              c:identifier="g_proxy_resolver_get_default"
              version="2.26">
      <doc xml:whitespace="preserve">Gets the default #GProxyResolver for the system.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the default #GProxyResolver.</doc>
        <type name="ProxyResolver" c:type="GProxyResolver*"/>
      </return-value>
    </function>
    <function name="resolver_error_quark"
              c:identifier="g_resolver_error_quark"
              version="2.22">
      <doc xml:whitespace="preserve">Gets the #GResolver Error Quark.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a #GQuark.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="simple_async_report_error_in_idle"
              c:identifier="g_simple_async_report_error_in_idle"
              introspectable="0">
      <doc xml:whitespace="preserve">Reports an error in an asynchronous function in an idle function by
directly setting the contents of the #GAsyncResult with the given error
information.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GObject.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="async"
                   closure="2">
          <doc xml:whitespace="preserve">a #GAsyncReadyCallback.</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data passed to @callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GQuark containing the error domain (usually #G_IO_ERROR).</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="code" transfer-ownership="none">
          <doc xml:whitespace="preserve">a specific error code.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">a formatted error reporting string.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="simple_async_report_gerror_in_idle"
              c:identifier="g_simple_async_report_gerror_in_idle">
      <doc xml:whitespace="preserve">Reports an error in an idle function. Similar to
g_simple_async_report_error_in_idle(), but takes a #GError rather
than building a new one.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GObject.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="async"
                   closure="2">
          <doc xml:whitespace="preserve">a #GAsyncReadyCallback.</doc>
          <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data passed to @callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GError to report</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="srv_target_list_sort"
              c:identifier="g_srv_target_list_sort"
              version="2.22">
      <doc xml:whitespace="preserve">Sorts @targets in place according to the algorithm in RFC 2782.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the head of the sorted list.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="targets" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #GSrvTarget</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="unix_is_mount_path_system_internal"
              c:identifier="g_unix_is_mount_path_system_internal">
      <doc xml:whitespace="preserve">Determines if @mount_path is considered an implementation of the
OS. This is primarily used for hiding mountable and mounted volumes
that only are used in the OS and has little to no relevance to the
casual user.
of the OS.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @mount_path is considered an implementation detail</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mount_path" transfer-ownership="none">
          <doc xml:whitespace="preserve">a mount path, e.g. &lt;filename&gt;/media/disk&lt;/filename&gt; or &lt;filename&gt;/usr&lt;/filename&gt;</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_at"
              c:identifier="g_unix_mount_at"
              introspectable="0">
      <doc xml:whitespace="preserve">Gets a #GUnixMountEntry for a given mount path. If @time_read
is set, it will be filled with a unix timestamp for checking
if the mounts have changed since with g_unix_mounts_changed_since().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #GUnixMount.</doc>
        <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
      </return-value>
      <parameters>
        <parameter name="mount_path" transfer-ownership="none">
          <doc xml:whitespace="preserve">path for a possible unix mount.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="time_read" transfer-ownership="none">
          <doc xml:whitespace="preserve">guint64 to contain a timestamp.</doc>
          <type name="guint64" c:type="guint64*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_compare" c:identifier="g_unix_mount_compare">
      <doc xml:whitespace="preserve">Compares two unix mounts.
or less than @mount2, respectively.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">1, 0 or -1 if @mount1 is greater than, equal to,</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="mount1" transfer-ownership="none">
          <doc xml:whitespace="preserve">first #GUnixMountEntry to compare.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
        <parameter name="mount2" transfer-ownership="none">
          <doc xml:whitespace="preserve">second #GUnixMountEntry to compare.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_free" c:identifier="g_unix_mount_free">
      <doc xml:whitespace="preserve">Frees a unix mount.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GUnixMount.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_get_device_path"
              c:identifier="g_unix_mount_get_device_path">
      <doc xml:whitespace="preserve">Gets the device path for a unix mount.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a string containing the device path.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GUnixMount.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_get_fs_type"
              c:identifier="g_unix_mount_get_fs_type">
      <doc xml:whitespace="preserve">Gets the filesystem type for the unix mount.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a string containing the file system type.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GUnixMount.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_get_mount_path"
              c:identifier="g_unix_mount_get_mount_path">
      <doc xml:whitespace="preserve">Gets the mount path for a unix mount.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the mount path for @mount_entry.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #GUnixMountEntry to get the mount path for.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_guess_can_eject"
              c:identifier="g_unix_mount_guess_can_eject">
      <doc xml:whitespace="preserve">Guesses whether a Unix mount can be ejected.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @mount_entry is deemed to be ejectable.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GUnixMountEntry</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_guess_icon"
              c:identifier="g_unix_mount_guess_icon">
      <doc xml:whitespace="preserve">Guesses the icon of a Unix mount.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #GIcon</doc>
        <type name="Icon" c:type="GIcon*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GUnixMountEntry</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_guess_name"
              c:identifier="g_unix_mount_guess_name">
      <doc xml:whitespace="preserve">Guesses the name of a Unix mount.
The result is a translated string.
be freed with g_free()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A newly allocated string that must</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GUnixMountEntry</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_guess_should_display"
              c:identifier="g_unix_mount_guess_should_display">
      <doc xml:whitespace="preserve">Guesses whether a Unix mount should be displayed in the UI.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @mount_entry is deemed to be displayable.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GUnixMountEntry</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_is_readonly"
              c:identifier="g_unix_mount_is_readonly">
      <doc xml:whitespace="preserve">Checks if a unix mount is mounted read only.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @mount_entry is read only.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GUnixMount.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_is_system_internal"
              c:identifier="g_unix_mount_is_system_internal">
      <doc xml:whitespace="preserve">Checks if a unix mount is a system path.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the unix mount is for a system path.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mount_entry" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GUnixMount.</doc>
          <type name="UnixMountEntry" c:type="GUnixMountEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_points_changed_since"
              c:identifier="g_unix_mount_points_changed_since">
      <doc xml:whitespace="preserve">Checks if the unix mount points have changed since a given unix time.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the mount points have changed since @time.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="time" transfer-ownership="none">
          <doc xml:whitespace="preserve">guint64 to contain a timestamp.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mount_points_get"
              c:identifier="g_unix_mount_points_get">
      <doc xml:whitespace="preserve">Gets a #GList of #GUnixMountPoint containing the unix mount points.
If @time_read is set, it will be filled with the mount timestamp,
allowing for checking if the mounts have changed with
g_unix_mounts_points_changed_since().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #GList of the UNIX mountpoints.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="time_read" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">guint64 to contain a timestamp.</doc>
          <type name="guint64" c:type="guint64*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mounts_changed_since"
              c:identifier="g_unix_mounts_changed_since">
      <doc xml:whitespace="preserve">Checks if the unix mounts have changed since a given unix time.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the mounts have changed since @time.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="time" transfer-ownership="none">
          <doc xml:whitespace="preserve">guint64 to contain a timestamp.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_mounts_get" c:identifier="g_unix_mounts_get">
      <doc xml:whitespace="preserve">Gets a #GList of #GUnixMountEntry containing the unix mounts.
If @time_read is set, it will be filled with the mount
timestamp, allowing for checking if the mounts have changed
with g_unix_mounts_changed_since().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #GList of the UNIX mounts.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="time_read" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">guint64 to contain a timestamp, or %NULL</doc>
          <type name="guint64" c:type="guint64*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
