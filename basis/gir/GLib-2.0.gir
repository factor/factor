<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:doc="http://www.gtk.org/introspection/doc/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <package name="glib-2.0"/>
  <c:include name="glib.h"/>
  <doc:format name="gi-docgen"/>
  <namespace name="GLib" version="2.0" shared-library="libgobject-2.0.so.0,libglib-2.0.so.0" c:identifier-prefixes="G" c:symbol-prefixes="glib,g">
    <alias name="DateDay" c:type="GDateDay">
      <doc xml:space="preserve">Integer representing a day of the month; between 1 and 31.

The %G_DATE_BAD_DAY value represents an invalid day of the month.</doc>
      <type name="guint8" c:type="guint8"/>
    </alias>
    <alias name="DateYear" c:type="GDateYear">
      <doc xml:space="preserve">Integer type representing a year.

The %G_DATE_BAD_YEAR value is the invalid value. The year
must be 1 or higher; negative ([BCE](https://en.wikipedia.org/wiki/Common_Era))
years are not allowed.

The year is represented with four digits.</doc>
      <type name="guint16" c:type="guint16"/>
    </alias>
    <alias name="MainContextPusher" c:type="GMainContextPusher">
      <doc xml:space="preserve">Opaque type. See g_main_context_pusher_new() for details.</doc>
      <type name="none" c:type="void"/>
    </alias>
    <alias name="MutexLocker" c:type="GMutexLocker">
      <doc xml:space="preserve">Opaque type. See g_mutex_locker_new() for details.</doc>
      <type name="none" c:type="void"/>
    </alias>
    <alias name="Pid" c:type="GPid">
      <doc xml:space="preserve">A type which is used to hold a process identification.

On UNIX, processes are identified by a process id (an integer),
while Windows uses process handles (which are pointers).

GPid is used in GLib only for descendant processes spawned with
the g_spawn functions.</doc>
      <type name="gint" c:type="int"/>
    </alias>
    <alias name="Quark" c:type="GQuark">
      <doc xml:space="preserve">A GQuark is a non-zero integer which uniquely identifies a
particular string.

A GQuark value of zero is associated to `NULL`.

Given either the string or the `GQuark` identifier it is possible to
retrieve the other.

Quarks are used for both
[datasets and keyed data lists](datalist-and-dataset.html).

To create a new quark from a string, use [func@GLib.quark_from_string]
or [func@GLib.quark_from_static_string].

To find the string corresponding to a given `GQuark`, use
[func@GLib.quark_to_string].

To find the `GQuark` corresponding to a given string, use
[func@GLib.quark_try_string].

Another use for the string pool maintained for the quark functions
is string interning, using [func@GLib.intern_string] or
[func@GLib.intern_static_string]. An interned string is a canonical
representation for a string. One important advantage of interned
strings is that they can be compared for equality by a simple
pointer comparison, rather than using `strcmp()`.</doc>
      <type name="guint32" c:type="guint32"/>
    </alias>
    <alias name="RWLockReaderLocker" c:type="GRWLockReaderLocker">
      <doc xml:space="preserve">Opaque type. See g_rw_lock_reader_locker_new() for details.</doc>
      <type name="none" c:type="void"/>
    </alias>
    <alias name="RWLockWriterLocker" c:type="GRWLockWriterLocker">
      <doc xml:space="preserve">Opaque type. See g_rw_lock_writer_locker_new() for details.</doc>
      <type name="none" c:type="void"/>
    </alias>
    <alias name="RecMutexLocker" c:type="GRecMutexLocker">
      <doc xml:space="preserve">Opaque type. See g_rec_mutex_locker_new() for details.</doc>
      <type name="none" c:type="void"/>
    </alias>
    <alias name="RefString" c:type="GRefString">
      <doc xml:space="preserve">A typedef for a reference-counted string. A pointer to a #GRefString can be
treated like a standard `char*` array by all code, but can additionally have
`g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be
called on `char*` arrays not allocated using g_ref_string_new().

If using #GRefString with autocleanups, g_autoptr() must be used rather than
g_autofree(), so that the reference counting metadata is also freed.</doc>
      <type name="gchar" c:type="char"/>
    </alias>
    <alias name="Strv" c:type="GStrv">
      <doc xml:space="preserve">A typedef alias for gchar**. This is mostly useful when used together with
`g_auto()`.</doc>
      <type name="utf8" c:type="gchar**"/>
    </alias>
    <alias name="Time" c:type="GTime" deprecated="1" deprecated-version="2.62">
      <doc xml:space="preserve">Simply a replacement for `time_t`. It has been deprecated
since it is not equivalent to `time_t` on 64-bit platforms
with a 64-bit `time_t`.

Unrelated to #GTimer.

Note that #GTime is defined to always be a 32-bit integer,
unlike `time_t` which may be 64-bit on some systems. Therefore,
#GTime will overflow in the year 2038, and you cannot use the
address of a #GTime variable as argument to the UNIX time()
function.

Instead, do the following:

|[&lt;!-- language="C" --&gt;
time_t ttime;
GTime gtime;

time (&amp;ttime);
gtime = (GTime)ttime;
]|</doc>
      <doc-deprecated xml:space="preserve">This is not [Y2038-safe](https://en.wikipedia.org/wiki/Year_2038_problem).
   Use #GDateTime or #time_t instead.</doc-deprecated>
      <type name="gint32" c:type="gint32"/>
    </alias>
    <alias name="TimeSpan" c:type="GTimeSpan">
      <doc xml:space="preserve">A value representing an interval of time, in microseconds.</doc>
      <type name="gint64" c:type="gint64"/>
    </alias>
    <function-macro name="ALIGNOF" c:identifier="G_ALIGNOF" version="2.60" introspectable="0">
      <doc xml:space="preserve">Return the minimal alignment required by the platform ABI for values of the given
type. The address of a variable or struct member of the given type must always be
a multiple of this alignment. For example, most platforms require int variables
to be aligned at a 4-byte boundary, so `G_ALIGNOF (int)` is 4 on most platforms.

Note this is not necessarily the same as the value returned by GCC&#x2019;s
`__alignof__` operator, which returns the preferred alignment for a type.
The preferred alignment may be a stricter alignment than the minimal
alignment.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">a type-name</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="ALLOCATOR_LIST" value="1" c:type="G_ALLOCATOR_LIST" deprecated="1" deprecated-version="2.10">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ALLOCATOR_NODE" value="3" c:type="G_ALLOCATOR_NODE" deprecated="1" deprecated-version="2.10">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ALLOCATOR_SLIST" value="2" c:type="G_ALLOCATOR_SLIST" deprecated="1" deprecated-version="2.10">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ALLOC_AND_FREE" value="2" c:type="G_ALLOC_AND_FREE" deprecated="1" deprecated-version="2.10">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ALLOC_ONLY" value="1" c:type="G_ALLOC_ONLY" deprecated="1" deprecated-version="2.10">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ANALYZER_ANALYZING" value="1" c:type="G_ANALYZER_ANALYZING">
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="APPROX_VALUE" c:identifier="G_APPROX_VALUE" version="2.58" introspectable="0">
      <doc xml:space="preserve">Evaluates to a truth value if the absolute difference between @a and @b is
smaller than @epsilon, and to a false value otherwise.

For example,
- `G_APPROX_VALUE (5, 6, 2)` evaluates to true
- `G_APPROX_VALUE (3.14, 3.15, 0.001)` evaluates to false
- `G_APPROX_VALUE (n, 0.f, FLT_EPSILON)` evaluates to true if `n` is within
  the single precision floating point epsilon from zero</doc>
      <parameters>
        <parameter name="a">
          <doc xml:space="preserve">a numeric value</doc>
        </parameter>
        <parameter name="b">
          <doc xml:space="preserve">a numeric value</doc>
        </parameter>
        <parameter name="epsilon">
          <doc xml:space="preserve">a numeric value that expresses the tolerance between @a and @b</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="ASCII_DTOSTR_BUF_SIZE" value="39" c:type="G_ASCII_DTOSTR_BUF_SIZE">
      <doc xml:space="preserve">A good size for a buffer to be passed into [func@GLib.ascii_dtostr].
It is guaranteed to be enough for all output of that function
on systems with 64bit IEEE-compatible doubles.

The typical usage would be something like:
```C
char buf[G_ASCII_DTOSTR_BUF_SIZE];

fprintf (out, "value=%s\n", g_ascii_dtostr (buf, sizeof (buf), value));
```</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="ATEXIT" c:identifier="g_ATEXIT" introspectable="0">
      <parameters>
        <parameter name="proc">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="ATOMIC_REF_COUNT_INIT" value="1" c:type="G_ATOMIC_REF_COUNT_INIT" version="2.78">
      <doc xml:space="preserve">Evaluates to the initial reference count for `gatomicrefcount`.

This macro is useful for initializing `gatomicrefcount` fields inside
structures, for instance:

|[&lt;!-- language="C" --&gt;
typedef struct {
  gatomicrefcount ref_count;
  char *name;
  char *address;
} Person;

static const Person default_person = {
  .ref_count = G_ATOMIC_REF_COUNT_INIT,
  .name = "Default name",
  .address = "Default address",
};
]|</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="AUTO_LOCK" c:identifier="G_AUTO_LOCK" version="2.80" introspectable="0">
      <doc xml:space="preserve">Works like [func@GLib.MUTEX_AUTO_LOCK], but for a lock defined with
[func@GLib.LOCK_DEFINE].

This feature is only supported on GCC and clang. This macro is not defined on
other compilers and should not be used in programs that are intended to be
portable to those compilers.</doc>
      <parameters>
        <parameter name="name">
          <doc xml:space="preserve">the name of the lock</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="Allocator" c:type="GAllocator" disguised="1" opaque="1" deprecated="1" deprecated-version="2.10">
      <method name="free" c:identifier="g_allocator_free" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="allocator" transfer-ownership="none">
            <type name="Allocator" c:type="GAllocator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_allocator_new" introspectable="0" deprecated="1" deprecated-version="2.10">
        <return-value>
          <type name="Allocator" c:type="GAllocator*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_preallocs" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="Array" c:type="GArray" copy-function="g_array_ref" free-function="g_array_unref" glib:type-name="GArray" glib:get-type="g_array_get_type" c:symbol-prefix="array">
      <doc xml:space="preserve">Contains the public fields of a `GArray`.</doc>
      <field name="data" writable="1">
        <doc xml:space="preserve">a pointer to the element data. The data may be moved as
    elements are added to the `GArray`.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="len" writable="1">
        <doc xml:space="preserve">the number of elements in the `GArray` not including the
    possible terminating zero element</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <function name="append_vals" c:identifier="g_array_append_vals" introspectable="0">
        <doc xml:space="preserve">Adds @len elements onto the end of the array.

@data may be `NULL` if (and only if) @len is zero. If @len is zero, this
function is a no-op.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GArray`</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to the elements to append to the end of the array</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements to append</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="binary_search" c:identifier="g_array_binary_search" version="2.62" introspectable="0">
        <doc xml:space="preserve">Checks whether @target exists in @array by performing a binary
search based on the given comparison function @compare_func which
gets pointers to items as arguments. If the element is found, true
is returned and the element&#x2019;s index is returned in @out_match_index
(if non-`NULL`). Otherwise, false is returned and @out_match_index
is undefined. This search is using a binary search, so the @array must
absolutely be sorted to return a correct result (if not, the function may
produce false-negative).

This example defines a comparison function and searches an element in a
`GArray`:
```c
static gint
cmpint (gconstpointer a, gconstpointer b)
{
  const gint *_a = a;
  const gint *_b = b;

  return *_a - *_b;
}
...
gint i = 424242;
guint matched_index;
gboolean result = g_array_binary_search (garray, &amp;i, cmpint, &amp;matched_index);
...
```</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @target is one of the elements of @array; false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="target" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to the item to look up</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">a comparison function to locate @target</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
          <parameter name="out_match_index" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the return location
   for the index of the element, if found</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="copy" c:identifier="g_array_copy" version="2.62" introspectable="0">
        <doc xml:space="preserve">Creates a shallow copy of a #GArray. If the array elements consist of
pointers to data, the pointers are copied but the actual data is not.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">The copy of @array</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="free" c:identifier="g_array_free" introspectable="0">
        <doc xml:space="preserve">Frees the memory allocated for the `GArray`. If @free_segment is
true it frees the memory block holding the elements as well. Pass
false if you want to free the `GArray` wrapper but preserve the
underlying array for use elsewhere. If the reference count of
@array is greater than one, the `GArray` wrapper is preserved but
the size of @array will be set to zero.

If array contents point to dynamically-allocated memory, they should
be freed separately if @free_segment is true and no @clear_func
function has been set for @array.

This function is not thread-safe. If using a `GArray` from multiple
threads, use only the atomic [func@GLib.Array.ref] and
[func@GLib.Array.unref] functions.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The allocated element data if @free_segment is false, otherwise
    `NULL`</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="full">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="free_segment" transfer-ownership="none">
            <doc xml:space="preserve">if true, the actual element data is freed as well</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_element_size" c:identifier="g_array_get_element_size" version="2.22" introspectable="0">
        <doc xml:space="preserve">Gets the size of the elements in @array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The size of each element, in bytes</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="insert_vals" c:identifier="g_array_insert_vals" introspectable="0">
        <doc xml:space="preserve">Inserts @len elements into a `GArray` at the given index.

If @index_ is greater than the array&#x2019;s current length, the array is expanded.
The elements between the old end of the array and the newly inserted elements
will be initialised to zero if the array was configured to clear elements;
otherwise their values will be undefined.

If @index_ is less than the array&#x2019;s current length, new entries will be
inserted into the array, and the existing entries above @index_ will be moved
upwards.

@data may be `NULL` if (and only if) @len is zero. If @len is zero, this
function is a no-op.</doc>
        <return-value>
          <doc xml:space="preserve">The `GArray`</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index to place the elements at</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to the elements to insert</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements to insert</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="g_array_new" introspectable="0">
        <doc xml:space="preserve">Creates a new `GArray` with a reference count of 1.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GArray`</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="zero_terminated" transfer-ownership="none">
            <doc xml:space="preserve">if true, the array should have an extra element at
    the end which is set to 0</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="clear_" transfer-ownership="none">
            <doc xml:space="preserve">if true, `GArray` elements should be automatically cleared
    to 0 when they are allocated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="element_size" transfer-ownership="none">
            <doc xml:space="preserve">the size of each element in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_take" c:identifier="g_array_new_take" version="2.76" introspectable="0">
        <doc xml:space="preserve">Creates a new `GArray` with @data as array data, @len as length and a
reference count of 1.

This avoids having to copy the data manually, when it can just be
inherited.
After this call, @data belongs to the `GArray` and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with [func@GLib.free].

In case the elements need to be cleared when the array is freed, use
[func@GLib.Array.set_clear_func] to set a [callback@GLib.DestroyNotify]
function to perform such task.

Do not use it if @len or @element_size are greater than
 [`G_MAXUINT`](types.html#guint). `GArray` stores the length of its data in
 `guint`, which may be shorter than `gsize`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">an array of
  elements of @element_size</doc>
            <array length="1" zero-terminated="0" c:type="gpointer">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="clear" transfer-ownership="none">
            <doc xml:space="preserve">if true, `GArray` elements should be automatically cleared
    to 0 when they are allocated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="element_size" transfer-ownership="none">
            <doc xml:space="preserve">the size of each element in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_take_zero_terminated" c:identifier="g_array_new_take_zero_terminated" version="2.76" introspectable="0">
        <doc xml:space="preserve">Creates a new `GArray` with @data as array data, computing the length of it
and setting the reference count to 1.

This avoids having to copy the data manually, when it can just be
inherited.
After this call, @data belongs to the `GArray` and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with [func@GLib.free].

The length is calculated by iterating through @data until the first `NULL`
element is found.

In case the elements need to be cleared when the array is freed, use
[func@GLib.Array.set_clear_func] to set a [callback@GLib.DestroyNotify]
function to perform such task.

Do not use it if @data length or @element_size are greater than
[`G_MAXUINT`](types.html#guint). `GArray` stores the length of its data in
`guint`, which may be shorter than `gsize`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GArray`</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">an array
    of elements of @element_size, `NULL` terminated</doc>
            <array c:type="gpointer">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="clear" transfer-ownership="none">
            <doc xml:space="preserve">if true, `GArray` elements should be automatically cleared
    to 0 when they are allocated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="element_size" transfer-ownership="none">
            <doc xml:space="preserve">the size of each element in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="prepend_vals" c:identifier="g_array_prepend_vals" introspectable="0">
        <doc xml:space="preserve">Adds @len elements onto the start of the array.

@data may be `NULL` if (and only if) @len is zero. If @len is zero, this
function is a no-op.

This operation is slower than [func@GLib.Array.append_vals] since the
existing elements in the array have to be moved to make space for
the new elements.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GArray`</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to the elements to prepend to the start of the array</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements to prepend, which may be zero</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="ref" c:identifier="g_array_ref" version="2.22" introspectable="0">
        <doc xml:space="preserve">Atomically increments the reference count of @array by one.
This function is thread-safe and may be called from any thread.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The passed in `GArray`</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="remove_index" c:identifier="g_array_remove_index" introspectable="0">
        <doc xml:space="preserve">Removes the element at the given index from a `GArray`. The following
elements are moved down one place.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GArray`</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_index_fast" c:identifier="g_array_remove_index_fast" introspectable="0">
        <doc xml:space="preserve">Removes the element at the given index from a `GArray`. The last
element in the array is used to fill in the space, so this function
does not preserve the order of the `GArray`. But it is faster than
[func@GLib.Array.remove_index].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GArray`</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the element to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_range" c:identifier="g_array_remove_range" version="2.4" introspectable="0">
        <doc xml:space="preserve">Removes the given number of elements starting at the given index
from a `GArray`. The following elements are moved to close the gap.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GArray`</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the first element to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_clear_func" c:identifier="g_array_set_clear_func" version="2.32" introspectable="0">
        <doc xml:space="preserve">Sets a function to clear an element of @array.

The @clear_func will be called when an element in the array
data segment is removed and when the array is freed and data
segment is deallocated as well. @clear_func will be passed a
pointer to the element to clear, rather than the element itself.

Note that in contrast with other uses of [callback@GLib.DestroyNotify]
functions, @clear_func is expected to clear the contents of
the array element it is given, but not free the element itself.

```c
typedef struct
{
  gchar *str;
  GObject *obj;
} ArrayElement;

static void
array_element_clear (ArrayElement *element)
{
  g_clear_pointer (&amp;element-&gt;str, g_free);
  g_clear_object (&amp;element-&gt;obj);
}

// main code
GArray *garray = g_array_new (FALSE, FALSE, sizeof (ArrayElement));
g_array_set_clear_func (garray, (GDestroyNotify) array_element_clear);
// assign data to the structure
g_array_free (garray, TRUE);
```</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="clear_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to clear an element of @array</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_size" c:identifier="g_array_set_size" introspectable="0">
        <doc xml:space="preserve">Sets the size of the array, expanding it if necessary. If the array
was created with @clear_ set to true, the new elements are set to 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GArray`</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the new size of the #GArray</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="sized_new" c:identifier="g_array_sized_new" introspectable="0">
        <doc xml:space="preserve">Creates a new `GArray` with @reserved_size elements preallocated and
a reference count of 1. This avoids frequent reallocation, if you
are going to add many elements to the array. Note however that the
size of the array is still 0.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GArray`</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="zero_terminated" transfer-ownership="none">
            <doc xml:space="preserve">if true, the array should have an extra element at
    the end with all bits cleared</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="clear_" transfer-ownership="none">
            <doc xml:space="preserve">if true, all bits in the array should be cleared to 0 on
    allocation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="element_size" transfer-ownership="none">
            <doc xml:space="preserve">the size of each element in the array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="reserved_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements preallocated</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort" c:identifier="g_array_sort" introspectable="0">
        <doc xml:space="preserve">Sorts a `GArray` using @compare_func which should be a `qsort()`-style
comparison function (returns less than zero for first arg is less
than second arg, zero for equal, greater zero if first arg is
greater than second arg).

This is guaranteed to be a stable sort since version 2.32.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">a comparison function</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort_with_data" c:identifier="g_array_sort_with_data" introspectable="0">
        <doc xml:space="preserve">Like [func@GLib.Array.sort], but the comparison function receives an extra
user data argument.

This is guaranteed to be a stable sort since version 2.32.

There used to be a comment here about making the sort stable by
using the addresses of the elements in the comparison function.
This did not actually work, so any such code should be removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">a comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="steal" c:identifier="g_array_steal" version="2.64" introspectable="0">
        <doc xml:space="preserve">Frees the data in the array and resets the size to zero, while
the underlying array is preserved for use elsewhere and returned
to the caller.

Note that if the array was created with the @zero_terminate
property set to true, this may still return `NULL` if the length
of the array was zero and data was not yet allocated.

If array elements contain dynamically-allocated memory,
the array elements should also be freed by the caller.

A short example of use:
```c
...
gpointer data;
gsize data_len;
data = g_array_steal (some_array, &amp;data_len);
...
```</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The allocated element data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="len" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a pointer to retrieve the number of
   elements of the original array</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref" c:identifier="g_array_unref" version="2.22" introspectable="0">
        <doc xml:space="preserve">Atomically decrements the reference count of @array by one. If the
reference count drops to 0, the effect is the same as calling
[func@GLib.Array.free] with @free_segment set to true. This function is
thread-safe and may be called from any thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="full">
            <doc xml:space="preserve">an array</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="AsciiType" c:type="GAsciiType">
      <member name="alnum" value="1" c:identifier="G_ASCII_ALNUM">
      </member>
      <member name="alpha" value="2" c:identifier="G_ASCII_ALPHA">
      </member>
      <member name="cntrl" value="4" c:identifier="G_ASCII_CNTRL">
      </member>
      <member name="digit" value="8" c:identifier="G_ASCII_DIGIT">
      </member>
      <member name="graph" value="16" c:identifier="G_ASCII_GRAPH">
      </member>
      <member name="lower" value="32" c:identifier="G_ASCII_LOWER">
      </member>
      <member name="print" value="64" c:identifier="G_ASCII_PRINT">
      </member>
      <member name="punct" value="128" c:identifier="G_ASCII_PUNCT">
      </member>
      <member name="space" value="256" c:identifier="G_ASCII_SPACE">
      </member>
      <member name="upper" value="512" c:identifier="G_ASCII_UPPER">
      </member>
      <member name="xdigit" value="1024" c:identifier="G_ASCII_XDIGIT">
      </member>
    </bitfield>
    <record name="AsyncQueue" c:type="GAsyncQueue" disguised="1" opaque="1" copy-function="g_async_queue_ref" free-function="g_async_queue_unref">
      <doc xml:space="preserve">An opaque data structure which represents an asynchronous queue.

It should only be accessed through the `g_async_queue_*` functions.</doc>
      <method name="length" c:identifier="g_async_queue_length">
        <doc xml:space="preserve">Returns the length of the queue.

Actually this function returns the number of data items in
the queue minus the number of waiting threads, so a negative
value means waiting threads, and a positive value means available
entries in the @queue. A return value of 0 could mean n entries
in the queue and n threads waiting. This can happen due to locking
of the queue or due to scheduling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the @queue</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue.</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="length_unlocked" c:identifier="g_async_queue_length_unlocked">
        <doc xml:space="preserve">Returns the length of the queue.

Actually this function returns the number of data items in
the queue minus the number of waiting threads, so a negative
value means waiting threads, and a positive value means available
entries in the @queue. A return value of 0 could mean n entries
in the queue and n threads waiting. This can happen due to locking
of the queue or due to scheduling.

This function must be called while holding the @queue's lock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the @queue.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lock" c:identifier="g_async_queue_lock">
        <doc xml:space="preserve">Acquires the @queue's lock. If another thread is already
holding the lock, this call will block until the lock
becomes available.

Call g_async_queue_unlock() to drop the lock again.

While holding the lock, you can only call the
g_async_queue_*_unlocked() functions on @queue. Otherwise,
deadlock may occur.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="g_async_queue_pop">
        <doc xml:space="preserve">Pops data from the @queue. If @queue is empty, this function
blocks until data becomes available.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">data from the queue</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_unlocked" c:identifier="g_async_queue_pop_unlocked">
        <doc xml:space="preserve">Pops data from the @queue. If @queue is empty, this function
blocks until data becomes available.

This function must be called while holding the @queue's lock.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">data from the queue.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="g_async_queue_push">
        <doc xml:space="preserve">Pushes the @data into the @queue.

The @data parameter must not be %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve">data to push onto the @queue</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_front" c:identifier="g_async_queue_push_front" version="2.46">
        <doc xml:space="preserve">Pushes the @item into the @queue. @item must not be %NULL.
In contrast to g_async_queue_push(), this function
pushes the new item ahead of the items already in the queue,
so that it will be the next one to be popped off the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="full">
            <doc xml:space="preserve">data to push into the @queue</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_front_unlocked" c:identifier="g_async_queue_push_front_unlocked" version="2.46">
        <doc xml:space="preserve">Pushes the @item into the @queue. @item must not be %NULL.
In contrast to g_async_queue_push_unlocked(), this function
pushes the new item ahead of the items already in the queue,
so that it will be the next one to be popped off the queue.

This function must be called while holding the @queue's lock.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="full">
            <doc xml:space="preserve">data to push into the @queue</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_sorted" c:identifier="g_async_queue_push_sorted" version="2.10">
        <doc xml:space="preserve">Inserts @data into @queue using @func to determine the new
position.

This function requires that the @queue is sorted before pushing on
new elements, see g_async_queue_sort().

This function will lock @queue before it sorts the queue and unlock
it when it is finished.

For an example of @func see g_async_queue_sort().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve">the @data to push into the @queue</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the #GCompareDataFunc is used to sort @queue</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_sorted_unlocked" c:identifier="g_async_queue_push_sorted_unlocked" version="2.10">
        <doc xml:space="preserve">Inserts @data into @queue using @func to determine the new
position.

The sort function @func is passed two elements of the @queue.
It should return 0 if they are equal, a negative value if the
first element should be higher in the @queue or a positive value
if the first element should be lower in the @queue than the second
element.

This function requires that the @queue is sorted before pushing on
new elements, see g_async_queue_sort().

This function must be called while holding the @queue's lock.

For an example of @func see g_async_queue_sort().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve">the data to push into the @queue</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the #GCompareDataFunc is used to sort @queue</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_unlocked" c:identifier="g_async_queue_push_unlocked">
        <doc xml:space="preserve">Pushes the @data into the @queue.

The @data parameter must not be %NULL.

This function must be called while holding the @queue's lock.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve">data to push onto the @queue</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_async_queue_ref">
        <doc xml:space="preserve">Increases the reference count of the asynchronous @queue by 1.
You do not need to hold the lock to call this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the @queue that was passed in (since 2.6)</doc>
          <type name="AsyncQueue" c:type="GAsyncQueue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref_unlocked" c:identifier="g_async_queue_ref_unlocked" deprecated="1" deprecated-version="2.8">
        <doc xml:space="preserve">Increases the reference count of the asynchronous @queue by 1.</doc>
        <doc-deprecated xml:space="preserve">Reference counting is done atomically.
so g_async_queue_ref() can be used regardless of the @queue's
lock.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_async_queue_remove" version="2.46">
        <doc xml:space="preserve">Remove an item from the queue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the item was removed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">the data to remove from the @queue</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_unlocked" c:identifier="g_async_queue_remove_unlocked" version="2.46">
        <doc xml:space="preserve">Remove an item from the queue.

This function must be called while holding the @queue's lock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the item was removed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">the data to remove from the @queue</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="sort" c:identifier="g_async_queue_sort" version="2.10">
        <doc xml:space="preserve">Sorts @queue using @func.

The sort function @func is passed two elements of the @queue.
It should return 0 if they are equal, a negative value if the
first element should be higher in the @queue or a positive value
if the first element should be lower in the @queue than the second
element.

This function will lock @queue before it sorts the queue and unlock
it when it is finished.

If you were sorting a list of priority numbers to make sure the
lowest priority would be at the top of the queue, you could use:
|[&lt;!-- language="C" --&gt;
 gint32 id1;
 gint32 id2;

 id1 = GPOINTER_TO_INT (element1);
 id2 = GPOINTER_TO_INT (element2);

 return (id1 &gt; id2 ? +1 : id1 == id2 ? 0 : -1);
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the #GCompareDataFunc is used to sort @queue</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="sort_unlocked" c:identifier="g_async_queue_sort_unlocked" version="2.10">
        <doc xml:space="preserve">Sorts @queue using @func.

The sort function @func is passed two elements of the @queue.
It should return 0 if they are equal, a negative value if the
first element should be higher in the @queue or a positive value
if the first element should be lower in the @queue than the second
element.

This function must be called while holding the @queue's lock.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the #GCompareDataFunc is used to sort @queue</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="timed_pop" c:identifier="g_async_queue_timed_pop" deprecated="1">
        <doc xml:space="preserve">Pops data from the @queue. If the queue is empty, blocks until
@end_time or until data becomes available.

If no data is received before @end_time, %NULL is returned.

To easily calculate @end_time, a combination of g_get_real_time()
and g_time_val_add() can be used.</doc>
        <doc-deprecated xml:space="preserve">use g_async_queue_timeout_pop().</doc-deprecated>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">data from the queue or %NULL, when no
  data is received before @end_time.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="end_time" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal, determining the final time</doc>
            <type name="TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
      <method name="timed_pop_unlocked" c:identifier="g_async_queue_timed_pop_unlocked" deprecated="1">
        <doc xml:space="preserve">Pops data from the @queue. If the queue is empty, blocks until
@end_time or until data becomes available.

If no data is received before @end_time, %NULL is returned.

To easily calculate @end_time, a combination of g_get_real_time()
and g_time_val_add() can be used.

This function must be called while holding the @queue's lock.</doc>
        <doc-deprecated xml:space="preserve">use g_async_queue_timeout_pop_unlocked().</doc-deprecated>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">data from the queue or %NULL, when no
  data is received before @end_time.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="end_time" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal, determining the final time</doc>
            <type name="TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
      <method name="timeout_pop" c:identifier="g_async_queue_timeout_pop">
        <doc xml:space="preserve">Pops data from the @queue. If the queue is empty, blocks for
@timeout microseconds, or until data becomes available.

If no data is received before the timeout, %NULL is returned.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">data from the queue or %NULL, when no
  data is received before the timeout.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the number of microseconds to wait</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="timeout_pop_unlocked" c:identifier="g_async_queue_timeout_pop_unlocked">
        <doc xml:space="preserve">Pops data from the @queue. If the queue is empty, blocks for
@timeout microseconds, or until data becomes available.

If no data is received before the timeout, %NULL is returned.

This function must be called while holding the @queue's lock.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">data from the queue or %NULL, when no
  data is received before the timeout.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">the number of microseconds to wait</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="try_pop" c:identifier="g_async_queue_try_pop">
        <doc xml:space="preserve">Tries to pop data from the @queue. If no data is available,
%NULL is returned.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">data from the queue or %NULL, when no
  data is available immediately.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="try_pop_unlocked" c:identifier="g_async_queue_try_pop_unlocked">
        <doc xml:space="preserve">Tries to pop data from the @queue. If no data is available,
%NULL is returned.

This function must be called while holding the @queue's lock.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">data from the queue or %NULL, when no
  data is available immediately.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unlock" c:identifier="g_async_queue_unlock">
        <doc xml:space="preserve">Releases the queue's lock.

Calling this function when you have not acquired
the with g_async_queue_lock() leads to undefined
behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_async_queue_unref">
        <doc xml:space="preserve">Decreases the reference count of the asynchronous @queue by 1.

If the reference count went to 0, the @queue will be destroyed
and the memory allocated will be freed. So you are not allowed
to use the @queue afterwards, as it might have disappeared.
You do not need to hold the lock to call this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="full">
            <doc xml:space="preserve">a #GAsyncQueue.</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref_and_unlock" c:identifier="g_async_queue_unref_and_unlock" deprecated="1" deprecated-version="2.8">
        <doc xml:space="preserve">Decreases the reference count of the asynchronous @queue by 1
and releases the lock. This function must be called while holding
the @queue's lock. If the reference count went to 0, the @queue
will be destroyed and the memory allocated will be freed.</doc>
        <doc-deprecated xml:space="preserve">Reference counting is done atomically.
so g_async_queue_unref() can be used regardless of the @queue's
lock.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="full">
            <doc xml:space="preserve">a #GAsyncQueue</doc>
            <type name="AsyncQueue" c:type="GAsyncQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_async_queue_new">
        <doc xml:space="preserve">Creates a new asynchronous queue.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GAsyncQueue. Free with g_async_queue_unref()</doc>
          <type name="AsyncQueue" c:type="GAsyncQueue*"/>
        </return-value>
      </function>
      <function name="new_full" c:identifier="g_async_queue_new_full" version="2.16">
        <doc xml:space="preserve">Creates a new asynchronous queue and sets up a destroy notify
function that is used to free any remaining queue items when
the queue is destroyed after the final unref.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GAsyncQueue. Free with g_async_queue_unref()</doc>
          <type name="AsyncQueue" c:type="GAsyncQueue*"/>
        </return-value>
        <parameters>
          <parameter name="item_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">function to free queue elements</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <constant name="BIG_ENDIAN" value="4321" c:type="G_BIG_ENDIAN">
      <doc xml:space="preserve">Specifies one of the possible types of byte order.
See %G_BYTE_ORDER.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="BREAKPOINT" c:identifier="G_BREAKPOINT" introspectable="0">
      <doc xml:space="preserve">Inserts a breakpoint instruction into the code.

On architectures which support it, this is implemented as a soft interrupt
and on other architectures it raises a `SIGTRAP` signal.

`SIGTRAP` is used rather than abort() to allow breakpoints to be skipped past
in a debugger if they are not the desired target of debugging.</doc>
    </function-macro>
    <record name="BookmarkFile" c:type="GBookmarkFile" opaque="1" version="2.12" glib:type-name="GBookmarkFile" glib:get-type="g_bookmark_file_get_type" c:symbol-prefix="bookmark_file">
      <doc xml:space="preserve">`GBookmarkFile` lets you parse, edit or create files containing bookmarks.

Bookmarks refer to a URI, along with some meta-data about the resource
pointed by the URI like its MIME type, the application that is registering
the bookmark and the icon that should be used to represent the bookmark.
The data is stored using the
[Desktop Bookmark Specification](https://www.freedesktop.org/wiki/Specifications/desktop-bookmark-spec/).

The syntax of the bookmark files is described in detail inside the
Desktop Bookmark Specification, here is a quick summary: bookmark
files use a sub-class of the XML Bookmark Exchange Language
specification, consisting of valid UTF-8 encoded XML, under the
`&lt;xbel&gt;` root element; each bookmark is stored inside a
`&lt;bookmark&gt;` element, using its URI: no relative paths can
be used inside a bookmark file. The bookmark may have a user defined
title and description, to be used instead of the URI. Under the
`&lt;metadata&gt;` element, with its owner attribute set to
`http://freedesktop.org`, is stored the meta-data about a resource
pointed by its URI. The meta-data consists of the resource's MIME
type; the applications that have registered a bookmark; the groups
to which a bookmark belongs to; a visibility flag, used to set the
bookmark as "private" to the applications and groups that has it
registered; the URI and MIME type of an icon, to be used when
displaying the bookmark inside a GUI.

Here is an example of a bookmark file:
[bookmarks.xbel](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/glib/tests/bookmarks.xbel)

A bookmark file might contain more than one bookmark; each bookmark
is accessed through its URI.

The important caveat of bookmark files is that when you add a new
bookmark you must also add the application that is registering it, using
[method@GLib.BookmarkFile.add_application] or [method@GLib.BookmarkFile.set_application_info].
If a bookmark has no applications then it won't be dumped when creating
the on disk representation, using [method@GLib.BookmarkFile.to_data] or
[method@GLib.BookmarkFile.to_file].</doc>
      <constructor name="new" c:identifier="g_bookmark_file_new" version="2.12">
        <doc xml:space="preserve">Creates a new empty #GBookmarkFile object.

Use g_bookmark_file_load_from_file(), g_bookmark_file_load_from_data()
or g_bookmark_file_load_from_data_dirs() to read an existing bookmark
file.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an empty #GBookmarkFile</doc>
          <type name="BookmarkFile" c:type="GBookmarkFile*"/>
        </return-value>
      </constructor>
      <method name="add_application" c:identifier="g_bookmark_file_add_application" version="2.12">
        <doc xml:space="preserve">Adds the application with @name and @exec to the list of
applications that have registered a bookmark for @uri into
@bookmark.

Every bookmark inside a #GBookmarkFile must have at least an
application registered.  Each application must provide a name, a
command line useful for launching the bookmark, the number of times
the bookmark has been registered by the application and the last
time the application registered this bookmark.

If @name is %NULL, the name of the application will be the
same returned by g_get_application_name(); if @exec is %NULL, the
command line will be a composition of the program name as
returned by g_get_prgname() and the "\%u" modifier, which will be
expanded to the bookmark's URI.

This function will automatically take care of updating the
registrations count and timestamping in case an application
with the same @name had already registered a bookmark for
@uri inside @bookmark.

If no bookmark for @uri is found, one is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the name of the application registering the bookmark
  or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="exec" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">command line to be used to launch the bookmark or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_group" c:identifier="g_bookmark_file_add_group" version="2.12">
        <doc xml:space="preserve">Adds @group to the list of groups to which the bookmark for @uri
belongs to.

If no bookmark for @uri is found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the group name to be added</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="g_bookmark_file_copy" version="2.76">
        <doc xml:space="preserve">Deeply copies a @bookmark #GBookmarkFile object to a new one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the copy of @bookmark. Use
  g_bookmark_free() when finished using it.</doc>
          <type name="BookmarkFile" c:type="GBookmarkFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">A #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_bookmark_file_free" version="2.12">
        <doc xml:space="preserve">Frees a #GBookmarkFile.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_added" c:identifier="g_bookmark_file_get_added" version="2.12" deprecated="1" deprecated-version="2.66" throws="1">
        <doc xml:space="preserve">Gets the time the bookmark for @uri was added to @bookmark

In the event the URI cannot be found, -1 is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <doc-deprecated xml:space="preserve">Use g_bookmark_file_get_added_date_time() instead, as
   `time_t` is deprecated due to the year 2038 problem.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a timestamp</doc>
          <type name="time_t" c:type="time_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_added_date_time" c:identifier="g_bookmark_file_get_added_date_time" version="2.66" throws="1">
        <doc xml:space="preserve">Gets the time the bookmark for @uri was added to @bookmark

In the event the URI cannot be found, %NULL is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GDateTime</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_app_info" c:identifier="g_bookmark_file_get_app_info" version="2.12" deprecated="1" deprecated-version="2.66" throws="1">
        <doc xml:space="preserve">Gets the registration information of @app_name for the bookmark for
@uri.  See g_bookmark_file_set_application_info() for more information about
the returned data.

The string returned in @app_exec must be freed.

In the event the URI cannot be found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
event that no application with name @app_name has registered a bookmark
for @uri,  %FALSE is returned and error is set to
%G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
the command line fails, an error of the %G_SHELL_ERROR domain is
set and %FALSE is returned.</doc>
        <doc-deprecated xml:space="preserve">Use g_bookmark_file_get_application_info() instead, as
   `time_t` is deprecated due to the year 2038 problem.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">an application's name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="exec" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the command line of the application, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="count" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the registration count, or %NULL</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="stamp" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the last registration time, or %NULL</doc>
            <type name="time_t" c:type="time_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_application_info" c:identifier="g_bookmark_file_get_application_info" version="2.66" throws="1">
        <doc xml:space="preserve">Gets the registration information of @app_name for the bookmark for
@uri.  See g_bookmark_file_set_application_info() for more information about
the returned data.

The string returned in @app_exec must be freed.

In the event the URI cannot be found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
event that no application with name @app_name has registered a bookmark
for @uri,  %FALSE is returned and error is set to
%G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
the command line fails, an error of the %G_SHELL_ERROR domain is
set and %FALSE is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">an application's name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="exec" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the command line of the application, or %NULL</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="count" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the registration count, or %NULL</doc>
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
          <parameter name="stamp" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the last registration time, or %NULL</doc>
            <type name="DateTime" c:type="GDateTime**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_applications" c:identifier="g_bookmark_file_get_applications" version="2.12" throws="1">
        <doc xml:space="preserve">Retrieves the names of the applications that have registered the
bookmark for @uri.

In the event the URI cannot be found, %NULL is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated %NULL-terminated array of strings.
  Use g_strfreev() to free it.</doc>
          <array length="1" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location of the length of the returned list, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_description" c:identifier="g_bookmark_file_get_description" version="2.12" throws="1">
        <doc xml:space="preserve">Retrieves the description of the bookmark for @uri.

In the event the URI cannot be found, %NULL is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string or %NULL if the specified
  URI cannot be found.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_groups" c:identifier="g_bookmark_file_get_groups" version="2.12" throws="1">
        <doc xml:space="preserve">Retrieves the list of group names of the bookmark for @uri.

In the event the URI cannot be found, %NULL is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.

The returned array is %NULL terminated, so @length may optionally
be %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated %NULL-terminated array of group names.
  Use g_strfreev() to free it.</doc>
          <array length="1" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the length of the returned string, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_icon" c:identifier="g_bookmark_file_get_icon" version="2.12" throws="1">
        <doc xml:space="preserve">Gets the icon of the bookmark for @uri.

In the event the URI cannot be found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the icon for the bookmark for the URI was found.
  You should free the returned strings.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="href" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the icon's location or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="mime_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the icon's MIME type or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_is_private" c:identifier="g_bookmark_file_get_is_private" version="2.12" throws="1">
        <doc xml:space="preserve">Gets whether the private flag of the bookmark for @uri is set.

In the event the URI cannot be found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
event that the private flag cannot be found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_INVALID_VALUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the private flag is set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mime_type" c:identifier="g_bookmark_file_get_mime_type" version="2.12" throws="1">
        <doc xml:space="preserve">Retrieves the MIME type of the resource pointed by @uri.

In the event the URI cannot be found, %NULL is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
event that the MIME type cannot be found, %NULL is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_INVALID_VALUE.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string or %NULL if the specified
  URI cannot be found.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_modified" c:identifier="g_bookmark_file_get_modified" version="2.12" deprecated="1" deprecated-version="2.66" throws="1">
        <doc xml:space="preserve">Gets the time when the bookmark for @uri was last modified.

In the event the URI cannot be found, -1 is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <doc-deprecated xml:space="preserve">Use g_bookmark_file_get_modified_date_time() instead, as
   `time_t` is deprecated due to the year 2038 problem.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a timestamp</doc>
          <type name="time_t" c:type="time_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_modified_date_time" c:identifier="g_bookmark_file_get_modified_date_time" version="2.66" throws="1">
        <doc xml:space="preserve">Gets the time when the bookmark for @uri was last modified.

In the event the URI cannot be found, %NULL is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GDateTime</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="g_bookmark_file_get_size" version="2.12">
        <doc xml:space="preserve">Gets the number of bookmarks inside @bookmark.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bookmarks</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_title" c:identifier="g_bookmark_file_get_title" version="2.12" throws="1">
        <doc xml:space="preserve">Returns the title of the bookmark for @uri.

If @uri is %NULL, the title of @bookmark is returned.

In the event the URI cannot be found, %NULL is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string or %NULL if the specified
  URI cannot be found.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a valid URI or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uris" c:identifier="g_bookmark_file_get_uris" version="2.12">
        <doc xml:space="preserve">Returns all URIs of the bookmarks in the bookmark file @bookmark.
The array of returned URIs will be %NULL-terminated, so @length may
optionally be %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated %NULL-terminated array of strings.
  Use g_strfreev() to free it.</doc>
          <array length="0" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the number of returned URIs, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_visited" c:identifier="g_bookmark_file_get_visited" version="2.12" deprecated="1" deprecated-version="2.66" throws="1">
        <doc xml:space="preserve">Gets the time the bookmark for @uri was last visited.

In the event the URI cannot be found, -1 is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <doc-deprecated xml:space="preserve">Use g_bookmark_file_get_visited_date_time() instead, as
   `time_t` is deprecated due to the year 2038 problem.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a timestamp.</doc>
          <type name="time_t" c:type="time_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_visited_date_time" c:identifier="g_bookmark_file_get_visited_date_time" version="2.66" throws="1">
        <doc xml:space="preserve">Gets the time the bookmark for @uri was last visited.

In the event the URI cannot be found, %NULL is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GDateTime</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_application" c:identifier="g_bookmark_file_has_application" version="2.12" throws="1">
        <doc xml:space="preserve">Checks whether the bookmark for @uri inside @bookmark has been
registered by application @name.

In the event the URI cannot be found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the application @name was found</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the application</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_group" c:identifier="g_bookmark_file_has_group" version="2.12" throws="1">
        <doc xml:space="preserve">Checks whether @group appears in the list of groups to which
the bookmark for @uri belongs to.

In the event the URI cannot be found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @group was found.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the group name to be searched</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_item" c:identifier="g_bookmark_file_has_item" version="2.12">
        <doc xml:space="preserve">Looks whether the desktop bookmark has an item with its URI set to @uri.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @uri is inside @bookmark, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_data" c:identifier="g_bookmark_file_load_from_data" version="2.12" throws="1">
        <doc xml:space="preserve">Loads a bookmark file from memory into an empty #GBookmarkFile
structure.  If the object cannot be created then @error is set to a
#GBookmarkFileError.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a desktop bookmark could be loaded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">an empty #GBookmarkFile struct</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">desktop bookmarks
   loaded in memory</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @data in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_data_dirs" c:identifier="g_bookmark_file_load_from_data_dirs" version="2.12" throws="1">
        <doc xml:space="preserve">This function looks for a desktop bookmark file named @file in the
paths returned from g_get_user_data_dir() and g_get_system_data_dirs(),
loads the file into @bookmark and returns the file's full path in
@full_path.  If the file could not be loaded then @error is
set to either a #GFileError or #GBookmarkFileError.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a key file could be loaded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a relative path to a filename to open and parse</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="full_path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for a string
   containing the full path of the file, or %NULL</doc>
            <type name="filename" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_file" c:identifier="g_bookmark_file_load_from_file" version="2.12" throws="1">
        <doc xml:space="preserve">Loads a desktop bookmark file into an empty #GBookmarkFile structure.
If the file could not be loaded then @error is set to either a #GFileError
or #GBookmarkFileError.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a desktop bookmark file could be loaded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">an empty #GBookmarkFile struct</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the path of a filename to load, in the
    GLib file name encoding</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="move_item" c:identifier="g_bookmark_file_move_item" version="2.12" throws="1">
        <doc xml:space="preserve">Changes the URI of a bookmark item from @old_uri to @new_uri.  Any
existing bookmark for @new_uri will be overwritten.  If @new_uri is
%NULL, then the bookmark is removed.

In the event the URI cannot be found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the URI was successfully changed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="old_uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_uri" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a valid URI, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_application" c:identifier="g_bookmark_file_remove_application" version="2.12" throws="1">
        <doc xml:space="preserve">Removes application registered with @name from the list of applications
that have registered a bookmark for @uri inside @bookmark.

In the event the URI cannot be found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
In the event that no application with name @app_name has registered
a bookmark for @uri,  %FALSE is returned and error is set to
%G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the application was successfully removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the application</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_group" c:identifier="g_bookmark_file_remove_group" version="2.12" throws="1">
        <doc xml:space="preserve">Removes @group from the list of groups to which the bookmark
for @uri belongs to.

In the event the URI cannot be found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
In the event no group was defined, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_INVALID_VALUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @group was successfully removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the group name to be removed</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_item" c:identifier="g_bookmark_file_remove_item" version="2.12" throws="1">
        <doc xml:space="preserve">Removes the bookmark for @uri from the bookmark file @bookmark.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the bookmark was removed successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_added" c:identifier="g_bookmark_file_set_added" version="2.12" deprecated="1" deprecated-version="2.66">
        <doc xml:space="preserve">Sets the time the bookmark for @uri was added into @bookmark.

If no bookmark for @uri is found then it is created.</doc>
        <doc-deprecated xml:space="preserve">Use g_bookmark_file_set_added_date_time() instead, as
   `time_t` is deprecated due to the year 2038 problem.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">a timestamp or -1 to use the current time</doc>
            <type name="time_t" c:type="time_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_added_date_time" c:identifier="g_bookmark_file_set_added_date_time" version="2.66">
        <doc xml:space="preserve">Sets the time the bookmark for @uri was added into @bookmark.

If no bookmark for @uri is found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="added" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_app_info" c:identifier="g_bookmark_file_set_app_info" version="2.12" deprecated="1" deprecated-version="2.66" throws="1">
        <doc xml:space="preserve">Sets the meta-data of application @name inside the list of
applications that have registered a bookmark for @uri inside
@bookmark.

You should rarely use this function; use g_bookmark_file_add_application()
and g_bookmark_file_remove_application() instead.

@name can be any UTF-8 encoded string used to identify an
application.
@exec can have one of these two modifiers: "\%f", which will
be expanded as the local file name retrieved from the bookmark's
URI; "\%u", which will be expanded as the bookmark's URI.
The expansion is done automatically when retrieving the stored
command line using the g_bookmark_file_get_application_info() function.
@count is the number of times the application has registered the
bookmark; if is &lt; 0, the current registration count will be increased
by one, if is 0, the application with @name will be removed from
the list of registered applications.
@stamp is the Unix time of the last registration; if it is -1, the
current time will be used.

If you try to remove an application by setting its registration count to
zero, and no bookmark for @uri is found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly,
in the event that no application @name has registered a bookmark
for @uri,  %FALSE is returned and error is set to
%G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.  Otherwise, if no bookmark
for @uri is found, one is created.</doc>
        <doc-deprecated xml:space="preserve">Use g_bookmark_file_set_application_info() instead, as
   `time_t` is deprecated due to the year 2038 problem.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the application's meta-data was successfully
  changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">an application's name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="exec" transfer-ownership="none">
            <doc xml:space="preserve">an application's command line</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of registrations done for this application</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="stamp" transfer-ownership="none">
            <doc xml:space="preserve">the time of the last registration for this application</doc>
            <type name="time_t" c:type="time_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_application_info" c:identifier="g_bookmark_file_set_application_info" version="2.66" throws="1">
        <doc xml:space="preserve">Sets the meta-data of application @name inside the list of
applications that have registered a bookmark for @uri inside
@bookmark.

You should rarely use this function; use g_bookmark_file_add_application()
and g_bookmark_file_remove_application() instead.

@name can be any UTF-8 encoded string used to identify an
application.
@exec can have one of these two modifiers: "\%f", which will
be expanded as the local file name retrieved from the bookmark's
URI; "\%u", which will be expanded as the bookmark's URI.
The expansion is done automatically when retrieving the stored
command line using the g_bookmark_file_get_application_info() function.
@count is the number of times the application has registered the
bookmark; if is &lt; 0, the current registration count will be increased
by one, if is 0, the application with @name will be removed from
the list of registered applications.
@stamp is the Unix time of the last registration.

If you try to remove an application by setting its registration count to
zero, and no bookmark for @uri is found, %FALSE is returned and
@error is set to %G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly,
in the event that no application @name has registered a bookmark
for @uri,  %FALSE is returned and error is set to
%G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.  Otherwise, if no bookmark
for @uri is found, one is created.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the application's meta-data was successfully
  changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">an application's name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="exec" transfer-ownership="none">
            <doc xml:space="preserve">an application's command line</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of registrations done for this application</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="stamp" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the time of the last registration for this application,
   which may be %NULL if @count is 0</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_description" c:identifier="g_bookmark_file_set_description" version="2.12">
        <doc xml:space="preserve">Sets @description as the description of the bookmark for @uri.

If @uri is %NULL, the description of @bookmark is set.

If a bookmark for @uri cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a valid URI or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_groups" c:identifier="g_bookmark_file_set_groups" version="2.12">
        <doc xml:space="preserve">Sets a list of group names for the item with URI @uri.  Each previously
set group name list is removed.

If @uri cannot be found then an item for it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">an item's URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="groups" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an array of
   group names, or %NULL to remove all groups</doc>
            <array length="2" zero-terminated="0" c:type="const gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">number of group name values in @groups</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon" c:identifier="g_bookmark_file_set_icon" version="2.12">
        <doc xml:space="preserve">Sets the icon for the bookmark for @uri. If @href is %NULL, unsets
the currently set icon. @href can either be a full URL for the icon
file or the icon name following the Icon Naming specification.

If no bookmark for @uri is found one is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="href" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the URI of the icon for the bookmark, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="mime_type" transfer-ownership="none">
            <doc xml:space="preserve">the MIME type of the icon for the bookmark</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_is_private" c:identifier="g_bookmark_file_set_is_private" version="2.12">
        <doc xml:space="preserve">Sets the private flag of the bookmark for @uri.

If a bookmark for @uri cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="is_private" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the bookmark should be marked as private</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mime_type" c:identifier="g_bookmark_file_set_mime_type" version="2.12">
        <doc xml:space="preserve">Sets @mime_type as the MIME type of the bookmark for @uri.

If a bookmark for @uri cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="mime_type" transfer-ownership="none">
            <doc xml:space="preserve">a MIME type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_modified" c:identifier="g_bookmark_file_set_modified" version="2.12" deprecated="1" deprecated-version="2.66">
        <doc xml:space="preserve">Sets the last time the bookmark for @uri was last modified.

If no bookmark for @uri is found then it is created.

The "modified" time should only be set when the bookmark's meta-data
was actually changed.  Every function of #GBookmarkFile that
modifies a bookmark also changes the modification time, except for
g_bookmark_file_set_visited_date_time().</doc>
        <doc-deprecated xml:space="preserve">Use g_bookmark_file_set_modified_date_time() instead, as
   `time_t` is deprecated due to the year 2038 problem.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="modified" transfer-ownership="none">
            <doc xml:space="preserve">a timestamp or -1 to use the current time</doc>
            <type name="time_t" c:type="time_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_modified_date_time" c:identifier="g_bookmark_file_set_modified_date_time" version="2.66">
        <doc xml:space="preserve">Sets the last time the bookmark for @uri was last modified.

If no bookmark for @uri is found then it is created.

The "modified" time should only be set when the bookmark's meta-data
was actually changed.  Every function of #GBookmarkFile that
modifies a bookmark also changes the modification time, except for
g_bookmark_file_set_visited_date_time().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="modified" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_title" c:identifier="g_bookmark_file_set_title" version="2.12">
        <doc xml:space="preserve">Sets @title as the title of the bookmark for @uri inside the
bookmark file @bookmark.

If @uri is %NULL, the title of @bookmark is set.

If a bookmark for @uri cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a valid URI or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="title" transfer-ownership="none">
            <doc xml:space="preserve">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_visited" c:identifier="g_bookmark_file_set_visited" version="2.12" deprecated="1" deprecated-version="2.66">
        <doc xml:space="preserve">Sets the time the bookmark for @uri was last visited.

If no bookmark for @uri is found then it is created.

The "visited" time should only be set if the bookmark was launched,
either using the command line retrieved by g_bookmark_file_get_application_info()
or by the default application for the bookmark's MIME type, retrieved
using g_bookmark_file_get_mime_type().  Changing the "visited" time
does not affect the "modified" time.</doc>
        <doc-deprecated xml:space="preserve">Use g_bookmark_file_set_visited_date_time() instead, as
   `time_t` is deprecated due to the year 2038 problem.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="visited" transfer-ownership="none">
            <doc xml:space="preserve">a timestamp or -1 to use the current time</doc>
            <type name="time_t" c:type="time_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_visited_date_time" c:identifier="g_bookmark_file_set_visited_date_time" version="2.66">
        <doc xml:space="preserve">Sets the time the bookmark for @uri was last visited.

If no bookmark for @uri is found then it is created.

The "visited" time should only be set if the bookmark was launched,
either using the command line retrieved by g_bookmark_file_get_application_info()
or by the default application for the bookmark's MIME type, retrieved
using g_bookmark_file_get_mime_type().  Changing the "visited" time
does not affect the "modified" time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="visited" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_data" c:identifier="g_bookmark_file_to_data" version="2.12" throws="1">
        <doc xml:space="preserve">This function outputs @bookmark as a string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
  a newly allocated string holding the contents of the #GBookmarkFile</doc>
          <array length="0" zero-terminated="0" c:type="gchar*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the length of the returned string, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_file" c:identifier="g_bookmark_file_to_file" version="2.12" throws="1">
        <doc xml:space="preserve">This function outputs @bookmark into a file.  The write process is
guaranteed to be atomic by using g_file_set_contents() internally.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file was successfully written.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bookmark" transfer-ownership="none">
            <doc xml:space="preserve">a #GBookmarkFile</doc>
            <type name="BookmarkFile" c:type="GBookmarkFile*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">path of the output file</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <function name="error_quark" c:identifier="g_bookmark_file_error_quark">
        <return-value transfer-ownership="none">
          <type name="Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </record>
    <enumeration name="BookmarkFileError" c:type="GBookmarkFileError" glib:error-domain="g-bookmark-file-error-quark">
      <doc xml:space="preserve">Error codes returned by bookmark file parsing.</doc>
      <member name="invalid_uri" value="0" c:identifier="G_BOOKMARK_FILE_ERROR_INVALID_URI">
        <doc xml:space="preserve">URI was ill-formed</doc>
      </member>
      <member name="invalid_value" value="1" c:identifier="G_BOOKMARK_FILE_ERROR_INVALID_VALUE">
        <doc xml:space="preserve">a requested field was not found</doc>
      </member>
      <member name="app_not_registered" value="2" c:identifier="G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED">
        <doc xml:space="preserve">a requested application did
    not register a bookmark</doc>
      </member>
      <member name="uri_not_found" value="3" c:identifier="G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND">
        <doc xml:space="preserve">a requested URI was not found</doc>
      </member>
      <member name="read" value="4" c:identifier="G_BOOKMARK_FILE_ERROR_READ">
        <doc xml:space="preserve">document was ill formed</doc>
      </member>
      <member name="unknown_encoding" value="5" c:identifier="G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING">
        <doc xml:space="preserve">the text being parsed was
    in an unknown encoding</doc>
      </member>
      <member name="write" value="6" c:identifier="G_BOOKMARK_FILE_ERROR_WRITE">
        <doc xml:space="preserve">an error occurred while writing</doc>
      </member>
      <member name="file_not_found" value="7" c:identifier="G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND">
        <doc xml:space="preserve">requested file was not found</doc>
      </member>
    </enumeration>
    <record name="ByteArray" c:type="GByteArray" copy-function="g_byte_array_ref" free-function="g_byte_array_unref" glib:type-name="GByteArray" glib:get-type="g_byte_array_get_type" c:symbol-prefix="byte_array">
      <doc xml:space="preserve">Contains the public fields of a `GByteArray`.</doc>
      <field name="data" writable="1">
        <doc xml:space="preserve">a pointer to the element data. The data may be moved as
    elements are added to the `GByteArray`</doc>
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="len" writable="1">
        <doc xml:space="preserve">the number of elements in the `GByteArray`</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <function name="append" c:identifier="g_byte_array_append">
        <doc xml:space="preserve">Adds the given bytes to the end of the `GByteArray`.
The array will grow in size automatically if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GByteArray`</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the byte data to be added</doc>
            <array length="2" zero-terminated="0" c:type="const guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to add</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="free" c:identifier="g_byte_array_free">
        <doc xml:space="preserve">Frees the memory allocated by the `GByteArray`. If @free_segment is
true it frees the actual byte data. If the reference count of
@array is greater than one, the `GByteArray` wrapper is preserved but
the size of @array will be set to zero.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The allocated element data if
  @free_segment is false, otherwise `NULL`.</doc>
          <array zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="full">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="free_segment" transfer-ownership="none">
            <doc xml:space="preserve">if true, the actual byte data is freed as well</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="free_to_bytes" c:identifier="g_byte_array_free_to_bytes" version="2.32">
        <doc xml:space="preserve">Transfers the data from the `GByteArray` into a new immutable
[struct@GLib.Bytes].

The `GByteArray` is freed unless the reference count of @array is greater
than one, in which the `GByteArray` wrapper is preserved but the size of
@array will be set to zero.

This is identical to using [ctor@GLib.Bytes.new_take] and
[func@GLib.ByteArray.free] together.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new immutable [struct@GLib.Bytes] representing
  same byte data that was in the array</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="full">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="g_byte_array_new">
        <doc xml:space="preserve">Creates a new `GByteArray` with a reference count of 1.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GByteArray`</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </function>
      <function name="new_take" c:identifier="g_byte_array_new_take" version="2.32">
        <doc xml:space="preserve">Creates a byte array containing the @data.
After this call, @data belongs to the `GByteArray` and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with [func@GLib.free].

Do not use it if @len is greater than [`G_MAXUINT`](types.html#guint).
`GByteArray` stores the length of its data in `guint`, which may be shorter
than `gsize`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GByteArray`</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve">the byte data for the array</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="prepend" c:identifier="g_byte_array_prepend">
        <doc xml:space="preserve">Adds the given data to the start of the `GByteArray`.
The array will grow in size automatically if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GByteArray`</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the byte data to be added</doc>
            <array length="2" zero-terminated="0" c:type="const guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to add</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="ref" c:identifier="g_byte_array_ref" version="2.22">
        <doc xml:space="preserve">Atomically increments the reference count of @array by one.
This function is thread-safe and may be called from any thread.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The passed in `GByteArray`</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="remove_index" c:identifier="g_byte_array_remove_index">
        <doc xml:space="preserve">Removes the byte at the given index from a `GByteArray`.
The following bytes are moved down one place.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GByteArray`</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the byte to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_index_fast" c:identifier="g_byte_array_remove_index_fast">
        <doc xml:space="preserve">Removes the byte at the given index from a `GByteArray`. The last
element in the array is used to fill in the space, so this function
does not preserve the order of the `GByteArray`. But it is faster
than [func@GLib.ByteArray.remove_index].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GByteArray`</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the byte to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_range" c:identifier="g_byte_array_remove_range" version="2.4">
        <doc xml:space="preserve">Removes the given number of bytes starting at the given index from a
`GByteArray`. The following elements are moved to close the gap.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GByteArray`</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the first byte to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_size" c:identifier="g_byte_array_set_size">
        <doc xml:space="preserve">Sets the size of the `GByteArray`, expanding it if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The `GByteArray`</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the new size of the `GByteArray`</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="sized_new" c:identifier="g_byte_array_sized_new">
        <doc xml:space="preserve">Creates a new `GByteArray` with @reserved_size bytes preallocated.
This avoids frequent reallocation, if you are going to add many
bytes to the array. Note however that the size of the array is still
0.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GByteArray`</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="reserved_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes preallocated</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort" c:identifier="g_byte_array_sort">
        <doc xml:space="preserve">Sorts a byte array, using @compare_func which should be a
`qsort()`-style comparison function (returns less than zero for first
arg is less than second arg, zero for equal, greater than zero if
first arg is greater than second arg).

If two array elements compare equal, their order in the sorted array
is undefined. If you want equal elements to keep their order (i.e.
you want a stable sort) you can write a comparison function that,
if two elements would otherwise compare equal, compares them by
their addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">the comparison function</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort_with_data" c:identifier="g_byte_array_sort_with_data">
        <doc xml:space="preserve">Like [func@GLib.ByteArray.sort], but the comparison function takes an extra
user data argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="steal" c:identifier="g_byte_array_steal" version="2.64">
        <doc xml:space="preserve">Frees the data in the array and resets the size to zero, while
the underlying array is preserved for use elsewhere and returned
to the caller.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The allocated element data</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the pointer to retrieve the number of
   elements of the original array</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref" c:identifier="g_byte_array_unref" version="2.22">
        <doc xml:space="preserve">Atomically decrements the reference count of @array by one. If the
reference count drops to 0, all memory allocated by the array is
released. This function is thread-safe and may be called from any
thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="full">
            <doc xml:space="preserve">a byte array</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="Bytes" c:type="GBytes" opaque="1" copy-function="g_bytes_ref" free-function="g_bytes_unref" version="2.32" glib:type-name="GBytes" glib:get-type="g_bytes_get_type" c:symbol-prefix="bytes">
      <doc xml:space="preserve">A simple reference counted data type representing an immutable sequence of
zero or more bytes from an unspecified origin.

The purpose of a `GBytes` is to keep the memory region that it holds
alive for as long as anyone holds a reference to the bytes.  When
the last reference count is dropped, the memory is released. Multiple
unrelated callers can use byte data in the `GBytes` without coordinating
their activities, resting assured that the byte data will not change or
move while they hold a reference.

A `GBytes` can come from many different origins that may have
different procedures for freeing the memory region.  Examples are
memory from [func@GLib.malloc], from memory slices, from a
[struct@GLib.MappedFile] or memory from other allocators.

`GBytes` work well as keys in [struct@GLib.HashTable]. Use
[method@GLib.Bytes.equal] and [method@GLib.Bytes.hash] as parameters to
[func@GLib.HashTable.new] or [func@GLib.HashTable.new_full].
`GBytes` can also be used as keys in a [struct@GLib.Tree] by passing the
[method@GLib.Bytes.compare] function to [ctor@GLib.Tree.new].

The data pointed to by this bytes must not be modified. For a mutable
array of bytes see [struct@GLib.ByteArray]. Use
[method@GLib.Bytes.unref_to_array] to create a mutable array for a `GBytes`
sequence. To create an immutable `GBytes` from a mutable
[struct@GLib.ByteArray], use the [func@GLib.ByteArray.free_to_bytes]
function.</doc>
      <constructor name="new" c:identifier="g_bytes_new" version="2.32">
        <doc xml:space="preserve">Creates a new [struct@GLib.Bytes] from @data.

@data is copied. If @size is 0, @data may be `NULL`.

As an optimization, [ctor@GLib.Bytes.new] may avoid an extra allocation by
copying the data within the resulting bytes structure if sufficiently small
(since GLib 2.84).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new [struct@GLib.Bytes]</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">
  the data to be used for the bytes</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the size of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_bytes" c:identifier="g_bytes_new_from_bytes" version="2.32">
        <doc xml:space="preserve">Creates a [struct@GLib.Bytes] which is a subsection of another `GBytes`.

The @offset + @length may not be longer than the size of @bytes.

A reference to @bytes will be held by the newly created `GBytes` until
the byte data is no longer needed.

Since 2.56, if @offset is 0 and @length matches the size of @bytes, then
@bytes will be returned with the reference count incremented by 1. If @bytes
is a slice of another `GBytes`, then the resulting `GBytes` will reference
the same `GBytes` instead of @bytes. This allows consumers to simplify the
usage of `GBytes` when asynchronously writing to streams.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new [struct@GLib.Bytes]</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">a [struct@GLib.Bytes]</doc>
            <type name="Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">offset which subsection starts at</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of subsection</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_static" c:identifier="g_bytes_new_static" version="2.32" introspectable="0">
        <doc xml:space="preserve">Creates a new [struct@GLib.Bytes] from static data.

@data must be static (ie: never modified or freed). It may be `NULL` if @size
is 0.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new [struct@GLib.Bytes]</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">
  the data to be used for the bytes</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the size of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_take" c:identifier="g_bytes_new_take" version="2.32">
        <doc xml:space="preserve">Creates a new [struct@GLib.Bytes] from @data.

After this call, @data belongs to the `GBytes` and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with [func@GLib.free].

For creating `GBytes` with memory from other allocators, see
[ctor@GLib.Bytes.new_with_free_func].

@data may be `NULL` if @size is 0.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new [struct@GLib.Bytes]</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">
  the data to be used for the bytes</doc>
            <array length="1" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the size of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_free_func" c:identifier="g_bytes_new_with_free_func" version="2.32" introspectable="0">
        <doc xml:space="preserve">Creates a [struct@GLib.Bytes] from @data.

When the last reference is dropped, @free_func will be called with the
@user_data argument.

@data must not be modified after this call is made until @free_func has
been called to indicate that the bytes is no longer in use.

@data may be `NULL` if @size is 0.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new [struct@GLib.Bytes]</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">
  the data to be used for the bytes</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the size of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="free_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">the function to call to release the data</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @free_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="compare" c:identifier="g_bytes_compare" version="2.32">
        <doc xml:space="preserve">Compares the two [struct@GLib.Bytes] values.

This function can be used to sort `GBytes` instances in lexicographical
order.

If @bytes1 and @bytes2 have different length but the shorter one is a
prefix of the longer one then the shorter one is considered to be less than
the longer one. Otherwise the first byte where both differ is used for
comparison. If @bytes1 has a smaller value at that position it is
considered less, otherwise greater than @bytes2.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a negative value if @bytes1 is less than @bytes2, a positive value
  if @bytes1 is greater than @bytes2, and zero if @bytes1 is equal to @bytes2</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bytes1" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a [struct@GLib.Bytes]</doc>
            <type name="Bytes" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="bytes2" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a [struct@GLib.Bytes] to compare with @bytes1</doc>
            <type name="Bytes" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="g_bytes_equal" version="2.32">
        <doc xml:space="preserve">Compares the two [struct@GLib.Bytes] values being pointed to and returns
`TRUE` if they are equal.

This function can be passed to [func@GLib.HashTable.new] as the
@key_equal_func parameter, when using non-`NULL` `GBytes` pointers as keys in
a [struct@GLib.HashTable].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the two keys match.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bytes1" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a [struct@GLib.Bytes]</doc>
            <type name="Bytes" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="bytes2" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a [struct@GLib.Bytes] to compare with @bytes1</doc>
            <type name="Bytes" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="g_bytes_get_data" version="2.32">
        <doc xml:space="preserve">Get the byte data in the [struct@GLib.Bytes].

This data should not be modified.

This function will always return the same pointer for a given `GBytes`.

`NULL` may be returned if @size is 0. This is not guaranteed, as the `GBytes`
may represent an empty string with @data non-`NULL` and @size as 0. `NULL`
will not be returned if @size is non-zero.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">
  a pointer to the byte data</doc>
          <array length="0" zero-terminated="0" c:type="gconstpointer">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">a [struct@GLib.Bytes]</doc>
            <type name="Bytes" c:type="GBytes*"/>
          </instance-parameter>
          <parameter name="size" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to return size of byte data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_region" c:identifier="g_bytes_get_region" version="2.70">
        <doc xml:space="preserve">Gets a pointer to a region in @bytes.

The region starts at @offset many bytes from the start of the data
and contains @n_elements many elements of @element_size size.

@n_elements may be zero, but @element_size must always be non-zero.
Ideally, @element_size is a static constant (eg: `sizeof` a struct).

This function does careful bounds checking (including checking for
arithmetic overflows) and returns a non-`NULL` pointer if the
specified region lies entirely within the @bytes. If the region is
in some way out of range, or if an overflow has occurred, then `NULL`
is returned.

Note: it is possible to have a valid zero-size region. In this case,
the returned pointer will be equal to the base pointer of the data of
@bytes, plus @offset.  This will be non-`NULL` except for the case
where @bytes itself was a zero-sized region.  Since it is unlikely
that you will be using this function to check for a zero-sized region
in a zero-sized @bytes, `NULL` effectively always means &#x2018;error&#x2019;.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the requested region, or `NULL` in case of an error</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">a [struct@GLib.Bytes]</doc>
            <type name="Bytes" c:type="GBytes*"/>
          </instance-parameter>
          <parameter name="element_size" transfer-ownership="none">
            <doc xml:space="preserve">a non-zero element size</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">an offset to the start of the region within the @bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="n_elements" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in the region</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="g_bytes_get_size" version="2.32">
        <doc xml:space="preserve">Get the size of the byte data in the [struct@GLib.Bytes].

This function will always return the same value for a given `GBytes`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">a [struct@GLib.Bytes]</doc>
            <type name="Bytes" c:type="GBytes*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="g_bytes_hash" version="2.32">
        <doc xml:space="preserve">Creates an integer hash code for the byte data in the [struct@GLib.Bytes].

This function can be passed to [func@GLib.HashTable.new] as the
@key_hash_func parameter, when using non-`NULL` `GBytes` pointers as keys in
a [struct@GLib.HashTable].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a hash value corresponding to the key.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a [struct@GLib.Bytes] key</doc>
            <type name="Bytes" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_bytes_ref" version="2.32">
        <doc xml:space="preserve">Increase the reference count on @bytes.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the [struct@GLib.Bytes]</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">a [struct@GLib.Bytes]</doc>
            <type name="Bytes" c:type="GBytes*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_bytes_unref" version="2.32">
        <doc xml:space="preserve">Releases a reference on @bytes.

This may result in the bytes being freed. If @bytes is `NULL`, it will
return immediately.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a [struct@GLib.Bytes]</doc>
            <type name="Bytes" c:type="GBytes*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref_to_array" c:identifier="g_bytes_unref_to_array" version="2.32">
        <doc xml:space="preserve">Unreferences the bytes, and returns a new mutable [struct@GLib.ByteArray]
containing the same byte data.

As an optimization, the byte data is transferred to the array without copying
if this was the last reference to @bytes and @bytes was created with
[ctor@GLib.Bytes.new], [ctor@GLib.Bytes.new_take] or
[func@GLib.ByteArray.free_to_bytes] and the buffer was larger than the size
[struct@GLib.Bytes] may internalize within its allocation. In all other cases
the data is copied.

Do not use it if @bytes contains more than %G_MAXUINT
bytes. [struct@GLib.ByteArray] stores the length of its data in `guint`,
which may be shorter than `gsize`, that @bytes is using.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new mutable [struct@GLib.ByteArray] containing
  the same byte data</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="full">
            <doc xml:space="preserve">a [struct@GLib.Bytes]</doc>
            <type name="Bytes" c:type="GBytes*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref_to_data" c:identifier="g_bytes_unref_to_data" version="2.32">
        <doc xml:space="preserve">Unreferences the bytes, and returns a pointer the same byte data
contents.

As an optimization, the byte data is returned without copying if this was
the last reference to @bytes and @bytes was created with
[ctor@GLib.Bytes.new], [ctor@GLib.Bytes.new_take] or
[func@GLib.ByteArray.free_to_bytes] and the buffer was larger than the size
[struct@GLib.Bytes] may internalize within its allocation. In all other cases
the data is copied.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
  a pointer to the same byte data, which should be freed with [func@GLib.free]</doc>
          <array length="0" zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="full">
            <doc xml:space="preserve">a [struct@GLib.Bytes]</doc>
            <type name="Bytes" c:type="GBytes*"/>
          </instance-parameter>
          <parameter name="size" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to place the length of the returned data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <function-macro name="CHECK_VERSION" c:identifier="GLIB_CHECK_VERSION" introspectable="0">
      <doc xml:space="preserve">Checks whether the version of the GLib library that is being compiled
against is greater than or equal to the given one.

See glib_check_version() for a runtime check.</doc>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve">the major version to check for</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve">the minor version to check for</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve">the micro version to check for</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="CSET_A_2_Z" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ" c:type="G_CSET_A_2_Z">
      <doc xml:space="preserve">The set of uppercase ASCII alphabet characters.
Used for specifying valid identifier characters
in #GScannerConfig.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CSET_DIGITS" value="0123456789" c:type="G_CSET_DIGITS">
      <doc xml:space="preserve">The set of ASCII digits.
Used for specifying valid identifier characters
in #GScannerConfig.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CSET_a_2_z" value="abcdefghijklmnopqrstuvwxyz" c:type="G_CSET_a_2_z">
      <doc xml:space="preserve">The set of lowercase ASCII alphabet characters.
Used for specifying valid identifier characters
in #GScannerConfig.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="CXX_STD_CHECK_VERSION" c:identifier="G_CXX_STD_CHECK_VERSION" version="2.76" introspectable="0">
      <doc xml:space="preserve">Macro to check if the current compiler supports a specified @version
of the C++ standard. Such value must be numeric and can be provided both
in the short form for the well-known versions (e.g. `11`, `17`...) or in
the complete form otherwise (e.g. `201103L`, `201703L`, `205503L`...).

When a C compiler is used, the macro is defined and returns always %FALSE.

This value is compared against %G_CXX_STD_VERSION.

|[&lt;!-- language="C" --&gt;
#if G_CXX_STD_CHECK_VERSION(20)
#endif
]|

See also: %G_C_STD_CHECK_VERSION</doc>
      <parameters>
        <parameter name="version">
          <doc xml:space="preserve">The C++ version to be checked for compatibility</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="C_STD_CHECK_VERSION" c:identifier="G_C_STD_CHECK_VERSION" version="2.76" introspectable="0">
      <doc xml:space="preserve">Macro to check if the current compiler supports a specified @version
of the C standard. Such value must be numeric and can be provided both
in the short form for the well-known versions (e.g. `90`, `99`...) or in
the complete form otherwise (e.g. `199000L`, `199901L`, `205503L`...).

When a C++ compiler is used, the macro is defined and returns always %FALSE.

This value is compared against %G_C_STD_VERSION.

|[&lt;!-- language="C" --&gt;
#if G_C_STD_CHECK_VERSION(17)
#endif
]|

See also: %G_CXX_STD_CHECK_VERSION</doc>
      <parameters>
        <parameter name="version">
          <doc xml:space="preserve">The C version to be checked for compatibility</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="C_STD_VERSION" value="199000" c:type="G_C_STD_VERSION" version="2.76">
      <doc xml:space="preserve">The C standard version the code is compiling against, it's normally
defined with the same value of `__STDC_VERSION__` for C standard
compatible compilers, while it uses the lowest standard version
in pure MSVC, given that in such compiler the definition depends on
a compilation flag.

This is granted to be undefined when compiling with a C++ compiler.

See also: %G_C_STD_CHECK_VERSION and %G_CXX_STD_VERSION</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Cache" c:type="GCache" disguised="1" opaque="1" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">A `GCache` allows sharing of complex data structures, in order to
save system resources.

`GCache` uses keys and values. A `GCache` key describes the properties
of a particular resource. A `GCache` value is the actual resource.

`GCache` has been marked as deprecated, since this API is rarely
used and not very actively maintained.</doc>
      <doc-deprecated xml:space="preserve">Use a #GHashTable instead</doc-deprecated>
      <method name="destroy" c:identifier="g_cache_destroy" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Frees the memory allocated for the #GCache.

Note that it does not destroy the keys and values which were
contained in the #GCache.</doc>
        <doc-deprecated xml:space="preserve">Use a #GHashTable instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #GCache</doc>
            <type name="Cache" c:type="GCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_cache_insert" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Gets the value corresponding to the given key, creating it if
necessary. It first checks if the value already exists in the
#GCache, by using the @key_equal_func function passed to
g_cache_new(). If it does already exist it is returned, and its
reference count is increased by one. If the value does not currently
exist, if is created by calling the @value_new_func. The key is
duplicated by calling @key_dup_func and the duplicated key and value
are inserted into the #GCache.</doc>
        <doc-deprecated xml:space="preserve">Use a #GHashTable instead</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a pointer to a #GCache value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #GCache</doc>
            <type name="Cache" c:type="GCache*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a key describing a #GCache object</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="key_foreach" c:identifier="g_cache_key_foreach" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Calls the given function for each of the keys in the #GCache.

NOTE @func is passed three parameters, the value and key of a cache
entry and the @user_data. The order of value and key is different
from the order in which g_hash_table_foreach() passes key-value
pairs to its callback function !</doc>
        <doc-deprecated xml:space="preserve">Use a #GHashTable instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #GCache</doc>
            <type name="Cache" c:type="GCache*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the function to call with each #GCache key</doc>
            <type name="HFunc" c:type="GHFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_cache_remove" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Decreases the reference count of the given value. If it drops to 0
then the value and its corresponding key are destroyed, using the
@value_destroy_func and @key_destroy_func passed to g_cache_new().</doc>
        <doc-deprecated xml:space="preserve">Use a #GHashTable instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #GCache</doc>
            <type name="Cache" c:type="GCache*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value to remove</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="value_foreach" c:identifier="g_cache_value_foreach" deprecated="1" deprecated-version="2.10">
        <doc xml:space="preserve">Calls the given function for each of the values in the #GCache.</doc>
        <doc-deprecated xml:space="preserve">The reason is that it passes pointers to internal
   data structures to @func; use g_cache_key_foreach() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #GCache</doc>
            <type name="Cache" c:type="GCache*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the function to call with each #GCache value</doc>
            <type name="HFunc" c:type="GHFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_cache_new" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Creates a new #GCache.</doc>
        <doc-deprecated xml:space="preserve">Use a #GHashTable instead</doc-deprecated>
        <return-value>
          <doc xml:space="preserve">a new #GCache</doc>
          <type name="Cache" c:type="GCache*"/>
        </return-value>
        <parameters>
          <parameter name="value_new_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to create a new object given a key.
                 This is called by g_cache_insert() if an object
                 with the given key does not already exist</doc>
            <type name="CacheNewFunc" c:type="GCacheNewFunc"/>
          </parameter>
          <parameter name="value_destroy_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to destroy an object. It is called
                     by g_cache_remove() when the object is no
                     longer needed (i.e. its reference count drops
                     to 0)</doc>
            <type name="CacheDestroyFunc" c:type="GCacheDestroyFunc"/>
          </parameter>
          <parameter name="key_dup_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to copy a key. It is called by
               g_cache_insert() if the key does not already exist in
               the #GCache</doc>
            <type name="CacheDupFunc" c:type="GCacheDupFunc"/>
          </parameter>
          <parameter name="key_destroy_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to destroy a key. It is called by
                   g_cache_remove() when the object is no longer
                   needed (i.e. its reference count drops to 0)</doc>
            <type name="CacheDestroyFunc" c:type="GCacheDestroyFunc"/>
          </parameter>
          <parameter name="hash_key_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to create a hash value from a key</doc>
            <type name="HashFunc" c:type="GHashFunc"/>
          </parameter>
          <parameter name="hash_value_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to create a hash value from a value</doc>
            <type name="HashFunc" c:type="GHashFunc"/>
          </parameter>
          <parameter name="key_equal_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to compare two keys. It should return
                 %TRUE if the two keys are equivalent</doc>
            <type name="EqualFunc" c:type="GEqualFunc"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="CacheDestroyFunc" c:type="GCacheDestroyFunc" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Specifies the type of the @value_destroy_func and @key_destroy_func
functions passed to g_cache_new(). The functions are passed a
pointer to the #GCache key or #GCache value and should free any
memory and other resources associated with it.</doc>
      <doc-deprecated xml:space="preserve">Use a #GHashTable instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the #GCache value to destroy</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CacheDupFunc" c:type="GCacheDupFunc" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Specifies the type of the @key_dup_func function passed to
g_cache_new(). The function is passed a key
(__not__ a value as the prototype implies) and
should return a duplicate of the key.</doc>
      <doc-deprecated xml:space="preserve">Use a #GHashTable instead</doc-deprecated>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a copy of the #GCache key</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the #GCache key to destroy (__not__ a
        #GCache value as it seems)</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CacheNewFunc" c:type="GCacheNewFunc" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Specifies the type of the @value_new_func function passed to
g_cache_new(). It is passed a #GCache key and should create the
value corresponding to the key.</doc>
      <doc-deprecated xml:space="preserve">Use a #GHashTable instead</doc-deprecated>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a new #GCache value corresponding to the key.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GCache key</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Checksum" c:type="GChecksum" opaque="1" version="2.16" glib:type-name="GChecksum" glib:get-type="g_checksum_get_type" c:symbol-prefix="checksum">
      <doc xml:space="preserve">GLib provides a generic API for computing checksums (or &#x2018;digests&#x2019;)
for a sequence of arbitrary bytes, using various hashing algorithms
like MD5, SHA-1 and SHA-256. Checksums are commonly used in various
environments and specifications.

To create a new `GChecksum`, use [ctor@GLib.Checksum.new]. To free
a `GChecksum`, use [method@GLib.Checksum.free].

GLib supports incremental checksums using the `GChecksum` data
structure, by calling [method@GLib.Checksum.update] as long as there&#x2019;s data
available and then using [method@GLib.Checksum.get_string] or
[method@GLib.Checksum.get_digest] to compute the checksum and return it
either as a string in hexadecimal form, or as a raw sequence of bytes. To
compute the checksum for binary blobs and nul-terminated strings in
one go, use the convenience functions [func@GLib.compute_checksum_for_data]
and [func@GLib.compute_checksum_for_string], respectively.</doc>
      <constructor name="new" c:identifier="g_checksum_new" version="2.16">
        <doc xml:space="preserve">Creates a new #GChecksum, using the checksum algorithm @checksum_type.
If the @checksum_type is not known, %NULL is returned.
A #GChecksum can be used to compute the checksum, or digest, of an
arbitrary binary blob, using different hashing algorithms.

A #GChecksum works by feeding a binary blob through g_checksum_update()
until there is data to be checked; the digest can then be extracted
using g_checksum_get_string(), which will return the checksum as a
hexadecimal string; or g_checksum_get_digest(), which will return a
vector of raw bytes. Once either g_checksum_get_string() or
g_checksum_get_digest() have been called on a #GChecksum, the checksum
will be closed and it won't be possible to call g_checksum_update()
on it anymore.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GChecksum, or %NULL.
  Use g_checksum_free() to free the memory allocated by it.</doc>
          <type name="Checksum" c:type="GChecksum*"/>
        </return-value>
        <parameters>
          <parameter name="checksum_type" transfer-ownership="none">
            <doc xml:space="preserve">the desired type of checksum</doc>
            <type name="ChecksumType" c:type="GChecksumType"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="g_checksum_copy" version="2.16">
        <doc xml:space="preserve">Copies a #GChecksum. If @checksum has been closed, by calling
g_checksum_get_string() or g_checksum_get_digest(), the copied
checksum will be closed as well.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the copy of the passed #GChecksum. Use
  g_checksum_free() when finished using it.</doc>
          <type name="Checksum" c:type="GChecksum*"/>
        </return-value>
        <parameters>
          <instance-parameter name="checksum" transfer-ownership="none">
            <doc xml:space="preserve">the #GChecksum to copy</doc>
            <type name="Checksum" c:type="const GChecksum*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_checksum_free" version="2.16">
        <doc xml:space="preserve">Frees the memory allocated for @checksum.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="checksum" transfer-ownership="none">
            <doc xml:space="preserve">a #GChecksum</doc>
            <type name="Checksum" c:type="GChecksum*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_digest" c:identifier="g_checksum_get_digest" version="2.16" introspectable="0">
        <doc xml:space="preserve">Gets the digest from @checksum as a raw binary vector and places it
into @buffer. The size of the digest depends on the type of checksum.

Once this function has been called, the #GChecksum is closed and can
no longer be updated with g_checksum_update().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="checksum" transfer-ownership="none">
            <doc xml:space="preserve">a #GChecksum</doc>
            <type name="Checksum" c:type="GChecksum*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">output buffer</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="digest_len" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">an inout parameter. The caller initializes it to the size of @buffer.
  After the call it contains the length of the digest.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="g_checksum_get_string" version="2.16">
        <doc xml:space="preserve">Gets the digest as a hexadecimal string.

Once this function has been called the #GChecksum can no longer be
updated with g_checksum_update().

The hexadecimal characters will be lower case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hexadecimal representation of the checksum. The
  returned string is owned by the checksum and should not be modified
  or freed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="checksum" transfer-ownership="none">
            <doc xml:space="preserve">a #GChecksum</doc>
            <type name="Checksum" c:type="GChecksum*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="g_checksum_reset" version="2.18">
        <doc xml:space="preserve">Resets the state of the @checksum back to its initial state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="checksum" transfer-ownership="none">
            <doc xml:space="preserve">the #GChecksum to reset</doc>
            <type name="Checksum" c:type="GChecksum*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="update" c:identifier="g_checksum_update" version="2.16">
        <doc xml:space="preserve">Feeds @data into an existing #GChecksum. The checksum must still be
open, that is g_checksum_get_string() or g_checksum_get_digest() must
not have been called on @checksum.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="checksum" transfer-ownership="none">
            <doc xml:space="preserve">a #GChecksum</doc>
            <type name="Checksum" c:type="GChecksum*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">buffer used to compute the checksum</doc>
            <array length="1" zero-terminated="0" c:type="const guchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">size of the buffer, or -1 if it is a null-terminated string.</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <function name="type_get_length" c:identifier="g_checksum_type_get_length" version="2.16">
        <doc xml:space="preserve">Gets the length in bytes of digests of type @checksum_type</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the checksum length, or -1 if @checksum_type is
not supported.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <parameter name="checksum_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GChecksumType</doc>
            <type name="ChecksumType" c:type="GChecksumType"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="ChecksumType" version="2.16" c:type="GChecksumType">
      <doc xml:space="preserve">The hashing algorithm to be used by #GChecksum when performing the
digest of some data.

Note that the #GChecksumType enumeration may be extended at a later
date to include new hashing algorithm types.</doc>
      <member name="md5" value="0" c:identifier="G_CHECKSUM_MD5">
        <doc xml:space="preserve">Use the MD5 hashing algorithm</doc>
      </member>
      <member name="sha1" value="1" c:identifier="G_CHECKSUM_SHA1">
        <doc xml:space="preserve">Use the SHA-1 hashing algorithm</doc>
      </member>
      <member name="sha256" value="2" c:identifier="G_CHECKSUM_SHA256">
        <doc xml:space="preserve">Use the SHA-256 hashing algorithm</doc>
      </member>
      <member name="sha512" value="3" c:identifier="G_CHECKSUM_SHA512">
        <doc xml:space="preserve">Use the SHA-512 hashing algorithm (Since: 2.36)</doc>
      </member>
      <member name="sha384" value="4" c:identifier="G_CHECKSUM_SHA384">
        <doc xml:space="preserve">Use the SHA-384 hashing algorithm (Since: 2.51)</doc>
      </member>
    </enumeration>
    <callback name="ChildWatchFunc" c:type="GChildWatchFunc">
      <doc xml:space="preserve">Prototype of a #GChildWatchSource callback, called when a child
process has exited.

To interpret @wait_status, see the documentation for
[func@GLib.spawn_check_wait_status]. In particular,
on Unix platforms, note that it is usually not equal
to the integer passed to `exit()` or returned from `main()`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pid" transfer-ownership="none">
          <doc xml:space="preserve">the process id of the child process</doc>
          <type name="Pid" c:type="GPid"/>
        </parameter>
        <parameter name="wait_status" transfer-ownership="none">
          <doc xml:space="preserve">Status information about the child process, encoded
              in a platform-specific manner</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data passed to [func@GLib.child_watch_add]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ClearHandleFunc" c:type="GClearHandleFunc" version="2.56">
      <doc xml:space="preserve">Specifies the type of function passed to [func@GLib.clear_handle_id] The
implementation is expected to free the resource identified by @handle_id;
for instance, if @handle_id is a [struct@GLib.Source] ID,
[func@GLib.Source.remove] can be used.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle_id" transfer-ownership="none">
          <doc xml:space="preserve">the handle ID to clear</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CompareDataFunc" c:type="GCompareDataFunc">
      <doc xml:space="preserve">Specifies the type of a comparison function used to compare two
values.  The function should return a negative integer if the first
value comes before the second, 0 if they are equal, or a positive
integer if the first value comes after the second.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">negative value if @a &lt; @b; zero if @a = @b; positive
         value if @a &gt; @b</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a value</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a value to compare with</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CompareFunc" c:type="GCompareFunc">
      <doc xml:space="preserve">Specifies the type of a comparison function used to compare two
values.  The function should return a negative integer if the first
value comes before the second, 0 if they are equal, or a positive
integer if the first value comes after the second.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">negative value if @a &lt; @b; zero if @a = @b; positive
         value if @a &gt; @b</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a value</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a value to compare with</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Completion" c:type="GCompletion" deprecated="1" deprecated-version="2.26">
      <doc xml:space="preserve">`GCompletion` provides support for automatic completion of a string
using any group of target strings. It is typically used for file
name completion as is common in many UNIX shells.

A `GCompletion` is created using [func@GLib.Completion.new]. Target items are
added and removed with [method@GLib.Completion.add_items],
[method@GLib.Completion.remove_items] and
[method@GLib.Completion.clear_items]. A completion attempt is requested with
[method@GLib.Completion.complete] or [method@GLib.Completion.complete_utf8].
When no longer needed, the `GCompletion` is freed with
[method@GLib.Completion.free].

Items in the completion can be simple strings (e.g. filenames), or
pointers to arbitrary data structures. If data structures are used
you must provide a [type@GLib.CompletionFunc] in [func@GLib.Completion.new],
which retrieves the item&#x2019;s string from the data structure. You can change
the way in which strings are compared by setting a different
[type@GLib.CompletionStrncmpFunc] in [method@GLib.Completion.set_compare].

`GCompletion` has been marked as deprecated, since this API is rarely
used and not very actively maintained.</doc>
      <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
      <field name="items" writable="1">
        <doc xml:space="preserve">list of target items (strings or data structures).</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="func" writable="1">
        <doc xml:space="preserve">function which is called to get the string associated with a
       target item. It is %NULL if the target items are strings.</doc>
        <type name="CompletionFunc" c:type="GCompletionFunc"/>
      </field>
      <field name="prefix" writable="1">
        <doc xml:space="preserve">the last prefix passed to g_completion_complete() or
         g_completion_complete_utf8().</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="cache" writable="1">
        <doc xml:space="preserve">the list of items which begin with @prefix.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="strncmp_func" writable="1">
        <doc xml:space="preserve">The function to use when comparing strings.  Use
               g_completion_set_compare() to modify this function.</doc>
        <type name="CompletionStrncmpFunc" c:type="GCompletionStrncmpFunc"/>
      </field>
      <method name="add_items" c:identifier="g_completion_add_items" introspectable="0" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Adds items to the #GCompletion.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmp" transfer-ownership="none">
            <doc xml:space="preserve">the #GCompletion.</doc>
            <type name="Completion" c:type="GCompletion*"/>
          </instance-parameter>
          <parameter name="items" transfer-ownership="none">
            <doc xml:space="preserve">the list of items to add.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="clear_items" c:identifier="g_completion_clear_items" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Removes all items from the #GCompletion. The items are not freed, so if the
memory was dynamically allocated, it should be freed after calling this
function.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmp" transfer-ownership="none">
            <doc xml:space="preserve">the #GCompletion.</doc>
            <type name="Completion" c:type="GCompletion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="complete" c:identifier="g_completion_complete" introspectable="0" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Attempts to complete the string @prefix using the #GCompletion
target items.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the list of items whose strings begin with
         @prefix. This should not be changed.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="cmp" transfer-ownership="none">
            <doc xml:space="preserve">the #GCompletion.</doc>
            <type name="Completion" c:type="GCompletion*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the prefix string, typically typed by the user, which is
         compared with each of the items.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_prefix" transfer-ownership="none">
            <doc xml:space="preserve">if non-%NULL, returns the longest prefix which is
             common to all items that matched @prefix, or %NULL if
             no items matched @prefix.  This string should be freed
             when no longer needed.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="complete_utf8" c:identifier="g_completion_complete_utf8" version="2.4" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Attempts to complete the string @prefix using the #GCompletion target items.
In contrast to g_completion_complete(), this function returns the largest common
prefix that is a valid UTF-8 string, omitting a possible common partial
character.

You should use this function instead of g_completion_complete() if your
items are UTF-8 strings.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the list of items whose strings begin with @prefix. This should
not be changed.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="cmp" transfer-ownership="none">
            <doc xml:space="preserve">the #GCompletion</doc>
            <type name="Completion" c:type="GCompletion*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the prefix string, typically used by the user, which is compared
   with each of the items</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_prefix" transfer-ownership="none">
            <doc xml:space="preserve">if non-%NULL, returns the longest prefix which is common to all
   items that matched @prefix, or %NULL if no items matched @prefix.
   This string should be freed when no longer needed.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_completion_free" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Frees all memory used by the #GCompletion. The items are not freed, so if
the memory was dynamically allocated, it should be freed after calling this
function.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmp" transfer-ownership="none">
            <doc xml:space="preserve">the #GCompletion.</doc>
            <type name="Completion" c:type="GCompletion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_items" c:identifier="g_completion_remove_items" introspectable="0" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Removes items from a #GCompletion. The items are not freed, so if the memory
was dynamically allocated, free @items with g_list_free_full() after calling
this function.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmp" transfer-ownership="none">
            <doc xml:space="preserve">the #GCompletion.</doc>
            <type name="Completion" c:type="GCompletion*"/>
          </instance-parameter>
          <parameter name="items" transfer-ownership="none">
            <doc xml:space="preserve">the items to remove.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_compare" c:identifier="g_completion_set_compare" introspectable="0" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Sets the function to use for string comparisons. The default string
comparison function is strncmp().</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cmp" transfer-ownership="none">
            <doc xml:space="preserve">a #GCompletion.</doc>
            <type name="Completion" c:type="GCompletion*"/>
          </instance-parameter>
          <parameter name="strncmp_func" transfer-ownership="none">
            <doc xml:space="preserve">the string comparison function.</doc>
            <type name="CompletionStrncmpFunc" c:type="GCompletionStrncmpFunc"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_completion_new" introspectable="0" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Creates a new #GCompletion.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value>
          <doc xml:space="preserve">the new #GCompletion.</doc>
          <type name="Completion" c:type="GCompletion*"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none">
            <doc xml:space="preserve">the function to be called to return the string representing
       an item in the #GCompletion, or %NULL if strings are going to
       be used as the #GCompletion items.</doc>
            <type name="CompletionFunc" c:type="GCompletionFunc"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="CompletionFunc" c:type="GCompletionFunc" deprecated="1" deprecated-version="2.26">
      <doc xml:space="preserve">Specifies the type of the function passed to g_completion_new(). It
should return the string corresponding to the given target item.
This is used when you use data structures as #GCompletion items.</doc>
      <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the string corresponding to the item.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="item" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the completion item.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CompletionStrncmpFunc" c:type="GCompletionStrncmpFunc" deprecated="1" deprecated-version="2.26">
      <doc xml:space="preserve">Specifies the type of the function passed to
g_completion_set_compare(). This is used when you use strings as
#GCompletion items.</doc>
      <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">an integer less than, equal to, or greater than zero if
         the first @n bytes of @s1 is found, respectively, to be
         less than, to match, or to be greater than the first @n
         bytes of @s2.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="s1" transfer-ownership="none">
          <doc xml:space="preserve">string to compare with @s2.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="s2" transfer-ownership="none">
          <doc xml:space="preserve">string to compare with @s1.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">maximal number of bytes to compare.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Cond" c:type="GCond">
      <doc xml:space="preserve">The #GCond struct is an opaque data structure that represents a
condition. Threads can block on a #GCond if they find a certain
condition to be false. If other threads change the state of this
condition they signal the #GCond, and that causes the waiting
threads to be woken up.

Consider the following example of a shared variable.  One or more
threads can wait for data to be published to the variable and when
another thread publishes the data, it can signal one of the waiting
threads to wake up to collect the data.

Here is an example for using GCond to block a thread until a condition
is satisfied:
|[&lt;!-- language="C" --&gt;
  gpointer current_data = NULL;
  GMutex data_mutex;
  GCond data_cond;

  void
  push_data (gpointer data)
  {
    g_mutex_lock (&amp;data_mutex);
    current_data = data;
    g_cond_signal (&amp;data_cond);
    g_mutex_unlock (&amp;data_mutex);
  }

  gpointer
  pop_data (void)
  {
    gpointer data;

    g_mutex_lock (&amp;data_mutex);
    while (!current_data)
      g_cond_wait (&amp;data_cond, &amp;data_mutex);
    data = current_data;
    current_data = NULL;
    g_mutex_unlock (&amp;data_mutex);

    return data;
  }
]|
Whenever a thread calls pop_data() now, it will wait until
current_data is non-%NULL, i.e. until some other thread
has called push_data().

The example shows that use of a condition variable must always be
paired with a mutex.  Without the use of a mutex, there would be a
race between the check of @current_data by the while loop in
pop_data() and waiting. Specifically, another thread could set
@current_data after the check, and signal the cond (with nobody
waiting on it) before the first thread goes to sleep. #GCond is
specifically useful for its ability to release the mutex and go
to sleep atomically.

It is also important to use the g_cond_wait() and g_cond_wait_until()
functions only inside a loop which checks for the condition to be
true.  See g_cond_wait() for an explanation of why the condition may
not be true even after it returns.

If a #GCond is allocated in static storage then it can be used
without initialisation.  Otherwise, you should call g_cond_init()
on it and g_cond_clear() when done.

A #GCond should only be accessed via the g_cond_ functions.</doc>
      <field name="p" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="i" readable="0" private="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <method name="broadcast" c:identifier="g_cond_broadcast">
        <doc xml:space="preserve">If threads are waiting for @cond, all of them are unblocked.
If no threads are waiting for @cond, this function has no effect.
It is good practice to lock the same mutex as the waiting threads
while calling this function, though not required.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none">
            <doc xml:space="preserve">a #GCond</doc>
            <type name="Cond" c:type="GCond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="g_cond_clear" version="2.32">
        <doc xml:space="preserve">Frees the resources allocated to a #GCond with g_cond_init().

This function should not be used with a #GCond that has been
statically allocated.

Calling g_cond_clear() for a #GCond on which threads are
blocking leads to undefined behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none">
            <doc xml:space="preserve">an initialised #GCond</doc>
            <type name="Cond" c:type="GCond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_cond_free" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Destroys a #GCond that has been created with g_cond_new().

Calling g_cond_free() for a #GCond on which threads are
blocking leads to undefined behaviour.</doc>
        <doc-deprecated xml:space="preserve">GCond can now be statically allocated, or embedded
in structures and initialised with g_cond_init().</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none">
            <doc xml:space="preserve">a #GCond</doc>
            <type name="Cond" c:type="GCond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_cond_init" version="2.32">
        <doc xml:space="preserve">Initialises a #GCond so that it can be used.

This function is useful to initialise a #GCond that has been
allocated as part of a larger structure.  It is not necessary to
initialise a #GCond that has been statically allocated.

To undo the effect of g_cond_init() when a #GCond is no longer
needed, use g_cond_clear().

Calling g_cond_init() on an already-initialised #GCond leads
to undefined behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized #GCond</doc>
            <type name="Cond" c:type="GCond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="signal" c:identifier="g_cond_signal">
        <doc xml:space="preserve">If threads are waiting for @cond, at least one of them is unblocked.
If no threads are waiting for @cond, this function has no effect.
It is good practice to hold the same lock as the waiting thread
while calling this function, though not required.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none">
            <doc xml:space="preserve">a #GCond</doc>
            <type name="Cond" c:type="GCond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="timed_wait" c:identifier="g_cond_timed_wait" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Waits until this thread is woken up on @cond, but not longer than
until the time specified by @abs_time. The @mutex is unlocked before
falling asleep and locked again before resuming.

If @abs_time is %NULL, g_cond_timed_wait() acts like g_cond_wait().

This function can be used even if g_thread_init() has not yet been
called, and, in that case, will immediately return %TRUE.

To easily calculate @abs_time a combination of g_get_real_time()
and g_time_val_add() can be used.</doc>
        <doc-deprecated xml:space="preserve">Use g_cond_wait_until() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @cond was signalled, or %FALSE on timeout</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none">
            <doc xml:space="preserve">a #GCond</doc>
            <type name="Cond" c:type="GCond*"/>
          </instance-parameter>
          <parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GMutex that is currently locked</doc>
            <type name="Mutex" c:type="GMutex*"/>
          </parameter>
          <parameter name="abs_time" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal, determining the final time</doc>
            <type name="TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait" c:identifier="g_cond_wait">
        <doc xml:space="preserve">Atomically releases @mutex and waits until @cond is signalled.
When this function returns, @mutex is locked again and owned by the
calling thread.

When using condition variables, it is possible that a spurious wakeup
may occur (ie: g_cond_wait() returns even though g_cond_signal() was
not called).  It's also possible that a stolen wakeup may occur.
This is when g_cond_signal() is called, but another thread acquires
@mutex before this thread and modifies the state of the program in
such a way that when g_cond_wait() is able to return, the expected
condition is no longer met.

For this reason, g_cond_wait() must always be used in a loop.  See
the documentation for #GCond for a complete example.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none">
            <doc xml:space="preserve">a #GCond</doc>
            <type name="Cond" c:type="GCond*"/>
          </instance-parameter>
          <parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GMutex that is currently locked</doc>
            <type name="Mutex" c:type="GMutex*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_until" c:identifier="g_cond_wait_until" version="2.32">
        <doc xml:space="preserve">Waits until either @cond is signalled or @end_time has passed.

As with g_cond_wait() it is possible that a spurious or stolen wakeup
could occur.  For that reason, waiting on a condition variable should
always be in a loop, based on an explicitly-checked predicate.

%TRUE is returned if the condition variable was signalled (or in the
case of a spurious wakeup).  %FALSE is returned if @end_time has
passed.

The following code shows how to correctly perform a timed wait on a
condition variable (extending the example presented in the
documentation for #GCond):

|[&lt;!-- language="C" --&gt;
gpointer
pop_data_timed (void)
{
  gint64 end_time;
  gpointer data;

  g_mutex_lock (&amp;data_mutex);

  end_time = g_get_monotonic_time () + 5 * G_TIME_SPAN_SECOND;
  while (!current_data)
    if (!g_cond_wait_until (&amp;data_cond, &amp;data_mutex, end_time))
      {
        // timeout has passed.
        g_mutex_unlock (&amp;data_mutex);
        return NULL;
      }

  // there is data for us
  data = current_data;
  current_data = NULL;

  g_mutex_unlock (&amp;data_mutex);

  return data;
}
]|

Notice that the end time is calculated once, before entering the
loop and reused.  This is the motivation behind the use of absolute
time on this API -- if a relative time of 5 seconds were passed
directly to the call and a spurious wakeup occurred, the program would
have to start over waiting again (which would lead to a total wait
time of more than 5 seconds).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on a signal, %FALSE on a timeout</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none">
            <doc xml:space="preserve">a #GCond</doc>
            <type name="Cond" c:type="GCond*"/>
          </instance-parameter>
          <parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GMutex that is currently locked</doc>
            <type name="Mutex" c:type="GMutex*"/>
          </parameter>
          <parameter name="end_time" transfer-ownership="none">
            <doc xml:space="preserve">the monotonic time to wait until</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_cond_new" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Allocates and initializes a new #GCond.</doc>
        <doc-deprecated xml:space="preserve">GCond can now be statically allocated, or embedded
in structures and initialised with g_cond_init().</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GCond. Free with g_cond_free()</doc>
          <type name="Cond" c:type="GCond*"/>
        </return-value>
      </function>
    </record>
    <enumeration name="ConvertError" c:type="GConvertError" glib:error-domain="g_convert_error">
      <doc xml:space="preserve">Error codes returned by character set conversion routines.</doc>
      <member name="no_conversion" value="0" c:identifier="G_CONVERT_ERROR_NO_CONVERSION">
        <doc xml:space="preserve">Conversion between the requested character
    sets is not supported.</doc>
      </member>
      <member name="illegal_sequence" value="1" c:identifier="G_CONVERT_ERROR_ILLEGAL_SEQUENCE">
        <doc xml:space="preserve">Invalid byte sequence in conversion input;
   or the character sequence could not be represented in the target
   character set.</doc>
      </member>
      <member name="failed" value="2" c:identifier="G_CONVERT_ERROR_FAILED">
        <doc xml:space="preserve">Conversion failed for some reason.</doc>
      </member>
      <member name="partial_input" value="3" c:identifier="G_CONVERT_ERROR_PARTIAL_INPUT">
        <doc xml:space="preserve">Partial character sequence at end of input.</doc>
      </member>
      <member name="bad_uri" value="4" c:identifier="G_CONVERT_ERROR_BAD_URI">
        <doc xml:space="preserve">URI is invalid.</doc>
      </member>
      <member name="not_absolute_path" value="5" c:identifier="G_CONVERT_ERROR_NOT_ABSOLUTE_PATH">
        <doc xml:space="preserve">Pathname is not an absolute path.</doc>
      </member>
      <member name="no_memory" value="6" c:identifier="G_CONVERT_ERROR_NO_MEMORY">
        <doc xml:space="preserve">No memory available. Since: 2.40</doc>
      </member>
      <member name="embedded_nul" value="7" c:identifier="G_CONVERT_ERROR_EMBEDDED_NUL">
        <doc xml:space="preserve">An embedded NUL character is present in
    conversion output where a NUL-terminated string is expected.
    Since: 2.56</doc>
      </member>
    </enumeration>
    <callback name="CopyFunc" c:type="GCopyFunc" version="2.4">
      <doc xml:space="preserve">A function of this signature is used to copy the node data
when doing a deep-copy of a tree.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A pointer to the copy</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">A pointer to the data which should be copied</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="DATALIST_FLAGS_MASK" value="3" c:type="G_DATALIST_FLAGS_MASK">
      <doc xml:space="preserve">A bitmask that restricts the possible flags passed to
g_datalist_set_flags(). Passing a flags value where
flags &amp; ~G_DATALIST_FLAGS_MASK != 0 is an error.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="DATE_BAD_DAY" value="0" c:type="G_DATE_BAD_DAY">
      <doc xml:space="preserve">Represents an invalid #GDateDay.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="DATE_BAD_JULIAN" value="0" c:type="G_DATE_BAD_JULIAN">
      <doc xml:space="preserve">Represents an invalid Julian day number.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="DATE_BAD_YEAR" value="0" c:type="G_DATE_BAD_YEAR">
      <doc xml:space="preserve">Represents an invalid year.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="DEBUG_HERE" c:identifier="G_DEBUG_HERE" version="2.50" introspectable="0">
      <doc xml:space="preserve">A convenience form of g_log_structured(), recommended to be added to
functions when debugging. It prints the current monotonic time and the code
location using %G_STRLOC.</doc>
    </function-macro>
    <function-macro name="DEFINE_AUTOPTR_CLEANUP_FUNC" c:identifier="G_DEFINE_AUTOPTR_CLEANUP_FUNC" version="2.44" introspectable="0">
      <doc xml:space="preserve">Defines the appropriate cleanup function for a pointer type.

The function will not be called if the variable to be cleaned up
contains %NULL.

This will typically be the `_free()` or `_unref()` function for the given
type.

With this definition, it will be possible to use g_autoptr() with
@TypeName.

|[
G_DEFINE_AUTOPTR_CLEANUP_FUNC(GObject, g_object_unref)
]|

This macro should be used unconditionally; it is a no-op on compilers
where cleanup is not supported.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">a type name to define a g_autoptr() cleanup function for</doc>
        </parameter>
        <parameter name="func">
          <doc xml:space="preserve">the cleanup function</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_AUTO_CLEANUP_CLEAR_FUNC" c:identifier="G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC" version="2.44" introspectable="0">
      <doc xml:space="preserve">Defines the appropriate cleanup function for a type.

This will typically be the `_clear()` function for the given type.

With this definition, it will be possible to use g_auto() with
@TypeName.

|[
G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC(GQueue, g_queue_clear)
]|

This macro should be used unconditionally; it is a no-op on compilers
where cleanup is not supported.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">a type name to define a g_auto() cleanup function for</doc>
        </parameter>
        <parameter name="func">
          <doc xml:space="preserve">the clear function</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_AUTO_CLEANUP_FREE_FUNC" c:identifier="G_DEFINE_AUTO_CLEANUP_FREE_FUNC" version="2.44" introspectable="0">
      <doc xml:space="preserve">Defines the appropriate cleanup function for a type.

With this definition, it will be possible to use g_auto() with
@TypeName.

This function will be rarely used.  It is used with pointer-based
typedefs and non-pointer types where the value of the variable
represents a resource that must be freed.  Two examples are #GStrv
and file descriptors.

@none specifies the "none" value for the type in question.  It is
probably something like %NULL or `-1`.  If the variable is found to
contain this value then the free function will not be called.

|[
G_DEFINE_AUTO_CLEANUP_FREE_FUNC(GStrv, g_strfreev, NULL)
]|

This macro should be used unconditionally; it is a no-op on compilers
where cleanup is not supported.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">a type name to define a g_auto() cleanup function for</doc>
        </parameter>
        <parameter name="func">
          <doc xml:space="preserve">the free function</doc>
        </parameter>
        <parameter name="none">
          <doc xml:space="preserve">the "none" value for the type</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_EXTENDED_ERROR" c:identifier="G_DEFINE_EXTENDED_ERROR" version="2.68" introspectable="0">
      <doc xml:space="preserve">A convenience macro which defines two functions. First, returning
the #GQuark for the extended error type @ErrorType; it is called
`error_type_quark()`. Second, returning the private data from a
passed #GError; it is called `error_type_get_private()`.

For this macro to work, a type named `ErrorTypePrivate` should be
defined, `error_type_private_init()`, `error_type_private_copy()`
and `error_type_private_clear()` functions need to be either
declared or defined. The functions should be similar to
#GErrorInitFunc, #GErrorCopyFunc and #GErrorClearFunc,
respectively, but they should receive the private data type instead
of #GError.

See [Extended #GError Domains](error-reporting.html#extended-gerror-domains) for an example.</doc>
      <parameters>
        <parameter name="ErrorType">
          <doc xml:space="preserve">name to return a #GQuark for</doc>
        </parameter>
        <parameter name="error_type">
          <doc xml:space="preserve">prefix for the function name</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_QUARK" c:identifier="G_DEFINE_QUARK" version="2.34" introspectable="0">
      <doc xml:space="preserve">A convenience macro which defines a function returning the
#GQuark for the name @QN. The function will be named
@q_n_quark().

Note that the quark name will be stringified automatically
in the macro, so you shouldn't use double quotes.</doc>
      <parameters>
        <parameter name="QN">
          <doc xml:space="preserve">the name to return a #GQuark for</doc>
        </parameter>
        <parameter name="q_n">
          <doc xml:space="preserve">prefix for the function name</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_26_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_26_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_28_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_28_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_30_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_30_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_32_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_32_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_34_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_34_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_36_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_36_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_38_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_38_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_40_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_40_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_42_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_42_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_44_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_44_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_46_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_46_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_48_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_48_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_50_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_50_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_52_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_52_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_54_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_54_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_56_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_56_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_58_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_58_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_60_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_60_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_62_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_62_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_64_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_64_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_66_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_66_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_68_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_68_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_70_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_70_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_72_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_72_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_74_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_74_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_76_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_76_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_78_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_78_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_80_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_80_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_82_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_82_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_84_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_84_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_86_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_86_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_88_FOR" c:identifier="GLIB_DEPRECATED_ENUMERATOR_IN_2_88_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_FOR" c:identifier="GLIB_DEPRECATED_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_26_FOR" c:identifier="GLIB_DEPRECATED_IN_2_26_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_28_FOR" c:identifier="GLIB_DEPRECATED_IN_2_28_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_30_FOR" c:identifier="GLIB_DEPRECATED_IN_2_30_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_32_FOR" c:identifier="GLIB_DEPRECATED_IN_2_32_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_34_FOR" c:identifier="GLIB_DEPRECATED_IN_2_34_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_36_FOR" c:identifier="GLIB_DEPRECATED_IN_2_36_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_38_FOR" c:identifier="GLIB_DEPRECATED_IN_2_38_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_40_FOR" c:identifier="GLIB_DEPRECATED_IN_2_40_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_42_FOR" c:identifier="GLIB_DEPRECATED_IN_2_42_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_44_FOR" c:identifier="GLIB_DEPRECATED_IN_2_44_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_46_FOR" c:identifier="GLIB_DEPRECATED_IN_2_46_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_48_FOR" c:identifier="GLIB_DEPRECATED_IN_2_48_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_50_FOR" c:identifier="GLIB_DEPRECATED_IN_2_50_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_52_FOR" c:identifier="GLIB_DEPRECATED_IN_2_52_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_54_FOR" c:identifier="GLIB_DEPRECATED_IN_2_54_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_56_FOR" c:identifier="GLIB_DEPRECATED_IN_2_56_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_58_FOR" c:identifier="GLIB_DEPRECATED_IN_2_58_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_60_FOR" c:identifier="GLIB_DEPRECATED_IN_2_60_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_62_FOR" c:identifier="GLIB_DEPRECATED_IN_2_62_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_64_FOR" c:identifier="GLIB_DEPRECATED_IN_2_64_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_66_FOR" c:identifier="GLIB_DEPRECATED_IN_2_66_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_68_FOR" c:identifier="GLIB_DEPRECATED_IN_2_68_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_70_FOR" c:identifier="GLIB_DEPRECATED_IN_2_70_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_72_FOR" c:identifier="GLIB_DEPRECATED_IN_2_72_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_74_FOR" c:identifier="GLIB_DEPRECATED_IN_2_74_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_76_FOR" c:identifier="GLIB_DEPRECATED_IN_2_76_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_78_FOR" c:identifier="GLIB_DEPRECATED_IN_2_78_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_80_FOR" c:identifier="GLIB_DEPRECATED_IN_2_80_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_82_FOR" c:identifier="GLIB_DEPRECATED_IN_2_82_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_84_FOR" c:identifier="GLIB_DEPRECATED_IN_2_84_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_86_FOR" c:identifier="GLIB_DEPRECATED_IN_2_86_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_88_FOR" c:identifier="GLIB_DEPRECATED_IN_2_88_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_FOR" c:identifier="GLIB_DEPRECATED_MACRO_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_26_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_26_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_28_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_28_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_30_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_30_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_32_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_32_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_34_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_34_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_36_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_36_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_38_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_38_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_40_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_40_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_42_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_42_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_44_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_44_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_46_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_46_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_48_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_48_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_50_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_50_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_52_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_52_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_54_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_54_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_56_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_56_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_58_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_58_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_60_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_60_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_62_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_62_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_64_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_64_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_66_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_66_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_68_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_68_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_70_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_70_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_72_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_72_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_74_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_74_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_76_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_76_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_78_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_78_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_80_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_80_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_82_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_82_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_84_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_84_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_86_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_86_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_88_FOR" c:identifier="GLIB_DEPRECATED_MACRO_IN_2_88_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_FOR" c:identifier="GLIB_DEPRECATED_TYPE_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_26_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_26_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_28_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_28_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_30_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_30_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_32_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_32_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_34_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_34_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_36_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_36_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_38_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_38_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_40_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_40_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_42_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_42_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_44_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_44_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_46_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_46_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_48_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_48_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_50_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_50_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_52_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_52_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_54_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_54_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_56_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_56_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_58_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_58_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_60_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_60_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_62_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_62_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_64_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_64_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_66_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_66_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_68_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_68_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_70_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_70_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_72_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_72_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_74_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_74_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_76_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_76_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_78_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_78_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_80_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_80_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_82_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_82_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_84_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_84_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_86_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_86_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_88_FOR" c:identifier="GLIB_DEPRECATED_TYPE_IN_2_88_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="DIR_SEPARATOR" value="47" c:type="G_DIR_SEPARATOR">
      <doc xml:space="preserve">The directory separator character.

This is `'/'` on UNIX machines and `'\'` under Windows.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="DIR_SEPARATOR_S" value="/" c:type="G_DIR_SEPARATOR_S">
      <doc xml:space="preserve">The directory separator as a string.

This is `"/"` on UNIX machines and `"\"` under Windows.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="Data" c:type="GData" disguised="1" opaque="1">
      <doc xml:space="preserve">An opaque data structure that represents a keyed data list.

See also: [Keyed data lists](datalist-and-dataset.html).</doc>
    </record>
    <callback name="DataForeachFunc" c:type="GDataForeachFunc">
      <doc xml:space="preserve">Specifies the type of function passed to g_dataset_foreach(). It is
called with each #GQuark id and associated data element, together
with the @user_data parameter supplied to g_dataset_foreach().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark id to identifying the data element.</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data element.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data passed to g_dataset_foreach().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Date" c:type="GDate" glib:type-name="GDate" glib:get-type="g_date_get_type" c:symbol-prefix="date">
      <doc xml:space="preserve">`GDate` is a struct for calendrical calculations.

The `GDate` data structure represents a day between January 1, Year 1,
and sometime a few thousand years in the future (right now it will go
to the year 65535 or so, but [method@GLib.Date.set_parse] only parses up to the
year 8000 or so - just count on "a few thousand"). `GDate` is meant to
represent everyday dates, not astronomical dates or historical dates
or ISO timestamps or the like. It extrapolates the current Gregorian
calendar forward and backward in time; there is no attempt to change
the calendar to match time periods or locations. `GDate` does not store
time information; it represents a day.

The `GDate` implementation has several nice features; it is only a
64-bit struct, so storing large numbers of dates is very efficient. It
can keep both a Julian and day-month-year representation of the date,
since some calculations are much easier with one representation or the
other. A Julian representation is simply a count of days since some
fixed day in the past; for #GDate the fixed day is January 1, 1 AD.
("Julian" dates in the #GDate API aren't really Julian dates in the
technical sense; technically, Julian dates count from the start of the
Julian period, Jan 1, 4713 BC).

`GDate` is simple to use. First you need a "blank" date; you can get a
dynamically allocated date from [ctor@GLib.Date.new], or you can declare an
automatic variable or array and initialize it by calling [method@GLib.Date.clear].
A cleared date is safe; it's safe to call [method@GLib.Date.set_dmy] and the other
mutator functions to initialize the value of a cleared date. However, a cleared date
is initially invalid, meaning that it doesn't represent a day that exists.
It is undefined to call any of the date calculation routines on an invalid date.
If you obtain a date from a user or other unpredictable source, you should check
its validity with the [method@GLib.Date.valid] predicate. [method@GLib.Date.valid]
is also used to check for errors with [method@GLib.Date.set_parse] and other functions
that can fail. Dates can be invalidated by calling [method@GLib.Date.clear] again.

It is very important to use the API to access the `GDate` struct. Often only the
day-month-year or only the Julian representation is valid. Sometimes neither is valid.
Use the API.

GLib also features `GDateTime` which represents a precise time.</doc>
      <field name="julian_days" writable="1" bits="32">
        <doc xml:space="preserve">the Julian representation of the date</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="julian" writable="1" bits="1">
        <doc xml:space="preserve">this bit is set if @julian_days is valid</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="dmy" writable="1" bits="1">
        <doc xml:space="preserve">this is set if @day, @month and @year are valid</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="day" writable="1" bits="6">
        <doc xml:space="preserve">the day of the day-month-year representation of the date,
  as a number between 1 and 31</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="month" writable="1" bits="4">
        <doc xml:space="preserve">the month of the day-month-year representation of the date,
  as a number between 1 and 12</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="year" writable="1" bits="16">
        <doc xml:space="preserve">the year of the day-month-year representation of the date</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <constructor name="new" c:identifier="g_date_new">
        <doc xml:space="preserve">Allocates a #GDate and initializes
it to a safe state. The new date will
be cleared (as if you'd called g_date_clear()) but invalid (it won't
represent an existing day). Free the return value with g_date_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated #GDate</doc>
          <type name="Date" c:type="GDate*"/>
        </return-value>
      </constructor>
      <constructor name="new_dmy" c:identifier="g_date_new_dmy">
        <doc xml:space="preserve">Create a new #GDate representing the given day-month-year triplet.

The triplet you pass in must represent a valid date. Use g_date_valid_dmy()
if needed to validate it. The returned #GDate is guaranteed to be non-%NULL
and valid.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated #GDate
  initialized with @day, @month, and @year</doc>
          <type name="Date" c:type="GDate*"/>
        </return-value>
        <parameters>
          <parameter name="day" transfer-ownership="none">
            <doc xml:space="preserve">day of the month</doc>
            <type name="DateDay" c:type="GDateDay"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:space="preserve">month of the year</doc>
            <type name="DateMonth" c:type="GDateMonth"/>
          </parameter>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">year</doc>
            <type name="DateYear" c:type="GDateYear"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_julian" c:identifier="g_date_new_julian">
        <doc xml:space="preserve">Create a new #GDate representing the given Julian date.

The @julian_day you pass in must be valid. Use g_date_valid_julian() if
needed to validate it. The returned #GDate is guaranteed to be non-%NULL and
valid.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated #GDate initialized
  with @julian_day</doc>
          <type name="Date" c:type="GDate*"/>
        </return-value>
        <parameters>
          <parameter name="julian_day" transfer-ownership="none">
            <doc xml:space="preserve">days since January 1, Year 1</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_days" c:identifier="g_date_add_days">
        <doc xml:space="preserve">Increments a date some number of days.
To move forward by weeks, add weeks*7 days.
The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to increment</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="n_days" transfer-ownership="none">
            <doc xml:space="preserve">number of days to move the date forward</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_months" c:identifier="g_date_add_months">
        <doc xml:space="preserve">Increments a date by some number of months.
If the day of the month is greater than 28,
this routine may change the day of the month
(because the destination month may not have
the current day in it). The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to increment</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="n_months" transfer-ownership="none">
            <doc xml:space="preserve">number of months to move forward</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_years" c:identifier="g_date_add_years">
        <doc xml:space="preserve">Increments a date by some number of years.
If the date is February 29, and the destination
year is not a leap year, the date will be changed
to February 28. The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to increment</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="n_years" transfer-ownership="none">
            <doc xml:space="preserve">number of years to move forward</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clamp" c:identifier="g_date_clamp">
        <doc xml:space="preserve">If @date is prior to @min_date, sets @date equal to @min_date.
If @date falls after @max_date, sets @date equal to @max_date.
Otherwise, @date is unchanged.
Either of @min_date and @max_date may be %NULL.
All non-%NULL dates must be valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to clamp</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="min_date" transfer-ownership="none">
            <doc xml:space="preserve">minimum accepted value for @date</doc>
            <type name="Date" c:type="const GDate*"/>
          </parameter>
          <parameter name="max_date" transfer-ownership="none">
            <doc xml:space="preserve">maximum accepted value for @date</doc>
            <type name="Date" c:type="const GDate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="g_date_clear">
        <doc xml:space="preserve">Initializes one or more #GDate structs to a safe but invalid
state. The cleared dates will not represent an existing date, but will
not contain garbage. Useful to init a date declared on the stack.
Validity can be tested with g_date_valid().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">pointer to one or more dates to clear</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="n_dates" transfer-ownership="none">
            <doc xml:space="preserve">number of dates to clear</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="compare" c:identifier="g_date_compare">
        <doc xml:space="preserve">qsort()-style comparison function for dates.
Both dates must be valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 for equal, less than zero if @lhs is less than @rhs,
    greater than zero if @lhs is greater than @rhs</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="lhs" transfer-ownership="none">
            <doc xml:space="preserve">first date to compare</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
          <parameter name="rhs" transfer-ownership="none">
            <doc xml:space="preserve">second date to compare</doc>
            <type name="Date" c:type="const GDate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="g_date_copy" version="2.56">
        <doc xml:space="preserve">Copies a GDate to a newly-allocated GDate. If the input was invalid
(as determined by g_date_valid()), the invalid state will be copied
as is into the new object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated #GDate initialized from @date</doc>
          <type name="Date" c:type="GDate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to copy</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="days_between" c:identifier="g_date_days_between">
        <doc xml:space="preserve">Computes the number of days between two dates.
If @date2 is prior to @date1, the returned value is negative.
Both dates must be valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of days between @date1 and @date2</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="date1" transfer-ownership="none">
            <doc xml:space="preserve">the first date</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
          <parameter name="date2" transfer-ownership="none">
            <doc xml:space="preserve">the second date</doc>
            <type name="Date" c:type="const GDate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_date_free">
        <doc xml:space="preserve">Frees a #GDate returned from g_date_new().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to free</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_day" c:identifier="g_date_get_day">
        <doc xml:space="preserve">Returns the day of the month. The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">day of the month</doc>
          <type name="DateDay" c:type="GDateDay"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to extract the day of the month from</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_day_of_year" c:identifier="g_date_get_day_of_year">
        <doc xml:space="preserve">Returns the day of the year, where Jan 1 is the first day of the
year. The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">day of the year</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to extract day of year from</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_iso8601_week_of_year" c:identifier="g_date_get_iso8601_week_of_year" version="2.6">
        <doc xml:space="preserve">Returns the week of the year, where weeks are interpreted according
to ISO 8601.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">ISO 8601 week number of the year.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GDate</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_julian" c:identifier="g_date_get_julian">
        <doc xml:space="preserve">Returns the Julian day or "serial number" of the #GDate. The
Julian day is simply the number of days since January 1, Year 1; i.e.,
January 1, Year 1 is Julian day 1; January 2, Year 1 is Julian day 2,
etc. The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Julian day</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to extract the Julian day from</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_monday_week_of_year" c:identifier="g_date_get_monday_week_of_year">
        <doc xml:space="preserve">Returns the week of the year, where weeks are understood to start on
Monday. If the date is before the first Monday of the year, return 0.
The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">week of the year</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_month" c:identifier="g_date_get_month">
        <doc xml:space="preserve">Returns the month of the year. The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">month of the year as a #GDateMonth</doc>
          <type name="DateMonth" c:type="GDateMonth"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to get the month from</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sunday_week_of_year" c:identifier="g_date_get_sunday_week_of_year">
        <doc xml:space="preserve">Returns the week of the year during which this date falls, if
weeks are understood to begin on Sunday. The date must be valid.
Can return 0 if the day is before the first Sunday of the year.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">week number</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_week_of_year" c:identifier="g_date_get_week_of_year" version="2.86">
        <doc xml:space="preserve">Calculates the week of the year during which this date falls.

The result depends on which day is considered the first day of the week,
which varies by locale. Both `date` and `first_day_of_week` must be valid.

If @date is before the start of the first week of the year (for example,
before the first Monday in January if @first_day_of_week is
[enum@GLib.DateWeekday.MONDAY]) then zero will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">week number (starting from 1), or `0` if @date is before the start
   of the first week of the year</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a [struct@GLib.Date]</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
          <parameter name="first_day_of_week" transfer-ownership="none">
            <doc xml:space="preserve">the day which is considered the first day of the week
   (for example, this would be [enum@GLib.DateWeekday.SUNDAY] in US locales,
   [enum@GLib.DateWeekday.MONDAY] in British locales, and
   [enum@GLib.DateWeekday.SATURDAY] in Egyptian locales</doc>
            <type name="DateWeekday" c:type="GDateWeekday"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_weekday" c:identifier="g_date_get_weekday">
        <doc xml:space="preserve">Returns the day of the week for a #GDate. The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">day of the week as a #GDateWeekday.</doc>
          <type name="DateWeekday" c:type="GDateWeekday"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_year" c:identifier="g_date_get_year">
        <doc xml:space="preserve">Returns the year of a #GDate. The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">year in which the date falls</doc>
          <type name="DateYear" c:type="GDateYear"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_first_of_month" c:identifier="g_date_is_first_of_month">
        <doc xml:space="preserve">Returns %TRUE if the date is on the first of a month.
The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the date is the first of the month</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to check</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_last_of_month" c:identifier="g_date_is_last_of_month">
        <doc xml:space="preserve">Returns %TRUE if the date is the last day of the month.
The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the date is the last day of the month</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to check</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="order" c:identifier="g_date_order">
        <doc xml:space="preserve">Checks if @date1 is less than or equal to @date2,
and swap the values if this is not the case.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date1" transfer-ownership="none">
            <doc xml:space="preserve">the first date</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="date2" transfer-ownership="none">
            <doc xml:space="preserve">the second date</doc>
            <type name="Date" c:type="GDate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_day" c:identifier="g_date_set_day">
        <doc xml:space="preserve">Sets the day of the month for a #GDate. If the resulting
day-month-year triplet is invalid, the date will be invalid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="day" transfer-ownership="none">
            <doc xml:space="preserve">day to set</doc>
            <type name="DateDay" c:type="GDateDay"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dmy" c:identifier="g_date_set_dmy">
        <doc xml:space="preserve">Sets the value of a #GDate from a day, month, and year.
The day-month-year triplet must be valid; if you aren't
sure it is, call g_date_valid_dmy() to check before you
set it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="day" transfer-ownership="none">
            <doc xml:space="preserve">day</doc>
            <type name="DateDay" c:type="GDateDay"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:space="preserve">month</doc>
            <type name="DateMonth" c:type="GDateMonth"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">year</doc>
            <type name="DateYear" c:type="GDateYear"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_julian" c:identifier="g_date_set_julian">
        <doc xml:space="preserve">Sets the value of a #GDate from a Julian day number.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="julian_date" transfer-ownership="none">
            <doc xml:space="preserve">Julian day number (days since January 1, Year 1)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_month" c:identifier="g_date_set_month">
        <doc xml:space="preserve">Sets the month of the year for a #GDate.  If the resulting
day-month-year triplet is invalid, the date will be invalid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:space="preserve">month to set</doc>
            <type name="DateMonth" c:type="GDateMonth"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parse" c:identifier="g_date_set_parse">
        <doc xml:space="preserve">Parses a user-inputted string @str, and try to figure out what date it
represents, taking the [current locale](running.html#locale)
into account. If the string is successfully parsed, the date will be
valid after the call. Otherwise, it will be invalid. You should check
using g_date_valid() to see whether the parsing succeeded.

This function is not appropriate for file formats and the like; it
isn't very precise, and its exact behavior varies with the locale.
It's intended to be a heuristic routine that guesses what the user
means by a given string (and it does work pretty well in that
capacity).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to fill in</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">string to parse</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_time" c:identifier="g_date_set_time" deprecated="1" deprecated-version="2.10">
        <doc xml:space="preserve">Sets the value of a date from a #GTime value.
The time to date conversion is done using the user's current timezone.</doc>
        <doc-deprecated xml:space="preserve">Use g_date_set_time_t() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate.</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="time_" transfer-ownership="none">
            <doc xml:space="preserve">#GTime value to set.</doc>
            <type name="Time" c:type="GTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_time_t" c:identifier="g_date_set_time_t" version="2.10">
        <doc xml:space="preserve">Sets the value of a date to the date corresponding to a time
specified as a time_t. The time to date conversion is done using
the user's current timezone.

To set the value of a date to the current day, you could write:
|[&lt;!-- language="C" --&gt;
 time_t now = time (NULL);
 if (now == (time_t) -1)
   // handle the error
 g_date_set_time_t (date, now);
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="timet" transfer-ownership="none">
            <doc xml:space="preserve">time_t value to set</doc>
            <type name="time_t" c:type="time_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_time_val" c:identifier="g_date_set_time_val" version="2.10" deprecated="1" deprecated-version="2.62">
        <doc xml:space="preserve">Sets the value of a date from a #GTimeVal value.  Note that the
@tv_usec member is ignored, because #GDate can't make use of the
additional precision.

The time to date conversion is done using the user's current timezone.</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use g_date_set_time_t()
   instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="timeval" transfer-ownership="none">
            <doc xml:space="preserve">#GTimeVal value to set</doc>
            <type name="TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_year" c:identifier="g_date_set_year">
        <doc xml:space="preserve">Sets the year for a #GDate. If the resulting day-month-year
triplet is invalid, the date will be invalid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">year to set</doc>
            <type name="DateYear" c:type="GDateYear"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract_days" c:identifier="g_date_subtract_days">
        <doc xml:space="preserve">Moves a date some number of days into the past.
To move by weeks, just move by weeks*7 days.
The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to decrement</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="n_days" transfer-ownership="none">
            <doc xml:space="preserve">number of days to move</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract_months" c:identifier="g_date_subtract_months">
        <doc xml:space="preserve">Moves a date some number of months into the past.
If the current day of the month doesn't exist in
the destination month, the day of the month
may change. The date must be valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to decrement</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="n_months" transfer-ownership="none">
            <doc xml:space="preserve">number of months to move</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract_years" c:identifier="g_date_subtract_years">
        <doc xml:space="preserve">Moves a date some number of years into the past.
If the current day doesn't exist in the destination
year (i.e. it's February 29 and you move to a non-leap-year)
then the day is changed to February 29. The date
must be valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to decrement</doc>
            <type name="Date" c:type="GDate*"/>
          </instance-parameter>
          <parameter name="n_years" transfer-ownership="none">
            <doc xml:space="preserve">number of years to move</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_struct_tm" c:identifier="g_date_to_struct_tm">
        <doc xml:space="preserve">Fills in the date-related bits of a struct tm using the @date value.
Initializes the non-date parts with something safe but meaningless.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to set the struct tm from</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
          <parameter name="tm" transfer-ownership="none">
            <doc xml:space="preserve">struct tm to fill</doc>
            <type name="gpointer" c:type="tm*"/>
          </parameter>
        </parameters>
      </method>
      <method name="valid" c:identifier="g_date_valid">
        <doc xml:space="preserve">Returns %TRUE if the #GDate represents an existing day. The date must not
contain garbage; it should have been initialized with g_date_clear()
if it wasn't allocated by one of the g_date_new() variants.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the date is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a #GDate to check</doc>
            <type name="Date" c:type="const GDate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="get_days_in_month" c:identifier="g_date_get_days_in_month">
        <doc xml:space="preserve">Returns the number of days in a month, taking leap
years into account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of days in @month during the @year</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <parameter name="month" transfer-ownership="none">
            <doc xml:space="preserve">month</doc>
            <type name="DateMonth" c:type="GDateMonth"/>
          </parameter>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">year</doc>
            <type name="DateYear" c:type="GDateYear"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_monday_weeks_in_year" c:identifier="g_date_get_monday_weeks_in_year">
        <doc xml:space="preserve">Returns the number of weeks in the year, where weeks
are taken to start on Monday. Will be 52 or 53. The
date must be valid. (Years always have 52 7-day periods,
plus 1 or 2 extra days depending on whether it's a leap
year. This function is basically telling you how many
Mondays are in the year, i.e. there are 53 Mondays if
one of the extra days happens to be a Monday.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of Mondays in the year</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">a year</doc>
            <type name="DateYear" c:type="GDateYear"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_sunday_weeks_in_year" c:identifier="g_date_get_sunday_weeks_in_year">
        <doc xml:space="preserve">Returns the number of weeks in the year, where weeks
are taken to start on Sunday. Will be 52 or 53. The
date must be valid. (Years always have 52 7-day periods,
plus 1 or 2 extra days depending on whether it's a leap
year. This function is basically telling you how many
Sundays are in the year, i.e. there are 53 Sundays if
one of the extra days happens to be a Sunday.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of weeks in @year</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">year to count weeks in</doc>
            <type name="DateYear" c:type="GDateYear"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_weeks_in_year" c:identifier="g_date_get_weeks_in_year" version="2.86">
        <doc xml:space="preserve">Calculates the number of weeks in the year.

The result depends on which day is considered the first day of the week,
which varies by locale. `first_day_of_week` must be valid.

The result will be either 52 or 53. Years always have 52 seven-day periods,
plus one or two extra days depending on whether it&#x2019;s a leap year. This
function effectively calculates how many @first_day_of_week days there are in
the year.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of weeks in @year</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">year to count weeks in</doc>
            <type name="DateYear" c:type="GDateYear"/>
          </parameter>
          <parameter name="first_day_of_week" transfer-ownership="none">
            <doc xml:space="preserve">the day which is considered the first day of the week
   (for example, this would be [enum@GLib.DateWeekday.SUNDAY] in US locales,
   [enum@GLib.DateWeekday.MONDAY] in British locales, and
   [enum@GLib.DateWeekday.SATURDAY] in Egyptian locales</doc>
            <type name="DateWeekday" c:type="GDateWeekday"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_leap_year" c:identifier="g_date_is_leap_year">
        <doc xml:space="preserve">Returns %TRUE if the year is a leap year.

For the purposes of this function, leap year is every year
divisible by 4 unless that year is divisible by 100. If it
is divisible by 100 it would be a leap year only if that year
is also divisible by 400.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the year is a leap year</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">year to check</doc>
            <type name="DateYear" c:type="GDateYear"/>
          </parameter>
        </parameters>
      </function>
      <function name="strftime" c:identifier="g_date_strftime">
        <doc xml:space="preserve">Generates a printed representation of the date, in a
[locale](running.html#locale)-specific way.
Works just like the platform's C library strftime() function,
but only accepts date-related formats; time-related formats
give undefined results. Date must be valid. Unlike strftime()
(which uses the locale encoding), works on a UTF-8 format
string and stores a UTF-8 result.

This function does not provide any conversion specifiers in
addition to those implemented by the platform's C library.
For example, don't expect that using g_date_strftime() would
make the \%F provided by the C99 strftime() work on Windows
where the C library only complies to C89.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of characters written to the buffer, or `0` if the buffer was too small</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">destination buffer</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="slen" transfer-ownership="none">
            <doc xml:space="preserve">buffer size</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">valid #GDate</doc>
            <type name="Date" c:type="const GDate*"/>
          </parameter>
        </parameters>
      </function>
      <function name="valid_day" c:identifier="g_date_valid_day">
        <doc xml:space="preserve">Returns %TRUE if the day of the month is valid (a day is valid if it's
between 1 and 31 inclusive).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the day is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="day" transfer-ownership="none">
            <doc xml:space="preserve">day to check</doc>
            <type name="DateDay" c:type="GDateDay"/>
          </parameter>
        </parameters>
      </function>
      <function name="valid_dmy" c:identifier="g_date_valid_dmy">
        <doc xml:space="preserve">Returns %TRUE if the day-month-year triplet forms a valid, existing day
in the range of days #GDate understands (Year 1 or later, no more than
a few thousand years in the future).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the date is a valid one</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="day" transfer-ownership="none">
            <doc xml:space="preserve">day</doc>
            <type name="DateDay" c:type="GDateDay"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:space="preserve">month</doc>
            <type name="DateMonth" c:type="GDateMonth"/>
          </parameter>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">year</doc>
            <type name="DateYear" c:type="GDateYear"/>
          </parameter>
        </parameters>
      </function>
      <function name="valid_julian" c:identifier="g_date_valid_julian">
        <doc xml:space="preserve">Returns %TRUE if the Julian day is valid. Anything greater than zero
is basically a valid Julian, though there is a 32-bit limit.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the Julian day is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="julian_date" transfer-ownership="none">
            <doc xml:space="preserve">Julian day to check</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </function>
      <function name="valid_month" c:identifier="g_date_valid_month">
        <doc xml:space="preserve">Returns %TRUE if the month value is valid. The 12 #GDateMonth
enumeration values are the only valid months.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the month is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="month" transfer-ownership="none">
            <doc xml:space="preserve">month</doc>
            <type name="DateMonth" c:type="GDateMonth"/>
          </parameter>
        </parameters>
      </function>
      <function name="valid_weekday" c:identifier="g_date_valid_weekday">
        <doc xml:space="preserve">Returns %TRUE if the weekday is valid. The seven #GDateWeekday enumeration
values are the only valid weekdays.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the weekday is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="weekday" transfer-ownership="none">
            <doc xml:space="preserve">weekday</doc>
            <type name="DateWeekday" c:type="GDateWeekday"/>
          </parameter>
        </parameters>
      </function>
      <function name="valid_year" c:identifier="g_date_valid_year">
        <doc xml:space="preserve">Returns %TRUE if the year is valid. Any year greater than 0 is valid,
though there is a 16-bit limit to what #GDate will understand.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the year is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">year</doc>
            <type name="DateYear" c:type="GDateYear"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="DateDMY" c:type="GDateDMY">
      <doc xml:space="preserve">This enumeration isn't used in the API, but may be useful if you need
to mark a number as a day, month, or year.</doc>
      <member name="day" value="0" c:identifier="G_DATE_DAY">
        <doc xml:space="preserve">a day</doc>
      </member>
      <member name="month" value="1" c:identifier="G_DATE_MONTH">
        <doc xml:space="preserve">a month</doc>
      </member>
      <member name="year" value="2" c:identifier="G_DATE_YEAR">
        <doc xml:space="preserve">a year</doc>
      </member>
    </enumeration>
    <enumeration name="DateMonth" c:type="GDateMonth">
      <doc xml:space="preserve">Enumeration representing a month; values are %G_DATE_JANUARY,
%G_DATE_FEBRUARY, etc. %G_DATE_BAD_MONTH is the invalid value.</doc>
      <member name="bad_month" value="0" c:identifier="G_DATE_BAD_MONTH">
        <doc xml:space="preserve">invalid value</doc>
      </member>
      <member name="january" value="1" c:identifier="G_DATE_JANUARY">
        <doc xml:space="preserve">January</doc>
      </member>
      <member name="february" value="2" c:identifier="G_DATE_FEBRUARY">
        <doc xml:space="preserve">February</doc>
      </member>
      <member name="march" value="3" c:identifier="G_DATE_MARCH">
        <doc xml:space="preserve">March</doc>
      </member>
      <member name="april" value="4" c:identifier="G_DATE_APRIL">
        <doc xml:space="preserve">April</doc>
      </member>
      <member name="may" value="5" c:identifier="G_DATE_MAY">
        <doc xml:space="preserve">May</doc>
      </member>
      <member name="june" value="6" c:identifier="G_DATE_JUNE">
        <doc xml:space="preserve">June</doc>
      </member>
      <member name="july" value="7" c:identifier="G_DATE_JULY">
        <doc xml:space="preserve">July</doc>
      </member>
      <member name="august" value="8" c:identifier="G_DATE_AUGUST">
        <doc xml:space="preserve">August</doc>
      </member>
      <member name="september" value="9" c:identifier="G_DATE_SEPTEMBER">
        <doc xml:space="preserve">September</doc>
      </member>
      <member name="october" value="10" c:identifier="G_DATE_OCTOBER">
        <doc xml:space="preserve">October</doc>
      </member>
      <member name="november" value="11" c:identifier="G_DATE_NOVEMBER">
        <doc xml:space="preserve">November</doc>
      </member>
      <member name="december" value="12" c:identifier="G_DATE_DECEMBER">
        <doc xml:space="preserve">December</doc>
      </member>
    </enumeration>
    <record name="DateTime" c:type="GDateTime" opaque="1" version="2.26" glib:type-name="GDateTime" glib:get-type="g_date_time_get_type" c:symbol-prefix="date_time">
      <doc xml:space="preserve">`GDateTime` is a structure that combines a Gregorian date and time
into a single structure.

`GDateTime` provides many conversion and methods to manipulate dates and times.
Time precision is provided down to microseconds and the time can range
(proleptically) from 0001-01-01 00:00:00 to 9999-12-31 23:59:59.999999.
`GDateTime` follows POSIX time in the sense that it is oblivious to leap
seconds.

`GDateTime` is an immutable object; once it has been created it cannot
be modified further. All modifiers will create a new `GDateTime`.
Nearly all such functions can fail due to the date or time going out
of range, in which case %NULL will be returned.

`GDateTime` is reference counted: the reference count is increased by calling
[method@GLib.DateTime.ref] and decreased by calling [method@GLib.DateTime.unref].
When the reference count drops to 0, the resources allocated by the `GDateTime`
structure are released.

Many parts of the API may produce non-obvious results. As an
example, adding two months to January 31st will yield March 31st
whereas adding one month and then one month again will yield either
March 28th or March 29th.  Also note that adding 24 hours is not
always the same as adding one day (since days containing daylight
savings time transitions are either 23 or 25 hours in length).</doc>
      <constructor name="new" c:identifier="g_date_time_new" version="2.26">
        <doc xml:space="preserve">Creates a new #GDateTime corresponding to the given date and time in
the time zone @tz.

The @year must be between 1 and 9999, @month between 1 and 12 and @day
between 1 and 28, 29, 30 or 31 depending on the month and the year.

@hour must be between 0 and 23 and @minute must be between 0 and 59.

@seconds must be at least 0.0 and must be strictly less than 60.0.
It will be rounded down to the nearest microsecond.

If the given time is not representable in the given time zone (for
example, 02:30 on March 14th 2010 in Toronto, due to daylight savings
time) then the time will be rounded up to the nearest existing time
(in this case, 03:00).  If this matters to you then you should verify
the return value for containing the same as the numbers you gave.

In the case that the given time is ambiguous in the given time zone
(for example, 01:30 on November 7th 2010 in Toronto, due to daylight
savings time) then the time falling within standard (ie:
non-daylight) time is taken.

It not considered a programmer error for the values to this function
to be out of range, but in the case that they are, the function will
return %NULL.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </parameter>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">the year component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:space="preserve">the month component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="day" transfer-ownership="none">
            <doc xml:space="preserve">the day component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hour" transfer-ownership="none">
            <doc xml:space="preserve">the hour component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minute" transfer-ownership="none">
            <doc xml:space="preserve">the minute component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="seconds" transfer-ownership="none">
            <doc xml:space="preserve">the number of seconds past the minute</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_iso8601" c:identifier="g_date_time_new_from_iso8601" version="2.56">
        <doc xml:space="preserve">Creates a #GDateTime corresponding to the given
[ISO 8601 formatted string](https://en.wikipedia.org/wiki/ISO_8601)
@text. ISO 8601 strings of the form `&lt;date&gt;&lt;sep&gt;&lt;time&gt;&lt;tz&gt;` are supported, with
some extensions from [RFC 3339](https://tools.ietf.org/html/rfc3339) as
mentioned below.

Note that as #GDateTime "is oblivious to leap seconds", leap seconds information
in an ISO-8601 string will be ignored, so a `23:59:60` time would be parsed as
`23:59:59`.

`&lt;sep&gt;` is the separator and can be either 'T', 't' or ' '. The latter two
separators are an extension from
[RFC 3339](https://tools.ietf.org/html/rfc3339#section-5.6).

`&lt;date&gt;` is in the form:

- `YYYY-MM-DD` - Year/month/day, e.g. 2016-08-24.
- `YYYYMMDD` - Same as above without dividers.
- `YYYY-DDD` - Ordinal day where DDD is from 001 to 366, e.g. 2016-237.
- `YYYYDDD` - Same as above without dividers.
- `YYYY-Www-D` - Week day where ww is from 01 to 52 and D from 1-7,
  e.g. 2016-W34-3.
- `YYYYWwwD` - Same as above without dividers.

`&lt;time&gt;` is in the form:

- `hh:mm:ss(.sss)` - Hours, minutes, seconds (subseconds), e.g. 22:10:42.123.
- `hhmmss(.sss)` - Same as above without dividers.

`&lt;tz&gt;` is an optional timezone suffix of the form:

- `Z` - UTC.
- `+hh:mm` or `-hh:mm` - Offset from UTC in hours and minutes, e.g. +12:00.
- `+hh` or `-hh` - Offset from UTC in hours, e.g. +12.

If the timezone is not provided in @text it must be provided in @default_tz
(this field is otherwise ignored).

This call can fail (returning %NULL) if @text is not a valid ISO 8601
formatted string.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">an ISO 8601 formatted time string.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="default_tz" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GTimeZone to use if the text doesn't contain a
                         timezone, or %NULL.</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_timeval_local" c:identifier="g_date_time_new_from_timeval_local" version="2.26" deprecated="1" deprecated-version="2.62">
        <doc xml:space="preserve">Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
local time zone.

The time contained in a #GTimeVal is always stored in the form of
seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
local time offset.

This call can fail (returning %NULL) if @tv represents a time outside
of the supported range of #GDateTime.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use
   g_date_time_new_from_unix_local() instead.</doc-deprecated>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="tv" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal</doc>
            <type name="TimeVal" c:type="const GTimeVal*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_timeval_utc" c:identifier="g_date_time_new_from_timeval_utc" version="2.26" deprecated="1" deprecated-version="2.62">
        <doc xml:space="preserve">Creates a #GDateTime corresponding to the given #GTimeVal @tv in UTC.

The time contained in a #GTimeVal is always stored in the form of
seconds elapsed since 1970-01-01 00:00:00 UTC.

This call can fail (returning %NULL) if @tv represents a time outside
of the supported range of #GDateTime.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use
   g_date_time_new_from_unix_utc() instead.</doc-deprecated>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="tv" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal</doc>
            <type name="TimeVal" c:type="const GTimeVal*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_unix_local" c:identifier="g_date_time_new_from_unix_local" version="2.26">
        <doc xml:space="preserve">Creates a #GDateTime corresponding to the given Unix time @t in the
local time zone.

Unix time is the number of seconds that have elapsed since 1970-01-01
00:00:00 UTC, regardless of the local time offset.

This call can fail (returning %NULL) if @t represents a time outside
of the supported range of #GDateTime.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">the Unix time</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_unix_local_usec" c:identifier="g_date_time_new_from_unix_local_usec" version="2.80">
        <doc xml:space="preserve">Creates a [struct@GLib.DateTime] corresponding to the given Unix time @t in the
local time zone.

Unix time is the number of microseconds that have elapsed since 1970-01-01
00:00:00 UTC, regardless of the local time offset.

This call can fail (returning `NULL`) if @t represents a time outside
of the supported range of #GDateTime.

You should release the return value by calling [method@GLib.DateTime.unref]
when you are done with it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new [struct@GLib.DateTime], or `NULL`</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="usecs" transfer-ownership="none">
            <doc xml:space="preserve">the Unix time in microseconds</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_unix_utc" c:identifier="g_date_time_new_from_unix_utc" version="2.26">
        <doc xml:space="preserve">Creates a #GDateTime corresponding to the given Unix time @t in UTC.

Unix time is the number of seconds that have elapsed since 1970-01-01
00:00:00 UTC.

This call can fail (returning %NULL) if @t represents a time outside
of the supported range of #GDateTime.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">the Unix time</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_unix_utc_usec" c:identifier="g_date_time_new_from_unix_utc_usec" version="2.80">
        <doc xml:space="preserve">Creates a [struct@GLib.DateTime] corresponding to the given Unix time @t in UTC.

Unix time is the number of microseconds that have elapsed since 1970-01-01
00:00:00 UTC.

This call can fail (returning `NULL`) if @t represents a time outside
of the supported range of #GDateTime.

You should release the return value by calling [method@GLib.DateTime.unref]
when you are done with it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new [struct@GLib.DateTime], or `NULL`</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="usecs" transfer-ownership="none">
            <doc xml:space="preserve">the Unix time in microseconds</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_local" c:identifier="g_date_time_new_local" version="2.26">
        <doc xml:space="preserve">Creates a new #GDateTime corresponding to the given date and time in
the local time zone.

This call is equivalent to calling g_date_time_new() with the time
zone returned by g_time_zone_new_local().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">the year component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:space="preserve">the month component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="day" transfer-ownership="none">
            <doc xml:space="preserve">the day component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hour" transfer-ownership="none">
            <doc xml:space="preserve">the hour component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minute" transfer-ownership="none">
            <doc xml:space="preserve">the minute component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="seconds" transfer-ownership="none">
            <doc xml:space="preserve">the number of seconds past the minute</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_now" c:identifier="g_date_time_new_now" version="2.26">
        <doc xml:space="preserve">Creates a #GDateTime corresponding to this exact instant in the given
time zone @tz.  The time is as accurate as the system allows, to a
maximum accuracy of 1 microsecond.

This function will always succeed unless GLib is still being used after the
year 9999.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_now_local" c:identifier="g_date_time_new_now_local" version="2.26">
        <doc xml:space="preserve">Creates a #GDateTime corresponding to this exact instant in the local
time zone.

This is equivalent to calling g_date_time_new_now() with the time
zone returned by g_time_zone_new_local().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
      </constructor>
      <constructor name="new_now_utc" c:identifier="g_date_time_new_now_utc" version="2.26">
        <doc xml:space="preserve">Creates a #GDateTime corresponding to this exact instant in UTC.

This is equivalent to calling g_date_time_new_now() with the time
zone returned by g_time_zone_new_utc().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
      </constructor>
      <constructor name="new_utc" c:identifier="g_date_time_new_utc" version="2.26">
        <doc xml:space="preserve">Creates a new #GDateTime corresponding to the given date and time in
UTC.

This call is equivalent to calling g_date_time_new() with the time
zone returned by g_time_zone_new_utc().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:space="preserve">the year component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:space="preserve">the month component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="day" transfer-ownership="none">
            <doc xml:space="preserve">the day component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hour" transfer-ownership="none">
            <doc xml:space="preserve">the hour component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minute" transfer-ownership="none">
            <doc xml:space="preserve">the minute component of the date</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="seconds" transfer-ownership="none">
            <doc xml:space="preserve">the number of seconds past the minute</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="g_date_time_add" version="2.26">
        <doc xml:space="preserve">Creates a copy of @datetime and adds the specified timespan to the copy.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="timespan" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeSpan</doc>
            <type name="TimeSpan" c:type="GTimeSpan"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_days" c:identifier="g_date_time_add_days" version="2.26">
        <doc xml:space="preserve">Creates a copy of @datetime and adds the specified number of days to the
copy. Add negative values to subtract days.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="days" transfer-ownership="none">
            <doc xml:space="preserve">the number of days</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_full" c:identifier="g_date_time_add_full" version="2.26">
        <doc xml:space="preserve">Creates a new #GDateTime adding the specified values to the current date and
time in @datetime. Add negative values to subtract.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="years" transfer-ownership="none">
            <doc xml:space="preserve">the number of years to add</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="months" transfer-ownership="none">
            <doc xml:space="preserve">the number of months to add</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="days" transfer-ownership="none">
            <doc xml:space="preserve">the number of days to add</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hours" transfer-ownership="none">
            <doc xml:space="preserve">the number of hours to add</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minutes" transfer-ownership="none">
            <doc xml:space="preserve">the number of minutes to add</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="seconds" transfer-ownership="none">
            <doc xml:space="preserve">the number of seconds to add</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_hours" c:identifier="g_date_time_add_hours" version="2.26">
        <doc xml:space="preserve">Creates a copy of @datetime and adds the specified number of hours.
Add negative values to subtract hours.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="hours" transfer-ownership="none">
            <doc xml:space="preserve">the number of hours to add</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_minutes" c:identifier="g_date_time_add_minutes" version="2.26">
        <doc xml:space="preserve">Creates a copy of @datetime adding the specified number of minutes.
Add negative values to subtract minutes.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="minutes" transfer-ownership="none">
            <doc xml:space="preserve">the number of minutes to add</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_months" c:identifier="g_date_time_add_months" version="2.26">
        <doc xml:space="preserve">Creates a copy of @datetime and adds the specified number of months to the
copy. Add negative values to subtract months.

The day of the month of the resulting #GDateTime is clamped to the number
of days in the updated calendar month. For example, if adding 1 month to
31st January 2018, the result would be 28th February 2018. In 2020 (a leap
year), the result would be 29th February.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="months" transfer-ownership="none">
            <doc xml:space="preserve">the number of months</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_seconds" c:identifier="g_date_time_add_seconds" version="2.26">
        <doc xml:space="preserve">Creates a copy of @datetime and adds the specified number of seconds.
Add negative values to subtract seconds.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="seconds" transfer-ownership="none">
            <doc xml:space="preserve">the number of seconds to add</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_weeks" c:identifier="g_date_time_add_weeks" version="2.26">
        <doc xml:space="preserve">Creates a copy of @datetime and adds the specified number of weeks to the
copy. Add negative values to subtract weeks.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="weeks" transfer-ownership="none">
            <doc xml:space="preserve">the number of weeks</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_years" c:identifier="g_date_time_add_years" version="2.26">
        <doc xml:space="preserve">Creates a copy of @datetime and adds the specified number of years to the
copy. Add negative values to subtract years.

As with g_date_time_add_months(), if the resulting date would be 29th
February on a non-leap year, the day will be clamped to 28th February.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="years" transfer-ownership="none">
            <doc xml:space="preserve">the number of years</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="compare" c:identifier="g_date_time_compare" version="2.26">
        <doc xml:space="preserve">A comparison function for #GDateTimes that is suitable
as a #GCompareFunc. Both #GDateTimes must be non-%NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1, 0 or 1 if @dt1 is less than, equal to or greater
  than @dt2.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dt1" transfer-ownership="none">
            <doc xml:space="preserve">first #GDateTime to compare</doc>
            <type name="DateTime" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="dt2" transfer-ownership="none">
            <doc xml:space="preserve">second #GDateTime to compare</doc>
            <type name="DateTime" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="difference" c:identifier="g_date_time_difference" version="2.26">
        <doc xml:space="preserve">Calculates the difference in time between @end and @begin.  The
#GTimeSpan that is returned is effectively @end - @begin (ie:
positive if the first parameter is larger).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the difference between the two #GDateTime, as a time
  span expressed in microseconds.</doc>
          <type name="TimeSpan" c:type="GTimeSpan"/>
        </return-value>
        <parameters>
          <instance-parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="begin" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="g_date_time_equal" version="2.26">
        <doc xml:space="preserve">Checks to see if @dt1 and @dt2 are equal.

Equal here means that they represent the same moment after converting
them to the same time zone.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @dt1 and @dt2 are equal</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dt1" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="dt2" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="format" c:identifier="g_date_time_format" version="2.26">
        <doc xml:space="preserve">Creates a newly allocated string representing the requested @format.

The format strings understood by this function are a subset of the
`strftime()` format language as specified by C99.  The `%D`, `%U` and `%W`
conversions are not supported, nor is the `E` modifier.  The GNU
extensions `%k`, `%l`, `%s` and `%P` are supported, however, as are the
`0`, `_` and `-` modifiers. The Python extension `%f` is also supported.

In contrast to `strftime()`, this function always produces a UTF-8
string, regardless of the current locale.  Note that the rendering of
many formats is locale-dependent and may not match the `strftime()`
output exactly.

The following format specifiers are supported:

- `%a`: the abbreviated weekday name according to the current locale
- `%A`: the full weekday name according to the current locale
- `%b`: the abbreviated month name according to the current locale
- `%B`: the full month name according to the current locale
- `%c`: the preferred date and time representation for the current locale
- `%C`: the century number (year/100) as a 2-digit integer (00-99)
- `%d`: the day of the month as a decimal number (range 01 to 31)
- `%e`: the day of the month as a decimal number (range 1 to 31);
  single digits are preceded by a figure space (U+2007)
- `%F`: equivalent to `%Y-%m-%d` (the ISO 8601 date format)
- `%g`: the last two digits of the ISO 8601 week-based year as a
  decimal number (00-99). This works well with `%V` and `%u`.
- `%G`: the ISO 8601 week-based year as a decimal number. This works
  well with `%V` and `%u`.
- `%h`: equivalent to `%b`
- `%H`: the hour as a decimal number using a 24-hour clock (range 00 to 23)
- `%I`: the hour as a decimal number using a 12-hour clock (range 01 to 12)
- `%j`: the day of the year as a decimal number (range 001 to 366)
- `%k`: the hour (24-hour clock) as a decimal number (range 0 to 23);
  single digits are preceded by a figure space (U+2007)
- `%l`: the hour (12-hour clock) as a decimal number (range 1 to 12);
  single digits are preceded by a figure space (U+2007)
- `%m`: the month as a decimal number (range 01 to 12)
- `%M`: the minute as a decimal number (range 00 to 59)
- `%f`: the microsecond as a decimal number (range 000000 to 999999)
- `%p`: either &#x2018;AM&#x2019; or &#x2018;PM&#x2019; according to the given time value, or the
  corresponding  strings for the current locale.  Noon is treated as
  &#x2018;PM&#x2019; and midnight as &#x2018;AM&#x2019;. Use of this format specifier is discouraged, as
  many locales have no concept of AM/PM formatting. Use `%c` or `%X` instead.
- `%P`: like `%p` but lowercase: &#x2018;am&#x2019; or &#x2018;pm&#x2019; or a corresponding string for
  the current locale. Use of this format specifier is discouraged, as
  many locales have no concept of AM/PM formatting. Use `%c` or `%X` instead.
- `%r`: the time in a.m. or p.m. notation. Use of this format specifier is
  discouraged, as many locales have no concept of AM/PM formatting. Use `%c`
  or `%X` instead.
- `%R`: the time in 24-hour notation (`%H:%M`)
- `%s`: the number of seconds since the Epoch, that is, since 1970-01-01
  00:00:00 UTC
- `%S`: the second as a decimal number (range 00 to 60)
- `%t`: a tab character
- `%T`: the time in 24-hour notation with seconds (`%H:%M:%S`)
- `%u`: the ISO 8601 standard day of the week as a decimal, range 1 to 7,
   Monday being 1. This works well with `%G` and `%V`.
- `%V`: the ISO 8601 standard week number of the current year as a decimal
  number, range 01 to 53, where week 1 is the first week that has at
  least 4 days in the new year. See g_date_time_get_week_of_year().
  This works well with `%G` and `%u`.
- `%w`: the day of the week as a decimal, range 0 to 6, Sunday being 0.
  This is not the ISO 8601 standard format &#x2014; use `%u` instead.
- `%x`: the preferred date representation for the current locale without
  the time
- `%X`: the preferred time representation for the current locale without
  the date
- `%y`: the year as a decimal number without the century
- `%Y`: the year as a decimal number including the century
- `%z`: the time zone as an offset from UTC (`+hhmm`)
- `%:z`: the time zone as an offset from UTC (`+hh:mm`).
  This is a gnulib `strftime()` extension. Since: 2.38
- `%::z`: the time zone as an offset from UTC (`+hh:mm:ss`). This is a
  gnulib `strftime()` extension. Since: 2.38
- `%:::z`: the time zone as an offset from UTC, with `:` to necessary
  precision (e.g., `-04`, `+05:30`). This is a gnulib `strftime()` extension. Since: 2.38
- `%Z`: the time zone or name or abbreviation
- `%%`: a literal `%` character

Some conversion specifications can be modified by preceding the
conversion specifier by one or more modifier characters.

The following modifiers are supported for many of the numeric
conversions:

- `O`: Use alternative numeric symbols, if the current locale supports those.
- `_`: Pad a numeric result with spaces. This overrides the default padding
  for the specifier.
- `-`: Do not pad a numeric result. This overrides the default padding
  for the specifier.
- `0`: Pad a numeric result with zeros. This overrides the default padding
  for the specifier.

The following modifiers are supported for many of the alphabetic conversions:

- `^`: Use upper case if possible. This is a gnulib `strftime()` extension.
  Since: 2.80
- `#`: Use opposite case if possible. This is a gnulib `strftime()`
  extension. Since: 2.80

Additionally, when `O` is used with `B`, `b`, or `h`, it produces the alternative
form of a month name. The alternative form should be used when the month
name is used without a day number (e.g., standalone). It is required in
some languages (Baltic, Slavic, Greek, and more) due to their grammatical
rules. For other languages there is no difference. `%OB` is a GNU and BSD
`strftime()` extension expected to be added to the future POSIX specification,
`%Ob` and `%Oh` are GNU `strftime()` extensions. Since: 2.56

Since GLib 2.80, when `E` is used with `%c`, `%C`, `%x`, `%X`, `%y` or `%Y`,
the date is formatted using an alternate era representation specific to the
locale. This is typically used for the Thai solar calendar or Japanese era
names, for example.

- `%Ec`: the preferred date and time representation for the current locale,
  using the alternate era representation
- `%EC`: the name of the era
- `%Ex`: the preferred date representation for the current locale without
  the time, using the alternate era representation
- `%EX`: the preferred time representation for the current locale without
  the date, using the alternate era representation
- `%Ey`: the year since the beginning of the era denoted by the `%EC`
  specifier
- `%EY`: the full alternative year representation</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated string formatted to
   the requested format or %NULL in the case that there was an error (such
   as a format specifier not being supported in the current locale). The
   string should be freed with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">A #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a valid UTF-8 string, containing the format for the
         #GDateTime</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="format_iso8601" c:identifier="g_date_time_format_iso8601" version="2.62">
        <doc xml:space="preserve">Format @datetime in [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601),
including the date, time and time zone, and return that as a UTF-8 encoded
string.

Since GLib 2.66, this will output to sub-second precision if needed.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated string formatted in
  ISO 8601 format or %NULL in the case that there was an error. The string
  should be freed with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">A #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_day_of_month" c:identifier="g_date_time_get_day_of_month" version="2.26">
        <doc xml:space="preserve">Retrieves the day of the month represented by @datetime in the gregorian
calendar.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the day of the month</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_day_of_week" c:identifier="g_date_time_get_day_of_week" version="2.26">
        <doc xml:space="preserve">Retrieves the ISO 8601 day of the week on which @datetime falls (1 is
Monday, 2 is Tuesday... 7 is Sunday).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the day of the week</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_day_of_year" c:identifier="g_date_time_get_day_of_year" version="2.26">
        <doc xml:space="preserve">Retrieves the day of the year represented by @datetime in the Gregorian
calendar.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the day of the year</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hour" c:identifier="g_date_time_get_hour" version="2.26">
        <doc xml:space="preserve">Retrieves the hour of the day represented by @datetime</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hour of the day</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_microsecond" c:identifier="g_date_time_get_microsecond" version="2.26">
        <doc xml:space="preserve">Retrieves the microsecond of the date represented by @datetime</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the microsecond of the second</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_minute" c:identifier="g_date_time_get_minute" version="2.26">
        <doc xml:space="preserve">Retrieves the minute of the hour represented by @datetime</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the minute of the hour</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_month" c:identifier="g_date_time_get_month" version="2.26">
        <doc xml:space="preserve">Retrieves the month of the year represented by @datetime in the Gregorian
calendar.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the month represented by @datetime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_second" c:identifier="g_date_time_get_second" version="2.26">
        <doc xml:space="preserve">Retrieves the second of the minute represented by @datetime</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the second represented by @datetime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_seconds" c:identifier="g_date_time_get_seconds" version="2.26">
        <doc xml:space="preserve">Retrieves the number of seconds since the start of the last minute,
including the fractional part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of seconds</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_timezone" c:identifier="g_date_time_get_timezone" version="2.58">
        <doc xml:space="preserve">Get the time zone for this @datetime.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the time zone</doc>
          <type name="TimeZone" c:type="GTimeZone*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_timezone_abbreviation" c:identifier="g_date_time_get_timezone_abbreviation" version="2.26">
        <doc xml:space="preserve">Determines the time zone abbreviation to be used at the time and in
the time zone of @datetime.

For example, in Toronto this is currently "EST" during the winter
months and "EDT" during the summer months when daylight savings
time is in effect.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the time zone abbreviation. The returned
         string is owned by the #GDateTime and it should not be
         modified or freed</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_utc_offset" c:identifier="g_date_time_get_utc_offset" version="2.26">
        <doc xml:space="preserve">Determines the offset to UTC in effect at the time and in the time
zone of @datetime.

The offset is the number of microseconds that you add to UTC time to
arrive at local time for the time zone (ie: negative numbers for time
zones west of GMT, positive numbers for east).

If @datetime represents UTC time, then the offset is always zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of microseconds that should be added to UTC to
         get the local time</doc>
          <type name="TimeSpan" c:type="GTimeSpan"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_week_numbering_year" c:identifier="g_date_time_get_week_numbering_year" version="2.26">
        <doc xml:space="preserve">Returns the ISO 8601 week-numbering year in which the week containing
@datetime falls.

This function, taken together with g_date_time_get_week_of_year() and
g_date_time_get_day_of_week() can be used to determine the full ISO
week date on which @datetime falls.

This is usually equal to the normal Gregorian year (as returned by
g_date_time_get_year()), except as detailed below:

For Thursday, the week-numbering year is always equal to the usual
calendar year.  For other days, the number is such that every day
within a complete week (Monday to Sunday) is contained within the
same week-numbering year.

For Monday, Tuesday and Wednesday occurring near the end of the year,
this may mean that the week-numbering year is one greater than the
calendar year (so that these days have the same week-numbering year
as the Thursday occurring early in the next year).

For Friday, Saturday and Sunday occurring near the start of the year,
this may mean that the week-numbering year is one less than the
calendar year (so that these days have the same week-numbering year
as the Thursday occurring late in the previous year).

An equivalent description is that the week-numbering year is equal to
the calendar year containing the majority of the days in the current
week (Monday to Sunday).

Note that January 1 0001 in the proleptic Gregorian calendar is a
Monday, so this function never returns 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ISO 8601 week-numbering year for @datetime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_week_of_year" c:identifier="g_date_time_get_week_of_year" version="2.26">
        <doc xml:space="preserve">Returns the ISO 8601 week number for the week containing @datetime.
The ISO 8601 week number is the same for every day of the week (from
Moday through Sunday).  That can produce some unusual results
(described below).

The first week of the year is week 1.  This is the week that contains
the first Thursday of the year.  Equivalently, this is the first week
that has more than 4 of its days falling within the calendar year.

The value 0 is never returned by this function.  Days contained
within a year but occurring before the first ISO 8601 week of that
year are considered as being contained in the last week of the
previous year.  Similarly, the final days of a calendar year may be
considered as being part of the first ISO 8601 week of the next year
if 4 or more days of that week are contained within the new year.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ISO 8601 week number for @datetime.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_year" c:identifier="g_date_time_get_year" version="2.26">
        <doc xml:space="preserve">Retrieves the year represented by @datetime in the Gregorian calendar.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the year represented by @datetime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">A #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ymd" c:identifier="g_date_time_get_ymd" version="2.26">
        <doc xml:space="preserve">Retrieves the Gregorian day, month, and year of a given #GDateTime.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime.</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="year" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the return location for the gregorian year, or %NULL.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="month" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the return location for the month of the year, or %NULL.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="day" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the return location for the day of the month, or %NULL.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="g_date_time_hash" version="2.26">
        <doc xml:space="preserve">Hashes @datetime into a #guint, suitable for use within #GHashTable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #guint containing the hash</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_daylight_savings" c:identifier="g_date_time_is_daylight_savings" version="2.26">
        <doc xml:space="preserve">Determines if daylight savings time is in effect at the time and in
the time zone of @datetime.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if daylight savings time is in effect</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_date_time_ref" version="2.26">
        <doc xml:space="preserve">Atomically increments the reference count of @datetime by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GDateTime with the reference count increased</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_local" c:identifier="g_date_time_to_local" version="2.26">
        <doc xml:space="preserve">Creates a new #GDateTime corresponding to the same instant in time as
@datetime, but in the local time zone.

This call is equivalent to calling g_date_time_to_timezone() with the
time zone returned by g_time_zone_new_local().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_timeval" c:identifier="g_date_time_to_timeval" version="2.26" deprecated="1" deprecated-version="2.62">
        <doc xml:space="preserve">Stores the instant in time that @datetime represents into @tv.

The time contained in a #GTimeVal is always stored in the form of
seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the time
zone associated with @datetime.

On systems where 'long' is 32bit (ie: all 32bit systems and all
Windows systems), a #GTimeVal is incapable of storing the entire
range of values that #GDateTime is capable of expressing.  On those
systems, this function returns %FALSE to indicate that the time is
out of range.

On systems where 'long' is 64bit, this function never fails.</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use
   g_date_time_to_unix() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if successful, else %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="tv" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal to modify</doc>
            <type name="TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_timezone" c:identifier="g_date_time_to_timezone" version="2.26">
        <doc xml:space="preserve">Create a new #GDateTime corresponding to the same instant in time as
@datetime, but in the time zone @tz.

This call can fail in the case that the time goes out of bounds.  For
example, converting 0001-01-01 00:00:00 UTC to a time zone west of
Greenwich will fail (due to the year 0 being out of range).</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
          <parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">the new #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_unix" c:identifier="g_date_time_to_unix" version="2.26">
        <doc xml:space="preserve">Gives the Unix time corresponding to @datetime, rounding down to the
nearest second.

Unix time is the number of seconds that have elapsed since 1970-01-01
00:00:00 UTC, regardless of the time zone associated with @datetime.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Unix time corresponding to @datetime</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_unix_usec" c:identifier="g_date_time_to_unix_usec" version="2.80">
        <doc xml:space="preserve">Gives the Unix time corresponding to @datetime, in microseconds.

Unix time is the number of microseconds that have elapsed since 1970-01-01
00:00:00 UTC, regardless of the time zone associated with @datetime.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Unix time corresponding to @datetime</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_utc" c:identifier="g_date_time_to_utc" version="2.26">
        <doc xml:space="preserve">Creates a new #GDateTime corresponding to the same instant in time as
@datetime, but in UTC.

This call is equivalent to calling g_date_time_to_timezone() with the
time zone returned by g_time_zone_new_utc().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_date_time_unref" version="2.26">
        <doc xml:space="preserve">Atomically decrements the reference count of @datetime by one.

When the reference count reaches zero, the resources allocated by
@datetime are freed</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="DateWeekday" c:type="GDateWeekday">
      <doc xml:space="preserve">Enumeration representing a day of the week; %G_DATE_MONDAY,
%G_DATE_TUESDAY, etc. %G_DATE_BAD_WEEKDAY is an invalid weekday.</doc>
      <member name="bad_weekday" value="0" c:identifier="G_DATE_BAD_WEEKDAY">
        <doc xml:space="preserve">invalid value</doc>
      </member>
      <member name="monday" value="1" c:identifier="G_DATE_MONDAY">
        <doc xml:space="preserve">Monday</doc>
      </member>
      <member name="tuesday" value="2" c:identifier="G_DATE_TUESDAY">
        <doc xml:space="preserve">Tuesday</doc>
      </member>
      <member name="wednesday" value="3" c:identifier="G_DATE_WEDNESDAY">
        <doc xml:space="preserve">Wednesday</doc>
      </member>
      <member name="thursday" value="4" c:identifier="G_DATE_THURSDAY">
        <doc xml:space="preserve">Thursday</doc>
      </member>
      <member name="friday" value="5" c:identifier="G_DATE_FRIDAY">
        <doc xml:space="preserve">Friday</doc>
      </member>
      <member name="saturday" value="6" c:identifier="G_DATE_SATURDAY">
        <doc xml:space="preserve">Saturday</doc>
      </member>
      <member name="sunday" value="7" c:identifier="G_DATE_SUNDAY">
        <doc xml:space="preserve">Sunday</doc>
      </member>
    </enumeration>
    <record name="DebugKey" c:type="GDebugKey">
      <doc xml:space="preserve">Associates a string with a bit flag.
Used in g_parse_debug_string().</doc>
      <field name="key" writable="1">
        <doc xml:space="preserve">the string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="value" writable="1">
        <doc xml:space="preserve">the flag</doc>
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <callback name="DestroyNotify" c:type="GDestroyNotify">
      <doc xml:space="preserve">Specifies the type of function which is called when a data element
is destroyed. It is passed the pointer to the data element and
should free any memory and resources allocated for it.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data element.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Dir" c:type="GDir" opaque="1" glib:type-name="GDir" glib:get-type="g_dir_get_type" c:symbol-prefix="dir">
      <doc xml:space="preserve">An opaque structure representing an opened directory.</doc>
      <constructor name="open" c:identifier="g_dir_open" throws="1">
        <doc xml:space="preserve">Opens a directory for reading. The names of the files in the
directory can then be retrieved using g_dir_read_name().  Note
that the ordering is not defined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GDir on success, %NULL on failure.
  If non-%NULL, you must free the result with g_dir_close()
  when you are finished with it.</doc>
          <type name="Dir" c:type="GDir*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to the directory you are interested in. On Unix
        in the on-disk encoding. On Windows in UTF-8</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Currently must be set to 0. Reserved for future use.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="close" c:identifier="g_dir_close">
        <doc xml:space="preserve">Closes the directory immediately and decrements the reference count.

Once the reference count reaches zero, the `GDir` structure itself will be
freed. Prior to GLib 2.80, `GDir` was not reference counted.

It is an error to call any of the `GDir` methods other than
[method@GLib.Dir.ref] and [method@GLib.Dir.unref] on a `GDir` after calling
[method@GLib.Dir.close] on it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dir" transfer-ownership="full">
            <doc xml:space="preserve">a #GDir* created by g_dir_open()</doc>
            <type name="Dir" c:type="GDir*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read_name" c:identifier="g_dir_read_name">
        <doc xml:space="preserve">Retrieves the name of another entry in the directory, or %NULL.
The order of entries returned from this function is not defined,
and may vary by file system or other operating-system dependent
factors.

%NULL may also be returned in case of errors. On Unix, you can
check `errno` to find out if %NULL was returned because of an error.

On Unix, the '.' and '..' entries are omitted, and the returned
name is in the on-disk encoding.

On Windows, as is true of all GLib functions which operate on
filenames, the returned name is in UTF-8.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The entry's name or %NULL if there are no
  more entries. The return value is owned by GLib and
  must not be modified or freed.</doc>
          <type name="filename" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dir" transfer-ownership="none">
            <doc xml:space="preserve">a #GDir* created by g_dir_open()</doc>
            <type name="Dir" c:type="GDir*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_dir_ref" version="2.80">
        <doc xml:space="preserve">Increment the reference count of `dir`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the same pointer as `dir`</doc>
          <type name="Dir" c:type="GDir*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dir" transfer-ownership="none">
            <doc xml:space="preserve">a `GDir`</doc>
            <type name="Dir" c:type="GDir*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rewind" c:identifier="g_dir_rewind">
        <doc xml:space="preserve">Resets the given directory. The next call to g_dir_read_name()
will return the first entry again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dir" transfer-ownership="none">
            <doc xml:space="preserve">a #GDir* created by g_dir_open()</doc>
            <type name="Dir" c:type="GDir*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_dir_unref" version="2.80">
        <doc xml:space="preserve">Decrements the reference count of `dir`.

Once the reference count reaches zero, the directory will be closed and all
resources associated with it will be freed. If [method@GLib.Dir.close] is
called when the reference count is greater than zero, the directory is closed
but the `GDir` structure will not be freed until its reference count reaches
zero.

It is an error to call any of the `GDir` methods other than
[method@GLib.Dir.ref] and [method@GLib.Dir.unref] on a `GDir` after calling
[method@GLib.Dir.close] on it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dir" transfer-ownership="full">
            <doc xml:space="preserve">a `GDir`</doc>
            <type name="Dir" c:type="GDir*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="make_tmp" c:identifier="g_dir_make_tmp" version="2.30" throws="1">
        <doc xml:space="preserve">Creates a subdirectory in the preferred directory for temporary
files (as returned by g_get_tmp_dir()).

@tmpl should be a string in the GLib file name encoding containing
a sequence of six 'X' characters, as the parameter to g_mkstemp().
However, unlike these functions, the template should only be a
basename, no directory components are allowed. If template is
%NULL, a default template is used.

Note that in contrast to g_mkdtemp() (and mkdtemp()) @tmpl is not
modified, and might thus be a read-only literal string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The actual name used. This string
  should be freed with g_free() when not needed any longer and is
  is in the GLib file name encoding. In case of errors, %NULL is
  returned and @error will be set.</doc>
          <type name="filename" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="tmpl" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Template for directory name,
  as in g_mkdtemp(), basename only, or %NULL for a default template</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <union name="DoubleIEEE754" c:type="GDoubleIEEE754">
      <doc xml:space="preserve">The #GFloatIEEE754 and #GDoubleIEEE754 unions are used to access the sign,
mantissa and exponent of IEEE floats and doubles. These unions are defined
as appropriate for a given platform. IEEE floats and doubles are supported
(used for storage) by at least Intel, PPC and Sparc.</doc>
      <field name="v_double" writable="1">
        <doc xml:space="preserve">the double value</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <record name="mpn" c:type="mpn">
        <field name="mantissa_low" writable="1" bits="32">
          <type name="guint" c:type="guint"/>
        </field>
        <field name="mantissa_high" writable="1" bits="20">
          <type name="guint" c:type="guint"/>
        </field>
        <field name="biased_exponent" writable="1" bits="11">
          <type name="guint" c:type="guint"/>
        </field>
        <field name="sign" writable="1" bits="1">
          <type name="guint" c:type="guint"/>
        </field>
      </record>
    </union>
    <callback name="DuplicateFunc" c:type="GDuplicateFunc">
      <doc xml:space="preserve">The type of functions that are used to 'duplicate' an object.
What this means depends on the context, it could just be
incrementing the reference count, if @data is a ref-counted
object.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a duplicate of data</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data to duplicate</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="1">
          <doc xml:space="preserve">user data that was specified in
            g_datalist_id_dup_data()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="E" value="2.718282" c:type="G_E">
      <doc xml:space="preserve">The base of natural logarithms.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <function-macro name="ENCODE_VERSION" c:identifier="G_ENCODE_VERSION" introspectable="0">
      <parameters>
        <parameter name="major">
        </parameter>
        <parameter name="minor">
        </parameter>
      </parameters>
    </function-macro>
    <callback name="EqualFunc" c:type="GEqualFunc">
      <doc xml:space="preserve">Specifies the type of a function used to test two values for
equality. The function should return %TRUE if both values are equal
and %FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @a = @b; %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a value</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a value to compare with</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="EqualFuncFull" c:type="GEqualFuncFull" version="2.74">
      <doc xml:space="preserve">Specifies the type of a function used to test two values for
equality. The function should return %TRUE if both values are equal
and %FALSE otherwise.

This is a version of #GEqualFunc which provides a @user_data closure from
the caller.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @a = @b; %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a value</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a value to compare with</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data provided by the caller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Error" c:type="GError" glib:type-name="GError" glib:get-type="g_error_get_type" c:symbol-prefix="error">
      <doc xml:space="preserve">The `GError` structure contains information about
an error that has occurred.</doc>
      <field name="domain" writable="1">
        <doc xml:space="preserve">error domain, e.g. %G_FILE_ERROR</doc>
        <type name="Quark" c:type="GQuark"/>
      </field>
      <field name="code" writable="1">
        <doc xml:space="preserve">error code, e.g. %G_FILE_ERROR_NOENT</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="message" writable="1">
        <doc xml:space="preserve">human-readable informative error message</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <constructor name="new" c:identifier="g_error_new" introspectable="0">
        <doc xml:space="preserve">Creates a new #GError with the given @domain and @code,
and a message formatted with @format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GError</doc>
          <type name="Error" c:type="GError*"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">error domain</doc>
            <type name="Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">error code</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">printf()-style format for error message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">parameters for message format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_literal" c:identifier="g_error_new_literal">
        <doc xml:space="preserve">Creates a new #GError; unlike g_error_new(), @message is
not a printf()-style format string. Use this function if
@message contains text you don't have control over,
that could include printf() escape sequences.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GError</doc>
          <type name="Error" c:type="GError*"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">error domain</doc>
            <type name="Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">error code</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">error message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_valist" c:identifier="g_error_new_valist" version="2.22" introspectable="0">
        <doc xml:space="preserve">Creates a new #GError with the given @domain and @code,
and a message formatted with @format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GError</doc>
          <type name="Error" c:type="GError*"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">error domain</doc>
            <type name="Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">error code</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">printf()-style format for error message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">#va_list of parameters for the message format</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="g_error_copy">
        <doc xml:space="preserve">Makes a copy of @error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GError</doc>
          <type name="Error" c:type="GError*"/>
        </return-value>
        <parameters>
          <instance-parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError</doc>
            <type name="Error" c:type="const GError*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_error_free">
        <doc xml:space="preserve">Frees a #GError and associated resources.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError</doc>
            <type name="Error" c:type="GError*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="matches" c:identifier="g_error_matches">
        <doc xml:space="preserve">Returns %TRUE if @error matches @domain and @code, %FALSE
otherwise. In particular, when @error is %NULL, %FALSE will
be returned.

If @domain contains a `FAILED` (or otherwise generic) error code,
you should generally not check for it explicitly, but should
instead treat any not-explicitly-recognized error code as being
equivalent to the `FAILED` code. This way, if the domain is
extended in the future to provide a more specific error code for
a certain case, your code will still work.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @error has @domain and @code</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="error" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GError</doc>
            <type name="Error" c:type="const GError*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">an error domain</doc>
            <type name="Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">an error code</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <function name="domain_register" c:identifier="g_error_domain_register" version="2.68">
        <doc xml:space="preserve">This function registers an extended #GError domain.
@error_type_name will be duplicated. Otherwise does the same as
g_error_domain_register_static().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#GQuark representing the error domain</doc>
          <type name="Quark" c:type="GQuark"/>
        </return-value>
        <parameters>
          <parameter name="error_type_name" transfer-ownership="none">
            <doc xml:space="preserve">string to create a #GQuark from</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="error_type_private_size" transfer-ownership="none">
            <doc xml:space="preserve">size of the private error data in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="error_type_init" transfer-ownership="none" scope="forever">
            <doc xml:space="preserve">function initializing fields of the private error data</doc>
            <type name="ErrorInitFunc" c:type="GErrorInitFunc"/>
          </parameter>
          <parameter name="error_type_copy" transfer-ownership="none" scope="forever">
            <doc xml:space="preserve">function copying fields of the private error data</doc>
            <type name="ErrorCopyFunc" c:type="GErrorCopyFunc"/>
          </parameter>
          <parameter name="error_type_clear" transfer-ownership="none" scope="forever">
            <doc xml:space="preserve">function freeing fields of the private error data</doc>
            <type name="ErrorClearFunc" c:type="GErrorClearFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="domain_register_static" c:identifier="g_error_domain_register_static" version="2.68">
        <doc xml:space="preserve">This function registers an extended #GError domain.

@error_type_name should not be freed. @error_type_private_size must
be greater than 0.

@error_type_init receives an initialized #GError and should then initialize
the private data.

@error_type_copy is a function that receives both original and a copy
#GError and should copy the fields of the private error data. The standard
#GError fields are already handled.

@error_type_clear receives the pointer to the error, and it should free the
fields of the private error data. It should not free the struct itself though.

Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it
already takes care of passing valid information to this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#GQuark representing the error domain</doc>
          <type name="Quark" c:type="GQuark"/>
        </return-value>
        <parameters>
          <parameter name="error_type_name" transfer-ownership="none">
            <doc xml:space="preserve">static string to create a #GQuark from</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="error_type_private_size" transfer-ownership="none">
            <doc xml:space="preserve">size of the private error data in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="error_type_init" transfer-ownership="none" scope="forever">
            <doc xml:space="preserve">function initializing fields of the private error data</doc>
            <type name="ErrorInitFunc" c:type="GErrorInitFunc"/>
          </parameter>
          <parameter name="error_type_copy" transfer-ownership="none" scope="forever">
            <doc xml:space="preserve">function copying fields of the private error data</doc>
            <type name="ErrorCopyFunc" c:type="GErrorCopyFunc"/>
          </parameter>
          <parameter name="error_type_clear" transfer-ownership="none" scope="forever">
            <doc xml:space="preserve">function freeing fields of the private error data</doc>
            <type name="ErrorClearFunc" c:type="GErrorClearFunc"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="ErrorClearFunc" c:type="GErrorClearFunc" version="2.68">
      <doc xml:space="preserve">Specifies the type of function which is called when an extended
error instance is freed. It is passed the error pointer about to be
freed, and should free the error's private data fields.

Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it
already takes care of getting the private data from @error.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">extended error to clear</doc>
          <type name="Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ErrorCopyFunc" c:type="GErrorCopyFunc" version="2.68">
      <doc xml:space="preserve">Specifies the type of function which is called when an extended
error instance is copied. It is passed the pointer to the
destination error and source error, and should copy only the fields
of the private data from @src_error to @dest_error.

Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it
already takes care of getting the private data from @src_error and
@dest_error.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src_error" transfer-ownership="none">
          <doc xml:space="preserve">source extended error</doc>
          <type name="Error" c:type="const GError*"/>
        </parameter>
        <parameter name="dest_error" transfer-ownership="none">
          <doc xml:space="preserve">destination extended error</doc>
          <type name="Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ErrorInitFunc" c:type="GErrorInitFunc" version="2.68">
      <doc xml:space="preserve">Specifies the type of function which is called just after an
extended error instance is created and its fields filled. It should
only initialize the fields in the private data, which can be
received with the generated `*_get_private()` function.

Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it
already takes care of getting the private data from @error.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">extended error</doc>
          <type name="Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ErrorType" c:type="GErrorType">
      <doc xml:space="preserve">The possible errors, used in the @v_error field
of #GTokenValue, when the token is a %G_TOKEN_ERROR.</doc>
      <member name="unknown" value="0" c:identifier="G_ERR_UNKNOWN">
        <doc xml:space="preserve">unknown error</doc>
      </member>
      <member name="unexp_eof" value="1" c:identifier="G_ERR_UNEXP_EOF">
        <doc xml:space="preserve">unexpected end of file</doc>
      </member>
      <member name="unexp_eof_in_string" value="2" c:identifier="G_ERR_UNEXP_EOF_IN_STRING">
        <doc xml:space="preserve">unterminated string constant</doc>
      </member>
      <member name="unexp_eof_in_comment" value="3" c:identifier="G_ERR_UNEXP_EOF_IN_COMMENT">
        <doc xml:space="preserve">unterminated comment</doc>
      </member>
      <member name="non_digit_in_const" value="4" c:identifier="G_ERR_NON_DIGIT_IN_CONST">
        <doc xml:space="preserve">non-digit character in a number</doc>
      </member>
      <member name="digit_radix" value="5" c:identifier="G_ERR_DIGIT_RADIX">
        <doc xml:space="preserve">digit beyond radix in a number</doc>
      </member>
      <member name="float_radix" value="6" c:identifier="G_ERR_FLOAT_RADIX">
        <doc xml:space="preserve">non-decimal floating point number</doc>
      </member>
      <member name="float_malformed" value="7" c:identifier="G_ERR_FLOAT_MALFORMED">
        <doc xml:space="preserve">malformed floating point number</doc>
      </member>
    </enumeration>
    <enumeration name="FileError" c:type="GFileError" glib:error-domain="g-file-error-quark">
      <doc xml:space="preserve">Values corresponding to @errno codes returned from file operations
on UNIX. Unlike @errno codes, GFileError values are available on
all systems, even Windows. The exact meaning of each code depends
on what sort of file operation you were performing; the UNIX
documentation gives more details. The following error code descriptions
come from the GNU C Library manual, and are under the copyright
of that manual.

It's not very portable to make detailed assumptions about exactly
which errors will be returned from a given operation. Some errors
don't occur on some systems, etc., sometimes there are subtle
differences in when a system will report a given error, etc.</doc>
      <member name="exist" value="0" c:identifier="G_FILE_ERROR_EXIST">
        <doc xml:space="preserve">Operation not permitted; only the owner of
    the file (or other resource) or processes with special privileges
    can perform the operation.</doc>
      </member>
      <member name="isdir" value="1" c:identifier="G_FILE_ERROR_ISDIR">
        <doc xml:space="preserve">File is a directory; you cannot open a directory
    for writing, or create or remove hard links to it.</doc>
      </member>
      <member name="acces" value="2" c:identifier="G_FILE_ERROR_ACCES">
        <doc xml:space="preserve">Permission denied; the file permissions do not
    allow the attempted operation.</doc>
      </member>
      <member name="nametoolong" value="3" c:identifier="G_FILE_ERROR_NAMETOOLONG">
        <doc xml:space="preserve">Filename too long.</doc>
      </member>
      <member name="noent" value="4" c:identifier="G_FILE_ERROR_NOENT">
        <doc xml:space="preserve">No such file or directory. This is a "file
    doesn't exist" error for ordinary files that are referenced in
    contexts where they are expected to already exist.</doc>
      </member>
      <member name="notdir" value="5" c:identifier="G_FILE_ERROR_NOTDIR">
        <doc xml:space="preserve">A file that isn't a directory was specified when
    a directory is required.</doc>
      </member>
      <member name="nxio" value="6" c:identifier="G_FILE_ERROR_NXIO">
        <doc xml:space="preserve">No such device or address. The system tried to
    use the device represented by a file you specified, and it
    couldn't find the device. This can mean that the device file was
    installed incorrectly, or that the physical device is missing or
    not correctly attached to the computer.</doc>
      </member>
      <member name="nodev" value="7" c:identifier="G_FILE_ERROR_NODEV">
        <doc xml:space="preserve">The underlying file system of the specified file
    does not support memory mapping.</doc>
      </member>
      <member name="rofs" value="8" c:identifier="G_FILE_ERROR_ROFS">
        <doc xml:space="preserve">The directory containing the new link can't be
    modified because it's on a read-only file system.</doc>
      </member>
      <member name="txtbsy" value="9" c:identifier="G_FILE_ERROR_TXTBSY">
        <doc xml:space="preserve">Text file busy.</doc>
      </member>
      <member name="fault" value="10" c:identifier="G_FILE_ERROR_FAULT">
        <doc xml:space="preserve">You passed in a pointer to bad memory.
    (GLib won't reliably return this, don't pass in pointers to bad
    memory.)</doc>
      </member>
      <member name="loop" value="11" c:identifier="G_FILE_ERROR_LOOP">
        <doc xml:space="preserve">Too many levels of symbolic links were encountered
    in looking up a file name. This often indicates a cycle of symbolic
    links.</doc>
      </member>
      <member name="nospc" value="12" c:identifier="G_FILE_ERROR_NOSPC">
        <doc xml:space="preserve">No space left on device; write operation on a
    file failed because the disk is full.</doc>
      </member>
      <member name="nomem" value="13" c:identifier="G_FILE_ERROR_NOMEM">
        <doc xml:space="preserve">No memory available. The system cannot allocate
    more virtual memory because its capacity is full.</doc>
      </member>
      <member name="mfile" value="14" c:identifier="G_FILE_ERROR_MFILE">
        <doc xml:space="preserve">The current process has too many files open and
    can't open any more. Duplicate descriptors do count toward this
    limit.</doc>
      </member>
      <member name="nfile" value="15" c:identifier="G_FILE_ERROR_NFILE">
        <doc xml:space="preserve">There are too many distinct file openings in the
    entire system.</doc>
      </member>
      <member name="badf" value="16" c:identifier="G_FILE_ERROR_BADF">
        <doc xml:space="preserve">Bad file descriptor; for example, I/O on a
    descriptor that has been closed or reading from a descriptor open
    only for writing (or vice versa).</doc>
      </member>
      <member name="inval" value="17" c:identifier="G_FILE_ERROR_INVAL">
        <doc xml:space="preserve">Invalid argument. This is used to indicate
    various kinds of problems with passing the wrong argument to a
    library function.</doc>
      </member>
      <member name="pipe" value="18" c:identifier="G_FILE_ERROR_PIPE">
        <doc xml:space="preserve">Broken pipe; there is no process reading from the
    other end of a pipe. Every library function that returns this
    error code also generates a 'SIGPIPE' signal; this signal
    terminates the program if not handled or blocked. Thus, your
    program will never actually see this code unless it has handled
    or blocked 'SIGPIPE'.</doc>
      </member>
      <member name="again" value="19" c:identifier="G_FILE_ERROR_AGAIN">
        <doc xml:space="preserve">Resource temporarily unavailable; the call might
    work if you try again later.</doc>
      </member>
      <member name="intr" value="20" c:identifier="G_FILE_ERROR_INTR">
        <doc xml:space="preserve">Interrupted function call; an asynchronous signal
    occurred and prevented completion of the call. When this
    happens, you should try the call again.</doc>
      </member>
      <member name="io" value="21" c:identifier="G_FILE_ERROR_IO">
        <doc xml:space="preserve">Input/output error; usually used for physical read
   or write errors. i.e. the disk or other physical device hardware
   is returning errors.</doc>
      </member>
      <member name="perm" value="22" c:identifier="G_FILE_ERROR_PERM">
        <doc xml:space="preserve">Operation not permitted; only the owner of the
   file (or other resource) or processes with special privileges can
   perform the operation.</doc>
      </member>
      <member name="nosys" value="23" c:identifier="G_FILE_ERROR_NOSYS">
        <doc xml:space="preserve">Function not implemented; this indicates that
   the system is missing some functionality.</doc>
      </member>
      <member name="failed" value="24" c:identifier="G_FILE_ERROR_FAILED">
        <doc xml:space="preserve">Does not correspond to a UNIX error code; this
   is the standard "failed for unspecified reason" error code present
   in all #GError error code enumerations. Returned if no specific
   code applies.</doc>
      </member>
    </enumeration>
    <bitfield name="FileSetContentsFlags" version="2.66" c:type="GFileSetContentsFlags">
      <doc xml:space="preserve">Flags to pass to g_file_set_contents_full() to affect its safety and
performance.</doc>
      <member name="none" value="0" c:identifier="G_FILE_SET_CONTENTS_NONE">
        <doc xml:space="preserve">No guarantees about file consistency or durability.
  The most dangerous setting, which is slightly faster than other settings.</doc>
      </member>
      <member name="consistent" value="1" c:identifier="G_FILE_SET_CONTENTS_CONSISTENT">
        <doc xml:space="preserve">Guarantee file consistency: after a crash,
  either the old version of the file or the new version of the file will be
  available, but not a mixture. On Unix systems this equates to an `fsync()`
  on the file and use of an atomic `rename()` of the new version of the file
  over the old.</doc>
      </member>
      <member name="durable" value="2" c:identifier="G_FILE_SET_CONTENTS_DURABLE">
        <doc xml:space="preserve">Guarantee file durability: after a crash, the
  new version of the file will be available. On Unix systems this equates to
  an `fsync()` on the file (if %G_FILE_SET_CONTENTS_CONSISTENT is unset), or
  the effects of %G_FILE_SET_CONTENTS_CONSISTENT plus an `fsync()` on the
  directory containing the file after calling `rename()`.</doc>
      </member>
      <member name="only_existing" value="4" c:identifier="G_FILE_SET_CONTENTS_ONLY_EXISTING">
        <doc xml:space="preserve">Only apply consistency and durability
  guarantees if the file already exists. This may speed up file operations
  if the file doesn&#x2019;t currently exist, but may result in a corrupted version
  of the new file if the system crashes while writing it.</doc>
      </member>
    </bitfield>
    <bitfield name="FileTest" c:type="GFileTest">
      <doc xml:space="preserve">A test to perform on a file using g_file_test().</doc>
      <member name="is_regular" value="1" c:identifier="G_FILE_TEST_IS_REGULAR">
        <doc xml:space="preserve">%TRUE if the file is a regular file
    (not a directory). Note that this test will also return %TRUE
    if the tested file is a symlink to a regular file.</doc>
      </member>
      <member name="is_symlink" value="2" c:identifier="G_FILE_TEST_IS_SYMLINK">
        <doc xml:space="preserve">%TRUE if the file is a symlink.</doc>
      </member>
      <member name="is_dir" value="4" c:identifier="G_FILE_TEST_IS_DIR">
        <doc xml:space="preserve">%TRUE if the file is a directory.</doc>
      </member>
      <member name="is_executable" value="8" c:identifier="G_FILE_TEST_IS_EXECUTABLE">
        <doc xml:space="preserve">%TRUE if the file is executable.</doc>
      </member>
      <member name="exists" value="16" c:identifier="G_FILE_TEST_EXISTS">
        <doc xml:space="preserve">%TRUE if the file exists. It may or may not
    be a regular file.</doc>
      </member>
    </bitfield>
    <union name="FloatIEEE754" c:type="GFloatIEEE754">
      <doc xml:space="preserve">The #GFloatIEEE754 and #GDoubleIEEE754 unions are used to access the sign,
mantissa and exponent of IEEE floats and doubles. These unions are defined
as appropriate for a given platform. IEEE floats and doubles are supported
(used for storage) by at least Intel, PPC and Sparc.</doc>
      <field name="v_float" writable="1">
        <doc xml:space="preserve">the double value</doc>
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <record name="mpn" c:type="mpn">
        <field name="mantissa" writable="1" bits="23">
          <type name="guint" c:type="guint"/>
        </field>
        <field name="biased_exponent" writable="1" bits="8">
          <type name="guint" c:type="guint"/>
        </field>
        <field name="sign" writable="1" bits="1">
          <type name="guint" c:type="guint"/>
        </field>
      </record>
    </union>
    <bitfield name="FormatSizeFlags" c:type="GFormatSizeFlags">
      <doc xml:space="preserve">Flags to modify the format of the string returned by g_format_size_full().</doc>
      <member name="default" value="0" c:identifier="G_FORMAT_SIZE_DEFAULT">
        <doc xml:space="preserve">behave the same as g_format_size()</doc>
      </member>
      <member name="long_format" value="1" c:identifier="G_FORMAT_SIZE_LONG_FORMAT">
        <doc xml:space="preserve">include the exact number of bytes as part
    of the returned string.  For example, "45.6 kB (45,612 bytes)".</doc>
      </member>
      <member name="iec_units" value="2" c:identifier="G_FORMAT_SIZE_IEC_UNITS">
        <doc xml:space="preserve">use IEC (base 1024) units with "KiB"-style
    suffixes. IEC units should only be used for reporting things with
    a strong "power of 2" basis, like RAM sizes or RAID stripe sizes.
    Network and storage sizes should be reported in the normal SI units.</doc>
      </member>
      <member name="bits" value="4" c:identifier="G_FORMAT_SIZE_BITS">
        <doc xml:space="preserve">set the size as a quantity in bits, rather than
    bytes, and return units in bits. For example, &#x2018;Mbit&#x2019; rather than &#x2018;MB&#x2019;.</doc>
      </member>
      <member name="only_value" value="8" c:identifier="G_FORMAT_SIZE_ONLY_VALUE">
        <doc xml:space="preserve">return only value, without unit; this should
    not be used together with @G_FORMAT_SIZE_LONG_FORMAT
    nor @G_FORMAT_SIZE_ONLY_UNIT. Since: 2.74</doc>
      </member>
      <member name="only_unit" value="16" c:identifier="G_FORMAT_SIZE_ONLY_UNIT">
        <doc xml:space="preserve">return only unit, without value; this should
    not be used together with @G_FORMAT_SIZE_LONG_FORMAT
    nor @G_FORMAT_SIZE_ONLY_VALUE. Since: 2.74</doc>
      </member>
    </bitfield>
    <callback name="FreeFunc" c:type="GFreeFunc">
      <doc xml:space="preserve">Declares a type of function which takes an arbitrary
data pointer argument and has no return value. It is
not currently used in GLib or GTK.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a data pointer</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="Func" c:type="GFunc">
      <doc xml:space="preserve">Specifies the type of functions passed to g_list_foreach() and
g_slist_foreach().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the element's data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="1">
          <doc xml:space="preserve">user data passed to g_list_foreach() or g_slist_foreach()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="GINT16_FORMAT" value="hi" c:type="G_GINT16_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GINT16_MODIFIER" value="h" c:type="G_GINT16_MODIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GINT32_FORMAT" value="i" c:type="G_GINT32_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GINT32_MODIFIER" value="" c:type="G_GINT32_MODIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GINT64_CONSTANT" c:identifier="G_GINT64_CONSTANT" introspectable="0">
      <parameters>
        <parameter name="val">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GINT64_FORMAT" value="li" c:type="G_GINT64_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GINT64_MODIFIER" value="l" c:type="G_GINT64_MODIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GINTPTR_FORMAT" value="li" c:type="G_GINTPTR_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GINTPTR_MODIFIER" value="l" c:type="G_GINTPTR_MODIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GNUC_ALLOC_SIZE" c:identifier="G_GNUC_ALLOC_SIZE" version="2.18" introspectable="0">
      <doc xml:space="preserve">Expands to the GNU C `alloc_size` function attribute if the compiler
is a new enough gcc. This attribute tells the compiler that the
function returns a pointer to memory of a size that is specified
by the @xth function parameter.

Place the attribute after the function declaration, just before the
semicolon.

|[&lt;!-- language="C" --&gt;
gpointer g_malloc (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
]|

See the [GNU C documentation](https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-alloc_005fsize-function-attribute) for more details.</doc>
      <parameters>
        <parameter name="x">
          <doc xml:space="preserve">the index of the argument specifying the allocation size</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GNUC_ALLOC_SIZE2" c:identifier="G_GNUC_ALLOC_SIZE2" version="2.18" introspectable="0">
      <doc xml:space="preserve">Expands to the GNU C `alloc_size` function attribute if the compiler is a
new enough gcc. This attribute tells the compiler that the function returns
a pointer to memory of a size that is specified by the product of two
function parameters.

Place the attribute after the function declaration, just before the
semicolon.

|[&lt;!-- language="C" --&gt;
gpointer g_malloc_n (gsize n_blocks,
                     gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1, 2);
]|

See the [GNU C documentation](https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-alloc_005fsize-function-attribute) for more details.</doc>
      <parameters>
        <parameter name="x">
          <doc xml:space="preserve">the index of the argument specifying one factor of the allocation size</doc>
        </parameter>
        <parameter name="y">
          <doc xml:space="preserve">the index of the argument specifying the second factor of the allocation size</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GNUC_CHECK_VERSION" c:identifier="G_GNUC_CHECK_VERSION" version="2.42" introspectable="0">
      <doc xml:space="preserve">Expands to a check for a compiler with __GNUC__ defined and a version
greater than or equal to the major and minor numbers provided. For example,
the following would only match on compilers such as GCC 4.8 or newer.

|[&lt;!-- language="C" --&gt;
#if G_GNUC_CHECK_VERSION(4, 8)
#endif
]|</doc>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve">major version to check against</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve">minor version to check against</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GNUC_DEPRECATED_FOR" c:identifier="G_GNUC_DEPRECATED_FOR" version="2.26" introspectable="0">
      <doc xml:space="preserve">Like %G_GNUC_DEPRECATED, but names the intended replacement for the
deprecated symbol if the version of gcc in use is new enough to support
custom deprecation messages.

Place the attribute after the declaration, just before the semicolon.

|[&lt;!-- language="C" --&gt;
int my_mistake (void) G_GNUC_DEPRECATED_FOR(my_replacement);
]|

See the [GNU C documentation](https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-deprecated-function-attribute) for more details.

Note that if @f is a macro, it will be expanded in the warning message.
You can enclose it in quotes to prevent this. (The quotes will show up
in the warning, but it's better than showing the macro expansion.)</doc>
      <parameters>
        <parameter name="f">
          <doc xml:space="preserve">the intended replacement for the deprecated symbol,
    such as the name of a function</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GNUC_FORMAT" c:identifier="G_GNUC_FORMAT" introspectable="0">
      <doc xml:space="preserve">Expands to the GNU C `format_arg` function attribute if the compiler
is gcc. This function attribute specifies that a function takes a
format string for a `printf()`, `scanf()`, `strftime()` or `strfmon()` style
function and modifies it, so that the result can be passed to a `printf()`,
`scanf()`, `strftime()` or `strfmon()` style function (with the remaining
arguments to the format function the same as they would have been
for the unmodified string).

Place the attribute after the function declaration, just before the
semicolon.

See the [GNU C documentation](https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-Wformat-nonliteral-1) for more details.

|[&lt;!-- language="C" --&gt;
gchar *g_dgettext (gchar *domain_name, gchar *msgid) G_GNUC_FORMAT (2);
]|</doc>
      <parameters>
        <parameter name="arg_idx">
          <doc xml:space="preserve">the index of the argument</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GNUC_FUNCTION" value="" c:type="G_GNUC_FUNCTION" deprecated="1" deprecated-version="2.16">
      <doc xml:space="preserve">Expands to "" on all modern compilers, and to  __FUNCTION__ on gcc
version 2.x. Don't use it.</doc>
      <doc-deprecated xml:space="preserve">Use G_STRFUNC() instead</doc-deprecated>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GNUC_PRETTY_FUNCTION" value="" c:type="G_GNUC_PRETTY_FUNCTION" deprecated="1" deprecated-version="2.16">
      <doc xml:space="preserve">Expands to "" on all modern compilers, and to __PRETTY_FUNCTION__
on gcc version 2.x. Don't use it.</doc>
      <doc-deprecated xml:space="preserve">Use G_STRFUNC() instead</doc-deprecated>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GNUC_PRINTF" c:identifier="G_GNUC_PRINTF" introspectable="0">
      <doc xml:space="preserve">Expands to the GNU C `format` function attribute if the compiler is gcc.
This is used for declaring functions which take a variable number of
arguments, with the same syntax as `printf()`. It allows the compiler
to type-check the arguments passed to the function.

Place the attribute after the function declaration, just before the
semicolon.

See the
[GNU C documentation](https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-Wformat-3288)
for more details.

|[&lt;!-- language="C" --&gt;
gint g_snprintf (gchar  *string,
                 gulong       n,
                 gchar const *format,
                 ...) G_GNUC_PRINTF (3, 4);
]|</doc>
      <parameters>
        <parameter name="format_idx">
          <doc xml:space="preserve">the index of the argument corresponding to the
    format string (the arguments are numbered from 1)</doc>
        </parameter>
        <parameter name="arg_idx">
          <doc xml:space="preserve">the index of the first of the format arguments, or 0 if
    there are no format arguments</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GNUC_SCANF" c:identifier="G_GNUC_SCANF" introspectable="0">
      <doc xml:space="preserve">Expands to the GNU C `format` function attribute if the compiler is gcc.
This is used for declaring functions which take a variable number of
arguments, with the same syntax as `scanf()`. It allows the compiler
to type-check the arguments passed to the function.

|[&lt;!-- language="C" --&gt;
int my_scanf (MyStream *stream,
              const char *format,
              ...) G_GNUC_SCANF (2, 3);
int my_vscanf (MyStream *stream,
               const char *format,
               va_list ap) G_GNUC_SCANF (2, 0);
]|

See the
[GNU C documentation](https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-Wformat-3288)
for details.</doc>
      <parameters>
        <parameter name="format_idx">
          <doc xml:space="preserve">the index of the argument corresponding to
    the format string (the arguments are numbered from 1)</doc>
        </parameter>
        <parameter name="arg_idx">
          <doc xml:space="preserve">the index of the first of the format arguments, or 0 if
    there are no format arguments</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GNUC_STRFTIME" c:identifier="G_GNUC_STRFTIME" version="2.60" introspectable="0">
      <doc xml:space="preserve">Expands to the GNU C `strftime` format function attribute if the compiler
is gcc. This is used for declaring functions which take a format argument
which is passed to `strftime()` or an API implementing its formats. It allows
the compiler check the format passed to the function.

|[&lt;!-- language="C" --&gt;
gsize my_strftime (MyBuffer *buffer,
                   const char *format,
                   const struct tm *tm) G_GNUC_STRFTIME (2);
]|

See the
[GNU C documentation](https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-Wformat-3288)
for details.</doc>
      <parameters>
        <parameter name="format_idx">
          <doc xml:space="preserve">the index of the argument corresponding to
    the format string (the arguments are numbered from 1)</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GOFFSET_CONSTANT" c:identifier="G_GOFFSET_CONSTANT" introspectable="0">
      <parameters>
        <parameter name="val">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GSIZE_FORMAT" value="lu" c:type="G_GSIZE_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GSIZE_MODIFIER" value="l" c:type="G_GSIZE_MODIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GSSIZE_FORMAT" value="li" c:type="G_GSSIZE_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GSSIZE_MODIFIER" value="l" c:type="G_GSSIZE_MODIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GUINT16_FORMAT" value="hu" c:type="G_GUINT16_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GUINT32_FORMAT" value="u" c:type="G_GUINT32_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="GUINT64_CONSTANT" c:identifier="G_GUINT64_CONSTANT" introspectable="0">
      <parameters>
        <parameter name="val">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="GUINT64_FORMAT" value="lu" c:type="G_GUINT64_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="GUINTPTR_FORMAT" value="lu" c:type="G_GUINTPTR_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="HAVE_GINT64" value="1" c:type="G_HAVE_GINT64">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="HAVE_GNUC_VARARGS" value="1" c:type="G_HAVE_GNUC_VARARGS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="HAVE_GNUC_VISIBILITY" value="1" c:type="G_HAVE_GNUC_VISIBILITY">
      <doc xml:space="preserve">Defined to 1 if gcc-style visibility handling is supported.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="HAVE_GROWING_STACK" value="0" c:type="G_HAVE_GROWING_STACK">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="HAVE_ISO_VARARGS" value="1" c:type="G_HAVE_ISO_VARARGS">
      <type name="gint" c:type="gint"/>
    </constant>
    <callback name="HFunc" c:type="GHFunc">
      <doc xml:space="preserve">Specifies the type of the function passed to g_hash_table_foreach().
It is called with each key/value pair, together with the @user_data
parameter which is passed to g_hash_table_foreach().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a key</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the value corresponding to the key</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data passed to g_hash_table_foreach()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="HOOK" c:identifier="G_HOOK" introspectable="0">
      <doc xml:space="preserve">Casts a pointer to a `GHook*`.</doc>
      <parameters>
        <parameter name="hook">
          <doc xml:space="preserve">a pointer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="HOOK_ACTIVE" c:identifier="G_HOOK_ACTIVE" introspectable="0">
      <doc xml:space="preserve">Returns %TRUE if the #GHook is active, which is normally the case
until the #GHook is destroyed.</doc>
      <parameters>
        <parameter name="hook">
          <doc xml:space="preserve">a #GHook</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="HOOK_FLAGS" c:identifier="G_HOOK_FLAGS" introspectable="0">
      <doc xml:space="preserve">Gets the flags of a hook.</doc>
      <parameters>
        <parameter name="hook">
          <doc xml:space="preserve">a #GHook</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="HOOK_FLAG_USER_SHIFT" value="4" c:type="G_HOOK_FLAG_USER_SHIFT">
      <doc xml:space="preserve">The position of the first bit which is not reserved for internal
use be the #GHook implementation, i.e.
`1 &lt;&lt; G_HOOK_FLAG_USER_SHIFT` is the first
bit which can be used for application-defined flags.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="HOOK_IN_CALL" c:identifier="G_HOOK_IN_CALL" introspectable="0">
      <doc xml:space="preserve">Returns %TRUE if the #GHook function is currently executing.</doc>
      <parameters>
        <parameter name="hook">
          <doc xml:space="preserve">a #GHook</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="HOOK_IS_UNLINKED" c:identifier="G_HOOK_IS_UNLINKED" introspectable="0">
      <doc xml:space="preserve">Returns %TRUE if the #GHook is not in a #GHookList.</doc>
      <parameters>
        <parameter name="hook">
          <doc xml:space="preserve">a #GHook</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="HOOK_IS_VALID" c:identifier="G_HOOK_IS_VALID" introspectable="0">
      <doc xml:space="preserve">Returns %TRUE if the #GHook is valid, i.e. it is in a #GHookList,
it is active and it has not been destroyed.</doc>
      <parameters>
        <parameter name="hook">
          <doc xml:space="preserve">a #GHook</doc>
        </parameter>
      </parameters>
    </function-macro>
    <callback name="HRFunc" c:type="GHRFunc">
      <doc xml:space="preserve">Specifies the type of the function passed to
[func@GLib.HashTable.find], [func@GLib.HashTable.foreach_remove], and
[func@GLib.HashTable.foreach_steal].

The function is called with each key/value pair, together with
the @user_data parameter passed to the calling function.

The function should return true if the key/value pair should be
selected, meaning it has been found or it should be removed from the
[struct@GLib.HashTable], depending on the calling function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if the key/value pair should be selected, and
  false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a key</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the value associated with the key</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data passed to the calling function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="HashFunc" c:type="GHashFunc">
      <doc xml:space="preserve">Specifies the type of the hash function which is passed to
g_hash_table_new() when a #GHashTable is created.

The function is passed a key and should return a #guint hash value.
The functions g_direct_hash(), g_int_hash() and g_str_hash() provide
hash functions which can be used when the key is a #gpointer, #gint*,
and #gchar* respectively.

g_direct_hash() is also the appropriate hash function for keys
of the form `GINT_TO_POINTER (n)` (or similar macros).

A good hash functions should produce
hash values that are evenly distributed over a fairly large range.
The modulus is taken with the hash table size (a prime number) to
find the 'bucket' to place each key into. The function should also
be very fast, since it is called for each key lookup.

Note that the hash functions provided by GLib have these qualities,
but are not particularly robust against manufactured keys that
cause hash collisions. Therefore, you should consider choosing
a more secure hash function when using a GHashTable with keys
that originate in untrusted data (such as HTTP requests).
Using g_str_hash() in that situation might make your application
vulnerable to
[Algorithmic Complexity Attacks](https://lwn.net/Articles/474912/).

The key to choosing a good hash is unpredictability.  Even
cryptographic hashes are very easy to find collisions for when the
remainder is taken modulo a somewhat predictable prime number.  There
must be an element of randomness that an attacker is unable to guess.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the hash value corresponding to the key</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a key</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="HashTable" c:type="GHashTable" opaque="1" glib:type-name="GHashTable" glib:get-type="g_hash_table_get_type" c:symbol-prefix="hash_table">
      <doc xml:space="preserve">The #GHashTable struct is an opaque data structure to represent a
[Hash Table](data-structures.html#hash-tables). It should only be accessed via the
following functions.</doc>
      <function name="add" c:identifier="g_hash_table_add" version="2.32">
        <doc xml:space="preserve">This is a convenience function for using a #GHashTable as a set.  It
is equivalent to calling g_hash_table_replace() with @key as both the
key and the value.

In particular, this means that if @key already exists in the hash table, then
the old copy of @key in the hash table is freed and @key replaces it in the
table.

When a hash table only ever contains keys that have themselves as the
corresponding value it is able to be stored more efficiently.  See
the discussion in the section description.

Starting from GLib 2.40, this function returns a boolean value to
indicate whether the newly added value was already in the hash table
or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key did not exist yet</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">a key to insert</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="contains" c:identifier="g_hash_table_contains" version="2.32">
        <doc xml:space="preserve">Checks if @key is in @hash_table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @key is in @hash_table, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a key to check</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="destroy" c:identifier="g_hash_table_destroy">
        <doc xml:space="preserve">Destroys all keys and values in the #GHashTable and decrements its
reference count by 1. If keys and/or values are dynamically allocated,
you should either free them first or create the #GHashTable with destroy
notifiers using g_hash_table_new_full(). In the latter case the destroy
functions you supplied will be called on all keys and values during the
destruction phase.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="find" c:identifier="g_hash_table_find" version="2.4">
        <doc xml:space="preserve">Calls the given function for key/value pairs in the #GHashTable
until @predicate returns %TRUE. The function is passed the key
and value of each pair, and the given @user_data parameter. The
hash table may not be modified while iterating over it (you can't
add/remove items).

Note, that hash tables are really only optimized for forward
lookups, i.e. g_hash_table_lookup(). So code that frequently issues
g_hash_table_find() or g_hash_table_foreach() (e.g. in the order of
once per every entry in a hash table) should probably be reworked
to use additional or different data structures for reverse lookups
(keep in mind that an O(n) find/foreach operation issued for all n
values in a hash table ends up needing O(n*n) operations).</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The value of the first key/value pair is returned,
    for which @predicate evaluates to %TRUE. If no pair with the
    requested property is found, %NULL is returned.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="predicate" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">function to test the key/value pairs for a certain property</doc>
            <type name="HRFunc" c:type="GHRFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="foreach" c:identifier="g_hash_table_foreach">
        <doc xml:space="preserve">Calls the given function for each of the key/value pairs in the
#GHashTable.  The function is passed the key and value of each
pair, and the given @user_data parameter.  The hash table may not
be modified while iterating over it (you can't add/remove
items). To remove all items matching a predicate, use
g_hash_table_foreach_remove().

The order in which g_hash_table_foreach() iterates over the keys/values in
the hash table is not defined.

See g_hash_table_find() for performance caveats for linear
order searches in contrast to g_hash_table_lookup().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call for each key/value pair</doc>
            <type name="HFunc" c:type="GHFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="foreach_remove" c:identifier="g_hash_table_foreach_remove">
        <doc xml:space="preserve">Calls the given function for each key/value pair in the
#GHashTable. If the function returns %TRUE, then the key/value
pair is removed from the #GHashTable. If you supplied key or
value destroy functions when creating the #GHashTable, they are
used to free the memory allocated for the removed keys and values.

See #GHashTableIter for an alternative way to loop over the
key/value pairs in the hash table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of key/value pairs removed</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call for each key/value pair</doc>
            <type name="HRFunc" c:type="GHRFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="foreach_steal" c:identifier="g_hash_table_foreach_steal">
        <doc xml:space="preserve">Calls the given function for each key/value pair in the
#GHashTable. If the function returns %TRUE, then the key/value
pair is removed from the #GHashTable, but no key or value
destroy functions are called.

See #GHashTableIter for an alternative way to loop over the
key/value pairs in the hash table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of key/value pairs removed.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call for each key/value pair</doc>
            <type name="HRFunc" c:type="GHRFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_keys" c:identifier="g_hash_table_get_keys" version="2.14" introspectable="0">
        <doc xml:space="preserve">Retrieves every key inside @hash_table. The returned data is valid
until changes to the hash release those keys.

This iterates over every entry in the hash table to build its return value.
To iterate over the entries in a #GHashTable more efficiently, use a
#GHashTableIter.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GList containing all the keys
    inside the hash table. The content of the list is owned by the
    hash table and should not be modified or freed. Use g_list_free()
    when done using the list.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="get_keys_as_array" c:identifier="g_hash_table_get_keys_as_array" version="2.40" introspectable="0">
        <doc xml:space="preserve">Retrieves every key inside @hash_table, as an array.

The returned array is %NULL-terminated but may contain %NULL as a
key.  Use @length to determine the true length if it's possible that
%NULL was used as the value for a key.

Note: in the common case of a string-keyed #GHashTable, the return
value of this function can be conveniently cast to (const gchar **).

This iterates over every entry in the hash table to build its return value.
To iterate over the entries in a #GHashTable more efficiently, use a
#GHashTableIter.

You should always free the return result with g_free().  In the
above-mentioned case of a string-keyed hash table, it may be
appropriate to use g_strfreev() if you call g_hash_table_steal_all()
first to transfer ownership of the keys.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a
  %NULL-terminated array containing each key from the table.</doc>
          <array length="1" zero-terminated="0" c:type="gpointer*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the length of the returned array</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_keys_as_ptr_array" c:identifier="g_hash_table_get_keys_as_ptr_array" version="2.76" introspectable="0">
        <doc xml:space="preserve">Retrieves every key inside @hash_table, as a #GPtrArray.
The returned data is valid until changes to the hash release those keys.

This iterates over every entry in the hash table to build its return value.
To iterate over the entries in a #GHashTable more efficiently, use a
#GHashTableIter.

You should always unref the returned array with g_ptr_array_unref().</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GPtrArray containing each key from
the table. Unref with g_ptr_array_unref() when done.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="get_values" c:identifier="g_hash_table_get_values" version="2.14" introspectable="0">
        <doc xml:space="preserve">Retrieves every value inside @hash_table. The returned data
is valid until @hash_table is modified.

This iterates over every entry in the hash table to build its return value.
To iterate over the entries in a #GHashTable more efficiently, use a
#GHashTableIter.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GList containing all the values
    inside the hash table. The content of the list is owned by the
    hash table and should not be modified or freed. Use g_list_free()
    when done using the list.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="get_values_as_ptr_array" c:identifier="g_hash_table_get_values_as_ptr_array" version="2.76" introspectable="0">
        <doc xml:space="preserve">Retrieves every value inside @hash_table, as a #GPtrArray.
The returned data is valid until changes to the hash release those values.

This iterates over every entry in the hash table to build its return value.
To iterate over the entries in a #GHashTable more efficiently, use a
#GHashTableIter.

You should always unref the returned array with g_ptr_array_unref().</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GPtrArray containing each value from
the table. Unref with g_ptr_array_unref() when done.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="insert" c:identifier="g_hash_table_insert">
        <doc xml:space="preserve">Inserts a new key and value into a #GHashTable.

If the key already exists in the #GHashTable its current
value is replaced with the new value. If you supplied a
@value_destroy_func when creating the #GHashTable, the old
value is freed using that function. If you supplied a
@key_destroy_func when creating the #GHashTable, the passed
key is freed using that function.

Starting from GLib 2.40, this function returns a boolean value to
indicate whether the newly added value was already in the hash table
or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key did not exist yet</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a key to insert</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value to associate with the key</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="lookup" c:identifier="g_hash_table_lookup">
        <doc xml:space="preserve">Looks up a key in a #GHashTable. Note that this function cannot
distinguish between a key that is not present and one which is present
and has the value %NULL. If you need this distinction, use
g_hash_table_lookup_extended().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the associated value, or %NULL if the key is not found</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="lookup_extended" c:identifier="g_hash_table_lookup_extended">
        <doc xml:space="preserve">Looks up a key in the #GHashTable, returning the original key and the
associated value and a #gboolean which is %TRUE if the key was found. This
is useful if you need to free the memory allocated for the original key,
for example before calling g_hash_table_remove().

You can actually pass %NULL for @lookup_key to test
whether the %NULL key exists, provided the hash and equal functions
of @hash_table are %NULL-safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key was found in the #GHashTable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="lookup_key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="orig_key" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the original key</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the value associated
with the key</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="g_hash_table_new" introspectable="0">
        <doc xml:space="preserve">Creates a new #GHashTable with a reference count of 1.

Hash values returned by @hash_func are used to determine where keys
are stored within the #GHashTable data structure. The g_direct_hash(),
g_int_hash(), g_int64_hash(), g_double_hash() and g_str_hash()
functions are provided for some common types of keys.
If @hash_func is %NULL, g_direct_hash() is used.

@key_equal_func is used when looking up keys in the #GHashTable.
The g_direct_equal(), g_int_equal(), g_int64_equal(), g_double_equal()
and g_str_equal() functions are provided for the most common types
of keys. If @key_equal_func is %NULL, keys are compared directly in
a similar fashion to g_direct_equal(), but without the overhead of
a function call. @key_equal_func is called with the key from the hash table
as its first parameter, and the user-provided key to check against as
its second.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="hash_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to create a hash value from a key</doc>
            <type name="HashFunc" c:type="GHashFunc"/>
          </parameter>
          <parameter name="key_equal_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to check two keys for equality</doc>
            <type name="EqualFunc" c:type="GEqualFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_full" c:identifier="g_hash_table_new_full" introspectable="0">
        <doc xml:space="preserve">Creates a new #GHashTable like g_hash_table_new() with a reference
count of 1 and allows to specify functions to free the memory
allocated for the key and value that get called when removing the
entry from the #GHashTable.

Since version 2.42 it is permissible for destroy notify functions to
recursively remove further items from the hash table. This is only
permissible if the application still holds a reference to the hash table.
This means that you may need to ensure that the hash table is empty by
calling g_hash_table_remove_all() before releasing the last reference using
g_hash_table_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="hash_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to create a hash value from a key</doc>
            <type name="HashFunc" c:type="GHashFunc"/>
          </parameter>
          <parameter name="key_equal_func" transfer-ownership="none" scope="notified" destroy="3">
            <doc xml:space="preserve">a function to check two keys for equality</doc>
            <type name="EqualFunc" c:type="GEqualFunc"/>
          </parameter>
          <parameter name="key_destroy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to free the memory allocated for the key
    used when removing the entry from the #GHashTable, or %NULL
    if you don't want to supply such a function.</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="value_destroy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to free the memory allocated for the
    value used when removing the entry from the #GHashTable, or %NULL
    if you don't want to supply such a function.</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_similar" c:identifier="g_hash_table_new_similar" version="2.72">
        <doc xml:space="preserve">Creates a new #GHashTable like g_hash_table_new_full() with a reference
count of 1.

It inherits the hash function, the key equal function, the key destroy function,
as well as the value destroy function, from @other_hash_table.

The returned hash table will be empty; it will not contain the keys
or values from @other_hash_table.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="other_hash_table" transfer-ownership="none">
            <doc xml:space="preserve">Another #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="ref" c:identifier="g_hash_table_ref" version="2.10">
        <doc xml:space="preserve">Atomically increments the reference count of @hash_table by one.
This function is MT-safe and may be called from any thread.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="remove" c:identifier="g_hash_table_remove">
        <doc xml:space="preserve">Removes a key and its associated value from a #GHashTable.

If the #GHashTable was created using g_hash_table_new_full(), the
key and value are freed using the supplied destroy functions, otherwise
you have to make sure that any dynamically allocated values are freed
yourself.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key was found and removed from the #GHashTable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to remove</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_all" c:identifier="g_hash_table_remove_all" version="2.12">
        <doc xml:space="preserve">Removes all keys and their associated values from a #GHashTable.

If the #GHashTable was created using g_hash_table_new_full(),
the keys and values are freed using the supplied destroy functions,
otherwise you have to make sure that any dynamically allocated
values are freed yourself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="replace" c:identifier="g_hash_table_replace">
        <doc xml:space="preserve">Inserts a new key and value into a #GHashTable similar to
g_hash_table_insert(). The difference is that if the key
already exists in the #GHashTable, it gets replaced by the
new key. If you supplied a @value_destroy_func when creating
the #GHashTable, the old value is freed using that function.
If you supplied a @key_destroy_func when creating the
#GHashTable, the old key is freed using that function.

Starting from GLib 2.40, this function returns a boolean value to
indicate whether the newly added value was already in the hash table
or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key did not exist yet</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a key to insert</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value to associate with the key</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="size" c:identifier="g_hash_table_size">
        <doc xml:space="preserve">Returns the number of elements contained in the #GHashTable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of key/value pairs in the #GHashTable.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="steal" c:identifier="g_hash_table_steal">
        <doc xml:space="preserve">Removes a key and its associated value from a #GHashTable without
calling the key and value destroy functions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key was found and removed from the #GHashTable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to remove</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="steal_all" c:identifier="g_hash_table_steal_all" version="2.12">
        <doc xml:space="preserve">Removes all keys and their associated values from a #GHashTable
without calling the key and value destroy functions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="steal_all_keys" c:identifier="g_hash_table_steal_all_keys" version="2.76" introspectable="0">
        <doc xml:space="preserve">Removes all keys and their associated values from a #GHashTable
without calling the key destroy functions, returning the keys
as a #GPtrArray with the free func set to the @hash_table key
destroy function.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GPtrArray containing each key of
the table. Unref with g_ptr_array_unref() when done.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="steal_all_values" c:identifier="g_hash_table_steal_all_values" version="2.76" introspectable="0">
        <doc xml:space="preserve">Removes all keys and their associated values from a #GHashTable
without calling the value destroy functions, returning the values
as a #GPtrArray with the free func set to the @hash_table value
destroy function.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GPtrArray containing each value of
the table. Unref with g_ptr_array_unref() when done.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="steal_extended" c:identifier="g_hash_table_steal_extended" version="2.58">
        <doc xml:space="preserve">Looks up a key in the #GHashTable, stealing the original key and the
associated value and returning %TRUE if the key was found. If the key was
not found, %FALSE is returned.

If found, the stolen key and value are removed from the hash table without
calling the key and value destroy functions, and ownership is transferred to
the caller of this method, as with g_hash_table_steal(). That is the case
regardless whether @stolen_key or @stolen_value output parameters are
requested.

You can pass %NULL for @lookup_key, provided the hash and equal functions
of @hash_table are %NULL-safe.

The dictionary implementation optimizes for having all values identical to
their keys, for example by using g_hash_table_add(). Before 2.82, when
stealing both the key and the value from such a dictionary, the value was
%NULL. Since 2.82, the returned value and key will be the same.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key was found in the #GHashTable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="lookup_key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="stolen_key" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the
   original key</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
          <parameter name="stolen_value" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">return location
   for the value associated with the key</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref" c:identifier="g_hash_table_unref" version="2.10">
        <doc xml:space="preserve">Atomically decrements the reference count of @hash_table by one.
If the reference count drops to 0, all keys and values will be
destroyed, and all memory allocated by the hash table is released.
This function is MT-safe and may be called from any thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="full">
            <doc xml:space="preserve">a valid #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="HashTableIter" c:type="GHashTableIter">
      <doc xml:space="preserve">A GHashTableIter structure represents an iterator that can be used
to iterate over the elements of a #GHashTable. GHashTableIter
structures are typically allocated on the stack and then initialized
with g_hash_table_iter_init().

The iteration order of a #GHashTableIter over the keys/values in a hash
table is not defined.</doc>
      <field name="dummy1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy4" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="dummy5" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="dummy6" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="get_hash_table" c:identifier="g_hash_table_iter_get_hash_table" version="2.16">
        <doc xml:space="preserve">Returns the #GHashTable associated with @iter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GHashTable associated with @iter.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an initialized #GHashTableIter</doc>
            <type name="HashTableIter" c:type="GHashTableIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_hash_table_iter_init" version="2.16">
        <doc xml:space="preserve">Initializes a key/value pair iterator and associates it with
@hash_table. Modifying the hash table after calling this function
invalidates the returned iterator.

The iteration order of a #GHashTableIter over the keys/values in a hash
table is not defined.

|[&lt;!-- language="C" --&gt;
GHashTableIter iter;
gpointer key, value;

g_hash_table_iter_init (&amp;iter, hash_table);
while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
  {
    // do something with key and value
  }
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized #GHashTableIter</doc>
            <type name="HashTableIter" c:type="GHashTableIter*"/>
          </instance-parameter>
          <parameter name="hash_table" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="g_hash_table_iter_next" version="2.16">
        <doc xml:space="preserve">Advances @iter and retrieves the key and/or value that are now
pointed to as a result of this advancement. If %FALSE is returned,
@key and @value are not set, and the iterator becomes invalid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the end of the #GHashTable has been reached.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an initialized #GHashTableIter</doc>
            <type name="HashTableIter" c:type="GHashTableIter*"/>
          </instance-parameter>
          <parameter name="key" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to store the key</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to store the value</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_hash_table_iter_remove" version="2.16">
        <doc xml:space="preserve">Removes the key/value pair currently pointed to by the iterator
from its associated #GHashTable. Can only be called after
g_hash_table_iter_next() returned %TRUE, and cannot be called
more than once for the same key/value pair.

If the #GHashTable was created using g_hash_table_new_full(),
the key and value are freed using the supplied destroy functions,
otherwise you have to make sure that any dynamically allocated
values are freed yourself.

It is safe to continue iterating the #GHashTable afterward:
|[&lt;!-- language="C" --&gt;
while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
  {
    if (condition)
      g_hash_table_iter_remove (&amp;iter);
  }
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an initialized #GHashTableIter</doc>
            <type name="HashTableIter" c:type="GHashTableIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="replace" c:identifier="g_hash_table_iter_replace" version="2.30">
        <doc xml:space="preserve">Replaces the value currently pointed to by the iterator
from its associated #GHashTable. Can only be called after
g_hash_table_iter_next() returned %TRUE.

If you supplied a @value_destroy_func when creating the
#GHashTable, the old value is freed using that function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an initialized #GHashTableIter</doc>
            <type name="HashTableIter" c:type="GHashTableIter*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value to replace with</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal" c:identifier="g_hash_table_iter_steal" version="2.16">
        <doc xml:space="preserve">Removes the key/value pair currently pointed to by the
iterator from its associated #GHashTable, without calling
the key and value destroy functions. Can only be called
after g_hash_table_iter_next() returned %TRUE, and cannot
be called more than once for the same key/value pair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an initialized #GHashTableIter</doc>
            <type name="HashTableIter" c:type="GHashTableIter*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Hmac" c:type="GHmac" opaque="1" version="2.30" glib:type-name="GHmac" glib:get-type="g_hmac_get_type" c:symbol-prefix="hmac">
      <doc xml:space="preserve">HMACs should be used when producing a cookie or hash based on data
and a key. Simple mechanisms for using SHA1 and other algorithms to
digest a key and data together are vulnerable to various security
issues.
[HMAC](http://en.wikipedia.org/wiki/HMAC)
uses algorithms like SHA1 in a secure way to produce a digest of a
key and data.

Both the key and data are arbitrary byte arrays of bytes or characters.

Support for HMAC Digests has been added in GLib 2.30, and support for SHA-512
in GLib 2.42. Support for SHA-384 was added in GLib 2.52.

To create a new `GHmac`, use [ctor@GLib.Hmac.new]. To free a `GHmac`, use
[method@GLib.Hmac.unref].</doc>
      <constructor name="new" c:identifier="g_hmac_new" version="2.30">
        <doc xml:space="preserve">Creates a new #GHmac, using the digest algorithm @digest_type.
If the @digest_type is not known, %NULL is returned.
A #GHmac can be used to compute the HMAC of a key and an
arbitrary binary blob, using different hashing algorithms.

A #GHmac works by feeding a binary blob through g_hmac_update()
until the data is complete; the digest can then be extracted
using g_hmac_get_string(), which will return the checksum as a
hexadecimal string; or g_hmac_get_digest(), which will return a
array of raw bytes. Once either g_hmac_get_string() or
g_hmac_get_digest() have been called on a #GHmac, the HMAC
will be closed and it won't be possible to call g_hmac_update()
on it anymore.

Support for digests of type %G_CHECKSUM_SHA512 has been added in GLib 2.42.
Support for %G_CHECKSUM_SHA384 was added in GLib 2.52.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the newly created #GHmac, or %NULL.
  Use g_hmac_unref() to free the memory allocated by it.</doc>
          <type name="Hmac" c:type="GHmac*"/>
        </return-value>
        <parameters>
          <parameter name="digest_type" transfer-ownership="none">
            <doc xml:space="preserve">the desired type of digest</doc>
            <type name="ChecksumType" c:type="GChecksumType"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key for the HMAC</doc>
            <array length="2" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="key_len" transfer-ownership="none">
            <doc xml:space="preserve">the length of the keys</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="g_hmac_copy" version="2.30">
        <doc xml:space="preserve">Copies a #GHmac. If @hmac has been closed, by calling
g_hmac_get_string() or g_hmac_get_digest(), the copied
HMAC will be closed as well.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the copy of the passed #GHmac. Use g_hmac_unref()
  when finished using it.</doc>
          <type name="Hmac" c:type="GHmac*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hmac" transfer-ownership="none">
            <doc xml:space="preserve">the #GHmac to copy</doc>
            <type name="Hmac" c:type="const GHmac*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_digest" c:identifier="g_hmac_get_digest" version="2.30">
        <doc xml:space="preserve">Gets the digest from @checksum as a raw binary array and places it
into @buffer. The size of the digest depends on the type of checksum.

Once this function has been called, the #GHmac is closed and can
no longer be updated with g_checksum_update().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hmac" transfer-ownership="none">
            <doc xml:space="preserve">a #GHmac</doc>
            <type name="Hmac" c:type="GHmac*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">output buffer</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="digest_len" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">an inout parameter. The caller initializes it to the
  size of @buffer. After the call it contains the length of the digest</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="g_hmac_get_string" version="2.30">
        <doc xml:space="preserve">Gets the HMAC as a hexadecimal string.

Once this function has been called the #GHmac can no longer be
updated with g_hmac_update().

The hexadecimal characters will be lower case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hexadecimal representation of the HMAC. The
  returned string is owned by the HMAC and should not be modified
  or freed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hmac" transfer-ownership="none">
            <doc xml:space="preserve">a #GHmac</doc>
            <type name="Hmac" c:type="GHmac*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_hmac_ref" version="2.30">
        <doc xml:space="preserve">Atomically increments the reference count of @hmac by one.

This function is MT-safe and may be called from any thread.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in #GHmac.</doc>
          <type name="Hmac" c:type="GHmac*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hmac" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GHmac</doc>
            <type name="Hmac" c:type="GHmac*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_hmac_unref" version="2.30">
        <doc xml:space="preserve">Atomically decrements the reference count of @hmac by one.

If the reference count drops to 0, all keys and values will be
destroyed, and all memory allocated by the hash table is released.
This function is MT-safe and may be called from any thread.
Frees the memory allocated for @hmac.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hmac" transfer-ownership="full">
            <doc xml:space="preserve">a #GHmac</doc>
            <type name="Hmac" c:type="GHmac*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="update" c:identifier="g_hmac_update" version="2.30">
        <doc xml:space="preserve">Feeds @data into an existing #GHmac.

The HMAC must still be open, that is g_hmac_get_string() or
g_hmac_get_digest() must not have been called on @hmac.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hmac" transfer-ownership="none">
            <doc xml:space="preserve">a #GHmac</doc>
            <type name="Hmac" c:type="GHmac*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">buffer used to compute the checksum</doc>
            <array length="1" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">size of the buffer, or -1 if it is a nul-terminated string</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="Hook" c:type="GHook">
      <doc xml:space="preserve">The #GHook struct represents a single hook function in a #GHookList.</doc>
      <field name="data" writable="1">
        <doc xml:space="preserve">data which is passed to func when this hook is invoked</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="next" writable="1">
        <doc xml:space="preserve">pointer to the next hook in the list</doc>
        <type name="Hook" c:type="GHook*"/>
      </field>
      <field name="prev" writable="1">
        <doc xml:space="preserve">pointer to the previous hook in the list</doc>
        <type name="Hook" c:type="GHook*"/>
      </field>
      <field name="ref_count" writable="1">
        <doc xml:space="preserve">the reference count of this hook</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="hook_id" writable="1">
        <doc xml:space="preserve">the id of this hook, which is unique within its list</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">flags which are set for this hook. See #GHookFlagMask for
    predefined flags</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="func" writable="1">
        <doc xml:space="preserve">the function to call when this hook is invoked. The possible
    signatures for this function are #GHookFunc and #GHookCheckFunc</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="destroy" writable="1">
        <doc xml:space="preserve">the default @finalize_hook function of a #GHookList calls
    this member of the hook that is being finalized</doc>
        <type name="DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <method name="compare_ids" c:identifier="g_hook_compare_ids">
        <doc xml:space="preserve">Compares the ids of two #GHook elements, returning a negative value
if the second id is greater than the first.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a value &lt;= 0 if the id of @sibling is &gt;= the id of @new_hook</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="new_hook" transfer-ownership="none">
            <doc xml:space="preserve">a #GHook</doc>
            <type name="Hook" c:type="GHook*"/>
          </instance-parameter>
          <parameter name="sibling" transfer-ownership="none">
            <doc xml:space="preserve">a #GHook to compare with @new_hook</doc>
            <type name="Hook" c:type="GHook*"/>
          </parameter>
        </parameters>
      </method>
      <function name="alloc" c:identifier="g_hook_alloc" introspectable="0">
        <doc xml:space="preserve">Allocates space for a #GHook and initializes it.</doc>
        <return-value>
          <doc xml:space="preserve">a new #GHook</doc>
          <type name="Hook" c:type="GHook*"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
        </parameters>
      </function>
      <function name="destroy" c:identifier="g_hook_destroy">
        <doc xml:space="preserve">Destroys a #GHook, given its ID.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the #GHook was found in the #GHookList and destroyed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="hook_id" transfer-ownership="none">
            <doc xml:space="preserve">a hook ID</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </function>
      <function name="destroy_link" c:identifier="g_hook_destroy_link">
        <doc xml:space="preserve">Removes one #GHook from a #GHookList, marking it
inactive and calling g_hook_unref() on it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="hook" transfer-ownership="none">
            <doc xml:space="preserve">the #GHook to remove</doc>
            <type name="Hook" c:type="GHook*"/>
          </parameter>
        </parameters>
      </function>
      <function name="find" c:identifier="g_hook_find" introspectable="0">
        <doc xml:space="preserve">Finds a #GHook in a #GHookList using the given function to
test for a match.</doc>
        <return-value>
          <doc xml:space="preserve">the found #GHook or %NULL if no matching #GHook is found</doc>
          <type name="Hook" c:type="GHook*"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="need_valids" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if #GHook elements which have been destroyed
    should be skipped</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="3">
            <doc xml:space="preserve">the function to call for each #GHook, which should return
    %TRUE when the #GHook has been found</doc>
            <type name="HookFindFunc" c:type="GHookFindFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_data" c:identifier="g_hook_find_data" introspectable="0">
        <doc xml:space="preserve">Finds a #GHook in a #GHookList with the given data.</doc>
        <return-value>
          <doc xml:space="preserve">the #GHook with the given @data or %NULL if no matching
    #GHook is found</doc>
          <type name="Hook" c:type="GHook*"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="need_valids" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if #GHook elements which have been destroyed
    should be skipped</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to find</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_func" c:identifier="g_hook_find_func" introspectable="0">
        <doc xml:space="preserve">Finds a #GHook in a #GHookList with the given function.</doc>
        <return-value>
          <doc xml:space="preserve">the #GHook with the given @func or %NULL if no matching
    #GHook is found</doc>
          <type name="Hook" c:type="GHook*"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="need_valids" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if #GHook elements which have been destroyed
    should be skipped</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the function to find</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_func_data" c:identifier="g_hook_find_func_data" introspectable="0">
        <doc xml:space="preserve">Finds a #GHook in a #GHookList with the given function and data.</doc>
        <return-value>
          <doc xml:space="preserve">the #GHook with the given @func and @data or %NULL if
    no matching #GHook is found</doc>
          <type name="Hook" c:type="GHook*"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="need_valids" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if #GHook elements which have been destroyed
    should be skipped</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="func" transfer-ownership="none">
            <doc xml:space="preserve">the function to find</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to find</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="first_valid" c:identifier="g_hook_first_valid" introspectable="0">
        <doc xml:space="preserve">Returns the first #GHook in a #GHookList which has not been destroyed.
The reference count for the #GHook is incremented, so you must call
g_hook_unref() to restore it when no longer needed. (Or call
g_hook_next_valid() if you are stepping through the #GHookList.)</doc>
        <return-value>
          <doc xml:space="preserve">the first valid #GHook, or %NULL if none are valid</doc>
          <type name="Hook" c:type="GHook*"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="may_be_in_call" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if hooks which are currently running
    (e.g. in another thread) are considered valid. If set to %FALSE,
    these are skipped</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="free" c:identifier="g_hook_free">
        <doc xml:space="preserve">Calls the #GHookList @finalize_hook function if it exists,
and frees the memory allocated for the #GHook.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="hook" transfer-ownership="none">
            <doc xml:space="preserve">the #GHook to free</doc>
            <type name="Hook" c:type="GHook*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get" c:identifier="g_hook_get" introspectable="0">
        <doc xml:space="preserve">Returns the #GHook with the given id, or %NULL if it is not found.</doc>
        <return-value>
          <doc xml:space="preserve">the #GHook with the given id, or %NULL if it is not found</doc>
          <type name="Hook" c:type="GHook*"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="hook_id" transfer-ownership="none">
            <doc xml:space="preserve">a hook id</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert_before" c:identifier="g_hook_insert_before">
        <doc xml:space="preserve">Inserts a #GHook into a #GHookList, before a given #GHook.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="sibling" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GHook to insert the new #GHook before</doc>
            <type name="Hook" c:type="GHook*"/>
          </parameter>
          <parameter name="hook" transfer-ownership="none">
            <doc xml:space="preserve">the #GHook to insert</doc>
            <type name="Hook" c:type="GHook*"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert_sorted" c:identifier="g_hook_insert_sorted">
        <doc xml:space="preserve">Inserts a #GHook into a #GHookList, sorted by the given function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="hook" transfer-ownership="none">
            <doc xml:space="preserve">the #GHook to insert</doc>
            <type name="Hook" c:type="GHook*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">the comparison function used to sort the #GHook elements</doc>
            <type name="HookCompareFunc" c:type="GHookCompareFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="next_valid" c:identifier="g_hook_next_valid" introspectable="0">
        <doc xml:space="preserve">Returns the next #GHook in a #GHookList which has not been destroyed.
The reference count for the #GHook is incremented, so you must call
g_hook_unref() to restore it when no longer needed. (Or continue to call
g_hook_next_valid() until %NULL is returned.)</doc>
        <return-value>
          <doc xml:space="preserve">the next valid #GHook, or %NULL if none are valid</doc>
          <type name="Hook" c:type="GHook*"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="hook" transfer-ownership="none">
            <doc xml:space="preserve">the current #GHook</doc>
            <type name="Hook" c:type="GHook*"/>
          </parameter>
          <parameter name="may_be_in_call" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if hooks which are currently running
    (e.g. in another thread) are considered valid. If set to %FALSE,
    these are skipped</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="prepend" c:identifier="g_hook_prepend">
        <doc xml:space="preserve">Prepends a #GHook on the start of a #GHookList.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="hook" transfer-ownership="none">
            <doc xml:space="preserve">the #GHook to add to the start of @hook_list</doc>
            <type name="Hook" c:type="GHook*"/>
          </parameter>
        </parameters>
      </function>
      <function name="ref" c:identifier="g_hook_ref" introspectable="0">
        <doc xml:space="preserve">Increments the reference count for a #GHook.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the @hook that was passed in (since 2.6)</doc>
          <type name="Hook" c:type="GHook*"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="hook" transfer-ownership="none">
            <doc xml:space="preserve">the #GHook to increment the reference count of</doc>
            <type name="Hook" c:type="GHook*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref" c:identifier="g_hook_unref">
        <doc xml:space="preserve">Decrements the reference count of a #GHook.
If the reference count falls to 0, the #GHook is removed
from the #GHookList and g_hook_free() is called to free it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </parameter>
          <parameter name="hook" transfer-ownership="none">
            <doc xml:space="preserve">the #GHook to unref</doc>
            <type name="Hook" c:type="GHook*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="HookCheckFunc" c:type="GHookCheckFunc">
      <doc xml:space="preserve">Defines the type of a hook function that can be invoked
by g_hook_list_invoke_check().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%FALSE if the #GHook should be destroyed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data field of the #GHook is passed to the hook function here</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="HookCheckMarshaller" c:type="GHookCheckMarshaller">
      <doc xml:space="preserve">Defines the type of function used by g_hook_list_marshal_check().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%FALSE if @hook should be destroyed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hook" transfer-ownership="none">
          <doc xml:space="preserve">a #GHook</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="HookCompareFunc" c:type="GHookCompareFunc">
      <doc xml:space="preserve">Defines the type of function used to compare #GHook elements in
g_hook_insert_sorted().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a value &lt;= 0 if @new_hook should be before @sibling</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="new_hook" transfer-ownership="none">
          <doc xml:space="preserve">the #GHook being inserted</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
        <parameter name="sibling" transfer-ownership="none">
          <doc xml:space="preserve">the #GHook to compare with @new_hook</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="HookFinalizeFunc" c:type="GHookFinalizeFunc">
      <doc xml:space="preserve">Defines the type of function to be called when a hook in a
list of hooks gets finalized.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hook_list" transfer-ownership="none">
          <doc xml:space="preserve">a #GHookList</doc>
          <type name="HookList" c:type="GHookList*"/>
        </parameter>
        <parameter name="hook" transfer-ownership="none">
          <doc xml:space="preserve">the hook in @hook_list that gets finalized</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="HookFindFunc" c:type="GHookFindFunc">
      <doc xml:space="preserve">Defines the type of the function passed to g_hook_find().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the required #GHook has been found</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hook" transfer-ownership="none">
          <doc xml:space="preserve">a #GHook</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to g_hook_find_func()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="HookFlagMask" c:type="GHookFlagMask">
      <doc xml:space="preserve">Flags used internally in the #GHook implementation.</doc>
      <member name="active" value="1" c:identifier="G_HOOK_FLAG_ACTIVE">
        <doc xml:space="preserve">set if the hook has not been destroyed</doc>
      </member>
      <member name="in_call" value="2" c:identifier="G_HOOK_FLAG_IN_CALL">
        <doc xml:space="preserve">set if the hook is currently being run</doc>
      </member>
      <member name="reserved1" value="4" c:identifier="G_HOOK_FLAG_RESERVED1">
      </member>
    </bitfield>
    <callback name="HookFunc" c:type="GHookFunc">
      <doc xml:space="preserve">Defines the type of a hook function that can be invoked
by g_hook_list_invoke().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data field of the #GHook is passed to the hook function here</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="HookList" c:type="GHookList">
      <doc xml:space="preserve">The #GHookList struct represents a list of hook functions.</doc>
      <field name="seq_id" writable="1">
        <doc xml:space="preserve">the next free #GHook id</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="hook_size" writable="1" bits="16">
        <doc xml:space="preserve">the size of the #GHookList elements, in bytes</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="is_setup" writable="1" bits="1">
        <doc xml:space="preserve">1 if the #GHookList has been initialized</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="hooks" writable="1">
        <doc xml:space="preserve">the first #GHook element in the list</doc>
        <type name="Hook" c:type="GHook*"/>
      </field>
      <field name="dummy3" writable="1">
        <doc xml:space="preserve">unused</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="finalize_hook" writable="1">
        <doc xml:space="preserve">the function to call to finalize a #GHook element.
    The default behaviour is to call the hooks @destroy function</doc>
        <type name="HookFinalizeFunc" c:type="GHookFinalizeFunc"/>
      </field>
      <field name="dummy" writable="1">
        <doc xml:space="preserve">unused</doc>
        <array zero-terminated="0" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="clear" c:identifier="g_hook_list_clear">
        <doc xml:space="preserve">Removes all the #GHook elements from a #GHookList.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_hook_list_init">
        <doc xml:space="preserve">Initializes a #GHookList.
This must be called before the #GHookList is used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </instance-parameter>
          <parameter name="hook_size" transfer-ownership="none">
            <doc xml:space="preserve">the size of each element in the #GHookList,
    typically `sizeof (GHook)`.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="invoke" c:identifier="g_hook_list_invoke">
        <doc xml:space="preserve">Calls all of the #GHook functions in a #GHookList.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </instance-parameter>
          <parameter name="may_recurse" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if functions which are already running
    (e.g. in another thread) can be called. If set to %FALSE,
    these are skipped</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="invoke_check" c:identifier="g_hook_list_invoke_check">
        <doc xml:space="preserve">Calls all of the #GHook functions in a #GHookList.
Any function which returns %FALSE is removed from the #GHookList.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </instance-parameter>
          <parameter name="may_recurse" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if functions which are already running
    (e.g. in another thread) can be called. If set to %FALSE,
    these are skipped</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="marshal" c:identifier="g_hook_list_marshal">
        <doc xml:space="preserve">Calls a function on each valid #GHook.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </instance-parameter>
          <parameter name="may_recurse" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if hooks which are currently running
    (e.g. in another thread) are considered valid. If set to %FALSE,
    these are skipped</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="marshaller" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call for each #GHook</doc>
            <type name="HookMarshaller" c:type="GHookMarshaller"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @marshaller</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="marshal_check" c:identifier="g_hook_list_marshal_check">
        <doc xml:space="preserve">Calls a function on each valid #GHook and destroys it if the
function returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hook_list" transfer-ownership="none">
            <doc xml:space="preserve">a #GHookList</doc>
            <type name="HookList" c:type="GHookList*"/>
          </instance-parameter>
          <parameter name="may_recurse" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if hooks which are currently running
    (e.g. in another thread) are considered valid. If set to %FALSE,
    these are skipped</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="marshaller" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call for each #GHook</doc>
            <type name="HookCheckMarshaller" c:type="GHookCheckMarshaller"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @marshaller</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="HookMarshaller" c:type="GHookMarshaller">
      <doc xml:space="preserve">Defines the type of function used by g_hook_list_marshal().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hook" transfer-ownership="none">
          <doc xml:space="preserve">a #GHook</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="IConv" c:type="GIConv" disguised="1" pointer="1" introspectable="0">
      <doc xml:space="preserve">The GIConv struct wraps an iconv() conversion descriptor. It contains
private data and should only be accessed using the following functions.</doc>
      <method name="" c:identifier="g_iconv" moved-to="iconv" introspectable="0">
        <doc xml:space="preserve">Same as the standard UNIX routine iconv(), but
may be implemented via libiconv on UNIX flavors that lack
a native implementation.

GLib provides g_convert() and g_locale_to_utf8() which are likely
more convenient than the raw iconv wrappers.

Note that the behaviour of iconv() for characters which are valid in the
input character set, but which have no representation in the output character
set, is implementation defined. This function may return success (with a
positive number of non-reversible conversions as replacement characters were
used), or it may return -1 and set an error such as %EILSEQ, in such a
situation.

See [`iconv(3posix)`](man:iconv(3posix)) and [`iconv(3)`](man:iconv(3)) for more details about behavior when an
error occurs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">count of non-reversible conversions, or -1 on error</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="converter" transfer-ownership="none">
            <doc xml:space="preserve">conversion descriptor from g_iconv_open()</doc>
            <type name="IConv" c:type="GIConv"/>
          </instance-parameter>
          <parameter name="inbuf" transfer-ownership="none">
            <doc xml:space="preserve">bytes to convert</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="inbytes_left" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">inout parameter, bytes remaining to convert in @inbuf</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <doc xml:space="preserve">converted output bytes</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="outbytes_left" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">inout parameter, bytes available to fill in @outbuf</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="g_iconv_close" introspectable="0">
        <doc xml:space="preserve">Same as the standard UNIX routine iconv_close(), but
may be implemented via libiconv on UNIX flavors that lack
a native implementation. Should be called to clean up
the conversion descriptor from g_iconv_open() when
you are done converting things.

GLib provides g_convert() and g_locale_to_utf8() which are likely
more convenient than the raw iconv wrappers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 on error, 0 on success</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="converter" transfer-ownership="none">
            <doc xml:space="preserve">a conversion descriptor from g_iconv_open()</doc>
            <type name="IConv" c:type="GIConv"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="open" c:identifier="g_iconv_open" introspectable="0">
        <doc xml:space="preserve">Same as the standard UNIX routine iconv_open(), but
may be implemented via libiconv on UNIX flavors that lack
a native implementation.

GLib provides g_convert() and g_locale_to_utf8() which are likely
more convenient than the raw iconv wrappers.</doc>
        <return-value>
          <doc xml:space="preserve">a "conversion descriptor", or (GIConv)-1 if
 opening the converter failed.</doc>
          <type name="IConv" c:type="GIConv"/>
        </return-value>
        <parameters>
          <parameter name="to_codeset" transfer-ownership="none">
            <doc xml:space="preserve">destination codeset</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="from_codeset" transfer-ownership="none">
            <doc xml:space="preserve">source codeset</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <constant name="IEEE754_DOUBLE_BIAS" value="1023" c:type="G_IEEE754_DOUBLE_BIAS">
      <doc xml:space="preserve">The bias by which exponents in double-precision floats are offset.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="IEEE754_FLOAT_BIAS" value="127" c:type="G_IEEE754_FLOAT_BIAS">
      <doc xml:space="preserve">The bias by which exponents in single-precision floats are offset.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="IOChannel" c:type="GIOChannel" glib:type-name="GIOChannel" glib:get-type="g_io_channel_get_type" c:symbol-prefix="io_channel">
      <doc xml:space="preserve">The `GIOChannel` data type aims to provide a portable method for
using file descriptors, pipes, and sockets, and integrating them
into the main event loop (see [struct@GLib.MainContext]). Currently,
full support is available on UNIX platforms; support for Windows
is only partially complete.

To create a new `GIOChannel` on UNIX systems use
[ctor@GLib.IOChannel.unix_new]. This works for plain file descriptors,
pipes and sockets. Alternatively, a channel can be created for a
file in a system independent manner using [ctor@GLib.IOChannel.new_file].

Once a `GIOChannel` has been created, it can be used in a generic
manner with the functions [method@GLib.IOChannel.read_chars],
[method@GLib.IOChannel.write_chars], [method@GLib.IOChannel.seek_position],
and [method@GLib.IOChannel.shutdown].

To add a `GIOChannel` to the main event loop, use [func@GLib.io_add_watch] or
[func@GLib.io_add_watch_full]. Here you specify which events you are
interested in on the `GIOChannel`, and provide a function to be called
whenever these events occur.

`GIOChannel` instances are created with an initial reference count of 1.
[method@GLib.IOChannel.ref] and [method@GLib.IOChannel.unref] can be used to
increment or decrement the reference count respectively. When the
reference count falls to 0, the `GIOChannel` is freed. (Though it
isn&#x2019;t closed automatically, unless it was created using
[ctor@GLib.IOChannel.new_file].) Using [func@GLib.io_add_watch] or
[func@GLib.io_add_watch_full] increments a channel&#x2019;s reference count.

The new functions [method@GLib.IOChannel.read_chars],
[method@GLib.IOChannel.read_line], [method@GLib.IOChannel.read_line_string],
[method@GLib.IOChannel.read_to_end], [method@GLib.IOChannel.write_chars],
[method@GLib.IOChannel.seek_position], and [method@GLib.IOChannel.flush]
should not be mixed with the deprecated functions
[method@GLib.IOChannel.read], [method@GLib.IOChannel.write], and
[method@GLib.IOChannel.seek] on the same channel.</doc>
      <field name="ref_count" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="funcs" readable="0" private="1">
        <type name="IOFuncs" c:type="GIOFuncs*"/>
      </field>
      <field name="encoding" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="read_cd" introspectable="0" readable="0" private="1">
        <type name="IConv" c:type="GIConv"/>
      </field>
      <field name="write_cd" introspectable="0" readable="0" private="1">
        <type name="IConv" c:type="GIConv"/>
      </field>
      <field name="line_term" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="line_term_len" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="buf_size" readable="0" private="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="read_buf" readable="0" private="1">
        <type name="String" c:type="GString*"/>
      </field>
      <field name="encoded_read_buf" readable="0" private="1">
        <type name="String" c:type="GString*"/>
      </field>
      <field name="write_buf" readable="0" private="1">
        <type name="String" c:type="GString*"/>
      </field>
      <field name="partial_write_buf" readable="0" private="1">
        <array zero-terminated="0" fixed-size="6">
          <type name="gchar" c:type="gchar"/>
        </array>
      </field>
      <field name="use_buffer" readable="0" bits="1" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="do_encode" readable="0" bits="1" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="close_on_unref" readable="0" bits="1" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="is_readable" readable="0" bits="1" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="is_writeable" readable="0" bits="1" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="is_seekable" readable="0" bits="1" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="reserved1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <constructor name="new_file" c:identifier="g_io_channel_new_file" throws="1">
        <doc xml:space="preserve">Open a file @filename as a #GIOChannel using mode @mode. This
channel will be closed when the last reference to it is dropped,
so there is no need to call g_io_channel_close() (though doing
so will not cause problems, as long as no attempt is made to
access the channel after it is closed).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GIOChannel on success, %NULL on failure.</doc>
          <type name="IOChannel" c:type="GIOChannel*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">A string containing the name of a file</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">One of "r", "w", "a", "r+", "w+", "a+". These have
       the same meaning as in fopen()</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="unix_new" c:identifier="g_io_channel_unix_new">
        <doc xml:space="preserve">Creates a new #GIOChannel given a file descriptor. On UNIX systems
this works for plain files, pipes, and sockets.

The returned #GIOChannel has a reference count of 1.

The default encoding for #GIOChannel is UTF-8. If your application
is reading output from a command using via pipe, you may need to set
the encoding to the encoding of the current locale (see
g_get_charset()) with the g_io_channel_set_encoding() function.
By default, the fd passed will not be closed when the final reference
to the #GIOChannel data structure is dropped.

If you want to read raw binary data without interpretation, then
call the g_io_channel_set_encoding() function with %NULL for the
encoding argument.

This function is available in GLib on Windows, too, but you should
avoid using it on Windows. The domain of file descriptors and
sockets overlap. There is no way for GLib to know which one you mean
in case the argument you pass to this function happens to be both a
valid file descriptor and socket. If that happens a warning is
issued, and GLib assumes that it is the file descriptor you mean.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GIOChannel.</doc>
          <type name="IOChannel" c:type="GIOChannel*"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a file descriptor.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="close" c:identifier="g_io_channel_close" deprecated="1" deprecated-version="2.2">
        <doc xml:space="preserve">Close an IO channel. Any pending data to be written will be
flushed, ignoring errors. The channel will not be freed until the
last reference is dropped using g_io_channel_unref().</doc>
        <doc-deprecated xml:space="preserve">Use g_io_channel_shutdown() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">A #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="g_io_channel_flush" throws="1">
        <doc xml:space="preserve">Flushes the write buffer for the GIOChannel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the status of the operation: One of
  %G_IO_STATUS_NORMAL, %G_IO_STATUS_AGAIN, or
  %G_IO_STATUS_ERROR.</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_buffer_condition" c:identifier="g_io_channel_get_buffer_condition">
        <doc xml:space="preserve">This function returns a #GIOCondition depending on whether there
is data to be read/space to write data in the internal buffers in
the #GIOChannel. Only the flags %G_IO_IN and %G_IO_OUT may be set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #GIOCondition</doc>
          <type name="IOCondition" c:type="GIOCondition"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">A #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_buffer_size" c:identifier="g_io_channel_get_buffer_size">
        <doc xml:space="preserve">Gets the buffer size.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the buffer.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_buffered" c:identifier="g_io_channel_get_buffered">
        <doc xml:space="preserve">Returns whether @channel is buffered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @channel is buffered.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_close_on_unref" c:identifier="g_io_channel_get_close_on_unref">
        <doc xml:space="preserve">Returns whether the file/socket/whatever associated with @channel
will be closed when @channel receives its final unref and is
destroyed. The default value of this is %TRUE for channels created
by g_io_channel_new_file (), and %FALSE for all other channels.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the channel will be closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel.</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_encoding" c:identifier="g_io_channel_get_encoding">
        <doc xml:space="preserve">Gets the encoding for the input/output of the channel.
The internal encoding is always UTF-8. The encoding %NULL
makes the channel safe for binary data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A string containing the encoding, this string is
  owned by GLib and must not be freed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_io_channel_get_flags">
        <doc xml:space="preserve">Gets the current flags for a #GIOChannel, including read-only
flags such as %G_IO_FLAG_IS_READABLE.

The values of the flags %G_IO_FLAG_IS_READABLE and %G_IO_FLAG_IS_WRITABLE
are cached for internal use by the channel when it is created.
If they should change at some later point (e.g. partial shutdown
of a socket with the UNIX shutdown() function), the user
should immediately call g_io_channel_get_flags() to update
the internal values of these flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the flags which are set on the channel</doc>
          <type name="IOFlags" c:type="GIOFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_line_term" c:identifier="g_io_channel_get_line_term">
        <doc xml:space="preserve">This returns the string that #GIOChannel uses to determine
where in the file a line break occurs. A value of %NULL
indicates autodetection. Since 2.84, the return value is always
nul-terminated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The line termination string. This value
  is owned by GLib and must not be freed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a location to return the length of the line terminator</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_io_channel_init">
        <doc xml:space="preserve">Initializes a #GIOChannel struct.

This is called by each of the above functions when creating a
#GIOChannel, and so is not often needed by the application
programmer (unless you are creating a new type of #GIOChannel).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="g_io_channel_read" deprecated="1" deprecated-version="2.2">
        <doc xml:space="preserve">Reads data from a #GIOChannel.</doc>
        <doc-deprecated xml:space="preserve">Use g_io_channel_read_chars() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%G_IO_ERROR_NONE if the operation was successful.</doc>
          <type name="IOError" c:type="GIOError"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to read the data into (which should be at least
      count bytes long)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to read from the #GIOChannel</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="bytes_read" transfer-ownership="none">
            <doc xml:space="preserve">returns the number of bytes actually read</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_chars" c:identifier="g_io_channel_read_chars" throws="1">
        <doc xml:space="preserve">Replacement for g_io_channel_read() with the new API.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the status of the operation.</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="buf" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">
    a buffer to read data into</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the size of the buffer. Note that the buffer may not be
    completely filled even if there is data in the buffer if the
    remaining data is not a complete character.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">The number of bytes read. This may be
    zero even on success if count &lt; 6 and the channel's encoding
    is non-%NULL. This indicates that the next UTF-8 character is
    too wide for the buffer.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_line" c:identifier="g_io_channel_read_line" throws="1">
        <doc xml:space="preserve">Reads a line, including the terminating character(s),
from a #GIOChannel into a newly-allocated string.
@str_return will contain allocated memory if the return
is %G_IO_STATUS_NORMAL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the status of the operation.</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="str_return" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The line read from the #GIOChannel, including the
             line terminator. This data should be freed with g_free()
             when no longer needed. This is a nul-terminated string.
             If a @length of zero is returned, this will be %NULL instead.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to store length of the read data, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="terminator_pos" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to store position of line terminator, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_line_string" c:identifier="g_io_channel_read_line_string" throws="1">
        <doc xml:space="preserve">Reads a line from a #GIOChannel, using a #GString as a buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the status of the operation.</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GString into which the line will be written.
         If @buffer already contains data, the old data will
         be overwritten.</doc>
            <type name="String" c:type="GString*"/>
          </parameter>
          <parameter name="terminator_pos" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">location to store position of line terminator, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_to_end" c:identifier="g_io_channel_read_to_end" throws="1">
        <doc xml:space="preserve">Reads all the remaining data from the file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%G_IO_STATUS_NORMAL on success.
    This function never returns %G_IO_STATUS_EOF.</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="str_return" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">Location to
             store a pointer to a string holding the remaining data in the
             #GIOChannel. This data should be freed with g_free() when no
             longer needed. This data is terminated by an extra nul
             character, but there may be other nuls in the intervening data.</doc>
            <array length="1" zero-terminated="0" c:type="gchar**">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store length of the data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_unichar" c:identifier="g_io_channel_read_unichar" throws="1">
        <doc xml:space="preserve">Reads a Unicode character from @channel.
This function cannot be called on a channel with %NULL encoding.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GIOStatus</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="thechar" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a location to return a character</doc>
            <type name="gunichar" c:type="gunichar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_io_channel_ref">
        <doc xml:space="preserve">Increments the reference count of a #GIOChannel.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the @channel that was passed in (since 2.6)</doc>
          <type name="IOChannel" c:type="GIOChannel*"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="seek" c:identifier="g_io_channel_seek" deprecated="1" deprecated-version="2.2">
        <doc xml:space="preserve">Sets the current position in the #GIOChannel, similar to the standard
library function fseek().</doc>
        <doc-deprecated xml:space="preserve">Use g_io_channel_seek_position() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%G_IO_ERROR_NONE if the operation was successful.</doc>
          <type name="IOError" c:type="GIOError"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">an offset, in bytes, which is added to the position specified
         by @type</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the position in the file, which can be %G_SEEK_CUR (the current
       position), %G_SEEK_SET (the start of the file), or %G_SEEK_END
       (the end of the file)</doc>
            <type name="SeekType" c:type="GSeekType"/>
          </parameter>
        </parameters>
      </method>
      <method name="seek_position" c:identifier="g_io_channel_seek_position" throws="1">
        <doc xml:space="preserve">Replacement for g_io_channel_seek() with the new API.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the status of the operation.</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">The offset in bytes from the position specified by @type</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GSeekType. The type %G_SEEK_CUR is only allowed in those
                     cases where a call to g_io_channel_set_encoding ()
                     is allowed. See the documentation for
                     g_io_channel_set_encoding () for details.</doc>
            <type name="SeekType" c:type="GSeekType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffer_size" c:identifier="g_io_channel_set_buffer_size">
        <doc xml:space="preserve">Sets the buffer size.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the size of the buffer, or 0 to let GLib pick a good size</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffered" c:identifier="g_io_channel_set_buffered">
        <doc xml:space="preserve">The buffering state can only be set if the channel's encoding
is %NULL. For any other encoding, the channel must be buffered.

A buffered channel can only be set unbuffered if the channel's
internal buffers have been flushed. Newly created channels or
channels which have returned %G_IO_STATUS_EOF
not require such a flush. For write-only channels, a call to
g_io_channel_flush () is sufficient. For all other channels,
the buffers may be flushed by a call to g_io_channel_seek_position ().
This includes the possibility of seeking with seek type %G_SEEK_CUR
and an offset of zero. Note that this means that socket-based
channels cannot be set unbuffered once they have had data
read from them.

On unbuffered channels, it is safe to mix read and write
calls from the new and old APIs, if this is necessary for
maintaining old code.

The default state of the channel is buffered.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="buffered" transfer-ownership="none">
            <doc xml:space="preserve">whether to set the channel buffered or unbuffered</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_close_on_unref" c:identifier="g_io_channel_set_close_on_unref">
        <doc xml:space="preserve">Whether to close the channel on the final unref of the #GIOChannel
data structure. The default value of this is %TRUE for channels
created by g_io_channel_new_file (), and %FALSE for all other channels.

Setting this flag to %TRUE for a channel you have already closed
can cause problems when the final reference to the #GIOChannel is dropped.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="do_close" transfer-ownership="none">
            <doc xml:space="preserve">Whether to close the channel on the final unref of
           the GIOChannel data structure.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_encoding" c:identifier="g_io_channel_set_encoding" throws="1">
        <doc xml:space="preserve">Sets the encoding for the input/output of the channel.
The internal encoding is always UTF-8. The default encoding
for the external file is UTF-8.

The encoding %NULL is safe to use with binary data.

The encoding can only be set if one of the following conditions
is true:

- The channel was just created, and has not been written to or read from yet.

- The channel is write-only.

- The channel is a file, and the file pointer was just repositioned
  by a call to g_io_channel_seek_position(). (This flushes all the
  internal buffers.)

- The current encoding is %NULL or UTF-8.

- One of the (new API) read functions has just returned %G_IO_STATUS_EOF
  (or, in the case of g_io_channel_read_to_end(), %G_IO_STATUS_NORMAL).

-  One of the functions g_io_channel_read_chars() or
   g_io_channel_read_unichar() has returned %G_IO_STATUS_AGAIN or
   %G_IO_STATUS_ERROR. This may be useful in the case of
   %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
   Returning one of these statuses from g_io_channel_read_line(),
   g_io_channel_read_line_string(), or g_io_channel_read_to_end()
   does not guarantee that the encoding can be changed.

Channels which do not meet one of the above conditions cannot call
g_io_channel_seek_position() with an offset of %G_SEEK_CUR, and, if
they are "seekable", cannot call g_io_channel_write_chars() after
calling one of the API "read" functions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%G_IO_STATUS_NORMAL if the encoding was successfully set</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="encoding" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the encoding type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="g_io_channel_set_flags" throws="1">
        <doc xml:space="preserve">Sets the (writeable) flags in @channel to (@flags &amp; %G_IO_FLAG_SET_MASK).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the status of the operation.</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the flags to set on the IO channel</doc>
            <type name="IOFlags" c:type="GIOFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_line_term" c:identifier="g_io_channel_set_line_term">
        <doc xml:space="preserve">This sets the string that #GIOChannel uses to determine
where in the file a line break occurs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="line_term" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The line termination string. Use %NULL for
            autodetect.  Autodetection breaks on "\n", "\r\n", "\r", "\0",
            and the Unicode paragraph separator. Autodetection should not be
            used for anything other than file-based channels.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">The length of the termination string. If -1 is passed, the
         string is assumed to be nul-terminated. This option allows
         termination strings with embedded nuls.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="shutdown" c:identifier="g_io_channel_shutdown" throws="1">
        <doc xml:space="preserve">Close an IO channel. Any pending data to be written will be
flushed if @flush is %TRUE. The channel will not be freed until the
last reference is dropped using g_io_channel_unref().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the status of the operation.</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="flush" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, flush pending</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="unix_get_fd" c:identifier="g_io_channel_unix_get_fd">
        <doc xml:space="preserve">Returns the file descriptor of the #GIOChannel.

On Windows this function returns the file descriptor or socket of
the #GIOChannel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the file descriptor of the #GIOChannel.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel, created with g_io_channel_unix_new().</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_io_channel_unref">
        <doc xml:space="preserve">Decrements the reference count of a #GIOChannel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="g_io_channel_write" deprecated="1" deprecated-version="2.2">
        <doc xml:space="preserve">Writes data to a #GIOChannel.</doc>
        <doc-deprecated xml:space="preserve">Use g_io_channel_write_chars() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%G_IO_ERROR_NONE if the operation was successful.</doc>
          <type name="IOError" c:type="GIOError"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the buffer containing the data to write</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="bytes_written" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes actually written</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_chars" c:identifier="g_io_channel_write_chars" throws="1">
        <doc xml:space="preserve">Replacement for g_io_channel_write() with the new API.

On seekable channels with encodings other than %NULL or UTF-8, generic
mixing of reading and writing is not allowed. A call to g_io_channel_write_chars ()
may only be made on a channel from which data has been read in the
cases described in the documentation for g_io_channel_set_encoding ().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the status of the operation.</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a buffer to write data from</doc>
            <array zero-terminated="0" c:type="const gchar*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the size of the buffer. If -1, the buffer
        is taken to be a nul-terminated string.</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The number of bytes written. This can be nonzero
                even if the return value is not %G_IO_STATUS_NORMAL.
                If the return value is %G_IO_STATUS_NORMAL and the
                channel is blocking, this will always be equal
                to @count if @count &gt;= 0.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_unichar" c:identifier="g_io_channel_write_unichar" throws="1">
        <doc xml:space="preserve">Writes a Unicode character to @channel.
This function cannot be called on a channel with %NULL encoding.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GIOStatus</doc>
          <type name="IOStatus" c:type="GIOStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="channel" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOChannel</doc>
            <type name="IOChannel" c:type="GIOChannel*"/>
          </instance-parameter>
          <parameter name="thechar" transfer-ownership="none">
            <doc xml:space="preserve">a character</doc>
            <type name="gunichar" c:type="gunichar"/>
          </parameter>
        </parameters>
      </method>
      <function name="error_from_errno" c:identifier="g_io_channel_error_from_errno">
        <doc xml:space="preserve">Converts an `errno` error number to a #GIOChannelError.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GIOChannelError error number, e.g.
     %G_IO_CHANNEL_ERROR_INVAL.</doc>
          <type name="IOChannelError" c:type="GIOChannelError"/>
        </return-value>
        <parameters>
          <parameter name="en" transfer-ownership="none">
            <doc xml:space="preserve">an `errno` error number, e.g. `EINVAL`</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="error_quark" c:identifier="g_io_channel_error_quark">
        <return-value transfer-ownership="none">
          <type name="Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </record>
    <enumeration name="IOChannelError" c:type="GIOChannelError" glib:error-domain="g-io-channel-error-quark">
      <doc xml:space="preserve">Error codes returned by #GIOChannel operations.</doc>
      <member name="fbig" value="0" c:identifier="G_IO_CHANNEL_ERROR_FBIG">
        <doc xml:space="preserve">File too large.</doc>
      </member>
      <member name="inval" value="1" c:identifier="G_IO_CHANNEL_ERROR_INVAL">
        <doc xml:space="preserve">Invalid argument.</doc>
      </member>
      <member name="io" value="2" c:identifier="G_IO_CHANNEL_ERROR_IO">
        <doc xml:space="preserve">IO error.</doc>
      </member>
      <member name="isdir" value="3" c:identifier="G_IO_CHANNEL_ERROR_ISDIR">
        <doc xml:space="preserve">File is a directory.</doc>
      </member>
      <member name="nospc" value="4" c:identifier="G_IO_CHANNEL_ERROR_NOSPC">
        <doc xml:space="preserve">No space left on device.</doc>
      </member>
      <member name="nxio" value="5" c:identifier="G_IO_CHANNEL_ERROR_NXIO">
        <doc xml:space="preserve">No such device or address.</doc>
      </member>
      <member name="overflow" value="6" c:identifier="G_IO_CHANNEL_ERROR_OVERFLOW">
        <doc xml:space="preserve">Value too large for defined datatype.</doc>
      </member>
      <member name="pipe" value="7" c:identifier="G_IO_CHANNEL_ERROR_PIPE">
        <doc xml:space="preserve">Broken pipe.</doc>
      </member>
      <member name="failed" value="8" c:identifier="G_IO_CHANNEL_ERROR_FAILED">
        <doc xml:space="preserve">Some other error.</doc>
      </member>
    </enumeration>
    <bitfield name="IOCondition" glib:type-name="GIOCondition" glib:get-type="g_io_condition_get_type" c:type="GIOCondition">
      <doc xml:space="preserve">A bitwise combination representing a condition to watch for on an
event source.</doc>
      <member name="in" value="1" c:identifier="G_IO_IN" glib:nick="in" glib:name="G_IO_IN">
        <doc xml:space="preserve">There is data to read.</doc>
      </member>
      <member name="out" value="4" c:identifier="G_IO_OUT" glib:nick="out" glib:name="G_IO_OUT">
        <doc xml:space="preserve">Data can be written (without blocking).</doc>
      </member>
      <member name="pri" value="2" c:identifier="G_IO_PRI" glib:nick="pri" glib:name="G_IO_PRI">
        <doc xml:space="preserve">There is urgent data to read.</doc>
      </member>
      <member name="err" value="8" c:identifier="G_IO_ERR" glib:nick="err" glib:name="G_IO_ERR">
        <doc xml:space="preserve">Error condition.</doc>
      </member>
      <member name="hup" value="16" c:identifier="G_IO_HUP" glib:nick="hup" glib:name="G_IO_HUP">
        <doc xml:space="preserve">Hung up (the connection has been broken, usually for
           pipes and sockets).</doc>
      </member>
      <member name="nval" value="32" c:identifier="G_IO_NVAL" glib:nick="nval" glib:name="G_IO_NVAL">
        <doc xml:space="preserve">Invalid request. The file descriptor is not open.</doc>
      </member>
    </bitfield>
    <enumeration name="IOError" c:type="GIOError">
      <doc xml:space="preserve">#GIOError is only used by the deprecated functions
g_io_channel_read(), g_io_channel_write(), and g_io_channel_seek().</doc>
      <member name="none" value="0" c:identifier="G_IO_ERROR_NONE">
        <doc xml:space="preserve">no error</doc>
      </member>
      <member name="again" value="1" c:identifier="G_IO_ERROR_AGAIN">
        <doc xml:space="preserve">an EAGAIN error occurred</doc>
      </member>
      <member name="inval" value="2" c:identifier="G_IO_ERROR_INVAL">
        <doc xml:space="preserve">an EINVAL error occurred</doc>
      </member>
      <member name="unknown" value="3" c:identifier="G_IO_ERROR_UNKNOWN">
        <doc xml:space="preserve">another error occurred</doc>
      </member>
    </enumeration>
    <bitfield name="IOFlags" c:type="GIOFlags">
      <doc xml:space="preserve">Specifies properties of a #GIOChannel. Some of the flags can only be
read with g_io_channel_get_flags(), but not changed with
g_io_channel_set_flags().</doc>
      <member name="none" value="0" c:identifier="G_IO_FLAG_NONE">
        <doc xml:space="preserve">no special flags set. Since: 2.74</doc>
      </member>
      <member name="append" value="1" c:identifier="G_IO_FLAG_APPEND">
        <doc xml:space="preserve">turns on append mode, corresponds to %O_APPEND
    (see the documentation of the UNIX open() syscall)</doc>
      </member>
      <member name="nonblock" value="2" c:identifier="G_IO_FLAG_NONBLOCK">
        <doc xml:space="preserve">turns on nonblocking mode, corresponds to
    %O_NONBLOCK/%O_NDELAY (see the documentation of the UNIX open()
    syscall)</doc>
      </member>
      <member name="is_readable" value="4" c:identifier="G_IO_FLAG_IS_READABLE">
        <doc xml:space="preserve">indicates that the io channel is readable.
    This flag cannot be changed.</doc>
      </member>
      <member name="is_writable" value="8" c:identifier="G_IO_FLAG_IS_WRITABLE">
        <doc xml:space="preserve">indicates that the io channel is writable.
    This flag cannot be changed.</doc>
      </member>
      <member name="is_writeable" value="8" c:identifier="G_IO_FLAG_IS_WRITEABLE">
        <doc xml:space="preserve">a misspelled version of @G_IO_FLAG_IS_WRITABLE
    that existed before the spelling was fixed in GLib 2.30. It is kept
    here for compatibility reasons. Deprecated since 2.30</doc>
      </member>
      <member name="is_seekable" value="16" c:identifier="G_IO_FLAG_IS_SEEKABLE">
        <doc xml:space="preserve">indicates that the io channel is seekable,
    i.e. that g_io_channel_seek_position() can be used on it.
    This flag cannot be changed.</doc>
      </member>
      <member name="mask" value="31" c:identifier="G_IO_FLAG_MASK">
        <doc xml:space="preserve">the mask that specifies all the valid flags.</doc>
      </member>
      <member name="get_mask" value="31" c:identifier="G_IO_FLAG_GET_MASK">
        <doc xml:space="preserve">the mask of the flags that are returned from
    g_io_channel_get_flags()</doc>
      </member>
      <member name="set_mask" value="3" c:identifier="G_IO_FLAG_SET_MASK">
        <doc xml:space="preserve">the mask of the flags that the user can modify
    with g_io_channel_set_flags()</doc>
      </member>
    </bitfield>
    <callback name="IOFunc" c:type="GIOFunc">
      <doc xml:space="preserve">Specifies the type of function passed to g_io_add_watch() or
g_io_add_watch_full(), which is called when the requested condition
on a #GIOChannel is satisfied.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the function should return %FALSE if the event source
         should be removed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">the #GIOChannel event source</doc>
          <type name="IOChannel" c:type="GIOChannel*"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">the condition which has been satisfied</doc>
          <type name="IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data set in g_io_add_watch() or g_io_add_watch_full()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="IOFuncs" c:type="GIOFuncs">
      <doc xml:space="preserve">A table of functions used to handle different types of #GIOChannel
in a generic way.</doc>
      <field name="io_read">
        <doc xml:space="preserve">reads raw bytes from the channel.  This is called from
          various functions such as g_io_channel_read_chars() to
          read raw bytes from the channel.  Encoding and buffering
          issues are dealt with at a higher level.</doc>
        <callback name="io_read" throws="1">
          <return-value transfer-ownership="none">
            <type name="IOStatus" c:type="GIOStatus"/>
          </return-value>
          <parameters>
            <parameter name="channel" transfer-ownership="none">
              <type name="IOChannel" c:type="GIOChannel*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="bytes_read" transfer-ownership="none">
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="io_write">
        <doc xml:space="preserve">writes raw bytes to the channel.  This is called from
           various functions such as g_io_channel_write_chars() to
           write raw bytes to the channel.  Encoding and buffering
           issues are dealt with at a higher level.</doc>
        <callback name="io_write" throws="1">
          <return-value transfer-ownership="none">
            <type name="IOStatus" c:type="GIOStatus"/>
          </return-value>
          <parameters>
            <parameter name="channel" transfer-ownership="none">
              <type name="IOChannel" c:type="GIOChannel*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="bytes_written" transfer-ownership="none">
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="io_seek">
        <doc xml:space="preserve">seeks the channel.  This is called from
          g_io_channel_seek() on channels that support it.</doc>
        <callback name="io_seek" throws="1">
          <return-value transfer-ownership="none">
            <type name="IOStatus" c:type="GIOStatus"/>
          </return-value>
          <parameters>
            <parameter name="channel" transfer-ownership="none">
              <type name="IOChannel" c:type="GIOChannel*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="SeekType" c:type="GSeekType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="io_close">
        <doc xml:space="preserve">closes the channel.  This is called from
           g_io_channel_close() after flushing the buffers.</doc>
        <callback name="io_close" throws="1">
          <return-value transfer-ownership="none">
            <type name="IOStatus" c:type="GIOStatus"/>
          </return-value>
          <parameters>
            <parameter name="channel" transfer-ownership="none">
              <type name="IOChannel" c:type="GIOChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="io_create_watch">
        <doc xml:space="preserve">creates a watch on the channel.  This call
                  corresponds directly to g_io_create_watch().</doc>
        <callback name="io_create_watch">
          <return-value transfer-ownership="full">
            <type name="Source" c:type="GSource*"/>
          </return-value>
          <parameters>
            <parameter name="channel" transfer-ownership="none">
              <type name="IOChannel" c:type="GIOChannel*"/>
            </parameter>
            <parameter name="condition" transfer-ownership="none">
              <type name="IOCondition" c:type="GIOCondition"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="io_free">
        <doc xml:space="preserve">called from g_io_channel_unref() when the channel needs to
          be freed.  This function must free the memory associated
          with the channel, including freeing the #GIOChannel
          structure itself.  The channel buffers have been flushed
          and possibly @io_close has been called by the time this
          function is called.</doc>
        <callback name="io_free">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="channel" transfer-ownership="none">
              <type name="IOChannel" c:type="GIOChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="io_set_flags">
        <doc xml:space="preserve">sets the #GIOFlags on the channel.  This is called
               from g_io_channel_set_flags() with all flags except
               for %G_IO_FLAG_APPEND and %G_IO_FLAG_NONBLOCK masked
               out.</doc>
        <callback name="io_set_flags" throws="1">
          <return-value transfer-ownership="none">
            <type name="IOStatus" c:type="GIOStatus"/>
          </return-value>
          <parameters>
            <parameter name="channel" transfer-ownership="none">
              <type name="IOChannel" c:type="GIOChannel*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="IOFlags" c:type="GIOFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="io_get_flags">
        <doc xml:space="preserve">gets the #GIOFlags for the channel.  This function
               need only return the %G_IO_FLAG_APPEND and
               %G_IO_FLAG_NONBLOCK flags; g_io_channel_get_flags()
               automatically adds the others as appropriate.</doc>
        <callback name="io_get_flags">
          <return-value transfer-ownership="none">
            <type name="IOFlags" c:type="GIOFlags"/>
          </return-value>
          <parameters>
            <parameter name="channel" transfer-ownership="none">
              <type name="IOChannel" c:type="GIOChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="IOStatus" c:type="GIOStatus">
      <doc xml:space="preserve">Statuses returned by most of the #GIOFuncs functions.</doc>
      <member name="error" value="0" c:identifier="G_IO_STATUS_ERROR">
        <doc xml:space="preserve">An error occurred.</doc>
      </member>
      <member name="normal" value="1" c:identifier="G_IO_STATUS_NORMAL">
        <doc xml:space="preserve">Success.</doc>
      </member>
      <member name="eof" value="2" c:identifier="G_IO_STATUS_EOF">
        <doc xml:space="preserve">End of file.</doc>
      </member>
      <member name="again" value="3" c:identifier="G_IO_STATUS_AGAIN">
        <doc xml:space="preserve">Resource temporarily unavailable.</doc>
      </member>
    </enumeration>
    <function-macro name="IS_DIR_SEPARATOR" c:identifier="G_IS_DIR_SEPARATOR" version="2.6" introspectable="0">
      <doc xml:space="preserve">Checks whether a character is a directory separator.

It returns true for `'/'` on UNIX machines and for `'\'` or `'/'` under
Windows.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">a character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="KEY_FILE_DESKTOP_GROUP" value="Desktop Entry" c:type="G_KEY_FILE_DESKTOP_GROUP" version="2.14">
      <doc xml:space="preserve">The name of the main group of a desktop entry file, as defined in the
[Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/).

Consult the specification for more
details about the meanings of the keys below.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_ACTIONS" value="Actions" c:type="G_KEY_FILE_DESKTOP_KEY_ACTIONS" version="2.38">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a string list
giving the available application actions.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_CATEGORIES" value="Categories" c:type="G_KEY_FILE_DESKTOP_KEY_CATEGORIES" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a list
of strings giving the categories in which the desktop entry
should be shown in a menu.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_COMMENT" value="Comment" c:type="G_KEY_FILE_DESKTOP_KEY_COMMENT" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a localized
string giving the tooltip for the desktop entry.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE" value="DBusActivatable" c:type="G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE" version="2.38">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a boolean
set to true if the application is D-Bus activatable.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_EXEC" value="Exec" c:type="G_KEY_FILE_DESKTOP_KEY_EXEC" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a string
giving the command line to execute.

It is only valid for desktop entries with the `Application` type.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_GENERIC_NAME" value="GenericName" c:type="G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a localized
string giving the generic name of the desktop entry.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_HIDDEN" value="Hidden" c:type="G_KEY_FILE_DESKTOP_KEY_HIDDEN" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a boolean
stating whether the desktop entry has been deleted by the user.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_ICON" value="Icon" c:type="G_KEY_FILE_DESKTOP_KEY_ICON" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a localized
string giving the name of the icon to be displayed for the desktop
entry.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_MIME_TYPE" value="MimeType" c:type="G_KEY_FILE_DESKTOP_KEY_MIME_TYPE" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a list
of strings giving the MIME types supported by this desktop entry.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_NAME" value="Name" c:type="G_KEY_FILE_DESKTOP_KEY_NAME" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a localized
string giving the specific name of the desktop entry.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN" value="NotShowIn" c:type="G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a list of
strings identifying the environments that should not display the
desktop entry.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_NO_DISPLAY" value="NoDisplay" c:type="G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a boolean
stating whether the desktop entry should be shown in menus.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN" value="OnlyShowIn" c:type="G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a list of
strings identifying the environments that should display the
desktop entry.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_PATH" value="Path" c:type="G_KEY_FILE_DESKTOP_KEY_PATH" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a string
containing the working directory to run the program in.

It is only valid for desktop entries with the `Application` type.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY" value="StartupNotify" c:type="G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a boolean
stating whether the application supports the
[Startup Notification Protocol Specification](https://specifications.freedesktop.org/startup-notification-spec/latest/).</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS" value="StartupWMClass" c:type="G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is string
identifying the WM class or name hint of a window that the application
will create, which can be used to emulate
[Startup Notification](https://specifications.freedesktop.org/startup-notification-spec/latest/)
with older applications.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_TERMINAL" value="Terminal" c:type="G_KEY_FILE_DESKTOP_KEY_TERMINAL" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a boolean
stating whether the program should be run in a terminal window.

It is only valid for desktop entries with the `Application` type.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_TRY_EXEC" value="TryExec" c:type="G_KEY_FILE_DESKTOP_KEY_TRY_EXEC" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a string
giving the file name of a binary on disk used to determine if the
program is actually installed.

It is only valid for desktop entries with the `Application` type.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_TYPE" value="Type" c:type="G_KEY_FILE_DESKTOP_KEY_TYPE" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a string
giving the type of the desktop entry.

Usually [const@GLib.KEY_FILE_DESKTOP_TYPE_APPLICATION],
[const@GLib.KEY_FILE_DESKTOP_TYPE_LINK], or
[const@GLib.KEY_FILE_DESKTOP_TYPE_DIRECTORY].</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_URL" value="URL" c:type="G_KEY_FILE_DESKTOP_KEY_URL" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a string
giving the URL to access.

It is only valid for desktop entries with the `Link` type.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_KEY_VERSION" value="Version" c:type="G_KEY_FILE_DESKTOP_KEY_VERSION" version="2.14">
      <doc xml:space="preserve">A key under [const@GLib.KEY_FILE_DESKTOP_GROUP], whose value is a string
giving the version of the Desktop Entry Specification used for
the desktop entry file.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_TYPE_APPLICATION" value="Application" c:type="G_KEY_FILE_DESKTOP_TYPE_APPLICATION" version="2.14">
      <doc xml:space="preserve">The value of the [const@GLib.KEY_FILE_DESKTOP_KEY_TYPE], key for desktop
entries representing applications.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_TYPE_DIRECTORY" value="Directory" c:type="G_KEY_FILE_DESKTOP_TYPE_DIRECTORY" version="2.14">
      <doc xml:space="preserve">The value of the [const@GLib.KEY_FILE_DESKTOP_KEY_TYPE], key for desktop
entries representing directories.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="KEY_FILE_DESKTOP_TYPE_LINK" value="Link" c:type="G_KEY_FILE_DESKTOP_TYPE_LINK" version="2.14">
      <doc xml:space="preserve">The value of the [const@GLib.KEY_FILE_DESKTOP_KEY_TYPE], key for desktop
entries representing links to documents.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="KeyFile" c:type="GKeyFile" opaque="1" glib:type-name="GKeyFile" glib:get-type="g_key_file_get_type" c:symbol-prefix="key_file">
      <doc xml:space="preserve">`GKeyFile` parses .ini-like config files.

`GKeyFile` lets you parse, edit or create files containing groups of
key-value pairs, which we call &#x2018;key files&#x2019; for lack of a better name.
Several freedesktop.org specifications use key files. For example, the
[Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/)
and the [Icon Theme Specification](https://specifications.freedesktop.org/icon-theme-spec/latest/).

The syntax of key files is described in detail in the
[Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/),
here is a quick summary: Key files consists of groups of key-value pairs, interspersed
with comments.

```txt
# this is just an example
# there can be comments before the first group

[First Group]

Name=Key File Example\tthis value shows\nescaping

# localized strings are stored in multiple key-value pairs
Welcome=Hello
Welcome[de]=Hallo
Welcome[fr_FR]=Bonjour
Welcome[it]=Ciao

[Another Group]

Numbers=2;20;-200;0

Booleans=true;false;true;true
```

Lines beginning with a `#` and blank lines are considered comments.

Groups are started by a header line containing the group name enclosed
in `[` and `]`, and ended implicitly by the start of the next group or
the end of the file. Each key-value pair must be contained in a group.

Key-value pairs generally have the form `key=value`, with the exception
of localized strings, which have the form `key[locale]=value`, with a
locale identifier of the form `lang_COUNTRY@MODIFIER` where `COUNTRY`
and `MODIFIER` are optional. As a special case, the locale `C` is associated
with the untranslated pair `key=value` (since GLib 2.84). Space before and
after the `=` character is ignored. Newline, tab, carriage return and
backslash characters in value are escaped as `\n`, `\t`, `\r`, and `\\\\`,
respectively. To preserve leading spaces in values, these can also be escaped
as `\s`.

Key files can store strings (possibly with localized variants), integers,
booleans and lists of these. Lists are separated by a separator character,
typically `;` or `,`. To use the list separator character in a value in
a list, it has to be escaped by prefixing it with a backslash.

This syntax is obviously inspired by the .ini files commonly met
on Windows, but there are some important differences:

- .ini files use the `;` character to begin comments,
  key files use the `#` character.

- Key files do not allow for ungrouped keys meaning only
  comments can precede the first group.

- Key files are always encoded in UTF-8.

- Key and Group names are case-sensitive. For example, a group called
  `[GROUP]` is a different from `[group]`.

- .ini files don&#x2019;t have a strongly typed boolean entry type,
   they only have `GetProfileInt()`. In key files, only
   `true` and `false` (in lower case) are allowed.

Note that in contrast to the
[Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/latest/),
groups in key files may contain the same key multiple times; the last entry wins.
Key files may also contain multiple groups with the same name; they are merged
together. Another difference is that keys and group names in key files are not
restricted to ASCII characters.

Here is an example of loading a key file and reading a value:

```c
g_autoptr(GError) error = NULL;
g_autoptr(GKeyFile) key_file = g_key_file_new ();

if (!g_key_file_load_from_file (key_file, "key-file.ini", flags, &amp;error))
  {
    if (!g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT))
      g_warning ("Error loading key file: %s", error-&gt;message);
    return;
  }

g_autofree gchar *val = g_key_file_get_string (key_file, "Group Name", "SomeKey", &amp;error);
if (val == NULL &amp;&amp;
    !g_error_matches (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND))
  {
    g_warning ("Error finding key in key file: %s", error-&gt;message);
    return;
  }
else if (val == NULL)
  {
    // Fall back to a default value.
    val = g_strdup ("default-value");
  }
```

Here is an example of creating and saving a key file:

```c
g_autoptr(GKeyFile) key_file = g_key_file_new ();
const gchar *val = &#x2026;;
g_autoptr(GError) error = NULL;

g_key_file_set_string (key_file, "Group Name", "SomeKey", val);

// Save as a file.
if (!g_key_file_save_to_file (key_file, "key-file.ini", &amp;error))
  {
    g_warning ("Error saving key file: %s", error-&gt;message);
    return;
  }

// Or store to a GBytes for use elsewhere.
gsize data_len;
g_autofree guint8 *data = (guint8 *) g_key_file_to_data (key_file, &amp;data_len, &amp;error);
if (data == NULL)
  {
    g_warning ("Error saving key file: %s", error-&gt;message);
    return;
  }
g_autoptr(GBytes) bytes = g_bytes_new_take (g_steal_pointer (&amp;data), data_len);
```</doc>
      <constructor name="new" c:identifier="g_key_file_new" version="2.6">
        <doc xml:space="preserve">Creates a new empty [struct@GLib.KeyFile] object.

Use [method@GLib.KeyFile.load_from_file],
[method@GLib.KeyFile.load_from_data], [method@GLib.KeyFile.load_from_dirs] or
[method@GLib.KeyFile.load_from_data_dirs] to
read an existing key file.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an empty [struct@GLib.KeyFile].</doc>
          <type name="KeyFile" c:type="GKeyFile*"/>
        </return-value>
      </constructor>
      <method name="free" c:identifier="g_key_file_free" version="2.6" introspectable="0">
        <doc xml:space="preserve">Clears all keys and groups from @key_file, and decreases the
reference count by 1.

If the reference count reaches zero, frees the key file and all its allocated
memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="full">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_boolean" c:identifier="g_key_file_get_boolean" version="2.6" throws="1">
        <doc xml:space="preserve">Returns the value associated with @key under @group_name as a
boolean.

If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
returned. Likewise, if the value associated with @key cannot be interpreted
as a boolean then [error@GLib.KeyFileError.INVALID_VALUE] is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value associated with the key as a boolean,
   or false if the key was not found or could not be parsed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean_list" c:identifier="g_key_file_get_boolean_list" version="2.6" throws="1">
        <doc xml:space="preserve">Returns the values associated with @key under @group_name as
booleans.

If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
returned. Likewise, if the values associated with @key cannot be interpreted
as booleans then [error@GLib.KeyFileError.INVALID_VALUE] is returned.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
   the values associated with the key as a list of booleans, or `NULL` if the
   key was not found or could not be parsed. The returned list of booleans
   should be freed with [func@GLib.free] when no longer needed.</doc>
          <array length="2" zero-terminated="0" c:type="gboolean*">
            <type name="gboolean"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the number of booleans returned</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_comment" c:identifier="g_key_file_get_comment" version="2.6" throws="1">
        <doc xml:space="preserve">Retrieves a comment above @key from @group_name.

If @key is `NULL` then @comment will be read from above
@group_name. If both @key and @group_name are `NULL`, then
@comment will be read from above the first group in the file.

Note that the returned string does not include the `#` comment markers,
but does include any whitespace after them (on each line). It includes
the line breaks between lines, but does not include the final line break.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a comment that should be freed with [func@GLib.free]</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a group name, or `NULL` to get a top-level comment</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a key, or `NULL` to get a group comment</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="g_key_file_get_double" version="2.12" throws="1">
        <doc xml:space="preserve">Returns the value associated with @key under @group_name as a double.

If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
returned. Likewise, if the value associated with @key cannot be interpreted
as a double then [error@GLib.KeyFileError.INVALID_VALUE] is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value associated with the key as a double, or
    `0.0` if the key was not found or could not be parsed.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double_list" c:identifier="g_key_file_get_double_list" version="2.12" throws="1">
        <doc xml:space="preserve">Returns the values associated with @key under @group_name as
doubles.

If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
returned. Likewise, if the values associated with @key cannot be interpreted
as doubles then [error@GLib.KeyFileError.INVALID_VALUE] is returned.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
    the values associated with the key as a list of doubles, or `NULL` if the
    key was not found or could not be parsed. The returned list of doubles
    should be freed with [func@GLib.free] when no longer needed.</doc>
          <array length="2" zero-terminated="0" c:type="gdouble*">
            <type name="gdouble"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the number of doubles returned</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_groups" c:identifier="g_key_file_get_groups" version="2.6">
        <doc xml:space="preserve">Returns all groups in the key file loaded with @key_file.

The array of returned groups will be `NULL`-terminated, so
@length may optionally be `NULL`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated
   `NULL`-terminated array of strings. Use [func@GLib.strfreev] to free it.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the number of returned groups,
   or `NULL` to ignore</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64" c:identifier="g_key_file_get_int64" version="2.26" throws="1">
        <doc xml:space="preserve">Returns the value associated with @key under @group_name as a signed
64-bit integer.

This is similar to [method@GLib.KeyFile.get_integer] but can return
64-bit results without truncation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value associated with the key as a signed 64-bit integer, or
   `0` if the key was not found or could not be parsed.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_integer" c:identifier="g_key_file_get_integer" version="2.6" throws="1">
        <doc xml:space="preserve">Returns the value associated with @key under @group_name as an
integer.

If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
returned. Likewise, if the value associated with @key cannot be interpreted
as an integer, or is out of range for a `gint`, then
[error@GLib.KeyFileError.INVALID_VALUE] is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value associated with the key as an integer, or
    `0` if the key was not found or could not be parsed.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_integer_list" c:identifier="g_key_file_get_integer_list" version="2.6" throws="1">
        <doc xml:space="preserve">Returns the values associated with @key under @group_name as
integers.

If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
returned. Likewise, if the values associated with @key cannot be interpreted
as integers, or are out of range for `gint`, then
[error@GLib.KeyFileError.INVALID_VALUE] is returned.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">
    the values associated with the key as a list of integers, or `NULL` if
    the key was not found or could not be parsed. The returned list of
    integers should be freed with [func@GLib.free] when no longer needed.</doc>
          <array length="2" zero-terminated="0" c:type="gint*">
            <type name="gint"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the number of integers returned</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_keys" c:identifier="g_key_file_get_keys" version="2.6" throws="1">
        <doc xml:space="preserve">Returns all keys for the group name @group_name.

The array of returned keys will be `NULL`-terminated, so @length may
optionally be `NULL`. If the @group_name cannot be found,
[error@GLib.KeyFileError.GROUP_NOT_FOUND] is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated
   `NULL`-terminated array of strings. Use [func@GLib.strfreev] to free it.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the number of keys returned,
   or `NULL` to ignore</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_locale_for_key" c:identifier="g_key_file_get_locale_for_key" version="2.56">
        <doc xml:space="preserve">Returns the actual locale which the result of
[method@GLib.KeyFile.get_locale_string] or
[method@GLib.KeyFile.get_locale_string_list] came from.

If calling [method@GLib.KeyFile.get_locale_string] or
[method@GLib.KeyFile.get_locale_string_list] with exactly the same @key_file,
@group_name, @key and @locale, the result of those functions will
have originally been tagged with the locale that is the result of
this function.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the locale from the file, or `NULL` if the key was not
  found or the entry in the file was was untranslated</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="locale" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a locale identifier or `NULL` to use the current locale</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_locale_string" c:identifier="g_key_file_get_locale_string" version="2.6" throws="1">
        <doc xml:space="preserve">Returns the value associated with @key under @group_name
translated in the given @locale if available.

If @locale is `C` then the untranslated value is returned (since GLib 2.84).

If @locale is `NULL` then the current locale is assumed.

If @locale is to be non-`NULL`, or if the current locale will change over
the lifetime of the [struct@GLib.KeyFile], it must be loaded with
[flags@GLib.KeyFileFlags.KEEP_TRANSLATIONS] in order to load strings for all
locales.

If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
returned. If the value associated
with @key cannot be interpreted or no suitable translation can
be found then the untranslated value is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string or `NULL` if the specified
  key cannot be found.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="locale" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a locale identifier or `NULL` to use the current locale</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_locale_string_list" c:identifier="g_key_file_get_locale_string_list" version="2.6" throws="1">
        <doc xml:space="preserve">Returns the values associated with @key under @group_name
translated in the given @locale if available.

If @locale is `C` then the untranslated value is returned (since GLib 2.84).

If @locale is `NULL` then the current locale is assumed.

If @locale is to be non-`NULL`, or if the current locale will change over
the lifetime of the [struct@GLib.KeyFile], it must be loaded with
[flags@GLib.KeyFileFlags.KEEP_TRANSLATIONS] in order to load strings for all
locales.

If @key cannot be found then [error@GLib.KeyFileError.KEY_NOT_FOUND] is
returned. If the values associated
with @key cannot be interpreted or no suitable translations
can be found then the untranslated values are returned. The
returned array is `NULL`-terminated, so @length may optionally
be `NULL`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
   a newly allocated `NULL`-terminated string array or `NULL` if the key
   isn&#x2019;t found. The string array should be freed with [func@GLib.strfreev].</doc>
          <array length="3" zero-terminated="1" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="locale" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a locale identifier or `NULL` to use the current locale</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the number of returned strings
   or `NULL` to ignore</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_start_group" c:identifier="g_key_file_get_start_group" version="2.6">
        <doc xml:space="preserve">Returns the name of the start group of the file.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The start group of the key file.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="g_key_file_get_string" version="2.6" throws="1">
        <doc xml:space="preserve">Returns the string value associated with @key under @group_name.

Unlike [method@GLib.KeyFile.get_value], this function handles escape
sequences like `\s`.

If the key cannot be found, [error@GLib.KeyFileError.KEY_NOT_FOUND] is
returned. If the @group_name cannot be found,
[error@GLib.KeyFileError.GROUP_NOT_FOUND] is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string or `NULL` if the specified
  key cannot be found.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string_list" c:identifier="g_key_file_get_string_list" version="2.6" throws="1">
        <doc xml:space="preserve">Returns the values associated with @key under @group_name.

If the key cannot be found, [error@GLib.KeyFileError.KEY_NOT_FOUND] is
returned. If the @group_name cannot be found,
[error@GLib.KeyFileError.GROUP_NOT_FOUND] is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
 a `NULL`-terminated string array or `NULL` if the specified
 key cannot be found. The array should be freed with [func@GLib.strfreev].</doc>
          <array length="2" zero-terminated="1" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the number of returned
   strings, or `NULL` to ignore</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64" c:identifier="g_key_file_get_uint64" version="2.26" throws="1">
        <doc xml:space="preserve">Returns the value associated with @key under @group_name as an unsigned
64-bit integer.

This is similar to [method@GLib.KeyFile.get_integer] but can return
large positive results without truncation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value associated with the key as an unsigned 64-bit integer,
   or `0` if the key was not found or could not be parsed.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="g_key_file_get_value" version="2.6" throws="1">
        <doc xml:space="preserve">Returns the raw value associated with @key under @group_name.

Use [method@GLib.KeyFile.get_string] to retrieve an unescaped UTF-8 string.

If the key cannot be found, [error@GLib.KeyFileError.KEY_NOT_FOUND]
is returned.  If the @group_name cannot be found,
[error@GLib.KeyFileError.GROUP_NOT_FOUND] is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string or `NULL` if the specified
 key cannot be found.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_group" c:identifier="g_key_file_has_group" version="2.6">
        <doc xml:space="preserve">Looks whether the key file has the group @group_name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @group_name is a part of @key_file, false otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_key" c:identifier="g_key_file_has_key" version="2.6" introspectable="0" throws="1">
        <doc xml:space="preserve">Looks whether the key file has the key @key in the group
@group_name.

Note that this function does not follow the rules for [struct@GLib.Error]
strictly;
the return value both carries meaning and signals an error.  To use
this function, you must pass a [struct@GLib.Error] pointer in @error, and
check whether it is not `NULL` to see if an error occurred.

Language bindings should use [method@GLib.KeyFile.get_value] to test whether
a key exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @key is a part of @group_name, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_bytes" c:identifier="g_key_file_load_from_bytes" version="2.50" throws="1">
        <doc xml:space="preserve">Loads a key file from the data in @bytes into an empty [struct@GLib.KeyFile]
structure.

If the object cannot be created then a [error@GLib.KeyFileError] is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if a key file could be loaded, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">an empty [struct@GLib.KeyFile] struct</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">a [struct@GLib.Bytes]</doc>
            <type name="Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags from [flags@GLib.KeyFileFlags]</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_data" c:identifier="g_key_file_load_from_data" version="2.6" throws="1">
        <doc xml:space="preserve">Loads a key file from memory into an empty [struct@GLib.KeyFile] structure.

If the object cannot be created then a [error@GLib.KeyFileError is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if a key file could be loaded, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">an empty key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">key file loaded in memory</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @data in bytes (or `(gsize)-1` if data is nul-terminated)</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags from [flags@GLib.KeyFileFlags]</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_data_dirs" c:identifier="g_key_file_load_from_data_dirs" version="2.6" throws="1">
        <doc xml:space="preserve">Looks for a key file named @file in the paths returned from
[func@GLib.get_user_data_dir] and [func@GLib.get_system_data_dirs].

The search algorithm from [method@GLib.KeyFile.load_from_dirs] is used. If
@file is found, it&#x2019;s loaded into @key_file and its full path is returned in
@full_path.

If the file could not be loaded then either a [error@GLib.FileError] or
[error@GLib.KeyFileError] is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if a key file could be loaded, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">an empty [struct@GLib.KeyFile] struct</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a relative path to a filename to open and parse</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="full_path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for a string
   containing the full path of the file, or `NULL` to ignore</doc>
            <type name="filename" c:type="gchar**"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags from [flags@GLib.KeyFileFlags]</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_dirs" c:identifier="g_key_file_load_from_dirs" version="2.14" throws="1">
        <doc xml:space="preserve">Looks for a key file named @file in the paths specified in @search_dirs,
loads the file into @key_file and returns the file&#x2019;s full path in @full_path.

@search_dirs are checked in the order listed in the array, with the highest
priority directory listed first. Within each directory, @file is looked for.
If it&#x2019;s not found, `-` characters in @file are progressively replaced with
directory separators to search subdirectories of the search directory. If the
file has not been found after all `-` characters have been replaced, the next
search directory in @search_dirs is checked.

If the file could not be found in any of the @search_dirs,
[error@GLib.KeyFileError.NOT_FOUND] is returned. If
the file is found but the OS returns an error when opening or reading the
file, a [error@GLib.FileError] is returned. If there is a problem parsing the
file, a [error@GLib.KeyFileError] is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if a key file could be loaded, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">an empty [struct@GLib.KeyFile] struct</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a relative path to a filename to open and parse</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="search_dirs" transfer-ownership="none">
            <doc xml:space="preserve">`NULL`-terminated
   array of directories to search</doc>
            <array c:type="const gchar**">
              <type name="filename"/>
            </array>
          </parameter>
          <parameter name="full_path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for a string
   containing the full path of the file, or `NULL` to ignore</doc>
            <type name="filename" c:type="gchar**"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags from [flags@GLib.KeyFileFlags]</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_from_file" c:identifier="g_key_file_load_from_file" version="2.6" throws="1">
        <doc xml:space="preserve">Loads a key file into an empty [struct@GLib.KeyFile] structure.

If the OS returns an error when opening or reading the file, a
[error@GLib.FileError] is returned. If there is a problem parsing the file,
a [error@GLib.KeyFileError] is returned.

This function will never return a [error@GLib.KeyFileError.NOT_FOUND]
error. If the @file is not found, [error@GLib.FileError.NOENT] is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if a key file could be loaded, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">an empty key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">the path of a filename to load, in the GLib filename encoding</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags from [flags@GLib.KeyFileFlags]</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_key_file_ref" version="2.32" introspectable="0">
        <doc xml:space="preserve">Increases the reference count of @key_file.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the same @key_file.</doc>
          <type name="KeyFile" c:type="GKeyFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_comment" c:identifier="g_key_file_remove_comment" version="2.6" throws="1">
        <doc xml:space="preserve">Removes a comment above @key from @group_name.

If @key is `NULL` then @comment will be removed above @group_name.
If both @key and @group_name are `NULL`, then @comment will
be removed above the first group in the file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if the comment was removed, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a group name, or `NULL` to get a top-level comment</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a key, or `NULL` to get a group comment</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_group" c:identifier="g_key_file_remove_group" version="2.6" throws="1">
        <doc xml:space="preserve">Removes the specified group, @group_name,
from the key file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if the group was removed, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_key" c:identifier="g_key_file_remove_key" version="2.6" throws="1">
        <doc xml:space="preserve">Removes @key in @group_name from the key file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if the key was removed, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key name to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_to_file" c:identifier="g_key_file_save_to_file" version="2.40" throws="1">
        <doc xml:space="preserve">Writes the contents of @key_file to @filename using
[func@GLib.file_set_contents].

If you need stricter guarantees about durability of
the written file than are provided by [func@GLib.file_set_contents], use
[func@GLib.file_set_contents_full] with the return value of
[method@GLib.KeyFile.to_data].

This function can fail for any of the reasons that
[func@GLib.file_set_contents] may fail.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if successful, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the name of the file to write to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boolean" c:identifier="g_key_file_set_boolean" version="2.6">
        <doc xml:space="preserve">Associates a new boolean value with @key under @group_name.

If @key cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">true or false</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boolean_list" c:identifier="g_key_file_set_boolean_list" version="2.6">
        <doc xml:space="preserve">Associates a list of boolean values with @key under @group_name.

If @key cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">an array of boolean values</doc>
            <array length="3" zero-terminated="0" c:type="gboolean*">
              <type name="gboolean" c:type="gboolean"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of @list</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_comment" c:identifier="g_key_file_set_comment" version="2.6" throws="1">
        <doc xml:space="preserve">Places a comment above @key from @group_name.

If @key is `NULL` then @comment will be written above @group_name.
If both @key and @group_name are `NULL`, then @comment will be
written above the first group in the file.

Passing a non-existent @group_name or @key to this function returns
false and populates @error. (In contrast, passing a non-existent
`group_name` or `key` to [method@GLib.KeyFile.set_string]
creates the associated group name and key.)

Note that this function prepends a `#` comment marker to
each line of @comment.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if the comment was written, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a group name, or `NULL` to write a top-level comment</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a key, or `NULL` to write a group comment</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="comment" transfer-ownership="none">
            <doc xml:space="preserve">a comment</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double" c:identifier="g_key_file_set_double" version="2.12">
        <doc xml:space="preserve">Associates a new double value with @key under @group_name.

If @key cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a double value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double_list" c:identifier="g_key_file_set_double_list" version="2.12">
        <doc xml:space="preserve">Associates a list of double values with @key under @group_name.

If @key cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">an array of double values</doc>
            <array length="3" zero-terminated="0" c:type="gdouble*">
              <type name="gdouble" c:type="gdouble"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">number of double values in @list</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int64" c:identifier="g_key_file_set_int64" version="2.26">
        <doc xml:space="preserve">Associates a new integer value with @key under @group_name.

If @key cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an integer value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_integer" c:identifier="g_key_file_set_integer" version="2.6">
        <doc xml:space="preserve">Associates a new integer value with @key under @group_name.

If @key cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an integer value</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_integer_list" c:identifier="g_key_file_set_integer_list" version="2.6">
        <doc xml:space="preserve">Associates a list of integer values with @key under @group_name.

If @key cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">an array of integer values</doc>
            <array length="3" zero-terminated="0" c:type="gint*">
              <type name="gint" c:type="gint"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">number of integer values in @list</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_list_separator" c:identifier="g_key_file_set_list_separator" version="2.6">
        <doc xml:space="preserve">Sets the character which is used to separate values in lists.

Typically `;` or `,` are used as separators. The default list separator
is `;`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="separator" transfer-ownership="none">
            <doc xml:space="preserve">the separator</doc>
            <type name="gchar" c:type="gchar"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_locale_string" c:identifier="g_key_file_set_locale_string" version="2.6">
        <doc xml:space="preserve">Associates a string value for @key and @locale under @group_name.

If the translation for @key cannot be found then it is created.

If @locale is `C` then the untranslated value is set (since GLib 2.84).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="locale" transfer-ownership="none">
            <doc xml:space="preserve">a locale identifier</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_locale_string_list" c:identifier="g_key_file_set_locale_string_list" version="2.6">
        <doc xml:space="preserve">Associates a list of string values for @key and @locale under
@group_name.

If @locale is `C` then the untranslated value is set (since GLib 2.84).

If the translation for @key cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="locale" transfer-ownership="none">
            <doc xml:space="preserve">a locale identifier</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a `NULL`-terminated array of
   locale string values</doc>
            <array length="4" zero-terminated="1" c:type="const gchar* const*">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @list</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="g_key_file_set_string" version="2.6">
        <doc xml:space="preserve">Associates a new string value with @key under @group_name.

If @key cannot be found then it is created.
If @group_name cannot be found then it is created.
Unlike [method@GLib.KeyFile.set_value], this function handles characters
that need escaping, such as newlines.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string_list" c:identifier="g_key_file_set_string_list" version="2.6">
        <doc xml:space="preserve">Associates a list of string values for @key under @group_name.

If @key cannot be found then it is created.
If @group_name cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">an array
   of string values</doc>
            <array length="3" zero-terminated="1" c:type="const gchar* const*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">number of string values in @list</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint64" c:identifier="g_key_file_set_uint64" version="2.26">
        <doc xml:space="preserve">Associates a new integer value with @key under @group_name.

If @key cannot be found then it is created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an integer value</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="g_key_file_set_value" version="2.6">
        <doc xml:space="preserve">Associates a new value with @key under @group_name.

If @key cannot be found then it is created. If @group_name cannot
be found then it is created. To set an UTF-8 string which may contain
characters that need escaping (such as newlines or spaces), use
[method@GLib.KeyFile.set_string].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none">
            <doc xml:space="preserve">a group name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_data" c:identifier="g_key_file_to_data" version="2.6" throws="1">
        <doc xml:space="preserve">Outputs @key_file as a string.

Note that this function never reports an error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string holding the contents of the key file</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the length of the
  returned string, or `NULL` to ignore</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_key_file_unref" version="2.32">
        <doc xml:space="preserve">Decreases the reference count of @key_file by 1.

If the reference count reaches zero, frees the key file and all its allocated
memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="full">
            <doc xml:space="preserve">a key file</doc>
            <type name="KeyFile" c:type="GKeyFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="error_quark" c:identifier="g_key_file_error_quark">
        <return-value transfer-ownership="none">
          <type name="Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </record>
    <enumeration name="KeyFileError" c:type="GKeyFileError" glib:error-domain="g-key-file-error-quark">
      <doc xml:space="preserve">Error codes returned by key file parsing.</doc>
      <member name="unknown_encoding" value="0" c:identifier="G_KEY_FILE_ERROR_UNKNOWN_ENCODING">
        <doc xml:space="preserve">the text being parsed was in
  an unknown encoding</doc>
      </member>
      <member name="parse" value="1" c:identifier="G_KEY_FILE_ERROR_PARSE">
        <doc xml:space="preserve">document was ill-formed</doc>
      </member>
      <member name="not_found" value="2" c:identifier="G_KEY_FILE_ERROR_NOT_FOUND">
        <doc xml:space="preserve">the file was not found</doc>
      </member>
      <member name="key_not_found" value="3" c:identifier="G_KEY_FILE_ERROR_KEY_NOT_FOUND">
        <doc xml:space="preserve">a requested key was not found</doc>
      </member>
      <member name="group_not_found" value="4" c:identifier="G_KEY_FILE_ERROR_GROUP_NOT_FOUND">
        <doc xml:space="preserve">a requested group was not found</doc>
      </member>
      <member name="invalid_value" value="5" c:identifier="G_KEY_FILE_ERROR_INVALID_VALUE">
        <doc xml:space="preserve">a value could not be parsed</doc>
      </member>
    </enumeration>
    <bitfield name="KeyFileFlags" c:type="GKeyFileFlags">
      <doc xml:space="preserve">Flags which influence the parsing.</doc>
      <member name="none" value="0" c:identifier="G_KEY_FILE_NONE">
        <doc xml:space="preserve">No flags, default behaviour</doc>
      </member>
      <member name="keep_comments" value="1" c:identifier="G_KEY_FILE_KEEP_COMMENTS">
        <doc xml:space="preserve">Use this flag if you plan to write the
  (possibly modified) contents of the key file back to a file;
  otherwise all comments will be lost when the key file is
  written back.</doc>
      </member>
      <member name="keep_translations" value="2" c:identifier="G_KEY_FILE_KEEP_TRANSLATIONS">
        <doc xml:space="preserve">Use this flag if you plan to write the
  (possibly modified) contents of the key file back to a file;
  otherwise only the translations for the current language will be
  written back.</doc>
      </member>
    </bitfield>
    <function-macro name="LIKELY" c:identifier="G_LIKELY" version="2.2" introspectable="0">
      <doc xml:space="preserve">Hints the compiler that the expression is likely to evaluate to
a true value. The compiler may use this information for optimizations.

|[&lt;!-- language="C" --&gt;
if (G_LIKELY (random () != 1))
  g_print ("not one");
]|</doc>
      <parameters>
        <parameter name="expr">
          <doc xml:space="preserve">the expression</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="LITTLE_ENDIAN" value="1234" c:type="G_LITTLE_ENDIAN">
      <doc xml:space="preserve">Specifies one of the possible types of byte order.
See %G_BYTE_ORDER.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="LN10" value="2.302585" c:type="G_LN10">
      <doc xml:space="preserve">The natural logarithm of 10.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="LN2" value="0.693147" c:type="G_LN2">
      <doc xml:space="preserve">The natural logarithm of 2.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <function-macro name="LOCK" c:identifier="G_LOCK" introspectable="0">
      <doc xml:space="preserve">Works like g_mutex_lock(), but for a lock defined with
%G_LOCK_DEFINE.</doc>
      <parameters>
        <parameter name="name">
          <doc xml:space="preserve">the name of the lock</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="LOCK_DEFINE" c:identifier="G_LOCK_DEFINE" introspectable="0">
      <doc xml:space="preserve">The `G_LOCK_` macros provide a convenient interface to #GMutex.
%G_LOCK_DEFINE defines a lock. It can appear in any place where
variable definitions may appear in programs, i.e. in the first block
of a function or outside of functions. The @name parameter will be
mangled to get the name of the #GMutex. This means that you
can use names of existing variables as the parameter - e.g. the name
of the variable you intend to protect with the lock. Look at our
give_me_next_number() example using the `G_LOCK` macros:

Here is an example for using the `G_LOCK` convenience macros:

|[&lt;!-- language="C" --&gt;
  G_LOCK_DEFINE (current_number);

  int
  give_me_next_number (void)
  {
    static int current_number = 0;
    int ret_val;

    G_LOCK (current_number);
    ret_val = current_number = calc_next_number (current_number);
    G_UNLOCK (current_number);

    return ret_val;
  }
]|</doc>
      <parameters>
        <parameter name="name">
          <doc xml:space="preserve">the name of the lock</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="LOCK_DEFINE_STATIC" c:identifier="G_LOCK_DEFINE_STATIC" introspectable="0">
      <doc xml:space="preserve">This works like %G_LOCK_DEFINE, but it creates a static object.</doc>
      <parameters>
        <parameter name="name">
          <doc xml:space="preserve">the name of the lock</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="LOCK_EXTERN" c:identifier="G_LOCK_EXTERN" introspectable="0">
      <doc xml:space="preserve">This declares a lock, that is defined with %G_LOCK_DEFINE in another
module.</doc>
      <parameters>
        <parameter name="name">
          <doc xml:space="preserve">the name of the lock</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="LOCK_NAME" c:identifier="G_LOCK_NAME" introspectable="0">
      <parameters>
        <parameter name="name">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="LOG_2_BASE_10" value="0.301030" c:type="G_LOG_2_BASE_10">
      <doc xml:space="preserve">Multiplying the base 2 exponent by this number yields the base 10 exponent.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="LOG_DOMAIN" value="0" c:type="G_LOG_DOMAIN">
      <doc xml:space="preserve">Defines the log domain. See [Log Domains](#log-domains).

Libraries should define this so that any messages
which they log can be differentiated from messages from other
libraries and application code. But be careful not to define
it in any public header files.

Log domains must be unique, and it is recommended that they are the
application or library name, optionally followed by a hyphen and a sub-domain
name. For example, `bloatpad` or `bloatpad-io`.

If undefined, it defaults to the default %NULL (or `""`) log domain; this is
not advisable, as it cannot be filtered against using the `G_MESSAGES_DEBUG`
environment variable.

For example, GTK uses this in its `Makefile.am`:
|[
AM_CPPFLAGS = -DG_LOG_DOMAIN=\"Gtk\"
]|

Applications can choose to leave it as the default %NULL (or `""`)
domain. However, defining the domain offers the same advantages as
above.</doc>
      <type name="gchar" c:type="gchar"/>
    </constant>
    <constant name="LOG_FATAL_MASK" value="5" c:type="G_LOG_FATAL_MASK">
      <doc xml:space="preserve">GLib log levels that are considered fatal by default.

This is not used if structured logging is enabled; see
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="LOG_LEVEL_USER_SHIFT" value="8" c:type="G_LOG_LEVEL_USER_SHIFT">
      <doc xml:space="preserve">Log levels below `1&lt;&lt;G_LOG_LEVEL_USER_SHIFT` are used by GLib.
Higher bits can be used for user-defined log levels.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="List" c:type="GList">
      <doc xml:space="preserve">The #GList struct is used for each element in a doubly-linked list.</doc>
      <field name="data" writable="1">
        <doc xml:space="preserve">holds the element's data, which can be a pointer to any kind
       of data, or any integer value using the
       [Type Conversion Macros](conversion-macros.html#conversion-macros)</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="next" writable="1">
        <doc xml:space="preserve">contains the link to the next element in the list</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="prev" writable="1">
        <doc xml:space="preserve">contains the link to the previous element in the list</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <function name="alloc" c:identifier="g_list_alloc" introspectable="0">
        <doc xml:space="preserve">Allocates space for one #GList element. It is called by
g_list_append(), g_list_prepend(), g_list_insert() and
g_list_insert_sorted() and so is rarely used on its own.</doc>
        <return-value>
          <doc xml:space="preserve">a pointer to the newly-allocated #GList element</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
      </function>
      <function name="append" c:identifier="g_list_append" introspectable="0">
        <doc xml:space="preserve">Adds a new element on to the end of the list.

Note that the return value is the new start of the list,
if @list was empty; make sure you store the new value.

g_list_append() has to traverse the entire list to find the end,
which is inefficient when adding multiple elements. A common idiom
to avoid the inefficiency is to use g_list_prepend() and reverse
the list with g_list_reverse() when all elements have been added.

|[&lt;!-- language="C" --&gt;
// Notice that these are initialized to the empty list.
GList *string_list = NULL, *number_list = NULL;

// This is a list of strings.
string_list = g_list_append (string_list, "first");
string_list = g_list_append (string_list, "second");

// This is a list of integers.
number_list = g_list_append (number_list, GINT_TO_POINTER (27));
number_list = g_list_append (number_list, GINT_TO_POINTER (14));
]|</doc>
        <return-value>
          <doc xml:space="preserve">either @list or the new start of the #GList if @list was %NULL</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to a #GList</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="concat" c:identifier="g_list_concat" introspectable="0">
        <doc xml:space="preserve">Adds the second #GList onto the end of the first #GList.
Note that the elements of the second #GList are not copied.
They are used directly.

This function is for example used to move an element in the list.
The following example moves an element to the top of the list:
|[&lt;!-- language="C" --&gt;
list = g_list_remove_link (list, llink);
list = g_list_concat (llink, list);
]|</doc>
        <return-value>
          <doc xml:space="preserve">the start of the new #GList, which equals @list1 if not %NULL</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list1" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="list2" transfer-ownership="none">
            <doc xml:space="preserve">the #GList to add to the end of the first #GList,
    this must point  to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="copy" c:identifier="g_list_copy" introspectable="0">
        <doc xml:space="preserve">Copies a #GList.

Note that this is a "shallow" copy. If the list elements
consist of pointers to data, the pointers are copied but
the actual data is not. See g_list_copy_deep() if you need
to copy the data as well.</doc>
        <return-value>
          <doc xml:space="preserve">the start of the new list that holds the same data as @list</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="copy_deep" c:identifier="g_list_copy_deep" version="2.34" introspectable="0">
        <doc xml:space="preserve">Makes a full (deep) copy of a #GList.

In contrast with g_list_copy(), this function uses @func to make
a copy of each list element, in addition to copying the list
container itself.

@func, as a #GCopyFunc, takes two arguments, the data to be copied
and a @user_data pointer. On common processor architectures, it's safe to
pass %NULL as @user_data if the copy function takes only one argument. You
may get compiler warnings from this though if compiling with GCC&#x2019;s
`-Wcast-function-type` warning.

For instance, if @list holds a list of GObjects, you can do:
|[&lt;!-- language="C" --&gt;
another_list = g_list_copy_deep (list, (GCopyFunc) g_object_ref, NULL);
]|

And, to entirely free the new list, you could do:
|[&lt;!-- language="C" --&gt;
g_list_free_full (another_list, g_object_unref);
]|</doc>
        <return-value>
          <doc xml:space="preserve">the start of the new list that holds a full copy of @list,
    use g_list_free_full() to free it</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">a copy function used to copy every element in the list</doc>
            <type name="CopyFunc" c:type="GCopyFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to the copy function @func, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="delete_link" c:identifier="g_list_delete_link" introspectable="0">
        <doc xml:space="preserve">Removes the node link_ from the list and frees it.
Compare this to g_list_remove_link() which removes the node
without freeing it.</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">node to delete from @list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="find" c:identifier="g_list_find" introspectable="0">
        <doc xml:space="preserve">Finds the element in a #GList which contains the given data.</doc>
        <return-value>
          <doc xml:space="preserve">the found #GList element, or %NULL if it is not found</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the element data to find</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_custom" c:identifier="g_list_find_custom" introspectable="0">
        <doc xml:space="preserve">Finds an element in a #GList, using a supplied function to
find the desired element. It iterates over the list, calling
the given function which should return 0 when the desired
element is found. The function takes two #gconstpointer arguments,
the #GList element's data as the first argument and the
given user data.</doc>
        <return-value>
          <doc xml:space="preserve">the found #GList element, or %NULL if it is not found</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to the function</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">the function to call for each element.
    It should return 0 when the desired element is found</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="first" c:identifier="g_list_first" introspectable="0">
        <doc xml:space="preserve">Gets the first element in a #GList.</doc>
        <return-value>
          <doc xml:space="preserve">the first element in the #GList,
    or %NULL if the #GList has no elements</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">any #GList element</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="foreach" c:identifier="g_list_foreach" introspectable="0">
        <doc xml:space="preserve">Calls a function for each element of a #GList.

It is safe for @func to remove the element from @list, but it must
not modify any part of the list after that element.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call with each element's data</doc>
            <type name="Func" c:type="GFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="free" c:identifier="g_list_free" introspectable="0">
        <doc xml:space="preserve">Frees all of the memory used by a #GList.
The freed elements are returned to the slice allocator.

If list elements contain dynamically-allocated memory, you should
either use g_list_free_full() or free them manually first.

It can be combined with g_steal_pointer() to ensure the list head pointer
is not left dangling:
|[&lt;!-- language="C" --&gt;
GList *list_of_borrowed_things = &#x2026;;  /&lt;!-- --&gt;* (transfer container) *&lt;!-- --&gt;/
g_list_free (g_steal_pointer (&amp;list_of_borrowed_things));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">the first link of a #GList</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free_1" c:identifier="g_list_free_1" introspectable="0">
        <doc xml:space="preserve">Frees one #GList element, but does not update links from the next and
previous elements in the list, so you should not call this function on an
element that is currently part of a list.

It is usually used after g_list_remove_link().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList element</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free_full" c:identifier="g_list_free_full" version="2.28" introspectable="0">
        <doc xml:space="preserve">Convenience method, which frees all the memory used by a #GList,
and calls @free_func on every element's data.

@free_func must not modify the list (eg, by removing the freed
element from it).

It can be combined with g_steal_pointer() to ensure the list head pointer
is not left dangling &#xAD;&#x2014; this also has the nice property that the head pointer
is cleared before any of the list elements are freed, to prevent double frees
from @free_func:
|[&lt;!-- language="C" --&gt;
GList *list_of_owned_things = &#x2026;;  /&lt;!-- --&gt;* (transfer full) (element-type GObject) *&lt;!-- --&gt;/
g_list_free_full (g_steal_pointer (&amp;list_of_owned_things), g_object_unref);
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">the first link of a #GList</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="free_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">the function to be called to free each element's data</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="index" c:identifier="g_list_index" introspectable="0">
        <doc xml:space="preserve">Gets the position of the element containing
the given data (starting from 0).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the index of the element containing the data,
    or -1 if the data is not found</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to find</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert" c:identifier="g_list_insert" introspectable="0">
        <doc xml:space="preserve">Inserts a new element into the list at the given position.</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position to insert the element. If this is
    negative, or is larger than the number of elements in the
    list, the new element is added on to the end of the list.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert_before" c:identifier="g_list_insert_before" introspectable="0">
        <doc xml:space="preserve">Inserts a new element into the list before the given position.</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="sibling" transfer-ownership="none">
            <doc xml:space="preserve">the list element before which the new element
    is inserted or %NULL to insert at the end of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert_before_link" c:identifier="g_list_insert_before_link" version="2.62" introspectable="0">
        <doc xml:space="preserve">Inserts @link_ into the list before the given position.</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="sibling" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the list element before which the new element
    is inserted or %NULL to insert at the end of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">the list element to be added, which must not be part of
    any other list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="insert_sorted" c:identifier="g_list_insert_sorted" introspectable="0">
        <doc xml:space="preserve">Inserts a new element into the list, using the given comparison
function to determine its position.

If you are adding many new elements to a list, and the number of
new elements is much larger than the length of the list, use
g_list_prepend() to add the new items and sort the list afterwards
with g_list_sort().</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #GList, this must point to the top of the
    already sorted list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">the function to compare elements in the list. It should
    return a number &gt; 0 if the first parameter comes after the
    second parameter in the sort order.</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert_sorted_with_data" c:identifier="g_list_insert_sorted_with_data" version="2.10" introspectable="0">
        <doc xml:space="preserve">Inserts a new element into the list, using the given comparison
function to determine its position.

If you are adding many new elements to a list, and the number of
new elements is much larger than the length of the list, use
g_list_prepend() to add the new items and sort the list afterwards
with g_list_sort().</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #GList, this must point to the top of the
    already sorted list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="3">
            <doc xml:space="preserve">the function to compare elements in the list. It should
    return a number &gt; 0 if the first parameter  comes after the
    second parameter in the sort order.</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to comparison function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="last" c:identifier="g_list_last" introspectable="0">
        <doc xml:space="preserve">Gets the last element in a #GList.</doc>
        <return-value>
          <doc xml:space="preserve">the last element in the #GList,
    or %NULL if the #GList has no elements</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">any #GList element</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="length" c:identifier="g_list_length" introspectable="0">
        <doc xml:space="preserve">Gets the number of elements in a #GList.

This function iterates over the whole list to count its elements.
Use a #GQueue instead of a GList if you regularly need the number
of items. To check whether the list is non-empty, it is faster to check
@list against %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of elements in the #GList</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="nth" c:identifier="g_list_nth" introspectable="0">
        <doc xml:space="preserve">Gets the element at the given position in a #GList.

This iterates over the list until it reaches the @n-th position. If you
intend to iterate over every element, it is better to use a for-loop as
described in the #GList introduction.</doc>
        <return-value>
          <doc xml:space="preserve">the element, or %NULL if the position is off
    the end of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the position of the element, counting from 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="nth_data" c:identifier="g_list_nth_data" introspectable="0">
        <doc xml:space="preserve">Gets the data of the element at the given position.

This iterates over the list until it reaches the @n-th position. If you
intend to iterate over every element, it is better to use a for-loop as
described in the #GList introduction.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the element's data, or %NULL if the position
    is off the end of the #GList</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the position of the element</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="nth_prev" c:identifier="g_list_nth_prev" introspectable="0">
        <doc xml:space="preserve">Gets the element @n places before @list.</doc>
        <return-value>
          <doc xml:space="preserve">the element, or %NULL if the position is
    off the end of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the position of the element, counting from 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="pop_allocator" c:identifier="g_list_pop_allocator" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="position" c:identifier="g_list_position" introspectable="0">
        <doc xml:space="preserve">Gets the position of the given element
in the #GList (starting from 0).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the position of the element in the #GList,
    or -1 if the element is not found</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="llink" transfer-ownership="none">
            <doc xml:space="preserve">an element in the #GList</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="prepend" c:identifier="g_list_prepend" introspectable="0">
        <doc xml:space="preserve">Prepends a new element on to the start of the list.

Note that the return value is the new start of the list,
which will have changed, so make sure you store the new value.

|[&lt;!-- language="C" --&gt;
// Notice that it is initialized to the empty list.
GList *list = NULL;

list = g_list_prepend (list, "last");
list = g_list_prepend (list, "first");
]|

Do not use this function to prepend a new element to a different
element than the start of the list. Use g_list_insert_before() instead.</doc>
        <return-value>
          <doc xml:space="preserve">a pointer to the newly prepended element, which is the new
    start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="push_allocator" c:identifier="g_list_push_allocator" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="allocator" transfer-ownership="none">
            <type name="Allocator" c:type="GAllocator*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove" c:identifier="g_list_remove" introspectable="0">
        <doc xml:space="preserve">Removes an element from a #GList.
If two elements contain the same data, only the first is removed.
If none of the elements contain the data, the #GList is unchanged.</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data of the element to remove</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_all" c:identifier="g_list_remove_all" introspectable="0">
        <doc xml:space="preserve">Removes all list nodes with data equal to @data.
Returns the new head of the list. Contrast with
g_list_remove() which removes only the first node
matching the given data.</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to remove</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_link" c:identifier="g_list_remove_link" introspectable="0">
        <doc xml:space="preserve">Removes an element from a #GList, without freeing the element.
The removed element's prev and next links are set to %NULL, so
that it becomes a self-contained list with one element.

This function is for example used to move an element in the list
(see the example for g_list_concat()) or to remove an element in
the list before freeing its data:
|[&lt;!-- language="C" --&gt;
list = g_list_remove_link (list, llink);
free_some_data_that_may_access_the_list_again (llink-&gt;data);
g_list_free (llink);
]|</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="llink" transfer-ownership="none">
            <doc xml:space="preserve">an element in the #GList</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="reverse" c:identifier="g_list_reverse" introspectable="0">
        <doc xml:space="preserve">Reverses a #GList.
It simply switches the next and prev pointers of each element.</doc>
        <return-value>
          <doc xml:space="preserve">the start of the reversed #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="sort" c:identifier="g_list_sort" introspectable="0">
        <doc xml:space="preserve">Sorts a #GList using the given comparison function. The algorithm
used is a stable sort.</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">the comparison function used to sort the #GList.
    This function is passed the data from 2 elements of the #GList
    and should return 0 if they are equal, a negative value if the
    first element comes before the second, or a positive value if
    the first element comes after the second.</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort_with_data" c:identifier="g_list_sort_with_data" introspectable="0">
        <doc xml:space="preserve">Like g_list_sort(), but the comparison function accepts
a user data argument.</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GList</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GList, this must point to the top of the list</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to comparison function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="LogField" c:type="GLogField" version="2.50">
      <doc xml:space="preserve">Structure representing a single field in a structured log entry. See
g_log_structured() for details.

Log fields may contain arbitrary values, including binary with embedded nul
bytes. If the field contains a string, the string must be UTF-8 encoded and
have a trailing nul byte. Otherwise, @length must be set to a non-negative
value.</doc>
      <field name="key" writable="1">
        <doc xml:space="preserve">field name (UTF-8 string)</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="value" writable="1">
        <doc xml:space="preserve">field value (arbitrary bytes)</doc>
        <type name="gpointer" c:type="gconstpointer"/>
      </field>
      <field name="length" writable="1">
        <doc xml:space="preserve">length of @value, in bytes, or -1 if it is nul-terminated</doc>
        <type name="gssize" c:type="gssize"/>
      </field>
    </record>
    <callback name="LogFunc" c:type="GLogFunc">
      <doc xml:space="preserve">Specifies the prototype of log handler functions.

The default log handler, [func@GLib.log_default_handler], automatically appends a
new-line character to @message when printing it. It is advised that any
custom log handler functions behave similarly, so that logging calls in user
code do not need modifying to add a new-line character to the message if the
log handler is changed.

The `log_domain` parameter can be set to `NULL` or an empty string to use the default
application domain.

This is not used if structured logging is enabled; see
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the log domain of the message</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">the log level of the message (including the
  fatal and recursion flags)</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">the message to process</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">user data, set in [func@GLib.log_set_handler]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="LogLevelFlags" c:type="GLogLevelFlags">
      <doc xml:space="preserve">Flags specifying the level of log messages.

It is possible to change how GLib treats messages of the various
levels using [func@GLib.log_set_handler] and [func@GLib.log_set_fatal_mask].</doc>
      <member name="flag_recursion" value="1" c:identifier="G_LOG_FLAG_RECURSION">
        <doc xml:space="preserve">internal flag</doc>
      </member>
      <member name="flag_fatal" value="2" c:identifier="G_LOG_FLAG_FATAL">
        <doc xml:space="preserve">internal flag</doc>
      </member>
      <member name="level_error" value="4" c:identifier="G_LOG_LEVEL_ERROR">
        <doc xml:space="preserve">log level for errors, see [func@GLib.error].
  This level is also used for messages produced by [func@GLib.assert].</doc>
      </member>
      <member name="level_critical" value="8" c:identifier="G_LOG_LEVEL_CRITICAL">
        <doc xml:space="preserve">log level for critical warning messages, see
  [func@GLib.critical]. This level is also used for messages produced by
  [func@GLib.return_if_fail] and [func@GLib.return_val_if_fail].</doc>
      </member>
      <member name="level_warning" value="16" c:identifier="G_LOG_LEVEL_WARNING">
        <doc xml:space="preserve">log level for warnings, see [func@GLib.warning]</doc>
      </member>
      <member name="level_message" value="32" c:identifier="G_LOG_LEVEL_MESSAGE">
        <doc xml:space="preserve">log level for messages, see [func@GLib.message]</doc>
      </member>
      <member name="level_info" value="64" c:identifier="G_LOG_LEVEL_INFO">
        <doc xml:space="preserve">log level for informational messages, see [func@GLib.info]</doc>
      </member>
      <member name="level_debug" value="128" c:identifier="G_LOG_LEVEL_DEBUG">
        <doc xml:space="preserve">log level for debug messages, see [func@GLib.debug]</doc>
      </member>
      <member name="level_mask" value="-4" c:identifier="G_LOG_LEVEL_MASK">
        <doc xml:space="preserve">a mask including all log levels</doc>
      </member>
    </bitfield>
    <callback name="LogWriterFunc" c:type="GLogWriterFunc" version="2.50">
      <doc xml:space="preserve">Writer function for log entries. A log entry is a collection of one or more
#GLogFields, using the standard [field names from journal
specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).
See g_log_structured() for more information.

Writer functions must ignore fields which they do not recognise, unless they
can write arbitrary binary output, as field values may be arbitrary binary.

@log_level is guaranteed to be included in @fields as the `PRIORITY` field,
but is provided separately for convenience of deciding whether or where to
output the log entry.

Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log
message successfully or if they deliberately ignored it. If there was an
error handling the message (for example, if the writer function is meant to
send messages to a remote logging server and there is a network error), it
should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be
chained and fall back to simpler handlers in case of failure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%G_LOG_WRITER_HANDLED if the log entry was handled successfully;
  %G_LOG_WRITER_UNHANDLED otherwise</doc>
        <type name="LogWriterOutput" c:type="GLogWriterOutput"/>
      </return-value>
      <parameters>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">log level of the message</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="fields" transfer-ownership="none">
          <doc xml:space="preserve">fields forming the message</doc>
          <array length="2" zero-terminated="0" c:type="const GLogField*">
            <type name="LogField" c:type="GLogField"/>
          </array>
        </parameter>
        <parameter name="n_fields" transfer-ownership="none">
          <doc xml:space="preserve">number of @fields</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">user data passed to g_log_set_writer_func()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="LogWriterOutput" version="2.50" c:type="GLogWriterOutput">
      <doc xml:space="preserve">Return values from #GLogWriterFuncs to indicate whether the given log entry
was successfully handled by the writer, or whether there was an error in
handling it (and hence a fallback writer should be used).

If a #GLogWriterFunc ignores a log entry, it should return
%G_LOG_WRITER_HANDLED.</doc>
      <member name="handled" value="1" c:identifier="G_LOG_WRITER_HANDLED">
        <doc xml:space="preserve">Log writer has handled the log entry.</doc>
      </member>
      <member name="unhandled" value="0" c:identifier="G_LOG_WRITER_UNHANDLED">
        <doc xml:space="preserve">Log writer could not handle the log entry.</doc>
      </member>
    </enumeration>
    <constant name="MAJOR_VERSION" value="2" c:type="GLIB_MAJOR_VERSION">
      <doc xml:space="preserve">The major version number of the GLib library.

Like #glib_major_version, but from the headers used at
application compile time, rather than from the library
linked against at application run time.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MAXINT16" value="32767" c:type="G_MAXINT16">
      <type name="gint16" c:type="gint16"/>
    </constant>
    <constant name="MAXINT32" value="2147483647" c:type="G_MAXINT32">
      <type name="gint32" c:type="gint32"/>
    </constant>
    <constant name="MAXINT64" value="9223372036854775807" c:type="G_MAXINT64">
      <type name="gint64" c:type="gint64"/>
    </constant>
    <constant name="MAXINT8" value="127" c:type="G_MAXINT8">
      <type name="gint8" c:type="gint8"/>
    </constant>
    <constant name="MAXUINT16" value="65535" c:type="G_MAXUINT16">
      <type name="guint16" c:type="guint16"/>
    </constant>
    <constant name="MAXUINT32" value="4294967295" c:type="G_MAXUINT32">
      <type name="guint32" c:type="guint32"/>
    </constant>
    <constant name="MAXUINT64" value="18446744073709551615" c:type="G_MAXUINT64">
      <type name="guint64" c:type="guint64"/>
    </constant>
    <constant name="MAXUINT8" value="255" c:type="G_MAXUINT8">
      <type name="guint8" c:type="guint8"/>
    </constant>
    <constant name="MICRO_VERSION" value="0" c:type="GLIB_MICRO_VERSION">
      <doc xml:space="preserve">The micro version number of the GLib library.

Like #gtk_micro_version, but from the headers used at
application compile time, rather than from the library
linked against at application run time.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MININT16" value="-32768" c:type="G_MININT16" version="2.4">
      <doc xml:space="preserve">The minimum value which can be held in a #gint16.</doc>
      <type name="gint16" c:type="gint16"/>
    </constant>
    <constant name="MININT32" value="-2147483648" c:type="G_MININT32" version="2.4">
      <doc xml:space="preserve">The minimum value which can be held in a #gint32.</doc>
      <type name="gint32" c:type="gint32"/>
    </constant>
    <constant name="MININT64" value="-9223372036854775808" c:type="G_MININT64">
      <doc xml:space="preserve">The minimum value which can be held in a #gint64.</doc>
      <type name="gint64" c:type="gint64"/>
    </constant>
    <constant name="MININT8" value="-128" c:type="G_MININT8" version="2.4">
      <doc xml:space="preserve">The minimum value which can be held in a #gint8.</doc>
      <type name="gint8" c:type="gint8"/>
    </constant>
    <constant name="MINOR_VERSION" value="87" c:type="GLIB_MINOR_VERSION">
      <doc xml:space="preserve">The minor version number of the GLib library.

Like #gtk_minor_version, but from the headers used at
application compile time, rather than from the library
linked against at application run time.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MODULE_SUFFIX" value="so" c:type="G_MODULE_SUFFIX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="MUTEX_AUTO_LOCK" c:identifier="G_MUTEX_AUTO_LOCK" version="2.80.0" introspectable="0">
      <doc xml:space="preserve">Declare a [type@GLib.MutexLocker] variable with `g_autoptr()` and lock the
mutex. The mutex will be unlocked automatically when leaving the scope. The
variable is declared with `G_GNUC_UNUSED` to avoid compiler warning if it is
not used in the scope.

This feature is only supported on GCC and clang. This macro is not defined on
other compilers and should not be used in programs that are intended to be
portable to those compilers.

Note that this should be used in a place where it is allowed to declare a
variable, which could be before any statement in the case
`-Wdeclaration-after-statement` is used, or C standard prior to C99.

```c
{
  G_MUTEX_AUTO_LOCK (&amp;obj-&gt;mutex, locker);

  obj-&gt;stuff_with_lock ();
  if (condition)
    {
      // No need to unlock
      return;
    }

  // Unlock before end of scope
  g_clear_pointer (&amp;locker, g_mutex_locker_free);
  obj-&gt;stuff_without_lock ();
}
```</doc>
      <parameters>
        <parameter name="mutex">
          <doc xml:space="preserve">a [type@GLib.Mutex]</doc>
        </parameter>
        <parameter name="var">
          <doc xml:space="preserve">a variable name to be declared</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="MainContext" c:type="GMainContext" opaque="1" glib:type-name="GMainContext" glib:get-type="g_main_context_get_type" c:symbol-prefix="main_context">
      <doc xml:space="preserve">The `GMainContext` struct is an opaque data
type representing a set of sources to be handled in a main loop.</doc>
      <constructor name="new" c:identifier="g_main_context_new">
        <doc xml:space="preserve">Creates a new [struct@GLib.MainContext] structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new main context</doc>
          <type name="MainContext" c:type="GMainContext*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_flags" c:identifier="g_main_context_new_with_flags" version="2.72">
        <doc xml:space="preserve">Creates a new [struct@GLib.MainContext] structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new main context</doc>
          <type name="MainContext" c:type="GMainContext*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a bitwise-OR combination of flags that can only be set at creation
  time</doc>
            <type name="MainContextFlags" c:type="GMainContextFlags"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="acquire" c:identifier="g_main_context_acquire">
        <doc xml:space="preserve">Tries to become the owner of the specified context.

If some other thread is the owner of the context,
returns false immediately. Ownership is properly
recursive: the owner can require ownership again
and will release ownership when [method@GLib.MainContext.release]
is called as many times as [method@GLib.MainContext.acquire].

You must be the owner of a context before you
can call [method@GLib.MainContext.prepare], [method@GLib.MainContext.query],
[method@GLib.MainContext.check], [method@GLib.MainContext.dispatch],
[method@GLib.MainContext.release].

Since 2.76 @context can be `NULL` to use the global-default
main context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if this thread is now the owner of @context, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="add_poll" c:identifier="g_main_context_add_poll">
        <doc xml:space="preserve">Adds a file descriptor to the set of file descriptors polled for
this context.

This will very seldom be used directly. Instead
a typical event source will use `g_source_add_unix_fd()` instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (or `NULL` for the global-default
  main context)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a [struct@GLib.PollFD] structure holding information about a file
  descriptor to watch.</doc>
            <type name="PollFD" c:type="GPollFD*"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">the priority for this file descriptor which should be
  the same as the priority used for [method@GLib.Source.attach] to ensure
  that the file descriptor is polled whenever the results may be needed.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="check" c:identifier="g_main_context_check">
        <doc xml:space="preserve">Passes the results of polling back to the main loop.

You should be
careful to pass @fds and its length @n_fds as received from
[method@GLib.MainContext.query], as this functions relies on assumptions
on how @fds is filled.

You must have successfully acquired the context with
[method@GLib.MainContext.acquire] before you may call this function.

Since 2.76 @context can be `NULL` to use the global-default
main context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if some sources are ready to be dispatched, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="max_priority" transfer-ownership="none">
            <doc xml:space="preserve">the maximum numerical priority of sources to check</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="fds" transfer-ownership="none">
            <doc xml:space="preserve">array of [struct@GLib.PollFD]s that was passed to
  the last call to [method@GLib.MainContext.query]</doc>
            <array length="2" zero-terminated="0" c:type="GPollFD*">
              <type name="PollFD" c:type="GPollFD"/>
            </array>
          </parameter>
          <parameter name="n_fds" transfer-ownership="none">
            <doc xml:space="preserve">return value of [method@GLib.MainContext.query]</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="dispatch" c:identifier="g_main_context_dispatch">
        <doc xml:space="preserve">Dispatches all pending sources.

You must have successfully acquired the context with
[method@GLib.MainContext.acquire] before you may call this function.

Since 2.76 @context can be `NULL` to use the global-default
main context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="find_source_by_funcs_user_data" c:identifier="g_main_context_find_source_by_funcs_user_data">
        <doc xml:space="preserve">Finds a source with the given source functions and user data.

If multiple sources exist with the same source function and user data,
the first one found will be returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the source, if one was found,
  otherwise `NULL`</doc>
          <type name="Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used).</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="funcs" transfer-ownership="none">
            <doc xml:space="preserve">the @source_funcs passed to [ctor@GLib.Source.new]</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user data from the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_source_by_id" c:identifier="g_main_context_find_source_by_id">
        <doc xml:space="preserve">Finds a [struct@GLib.Source] given a pair of context and ID.

It is a programmer error to attempt to look up a non-existent source.

More specifically: source IDs can be reissued after a source has been
destroyed and therefore it is never valid to use this function with a
source ID which may have already been removed.  An example is when
scheduling an idle to run in another thread with [func@GLib.idle_add]: the
idle may already have run and been removed by the time this function
is called on its (now invalid) source ID.  This source ID may have
been reissued, leading to the operation being performed against the
wrong source.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the source</doc>
          <type name="Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="source_id" transfer-ownership="none">
            <doc xml:space="preserve">the source ID, as returned by [method@GLib.Source.get_id]</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_source_by_user_data" c:identifier="g_main_context_find_source_by_user_data">
        <doc xml:space="preserve">Finds a source with the given user data for the callback.

If multiple sources exist with the same user data, the first
one found will be returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the source, if one was found,
  otherwise `NULL`</doc>
          <type name="Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user_data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_poll_func" c:identifier="g_main_context_get_poll_func" introspectable="0">
        <doc xml:space="preserve">Gets the poll function set by [method@GLib.MainContext.set_poll_func].</doc>
        <return-value>
          <doc xml:space="preserve">the poll function</doc>
          <type name="PollFunc" c:type="GPollFunc"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invoke" c:identifier="g_main_context_invoke" version="2.28" introspectable="0">
        <doc xml:space="preserve">Invokes a function in such a way that @context is owned during the
invocation of @function.

If @context is `NULL` then the global-default main context &#x2014; as
returned by [func@GLib.MainContext.default] &#x2014; is used.

If @context is owned by the current thread, @function is called
directly.  Otherwise, if @context is the thread-default main context
of the current thread and [method@GLib.MainContext.acquire] succeeds,
then @function is called and [method@GLib.MainContext.release] is called
afterwards.

In any other case, an idle source is created to call @function and
that source is attached to @context (presumably to be run in another
thread).  The idle source is attached with [const@GLib.PRIORITY_DEFAULT]
priority.  If you want a different priority, use
[method@GLib.MainContext.invoke_full].

Note that, as with normal idle functions, @function should probably return
[const@GLib.SOURCE_REMOVE].  If it returns [const@GLib.SOURCE_CONTINUE], it
will be continuously run in a loop (and may prevent this call from returning).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context, or `NULL` for the global-default
  main context</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="function" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">function to call</doc>
            <type name="SourceFunc" c:type="GSourceFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="invoke_full" c:identifier="g_main_context_invoke_full" version="2.28">
        <doc xml:space="preserve">Invokes a function in such a way that @context is owned during the
invocation of @function.

This function is the same as [method@GLib.MainContext.invoke] except that it
lets you specify the priority in case @function ends up being
scheduled as an idle and also lets you give a [callback@GLib.DestroyNotify]
for @data.

The @notify function should not assume that it is called from any particular
thread or with any particular context acquired.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context, or `NULL` for the global-default
  main context</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">the priority at which to run @function</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="function" transfer-ownership="none" scope="notified" closure="2" destroy="3">
            <doc xml:space="preserve">function to call</doc>
            <type name="SourceFunc" c:type="GSourceFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to call when @data is no longer in use</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_owner" c:identifier="g_main_context_is_owner" version="2.10">
        <doc xml:space="preserve">Determines whether this thread holds the (recursive)
ownership of this [struct@GLib.MainContext].

This is useful to
know before waiting on another thread that may be
blocking to get ownership of @context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if current thread is owner of @context, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="iteration" c:identifier="g_main_context_iteration">
        <doc xml:space="preserve">Runs a single iteration for the given main loop.

This involves
checking to see if any event sources are ready to be processed,
then if no events sources are ready and @may_block is true, waiting
for a source to become ready, then dispatching the highest priority
events sources that are ready. Otherwise, if @may_block is false,
this function does not wait for sources to become ready, and only the highest
priority sources which are already ready (if any) will be dispatched.

Note that even when @may_block is true, it is still possible for
[method@GLib.MainContext.iteration] to return false, since the wait may
be interrupted for other reasons than an event source becoming ready.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if events were dispatched, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="may_block" transfer-ownership="none">
            <doc xml:space="preserve">whether the call may block</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="pending" c:identifier="g_main_context_pending">
        <doc xml:space="preserve">Checks if any sources have pending events for the given context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if events are pending, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_thread_default" c:identifier="g_main_context_pop_thread_default" version="2.22">
        <doc xml:space="preserve">Pops @context off the thread-default context stack (verifying that
it was on the top of the stack).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context, or `NULL` for the global-default
  main context</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="prepare" c:identifier="g_main_context_prepare">
        <doc xml:space="preserve">Prepares to poll sources within a main loop.

The resulting information
for polling is determined by calling [method@GLib.MainContext.query].

You must have successfully acquired the context with
[method@GLib.MainContext.acquire] before you may call this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if some source is ready to be dispatched prior to polling,
  false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="priority" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to store priority of highest priority
  source already ready</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_thread_default" c:identifier="g_main_context_push_thread_default" version="2.22">
        <doc xml:space="preserve">Acquires @context and sets it as the thread-default context for the
current thread. This will cause certain asynchronous operations
(such as most [Gio](../gio/index.html)-based I/O) which are
started in this thread to run under @context and deliver their
results to its main loop, rather than running under the global
default main context in the main thread. Note that calling this function
changes the context returned by [func@GLib.MainContext.get_thread_default],
not the one returned by [func@GLib.MainContext.default], so it does not
affect the context used by functions like [func@GLib.idle_add].

Normally you would call this function shortly after creating a new
thread, passing it a [struct@GLib.MainContext] which will be run by a
[struct@GLib.MainLoop] in that thread, to set a new default context for all
async operations in that thread. In this case you may not need to
ever call [method@GLib.MainContext.pop_thread_default], assuming you want
the new [struct@GLib.MainContext] to be the default for the whole lifecycle
of the thread.

If you don&#x2019;t have control over how the new thread was created (e.g.
in the new thread isn&#x2019;t newly created, or if the thread life
cycle is managed by a #GThreadPool), it is always suggested to wrap
the logic that needs to use the new [struct@GLib.MainContext] inside a
[method@GLib.MainContext.push_thread_default] /
[method@GLib.MainContext.pop_thread_default] pair, otherwise threads that
are re-used will end up never explicitly releasing the
[struct@GLib.MainContext] reference they hold.

In some cases you may want to schedule a single operation in a
non-default context, or temporarily use a non-default context in
the main thread. In that case, you can wrap the call to the
asynchronous operation inside a
[method@GLib.MainContext.push_thread_default] /
[method@GLib.MainContext.pop_thread_default] pair, but it is up to you to
ensure that no other asynchronous operations accidentally get
started while the non-default context is active.

Beware that libraries that predate this function may not correctly
handle being used from a thread with a thread-default context. For example,
see `g_file_supports_thread_contexts()`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context, or `NULL` for the global-default
  main context</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pusher_new" c:identifier="g_main_context_pusher_new" version="2.64">
        <doc xml:space="preserve">Push @main_context as the new thread-default main context for the current
thread, using [method@GLib.MainContext.push_thread_default], and return a
new [alias@GLib.MainContextPusher]. Pop with g_main_context_pusher_free().
Using [method@GLib.MainContext.pop_thread_default] on @main_context while a
[alias@GLib.MainContextPusher] exists for it can lead to undefined behaviour.

Using two [alias@GLib.MainContextPusher]s in the same scope is not allowed,
as it leads to an undefined pop order.

This is intended to be used with g_autoptr().  Note that g_autoptr()
is only available when using GCC or clang, so the following example
will only work with those compilers:
|[
typedef struct
{
  ...
  GMainContext *context;
  ...
} MyObject;

static void
my_object_do_stuff (MyObject *self)
{
  g_autoptr(GMainContextPusher) pusher = g_main_context_pusher_new (self-&gt;context);

  // Code with main context as the thread default here

  if (cond)
    // No need to pop
    return;

  // Optionally early pop
  g_clear_pointer (&amp;pusher, g_main_context_pusher_free);

  // Code with main context no longer the thread default here
}
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GMainContextPusher</doc>
          <type name="MainContextPusher" c:type="GMainContextPusher*"/>
        </return-value>
        <parameters>
          <instance-parameter name="main_context" transfer-ownership="none">
            <doc xml:space="preserve">a main context to push</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="query" c:identifier="g_main_context_query">
        <doc xml:space="preserve">Determines information necessary to poll this main loop.

You should
be careful to pass the resulting @fds array and its length @n_fds
as-is when calling [method@GLib.MainContext.check], as this function relies
on assumptions made when the array is filled.

You must have successfully acquired the context with
[method@GLib.MainContext.acquire] before you may call this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of records actually stored in @fds,
  or, if more than @n_fds records need to be stored, the number
  of records that need to be stored</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="max_priority" transfer-ownership="none">
            <doc xml:space="preserve">maximum priority source to check</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="timeout_" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store timeout to be used in polling</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="fds" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">location to
  store [struct@GLib.PollFD] records that need to be polled</doc>
            <array length="3" zero-terminated="0" c:type="GPollFD*">
              <type name="PollFD" c:type="GPollFD"/>
            </array>
          </parameter>
          <parameter name="n_fds" transfer-ownership="none">
            <doc xml:space="preserve">length of @fds</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_main_context_ref">
        <doc xml:space="preserve">Increases the reference count on a [struct@GLib.MainContext] object by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the @context that was passed in (since 2.6)</doc>
          <type name="MainContext" c:type="GMainContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a main context</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="release" c:identifier="g_main_context_release">
        <doc xml:space="preserve">Releases ownership of a context previously acquired by this thread
with [method@GLib.MainContext.acquire].

If the context was acquired multiple
times, the ownership will be released only when [method@GLib.MainContext.release]
is called as many times as it was acquired.

You must have successfully acquired the context with
[method@GLib.MainContext.acquire] before you may call this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_poll" c:identifier="g_main_context_remove_poll">
        <doc xml:space="preserve">Removes file descriptor from the set of file descriptors to be
polled for a particular context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a [struct@GLib.PollFD] descriptor previously added with
  [method@GLib.MainContext.add_poll]</doc>
            <type name="PollFD" c:type="GPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_poll_func" c:identifier="g_main_context_set_poll_func" introspectable="0">
        <doc xml:space="preserve">Sets the function to use to handle polling of file descriptors.

It will be used instead of the [`poll()`](man:poll(2)) system call
(or GLib&#x2019;s replacement function, which is used where
`poll()` isn&#x2019;t available).

This function could possibly be used to integrate the GLib event
loop with an external event loop.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none">
            <doc xml:space="preserve">the function to call to poll all file descriptors</doc>
            <type name="PollFunc" c:type="GPollFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_main_context_unref">
        <doc xml:space="preserve">Decreases the reference count on a [struct@GLib.MainContext] object by one.
If
the result is zero, free the context and free all associated memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a main context</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wait" c:identifier="g_main_context_wait" deprecated="1" deprecated-version="2.58">
        <doc xml:space="preserve">Tries to become the owner of the specified context, and waits on @cond if
another thread is the owner.

This is the same as [method@GLib.MainContext.acquire], but if another thread
is the owner, atomically drop @mutex and wait on @cond until
that owner releases ownership or until @cond is signaled, then
try again (once) to become the owner.</doc>
        <doc-deprecated xml:space="preserve">Use [method@GLib.MainContext.is_owner] and separate
   locking instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if this thread is now the owner of @context, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
          <parameter name="cond" transfer-ownership="none">
            <doc xml:space="preserve">a condition variable</doc>
            <type name="Cond" c:type="GCond*"/>
          </parameter>
          <parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a mutex, currently held</doc>
            <type name="Mutex" c:type="GMutex*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wakeup" c:identifier="g_main_context_wakeup">
        <doc xml:space="preserve">Wake up @context if it&#x2019;s currently blocking in
[method@GLib.MainContext.iteration], causing it to stop blocking.

The @context could be blocking waiting for a source to become ready.
Otherwise, if @context is not currently blocking, this function causes the
next invocation of [method@GLib.MainContext.iteration] to return without
blocking.

This API is useful for low-level control over [struct@GLib.MainContext]; for
example, integrating it with main loop implementations such as
[struct@GLib.MainLoop].

Another related use for this function is when implementing a main
loop with a termination condition, computed from multiple threads:

```c
  #define NUM_TASKS 10
  static gint tasks_remaining = NUM_TASKS;  // (atomic)
  ...
 
  while (g_atomic_int_get (&amp;tasks_remaining) != 0)
    g_main_context_iteration (NULL, TRUE);
```
 
Then in a thread:
```c
  perform_work ();

  if (g_atomic_int_dec_and_test (&amp;tasks_remaining))
    g_main_context_wakeup (NULL);
```</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="default" c:identifier="g_main_context_default">
        <doc xml:space="preserve">Returns the global-default main context.

This is the main context
used for main loop functions when a main loop is not explicitly
specified, and corresponds to the &#x2018;main&#x2019; main loop. See also
[func@GLib.MainContext.get_thread_default].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the global-default main context.</doc>
          <type name="MainContext" c:type="GMainContext*"/>
        </return-value>
      </function>
      <function name="get_thread_default" c:identifier="g_main_context_get_thread_default" version="2.22">
        <doc xml:space="preserve">Gets the thread-default main context for this thread.

Asynchronous operations that want to be able to be run in contexts other than
the default one should call this method or
[func@GLib.MainContext.ref_thread_default] to get a
[struct@GLib.MainContext] to add their [struct@GLib.Source]s to. (Note that
even in single-threaded programs applications may sometimes want to
temporarily push a non-default context, so it is not safe to assume that
this will always return `NULL` if you are running in the default thread.)

If you need to hold a reference on the context, use
[func@GLib.MainContext.ref_thread_default] instead.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the thread-default main context, or
  `NULL` if the thread-default context is the global-default main context</doc>
          <type name="MainContext" c:type="GMainContext*"/>
        </return-value>
      </function>
      <function name="pusher_free" c:identifier="g_main_context_pusher_free" version="2.64" introspectable="0">
        <doc xml:space="preserve">Pop @pusher&#x2019;s main context as the thread default main context.
See g_main_context_pusher_new() for details.

This will pop the [struct@GLib.MainContext] as the current thread-default
main context, but will not call [method@GLib.MainContext.unref] on it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pusher" transfer-ownership="full">
            <doc xml:space="preserve">a #GMainContextPusher</doc>
            <type name="MainContextPusher" c:type="GMainContextPusher*"/>
          </parameter>
        </parameters>
      </function>
      <function name="ref_thread_default" c:identifier="g_main_context_ref_thread_default" version="2.32">
        <doc xml:space="preserve">Gets a reference to the thread-default [struct@GLib.MainContext] for this
thread

This is the same as [func@GLib.MainContext.get_thread_default], but it also
adds a reference to the returned main context with [method@GLib.MainContext.ref].
In addition, unlike
[func@GLib.MainContext.get_thread_default], if the thread-default context
is the global-default context, this will return that
[struct@GLib.MainContext] (with a ref added to it) rather than returning
`NULL`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the thread-default main context</doc>
          <type name="MainContext" c:type="GMainContext*"/>
        </return-value>
      </function>
    </record>
    <bitfield name="MainContextFlags" version="2.72" c:type="GMainContextFlags">
      <doc xml:space="preserve">Flags to pass to [ctor@GLib.MainContext.new_with_flags] which affect the
behaviour of a [struct@GLib.MainContext].</doc>
      <member name="none" value="0" c:identifier="G_MAIN_CONTEXT_FLAGS_NONE">
        <doc xml:space="preserve">Default behaviour.</doc>
      </member>
      <member name="ownerless_polling" value="1" c:identifier="G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING">
        <doc xml:space="preserve">Assume that polling for events will
free the thread to process other jobs. That's useful if you're using
`g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in
other event loops.</doc>
      </member>
    </bitfield>
    <record name="MainLoop" c:type="GMainLoop" opaque="1" glib:type-name="GMainLoop" glib:get-type="g_main_loop_get_type" c:symbol-prefix="main_loop">
      <doc xml:space="preserve">The `GMainLoop` struct is an opaque data type
representing the main event loop of a GLib or GTK application.</doc>
      <constructor name="new" c:identifier="g_main_loop_new">
        <doc xml:space="preserve">Creates a new [struct@GLib.MainLoop] structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new main loop</doc>
          <type name="MainLoop" c:type="GMainLoop*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context  (if `NULL`, the global-default
  main context will be used).</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="is_running" transfer-ownership="none">
            <doc xml:space="preserve">set to true to indicate that the loop is running. This
  is not very important since calling [method@GLib.MainLoop.run] will set this
  to true anyway.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_context" c:identifier="g_main_loop_get_context">
        <doc xml:space="preserve">Returns the [struct@GLib.MainContext] of @loop.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the [struct@GLib.MainContext] of @loop</doc>
          <type name="MainContext" c:type="GMainContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none">
            <doc xml:space="preserve">a main loop</doc>
            <type name="MainLoop" c:type="GMainLoop*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_running" c:identifier="g_main_loop_is_running">
        <doc xml:space="preserve">Checks to see if the main loop is currently being run via
[method@GLib.MainLoop.run].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if the main loop is currently being run, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none">
            <doc xml:space="preserve">a main loop</doc>
            <type name="MainLoop" c:type="GMainLoop*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="quit" c:identifier="g_main_loop_quit">
        <doc xml:space="preserve">Stops a [struct@GLib.MainLoop] from running. Any calls to
[method@GLib.MainLoop.run] for the loop will return.

Note that sources that have already been dispatched when
[method@GLib.MainLoop.quit] is called will still be executed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none">
            <doc xml:space="preserve">a main loop</doc>
            <type name="MainLoop" c:type="GMainLoop*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_main_loop_ref">
        <doc xml:space="preserve">Increases the reference count on a [struct@GLib.MainLoop] object by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">@loop</doc>
          <type name="MainLoop" c:type="GMainLoop*"/>
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none">
            <doc xml:space="preserve">a main loop</doc>
            <type name="MainLoop" c:type="GMainLoop*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="run" c:identifier="g_main_loop_run">
        <doc xml:space="preserve">Runs a main loop until [method@GLib.MainLoop.quit] is called on the loop.

If this is called from the thread of the loop&#x2019;s [struct@GLib.MainContext],
it will process events from the loop, otherwise it will
simply wait.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none">
            <doc xml:space="preserve">a main loop</doc>
            <type name="MainLoop" c:type="GMainLoop*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_main_loop_unref">
        <doc xml:space="preserve">Decreases the reference count on a [struct@GLib.MainLoop] object by one.

If the result is zero, the loop and all associated memory are freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none">
            <doc xml:space="preserve">a main loop</doc>
            <type name="MainLoop" c:type="GMainLoop*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="MappedFile" c:type="GMappedFile" opaque="1" glib:type-name="GMappedFile" glib:get-type="g_mapped_file_get_type" c:symbol-prefix="mapped_file">
      <doc xml:space="preserve">The #GMappedFile represents a file mapping created with
g_mapped_file_new(). It has only private members and should
not be accessed directly.</doc>
      <constructor name="new" c:identifier="g_mapped_file_new" version="2.8" throws="1">
        <doc xml:space="preserve">Maps a file into memory. On UNIX, this is using the mmap() function.

If @writable is %TRUE, the mapped buffer may be modified, otherwise
it is an error to modify the mapped buffer. Modifications to the buffer
are not visible to other processes mapping the same file, and are not
written back to the file.

Note that modifications of the underlying file might affect the contents
of the #GMappedFile. Therefore, mapping should only be used if the file
will not be modified, or if all modifications of the file are done
atomically (e.g. using g_file_set_contents()).

If @filename is the name of an empty, regular file, the function
will successfully return an empty #GMappedFile. In other cases of
size 0 (e.g. device files such as /dev/null), @error will be set
to the #GFileError value %G_FILE_ERROR_INVAL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GMappedFile which must be unref'd
   with g_mapped_file_unref(), or %NULL if the mapping failed.</doc>
          <type name="MappedFile" c:type="GMappedFile*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">The path of the file to load, in the GLib
    filename encoding</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
          <parameter name="writable" transfer-ownership="none">
            <doc xml:space="preserve">whether the mapping should be writable</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_fd" c:identifier="g_mapped_file_new_from_fd" version="2.32" throws="1">
        <doc xml:space="preserve">Maps a file into memory. On UNIX, this is using the mmap() function.

If @writable is %TRUE, the mapped buffer may be modified, otherwise
it is an error to modify the mapped buffer. Modifications to the buffer
are not visible to other processes mapping the same file, and are not
written back to the file.

Note that modifications of the underlying file might affect the contents
of the #GMappedFile. Therefore, mapping should only be used if the file
will not be modified, or if all modifications of the file are done
atomically (e.g. using g_file_set_contents()).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GMappedFile which must be unref'd
   with g_mapped_file_unref(), or %NULL if the mapping failed.</doc>
          <type name="MappedFile" c:type="GMappedFile*"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">The file descriptor of the file to load</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="writable" transfer-ownership="none">
            <doc xml:space="preserve">whether the mapping should be writable</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="free" c:identifier="g_mapped_file_free" version="2.8" deprecated="1" deprecated-version="2.22">
        <doc xml:space="preserve">This call existed before #GMappedFile had refcounting and is currently
exactly the same as g_mapped_file_unref().</doc>
        <doc-deprecated xml:space="preserve">Use g_mapped_file_unref() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GMappedFile</doc>
            <type name="MappedFile" c:type="GMappedFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bytes" c:identifier="g_mapped_file_get_bytes" version="2.34">
        <doc xml:space="preserve">Creates a new #GBytes which references the data mapped from @file.
The mapped contents of the file must not be modified after creating this
bytes object, because a #GBytes should be immutable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #GBytes referencing data
    from @file</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GMappedFile</doc>
            <type name="MappedFile" c:type="GMappedFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_contents" c:identifier="g_mapped_file_get_contents" version="2.8">
        <doc xml:space="preserve">Returns the contents of a #GMappedFile.

Note that the contents may not be zero-terminated,
even if the #GMappedFile is backed by a text file.

If the file is empty then %NULL is returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the contents of @file, or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GMappedFile</doc>
            <type name="MappedFile" c:type="GMappedFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="g_mapped_file_get_length" version="2.8">
        <doc xml:space="preserve">Returns the length of the contents of a #GMappedFile.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the contents of @file.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GMappedFile</doc>
            <type name="MappedFile" c:type="GMappedFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_mapped_file_ref" version="2.22">
        <doc xml:space="preserve">Increments the reference count of @file by one.  It is safe to call
this function from any thread.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in #GMappedFile.</doc>
          <type name="MappedFile" c:type="GMappedFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GMappedFile</doc>
            <type name="MappedFile" c:type="GMappedFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_mapped_file_unref">
        <doc xml:space="preserve">Decrements the reference count of @file by one.  If the reference count
drops to 0, unmaps the buffer of @file and frees it.

It is safe to call this function from any thread.

Since 2.22</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GMappedFile</doc>
            <type name="MappedFile" c:type="GMappedFile*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="MarkupCollectType" c:type="GMarkupCollectType">
      <doc xml:space="preserve">A mixed enumerated type and flags field. You must specify one type
(string, strdup, boolean, tristate).  Additionally, you may  optionally
bitwise OR the type with the flag %G_MARKUP_COLLECT_OPTIONAL.

It is likely that this enum will be extended in the future to
support other types.</doc>
      <member name="invalid" value="0" c:identifier="G_MARKUP_COLLECT_INVALID">
        <doc xml:space="preserve">used to terminate the list of attributes
    to collect</doc>
      </member>
      <member name="string" value="1" c:identifier="G_MARKUP_COLLECT_STRING">
        <doc xml:space="preserve">collect the string pointer directly from
    the attribute_values[] array. Expects a parameter of type (const
    char **). If %G_MARKUP_COLLECT_OPTIONAL is specified and the
    attribute isn't present then the pointer will be set to %NULL</doc>
      </member>
      <member name="strdup" value="2" c:identifier="G_MARKUP_COLLECT_STRDUP">
        <doc xml:space="preserve">as with %G_MARKUP_COLLECT_STRING, but
    expects a parameter of type (char **) and g_strdup()s the
    returned pointer. The pointer must be freed with g_free()</doc>
      </member>
      <member name="boolean" value="3" c:identifier="G_MARKUP_COLLECT_BOOLEAN">
        <doc xml:space="preserve">expects a parameter of type (`gboolean *`)
    and parses the attribute value as a boolean. Sets %FALSE if the
    attribute isn't present. Valid boolean values consist of
    (case-insensitive) "false", "f", "no", "n", "0" and "true", "t",
    "yes", "y", "1"</doc>
      </member>
      <member name="tristate" value="4" c:identifier="G_MARKUP_COLLECT_TRISTATE">
        <doc xml:space="preserve">as with %G_MARKUP_COLLECT_BOOLEAN, but
    in the case of a missing attribute a value is set that compares
    equal to neither %FALSE nor %TRUE %G_MARKUP_COLLECT_OPTIONAL is
    implied</doc>
      </member>
      <member name="optional" value="65536" c:identifier="G_MARKUP_COLLECT_OPTIONAL">
        <doc xml:space="preserve">can be bitwise ORed with the other fields.
    If present, allows the attribute not to appear. A default value
    is set depending on what value type is used</doc>
      </member>
    </bitfield>
    <enumeration name="MarkupError" c:type="GMarkupError" glib:error-domain="g-markup-error-quark">
      <doc xml:space="preserve">Error codes returned by markup parsing.</doc>
      <member name="bad_utf8" value="0" c:identifier="G_MARKUP_ERROR_BAD_UTF8">
        <doc xml:space="preserve">text being parsed was not valid UTF-8</doc>
      </member>
      <member name="empty" value="1" c:identifier="G_MARKUP_ERROR_EMPTY">
        <doc xml:space="preserve">document contained nothing, or only whitespace</doc>
      </member>
      <member name="parse" value="2" c:identifier="G_MARKUP_ERROR_PARSE">
        <doc xml:space="preserve">document was ill-formed</doc>
      </member>
      <member name="unknown_element" value="3" c:identifier="G_MARKUP_ERROR_UNKNOWN_ELEMENT">
        <doc xml:space="preserve">error should be set by #GMarkupParser
    functions; element wasn't known</doc>
      </member>
      <member name="unknown_attribute" value="4" c:identifier="G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE">
        <doc xml:space="preserve">error should be set by #GMarkupParser
    functions; attribute wasn't known</doc>
      </member>
      <member name="invalid_content" value="5" c:identifier="G_MARKUP_ERROR_INVALID_CONTENT">
        <doc xml:space="preserve">error should be set by #GMarkupParser
    functions; content was invalid</doc>
      </member>
      <member name="missing_attribute" value="6" c:identifier="G_MARKUP_ERROR_MISSING_ATTRIBUTE">
        <doc xml:space="preserve">error should be set by #GMarkupParser
    functions; a required attribute was missing</doc>
      </member>
    </enumeration>
    <record name="MarkupParseContext" c:type="GMarkupParseContext" opaque="1" glib:type-name="GMarkupParseContext" glib:get-type="g_markup_parse_context_get_type" c:symbol-prefix="markup_parse_context">
      <doc xml:space="preserve">A parse context is used to parse a stream of bytes that
you expect to contain marked-up text.

See g_markup_parse_context_new(), #GMarkupParser, and so
on for more details.</doc>
      <constructor name="new" c:identifier="g_markup_parse_context_new">
        <doc xml:space="preserve">Creates a new parse context. A parse context is used to parse
marked-up documents. You can feed any number of documents into
a context, as long as no errors occur; once an error occurs,
the parse context can't continue to parse text (you have to
free it and create a new parse context).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GMarkupParseContext</doc>
          <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
        </return-value>
        <parameters>
          <parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParser</doc>
            <type name="MarkupParser" c:type="const GMarkupParser*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">one or more #GMarkupParseFlags</doc>
            <type name="MarkupParseFlags" c:type="GMarkupParseFlags"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to #GMarkupParser functions</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_dnotify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">user data destroy notifier called when
    the parse context is freed</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="end_parse" c:identifier="g_markup_parse_context_end_parse" throws="1">
        <doc xml:space="preserve">Signals to the #GMarkupParseContext that all data has been
fed into the parse context with g_markup_parse_context_parse().

This function reports an error if the document isn't complete,
for example if elements are still open.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if an error was set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_markup_parse_context_free">
        <doc xml:space="preserve">Frees a #GMarkupParseContext.

This function can't be called from inside one of the
#GMarkupParser functions or while a subparser is pushed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_element" c:identifier="g_markup_parse_context_get_element" version="2.2">
        <doc xml:space="preserve">Retrieves the name of the currently open element.

If called from the start_element or end_element handlers this will
give the element_name as passed to those functions. For the parent
elements, see g_markup_parse_context_get_element_stack().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the currently open element, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_element_stack" c:identifier="g_markup_parse_context_get_element_stack" version="2.16">
        <doc xml:space="preserve">Retrieves the element stack from the internal state of the parser.

The returned #GSList is a list of strings where the first item is
the currently open tag (as would be returned by
g_markup_parse_context_get_element()) and the next item is its
immediate parent.

This function is intended to be used in the start_element and
end_element handlers where g_markup_parse_context_get_element()
would merely return the name of the element that is being
processed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the element stack, which must not be modified</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset" c:identifier="g_markup_parse_context_get_offset" version="2.88">
        <doc xml:space="preserve">Retrieves the current offset from the beginning of the document,
in bytes.

The information is meant to accompany the values returned by
[method@GLib.MarkupParseContext.get_position], and comes with the
same accuracy guarantees.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_position" c:identifier="g_markup_parse_context_get_position">
        <doc xml:space="preserve">Retrieves the current line number and the number of the character on
that line. Intended for use in error messages; there are no strict
semantics for what constitutes the "current" line number other than
"the best number we could come up with for error messages."</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
          <parameter name="line_number" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for a line number, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="char_number" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for a char-on-line number, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_data" c:identifier="g_markup_parse_context_get_user_data" version="2.18">
        <doc xml:space="preserve">Returns the user_data associated with @context.

This will either be the user_data that was provided to
g_markup_parse_context_new() or to the most recent call
of g_markup_parse_context_push().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the provided user_data. The returned data belongs to
    the markup context and will be freed when
    g_markup_parse_context_free() is called.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="parse" c:identifier="g_markup_parse_context_parse" throws="1">
        <doc xml:space="preserve">Feed some data to the #GMarkupParseContext.

The data need not be valid UTF-8; an error will be signaled if
it's invalid. The data need not be an entire document; you can
feed a document into the parser incrementally, via multiple calls
to this function. Typically, as you receive data from a network
connection or file, you feed each received chunk of data into this
function, aborting the process if an error occurs. Once an error
is reported, no further data may be fed to the #GMarkupParseContext;
all errors are fatal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if an error occurred, %TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">chunk of text to parse</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="text_len" transfer-ownership="none">
            <doc xml:space="preserve">length of @text in bytes</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="g_markup_parse_context_pop" version="2.18">
        <doc xml:space="preserve">Completes the process of a temporary sub-parser redirection.

This function exists to collect the user_data allocated by a
matching call to g_markup_parse_context_push(). It must be called
in the end_element handler corresponding to the start_element
handler during which g_markup_parse_context_push() was called.
You must not call this function from the error callback -- the
@user_data is provided directly to the callback in that case.

This function is not intended to be directly called by users
interested in invoking subparsers. Instead, it is intended to
be used by the subparsers themselves to implement a higher-level
interface.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the user data passed to g_markup_parse_context_push()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="g_markup_parse_context_push" version="2.18">
        <doc xml:space="preserve">Temporarily redirects markup data to a sub-parser.

This function may only be called from the start_element handler of
a #GMarkupParser. It must be matched with a corresponding call to
g_markup_parse_context_pop() in the matching end_element handler
(except in the case that the parser aborts due to an error).

All tags, text and other data between the matching tags is
redirected to the subparser given by @parser. @user_data is used
as the user_data for that parser. @user_data is also passed to the
error callback in the event that an error occurs. This includes
errors that occur in subparsers of the subparser.

The end tag matching the start tag for which this call was made is
handled by the previous parser (which is given its own user_data)
which is why g_markup_parse_context_pop() is provided to allow "one
last access" to the @user_data provided to this function. In the
case of error, the @user_data provided here is passed directly to
the error callback of the subparser and g_markup_parse_context_pop()
should not be called. In either case, if @user_data was allocated
then it ought to be freed from both of these locations.

This function is not intended to be directly called by users
interested in invoking subparsers. Instead, it is intended to be
used by the subparsers themselves to implement a higher-level
interface.

As an example, see the following implementation of a simple
parser that counts the number of tags encountered.

|[&lt;!-- language="C" --&gt;
typedef struct
{
  gint tag_count;
} CounterData;

static void
counter_start_element (GMarkupParseContext  *context,
                       const gchar          *element_name,
                       const gchar         **attribute_names,
                       const gchar         **attribute_values,
                       gpointer              user_data,
                       GError              **error)
{
  CounterData *data = user_data;

  data-&gt;tag_count++;
}

static void
counter_error (GMarkupParseContext *context,
               GError              *error,
               gpointer             user_data)
{
  CounterData *data = user_data;

  g_slice_free (CounterData, data);
}

static GMarkupParser counter_subparser =
{
  counter_start_element,
  NULL,
  NULL,
  NULL,
  counter_error
};
]|

In order to allow this parser to be easily used as a subparser, the
following interface is provided:

|[&lt;!-- language="C" --&gt;
void
start_counting (GMarkupParseContext *context)
{
  CounterData *data = g_slice_new (CounterData);

  data-&gt;tag_count = 0;
  g_markup_parse_context_push (context, &amp;counter_subparser, data);
}

gint
end_counting (GMarkupParseContext *context)
{
  CounterData *data = g_markup_parse_context_pop (context);
  int result;

  result = data-&gt;tag_count;
  g_slice_free (CounterData, data);

  return result;
}
]|

The subparser would then be used as follows:

|[&lt;!-- language="C" --&gt;
static void start_element (context, element_name, ...)
{
  if (strcmp (element_name, "count-these") == 0)
    start_counting (context);

  // else, handle other tags...
}

static void end_element (context, element_name, ...)
{
  if (strcmp (element_name, "count-these") == 0)
    g_print ("Counted %d tags\n", end_counting (context));

  // else, handle other tags...
}
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
          <parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParser</doc>
            <type name="MarkupParser" c:type="const GMarkupParser*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to #GMarkupParser functions</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_markup_parse_context_ref" version="2.36">
        <doc xml:space="preserve">Increases the reference count of @context.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the same @context</doc>
          <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_markup_parse_context_unref" version="2.36">
        <doc xml:space="preserve">Decreases the reference count of @context.  When its reference count
drops to 0, it is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GMarkupParseContext</doc>
            <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="MarkupParseFlags" c:type="GMarkupParseFlags">
      <doc xml:space="preserve">Flags that affect the behaviour of the parser.</doc>
      <member name="default_flags" value="0" c:identifier="G_MARKUP_DEFAULT_FLAGS">
        <doc xml:space="preserve">No special behaviour. Since: 2.74</doc>
      </member>
      <member name="do_not_use_this_unsupported_flag" value="1" c:identifier="G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG">
        <doc xml:space="preserve">flag you should not use</doc>
      </member>
      <member name="treat_cdata_as_text" value="2" c:identifier="G_MARKUP_TREAT_CDATA_AS_TEXT">
        <doc xml:space="preserve">When this flag is set, CDATA marked
    sections are not passed literally to the @passthrough function of
    the parser. Instead, the content of the section (without the
    `&lt;![CDATA[` and `]]&gt;`) is
    passed to the @text function. This flag was added in GLib 2.12</doc>
      </member>
      <member name="prefix_error_position" value="4" c:identifier="G_MARKUP_PREFIX_ERROR_POSITION">
        <doc xml:space="preserve">Normally errors caught by GMarkup
    itself have line/column information prefixed to them to let the
    caller know the location of the error. When this flag is set the
    location information is also prefixed to errors generated by the
    #GMarkupParser implementation functions</doc>
      </member>
      <member name="ignore_qualified" value="8" c:identifier="G_MARKUP_IGNORE_QUALIFIED">
        <doc xml:space="preserve">Ignore (don't report) qualified
    attributes and tags, along with their contents.  A qualified
    attribute or tag is one that contains ':' in its name (ie: is in
    another namespace).  Since: 2.40.</doc>
      </member>
    </bitfield>
    <record name="MarkupParser" c:type="GMarkupParser">
      <doc xml:space="preserve">Any of the fields in #GMarkupParser can be %NULL, in which case they
will be ignored. Except for the @error function, any of these callbacks
can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,
%G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT
errors are intended to be set from these callbacks. If you set an error
from a callback, g_markup_parse_context_parse() will report that error
back to its caller.

Refer to the [GMarkup](../glib/markup.html) documentation to understand
the scope and limitations of `GMarkupParser`. In particular, it is not a
full XML parser and it must not be used to process untrusted data.</doc>
      <field name="start_element">
        <doc xml:space="preserve">Callback to invoke when the opening tag of an element
    is seen. The callback's @attribute_names and @attribute_values parameters
    are %NULL-terminated.</doc>
        <callback name="start_element" throws="1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
            </parameter>
            <parameter name="element_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="attribute_names" transfer-ownership="none">
              <type name="utf8" c:type="const gchar**"/>
            </parameter>
            <parameter name="attribute_values" transfer-ownership="none">
              <type name="utf8" c:type="const gchar**"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="end_element">
        <doc xml:space="preserve">Callback to invoke when the closing tag of an element
    is seen. Note that this is also called for empty tags like
    `&lt;empty/&gt;`.</doc>
        <callback name="end_element" throws="1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
            </parameter>
            <parameter name="element_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="text">
        <doc xml:space="preserve">Callback to invoke when some text is seen (text is always
    inside an element). Note that the text of an element may be spread
    over multiple calls of this function. If the
    %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also
    called for the content of CDATA marked sections.</doc>
        <callback name="text" throws="1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
            </parameter>
            <parameter name="text" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="text_len" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="passthrough">
        <doc xml:space="preserve">Callback to invoke for comments, processing instructions
    and doctype declarations; if you're re-writing the parsed document,
    write the passthrough text back out in the same position. If the
    %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also
    called for CDATA marked sections.</doc>
        <callback name="passthrough" throws="1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
            </parameter>
            <parameter name="passthrough_text" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="text_len" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="error">
        <doc xml:space="preserve">Callback to invoke when an error occurs.</doc>
        <callback name="error">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="MarkupParseContext" c:type="GMarkupParseContext*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="Error" c:type="GError*"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="MatchInfo" c:type="GMatchInfo" opaque="1" glib:type-name="GMatchInfo" glib:get-type="g_match_info_get_type" c:symbol-prefix="match_info">
      <doc xml:space="preserve">A GMatchInfo is an opaque struct used to return information about
matches.</doc>
      <method name="expand_references" c:identifier="g_match_info_expand_references" version="2.14" throws="1">
        <doc xml:space="preserve">Returns a new string containing the text in @string_to_expand with
references and escape sequences expanded. References refer to the last
match done with @string against @regex and have the same syntax used by
g_regex_replace().

The @string_to_expand must be UTF-8 encoded even if %G_REGEX_RAW was
passed to g_regex_new().

The backreferences are extracted from the string passed to the match
function, so you cannot call this function after freeing the string.

@match_info may be %NULL in which case @string_to_expand must not
contain references. For instance "foo\n" does not refer to an actual
pattern and '\n' merely will be replaced with \n character,
while to expand "\0" (whole match) one needs the result of a match.
Use g_regex_check_replacement() to find out whether @string_to_expand
contains references.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the expanded string, or %NULL if an error occurred</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMatchInfo or %NULL</doc>
            <type name="MatchInfo" c:type="const GMatchInfo*"/>
          </instance-parameter>
          <parameter name="string_to_expand" transfer-ownership="none">
            <doc xml:space="preserve">the string to expand</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fetch" c:identifier="g_match_info_fetch" version="2.14">
        <doc xml:space="preserve">Retrieves the text matching the @match_num'th capturing
parentheses. 0 is the full text of the match, 1 is the first paren
set, 2 the second, and so on.

If @match_num is a valid sub pattern but it didn't match anything
(e.g. sub pattern 1, matching "b" against "(a)?b") then an empty
string is returned.

If the match was obtained using the DFA algorithm, that is using
g_regex_match_all() or g_regex_match_all_full(), the retrieved
string is not that of a set of parentheses but that of a matched
substring. Substrings are matched in reverse order of length, so
0 is the longest match.

The string is fetched from the string passed to the match function,
so you cannot call this function after freeing the string.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The matched substring, or %NULL if an error
    occurred. You have to free the string yourself</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">#GMatchInfo structure</doc>
            <type name="MatchInfo" c:type="const GMatchInfo*"/>
          </instance-parameter>
          <parameter name="match_num" transfer-ownership="none">
            <doc xml:space="preserve">number of the sub expression</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="fetch_all" c:identifier="g_match_info_fetch_all" version="2.14">
        <doc xml:space="preserve">Bundles up pointers to each of the matching substrings from a match
and stores them in an array of gchar pointers. The first element in
the returned array is the match number 0, i.e. the entire matched
text.

If a sub pattern didn't match anything (e.g. sub pattern 1, matching
"b" against "(a)?b") then an empty string is inserted.

If the last match was obtained using the DFA algorithm, that is using
g_regex_match_all() or g_regex_match_all_full(), the retrieved
strings are not that matched by sets of parentheses but that of the
matched substring. Substrings are matched in reverse order of length,
so the first one is the longest match.

The strings are fetched from the string passed to the match function,
so you cannot call this function after freeing the string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array of gchar *
    pointers.  It must be freed using g_strfreev(). If the previous
    match failed %NULL is returned</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">a #GMatchInfo structure</doc>
            <type name="MatchInfo" c:type="const GMatchInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="fetch_named" c:identifier="g_match_info_fetch_named" version="2.14">
        <doc xml:space="preserve">Retrieves the text matching the capturing parentheses named @name.

If @name is a valid sub pattern name but it didn't match anything
(e.g. sub pattern `"X"`, matching `"b"` against `"(?P&lt;X&gt;a)?b"`)
then an empty string is returned.

The string is fetched from the string passed to the match function,
so you cannot call this function after freeing the string.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The matched substring, or %NULL if an error
    occurred. You have to free the string yourself</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">#GMatchInfo structure</doc>
            <type name="MatchInfo" c:type="const GMatchInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the subexpression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fetch_named_pos" c:identifier="g_match_info_fetch_named_pos" version="2.14">
        <doc xml:space="preserve">Retrieves the position in bytes of the capturing parentheses named @name.

If @name is a valid sub pattern name but it didn't match anything
(e.g. sub pattern `"X"`, matching `"b"` against `"(?P&lt;X&gt;a)?b"`)
then @start_pos and @end_pos are set to -1 and %TRUE is returned.

As @end_pos is set to the byte after the final byte of the match (on success),
the length of the match can be calculated as `end_pos - start_pos`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the position was fetched, %FALSE otherwise.
    If the position cannot be fetched, @start_pos and @end_pos
    are left unchanged.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">#GMatchInfo structure</doc>
            <type name="MatchInfo" c:type="const GMatchInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the subexpression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="start_pos" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">pointer to location where to store
    the start position, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="end_pos" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">pointer to location where to store
    the end position (the byte after the final byte of the match), or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fetch_pos" c:identifier="g_match_info_fetch_pos" version="2.14">
        <doc xml:space="preserve">Returns the start and end positions (in bytes) of a successfully matching
capture parenthesis.

Valid values for @match_num are `0` for the full text of the match,
`1` for the first paren set, `2` for the second, and so on.

As @end_pos is set to the byte after the final byte of the match (on success),
the length of the match can be calculated as `end_pos - start_pos`.

As a best practice, initialize @start_pos and @end_pos to identifiable
values, such as `G_MAXINT`, so that you can test if
`g_match_info_fetch_pos()` actually changed the value for a given
capture parenthesis.

The parameter @match_num corresponds to a matched capture parenthesis. The
actual value you use for @match_num depends on the method used to generate
@match_info. The following sections describe those methods.

## Methods Using Non-deterministic Finite Automata Matching

The methods [method@GLib.Regex.match] and [method@GLib.Regex.match_full]
return a [struct@GLib.MatchInfo] using traditional (greedy) pattern
matching, also known as
[Non-deterministic Finite Automaton](https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton)
(NFA) matching. You pass the returned `GMatchInfo` from these methods to
`g_match_info_fetch_pos()` to determine the start and end positions
of capture parentheses. The values for @match_num correspond to the capture
parentheses in order, with `0` corresponding to the entire matched string.

@match_num can refer to a capture parenthesis with no match. For example,
the string `b` matches against the pattern `(a)?b`, but the capture
parenthesis `(a)` has no match. In this case, `g_match_info_fetch_pos()`
returns true and sets @start_pos and @end_pos to `-1` when called with
`match_num` as `1` (for `(a)`).

For an expanded example, a regex pattern is `(a)?(.*?)the (.*)`,
and a candidate string is `glib regexes are the best`. In this scenario
there are four capture parentheses numbered 0&#x2013;3: an implicit one
for the entire string, and three explicitly declared in the regex pattern.

Given this example, the following table describes the return values
from `g_match_info_fetch_pos()` for various values of @match_num.

`match_num` | Contents | Return value | Returned `start_pos` | Returned `end_pos`
----------- | -------- | ------------ | -------------------- | ------------------
0 | Matches entire string | True | 0 | 25
1 | Does not match first character | True | -1 | -1
2 | All text before `the ` | True | 0 | 17
3 | All text after `the ` | True | 21 | 25
4 | Capture paren out of range | False | Unchanged | Unchanged

The following code sample and output implements this example.

``` { .c }
#include &lt;glib.h&gt;

int
main (int argc, char *argv[])
{
  g_autoptr(GError) local_error = NULL;
  const char *regex_pattern = "(a)?(.*?)the (.*)";
  const char *test_string = "glib regexes are the best";
  g_autoptr(GRegex) regex = NULL;

  regex = g_regex_new (regex_pattern,
                       G_REGEX_DEFAULT,
                       G_REGEX_MATCH_DEFAULT,
                       &amp;local_error);
  if (regex == NULL)
    {
      g_printerr ("Error creating regex: %s\n", local_error-&gt;message);
      return 1;
    }

  g_autoptr(GMatchInfo) match_info = NULL;
  g_regex_match (regex, test_string, G_REGEX_MATCH_DEFAULT, &amp;match_info);

  int n_matched_strings = g_match_info_get_match_count (match_info);

  // Print header line
  g_print ("match_num Contents                  Return value returned start_pos returned end_pos\n");

  // Iterate over each capture paren, including one that is out of range as a demonstration.
  for (int match_num = 0; match_num &lt;= n_matched_strings; match_num++)
    {
      gboolean found_match;
      g_autofree char *paren_string = NULL;
      int start_pos = G_MAXINT;
      int end_pos = G_MAXINT;

      found_match = g_match_info_fetch_pos (match_info,
                                            match_num,
                                            &amp;start_pos,
                                            &amp;end_pos);

      // If no match, display N/A as the found string.
      if (start_pos == G_MAXINT || start_pos == -1)
        paren_string = g_strdup ("N/A");
      else
        paren_string = g_strndup (test_string + start_pos, end_pos - start_pos);

      g_print ("%-9d %-25s %-12d %-18d %d\n", match_num, paren_string, found_match, start_pos, end_pos);
    }

  return 0;
}
```

```
match_num Contents                  Return value returned start_pos returned end_pos
0         glib regexes are the best 1            0                  25
1         N/A                       1            -1                 -1
2         glib regexes are          1            0                  17
3         best                      1            21                 25
4         N/A                       0            2147483647         2147483647
```
## Methods Using Deterministic Finite Automata Matching

The methods [method@GLib.Regex.match_all] and
[method@GLib.Regex.match_all_full]
return a `GMatchInfo` using
[Deterministic Finite Automaton](https://en.wikipedia.org/wiki/Deterministic_finite_automaton)
(DFA) pattern matching. This algorithm detects overlapping matches. You pass
the returned `GMatchInfo` from these methods to `g_match_info_fetch_pos()`
to determine the start and end positions of each overlapping match. Use the
method [method@GLib.MatchInfo.get_match_count] to determine the number
of overlapping matches.

For example, a regex pattern is `&lt;.*&gt;`, and a candidate string is
`&lt;a&gt; &lt;b&gt; &lt;c&gt;`. In this scenario there are three implicit capture
parentheses: one for the entire string, one for `&lt;a&gt; &lt;b&gt;`, and one for `&lt;a&gt;`.

Given this example, the following table describes the return values from
`g_match_info_fetch_pos()` for various values of @match_num.

`match_num` | Contents | Return value | Returned `start_pos` | Returned `end_pos`
----------- | -------- | ------------ | -------------------- | ------------------
0 | Matches entire string | True | 0 | 11
1 | Matches `&lt;a&gt; &lt;b&gt;` | True | 0 | 7
2 | Matches `&lt;a&gt;` | True | 0 | 3
3 | Capture paren out of range | False | Unchanged | Unchanged

The following code sample and output implements this example.

``` { .c }
#include &lt;glib.h&gt;

int
main (int argc, char *argv[])
{
  g_autoptr(GError) local_error = NULL;
  const char *regex_pattern = "&lt;.*&gt;";
  const char *test_string = "&lt;a&gt; &lt;b&gt; &lt;c&gt;";
  g_autoptr(GRegex) regex = NULL;

  regex = g_regex_new (regex_pattern,
                       G_REGEX_DEFAULT,
                       G_REGEX_MATCH_DEFAULT,
                       &amp;local_error);
  if (regex == NULL)
    {
      g_printerr ("Error creating regex: %s\n", local_error-&gt;message);
      return -1;
    }

  g_autoptr(GMatchInfo) match_info = NULL;
  g_regex_match_all (regex, test_string, G_REGEX_MATCH_DEFAULT, &amp;match_info);

  int n_matched_strings = g_match_info_get_match_count (match_info);

  // Print header line
  g_print ("match_num Contents                  Return value returned start_pos returned end_pos\n");

  // Iterate over each capture paren, including one that is out of range as a demonstration.
  for (int match_num = 0; match_num &lt;= n_matched_strings; match_num++)
    {
      gboolean found_match;
      g_autofree char *paren_string = NULL;
      int start_pos = G_MAXINT;
      int end_pos = G_MAXINT;

      found_match = g_match_info_fetch_pos (match_info, match_num, &amp;start_pos, &amp;end_pos);

      // If no match, display N/A as the found string.
      if (start_pos == G_MAXINT || start_pos == -1)
        paren_string = g_strdup ("N/A");
      else
        paren_string = g_strndup (test_string + start_pos, end_pos - start_pos);

      g_print ("%-9d %-25s %-12d %-18d %d\n", match_num, paren_string, found_match, start_pos, end_pos);
    }

  return 0;
}
```

```
match_num Contents                  Return value returned start_pos returned end_pos
0         &lt;a&gt; &lt;b&gt; &lt;c&gt;               1            0                  11
1         &lt;a&gt; &lt;b&gt;                   1            0                  7
2         &lt;a&gt;                       1            0                  3
3         N/A                       0            2147483647         2147483647
```</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">True if @match_num is within range, false otherwise. If
  the capture paren has a match, @start_pos and @end_pos contain the
  start and end positions (in bytes) of the matching substring. If the
  capture paren has no match, @start_pos and @end_pos are `-1`. If
  @match_num is out of range, @start_pos and @end_pos are left unchanged.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">#GMatchInfo structure</doc>
            <type name="MatchInfo" c:type="const GMatchInfo*"/>
          </instance-parameter>
          <parameter name="match_num" transfer-ownership="none">
            <doc xml:space="preserve">number of the capture parenthesis</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="start_pos" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">pointer to location where to store
    the start position, or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="end_pos" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">pointer to location where to store
    the end position (the byte after the final byte of the match), or %NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_match_info_free" version="2.14">
        <doc xml:space="preserve">If @match_info is not %NULL, calls g_match_info_unref(); otherwise does
nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GMatchInfo, or %NULL</doc>
            <type name="MatchInfo" c:type="GMatchInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_match_count" c:identifier="g_match_info_get_match_count" version="2.14">
        <doc xml:space="preserve">Retrieves the number of matched substrings (including substring 0,
that is the whole matched text), so 1 is returned if the pattern
has no substrings in it and 0 is returned if the match failed.

If the last match was obtained using the DFA algorithm, that is
using g_regex_match_all() or g_regex_match_all_full(), the retrieved
count is not that of the number of capturing parentheses but that of
the number of matched substrings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of matched substrings, or -1 if an error occurred</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">a #GMatchInfo structure</doc>
            <type name="MatchInfo" c:type="const GMatchInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_regex" c:identifier="g_match_info_get_regex" version="2.14">
        <doc xml:space="preserve">Returns #GRegex object used in @match_info. It belongs to Glib
and must not be freed. Use g_regex_ref() if you need to keep it
after you free @match_info object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#GRegex object used in @match_info</doc>
          <type name="Regex" c:type="GRegex*"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">a #GMatchInfo</doc>
            <type name="MatchInfo" c:type="const GMatchInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="g_match_info_get_string" version="2.14">
        <doc xml:space="preserve">Returns the string searched with @match_info. This is the
string passed to g_regex_match() or g_regex_replace() so
you may not free it before calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the string searched with @match_info</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">a #GMatchInfo</doc>
            <type name="MatchInfo" c:type="const GMatchInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_partial_match" c:identifier="g_match_info_is_partial_match" version="2.14">
        <doc xml:space="preserve">Usually if the string passed to g_regex_match*() matches as far as
it goes, but is too short to match the entire pattern, %FALSE is
returned. There are circumstances where it might be helpful to
distinguish this case from other cases in which there is no match.

Consider, for example, an application where a human is required to
type in data for a field with specific formatting requirements. An
example might be a date in the form ddmmmyy, defined by the pattern
"^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$".
If the application sees the user&#x2019;s keystrokes one by one, and can
check that what has been typed so far is potentially valid, it is
able to raise an error as soon as a mistake is made.

GRegex supports the concept of partial matching by means of the
%G_REGEX_MATCH_PARTIAL_SOFT and %G_REGEX_MATCH_PARTIAL_HARD flags.
When they are used, the return code for
g_regex_match() or g_regex_match_full() is, as usual, %TRUE
for a complete match, %FALSE otherwise. But, when these functions
return %FALSE, you can check if the match was partial calling
g_match_info_is_partial_match().

The difference between %G_REGEX_MATCH_PARTIAL_SOFT and
%G_REGEX_MATCH_PARTIAL_HARD is that when a partial match is encountered
with %G_REGEX_MATCH_PARTIAL_SOFT, matching continues to search for a
possible complete match, while with %G_REGEX_MATCH_PARTIAL_HARD matching
stops at the partial match.
When both %G_REGEX_MATCH_PARTIAL_SOFT and %G_REGEX_MATCH_PARTIAL_HARD
are set, the latter takes precedence.

There were formerly some restrictions on the pattern for partial matching.
The restrictions no longer apply.

See pcrepartial(3) for more information on partial matching.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the match was partial, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">a #GMatchInfo structure</doc>
            <type name="MatchInfo" c:type="const GMatchInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="matches" c:identifier="g_match_info_matches" version="2.14">
        <doc xml:space="preserve">Returns whether the previous match operation succeeded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the previous match operation succeeded,
  %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">a #GMatchInfo structure</doc>
            <type name="MatchInfo" c:type="const GMatchInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="g_match_info_next" version="2.14" throws="1">
        <doc xml:space="preserve">Scans for the next match using the same parameters of the previous
call to g_regex_match_full() or g_regex_match() that returned
@match_info.

The match is done on the string passed to the match function, so you
cannot free it before calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE is the string matched, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">a #GMatchInfo structure</doc>
            <type name="MatchInfo" c:type="GMatchInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_match_info_ref" version="2.30">
        <doc xml:space="preserve">Increases reference count of @match_info by 1.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">@match_info</doc>
          <type name="MatchInfo" c:type="GMatchInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">a #GMatchInfo</doc>
            <type name="MatchInfo" c:type="GMatchInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_match_info_unref" version="2.30">
        <doc xml:space="preserve">Decreases reference count of @match_info by 1. When reference count drops
to zero, it frees all the memory associated with the match_info structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="match_info" transfer-ownership="none">
            <doc xml:space="preserve">a #GMatchInfo</doc>
            <type name="MatchInfo" c:type="GMatchInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="MemChunk" c:type="GMemChunk" disguised="1" opaque="1" deprecated="1" deprecated-version="2.10">
      <method name="alloc" c:identifier="g_mem_chunk_alloc" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem_chunk" transfer-ownership="none">
            <type name="MemChunk" c:type="GMemChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="alloc0" c:identifier="g_mem_chunk_alloc0" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem_chunk" transfer-ownership="none">
            <type name="MemChunk" c:type="GMemChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clean" c:identifier="g_mem_chunk_clean" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem_chunk" transfer-ownership="none">
            <type name="MemChunk" c:type="GMemChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="g_mem_chunk_destroy" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem_chunk" transfer-ownership="none">
            <type name="MemChunk" c:type="GMemChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_mem_chunk_free" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem_chunk" transfer-ownership="none">
            <type name="MemChunk" c:type="GMemChunk*"/>
          </instance-parameter>
          <parameter name="mem" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="print" c:identifier="g_mem_chunk_print" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem_chunk" transfer-ownership="none">
            <type name="MemChunk" c:type="GMemChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="g_mem_chunk_reset" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem_chunk" transfer-ownership="none">
            <type name="MemChunk" c:type="GMemChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="info" c:identifier="g_mem_chunk_info" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="new" c:identifier="g_mem_chunk_new" introspectable="0" deprecated="1" deprecated-version="2.10">
        <return-value>
          <type name="MemChunk" c:type="GMemChunk*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="atom_size" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="area_size" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="MemVTable" c:type="GMemVTable">
      <doc xml:space="preserve">A set of functions used to perform memory allocation. The same #GMemVTable must
be used for all allocations in the same program; a call to g_mem_set_vtable(),
if it exists, should be prior to any use of GLib.

This functions related to this has been deprecated in 2.46, and no longer work.</doc>
      <field name="malloc">
        <doc xml:space="preserve">function to use for allocating memory.</doc>
        <callback name="malloc">
          <return-value transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="n_bytes" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="realloc">
        <doc xml:space="preserve">function to use for reallocating memory.</doc>
        <callback name="realloc">
          <return-value transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="mem" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="n_bytes" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="free">
        <doc xml:space="preserve">function to use to free memory.</doc>
        <callback name="free">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mem" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="calloc">
        <doc xml:space="preserve">function to use for allocating zero-filled memory.</doc>
        <callback name="calloc">
          <return-value transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="n_blocks" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="n_block_bytes" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="try_malloc">
        <doc xml:space="preserve">function to use for allocating memory without a default error handler.</doc>
        <callback name="try_malloc">
          <return-value transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="n_bytes" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="try_realloc">
        <doc xml:space="preserve">function to use for reallocating memory without a default error handler.</doc>
        <callback name="try_realloc">
          <return-value transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="mem" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="n_bytes" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <union name="Mutex" c:type="GMutex">
      <doc xml:space="preserve">The #GMutex struct is an opaque data structure to represent a mutex
(mutual exclusion). It can be used to protect data against shared
access.

Take for example the following function:
|[&lt;!-- language="C" --&gt;
  int
  give_me_next_number (void)
  {
    static int current_number = 0;

    // now do a very complicated calculation to calculate the new
    // number, this might for example be a random number generator
    current_number = calc_next_number (current_number);

    return current_number;
  }
]|
It is easy to see that this won't work in a multi-threaded
application. There current_number must be protected against shared
access. A #GMutex can be used as a solution to this problem:
|[&lt;!-- language="C" --&gt;
  int
  give_me_next_number (void)
  {
    static GMutex mutex;
    static int current_number = 0;
    int ret_val;

    g_mutex_lock (&amp;mutex);
    ret_val = current_number = calc_next_number (current_number);
    g_mutex_unlock (&amp;mutex);

    return ret_val;
  }
]|
Notice that the #GMutex is not initialised to any particular value.
Its placement in static storage ensures that it will be initialised
to all-zeros, which is appropriate.

If a #GMutex is placed in other contexts (eg: embedded in a struct)
then it must be explicitly initialised using g_mutex_init().

A #GMutex should only be accessed via g_mutex_ functions.</doc>
      <field name="p" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="i" readable="0" private="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <method name="clear" c:identifier="g_mutex_clear" version="2.32">
        <doc xml:space="preserve">Frees the resources allocated to a mutex with g_mutex_init().

This function should not be used with a #GMutex that has been
statically allocated.

Calling g_mutex_clear() on a locked mutex leads to undefined
behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">an initialized #GMutex</doc>
            <type name="Mutex" c:type="GMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_mutex_free" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Destroys a @mutex that has been created with g_mutex_new().

Calling g_mutex_free() on a locked mutex may result
in undefined behaviour.</doc>
        <doc-deprecated xml:space="preserve">GMutex can now be statically allocated, or embedded
in structures and initialised with g_mutex_init().</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GMutex</doc>
            <type name="Mutex" c:type="GMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_mutex_init" version="2.32">
        <doc xml:space="preserve">Initializes a #GMutex so that it can be used.

This function is useful to initialize a mutex that has been
allocated on the stack, or as part of a larger structure.
It is not necessary to initialize a mutex that has been
statically allocated.

|[&lt;!-- language="C" --&gt;
  typedef struct {
    GMutex m;
    ...
  } Blob;

Blob *b;

b = g_new (Blob, 1);
g_mutex_init (&amp;b-&gt;m);
]|

To undo the effect of g_mutex_init() when a mutex is no longer
needed, use g_mutex_clear().

Calling g_mutex_init() on an already initialized #GMutex leads
to undefined behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized #GMutex</doc>
            <type name="Mutex" c:type="GMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lock" c:identifier="g_mutex_lock">
        <doc xml:space="preserve">Locks @mutex. If @mutex is already locked by another thread, the
current thread will block until @mutex is unlocked by the other
thread.

#GMutex is neither guaranteed to be recursive nor to be
non-recursive.  As such, calling g_mutex_lock() on a #GMutex that has
already been locked by the same thread results in undefined behaviour
(including but not limited to deadlocks).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GMutex</doc>
            <type name="Mutex" c:type="GMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="trylock" c:identifier="g_mutex_trylock">
        <doc xml:space="preserve">Tries to lock @mutex. If @mutex is already locked by another thread,
it immediately returns %FALSE. Otherwise it locks @mutex and returns
%TRUE.

#GMutex is neither guaranteed to be recursive nor to be
non-recursive.  As such, calling g_mutex_lock() on a #GMutex that has
already been locked by the same thread results in undefined behaviour
(including but not limited to deadlocks or arbitrary return values).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @mutex could be locked</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GMutex</doc>
            <type name="Mutex" c:type="GMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unlock" c:identifier="g_mutex_unlock">
        <doc xml:space="preserve">Unlocks @mutex. If another thread is blocked in a g_mutex_lock()
call for @mutex, it will become unblocked and can lock @mutex itself.

Calling g_mutex_unlock() on a mutex that is not locked by the
current thread leads to undefined behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GMutex</doc>
            <type name="Mutex" c:type="GMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_mutex_new" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Allocates and initializes a new #GMutex.</doc>
        <doc-deprecated xml:space="preserve">GMutex can now be statically allocated, or embedded
in structures and initialised with g_mutex_init().</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GMutex. Use g_mutex_free() to free</doc>
          <type name="Mutex" c:type="GMutex*"/>
        </return-value>
      </function>
    </union>
    <function-macro name="NODE_IS_LEAF" c:identifier="G_NODE_IS_LEAF" introspectable="0">
      <doc xml:space="preserve">Returns %TRUE if a #GNode is a leaf node.</doc>
      <parameters>
        <parameter name="node">
          <doc xml:space="preserve">a #GNode</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="NODE_IS_ROOT" c:identifier="G_NODE_IS_ROOT" introspectable="0">
      <doc xml:space="preserve">Returns %TRUE if a #GNode is the root of a tree.</doc>
      <parameters>
        <parameter name="node">
          <doc xml:space="preserve">a #GNode</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="N_ELEMENTS" c:identifier="G_N_ELEMENTS" introspectable="0">
      <doc xml:space="preserve">Determines the number of elements in an array. The array must be
declared so the compiler knows its size at compile-time; this
macro will not work on an array allocated on the heap, only static
arrays or arrays on the stack.</doc>
      <parameters>
        <parameter name="arr">
          <doc xml:space="preserve">the array</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="Node" c:type="GNode">
      <doc xml:space="preserve">The #GNode struct represents one node in a [n-ary tree](data-structures.html#n-ary-trees).</doc>
      <field name="data" writable="1">
        <doc xml:space="preserve">contains the actual data of the node.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="next" writable="1">
        <doc xml:space="preserve">points to the node's next sibling (a sibling is another
       #GNode with the same parent).</doc>
        <type name="Node" c:type="GNode*"/>
      </field>
      <field name="prev" writable="1">
        <doc xml:space="preserve">points to the node's previous sibling.</doc>
        <type name="Node" c:type="GNode*"/>
      </field>
      <field name="parent" writable="1">
        <doc xml:space="preserve">points to the parent of the #GNode, or is %NULL if the
         #GNode is the root of the tree.</doc>
        <type name="Node" c:type="GNode*"/>
      </field>
      <field name="children" writable="1">
        <doc xml:space="preserve">points to the first child of the #GNode.  The other
           children are accessed by using the @next pointer of each
           child.</doc>
        <type name="Node" c:type="GNode*"/>
      </field>
      <method name="child_index" c:identifier="g_node_child_index">
        <doc xml:space="preserve">Gets the position of the first child of a #GNode
which contains the given data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the index of the child of @node which contains
    @data, or -1 if the data is not found</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to find</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="child_position" c:identifier="g_node_child_position">
        <doc xml:space="preserve">Gets the position of a #GNode with respect to its siblings.
@child must be a child of @node. The first child is numbered 0,
the second 1, and so on.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the position of @child with respect to its siblings</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">a child of @node</doc>
            <type name="Node" c:type="GNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="children_foreach" c:identifier="g_node_children_foreach">
        <doc xml:space="preserve">Calls a function for each of the children of a #GNode. Note that it
doesn't descend beneath the child nodes. @func must not do anything
that would modify the structure of the tree.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">which types of children are to be visited, one of
    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>
            <type name="TraverseFlags" c:type="GTraverseFlags"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call for each visited node</doc>
            <type name="NodeForeachFunc" c:type="GNodeForeachFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="g_node_copy" introspectable="0">
        <doc xml:space="preserve">Recursively copies a #GNode (but does not deep-copy the data inside the
nodes, see g_node_copy_deep() if you need that).</doc>
        <return-value>
          <doc xml:space="preserve">a new #GNode containing the same data pointers</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy_deep" c:identifier="g_node_copy_deep" version="2.4" introspectable="0">
        <doc xml:space="preserve">Recursively copies a #GNode and its data.</doc>
        <return-value>
          <doc xml:space="preserve">a new #GNode containing copies of the data in @node.</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="copy_func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the function which is called to copy the data
  inside each node, or %NULL to use the original data.</doc>
            <type name="CopyFunc" c:type="GCopyFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @copy_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="depth" c:identifier="g_node_depth">
        <doc xml:space="preserve">Gets the depth of a #GNode.

If @node is %NULL the depth is 0. The root node has a depth of 1.
For the children of the root node the depth is 2. And so on.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the depth of the #GNode</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="g_node_destroy">
        <doc xml:space="preserve">Removes @root and its children from the tree, freeing any memory
allocated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">the root of the tree/subtree to destroy</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="find" c:identifier="g_node_find" introspectable="0">
        <doc xml:space="preserve">Finds a #GNode in a tree.</doc>
        <return-value>
          <doc xml:space="preserve">the found #GNode, or %NULL if the data is not found</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">the root #GNode of the tree to search</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="order" transfer-ownership="none">
            <doc xml:space="preserve">the order in which nodes are visited - %G_IN_ORDER,
    %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER</doc>
            <type name="TraverseType" c:type="GTraverseType"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">which types of children are to be searched, one of
    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>
            <type name="TraverseFlags" c:type="GTraverseFlags"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to find</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_child" c:identifier="g_node_find_child" introspectable="0">
        <doc xml:space="preserve">Finds the first child of a #GNode with the given data.</doc>
        <return-value>
          <doc xml:space="preserve">the found child #GNode, or %NULL if the data is not found</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">which types of children are to be searched, one of
    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>
            <type name="TraverseFlags" c:type="GTraverseFlags"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to find</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="first_sibling" c:identifier="g_node_first_sibling" introspectable="0">
        <doc xml:space="preserve">Gets the first sibling of a #GNode.
This could possibly be the node itself.</doc>
        <return-value>
          <doc xml:space="preserve">the first sibling of @node</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_root" c:identifier="g_node_get_root" introspectable="0">
        <doc xml:space="preserve">Gets the root of a tree.</doc>
        <return-value>
          <doc xml:space="preserve">the root of the tree</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_node_insert" introspectable="0">
        <doc xml:space="preserve">Inserts a #GNode beneath the parent at the given position.</doc>
        <return-value>
          <doc xml:space="preserve">the inserted #GNode</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">the #GNode to place @node under</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position to place @node at, with respect to its siblings
    If position is -1, @node is inserted as the last child of @parent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the #GNode to insert</doc>
            <type name="Node" c:type="GNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_after" c:identifier="g_node_insert_after" introspectable="0">
        <doc xml:space="preserve">Inserts a #GNode beneath the parent after the given sibling.</doc>
        <return-value>
          <doc xml:space="preserve">the inserted #GNode</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">the #GNode to place @node under</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="sibling" transfer-ownership="none">
            <doc xml:space="preserve">the sibling #GNode to place @node after.
    If sibling is %NULL, the node is inserted as the first child of @parent.</doc>
            <type name="Node" c:type="GNode*"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the #GNode to insert</doc>
            <type name="Node" c:type="GNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_before" c:identifier="g_node_insert_before" introspectable="0">
        <doc xml:space="preserve">Inserts a #GNode beneath the parent before the given sibling.</doc>
        <return-value>
          <doc xml:space="preserve">the inserted #GNode</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">the #GNode to place @node under</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="sibling" transfer-ownership="none">
            <doc xml:space="preserve">the sibling #GNode to place @node before.
    If sibling is %NULL, the node is inserted as the last child of @parent.</doc>
            <type name="Node" c:type="GNode*"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the #GNode to insert</doc>
            <type name="Node" c:type="GNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_ancestor" c:identifier="g_node_is_ancestor">
        <doc xml:space="preserve">Returns %TRUE if @node is an ancestor of @descendant.
This is true if node is the parent of @descendant,
or if node is the grandparent of @descendant etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @node is an ancestor of @descendant</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="descendant" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="last_child" c:identifier="g_node_last_child" introspectable="0">
        <doc xml:space="preserve">Gets the last child of a #GNode.</doc>
        <return-value>
          <doc xml:space="preserve">the last child of @node, or %NULL if @node has no children</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode (must not be %NULL)</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="last_sibling" c:identifier="g_node_last_sibling" introspectable="0">
        <doc xml:space="preserve">Gets the last sibling of a #GNode.
This could possibly be the node itself.</doc>
        <return-value>
          <doc xml:space="preserve">the last sibling of @node</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="max_height" c:identifier="g_node_max_height">
        <doc xml:space="preserve">Gets the maximum height of all branches beneath a #GNode.
This is the maximum distance from the #GNode to all leaf nodes.

If @root is %NULL, 0 is returned. If @root has no children,
1 is returned. If @root has children, 2 is returned. And so on.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum height of the tree beneath @root</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="n_children" c:identifier="g_node_n_children">
        <doc xml:space="preserve">Gets the number of children of a #GNode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of children of @node</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="n_nodes" c:identifier="g_node_n_nodes">
        <doc xml:space="preserve">Gets the number of nodes in a tree.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of nodes in the tree</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">which types of children are to be counted, one of
    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>
            <type name="TraverseFlags" c:type="GTraverseFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="nth_child" c:identifier="g_node_nth_child" introspectable="0">
        <doc xml:space="preserve">Gets a child of a #GNode, using the given index.
The first child is at index 0. If the index is
too big, %NULL is returned.</doc>
        <return-value>
          <doc xml:space="preserve">the child of @node at index @n</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the index of the desired child</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend" c:identifier="g_node_prepend" introspectable="0">
        <doc xml:space="preserve">Inserts a #GNode as the first child of the given parent.</doc>
        <return-value>
          <doc xml:space="preserve">the inserted #GNode</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">the #GNode to place the new #GNode under</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the #GNode to insert</doc>
            <type name="Node" c:type="GNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reverse_children" c:identifier="g_node_reverse_children">
        <doc xml:space="preserve">Reverses the order of the children of a #GNode.
(It doesn't change the order of the grandchildren.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GNode.</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="traverse" c:identifier="g_node_traverse">
        <doc xml:space="preserve">Traverses a tree starting at the given root #GNode.
It calls the given function for each node visited.
The traversal can be halted at any point by returning %TRUE from @func.
@func must not do anything that would modify the structure of the tree.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">the root #GNode of the tree to traverse</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
          <parameter name="order" transfer-ownership="none">
            <doc xml:space="preserve">the order in which nodes are visited - %G_IN_ORDER,
    %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER.</doc>
            <type name="TraverseType" c:type="GTraverseType"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">which types of children are to be visited, one of
    %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES</doc>
            <type name="TraverseFlags" c:type="GTraverseFlags"/>
          </parameter>
          <parameter name="max_depth" transfer-ownership="none">
            <doc xml:space="preserve">the maximum depth of the traversal. Nodes below this
    depth will not be visited. If max_depth is -1 all nodes in
    the tree are visited. If depth is 1, only the root is visited.
    If depth is 2, the root and its children are visited. And so on.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="4">
            <doc xml:space="preserve">the function to call for each visited #GNode</doc>
            <type name="NodeTraverseFunc" c:type="GNodeTraverseFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unlink" c:identifier="g_node_unlink">
        <doc xml:space="preserve">Unlinks a #GNode from a tree, resulting in two separate trees.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the #GNode to unlink, which becomes the root of a new tree</doc>
            <type name="Node" c:type="GNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_node_new" introspectable="0">
        <doc xml:space="preserve">Creates a new #GNode containing the given data.
Used to create the first node in a tree.</doc>
        <return-value>
          <doc xml:space="preserve">a new #GNode</doc>
          <type name="Node" c:type="GNode*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data of the new node</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="pop_allocator" c:identifier="g_node_pop_allocator" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="push_allocator" c:identifier="g_node_push_allocator" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="allocator" transfer-ownership="none">
            <type name="Allocator" c:type="GAllocator*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="NodeForeachFunc" c:type="GNodeForeachFunc">
      <doc xml:space="preserve">Specifies the type of function passed to g_node_children_foreach().
The function is called with each child node, together with the user
data passed to g_node_children_foreach().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a #GNode.</doc>
          <type name="Node" c:type="GNode*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to g_node_children_foreach().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="NodeTraverseFunc" c:type="GNodeTraverseFunc">
      <doc xml:space="preserve">Specifies the type of function passed to g_node_traverse(). The
function is called with each of the nodes visited, together with the
user data passed to g_node_traverse(). If the function returns
%TRUE, then the traversal is stopped.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE to stop the traversal.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a #GNode.</doc>
          <type name="Node" c:type="GNode*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to g_node_traverse().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="NormalizeMode" glib:type-name="GNormalizeMode" glib:get-type="g_normalize_mode_get_type" c:type="GNormalizeMode">
      <doc xml:space="preserve">Defines how a Unicode string is transformed in a canonical
form, standardizing such issues as whether a character with
an accent is represented as a base character and combining
accent or as a single precomposed character. Unicode strings
should generally be normalized before comparing them.</doc>
      <member name="default" value="0" c:identifier="G_NORMALIZE_DEFAULT" glib:nick="default" glib:name="G_NORMALIZE_DEFAULT">
        <doc xml:space="preserve">standardize differences that do not affect the
    text content, such as the above-mentioned accent representation</doc>
      </member>
      <member name="nfd" value="0" c:identifier="G_NORMALIZE_NFD" glib:nick="nfd" glib:name="G_NORMALIZE_NFD">
        <doc xml:space="preserve">another name for %G_NORMALIZE_DEFAULT</doc>
      </member>
      <member name="default_compose" value="1" c:identifier="G_NORMALIZE_DEFAULT_COMPOSE" glib:nick="default-compose" glib:name="G_NORMALIZE_DEFAULT_COMPOSE">
        <doc xml:space="preserve">like %G_NORMALIZE_DEFAULT, but with
    composed forms rather than a maximally decomposed form</doc>
      </member>
      <member name="nfc" value="1" c:identifier="G_NORMALIZE_NFC" glib:nick="nfc" glib:name="G_NORMALIZE_NFC">
        <doc xml:space="preserve">another name for %G_NORMALIZE_DEFAULT_COMPOSE</doc>
      </member>
      <member name="all" value="2" c:identifier="G_NORMALIZE_ALL" glib:nick="all" glib:name="G_NORMALIZE_ALL">
        <doc xml:space="preserve">beyond %G_NORMALIZE_DEFAULT also standardize the
    "compatibility" characters in Unicode, such as SUPERSCRIPT THREE
    to the standard forms (in this case DIGIT THREE). Formatting
    information may be lost but for most text operations such
    characters should be considered the same</doc>
      </member>
      <member name="nfkd" value="2" c:identifier="G_NORMALIZE_NFKD" glib:nick="nfkd" glib:name="G_NORMALIZE_NFKD">
        <doc xml:space="preserve">another name for %G_NORMALIZE_ALL</doc>
      </member>
      <member name="all_compose" value="3" c:identifier="G_NORMALIZE_ALL_COMPOSE" glib:nick="all-compose" glib:name="G_NORMALIZE_ALL_COMPOSE">
        <doc xml:space="preserve">like %G_NORMALIZE_ALL, but with composed
    forms rather than a maximally decomposed form</doc>
      </member>
      <member name="nfkc" value="3" c:identifier="G_NORMALIZE_NFKC" glib:nick="nfkc" glib:name="G_NORMALIZE_NFKC">
        <doc xml:space="preserve">another name for %G_NORMALIZE_ALL_COMPOSE</doc>
      </member>
    </enumeration>
    <enumeration name="NumberParserError" version="2.54" c:type="GNumberParserError" glib:error-domain="g-number-parser-error-quark">
      <doc xml:space="preserve">Error codes returned by functions converting a string to a number.</doc>
      <member name="invalid" value="0" c:identifier="G_NUMBER_PARSER_ERROR_INVALID">
        <doc xml:space="preserve">string was not a valid number</doc>
      </member>
      <member name="out_of_bounds" value="1" c:identifier="G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS">
        <doc xml:space="preserve">string was a number, but out of bounds</doc>
      </member>
    </enumeration>
    <constant name="OPTION_REMAINING" value="" c:type="G_OPTION_REMAINING" version="2.6">
      <doc xml:space="preserve">If a long option in the main group has this name, it is not treated as a
regular option. Instead it collects all non-option arguments which would
otherwise be left in `argv`. The option must be of type
%G_OPTION_ARG_CALLBACK, %G_OPTION_ARG_STRING_ARRAY
or %G_OPTION_ARG_FILENAME_ARRAY.


Using %G_OPTION_REMAINING instead of simply scanning `argv`
for leftover arguments has the advantage that GOption takes care of
necessary encoding conversions for strings or filenames.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="Once" c:type="GOnce" version="2.4">
      <doc xml:space="preserve">A #GOnce struct controls a one-time initialization function. Any
one-time initialization function must have its own unique #GOnce
struct.</doc>
      <field name="status" writable="1">
        <doc xml:space="preserve">the status of the #GOnce</doc>
        <type name="OnceStatus" c:type="volatile GOnceStatus"/>
      </field>
      <field name="retval" writable="1">
        <doc xml:space="preserve">the value returned by the call to the function, if @status
         is %G_ONCE_STATUS_READY</doc>
        <type name="gpointer" c:type="volatile gpointer"/>
      </field>
      <method name="impl" c:identifier="g_once_impl" introspectable="0">
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="once" transfer-ownership="none">
            <type name="Once" c:type="GOnce*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none">
            <type name="ThreadFunc" c:type="GThreadFunc"/>
          </parameter>
          <parameter name="arg" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <function name="init_enter" c:identifier="g_once_init_enter" version="2.14">
        <doc xml:space="preserve">Function to be called when starting a critical initialization
section. The argument @location must point to a static
0-initialized variable that will be set to a value other than 0 at
the end of the initialization section. In combination with
g_once_init_leave() and the unique address @value_location, it can
be ensured that an initialization section will be executed only once
during a program's life time, and that concurrent threads are
blocked until initialization completed. To be used in constructs
like this:

|[&lt;!-- language="C" --&gt;
  static gsize initialization_value = 0;

  if (g_once_init_enter (&amp;initialization_value))
    {
      gsize setup_value = 42; // initialization code here

      g_once_init_leave (&amp;initialization_value, setup_value);
    }

  // use initialization_value here
]|

While @location has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the initialization section should be entered,
    %FALSE and blocks otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="location" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location of a static initializable variable
   containing 0</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_enter_impl" c:identifier="g_once_init_enter_impl">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="location" transfer-ownership="none">
            <type name="gsize" c:type="volatile gsize*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_enter_pointer" c:identifier="g_once_init_enter_pointer" version="2.80">
        <doc xml:space="preserve">This functions behaves in the same way as g_once_init_enter(), but can
can be used to initialize pointers (or #guintptr) instead of #gsize.

|[&lt;!-- language="C" --&gt;
  static MyStruct *interesting_struct = NULL;

  if (g_once_init_enter_pointer (&amp;interesting_struct))
    {
      MyStruct *setup_value = allocate_my_struct (); // initialization code here

      g_once_init_leave_pointer (&amp;interesting_struct, g_steal_pointer (&amp;setup_value));
    }

  // use interesting_struct here
]|</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the initialization section should be entered,
    %FALSE and blocks otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="location" transfer-ownership="none">
            <doc xml:space="preserve">location of a static initializable variable
   containing `NULL`</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_leave" c:identifier="g_once_init_leave" version="2.14">
        <doc xml:space="preserve">Counterpart to g_once_init_enter(). Expects a location of a static
0-initialized initialization variable, and an initialization value
other than 0. Sets the variable to the initialization value, and
releases concurrent threads blocking in g_once_init_enter() on this
initialization variable.

While @location has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="location" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location of a static initializable variable
   containing 0</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">new non-0 value for `*value_location`</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_leave_pointer" c:identifier="g_once_init_leave_pointer" version="2.80">
        <doc xml:space="preserve">Counterpart to g_once_init_enter_pointer(). Expects a location of a static
`NULL`-initialized initialization variable, and an initialization value
other than `NULL`. Sets the variable to the initialization value, and
releases concurrent threads blocking in g_once_init_enter_pointer() on this
initialization variable.

This functions behaves in the same way as g_once_init_leave(), but
can be used to initialize pointers (or #guintptr) instead of #gsize.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="location" transfer-ownership="none">
            <doc xml:space="preserve">location of a static initializable variable
   containing `NULL`</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="result" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">new non-`NULL` value for `*location`</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="OnceStatus" version="2.4" c:type="GOnceStatus">
      <doc xml:space="preserve">The possible statuses of a one-time initialization function
controlled by a #GOnce struct.</doc>
      <member name="notcalled" value="0" c:identifier="G_ONCE_STATUS_NOTCALLED">
        <doc xml:space="preserve">the function has not been called yet.</doc>
      </member>
      <member name="progress" value="1" c:identifier="G_ONCE_STATUS_PROGRESS">
        <doc xml:space="preserve">the function call is currently in progress.</doc>
      </member>
      <member name="ready" value="2" c:identifier="G_ONCE_STATUS_READY">
        <doc xml:space="preserve">the function has been called.</doc>
      </member>
    </enumeration>
    <enumeration name="OptionArg" c:type="GOptionArg">
      <doc xml:space="preserve">The #GOptionArg enum values determine which type of extra argument the
options expect to find. If an option expects an extra argument, it can
be specified in several ways; with a short option: `-x arg`, with a long
option: `--name arg` or combined in a single argument: `--name=arg`.</doc>
      <member name="none" value="0" c:identifier="G_OPTION_ARG_NONE">
        <doc xml:space="preserve">No extra argument. This is useful for simple flags or booleans.</doc>
      </member>
      <member name="string" value="1" c:identifier="G_OPTION_ARG_STRING">
        <doc xml:space="preserve">The option takes a UTF-8 string argument.</doc>
      </member>
      <member name="int" value="2" c:identifier="G_OPTION_ARG_INT">
        <doc xml:space="preserve">The option takes an integer argument.</doc>
      </member>
      <member name="callback" value="3" c:identifier="G_OPTION_ARG_CALLBACK">
        <doc xml:space="preserve">The option provides a callback (of type #GOptionArgFunc)
  to parse the extra argument.</doc>
      </member>
      <member name="filename" value="4" c:identifier="G_OPTION_ARG_FILENAME">
        <doc xml:space="preserve">The option takes a filename as argument, which will
     be in the GLib filename encoding rather than UTF-8.</doc>
      </member>
      <member name="string_array" value="5" c:identifier="G_OPTION_ARG_STRING_ARRAY">
        <doc xml:space="preserve">The option takes a string argument, multiple
  uses of the option are collected into an array of strings.</doc>
      </member>
      <member name="filename_array" value="6" c:identifier="G_OPTION_ARG_FILENAME_ARRAY">
        <doc xml:space="preserve">The option takes a filename as argument,
  multiple uses of the option are collected into an array of strings.</doc>
      </member>
      <member name="double" value="7" c:identifier="G_OPTION_ARG_DOUBLE">
        <doc xml:space="preserve">The option takes a double argument. The argument
  can be formatted either for the user's locale or for the "C" locale.
  Since 2.12</doc>
      </member>
      <member name="int64" value="8" c:identifier="G_OPTION_ARG_INT64">
        <doc xml:space="preserve">The option takes a 64-bit integer. Like
  %G_OPTION_ARG_INT but for larger numbers. The number can be in
  decimal base, or in hexadecimal (when prefixed with `0x`, for
  example, `0xffffffff`). Since 2.12</doc>
      </member>
    </enumeration>
    <callback name="OptionArgFunc" c:type="GOptionArgFunc" throws="1">
      <doc xml:space="preserve">The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK
options.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the option was successfully parsed, %FALSE if an error
 occurred, in which case @error should be set with g_set_error()</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="option_name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the option being parsed. This will be either a
 single dash followed by a single letter (for a short name) or two dashes
 followed by a long option name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The value to be parsed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">User data added to the #GOptionGroup containing the option when it
 was created with g_option_group_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="OptionContext" c:type="GOptionContext" disguised="1" opaque="1">
      <doc xml:space="preserve">A `GOptionContext` struct defines which options
are accepted by the commandline option parser. The struct has only private
fields and should not be directly accessed.</doc>
      <method name="add_group" c:identifier="g_option_context_add_group" version="2.6">
        <doc xml:space="preserve">Adds a #GOptionGroup to the @context, so that parsing with @context
will recognize the options in the group. Note that this will take
ownership of the @group and thus the @group should not be freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="full">
            <doc xml:space="preserve">the group to add</doc>
            <type name="OptionGroup" c:type="GOptionGroup*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_main_entries" c:identifier="g_option_context_add_main_entries" version="2.6">
        <doc xml:space="preserve">A convenience function which creates a main group if it doesn't
exist, adds the @entries to it and sets the translation domain.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="entries" transfer-ownership="none">
            <doc xml:space="preserve">a %NULL-terminated array of #GOptionEntrys</doc>
            <array c:type="const GOptionEntry*">
              <type name="OptionEntry" c:type="GOptionEntry"/>
            </array>
          </parameter>
          <parameter name="translation_domain" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a translation domain to use for translating
   the `--help` output for the options in @entries
   with gettext(), or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_option_context_free" version="2.6">
        <doc xml:space="preserve">Frees context and all the groups which have been
added to it.

Please note that parsed arguments need to be freed separately (see
#GOptionEntry).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="full">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description" c:identifier="g_option_context_get_description" version="2.12">
        <doc xml:space="preserve">Returns the description. See g_option_context_set_description().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the description</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_help" c:identifier="g_option_context_get_help" version="2.14">
        <doc xml:space="preserve">Returns a formatted, translated help text for the given context.
To obtain the text produced by `--help`, call
`g_option_context_get_help (context, TRUE, NULL)`.
To obtain the text produced by `--help-all`, call
`g_option_context_get_help (context, FALSE, NULL)`.
To obtain the help text for an option group, call
`g_option_context_get_help (context, FALSE, group)`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string containing the help text</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="main_help" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, only include the main group</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="group" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GOptionGroup to create help for, or %NULL</doc>
            <type name="OptionGroup" c:type="GOptionGroup*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_help_enabled" c:identifier="g_option_context_get_help_enabled" version="2.6">
        <doc xml:space="preserve">Returns whether automatic `--help` generation
is turned on for @context. See g_option_context_set_help_enabled().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if automatic help generation is turned on.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ignore_unknown_options" c:identifier="g_option_context_get_ignore_unknown_options" version="2.6">
        <doc xml:space="preserve">Returns whether unknown options are ignored or not. See
g_option_context_set_ignore_unknown_options().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if unknown options are ignored.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_main_group" c:identifier="g_option_context_get_main_group" version="2.6">
        <doc xml:space="preserve">Returns a pointer to the main group of @context.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the main group of @context, or %NULL if
 @context doesn't have a main group. Note that group belongs to
 @context and should not be modified or freed.</doc>
          <type name="OptionGroup" c:type="GOptionGroup*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_strict_posix" c:identifier="g_option_context_get_strict_posix" version="2.44">
        <doc xml:space="preserve">Returns whether strict POSIX code is enabled.

See g_option_context_set_strict_posix() for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if strict POSIX is enabled, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_summary" c:identifier="g_option_context_get_summary" version="2.12">
        <doc xml:space="preserve">Returns the summary. See g_option_context_set_summary().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the summary</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="parse" c:identifier="g_option_context_parse" version="2.6" throws="1">
        <doc xml:space="preserve">Parses the command line arguments, recognizing options
which have been added to @context. A side-effect of
calling this function is that g_set_prgname() will be
called.

If the parsing is successful, any parsed arguments are
removed from the array and @argc and @argv are updated
accordingly. A '--' option is stripped from @argv
unless there are unparsed options before and after it,
or some of the options after it start with '-'. In case
of an error, @argc and @argv are left unmodified.

If automatic `--help` support is enabled
(see g_option_context_set_help_enabled()), and the
@argv array contains one of the recognized help options,
this function will produce help output to stdout and
call `exit (0)`.

Note that function depends on the
[current locale](running.html#locale) for automatic
character set conversion of string and filename arguments.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the parsing was successful,
              %FALSE if an error occurred</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="argc" direction="inout" caller-allocates="0" transfer-ownership="full" optional="1">
            <doc xml:space="preserve">a pointer to the number of command line arguments</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="argv" direction="inout" caller-allocates="0" transfer-ownership="full" optional="1">
            <doc xml:space="preserve">a pointer to the array of command line arguments</doc>
            <array length="0" zero-terminated="0" c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="parse_strv" c:identifier="g_option_context_parse_strv" version="2.40" throws="1">
        <doc xml:space="preserve">Parses the command line arguments.

This function is similar to g_option_context_parse() except that it
respects the normal memory rules when dealing with a strv instead of
assuming that the passed-in array is the argv of the main function.

In particular, strings that are removed from the arguments list will
be freed using g_free().

On Windows, the strings are expected to be in UTF-8.  This is in
contrast to g_option_context_parse() which expects them to be in the
system codepage, which is how they are passed as @argv to main().
See g_win32_get_command_line() for a solution.

This function is useful if you are trying to use #GOptionContext with
#GApplication.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the parsing was successful,
         %FALSE if an error occurred</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="arguments" direction="inout" caller-allocates="0" transfer-ownership="full" optional="1">
            <doc xml:space="preserve">a pointer
   to the command line arguments (which must be in UTF-8 on Windows).
   Starting with GLib 2.62, @arguments can be %NULL, which matches
   g_option_context_parse().</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_description" c:identifier="g_option_context_set_description" version="2.12">
        <doc xml:space="preserve">Adds a string to be displayed in `--help` output after the list
of options. This text often includes a bug reporting address.

Note that the summary is translated (see
g_option_context_set_translate_func()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="description" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string to be shown in `--help` output
  after the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_help_enabled" c:identifier="g_option_context_set_help_enabled" version="2.6">
        <doc xml:space="preserve">Enables or disables automatic generation of `--help` output.
By default, g_option_context_parse() recognizes `--help`, `-h`,
`-?`, `--help-all` and `--help-groupname` and creates suitable
output to stdout.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="help_enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable `--help`, %FALSE to disable it</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ignore_unknown_options" c:identifier="g_option_context_set_ignore_unknown_options" version="2.6">
        <doc xml:space="preserve">Sets whether to ignore unknown options or not. If an argument is
ignored, it is left in the @argv array after parsing. By default,
g_option_context_parse() treats unknown options as error.

This setting does not affect non-option arguments (i.e. arguments
which don't start with a dash). But note that GOption cannot reliably
determine whether a non-option belongs to a preceding unknown option.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="ignore_unknown" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to ignore unknown options, %FALSE to produce
   an error when unknown options are met</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_main_group" c:identifier="g_option_context_set_main_group" version="2.6">
        <doc xml:space="preserve">Sets a #GOptionGroup as main group of the @context.
This has the same effect as calling g_option_context_add_group(),
the only difference is that the options in the main group are
treated differently when generating `--help` output.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="full">
            <doc xml:space="preserve">the group to set as main group</doc>
            <type name="OptionGroup" c:type="GOptionGroup*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_strict_posix" c:identifier="g_option_context_set_strict_posix" version="2.44">
        <doc xml:space="preserve">Sets strict POSIX mode.

By default, this mode is disabled.

In strict POSIX mode, the first non-argument parameter encountered
(eg: filename) terminates argument processing.  Remaining arguments
are treated as non-options and are not attempted to be parsed.

If strict POSIX mode is disabled then parsing is done in the GNU way
where option arguments can be freely mixed with non-options.

As an example, consider "ls foo -l".  With GNU style parsing, this
will list "foo" in long mode.  In strict POSIX style, this will list
the files named "foo" and "-l".

It may be useful to force strict POSIX mode when creating "verb
style" command line tools.  For example, the "gsettings" command line
tool supports the global option "--schemadir" as well as many
subcommands ("get", "set", etc.) which each have their own set of
arguments.  Using strict POSIX mode will allow parsing the global
options up to the verb name while leaving the remaining options to be
parsed by the relevant subcommand (which can be determined by
examining the verb name, which should be present in argv[1] after
parsing).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="strict_posix" transfer-ownership="none">
            <doc xml:space="preserve">the new value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_summary" c:identifier="g_option_context_set_summary" version="2.12">
        <doc xml:space="preserve">Adds a string to be displayed in `--help` output before the list
of options. This is typically a summary of the program functionality.

Note that the summary is translated (see
g_option_context_set_translate_func() and
g_option_context_set_translation_domain()).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="summary" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string to be shown in `--help` output
 before the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_translate_func" c:identifier="g_option_context_set_translate_func" version="2.12">
        <doc xml:space="preserve">Sets the function which is used to translate the contexts
user-visible strings, for `--help` output. If @func is %NULL,
strings are not translated.

Note that option groups have their own translation functions,
this function only affects the @parameter_string (see g_option_context_new()),
the summary (see g_option_context_set_summary()) and the description
(see g_option_context_set_description()).

If you are using gettext(), you only need to set the translation
domain, see g_option_context_set_translation_domain().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">the #GTranslateFunc, or %NULL</doc>
            <type name="TranslateFunc" c:type="GTranslateFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @func, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function which gets called to free @data, or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_translation_domain" c:identifier="g_option_context_set_translation_domain" version="2.12">
        <doc xml:space="preserve">A convenience function to use gettext() for translating
user-visible strings.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the domain to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_option_context_new" version="2.6" introspectable="0">
        <doc xml:space="preserve">Creates a new option context.

The @parameter_string can serve multiple purposes. It can be used
to add descriptions for "rest" arguments, which are not parsed by
the #GOptionContext, typically something like "FILES" or
"FILE1 FILE2...". If you are using %G_OPTION_REMAINING for
collecting "rest" arguments, GLib handles this automatically by
using the @arg_description of the corresponding #GOptionEntry in
the usage summary.

Another usage is to give a short summary of the program
functionality, like " - frob the strings", which will be displayed
in the same line as the usage. For a longer description of the
program functionality that should be displayed as a paragraph
below the usage line, use g_option_context_set_summary().

Note that the @parameter_string is translated using the
function set with g_option_context_set_translate_func(), so
it should normally be passed untranslated.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #GOptionContext, which must be
   freed with g_option_context_free() after use.</doc>
          <type name="OptionContext" c:type="GOptionContext*"/>
        </return-value>
        <parameters>
          <parameter name="parameter_string" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string which is displayed in
   the first line of `--help` output, after the usage summary
   `programname [OPTION...]`</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="OptionEntry" c:type="GOptionEntry">
      <doc xml:space="preserve">- %G_OPTION_ARG_NONE: %gboolean
    - %G_OPTION_ARG_STRING: %gchar*
    - %G_OPTION_ARG_INT: %gint
    - %G_OPTION_ARG_FILENAME: %gchar*
    - %G_OPTION_ARG_STRING_ARRAY: %gchar**
    - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**
    - %G_OPTION_ARG_DOUBLE: %gdouble

    If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,
    the location will contain a newly allocated string if the option
    was given. That string needs to be freed by the callee using g_free().
    Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or
    %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().
A GOptionEntry struct defines a single option. To have an effect, they
must be added to a #GOptionGroup with g_option_context_add_main_entries()
or g_option_group_add_entries().</doc>
      <field name="long_name" writable="1">
        <doc xml:space="preserve">The long name of an option can be used to specify it
    in a commandline as `--long_name`. Every option must have a
    long name. To resolve conflicts if multiple option groups contain
    the same long name, it is also possible to specify the option as
    `--groupname-long_name`.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="short_name" writable="1">
        <doc xml:space="preserve">If an option has a short name, it can be specified
    `-short_name` in a commandline. @short_name must be  a printable
    ASCII character different from '-', or zero if the option has no
    short name.</doc>
        <type name="gchar" c:type="gchar"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">Flags from #GOptionFlags</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="arg" writable="1">
        <doc xml:space="preserve">The type of the option, as a #GOptionArg</doc>
        <type name="OptionArg" c:type="GOptionArg"/>
      </field>
      <field name="arg_data" writable="1">
        <doc xml:space="preserve">If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data
    must point to a #GOptionArgFunc callback function, which will be
    called to handle the extra argument. Otherwise, @arg_data is a
    pointer to a location to store the value, the required type of
    the location depends on the @arg type:</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="description" writable="1">
        <doc xml:space="preserve">the description for the option in `--help`
    output. The @description is translated using the @translate_func
    of the group, see g_option_group_set_translation_domain().</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="arg_description" writable="1">
        <doc xml:space="preserve">The placeholder to use for the extra argument parsed
    by the option in `--help` output. The @arg_description is translated
    using the @translate_func of the group, see
    g_option_group_set_translation_domain().</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
    </record>
    <enumeration name="OptionError" c:type="GOptionError" glib:error-domain="g-option-error-quark">
      <doc xml:space="preserve">Error codes returned by option parsing.</doc>
      <member name="unknown_option" value="0" c:identifier="G_OPTION_ERROR_UNKNOWN_OPTION">
        <doc xml:space="preserve">An option was not known to the parser.
 This error will only be reported, if the parser hasn't been instructed
 to ignore unknown options, see g_option_context_set_ignore_unknown_options().</doc>
      </member>
      <member name="bad_value" value="1" c:identifier="G_OPTION_ERROR_BAD_VALUE">
        <doc xml:space="preserve">A value couldn't be parsed.</doc>
      </member>
      <member name="failed" value="2" c:identifier="G_OPTION_ERROR_FAILED">
        <doc xml:space="preserve">A #GOptionArgFunc callback failed.</doc>
      </member>
    </enumeration>
    <callback name="OptionErrorFunc" c:type="GOptionErrorFunc" throws="1">
      <doc xml:space="preserve">The type of function to be used as callback when a parse error occurs.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">The active #GOptionContext</doc>
          <type name="OptionContext" c:type="GOptionContext*"/>
        </parameter>
        <parameter name="group" transfer-ownership="none">
          <doc xml:space="preserve">The group to which the function belongs</doc>
          <type name="OptionGroup" c:type="GOptionGroup*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">User data added to the #GOptionGroup containing the option when it
 was created with g_option_group_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="OptionFlags" c:type="GOptionFlags">
      <doc xml:space="preserve">Flags which modify individual options.</doc>
      <member name="none" value="0" c:identifier="G_OPTION_FLAG_NONE" version="2.42">
        <doc xml:space="preserve">No flags.</doc>
      </member>
      <member name="hidden" value="1" c:identifier="G_OPTION_FLAG_HIDDEN">
        <doc xml:space="preserve">The option doesn't appear in `--help` output.</doc>
      </member>
      <member name="in_main" value="2" c:identifier="G_OPTION_FLAG_IN_MAIN">
        <doc xml:space="preserve">The option appears in the main section of the
  `--help` output, even if it is defined in a group.</doc>
      </member>
      <member name="reverse" value="4" c:identifier="G_OPTION_FLAG_REVERSE">
        <doc xml:space="preserve">For options of the %G_OPTION_ARG_NONE kind, this
  flag indicates that the sense of the option is reversed. i.e. %FALSE will
  be stored into the argument rather than %TRUE.</doc>
      </member>
      <member name="no_arg" value="8" c:identifier="G_OPTION_FLAG_NO_ARG">
        <doc xml:space="preserve">For options of the %G_OPTION_ARG_CALLBACK kind,
  this flag indicates that the callback does not take any argument
  (like a %G_OPTION_ARG_NONE option). Since 2.8</doc>
      </member>
      <member name="filename" value="16" c:identifier="G_OPTION_FLAG_FILENAME">
        <doc xml:space="preserve">For options of the %G_OPTION_ARG_CALLBACK
  kind, this flag indicates that the argument should be passed to the
  callback in the GLib filename encoding rather than UTF-8. Since 2.8</doc>
      </member>
      <member name="optional_arg" value="32" c:identifier="G_OPTION_FLAG_OPTIONAL_ARG">
        <doc xml:space="preserve">For options of the %G_OPTION_ARG_CALLBACK
  kind, this flag indicates that the argument supply is optional.
  If no argument is given then data of %GOptionParseFunc will be
  set to NULL. Since 2.8</doc>
      </member>
      <member name="noalias" value="64" c:identifier="G_OPTION_FLAG_NOALIAS">
        <doc xml:space="preserve">This flag turns off the automatic conflict
  resolution which prefixes long option names with `groupname-` if
  there is a conflict. This option should only be used in situations
  where aliasing is necessary to model some legacy commandline interface.
  It is not safe to use this option, unless all option groups are under
  your direct control. Since 2.8.</doc>
      </member>
      <member name="deprecated" value="128" c:identifier="G_OPTION_FLAG_DEPRECATED" version="2.84">
        <doc xml:space="preserve">This flag marks the option as deprecated in the `--help`.

You should update the description of the option to describe what
the user should do in response to the deprecation, for instance:
remove the option, or replace it with another one.</doc>
      </member>
    </bitfield>
    <record name="OptionGroup" c:type="GOptionGroup" opaque="1" glib:type-name="GOptionGroup" glib:get-type="g_option_group_get_type" c:symbol-prefix="option_group">
      <doc xml:space="preserve">A `GOptionGroup` struct defines the options in a single
group. The struct has only private fields and should not be directly accessed.

All options in a group share the same translation function. Libraries which
need to parse commandline options are expected to provide a function for
getting a `GOptionGroup` holding their options, which
the application can then add to its #GOptionContext.</doc>
      <constructor name="new" c:identifier="g_option_group_new" version="2.6">
        <doc xml:space="preserve">Creates a new #GOptionGroup.

@description is typically used to provide a title for the group. If so, it
is recommended that it&#x2019;s written in title case, and has a trailing colon so
that it matches the style of built-in GLib group titles such as
&#x2018;Application Options:&#x2019;.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created option group. It should be added
  to a #GOptionContext or freed with g_option_group_unref().</doc>
          <type name="OptionGroup" c:type="GOptionGroup*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name for the option group, this is used to provide
  help for the options in this group with `--help-`@name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">a description for this group to be shown in
  `--help`. This string is translated using the translation
  domain or translation function of the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="help_description" transfer-ownership="none">
            <doc xml:space="preserve">a description for the `--help-`@name option.
  This string is translated using the translation domain or translation function
  of the group</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data that will be passed to the pre- and post-parse hooks,
  the error hook and to callbacks of %G_OPTION_ARG_CALLBACK options, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function that will be called to free @user_data, or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_entries" c:identifier="g_option_group_add_entries" version="2.6">
        <doc xml:space="preserve">Adds the options specified in @entries to @group.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*"/>
          </instance-parameter>
          <parameter name="entries" transfer-ownership="none">
            <doc xml:space="preserve">a %NULL-terminated array of #GOptionEntrys</doc>
            <array c:type="const GOptionEntry*">
              <type name="OptionEntry" c:type="GOptionEntry"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_option_group_free" version="2.6" deprecated="1" deprecated-version="2.44">
        <doc xml:space="preserve">Frees a #GOptionGroup. Note that you must not free groups
which have been added to a #GOptionContext.</doc>
        <doc-deprecated xml:space="preserve">Use g_option_group_unref() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_option_group_ref" version="2.44">
        <doc xml:space="preserve">Increments the reference count of @group by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GOptionGroup</doc>
          <type name="OptionGroup" c:type="GOptionGroup*"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_error_hook" c:identifier="g_option_group_set_error_hook" version="2.6" introspectable="0">
        <doc xml:space="preserve">Associates a function with @group which will be called
from g_option_context_parse() when an error occurs.

Note that the user data to be passed to @error_func can be
specified when constructing the group with g_option_group_new().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*"/>
          </instance-parameter>
          <parameter name="error_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to call when an error occurs</doc>
            <type name="OptionErrorFunc" c:type="GOptionErrorFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parse_hooks" c:identifier="g_option_group_set_parse_hooks" version="2.6" introspectable="0">
        <doc xml:space="preserve">Associates two functions with @group which will be called
from g_option_context_parse() before the first option is parsed
and after the last option has been parsed, respectively.

Note that the user data to be passed to @pre_parse_func and
@post_parse_func can be specified when constructing the group
with g_option_group_new().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*"/>
          </instance-parameter>
          <parameter name="pre_parse_func" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a function to call before parsing, or %NULL</doc>
            <type name="OptionParseFunc" c:type="GOptionParseFunc"/>
          </parameter>
          <parameter name="post_parse_func" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a function to call after parsing, or %NULL</doc>
            <type name="OptionParseFunc" c:type="GOptionParseFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_translate_func" c:identifier="g_option_group_set_translate_func" version="2.6">
        <doc xml:space="preserve">Sets the function which is used to translate user-visible strings,
for `--help` output. Different groups can use different
#GTranslateFuncs. If @func is %NULL, strings are not translated.

If you are using gettext(), you only need to set the translation
domain, see g_option_group_set_translation_domain().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">the #GTranslateFunc, or %NULL</doc>
            <type name="TranslateFunc" c:type="GTranslateFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @func, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function which gets called to free @data, or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_translation_domain" c:identifier="g_option_group_set_translation_domain" version="2.6">
        <doc xml:space="preserve">A convenience function to use gettext() for translating
user-visible strings.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the domain to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_option_group_unref" version="2.44">
        <doc xml:space="preserve">Decrements the reference count of @group by one.
If the reference count drops to 0, the @group will be freed.
and all memory allocated by the @group is released.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="OptionParseFunc" c:type="GOptionParseFunc" throws="1">
      <doc xml:space="preserve">The type of function that can be called before and after parsing.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the function completed successfully, %FALSE if an error
 occurred, in which case @error should be set with g_set_error()</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">The active #GOptionContext</doc>
          <type name="OptionContext" c:type="GOptionContext*"/>
        </parameter>
        <parameter name="group" transfer-ownership="none">
          <doc xml:space="preserve">The group to which the function belongs</doc>
          <type name="OptionGroup" c:type="GOptionGroup*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">User data added to the #GOptionGroup containing the option when it
 was created with g_option_group_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="PASTE" c:identifier="G_PASTE" version="2.20" introspectable="0">
      <doc xml:space="preserve">Yields a new preprocessor pasted identifier
@identifier1identifier2 from its expanded
arguments @identifier1 and @identifier2. For example,
the following code:
|[&lt;!-- language="C" --&gt;
#define GET(traveller,method) G_PASTE(traveller_get_, method) (traveller)
const gchar *name = GET (traveller, name);
const gchar *quest = GET (traveller, quest);
GdkColor *favourite = GET (traveller, favourite_colour);
]|

is transformed by the preprocessor into:
|[&lt;!-- language="C" --&gt;
const gchar *name = traveller_get_name (traveller);
const gchar *quest = traveller_get_quest (traveller);
GdkColor *favourite = traveller_get_favourite_colour (traveller);
]|</doc>
      <parameters>
        <parameter name="identifier1">
          <doc xml:space="preserve">an identifier</doc>
        </parameter>
        <parameter name="identifier2">
          <doc xml:space="preserve">an identifier</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PASTE_ARGS" c:identifier="G_PASTE_ARGS" introspectable="0">
      <parameters>
        <parameter name="identifier1">
        </parameter>
        <parameter name="identifier2">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="PDP_ENDIAN" value="3412" c:type="G_PDP_ENDIAN">
      <doc xml:space="preserve">Specifies one of the possible types of byte order
(currently unused). See %G_BYTE_ORDER.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PI" value="3.141593" c:type="G_PI">
      <doc xml:space="preserve">The value of pi (ratio of circle's circumference to its diameter).</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="PID_FORMAT" value="i" c:type="G_PID_FORMAT" version="2.50">
      <doc xml:space="preserve">A format specifier that can be used in printf()-style format strings
when printing a #GPid.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PI_2" value="1.570796" c:type="G_PI_2">
      <doc xml:space="preserve">Pi divided by 2.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="PI_4" value="0.785398" c:type="G_PI_4">
      <doc xml:space="preserve">Pi divided by 4.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="POLLFD_FORMAT" value="%d" c:type="G_POLLFD_FORMAT">
      <doc xml:space="preserve">A format specifier that can be used in printf()-style format strings
when printing the @fd member of a #GPollFD.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PRIORITY_DEFAULT" value="0" c:type="G_PRIORITY_DEFAULT">
      <doc xml:space="preserve">Use this for default priority event sources.

In GLib this priority is used when adding timeout functions
with [func@GLib.timeout_add]. In GDK this priority is used for events
from the X server.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PRIORITY_DEFAULT_IDLE" value="200" c:type="G_PRIORITY_DEFAULT_IDLE">
      <doc xml:space="preserve">Use this for default priority idle functions.

In GLib this priority is used when adding idle functions with
[func@GLib.idle_add].</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PRIORITY_HIGH" value="-100" c:type="G_PRIORITY_HIGH">
      <doc xml:space="preserve">Use this for high priority event sources.

It is not used within GLib or GTK.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PRIORITY_HIGH_IDLE" value="100" c:type="G_PRIORITY_HIGH_IDLE">
      <doc xml:space="preserve">Use this for high priority idle functions.

GTK uses %G_PRIORITY_HIGH_IDLE + 10 for resizing operations,
and %G_PRIORITY_HIGH_IDLE + 20 for redrawing operations. (This is
done to ensure that any pending resizes are processed before any
pending redraws, so that widgets are not redrawn twice unnecessarily.)</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PRIORITY_LOW" value="300" c:type="G_PRIORITY_LOW">
      <doc xml:space="preserve">Use this for very low priority background tasks.

It is not used within GLib or GTK.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="PRIVATE_INIT" c:identifier="G_PRIVATE_INIT" version="2.32" introspectable="0">
      <doc xml:space="preserve">A macro to assist with the static initialisation of a #GPrivate.

This macro is useful for the case that a #GDestroyNotify function
should be associated with the key.  This is needed when the key will be
used to point at memory that should be deallocated when the thread
exits.

Additionally, the #GDestroyNotify will also be called on the previous
value stored in the key when g_private_replace() is used.

If no #GDestroyNotify is needed, then use of this macro is not
required -- if the #GPrivate is declared in static scope then it will
be properly initialised by default (ie: to all zeros).  See the
examples below.

|[&lt;!-- language="C" --&gt;
static GPrivate name_key = G_PRIVATE_INIT (g_free);

// return value should not be freed
const gchar *
get_local_name (void)
{
  return g_private_get (&amp;name_key);
}

void
set_local_name (const gchar *name)
{
  g_private_replace (&amp;name_key, g_strdup (name));
}


static GPrivate count_key;   // no free function

gint
get_local_count (void)
{
  return GPOINTER_TO_INT (g_private_get (&amp;count_key));
}

void
set_local_count (gint count)
{
  g_private_set (&amp;count_key, GINT_TO_POINTER (count));
}
]|</doc>
      <parameters>
        <parameter name="notify">
          <doc xml:space="preserve">a #GDestroyNotify</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="PathBuf" c:type="GPathBuf" version="2.76">
      <doc xml:space="preserve">`GPathBuf` is a helper type that allows you to easily build paths from
individual elements, using the platform specific conventions for path
separators.

```c
g_auto (GPathBuf) path;

g_path_buf_init (&amp;path);

g_path_buf_push (&amp;path, "usr");
g_path_buf_push (&amp;path, "bin");
g_path_buf_push (&amp;path, "echo");

g_autofree char *echo = g_path_buf_to_path (&amp;path);
g_assert_cmpstr (echo, ==, "/usr/bin/echo");
```

You can also load a full path and then operate on its components:

```c
g_auto (GPathBuf) path;

g_path_buf_init_from_path (&amp;path, "/usr/bin/echo");

g_path_buf_pop (&amp;path);
g_path_buf_push (&amp;path, "sh");

g_autofree char *sh = g_path_buf_to_path (&amp;path);
g_assert_cmpstr (sh, ==, "/usr/bin/sh");
```</doc>
      <field name="dummy" readable="0" private="1">
        <array zero-terminated="0" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="clear" c:identifier="g_path_buf_clear" version="2.76">
        <doc xml:space="preserve">Clears the contents of the path buffer.

This function should be use to free the resources in a stack-allocated
`GPathBuf` initialized using g_path_buf_init() or
g_path_buf_init_from_path().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_to_path" c:identifier="g_path_buf_clear_to_path" version="2.76">
        <doc xml:space="preserve">Clears the contents of the path buffer and returns the built path.

This function returns `NULL` if the `GPathBuf` is empty.

See also: g_path_buf_to_path()</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the built path</doc>
          <type name="filename" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="g_path_buf_copy" version="2.76" introspectable="0">
        <doc xml:space="preserve">Copies the contents of a path buffer into a new `GPathBuf`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated path buffer</doc>
          <type name="PathBuf" c:type="GPathBuf*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_path_buf_free" version="2.76">
        <doc xml:space="preserve">Frees a `GPathBuf` allocated by g_path_buf_new().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="full">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_to_path" c:identifier="g_path_buf_free_to_path" version="2.76">
        <doc xml:space="preserve">Frees a `GPathBuf` allocated by g_path_buf_new(), and
returns the path inside the buffer.

This function returns `NULL` if the `GPathBuf` is empty.

See also: g_path_buf_to_path()</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the path</doc>
          <type name="filename" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="full">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_path_buf_init" version="2.76">
        <doc xml:space="preserve">Initializes a `GPathBuf` instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized path builder</doc>
          <type name="PathBuf" c:type="GPathBuf*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_from_path" c:identifier="g_path_buf_init_from_path" version="2.76">
        <doc xml:space="preserve">Initializes a `GPathBuf` instance with the given path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized path builder</doc>
          <type name="PathBuf" c:type="GPathBuf*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a file system path</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="g_path_buf_pop" version="2.76">
        <doc xml:space="preserve">Removes the last element of the path buffer.

If there is only one element in the path buffer (for example, `/` on
Unix-like operating systems or the drive on Windows systems), it will
not be removed and %FALSE will be returned instead.

|[&lt;!-- language="C" --&gt;
GPathBuf buf, cmp;

g_path_buf_init_from_path (&amp;buf, "/bin/sh");

g_path_buf_pop (&amp;buf);
g_path_buf_init_from_path (&amp;cmp, "/bin");
g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
g_path_buf_clear (&amp;cmp);

g_path_buf_pop (&amp;buf);
g_path_buf_init_from_path (&amp;cmp, "/");
g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
g_path_buf_clear (&amp;cmp);

g_path_buf_clear (&amp;buf);
]|</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the buffer was modified and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="g_path_buf_push" version="2.76">
        <doc xml:space="preserve">Extends the given path buffer with @path.

If @path is absolute, it replaces the current path.

If @path contains a directory separator, the buffer is extended by
as many elements the path provides.

On Windows, both forward slashes and backslashes are treated as
directory separators. On other platforms, %G_DIR_SEPARATOR_S is the
only directory separator.

|[&lt;!-- language="C" --&gt;
GPathBuf buf, cmp;

g_path_buf_init_from_path (&amp;buf, "/tmp");
g_path_buf_push (&amp;buf, ".X11-unix/X0");
g_path_buf_init_from_path (&amp;cmp, "/tmp/.X11-unix/X0");
g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
g_path_buf_clear (&amp;cmp);

g_path_buf_push (&amp;buf, "/etc/locale.conf");
g_path_buf_init_from_path (&amp;cmp, "/etc/locale.conf");
g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
g_path_buf_clear (&amp;cmp);

g_path_buf_clear (&amp;buf);
]|</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same pointer to @buf, for convenience</doc>
          <type name="PathBuf" c:type="GPathBuf*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a path</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_extension" c:identifier="g_path_buf_set_extension" version="2.76">
        <doc xml:space="preserve">Adds an extension to the file name in the path buffer.

If @extension is `NULL`, the extension will be unset.

If the path buffer does not have a file name set, this function returns
`FALSE` and leaves the path buffer unmodified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the extension was replaced, and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
          <parameter name="extension" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the file extension</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_filename" c:identifier="g_path_buf_set_filename" version="2.76">
        <doc xml:space="preserve">Sets the file name of the path.

If the path buffer is empty, the filename is left unset and this
function returns `FALSE`.

If the path buffer only contains the root element (on Unix-like operating
systems) or the drive (on Windows), this is the equivalent of pushing
the new @file_name.

If the path buffer contains a path, this is the equivalent of
popping the path buffer and pushing @file_name, creating a
sibling of the original path.

|[&lt;!-- language="C" --&gt;
GPathBuf buf, cmp;

g_path_buf_init_from_path (&amp;buf, "/");

g_path_buf_set_filename (&amp;buf, "bar");
g_path_buf_init_from_path (&amp;cmp, "/bar");
g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp));
g_path_buf_clear (&amp;cmp);

g_path_buf_set_filename (&amp;buf, "baz.txt");
g_path_buf_init_from_path (&amp;cmp, "/baz.txt");
g_assert_true (g_path_buf_equal (&amp;buf, &amp;cmp);
g_path_buf_clear (&amp;cmp);

g_path_buf_clear (&amp;buf);
]|</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the file name was replaced, and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
          <parameter name="file_name" transfer-ownership="none">
            <doc xml:space="preserve">the file name in the path</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_path" c:identifier="g_path_buf_to_path" version="2.76">
        <doc xml:space="preserve">Retrieves the built path from the path buffer.

On Windows, the result contains backslashes as directory separators,
even if forward slashes were used in input.

If the path buffer is empty, this function returns `NULL`.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the path</doc>
          <type name="filename" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer</doc>
            <type name="PathBuf" c:type="GPathBuf*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="equal" c:identifier="g_path_buf_equal" version="2.76">
        <doc xml:space="preserve">Compares two path buffers for equality and returns `TRUE`
if they are equal.

The paths inside the path buffers are not going to be normalized,
so `X/Y/Z/A/..`, `X/./Y/Z` and `X/Y/Z` are not going to be considered
equal.

This function can be passed to g_hash_table_new() as the
`key_equal_func` parameter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the two path buffers are equal,
  and `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer to compare</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">a path buffer to compare</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="g_path_buf_new" version="2.76" introspectable="0">
        <doc xml:space="preserve">Allocates a new `GPathBuf`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated path buffer</doc>
          <type name="PathBuf" c:type="GPathBuf*"/>
        </return-value>
      </function>
      <function name="new_from_path" c:identifier="g_path_buf_new_from_path" version="2.76" introspectable="0">
        <doc xml:space="preserve">Allocates a new `GPathBuf` with the given @path.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated path buffer</doc>
          <type name="PathBuf" c:type="GPathBuf*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the path used to initialize the buffer</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PatternSpec" c:type="GPatternSpec" opaque="1" glib:type-name="GPatternSpec" glib:get-type="g_pattern_spec_get_type" c:symbol-prefix="pattern_spec">
      <doc xml:space="preserve">A `GPatternSpec` struct is the &#x2018;compiled&#x2019; form of a glob-style pattern.

The [func@GLib.pattern_match_simple] and [method@GLib.PatternSpec.match] functions
match a string against a pattern containing `*` and `?` wildcards with similar
semantics as the standard `glob()` function: `*` matches an arbitrary,
possibly empty, string, `?` matches an arbitrary character.

Note that in contrast to [`glob()`](man:glob(3)), the `/` character can be
matched by the wildcards, there are no `[&#x2026;]` character ranges and `*` and `?`
can not be escaped to include them literally in a pattern.

When multiple strings must be matched against the same pattern, it is better
to compile the pattern to a [struct@GLib.PatternSpec] using
[ctor@GLib.PatternSpec.new] and use [method@GLib.PatternSpec.match_string]
instead of [func@GLib.pattern_match_simple]. This avoids the overhead of repeated
pattern compilation.</doc>
      <constructor name="new" c:identifier="g_pattern_spec_new">
        <doc xml:space="preserve">Compiles a pattern to a [type@GLib.PatternSpec].</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated [type@GLib.PatternSpec]</doc>
          <type name="PatternSpec" c:type="GPatternSpec*"/>
        </return-value>
        <parameters>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve">a zero-terminated UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="g_pattern_spec_copy" version="2.70">
        <doc xml:space="preserve">Copies @pspec in a new [type@GLib.PatternSpec].</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @pspec.</doc>
          <type name="PatternSpec" c:type="GPatternSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a #GPatternSpec</doc>
            <type name="PatternSpec" c:type="GPatternSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="g_pattern_spec_equal">
        <doc xml:space="preserve">Compares two compiled pattern specs and returns whether they will
match the same set of strings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the compiled patterns are equal</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec1" transfer-ownership="none">
            <doc xml:space="preserve">a #GPatternSpec</doc>
            <type name="PatternSpec" c:type="GPatternSpec*"/>
          </instance-parameter>
          <parameter name="pspec2" transfer-ownership="none">
            <doc xml:space="preserve">another #GPatternSpec</doc>
            <type name="PatternSpec" c:type="GPatternSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_pattern_spec_free">
        <doc xml:space="preserve">Frees the memory allocated for the [type@GLib.PatternSpec].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a #GPatternSpec</doc>
            <type name="PatternSpec" c:type="GPatternSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="match" c:identifier="g_pattern_spec_match" version="2.70">
        <doc xml:space="preserve">Matches a string against a compiled pattern.

Passing the correct
length of the string given is mandatory. The reversed string can be
omitted by passing `NULL`, this is more efficient if the reversed
version of the string to be matched is not at hand, as
[method@GLib.PatternSpec.match] will only construct it if the compiled pattern
requires reverse matches.

Note that, if the user code will (possibly) match a string against a
multitude of patterns containing wildcards, chances are high that
some patterns will require a reversed string. In this case, it&#x2019;s
more efficient to provide the reversed string to avoid multiple
constructions thereof in the various calls to [method@GLib.PatternSpec.match].

Note also that the reverse of a UTF-8 encoded string can in general
not be obtained by [func@GLib.strreverse]. This works only if the string
does not contain any multibyte characters. GLib offers the
[func@GLib.utf8_strreverse] function to reverse UTF-8 encoded strings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @string matches @pspec</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a #GPatternSpec</doc>
            <type name="PatternSpec" c:type="GPatternSpec*"/>
          </instance-parameter>
          <parameter name="string_length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @string (in bytes, i.e. `strlen()`,
   not [func@GLib.utf8_strlen])</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the UTF-8 encoded string to match</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="string_reversed" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the reverse of @string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="match_string" c:identifier="g_pattern_spec_match_string" version="2.70">
        <doc xml:space="preserve">Matches a string against a compiled pattern.

If the string is to be
matched against more than one pattern, consider using
[method@GLib.PatternSpec.match] instead while supplying the reversed string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @string matches @pspec</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a #GPatternSpec</doc>
            <type name="PatternSpec" c:type="GPatternSpec*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the UTF-8 encoded string to match</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="PollFD" c:type="GPollFD" glib:type-name="GPollFD" glib:get-type="g_pollfd_get_type" c:symbol-prefix="pollfd">
      <doc xml:space="preserve">Represents a file descriptor, which events to poll for, and which events
occurred.</doc>
      <field name="fd" writable="1">
        <doc xml:space="preserve">the file descriptor to poll (or a HANDLE on Win32)</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="events" writable="1">
        <doc xml:space="preserve">a bitwise combination from #GIOCondition, specifying which
    events should be polled for. Typically for reading from a file
    descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and
    for writing you would use %G_IO_OUT | %G_IO_ERR.</doc>
        <type name="gushort" c:type="gushort"/>
      </field>
      <field name="revents" writable="1">
        <doc xml:space="preserve">a bitwise combination of flags from #GIOCondition, returned
    from the poll() function to indicate which events occurred.</doc>
        <type name="gushort" c:type="gushort"/>
      </field>
    </record>
    <callback name="PollFunc" c:type="GPollFunc">
      <doc xml:space="preserve">Specifies the type of function passed to g_main_context_set_poll_func().
The semantics of the function should match those of the poll() system call.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of #GPollFD elements which have events or errors
    reported, or -1 if an error occurred.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="ufds" transfer-ownership="none">
          <doc xml:space="preserve">an array of #GPollFD elements</doc>
          <type name="PollFD" c:type="GPollFD*"/>
        </parameter>
        <parameter name="nfsd" transfer-ownership="none">
          <doc xml:space="preserve">the number of elements in @ufds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="timeout_" transfer-ownership="none">
          <doc xml:space="preserve">the maximum time to wait for an event of the file descriptors.
    A negative value indicates an infinite timeout.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PrintFunc" c:type="GPrintFunc">
      <doc xml:space="preserve">Specifies the type of the print handler functions.
These are called with the complete formatted string to output.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the message to output</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Private" c:type="GPrivate">
      <doc xml:space="preserve">The #GPrivate struct is an opaque data structure to represent a
thread-local data key. It is approximately equivalent to the
pthread_setspecific()/pthread_getspecific() APIs on POSIX and to
TlsSetValue()/TlsGetValue() on Windows.

If you don't already know why you might want this functionality,
then you probably don't need it.

#GPrivate is a very limited resource (as far as 128 per program,
shared between all libraries). It is also not possible to destroy a
#GPrivate after it has been used. As such, it is only ever acceptable
to use #GPrivate in static scope, and even then sparingly so.

See G_PRIVATE_INIT() for a couple of examples.

The #GPrivate structure should be considered opaque.  It should only
be accessed via the g_private_ functions.</doc>
      <field name="p" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="notify" readable="0" private="1">
        <type name="DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="future" readable="0" private="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="get" c:identifier="g_private_get">
        <doc xml:space="preserve">Returns the current value of the thread local variable @key.

If the value has not yet been set in this thread, %NULL is returned.
Values are never copied between threads (when a new thread is
created, for example).</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the thread-local value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GPrivate</doc>
            <type name="Private" c:type="GPrivate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="replace" c:identifier="g_private_replace" version="2.32">
        <doc xml:space="preserve">Sets the thread local variable @key to have the value @value in the
current thread.

This function differs from g_private_set() in the following way: if
the previous value was non-%NULL then the #GDestroyNotify handler for
@key is run on it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GPrivate</doc>
            <type name="Private" c:type="GPrivate*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the new value</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="g_private_set">
        <doc xml:space="preserve">Sets the thread local variable @key to have the value @value in the
current thread.

This function differs from g_private_replace() in the following way:
the #GDestroyNotify for @key is not called on the old value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a #GPrivate</doc>
            <type name="Private" c:type="GPrivate*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the new value</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_private_new" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Creates a new #GPrivate.</doc>
        <doc-deprecated xml:space="preserve">dynamic allocation of #GPrivate is a bad idea.  Use
                 static storage and G_PRIVATE_INIT() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GPrivate (which can never be destroyed)</doc>
          <type name="Private" c:type="GPrivate*"/>
        </return-value>
        <parameters>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PtrArray" c:type="GPtrArray" copy-function="g_ptr_array_ref" free-function="g_ptr_array_unref" glib:type-name="GPtrArray" glib:get-type="g_ptr_array_get_type" c:symbol-prefix="ptr_array">
      <doc xml:space="preserve">Contains the public fields of a `GPtrArray`.</doc>
      <field name="pdata" writable="1">
        <doc xml:space="preserve">a pointer to the array of pointers, which may be moved when the
    array grows</doc>
        <type name="gpointer" c:type="gpointer*"/>
      </field>
      <field name="len" writable="1">
        <doc xml:space="preserve">the number of pointers in the array</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <function name="add" c:identifier="g_ptr_array_add" introspectable="0">
        <doc xml:space="preserve">Adds a pointer to the end of the pointer array. The array will grow
in size automatically if necessary.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the pointer to add</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="copy" c:identifier="g_ptr_array_copy" version="2.62" introspectable="0">
        <doc xml:space="preserve">Makes a full (deep) copy of a `GPtrArray`.

@func, as a [callback@GLib.CopyFunc], takes two arguments, the data to be
copied
and a @user_data pointer. On common processor architectures, it&#x2019;s safe to
pass `NULL` as @user_data if the copy function takes only one argument. You
may get compiler warnings from this though if compiling with GCC&#x2019;s
`-Wcast-function-type` warning.

If @func is `NULL`, then only the pointers (and not what they are
pointing to) are copied to the new `GPtrArray`.

The copy of @array will have the same [callback@GLib.DestroyNotify] for its
elements as
@array. The copy will also be `NULL` terminated if (and only if) the source
array is.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The deep copy of the initial `GPtrArray`</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array to duplicate</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="2">
            <doc xml:space="preserve">a copy function used to copy every element in the array</doc>
            <type name="CopyFunc" c:type="GCopyFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user data passed to the copy function @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="extend" c:identifier="g_ptr_array_extend" version="2.62" introspectable="0">
        <doc xml:space="preserve">Adds all pointers of @array to the end of the array @array_to_extend.
The array will grow in size automatically if needed. @array_to_extend is
modified in-place.

@func, as a [callback@GLib.CopyFunc], takes two arguments, the data to be
copied
and a @user_data pointer. On common processor architectures, it&#x2019;s safe to
pass `NULL` as @user_data if the copy function takes only one argument. You
may get compiler warnings from this though if compiling with GCC&#x2019;s
`-Wcast-function-type` warning.

If @func is `NULL`, then only the pointers (and not what they are
pointing to) are copied to the new `GPtrArray`.

Whether @array_to_extend is `NULL` terminated stays unchanged by this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array_to_extend" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array to add to the end of @array_to_extend</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="3">
            <doc xml:space="preserve">a copy function used to copy every element in the array</doc>
            <type name="CopyFunc" c:type="GCopyFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user data passed to the copy function @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="extend_and_steal" c:identifier="g_ptr_array_extend_and_steal" version="2.62" introspectable="0">
        <doc xml:space="preserve">Adds all the pointers in @array to the end of @array_to_extend, transferring
ownership of each element from @array to @array_to_extend and modifying
@array_to_extend in-place. @array is then freed.

As with [func@GLib.PtrArray.free], @array will be destroyed if its reference
count is 1. If its reference count is higher, it will be decremented and the
length of @array set to zero.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array_to_extend" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="array" transfer-ownership="container">
            <doc xml:space="preserve">a pointer array to add to the end of
    @array_to_extend</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="find" c:identifier="g_ptr_array_find" version="2.54" introspectable="0">
        <doc xml:space="preserve">Checks whether @needle exists in @haystack. If the element is found, true
is returned and the element&#x2019;s index is returned in @index_ (if non-`NULL`).
Otherwise, false is returned and @index_ is undefined. If @needle exists
multiple times in @haystack, the index of the first instance is returned.

This does pointer comparisons only. If you want to use more complex equality
checks, such as string comparisons, use
[func@GLib.PtrArray.find_with_equal_func].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @needle is one of the elements of @haystack; false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="haystack" transfer-ownership="none">
            <doc xml:space="preserve">the pointer array to be searched</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="needle" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the pointer to look for</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="index_" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the return location for the index of
   the element, if found</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_with_equal_func" c:identifier="g_ptr_array_find_with_equal_func" version="2.54" introspectable="0">
        <doc xml:space="preserve">Checks whether @needle exists in @haystack, using the given @equal_func.
If the element is found, true is returned and the element&#x2019;s index is
returned in @index_ (if non-`NULL`). Otherwise, false is returned and @index_
is undefined. If @needle exists multiple times in @haystack, the index of
the first instance is returned.

@equal_func is called with the element from the array as its first parameter,
and @needle as its second parameter. If @equal_func is `NULL`, pointer
equality is used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @needle is one of the elements of @haystack; false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="haystack" transfer-ownership="none">
            <doc xml:space="preserve">the pointer array to be searched</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="needle" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the pointer to look for</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="equal_func" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the function to call for each element, which should
   return true when the desired element is found; or `NULL` to use pointer
   equality</doc>
            <type name="EqualFunc" c:type="GEqualFunc"/>
          </parameter>
          <parameter name="index_" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the return location for the index of
   the element, if found</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="foreach" c:identifier="g_ptr_array_foreach" version="2.4" introspectable="0">
        <doc xml:space="preserve">Calls a function for each element of a `GPtrArray`. @func must not
add elements to or remove elements from the array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call for each array element</doc>
            <type name="Func" c:type="GFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="free" c:identifier="g_ptr_array_free" introspectable="0">
        <doc xml:space="preserve">Frees the memory allocated for the `GPtrArray`. If @free_segment is true
it frees the memory block holding the elements as well. Pass false
if you want to free the `GPtrArray` wrapper but preserve the
underlying array for use elsewhere. If the reference count of @array
is greater than one, the `GPtrArray` wrapper is preserved but the
size of @array will be set to zero.

If array contents point to dynamically-allocated memory, they should
be freed separately if @free_segment is true and no
[callback@GLib.DestroyNotify] function has been set for @array.

Note that if the array is `NULL` terminated and @free_segment is false
then this will always return an allocated `NULL` terminated buffer.
If `pdata` is previously `NULL`, a new buffer will be allocated.

This function is not thread-safe. If using a `GPtrArray` from multiple
threads, use only the atomic [func@GLib.PtrArray.ref] and
[func@GLib.PtrArray.unref] functions.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The allocated pointer array if
  @free_segment is false, otherwise `NULL`.</doc>
          <array zero-terminated="0" c:type="gpointer*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="full">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="free_segment" transfer-ownership="none">
            <doc xml:space="preserve">if true, the actual pointer array is freed as well</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert" c:identifier="g_ptr_array_insert" version="2.40" introspectable="0">
        <doc xml:space="preserve">Inserts an element into the pointer array at the given index. The
array will grow in size automatically if necessary.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index to place the new element at, or -1 to append</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the pointer to add</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_null_terminated" c:identifier="g_ptr_array_is_null_terminated" version="2.74" introspectable="0">
        <doc xml:space="preserve">Checks whether the @array was constructed as `NULL`-terminated.

This will only return true for arrays constructed by passing true to the
`null_terminated` argument of [func@GLib.PtrArray.new_null_terminated]. It
will not return true for normal arrays which have had a `NULL` element
appended to them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if the array is made to be `NULL` terminated; false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="g_ptr_array_new" introspectable="0">
        <doc xml:space="preserve">Creates a new `GPtrArray` with a reference count of 1.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GPtrArray`</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
      </function>
      <function name="new_from_array" c:identifier="g_ptr_array_new_from_array" version="2.76" introspectable="0">
        <doc xml:space="preserve">Creates a new `GPtrArray`, copying @len pointers from @data, and setting
the array&#x2019;s reference count to 1.

This avoids having to manually add each element one by one.

If @copy_func is provided, then it is used to copy each element before
adding them to the new array. If it is `NULL` then the pointers are copied
directly.

It also sets @element_free_func for freeing each element when the array is
destroyed either via [func@GLib.PtrArray.unref], when
[func@GLib.PtrArray.free] is called with @free_segment set to true or when
removing elements.

Do not use it if @len is greater than [`G_MAXUINT`](types.html#guint).
`GPtrArray` stores the length of its data in `guint`, which may be shorter
than `gsize`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GPtrArray`</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an array of pointers</doc>
            <array length="1" zero-terminated="0" c:type="gpointer*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of pointers in @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="copy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="3" destroy="4">
            <doc xml:space="preserve">a copy function used to copy every element in the
  array</doc>
            <type name="CopyFunc" c:type="GCopyFunc"/>
          </parameter>
          <parameter name="copy_func_user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user data passed to @copy_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to free elements on @array
  destruction</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_null_terminated_array" c:identifier="g_ptr_array_new_from_null_terminated_array" version="2.76" introspectable="0">
        <doc xml:space="preserve">Creates a new `GPtrArray` copying the pointers from @data after having
computed the length of it and with a reference count of 1.
This avoids having to manually add each element one by one.
If @copy_func is provided, then it is used to copy the data in the new
array.
It also sets @element_free_func for freeing each element when the array is
destroyed either via [func@GLib.PtrArray.unref], when
[func@GLib.PtrArray.free] is called with @free_segment set to true or when
removing elements.

Do not use it if the @data has more than [`G_MAXUINT`](types.html#guint)
elements. `GPtrArray` stores the length of its data in `guint`, which may be
shorter than `gsize`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GPtrArray`</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an array of
  pointers, `NULL` terminated</doc>
            <array c:type="gpointer*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="copy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="2" destroy="3">
            <doc xml:space="preserve">a copy function used to copy every element in the
  array</doc>
            <type name="CopyFunc" c:type="GCopyFunc"/>
          </parameter>
          <parameter name="copy_func_user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user data passed to @copy_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to free elements on @array
  destruction</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_full" c:identifier="g_ptr_array_new_full" version="2.30" introspectable="0">
        <doc xml:space="preserve">Creates a new `GPtrArray` with @reserved_size pointers preallocated
and a reference count of 1. This avoids frequent reallocation, if
you are going to add many pointers to the array. Note however that
the size of the array is still 0. It also sets @element_free_func
for freeing each element when the array is destroyed either via
[func@GLib.PtrArray.unref], when [func@GLib.PtrArray.free] is called with
@free_segment set to true or when removing elements.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GPtrArray`</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="reserved_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of pointers preallocated</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to free elements with
    destroy @array</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_null_terminated" c:identifier="g_ptr_array_new_null_terminated" version="2.74" introspectable="0">
        <doc xml:space="preserve">Like [func@GLib.PtrArray.new_full] but also allows to set the array to
be `NULL` terminated. A `NULL` terminated pointer array has an
additional `NULL` pointer after the last element, beyond the
current length.

`GPtrArray` created by other constructors are not automatically `NULL`
terminated.

Note that if the @array&#x2019;s length is zero and currently no
data array is allocated, then `pdata` will still be `NULL`.
`GPtrArray` will only `NULL` terminate `pdata`, if an actual
array is allocated. It does not guarantee that an array
is always allocated. In other words, if the length is zero,
then `pdata` may either point to a `NULL` terminated array of length
zero or be `NULL`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GPtrArray`</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="reserved_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of pointers preallocated.
    If @null_terminated is `TRUE`, the actually allocated
    buffer size is @reserved_size plus 1, unless @reserved_size
    is zero, in which case no initial buffer gets allocated.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to free elements during
    destruction of @array</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="null_terminated" transfer-ownership="none">
            <doc xml:space="preserve">if true, make the array `NULL` terminated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_take" c:identifier="g_ptr_array_new_take" version="2.76" introspectable="0">
        <doc xml:space="preserve">Creates a new `GPtrArray` with @data as pointers, @len as length and a
reference count of 1.

This avoids having to copy such data manually.
After this call, @data belongs to the `GPtrArray` and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with [func@GLib.free].

It also sets @element_free_func for freeing each element when the array is
destroyed either via [func@GLib.PtrArray.unref], when
[func@GLib.PtrArray.free] is called with @free_segment set to true or when
removing elements.

Do not use it if @len is greater than [`G_MAXUINT`](types.html#guint).
`GPtrArray` stores the length of its data in `guint`, which may be shorter
than `gsize`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GPtrArray`</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">an array of pointers</doc>
            <array length="1" zero-terminated="0" c:type="gpointer*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of pointers in @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to free elements on @array
  destruction</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_take_null_terminated" c:identifier="g_ptr_array_new_take_null_terminated" version="2.76" introspectable="0">
        <doc xml:space="preserve">Creates a new `GPtrArray` with @data as pointers, computing the length of it
and setting the reference count to 1.

This avoids having to copy such data manually.
After this call, @data belongs to the `GPtrArray` and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with [func@GLib.free].

The length is calculated by iterating through @data until the first `NULL`
element is found.

It also sets @element_free_func for freeing each element when the array is
destroyed either via [func@GLib.PtrArray.unref], when
[func@GLib.PtrArray.free] is called with @free_segment set to true or when
removing elements.

Do not use it if the @data length is greater than
[`G_MAXUINT`](types.html#guint). `GPtrArray` stores the length of its data
in `guint`, which may be shorter than `gsize`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GPtrArray`</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">an array
 of pointers, `NULL` terminated</doc>
            <array c:type="gpointer*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to free elements on @array
  destruction</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_with_free_func" c:identifier="g_ptr_array_new_with_free_func" version="2.22" introspectable="0">
        <doc xml:space="preserve">Creates a new `GPtrArray` with a reference count of 1 and use
@element_free_func for freeing each element when the array is destroyed
either via [func@GLib.PtrArray.unref], when [func@GLib.PtrArray.free] is
called with @free_segment set to true or when removing elements.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GPtrArray`</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to free elements with
    destroy @array</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="ref" c:identifier="g_ptr_array_ref" version="2.22" introspectable="0">
        <doc xml:space="preserve">Atomically increments the reference count of @array by one.
This function is thread-safe and may be called from any thread.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The passed in `GPtrArray`</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="remove" c:identifier="g_ptr_array_remove" introspectable="0">
        <doc xml:space="preserve">Removes the first occurrence of the given pointer from the pointer
array. The following elements are moved down one place. If @array
has a non-`NULL` [callback@GLib.DestroyNotify] function it is called for the
removed element.

It returns true if the pointer was removed, or false if the
pointer was not found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if the pointer is found and removed; false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the pointer to remove</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_fast" c:identifier="g_ptr_array_remove_fast" introspectable="0">
        <doc xml:space="preserve">Removes the first occurrence of the given pointer from the pointer
array. The last element in the array is used to fill in the space,
so this function does not preserve the order of the array. But it
is faster than [func@GLib.PtrArray.remove]. If @array has a non-`NULL`
[callback@GLib.DestroyNotify] function it is called for the removed element.

It returns true if the pointer was removed, or false if the
pointer was not found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if the pointer is found and removed; false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the pointer to remove</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_index" c:identifier="g_ptr_array_remove_index" introspectable="0">
        <doc xml:space="preserve">Removes the pointer at the given index from the pointer array.
The following elements are moved down one place. If @array has
a non-`NULL` [callback@GLib.DestroyNotify] function it is called for the
removed
element. If so, the return value from this function will potentially point
to freed memory (depending on the [callback@GLib.DestroyNotify]
implementation).</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The pointer which was removed</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the pointer to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_index_fast" c:identifier="g_ptr_array_remove_index_fast" introspectable="0">
        <doc xml:space="preserve">Removes the pointer at the given index from the pointer array.
The last element in the array is used to fill in the space, so
this function does not preserve the order of the array. But it
is faster than [func@GLib.PtrArray.remove_index]. If @array has a non-`NULL`
[callback@GLib.DestroyNotify] function it is called for the removed element.
If so, the
return value from this function will potentially point to freed memory
(depending on the [callback@GLib.DestroyNotify] implementation).</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The pointer which was removed</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the pointer to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_range" c:identifier="g_ptr_array_remove_range" version="2.4" introspectable="0">
        <doc xml:space="preserve">Removes the given number of pointers starting at the given index
from a `GPtrArray`. The following elements are moved to close the
gap. If @array has a non-`NULL` [callback@GLib.DestroyNotify] function it is
called for the removed elements.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The @array</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the first pointer to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the number of pointers to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_free_func" c:identifier="g_ptr_array_set_free_func" version="2.22" introspectable="0">
        <doc xml:space="preserve">Sets a function for freeing each element when @array is destroyed
either via [func@GLib.PtrArray.unref], when [func@GLib.PtrArray.free] is
called with @free_segment set to true or when removing elements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to free elements during
    destruction of @array</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_size" c:identifier="g_ptr_array_set_size" introspectable="0">
        <doc xml:space="preserve">Sets the size of the array. When making the array larger,
newly-added elements will be set to `NULL`. When making it smaller,
if @array has a non-`NULL` [callback@GLib.DestroyNotify] function then it
will be called for the removed elements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the new length of the pointer array</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="sized_new" c:identifier="g_ptr_array_sized_new" introspectable="0">
        <doc xml:space="preserve">Creates a new `GPtrArray` with @reserved_size pointers preallocated
and a reference count of 1. This avoids frequent reallocation, if
you are going to add many pointers to the array. Note however that
the size of the array is still 0.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new `GPtrArray`</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="reserved_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of pointers preallocated</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort" c:identifier="g_ptr_array_sort" introspectable="0">
        <doc xml:space="preserve">Sorts the array, using @compare_func which should be a `qsort()`-style
comparison function (returns less than zero for first arg is less
than second arg, zero for equal, greater than zero if first arg is
greater than second arg).

Note that the comparison function for [func@GLib.PtrArray.sort] doesn&#x2019;t
take the pointers from the array as arguments, it takes pointers to
the pointers in the array.

Use [func@GLib.PtrArray.sort_values] if you want to use normal
[callback@GLib.CompareFunc] instances, otherwise here is a full example of
use:

```c
typedef struct
{
  gchar *name;
  gint size;
} FileListEntry;

static gint
sort_filelist (gconstpointer a, gconstpointer b)
{
  const FileListEntry *entry1 = *((FileListEntry **) a);
  const FileListEntry *entry2 = *((FileListEntry **) b);

  return g_ascii_strcasecmp (entry1-&gt;name, entry2-&gt;name);
}

&#x2026;
g_autoptr (GPtrArray) file_list = NULL;

// initialize file_list array and load with many FileListEntry entries
...
// now sort it with
g_ptr_array_sort (file_list, sort_filelist);
```

This is guaranteed to be a stable sort since version 2.32.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">a comparison function</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort_values" c:identifier="g_ptr_array_sort_values" version="2.76" introspectable="0">
        <doc xml:space="preserve">Sorts the array, using @compare_func which should be a `qsort()`-style
comparison function (returns less than zero for first arg is less
than second arg, zero for equal, greater than zero if first arg is
greater than second arg).

This is guaranteed to be a stable sort.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">a comparison function</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort_values_with_data" c:identifier="g_ptr_array_sort_values_with_data" version="2.76" introspectable="0">
        <doc xml:space="preserve">Like [func@GLib.PtrArray.sort_values], but the comparison function has an
extra user data argument.

This is guaranteed to be a stable sort.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">a comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort_with_data" c:identifier="g_ptr_array_sort_with_data" introspectable="0">
        <doc xml:space="preserve">Like [func@GLib.PtrArray.sort], but the comparison function has an extra
user data argument.

Note that the comparison function for [func@GLib.PtrArray.sort_with_data]
doesn&#x2019;t take the pointers from the array as arguments, it takes
pointers to the pointers in the array.

Use [func@GLib.PtrArray.sort_values_with_data] if you want to use normal
[callback@GLib.CompareDataFunc] instances, otherwise here is a full example
of use:

```c
typedef enum { SORT_NAME, SORT_SIZE } SortMode;

typedef struct
{
  gchar *name;
  gint size;
} FileListEntry;

static gint
sort_filelist (gconstpointer a, gconstpointer b, gpointer user_data)
{
  gint order;
  const SortMode sort_mode = GPOINTER_TO_INT (user_data);
  const FileListEntry *entry1 = *((FileListEntry **) a);
  const FileListEntry *entry2 = *((FileListEntry **) b);

  switch (sort_mode)
    {
    case SORT_NAME:
      order = g_ascii_strcasecmp (entry1-&gt;name, entry2-&gt;name);
      break;
    case SORT_SIZE:
      order = entry1-&gt;size - entry2-&gt;size;
      break;
    default:
      order = 0;
      break;
    }
  return order;
}

...
g_autoptr (GPtrArray) file_list = NULL;
SortMode sort_mode;

// initialize file_list array and load with many FileListEntry entries
...
// now sort it with
sort_mode = SORT_NAME;
g_ptr_array_sort_with_data (file_list,
                            sort_filelist,
                            GINT_TO_POINTER (sort_mode));
```

This is guaranteed to be a stable sort since version 2.32.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">a comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="steal" c:identifier="g_ptr_array_steal" version="2.64" introspectable="0">
        <doc xml:space="preserve">Frees the data in the array and resets the size to zero, while
the underlying array is preserved for use elsewhere and returned
to the caller.

Note that if the array is `NULL` terminated this may still return
`NULL` if the length of the array was zero and pdata was not yet
allocated.

Even if set, the [callback@GLib.DestroyNotify] function will never be called
on the current contents of the array and the caller is
responsible for freeing the array elements.

An example of use:
```c
g_autoptr(GPtrArray) chunk_buffer = g_ptr_array_new_with_free_func (g_bytes_unref);

// Some part of your application appends a number of chunks to the pointer array.
g_ptr_array_add (chunk_buffer, g_bytes_new_static ("hello", 5));
g_ptr_array_add (chunk_buffer, g_bytes_new_static ("world", 5));

&#x2026;

// Periodically, the chunks need to be sent as an array-and-length to some
// other part of the program.
GBytes **chunks;
gsize n_chunks;

chunks = g_ptr_array_steal (chunk_buffer, &amp;n_chunks);
for (gsize i = 0; i &lt; n_chunks; i++)
  {
    // Do something with each chunk here, and then free them, since
    // g_ptr_array_steal() transfers ownership of all the elements and the
    // array to the caller.
    &#x2026;

    g_bytes_unref (chunks[i]);
  }

g_free (chunks);

// After calling g_ptr_array_steal(), the pointer array can be reused for the
// next set of chunks.
g_assert (chunk_buffer-&gt;len == 0);
```</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The allocated element data.
  This may be `NULL`if the array doesn&#x2019;t have any elements (i.e. if `*len` is zero).</doc>
          <array length="1" zero-terminated="0" c:type="gpointer*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="len" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a pointer to retrieve the number of
   elements of the original array</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </function>
      <function name="steal_index" c:identifier="g_ptr_array_steal_index" version="2.58" introspectable="0">
        <doc xml:space="preserve">Removes the pointer at the given index from the pointer array.
The following elements are moved down one place. The
[callback@GLib.DestroyNotify] for
@array is *not* called on the removed element; ownership is transferred to
the caller of this function.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The pointer which was removed</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the pointer to steal</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="steal_index_fast" c:identifier="g_ptr_array_steal_index_fast" version="2.58" introspectable="0">
        <doc xml:space="preserve">Removes the pointer at the given index from the pointer array.
The last element in the array is used to fill in the space, so
this function does not preserve the order of the array. But it
is faster than [func@GLib.PtrArray.steal_index]. The
[callback@GLib.DestroyNotify] for @array is
*not* called on the removed element; ownership is transferred to the caller
of this function.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The pointer which was removed</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the pointer to steal</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref" c:identifier="g_ptr_array_unref" version="2.22" introspectable="0">
        <doc xml:space="preserve">Atomically decrements the reference count of @array by one. If the
reference count drops to 0, the effect is the same as calling
[func@GLib.PtrArray.free] with @free_segment set to true. This function
is thread-safe and may be called from any thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="full">
            <doc xml:space="preserve">a pointer array</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="Queue" c:type="GQueue">
      <doc xml:space="preserve">Contains the public fields of a
[Queue](data-structures.html#double-ended-queues).</doc>
      <field name="head" writable="1">
        <doc xml:space="preserve">a pointer to the first element of the queue</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="tail" writable="1">
        <doc xml:space="preserve">a pointer to the last element of the queue</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="length" writable="1">
        <doc xml:space="preserve">the number of elements in the queue</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <method name="clear" c:identifier="g_queue_clear" version="2.14">
        <doc xml:space="preserve">Removes all the elements in @queue. If queue elements contain
dynamically-allocated memory, they should be freed first.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_full" c:identifier="g_queue_clear_full" version="2.60">
        <doc xml:space="preserve">Convenience method, which frees all the memory used by a #GQueue,
and calls the provided @free_func on each item in the #GQueue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">the function to be called to free memory allocated</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="g_queue_copy" version="2.4" introspectable="0">
        <doc xml:space="preserve">Copies a @queue. Note that is a shallow copy. If the elements in the
queue consist of pointers to data, the pointers are copied, but the
actual data is not.</doc>
        <return-value>
          <doc xml:space="preserve">a copy of @queue</doc>
          <type name="Queue" c:type="GQueue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delete_link" c:identifier="g_queue_delete_link" version="2.4" introspectable="0">
        <doc xml:space="preserve">Removes @link_ from @queue and frees it.

@link_ must be part of @queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">a #GList link that must be part of @queue</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="find" c:identifier="g_queue_find" version="2.4" introspectable="0">
        <doc xml:space="preserve">Finds the first link in @queue which contains @data.</doc>
        <return-value>
          <doc xml:space="preserve">the first link in @queue which contains @data</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to find</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_custom" c:identifier="g_queue_find_custom" version="2.4" introspectable="0">
        <doc xml:space="preserve">Finds an element in a #GQueue, using a supplied function to find the
desired element. It iterates over the queue, calling the given function
which should return 0 when the desired element is found. The function
takes two gconstpointer arguments, the #GQueue element's data as the
first argument and the given user data as the second argument.</doc>
        <return-value>
          <doc xml:space="preserve">the found link, or %NULL if it wasn't found</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">a #GCompareFunc to call for each element. It should return 0
    when the desired element is found</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="g_queue_foreach" version="2.4">
        <doc xml:space="preserve">Calls @func for each element in the queue passing @user_data to the
function.

It is safe for @func to remove the element from @queue, but it must
not modify any part of the queue after that element.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the function to call for each element's data</doc>
            <type name="Func" c:type="GFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_queue_free">
        <doc xml:space="preserve">Frees the memory allocated for the #GQueue. Only call this function
if @queue was created with g_queue_new(). If queue elements contain
dynamically-allocated memory, they should be freed first.

If queue elements contain dynamically-allocated memory, you should
either use g_queue_free_full() or free them manually first.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_full" c:identifier="g_queue_free_full" version="2.32">
        <doc xml:space="preserve">Convenience method, which frees all the memory used by a #GQueue,
and calls the specified destroy function on every element's data.

@free_func should not modify the queue (eg, by removing the freed
element from it).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="free_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">the function to be called to free each element's data</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="g_queue_get_length" version="2.4">
        <doc xml:space="preserve">Returns the number of items in @queue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of items in @queue</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="index" c:identifier="g_queue_index" version="2.4">
        <doc xml:space="preserve">Returns the position of the first element in @queue which contains @data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the position of the first element in @queue which
    contains @data, or -1 if no element in @queue contains @data</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to find</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_queue_init" version="2.14">
        <doc xml:space="preserve">A statically-allocated #GQueue must be initialized with this function
before it can be used. Alternatively you can initialize it with
%G_QUEUE_INIT. It is not necessary to initialize queues created with
g_queue_new().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert_after" c:identifier="g_queue_insert_after" version="2.4" introspectable="0">
        <doc xml:space="preserve">Inserts @data into @queue after @sibling.

@sibling must be part of @queue. Since GLib 2.44 a %NULL sibling pushes the
data at the head of the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="sibling" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GList link that must be part of @queue, or %NULL to
  push at the head of the queue.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to insert</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_after_link" c:identifier="g_queue_insert_after_link" version="2.62" introspectable="0">
        <doc xml:space="preserve">Inserts @link_ into @queue after @sibling.

@sibling must be part of @queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="sibling" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GList link that must be part of @queue, or %NULL to
  push at the head of the queue.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">a #GList link to insert which must not be part of any other list.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="insert_before" c:identifier="g_queue_insert_before" version="2.4" introspectable="0">
        <doc xml:space="preserve">Inserts @data into @queue before @sibling.

@sibling must be part of @queue. Since GLib 2.44 a %NULL sibling pushes the
data at the tail of the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="sibling" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GList link that must be part of @queue, or %NULL to
  push at the tail of the queue.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to insert</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_before_link" c:identifier="g_queue_insert_before_link" version="2.62" introspectable="0">
        <doc xml:space="preserve">Inserts @link_ into @queue before @sibling.

@sibling must be part of @queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="sibling" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GList link that must be part of @queue, or %NULL to
  push at the tail of the queue.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">a #GList link to insert which must not be part of any other list.</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="insert_sorted" c:identifier="g_queue_insert_sorted" version="2.4">
        <doc xml:space="preserve">Inserts @data into @queue using @func to determine the new position.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to insert</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the #GCompareDataFunc used to compare elements in the queue. It is
    called with two elements of the @queue and @user_data. It should
    return 0 if the elements are equal, a negative value if the first
    element comes before the second, and a positive value if the second
    element comes before the first.</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="g_queue_is_empty">
        <doc xml:space="preserve">Returns %TRUE if the queue is empty.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the queue is empty</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue.</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="link_index" c:identifier="g_queue_link_index" version="2.4" introspectable="0">
        <doc xml:space="preserve">Returns the position of @link_ in @queue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the position of @link_, or -1 if the link is
    not part of @queue</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">a #GList link</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="peek_head" c:identifier="g_queue_peek_head">
        <doc xml:space="preserve">Returns the first element of the queue.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the data of the first element in the queue, or %NULL
    if the queue is empty</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_head_link" c:identifier="g_queue_peek_head_link" version="2.4" introspectable="0">
        <doc xml:space="preserve">Returns the first link in @queue.</doc>
        <return-value>
          <doc xml:space="preserve">the first link in @queue, or %NULL if @queue is empty</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_nth" c:identifier="g_queue_peek_nth" version="2.4">
        <doc xml:space="preserve">Returns the @n'th element of @queue.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the data for the @n'th element of @queue,
    or %NULL if @n is off the end of @queue</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the position of the element</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_nth_link" c:identifier="g_queue_peek_nth_link" version="2.4" introspectable="0">
        <doc xml:space="preserve">Returns the link at the given position</doc>
        <return-value>
          <doc xml:space="preserve">the link at the @n'th position, or %NULL
    if @n is off the end of the list</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the position of the link</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_tail" c:identifier="g_queue_peek_tail">
        <doc xml:space="preserve">Returns the last element of the queue.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the data of the last element in the queue, or %NULL
    if the queue is empty</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_tail_link" c:identifier="g_queue_peek_tail_link" version="2.4" introspectable="0">
        <doc xml:space="preserve">Returns the last link in @queue.</doc>
        <return-value>
          <doc xml:space="preserve">the last link in @queue, or %NULL if @queue is empty</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_head" c:identifier="g_queue_pop_head">
        <doc xml:space="preserve">Removes the first element of the queue and returns its data.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the data of the first element in the queue, or %NULL
    if the queue is empty</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_head_link" c:identifier="g_queue_pop_head_link" introspectable="0">
        <doc xml:space="preserve">Removes and returns the first element of the queue.</doc>
        <return-value>
          <doc xml:space="preserve">the #GList element at the head of the queue, or %NULL
    if the queue is empty</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_nth" c:identifier="g_queue_pop_nth" version="2.4">
        <doc xml:space="preserve">Removes the @n'th element of @queue and returns its data.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the element's data, or %NULL if @n is off the end of @queue</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the position of the element</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop_nth_link" c:identifier="g_queue_pop_nth_link" version="2.4" introspectable="0">
        <doc xml:space="preserve">Removes and returns the link at the given position.</doc>
        <return-value>
          <doc xml:space="preserve">the @n'th link, or %NULL if @n is off the end of @queue</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the link's position</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop_tail" c:identifier="g_queue_pop_tail">
        <doc xml:space="preserve">Removes the last element of the queue and returns its data.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the data of the last element in the queue, or %NULL
    if the queue is empty</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_tail_link" c:identifier="g_queue_pop_tail_link" introspectable="0">
        <doc xml:space="preserve">Removes and returns the last element of the queue.</doc>
        <return-value>
          <doc xml:space="preserve">the #GList element at the tail of the queue, or %NULL
    if the queue is empty</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_head" c:identifier="g_queue_push_head">
        <doc xml:space="preserve">Adds a new element at the head of the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue.</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_head_link" c:identifier="g_queue_push_head_link" introspectable="0">
        <doc xml:space="preserve">Adds a new element at the head of the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">a single #GList element, not a list with more than one element</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="push_nth" c:identifier="g_queue_push_nth" version="2.4">
        <doc xml:space="preserve">Inserts a new element into @queue at the given position.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the position to insert the new element. If @n is negative or
    larger than the number of elements in the @queue, the element is
    added to the end of the queue.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_nth_link" c:identifier="g_queue_push_nth_link" version="2.4" introspectable="0">
        <doc xml:space="preserve">Inserts @link into @queue at the given position.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the position to insert the link. If this is negative or larger than
    the number of elements in @queue, the link is added to the end of
    @queue.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">the link to add to @queue</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="push_tail" c:identifier="g_queue_push_tail">
        <doc xml:space="preserve">Adds a new element at the tail of the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_tail_link" c:identifier="g_queue_push_tail_link" introspectable="0">
        <doc xml:space="preserve">Adds a new element at the tail of the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">a single #GList element, not a list with more than one element</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_queue_remove" version="2.4">
        <doc xml:space="preserve">Removes the first element in @queue that contains @data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @data was found and removed from @queue</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to remove</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_all" c:identifier="g_queue_remove_all" version="2.4">
        <doc xml:space="preserve">Remove all elements whose data equals @data from @queue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of elements removed from @queue</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to remove</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reverse" c:identifier="g_queue_reverse" version="2.4">
        <doc xml:space="preserve">Reverses the order of the items in @queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sort" c:identifier="g_queue_sort" version="2.4">
        <doc xml:space="preserve">Sorts @queue using @compare_func.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the #GCompareDataFunc used to sort @queue. This function
    is passed two elements of the queue and should return 0 if they are
    equal, a negative value if the first comes before the second, and
    a positive value if the second comes before the first.</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unlink" c:identifier="g_queue_unlink" version="2.4" introspectable="0">
        <doc xml:space="preserve">Unlinks @link_ so that it will no longer be part of @queue.
The link is not freed.

@link_ must be part of @queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve">a #GQueue</doc>
            <type name="Queue" c:type="GQueue*"/>
          </instance-parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">a #GList link that must be part of @queue</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_queue_new" introspectable="0">
        <doc xml:space="preserve">Creates a new #GQueue.</doc>
        <return-value>
          <doc xml:space="preserve">a newly allocated #GQueue</doc>
          <type name="Queue" c:type="GQueue*"/>
        </return-value>
      </function>
    </record>
    <function-macro name="REC_MUTEX_AUTO_LOCK" c:identifier="G_REC_MUTEX_AUTO_LOCK" version="2.80.0" introspectable="0">
      <doc xml:space="preserve">Declare a [type@GLib.RecMutexLocker] variable with `g_autoptr()` and lock the
mutex. The mutex will be unlocked automatically when leaving the scope. The
variable is declared with `G_GNUC_UNUSED` to avoid compiler warning if it is
not used in the scope.

This feature is only supported on GCC and clang. This macro is not defined on
other compilers and should not be used in programs that are intended to be
portable to those compilers.

Note that this should be used in a place where it is allowed to declare a
variable, which could be before any statement in the case
`-Wdeclaration-after-statement` is used, or C standard prior to C99.

```c
{
  G_REC_MUTEX_AUTO_LOCK (&amp;obj-&gt;rec_mutex, locker);

  obj-&gt;stuff_with_lock ();
  if (condition)
    {
      // No need to unlock
      return;
    }

  // Unlock before end of scope
  g_clear_pointer (&amp;locker, g_rec_mutex_locker_free);
  obj-&gt;stuff_without_lock ();
}
```</doc>
      <parameters>
        <parameter name="mutex">
          <doc xml:space="preserve">a [type@GLib.RecMutex]</doc>
        </parameter>
        <parameter name="var">
          <doc xml:space="preserve">a variable name to be declared</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="REF_COUNT_INIT" value="-1" c:type="G_REF_COUNT_INIT" version="2.78">
      <doc xml:space="preserve">Evaluates to the initial reference count for `grefcount`.

This macro is useful for initializing `grefcount` fields inside
structures, for instance:

|[&lt;!-- language="C" --&gt;
typedef struct {
  grefcount ref_count;
  char *name;
  char *address;
} Person;

static const Person default_person = {
  .ref_count = G_REF_COUNT_INIT,
  .name = "Default name",
  .address = "Default address",
};
]|</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="RWLock" c:type="GRWLock" version="2.32">
      <doc xml:space="preserve">The GRWLock struct is an opaque data structure to represent a
reader-writer lock. It is similar to a #GMutex in that it allows
multiple threads to coordinate access to a shared resource.

The difference to a mutex is that a reader-writer lock discriminates
between read-only ('reader') and full ('writer') access. While only
one thread at a time is allowed write access (by holding the 'writer'
lock via g_rw_lock_writer_lock()), multiple threads can gain
simultaneous read-only access (by holding the 'reader' lock via
g_rw_lock_reader_lock()).

It is unspecified whether readers or writers have priority in acquiring the
lock when a reader already holds the lock and a writer is queued to acquire
it.

Here is an example for an array with access functions:
|[&lt;!-- language="C" --&gt;
  GRWLock lock;
  GPtrArray *array;

  gpointer
  my_array_get (guint index)
  {
    gpointer retval = NULL;

    if (!array)
      return NULL;

    g_rw_lock_reader_lock (&amp;lock);
    if (index &lt; array-&gt;len)
      retval = g_ptr_array_index (array, index);
    g_rw_lock_reader_unlock (&amp;lock);

    return retval;
  }

  void
  my_array_set (guint index, gpointer data)
  {
    g_rw_lock_writer_lock (&amp;lock);

    if (!array)
      array = g_ptr_array_new ();

    if (index &gt;= array-&gt;len)
      g_ptr_array_set_size (array, index+1);
    g_ptr_array_index (array, index) = data;

    g_rw_lock_writer_unlock (&amp;lock);
  }
 ]|
This example shows an array which can be accessed by many readers
(the my_array_get() function) simultaneously, whereas the writers
(the my_array_set() function) will only be allowed one at a time
and only if no readers currently access the array. This is because
of the potentially dangerous resizing of the array. Using these
functions is fully multi-thread safe now.

If a #GRWLock is allocated in static storage then it can be used
without initialisation.  Otherwise, you should call
g_rw_lock_init() on it and g_rw_lock_clear() when done.

A GRWLock should only be accessed with the g_rw_lock_ functions.</doc>
      <field name="p" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="i" readable="0" private="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <method name="clear" c:identifier="g_rw_lock_clear" version="2.32">
        <doc xml:space="preserve">Frees the resources allocated to a lock with g_rw_lock_init().

This function should not be used with a #GRWLock that has been
statically allocated.

Calling g_rw_lock_clear() when any thread holds the lock
leads to undefined behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rw_lock" transfer-ownership="none">
            <doc xml:space="preserve">an initialized #GRWLock</doc>
            <type name="RWLock" c:type="GRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_rw_lock_init" version="2.32">
        <doc xml:space="preserve">Initializes a #GRWLock so that it can be used.

This function is useful to initialize a lock that has been
allocated on the stack, or as part of a larger structure.  It is not
necessary to initialise a reader-writer lock that has been statically
allocated.

|[&lt;!-- language="C" --&gt;
  typedef struct {
    GRWLock l;
    ...
  } Blob;

Blob *b;

b = g_new (Blob, 1);
g_rw_lock_init (&amp;b-&gt;l);
]|

To undo the effect of g_rw_lock_init() when a lock is no longer
needed, use g_rw_lock_clear().

Calling g_rw_lock_init() on an already initialized #GRWLock leads
to undefined behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rw_lock" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized #GRWLock</doc>
            <type name="RWLock" c:type="GRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reader_lock" c:identifier="g_rw_lock_reader_lock" version="2.32">
        <doc xml:space="preserve">Obtain a read lock on @rw_lock. If another thread currently holds
the write lock on @rw_lock, the current thread will block until the
write lock was (held and) released. If another thread does not hold
the write lock, but is waiting for it, it is implementation defined
whether the reader or writer will block. Read locks can be taken
recursively.

Calling g_rw_lock_reader_lock() while the current thread already
owns a write lock leads to undefined behaviour. Read locks however
can be taken recursively, in which case you need to make sure to
call g_rw_lock_reader_unlock() the same amount of times.

It is implementation-defined how many read locks are allowed to be
held on the same lock simultaneously. If the limit is hit,
or if a deadlock is detected, a critical warning will be emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rw_lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GRWLock</doc>
            <type name="RWLock" c:type="GRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reader_trylock" c:identifier="g_rw_lock_reader_trylock" version="2.32">
        <doc xml:space="preserve">Tries to obtain a read lock on @rw_lock and returns %TRUE if
the read lock was successfully obtained. Otherwise it
returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @rw_lock could be locked</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rw_lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GRWLock</doc>
            <type name="RWLock" c:type="GRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reader_unlock" c:identifier="g_rw_lock_reader_unlock" version="2.32">
        <doc xml:space="preserve">Release a read lock on @rw_lock.

Calling g_rw_lock_reader_unlock() on a lock that is not held
by the current thread leads to undefined behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rw_lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GRWLock</doc>
            <type name="RWLock" c:type="GRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="writer_lock" c:identifier="g_rw_lock_writer_lock" version="2.32">
        <doc xml:space="preserve">Obtain a write lock on @rw_lock. If another thread currently holds
a read or write lock on @rw_lock, the current thread will block
until all other threads have dropped their locks on @rw_lock.

Calling g_rw_lock_writer_lock() while the current thread already
owns a read or write lock on @rw_lock leads to undefined behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rw_lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GRWLock</doc>
            <type name="RWLock" c:type="GRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="writer_trylock" c:identifier="g_rw_lock_writer_trylock" version="2.32">
        <doc xml:space="preserve">Tries to obtain a write lock on @rw_lock. If another thread
currently holds a read or write lock on @rw_lock, it immediately
returns %FALSE.
Otherwise it locks @rw_lock and returns %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @rw_lock could be locked</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rw_lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GRWLock</doc>
            <type name="RWLock" c:type="GRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="writer_unlock" c:identifier="g_rw_lock_writer_unlock" version="2.32">
        <doc xml:space="preserve">Release a write lock on @rw_lock.

Calling g_rw_lock_writer_unlock() on a lock that is not held
by the current thread leads to undefined behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rw_lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GRWLock</doc>
            <type name="RWLock" c:type="GRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <function-macro name="RW_LOCK_READER_AUTO_LOCK" c:identifier="G_RW_LOCK_READER_AUTO_LOCK" version="2.80.0" introspectable="0">
      <doc xml:space="preserve">Declare a [type@GLib.RWLockReaderLocker] variable with `g_autoptr()` and lock
for reading. The mutex will be unlocked automatically when leaving the scope.
The variable is declared with `G_GNUC_UNUSED` to avoid compiler warning if it
is not used in the scope.

This feature is only supported on GCC and clang. This macro is not defined on
other compilers and should not be used in programs that are intended to be
portable to those compilers.

Note that this should be used in a place where it is allowed to declare a
variable, which could be before any statement in the case
`-Wdeclaration-after-statement` is used, or C standard prior to C99.

```c
{
  G_RW_LOCK_READER_AUTO_LOCK (&amp;obj-&gt;rw_lock, locker);

  obj-&gt;stuff_with_lock ();
  if (condition)
    {
      // No need to unlock
      return;
    }

  // Unlock before end of scope
  g_clear_pointer (&amp;locker, g_rw_lock_reader_locker_free);
  obj-&gt;stuff_without_lock ();
}
```</doc>
      <parameters>
        <parameter name="mutex">
          <doc xml:space="preserve">a [type@GLib.RWLock]</doc>
        </parameter>
        <parameter name="var">
          <doc xml:space="preserve">a variable name to be declared</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="RW_LOCK_WRITER_AUTO_LOCK" c:identifier="G_RW_LOCK_WRITER_AUTO_LOCK" version="2.80.0" introspectable="0">
      <doc xml:space="preserve">Declare a [type@GLib.RWLockWriterLocker] variable with `g_autoptr()` and lock
for writing. The mutex will be unlocked automatically when leaving the scope.
The variable is declared with `G_GNUC_UNUSED` to avoid compiler warning if it
is not used in the scope.

This feature is only supported on GCC and clang. This macro is not defined on
other compilers and should not be used in programs that are intended to be
portable to those compilers.

Note that this should be used in a place where it is allowed to declare a
variable, which could be before any statement in the case
`-Wdeclaration-after-statement` is used, or C standard prior to C99.

```c
{
  G_RW_LOCK_WRITER_AUTO_LOCK (&amp;obj-&gt;rw_lock, locker);

  obj-&gt;stuff_with_lock ();
  if (condition)
    {
      // No need to unlock
      return;
    }

  // Unlock before end of scope
  g_clear_pointer (&amp;locker, g_rw_lock_writer_locker_free);
  obj-&gt;stuff_without_lock ();
}
```</doc>
      <parameters>
        <parameter name="mutex">
          <doc xml:space="preserve">a [type@GLib.RWLock]</doc>
        </parameter>
        <parameter name="var">
          <doc xml:space="preserve">a variable name to be declared</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="Rand" c:type="GRand" opaque="1" glib:type-name="GRand" glib:get-type="g_rand_get_type" c:symbol-prefix="rand">
      <doc xml:space="preserve">The GRand struct is an opaque data structure. It should only be
accessed through the g_rand_* functions.</doc>
      <constructor name="new" c:identifier="g_rand_new">
        <doc xml:space="preserve">Creates a new random number generator initialized with a seed taken
either from `/dev/urandom` (if existing) or from the current time
(as a fallback).

On Windows, the seed is taken from rand_s().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GRand</doc>
          <type name="Rand" c:type="GRand*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_seed" c:identifier="g_rand_new_with_seed">
        <doc xml:space="preserve">Creates a new random number generator initialized with @seed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GRand</doc>
          <type name="Rand" c:type="GRand*"/>
        </return-value>
        <parameters>
          <parameter name="seed" transfer-ownership="none">
            <doc xml:space="preserve">a value to initialize the random number generator</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_seed_array" c:identifier="g_rand_new_with_seed_array" version="2.4">
        <doc xml:space="preserve">Creates a new random number generator initialized with @seed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GRand</doc>
          <type name="Rand" c:type="GRand*"/>
        </return-value>
        <parameters>
          <parameter name="seed" transfer-ownership="none">
            <doc xml:space="preserve">an array of seeds to initialize the random number generator</doc>
            <type name="guint32" c:type="const guint32*"/>
          </parameter>
          <parameter name="seed_length" transfer-ownership="none">
            <doc xml:space="preserve">an array of seeds to initialize the random number
    generator</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="g_rand_copy" version="2.4">
        <doc xml:space="preserve">Copies a #GRand into a new one with the same exact state as before.
This way you can take a snapshot of the random number generator for
replaying later.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GRand</doc>
          <type name="Rand" c:type="GRand*"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand_" transfer-ownership="none">
            <doc xml:space="preserve">a #GRand</doc>
            <type name="Rand" c:type="GRand*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="double" c:identifier="g_rand_double">
        <doc xml:space="preserve">Returns the next random #gdouble from @rand_ equally distributed over
the range [0..1).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a random number</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand_" transfer-ownership="none">
            <doc xml:space="preserve">a #GRand</doc>
            <type name="Rand" c:type="GRand*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="double_range" c:identifier="g_rand_double_range">
        <doc xml:space="preserve">Returns the next random #gdouble from @rand_ equally distributed over
the range [@begin..@end).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a random number</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand_" transfer-ownership="none">
            <doc xml:space="preserve">a #GRand</doc>
            <type name="Rand" c:type="GRand*"/>
          </instance-parameter>
          <parameter name="begin" transfer-ownership="none">
            <doc xml:space="preserve">lower closed bound of the interval</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">upper open bound of the interval</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_rand_free">
        <doc xml:space="preserve">Frees the memory allocated for the #GRand.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand_" transfer-ownership="none">
            <doc xml:space="preserve">a #GRand</doc>
            <type name="Rand" c:type="GRand*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="int" c:identifier="g_rand_int">
        <doc xml:space="preserve">Returns the next random #guint32 from @rand_ equally distributed over
the range [0..2^32-1].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a random number</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand_" transfer-ownership="none">
            <doc xml:space="preserve">a #GRand</doc>
            <type name="Rand" c:type="GRand*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="int_range" c:identifier="g_rand_int_range">
        <doc xml:space="preserve">Returns the next random #gint32 from @rand_ equally distributed over
the range [@begin..@end-1].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a random number</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand_" transfer-ownership="none">
            <doc xml:space="preserve">a #GRand</doc>
            <type name="Rand" c:type="GRand*"/>
          </instance-parameter>
          <parameter name="begin" transfer-ownership="none">
            <doc xml:space="preserve">lower closed bound of the interval</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">upper open bound of the interval</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_seed" c:identifier="g_rand_set_seed">
        <doc xml:space="preserve">Sets the seed for the random number generator #GRand to @seed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand_" transfer-ownership="none">
            <doc xml:space="preserve">a #GRand</doc>
            <type name="Rand" c:type="GRand*"/>
          </instance-parameter>
          <parameter name="seed" transfer-ownership="none">
            <doc xml:space="preserve">a value to reinitialize the random number generator</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_seed_array" c:identifier="g_rand_set_seed_array" version="2.4">
        <doc xml:space="preserve">Initializes the random number generator by an array of longs.
Array can be of arbitrary size, though only the first 624 values
are taken.  This function is useful if you have many low entropy
seeds, or if you require more then 32 bits of actual entropy for
your application.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand_" transfer-ownership="none">
            <doc xml:space="preserve">a #GRand</doc>
            <type name="Rand" c:type="GRand*"/>
          </instance-parameter>
          <parameter name="seed" transfer-ownership="none">
            <doc xml:space="preserve">array to initialize with</doc>
            <type name="guint32" c:type="const guint32*"/>
          </parameter>
          <parameter name="seed_length" transfer-ownership="none">
            <doc xml:space="preserve">length of array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="RecMutex" c:type="GRecMutex" version="2.32">
      <doc xml:space="preserve">The GRecMutex struct is an opaque data structure to represent a
recursive mutex. It is similar to a #GMutex with the difference
that it is possible to lock a GRecMutex multiple times in the same
thread without deadlock. When doing so, care has to be taken to
unlock the recursive mutex as often as it has been locked.

If a #GRecMutex is allocated in static storage then it can be used
without initialisation.  Otherwise, you should call
g_rec_mutex_init() on it and g_rec_mutex_clear() when done.

A GRecMutex should only be accessed with the
g_rec_mutex_ functions.</doc>
      <field name="p" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="i" readable="0" private="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <method name="clear" c:identifier="g_rec_mutex_clear" version="2.32">
        <doc xml:space="preserve">Frees the resources allocated to a recursive mutex with
g_rec_mutex_init().

This function should not be used with a #GRecMutex that has been
statically allocated.

Calling g_rec_mutex_clear() on a locked recursive mutex leads
to undefined behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rec_mutex" transfer-ownership="none">
            <doc xml:space="preserve">an initialized #GRecMutex</doc>
            <type name="RecMutex" c:type="GRecMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_rec_mutex_init" version="2.32">
        <doc xml:space="preserve">Initializes a #GRecMutex so that it can be used.

This function is useful to initialize a recursive mutex
that has been allocated on the stack, or as part of a larger
structure.

It is not necessary to initialise a recursive mutex that has been
statically allocated.

|[&lt;!-- language="C" --&gt;
  typedef struct {
    GRecMutex m;
    ...
  } Blob;

Blob *b;

b = g_new (Blob, 1);
g_rec_mutex_init (&amp;b-&gt;m);
]|

Calling g_rec_mutex_init() on an already initialized #GRecMutex
leads to undefined behaviour.

To undo the effect of g_rec_mutex_init() when a recursive mutex
is no longer needed, use g_rec_mutex_clear().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rec_mutex" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized #GRecMutex</doc>
            <type name="RecMutex" c:type="GRecMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lock" c:identifier="g_rec_mutex_lock" version="2.32">
        <doc xml:space="preserve">Locks @rec_mutex. If @rec_mutex is already locked by another
thread, the current thread will block until @rec_mutex is
unlocked by the other thread. If @rec_mutex is already locked
by the current thread, the 'lock count' of @rec_mutex is increased.
The mutex will only become available again when it is unlocked
as many times as it has been locked.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rec_mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRecMutex</doc>
            <type name="RecMutex" c:type="GRecMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="trylock" c:identifier="g_rec_mutex_trylock" version="2.32">
        <doc xml:space="preserve">Tries to lock @rec_mutex. If @rec_mutex is already locked
by another thread, it immediately returns %FALSE. Otherwise
it locks @rec_mutex and returns %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @rec_mutex could be locked</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rec_mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRecMutex</doc>
            <type name="RecMutex" c:type="GRecMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unlock" c:identifier="g_rec_mutex_unlock" version="2.32">
        <doc xml:space="preserve">Unlocks @rec_mutex. If another thread is blocked in a
g_rec_mutex_lock() call for @rec_mutex, it will become unblocked
and can lock @rec_mutex itself.

Calling g_rec_mutex_unlock() on a recursive mutex that is not
locked by the current thread leads to undefined behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rec_mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRecMutex</doc>
            <type name="RecMutex" c:type="GRecMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Regex" c:type="GRegex" opaque="1" version="2.14" glib:type-name="GRegex" glib:get-type="g_regex_get_type" c:symbol-prefix="regex">
      <doc xml:space="preserve">A `GRegex` is a compiled form of a regular expression.

After instantiating a `GRegex`, you can use its methods to find matches
in a string, replace matches within a string, or split the string at matches.

`GRegex` implements regular expression pattern matching using syntax and
semantics (such as character classes, quantifiers, and capture groups)
similar to Perl regular expression. See the
[PCRE documentation](man:pcre2pattern(3)) for details.

A typical scenario for regex pattern matching is to check if a string
matches a pattern. The following statements implement this scenario.

``` { .c }
const char *regex_pattern = ".*GLib.*";
const char *string_to_search = "You will love the GLib implementation of regex";
g_autoptr(GMatchInfo) match_info = NULL;
g_autoptr(GRegex) regex = NULL;

regex = g_regex_new (regex_pattern, G_REGEX_DEFAULT, G_REGEX_MATCH_DEFAULT, NULL);
g_assert (regex != NULL);

if (g_regex_match (regex, string_to_search, G_REGEX_MATCH_DEFAULT, &amp;match_info))
  {
    int start_pos, end_pos;
    g_match_info_fetch_pos (match_info, 0, &amp;start_pos, &amp;end_pos);
    g_print ("Match successful! Overall pattern matches bytes %d to %d\n", start_pos, end_pos);
  }
else
  {
    g_print ("No match!\n");
  }
```

The constructor for `GRegex` includes two sets of bitmapped flags:

* [flags@GLib.RegexCompileFlags]&#x2014;These flags
control how GLib compiles the regex. There are options for case
sensitivity, multiline, ignoring whitespace, etc.
* [flags@GLib.RegexMatchFlags]&#x2014;These flags control
`GRegex`&#x2019;s matching behavior, such as anchoring and customizing definitions
for newline characters.

Some regex patterns include backslash assertions, such as `\d` (digit) or
`\D` (non-digit). The regex pattern must escape those backslashes. For
example, the pattern `"\\d\\D"` matches a digit followed by a non-digit.

GLib&#x2019;s implementation of pattern matching includes a `start_position`
argument for some of the match, replace, and split methods. Specifying
a start position provides flexibility when you want to ignore the first
_n_ characters of a string, but want to incorporate backslash assertions
at character _n_ - 1. For example, a database field contains inconsistent
spelling for a job title: `healthcare provider` and `health-care provider`.
The database manager wants to make the spelling consistent by adding a
hyphen when it is missing. The following regex pattern tests for the string
`care` preceded by a non-word boundary character (instead of a hyphen)
and followed by a space.

``` { .c }
const char *regex_pattern = "\\Bcare\\s";
```

An efficient way to match with this pattern is to start examining at
`start_position` 6 in the string `healthcare` or `health-care`.

``` { .c }
const char *regex_pattern = "\\Bcare\\s";
const char *string_to_search = "healthcare provider";
g_autoptr(GMatchInfo) match_info = NULL;
g_autoptr(GRegex) regex = NULL;

regex = g_regex_new (
  regex_pattern,
  G_REGEX_DEFAULT,
  G_REGEX_MATCH_DEFAULT,
  NULL);
g_assert (regex != NULL);

g_regex_match_full (
  regex,
  string_to_search,
  -1,
  6, // position of 'c' in the test string.
  G_REGEX_MATCH_DEFAULT,
  &amp;match_info,
  NULL);
```

The method [method@GLib.Regex.match_full] (and other methods implementing
`start_pos`) allow for lookback before the start position to determine if
the previous character satisfies an assertion.

Unless you set the [flags@GLib.RegexCompileFlags.RAW] as one of
the `GRegexCompileFlags`, all the strings passed to `GRegex` methods must
be encoded in UTF-8. The lengths and the positions inside the strings are
in bytes and not in characters, so, for instance, `\xc3\xa0` (i.e., `&#xE0;`)
is two bytes long but it is treated as a single character. If you set
`G_REGEX_RAW`, the strings can be non-valid UTF-8 strings and a byte is
treated as a character, so `\xc3\xa0` is two bytes and two characters long.

Regarding line endings, `\n` matches a `\n` character, and `\r` matches
a `\r` character. More generally, `\R` matches all typical line endings:
CR + LF (`\r\n`), LF (linefeed, U+000A, `\n`), VT (vertical tab, U+000B,
`\v`), FF (formfeed, U+000C, `\f`), CR (carriage return, U+000D, `\r`),
NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph
separator, U+2029).

The behaviour of the dot, circumflex, and dollar metacharacters are
affected by newline characters. By default, `GRegex` matches any newline
character matched by `\R`. You can limit the matched newline characters by
specifying the [flags@GLib.RegexMatchFlags.NEWLINE_CR],
[flags@GLib.RegexMatchFlags.NEWLINE_LF], and
[flags@GLib.RegexMatchFlags.NEWLINE_CRLF] compile options, and
with [flags@GLib.RegexMatchFlags.NEWLINE_ANY],
[flags@GLib.RegexMatchFlags.NEWLINE_CR],
[flags@GLib.RegexMatchFlags.NEWLINE_LF] and
[flags@GLib.RegexMatchFlags.NEWLINE_CRLF] match options.
These settings are also relevant when compiling a pattern if
[flags@GLib.RegexCompileFlags.EXTENDED] is set and an unescaped
`#` outside a character class is encountered. This indicates a comment
that lasts until after the next newline.

Because `GRegex` does not modify its internal state between creation and
destruction, you can create and modify the same `GRegex` instance from
different threads. In contrast, [struct@GLib.MatchInfo] is not thread safe.

The regular expression low-level functionalities are obtained through
the excellent [PCRE](http://www.pcre.org/) library written by Philip Hazel.</doc>
      <constructor name="new" c:identifier="g_regex_new" version="2.14" throws="1">
        <doc xml:space="preserve">Compiles the regular expression to an internal form, and does
the initial setup of the #GRegex structure.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GRegex structure or %NULL if an error occurred. Call
  g_regex_unref() when you are done with it</doc>
          <type name="Regex" c:type="GRegex*"/>
        </return-value>
        <parameters>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve">the regular expression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="compile_options" transfer-ownership="none">
            <doc xml:space="preserve">compile options for the regular expression, or 0</doc>
            <type name="RegexCompileFlags" c:type="GRegexCompileFlags"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">match options for the regular expression, or 0</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_capture_count" c:identifier="g_regex_get_capture_count" version="2.14">
        <doc xml:space="preserve">Returns the number of capturing subpatterns in the pattern.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of capturing subpatterns</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_compile_flags" c:identifier="g_regex_get_compile_flags" version="2.26">
        <doc xml:space="preserve">Returns the compile options that @regex was created with.

Depending on the version of PCRE that is used, this may or may not
include flags set by option expressions such as `(?i)` found at the
top-level within the compiled pattern.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">flags from #GRegexCompileFlags</doc>
          <type name="RegexCompileFlags" c:type="GRegexCompileFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_has_cr_or_lf" c:identifier="g_regex_get_has_cr_or_lf" version="2.34">
        <doc xml:space="preserve">Checks whether the pattern contains explicit CR or LF references.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the pattern contains explicit CR or LF references</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_match_flags" c:identifier="g_regex_get_match_flags" version="2.26">
        <doc xml:space="preserve">Returns the match options that @regex was created with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">flags from #GRegexMatchFlags</doc>
          <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_backref" c:identifier="g_regex_get_max_backref" version="2.14">
        <doc xml:space="preserve">Returns the number of the highest back reference
in the pattern, or 0 if the pattern does not contain
back references.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of the highest back reference</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_lookbehind" c:identifier="g_regex_get_max_lookbehind" version="2.38">
        <doc xml:space="preserve">Gets the number of characters in the longest lookbehind assertion in the
pattern. This information is useful when doing multi-segment matching using
the partial matching facilities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of characters in the longest lookbehind assertion.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pattern" c:identifier="g_regex_get_pattern" version="2.14">
        <doc xml:space="preserve">Gets the pattern string associated with @regex, i.e. a copy of
the string passed to g_regex_new().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the pattern of @regex</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string_number" c:identifier="g_regex_get_string_number" version="2.14">
        <doc xml:space="preserve">Retrieves the number of the subexpression named @name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of the subexpression or -1 if @name
  does not exists</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">#GRegex structure</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the subexpression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="match" c:identifier="g_regex_match" version="2.14">
        <doc xml:space="preserve">Scans for a match in @string for the pattern in @regex.
The @match_options are combined with the match options specified
when the @regex structure was created, letting you have more
flexibility in reusing #GRegex structures.

Unless %G_REGEX_RAW is specified in the options, @string must be valid UTF-8.

A #GMatchInfo structure, used to get information on the match,
is stored in @match_info if not %NULL. Note that if @match_info
is not %NULL then it is created even if the function returns %FALSE,
i.e. you must free it regardless if regular expression actually matched.

To retrieve all the non-overlapping matches of the pattern in
string you can use g_match_info_next().

|[&lt;!-- language="C" --&gt;
static void
print_uppercase_words (const gchar *string)
{
  // Print all uppercase-only words.
  GRegex *regex;
  GMatchInfo *match_info;
 
  regex = g_regex_new ("[A-Z]+", G_REGEX_DEFAULT, G_REGEX_MATCH_DEFAULT, NULL);
  g_regex_match (regex, string, 0, &amp;match_info);
  while (g_match_info_matches (match_info))
    {
      gchar *word = g_match_info_fetch (match_info, 0);
      g_print ("Found: %s\n", word);
      g_free (word);
      g_match_info_next (match_info, NULL);
    }
  g_match_info_free (match_info);
  g_regex_unref (regex);
}
]|

@string is not copied and is used in #GMatchInfo internally. If
you use any #GMatchInfo method (except g_match_info_free()) after
freeing or modifying @string then the behaviour is undefined.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE is the string matched, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure from g_regex_new()</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to scan for matches</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">match options</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
          <parameter name="match_info" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">pointer to location where to store
    the #GMatchInfo, or %NULL if you do not need it</doc>
            <type name="MatchInfo" c:type="GMatchInfo**"/>
          </parameter>
        </parameters>
      </method>
      <method name="match_all" c:identifier="g_regex_match_all" version="2.14">
        <doc xml:space="preserve">Using the standard algorithm for regular expression matching only
the longest match in the string is retrieved. This function uses
a different algorithm so it can retrieve all the possible matches.
For more documentation see g_regex_match_all_full().

A #GMatchInfo structure, used to get information on the match, is
stored in @match_info if not %NULL. Note that if @match_info is
not %NULL then it is created even if the function returns %FALSE,
i.e. you must free it regardless if regular expression actually
matched.

@string is not copied and is used in #GMatchInfo internally. If
you use any #GMatchInfo method (except g_match_info_free()) after
freeing or modifying @string then the behaviour is undefined.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE is the string matched, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure from g_regex_new()</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to scan for matches</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">match options</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
          <parameter name="match_info" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">pointer to location where to store
    the #GMatchInfo, or %NULL if you do not need it</doc>
            <type name="MatchInfo" c:type="GMatchInfo**"/>
          </parameter>
        </parameters>
      </method>
      <method name="match_all_full" c:identifier="g_regex_match_all_full" version="2.14" throws="1">
        <doc xml:space="preserve">Using the standard algorithm for regular expression matching only
the longest match in the @string is retrieved, it is not possible
to obtain all the available matches. For instance matching
`"&lt;a&gt; &lt;b&gt; &lt;c&gt;"` against the pattern `"&lt;.*&gt;"`
you get `"&lt;a&gt; &lt;b&gt; &lt;c&gt;"`.

This function uses a different algorithm (called DFA, i.e. deterministic
finite automaton), so it can retrieve all the possible matches, all
starting at the same point in the string. For instance matching
`"&lt;a&gt; &lt;b&gt; &lt;c&gt;"` against the pattern `"&lt;.*&gt;"`
you would obtain three matches: `"&lt;a&gt; &lt;b&gt; &lt;c&gt;"`,
`"&lt;a&gt; &lt;b&gt;"` and `"&lt;a&gt;"`.

The number of matched strings is retrieved using
g_match_info_get_match_count(). To obtain the matched strings and
their position you can use, respectively, g_match_info_fetch() and
g_match_info_fetch_pos(). Note that the strings are returned in
reverse order of length; that is, the longest matching string is
given first.

Note that the DFA algorithm is slower than the standard one and it
is not able to capture substrings, so backreferences do not work.

Setting @start_position differs from just passing over a shortened
string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern
that begins with any kind of lookbehind assertion, such as "\b".

Unless %G_REGEX_RAW is specified in the options, @string must be valid UTF-8.

A #GMatchInfo structure, used to get information on the match, is
stored in @match_info if not %NULL. Note that if @match_info is
not %NULL then it is created even if the function returns %FALSE,
i.e. you must free it regardless if regular expression actually
matched.

@string is not copied and is used in #GMatchInfo internally. If
you use any #GMatchInfo method (except g_match_info_free()) after
freeing or modifying @string then the behaviour is undefined.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE is the string matched, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure from g_regex_new()</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to scan for matches</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="string_len" transfer-ownership="none">
            <doc xml:space="preserve">the length of @string, in bytes, or -1 if @string is nul-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="start_position" transfer-ownership="none">
            <doc xml:space="preserve">starting index of the string to match, in bytes</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">match options</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
          <parameter name="match_info" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">pointer to location where to store
    the #GMatchInfo, or %NULL if you do not need it</doc>
            <type name="MatchInfo" c:type="GMatchInfo**"/>
          </parameter>
        </parameters>
      </method>
      <method name="match_full" c:identifier="g_regex_match_full" version="2.14" throws="1">
        <doc xml:space="preserve">Scans for a match in @string for the pattern in @regex.
The @match_options are combined with the match options specified
when the @regex structure was created, letting you have more
flexibility in reusing #GRegex structures.

Setting @start_position differs from just passing over a shortened
string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern
that begins with any kind of lookbehind assertion, such as "\b".

Unless %G_REGEX_RAW is specified in the options, @string must be valid UTF-8.

A #GMatchInfo structure, used to get information on the match, is
stored in @match_info if not %NULL. Note that if @match_info is
not %NULL then it is created even if the function returns %FALSE,
i.e. you must free it regardless if regular expression actually
matched.

@string is not copied and is used in #GMatchInfo internally. If
you use any #GMatchInfo method (except g_match_info_free()) after
freeing or modifying @string then the behaviour is undefined.

To retrieve all the non-overlapping matches of the pattern in
string you can use g_match_info_next().

|[&lt;!-- language="C" --&gt;
static void
print_uppercase_words (const gchar *string)
{
  // Print all uppercase-only words.
  GRegex *regex;
  GMatchInfo *match_info;
  GError *error = NULL;
  
  regex = g_regex_new ("[A-Z]+", G_REGEX_DEFAULT, G_REGEX_MATCH_DEFAULT, NULL);
  g_regex_match_full (regex, string, -1, 0, 0, &amp;match_info, &amp;error);
  while (g_match_info_matches (match_info))
    {
      gchar *word = g_match_info_fetch (match_info, 0);
      g_print ("Found: %s\n", word);
      g_free (word);
      g_match_info_next (match_info, &amp;error);
    }
  g_match_info_free (match_info);
  g_regex_unref (regex);
  if (error != NULL)
    {
      g_printerr ("Error while matching: %s\n", error-&gt;message);
      g_error_free (error);
    }
}
]|</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE is the string matched, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure from g_regex_new()</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to scan for matches</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="string_len" transfer-ownership="none">
            <doc xml:space="preserve">the length of @string, in bytes, or -1 if @string is nul-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="start_position" transfer-ownership="none">
            <doc xml:space="preserve">starting index of the string to match, in bytes</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">match options</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
          <parameter name="match_info" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">pointer to location where to store
    the #GMatchInfo, or %NULL if you do not need it</doc>
            <type name="MatchInfo" c:type="GMatchInfo**"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_regex_ref" version="2.14">
        <doc xml:space="preserve">Increases reference count of @regex by 1.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">@regex</doc>
          <type name="Regex" c:type="GRegex*"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex</doc>
            <type name="Regex" c:type="GRegex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="replace" c:identifier="g_regex_replace" version="2.14" throws="1">
        <doc xml:space="preserve">Replaces all occurrences of the pattern in @regex with the
replacement text. Backreferences of the form `\number` or
`\g&lt;number&gt;` in the replacement text are interpolated by the
number-th captured subexpression of the match, `\g&lt;name&gt;` refers
to the captured subexpression with the given name. `\0` refers
to the complete match, but `\0` followed by a number is the octal
representation of a character. To include a literal `\` in the
replacement, write `\\\\`.

There are also escapes that changes the case of the following text:

- \l: Convert to lower case the next character
- \u: Convert to upper case the next character
- \L: Convert to lower case till \E
- \U: Convert to upper case till \E
- \E: End case modification

If you do not need to use backreferences use g_regex_replace_literal().

The @replacement string must be UTF-8 encoded even if %G_REGEX_RAW was
passed to g_regex_new(). If you want to use not UTF-8 encoded strings
you can use g_regex_replace_literal().

Setting @start_position differs from just passing over a shortened
string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern that
begins with any kind of lookbehind assertion, such as "\b".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the replacements</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to perform matches against</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="string_len" transfer-ownership="none">
            <doc xml:space="preserve">the length of @string, in bytes, or -1 if @string is nul-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="start_position" transfer-ownership="none">
            <doc xml:space="preserve">starting index of the string to match, in bytes</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="replacement" transfer-ownership="none">
            <doc xml:space="preserve">text to replace each match with</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">options for the match</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_eval" c:identifier="g_regex_replace_eval" version="2.14" throws="1">
        <doc xml:space="preserve">Replaces occurrences of the pattern in regex with the output of
@eval for that occurrence.

Setting @start_position differs from just passing over a shortened
string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern
that begins with any kind of lookbehind assertion, such as "\b".

The following example uses g_regex_replace_eval() to replace multiple
strings at once:
|[&lt;!-- language="C" --&gt;
static gboolean
eval_cb (const GMatchInfo *info,
         GString          *res,
         gpointer          data)
{
  gchar *match;
  gchar *r;

   match = g_match_info_fetch (info, 0);
   r = g_hash_table_lookup ((GHashTable *)data, match);
   g_string_append (res, r);
   g_free (match);

   return FALSE;
}

...

GRegex *reg;
GHashTable *h;
gchar *res;

h = g_hash_table_new (g_str_hash, g_str_equal);

g_hash_table_insert (h, "1", "ONE");
g_hash_table_insert (h, "2", "TWO");
g_hash_table_insert (h, "3", "THREE");
g_hash_table_insert (h, "4", "FOUR");

reg = g_regex_new ("1|2|3|4", G_REGEX_DEFAULT, G_REGEX_MATCH_DEFAULT, NULL);
res = g_regex_replace_eval (reg, text, -1, 0, 0, eval_cb, h, NULL);
g_hash_table_destroy (h);

...
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the replacements</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure from g_regex_new()</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">string to perform matches against</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="string_len" transfer-ownership="none">
            <doc xml:space="preserve">the length of @string, in bytes, or -1 if @string is nul-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="start_position" transfer-ownership="none">
            <doc xml:space="preserve">starting index of the string to match, in bytes</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">options for the match</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
          <parameter name="eval" transfer-ownership="none" scope="call" closure="5">
            <doc xml:space="preserve">a function to call for each match</doc>
            <type name="RegexEvalCallback" c:type="GRegexEvalCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_literal" c:identifier="g_regex_replace_literal" version="2.14" throws="1">
        <doc xml:space="preserve">Replaces all occurrences of the pattern in @regex with the
replacement text. @replacement is replaced literally, to
include backreferences use g_regex_replace().

Setting @start_position differs from just passing over a
shortened string and setting %G_REGEX_MATCH_NOTBOL in the
case of a pattern that begins with any kind of lookbehind
assertion, such as "\b".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the replacements</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to perform matches against</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="string_len" transfer-ownership="none">
            <doc xml:space="preserve">the length of @string, in bytes, or -1 if @string is nul-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="start_position" transfer-ownership="none">
            <doc xml:space="preserve">starting index of the string to match, in bytes</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="replacement" transfer-ownership="none">
            <doc xml:space="preserve">text to replace each match with</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">options for the match</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="split" c:identifier="g_regex_split" version="2.14">
        <doc xml:space="preserve">Breaks the string on the pattern, and returns an array of the tokens.
If the pattern contains capturing parentheses, then the text for each
of the substrings will also be returned. If the pattern does not match
anywhere in the string, then the whole string is returned as the first
token.

As a special case, the result of splitting the empty string "" is an
empty vector, not a vector containing a single string. The reason for
this special case is that being able to represent an empty vector is
typically more useful than consistent handling of empty elements. If
you do need to represent empty elements, you'll need to check for the
empty string before calling this function.

A pattern that can match empty strings splits @string into separate
characters wherever it matches the empty string between characters.
For example splitting "ab c" using as a separator "\s*", you will get
"a", "b" and "c".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated gchar ** array. Free
it using g_strfreev()</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to split with the pattern</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">match time option flags</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="split_full" c:identifier="g_regex_split_full" version="2.14" throws="1">
        <doc xml:space="preserve">Breaks the string on the pattern, and returns an array of the tokens.
If the pattern contains capturing parentheses, then the text for each
of the substrings will also be returned. If the pattern does not match
anywhere in the string, then the whole string is returned as the first
token.

As a special case, the result of splitting the empty string "" is an
empty vector, not a vector containing a single string. The reason for
this special case is that being able to represent an empty vector is
typically more useful than consistent handling of empty elements. If
you do need to represent empty elements, you'll need to check for the
empty string before calling this function.

A pattern that can match empty strings splits @string into separate
characters wherever it matches the empty string between characters.
For example splitting "ab c" using as a separator "\s*", you will get
"a", "b" and "c".

Setting @start_position differs from just passing over a shortened
string and setting %G_REGEX_MATCH_NOTBOL in the case of a pattern
that begins with any kind of lookbehind assertion, such as "\b".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated gchar ** array. Free
it using g_strfreev()</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex structure</doc>
            <type name="Regex" c:type="const GRegex*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to split with the pattern</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="string_len" transfer-ownership="none">
            <doc xml:space="preserve">the length of @string, in bytes, or -1 if @string is nul-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="start_position" transfer-ownership="none">
            <doc xml:space="preserve">starting index of the string to match, in bytes</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">match time option flags</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
          <parameter name="max_tokens" transfer-ownership="none">
            <doc xml:space="preserve">the maximum number of tokens to split @string into.
  If this is less than 1, the string is split completely</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_regex_unref" version="2.14">
        <doc xml:space="preserve">Decreases reference count of @regex by 1. When reference count drops
to zero, it frees all the memory associated with the regex structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="regex" transfer-ownership="none">
            <doc xml:space="preserve">a #GRegex</doc>
            <type name="Regex" c:type="GRegex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="check_replacement" c:identifier="g_regex_check_replacement" version="2.14" throws="1">
        <doc xml:space="preserve">Checks whether @replacement is a valid replacement string
(see g_regex_replace()), i.e. that all escape sequences in
it are valid.

If @has_references is not %NULL then @replacement is checked
for pattern references. For instance, replacement text 'foo\n'
does not contain references and may be evaluated without information
about actual match, but '\0\1' (whole match followed by first
subpattern) requires valid #GMatchInfo object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @replacement is a valid replacement string</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="replacement" transfer-ownership="none">
            <doc xml:space="preserve">the replacement string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="has_references" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to store information about
  references in @replacement or %NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </function>
      <function name="error_quark" c:identifier="g_regex_error_quark">
        <return-value transfer-ownership="none">
          <type name="Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="escape_nul" c:identifier="g_regex_escape_nul" version="2.30">
        <doc xml:space="preserve">Escapes the nul characters in @string to "\x00".  It can be used
to compile a regex with embedded nul characters.

For completeness, @length can be -1 for a nul-terminated string.
In this case the output string will be of course equal to @string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated escaped string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to escape</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @string</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="escape_string" c:identifier="g_regex_escape_string" version="2.14">
        <doc xml:space="preserve">Escapes the special characters used for regular expressions
in @string, for instance "a.b*c" becomes "a\.b\*c". This
function is useful to dynamically generate regular expressions.

@string can contain nul characters that are replaced with "\0",
in this case remember to specify the correct length of @string
in @length.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated escaped string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to escape</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @string, in bytes, or -1 if @string is nul-terminated</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="match_simple" c:identifier="g_regex_match_simple" version="2.14">
        <doc xml:space="preserve">Scans for a match in @string for @pattern.

This function is equivalent to g_regex_match() but it does not
require to compile the pattern with g_regex_new(), avoiding some
lines of code when you need just to do a match without extracting
substrings, capture counts, and so on.

If this function is to be called on the same @pattern more than
once, it's more efficient to compile the pattern once with
g_regex_new() and then use g_regex_match().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the string matched, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve">the regular expression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to scan for matches</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="compile_options" transfer-ownership="none">
            <doc xml:space="preserve">compile options for the regular expression, or 0</doc>
            <type name="RegexCompileFlags" c:type="GRegexCompileFlags"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">match options, or 0</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="split_simple" c:identifier="g_regex_split_simple" version="2.14">
        <doc xml:space="preserve">Breaks the string on the pattern, and returns an array of
the tokens. If the pattern contains capturing parentheses,
then the text for each of the substrings will also be returned.
If the pattern does not match anywhere in the string, then the
whole string is returned as the first token.

This function is equivalent to g_regex_split() but it does
not require to compile the pattern with g_regex_new(), avoiding
some lines of code when you need just to do a split without
extracting substrings, capture counts, and so on.

If this function is to be called on the same @pattern more than
once, it's more efficient to compile the pattern once with
g_regex_new() and then use g_regex_split().

As a special case, the result of splitting the empty string ""
is an empty vector, not a vector containing a single string.
The reason for this special case is that being able to represent
an empty vector is typically more useful than consistent handling
of empty elements. If you do need to represent empty elements,
you'll need to check for the empty string before calling this
function.

A pattern that can match empty strings splits @string into
separate characters wherever it matches the empty string between
characters. For example splitting "ab c" using as a separator
"\s*", you will get "a", "b" and "c".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a %NULL-terminated array of strings. Free
it using g_strfreev()</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve">the regular expression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to scan for matches</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="compile_options" transfer-ownership="none">
            <doc xml:space="preserve">compile options for the regular expression, or 0</doc>
            <type name="RegexCompileFlags" c:type="GRegexCompileFlags"/>
          </parameter>
          <parameter name="match_options" transfer-ownership="none">
            <doc xml:space="preserve">match options, or 0</doc>
            <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="RegexCompileFlags" version="2.14" c:type="GRegexCompileFlags">
      <doc xml:space="preserve">Flags specifying compile-time options.</doc>
      <member name="default" value="0" c:identifier="G_REGEX_DEFAULT">
        <doc xml:space="preserve">No special options set. Since: 2.74</doc>
      </member>
      <member name="caseless" value="1" c:identifier="G_REGEX_CASELESS">
        <doc xml:space="preserve">Letters in the pattern match both upper- and
    lowercase letters. This option can be changed within a pattern
    by a "(?i)" option setting.</doc>
      </member>
      <member name="multiline" value="2" c:identifier="G_REGEX_MULTILINE">
        <doc xml:space="preserve">By default, GRegex treats the strings as consisting
    of a single line of characters (even if it actually contains
    newlines). The "start of line" metacharacter ("^") matches only
    at the start of the string, while the "end of line" metacharacter
    ("$") matches only at the end of the string, or before a terminating
    newline (unless %G_REGEX_DOLLAR_ENDONLY is set). When
    %G_REGEX_MULTILINE is set, the "start of line" and "end of line"
    constructs match immediately following or immediately before any
    newline in the string, respectively, as well as at the very start
    and end. This can be changed within a pattern by a "(?m)" option
    setting.</doc>
      </member>
      <member name="dotall" value="4" c:identifier="G_REGEX_DOTALL">
        <doc xml:space="preserve">A dot metacharacter (".") in the pattern matches all
    characters, including newlines. Without it, newlines are excluded.
    This option can be changed within a pattern by a ("?s") option setting.</doc>
      </member>
      <member name="extended" value="8" c:identifier="G_REGEX_EXTENDED">
        <doc xml:space="preserve">Whitespace data characters in the pattern are
    totally ignored except when escaped or inside a character class.
    Whitespace does not include the VT character (code 11). In addition,
    characters between an unescaped "#" outside a character class and
    the next newline character, inclusive, are also ignored. This can
    be changed within a pattern by a "(?x)" option setting.</doc>
      </member>
      <member name="anchored" value="16" c:identifier="G_REGEX_ANCHORED">
        <doc xml:space="preserve">The pattern is forced to be "anchored", that is,
    it is constrained to match only at the first matching point in the
    string that is being searched. This effect can also be achieved by
    appropriate constructs in the pattern itself such as the "^"
    metacharacter.</doc>
      </member>
      <member name="dollar_endonly" value="32" c:identifier="G_REGEX_DOLLAR_ENDONLY">
        <doc xml:space="preserve">A dollar metacharacter ("$") in the pattern
    matches only at the end of the string. Without this option, a
    dollar also matches immediately before the final character if
    it is a newline (but not before any other newlines). This option
    is ignored if %G_REGEX_MULTILINE is set.</doc>
      </member>
      <member name="ungreedy" value="512" c:identifier="G_REGEX_UNGREEDY">
        <doc xml:space="preserve">Inverts the "greediness" of the quantifiers so that
    they are not greedy by default, but become greedy if followed by "?".
    It can also be set by a "(?U)" option setting within the pattern.</doc>
      </member>
      <member name="raw" value="2048" c:identifier="G_REGEX_RAW">
        <doc xml:space="preserve">Usually strings must be valid UTF-8 strings, using this
    flag they are considered as a raw sequence of bytes.</doc>
      </member>
      <member name="no_auto_capture" value="4096" c:identifier="G_REGEX_NO_AUTO_CAPTURE">
        <doc xml:space="preserve">Disables the use of numbered capturing
    parentheses in the pattern. Any opening parenthesis that is not
    followed by "?" behaves as if it were followed by "?:" but named
    parentheses can still be used for capturing (and they acquire numbers
    in the usual way).</doc>
      </member>
      <member name="optimize" value="8192" c:identifier="G_REGEX_OPTIMIZE">
        <doc xml:space="preserve">Since 2.74 and the port to pcre2, requests JIT
    compilation, which, if the just-in-time compiler is available, further
    processes a compiled pattern into machine code that executes much
    faster. However, it comes at the cost of extra processing before the
    match is performed, so it is most beneficial to use this when the same
    compiled pattern is used for matching many times. Before 2.74 this
    option used the built-in non-JIT optimizations in pcre1.</doc>
      </member>
      <member name="firstline" value="262144" c:identifier="G_REGEX_FIRSTLINE">
        <doc xml:space="preserve">Limits an unanchored pattern to match before (or at) the
    first newline. Since: 2.34</doc>
      </member>
      <member name="dupnames" value="524288" c:identifier="G_REGEX_DUPNAMES">
        <doc xml:space="preserve">Names used to identify capturing subpatterns need not
    be unique. This can be helpful for certain types of pattern when it
    is known that only one instance of the named subpattern can ever be
    matched.</doc>
      </member>
      <member name="newline_cr" value="1048576" c:identifier="G_REGEX_NEWLINE_CR">
        <doc xml:space="preserve">Usually any newline character or character sequence is
    recognized. If this option is set, the only recognized newline character
    is '\r'.</doc>
      </member>
      <member name="newline_lf" value="2097152" c:identifier="G_REGEX_NEWLINE_LF">
        <doc xml:space="preserve">Usually any newline character or character sequence is
    recognized. If this option is set, the only recognized newline character
    is '\n'.</doc>
      </member>
      <member name="newline_reserved1" value="4194304" c:identifier="G_REGEX_NEWLINE_RESERVED1">
      </member>
    </bitfield>
    <enumeration name="RegexError" version="2.14" c:type="GRegexError" glib:error-domain="g-regex-error-quark">
      <doc xml:space="preserve">Error codes returned by regular expressions functions.</doc>
      <member name="compile" value="0" c:identifier="G_REGEX_ERROR_COMPILE">
        <doc xml:space="preserve">Compilation of the regular expression failed.</doc>
      </member>
      <member name="optimize" value="1" c:identifier="G_REGEX_ERROR_OPTIMIZE">
        <doc xml:space="preserve">Optimization of the regular expression failed.</doc>
      </member>
      <member name="replace" value="2" c:identifier="G_REGEX_ERROR_REPLACE">
        <doc xml:space="preserve">Replacement failed due to an ill-formed replacement
    string.</doc>
      </member>
      <member name="match" value="3" c:identifier="G_REGEX_ERROR_MATCH">
        <doc xml:space="preserve">The match process failed.</doc>
      </member>
      <member name="internal" value="4" c:identifier="G_REGEX_ERROR_INTERNAL">
        <doc xml:space="preserve">Internal error of the regular expression engine.
    Since 2.16</doc>
      </member>
      <member name="stray_backslash" value="101" c:identifier="G_REGEX_ERROR_STRAY_BACKSLASH">
        <doc xml:space="preserve">"\\" at end of pattern. Since 2.16</doc>
      </member>
      <member name="missing_control_char" value="102" c:identifier="G_REGEX_ERROR_MISSING_CONTROL_CHAR">
        <doc xml:space="preserve">"\\c" at end of pattern. Since 2.16</doc>
      </member>
      <member name="unrecognized_escape" value="103" c:identifier="G_REGEX_ERROR_UNRECOGNIZED_ESCAPE">
        <doc xml:space="preserve">Unrecognized character follows "\\".
    Since 2.16</doc>
      </member>
      <member name="quantifiers_out_of_order" value="104" c:identifier="G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER">
        <doc xml:space="preserve">Numbers out of order in "{}"
    quantifier. Since 2.16</doc>
      </member>
      <member name="quantifier_too_big" value="105" c:identifier="G_REGEX_ERROR_QUANTIFIER_TOO_BIG">
        <doc xml:space="preserve">Number too big in "{}" quantifier.
    Since 2.16</doc>
      </member>
      <member name="unterminated_character_class" value="106" c:identifier="G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS">
        <doc xml:space="preserve">Missing terminating "]" for
    character class. Since 2.16</doc>
      </member>
      <member name="invalid_escape_in_character_class" value="107" c:identifier="G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS">
        <doc xml:space="preserve">Invalid escape sequence
    in character class. Since 2.16</doc>
      </member>
      <member name="range_out_of_order" value="108" c:identifier="G_REGEX_ERROR_RANGE_OUT_OF_ORDER">
        <doc xml:space="preserve">Range out of order in character class.
    Since 2.16</doc>
      </member>
      <member name="nothing_to_repeat" value="109" c:identifier="G_REGEX_ERROR_NOTHING_TO_REPEAT">
        <doc xml:space="preserve">Nothing to repeat. Since 2.16</doc>
      </member>
      <member name="unrecognized_character" value="112" c:identifier="G_REGEX_ERROR_UNRECOGNIZED_CHARACTER">
        <doc xml:space="preserve">Unrecognized character after "(?",
    "(?&lt;" or "(?P". Since 2.16</doc>
      </member>
      <member name="posix_named_class_outside_class" value="113" c:identifier="G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS">
        <doc xml:space="preserve">POSIX named classes are
    supported only within a class. Since 2.16</doc>
      </member>
      <member name="unmatched_parenthesis" value="114" c:identifier="G_REGEX_ERROR_UNMATCHED_PARENTHESIS">
        <doc xml:space="preserve">Missing terminating ")" or ")"
    without opening "(". Since 2.16</doc>
      </member>
      <member name="inexistent_subpattern_reference" value="115" c:identifier="G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE">
        <doc xml:space="preserve">Reference to non-existent
    subpattern. Since 2.16</doc>
      </member>
      <member name="unterminated_comment" value="118" c:identifier="G_REGEX_ERROR_UNTERMINATED_COMMENT">
        <doc xml:space="preserve">Missing terminating ")" after comment.
    Since 2.16</doc>
      </member>
      <member name="expression_too_large" value="120" c:identifier="G_REGEX_ERROR_EXPRESSION_TOO_LARGE">
        <doc xml:space="preserve">Regular expression too large.
    Since 2.16</doc>
      </member>
      <member name="memory_error" value="121" c:identifier="G_REGEX_ERROR_MEMORY_ERROR">
        <doc xml:space="preserve">Failed to get memory. Since 2.16</doc>
      </member>
      <member name="variable_length_lookbehind" value="125" c:identifier="G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND">
        <doc xml:space="preserve">Lookbehind assertion is not
    fixed length. Since 2.16</doc>
      </member>
      <member name="malformed_condition" value="126" c:identifier="G_REGEX_ERROR_MALFORMED_CONDITION">
        <doc xml:space="preserve">Malformed number or name after "(?(".
    Since 2.16</doc>
      </member>
      <member name="too_many_conditional_branches" value="127" c:identifier="G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES">
        <doc xml:space="preserve">Conditional group contains
    more than two branches. Since 2.16</doc>
      </member>
      <member name="assertion_expected" value="128" c:identifier="G_REGEX_ERROR_ASSERTION_EXPECTED">
        <doc xml:space="preserve">Assertion expected after "(?(".
    Since 2.16</doc>
      </member>
      <member name="unknown_posix_class_name" value="130" c:identifier="G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME">
        <doc xml:space="preserve">Unknown POSIX class name.
    Since 2.16</doc>
      </member>
      <member name="posix_collating_elements_not_supported" value="131" c:identifier="G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED">
        <doc xml:space="preserve">POSIX collating
    elements are not supported. Since 2.16</doc>
      </member>
      <member name="hex_code_too_large" value="134" c:identifier="G_REGEX_ERROR_HEX_CODE_TOO_LARGE">
        <doc xml:space="preserve">Character value in "\\x{...}" sequence
    is too large. Since 2.16</doc>
      </member>
      <member name="invalid_condition" value="135" c:identifier="G_REGEX_ERROR_INVALID_CONDITION">
        <doc xml:space="preserve">Invalid condition "(?(0)". Since 2.16</doc>
      </member>
      <member name="single_byte_match_in_lookbehind" value="136" c:identifier="G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND">
        <doc xml:space="preserve">\\C not allowed in
    lookbehind assertion. Since 2.16</doc>
      </member>
      <member name="infinite_loop" value="140" c:identifier="G_REGEX_ERROR_INFINITE_LOOP">
        <doc xml:space="preserve">Recursive call could loop indefinitely.
    Since 2.16</doc>
      </member>
      <member name="missing_subpattern_name_terminator" value="142" c:identifier="G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR">
        <doc xml:space="preserve">Missing terminator
    in subpattern name. Since 2.16</doc>
      </member>
      <member name="duplicate_subpattern_name" value="143" c:identifier="G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME">
        <doc xml:space="preserve">Two named subpatterns have
    the same name. Since 2.16</doc>
      </member>
      <member name="malformed_property" value="146" c:identifier="G_REGEX_ERROR_MALFORMED_PROPERTY">
        <doc xml:space="preserve">Malformed "\\P" or "\\p" sequence.
    Since 2.16</doc>
      </member>
      <member name="unknown_property" value="147" c:identifier="G_REGEX_ERROR_UNKNOWN_PROPERTY">
        <doc xml:space="preserve">Unknown property name after "\\P" or
    "\\p". Since 2.16</doc>
      </member>
      <member name="subpattern_name_too_long" value="148" c:identifier="G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG">
        <doc xml:space="preserve">Subpattern name is too long
    (maximum 32 characters). Since 2.16</doc>
      </member>
      <member name="too_many_subpatterns" value="149" c:identifier="G_REGEX_ERROR_TOO_MANY_SUBPATTERNS">
        <doc xml:space="preserve">Too many named subpatterns (maximum
    10,000). Since 2.16</doc>
      </member>
      <member name="invalid_octal_value" value="151" c:identifier="G_REGEX_ERROR_INVALID_OCTAL_VALUE">
        <doc xml:space="preserve">Octal value is greater than "\\377".
    Since 2.16</doc>
      </member>
      <member name="too_many_branches_in_define" value="154" c:identifier="G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE">
        <doc xml:space="preserve">"DEFINE" group contains more
    than one branch. Since 2.16</doc>
      </member>
      <member name="define_repetion" value="155" c:identifier="G_REGEX_ERROR_DEFINE_REPETION">
        <doc xml:space="preserve">Repeating a "DEFINE" group is not allowed.
    This error is never raised. Since: 2.16 Deprecated: 2.34</doc>
      </member>
      <member name="inconsistent_newline_options" value="156" c:identifier="G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS">
        <doc xml:space="preserve">Inconsistent newline options.
    Since 2.16</doc>
      </member>
      <member name="missing_back_reference" value="157" c:identifier="G_REGEX_ERROR_MISSING_BACK_REFERENCE">
        <doc xml:space="preserve">"\\g" is not followed by a braced,
     angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16</doc>
      </member>
      <member name="invalid_relative_reference" value="158" c:identifier="G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE">
        <doc xml:space="preserve">relative reference must not be zero. Since: 2.34</doc>
      </member>
      <member name="backtracking_control_verb_argument_forbidden" value="159" c:identifier="G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN">
        <doc xml:space="preserve">the backtracing
    control verb used does not allow an argument. Since: 2.34</doc>
      </member>
      <member name="unknown_backtracking_control_verb" value="160" c:identifier="G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB">
        <doc xml:space="preserve">unknown backtracing
    control verb. Since: 2.34</doc>
      </member>
      <member name="number_too_big" value="161" c:identifier="G_REGEX_ERROR_NUMBER_TOO_BIG">
        <doc xml:space="preserve">number is too big in escape sequence. Since: 2.34</doc>
      </member>
      <member name="missing_subpattern_name" value="162" c:identifier="G_REGEX_ERROR_MISSING_SUBPATTERN_NAME">
        <doc xml:space="preserve">Missing subpattern name. Since: 2.34</doc>
      </member>
      <member name="missing_digit" value="163" c:identifier="G_REGEX_ERROR_MISSING_DIGIT">
        <doc xml:space="preserve">Missing digit. Since 2.34</doc>
      </member>
      <member name="invalid_data_character" value="164" c:identifier="G_REGEX_ERROR_INVALID_DATA_CHARACTER">
        <doc xml:space="preserve">In JavaScript compatibility mode,
    "[" is an invalid data character. Since: 2.34</doc>
      </member>
      <member name="extra_subpattern_name" value="165" c:identifier="G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME">
        <doc xml:space="preserve">different names for subpatterns of the
    same number are not allowed. Since: 2.34</doc>
      </member>
      <member name="backtracking_control_verb_argument_required" value="166" c:identifier="G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED">
        <doc xml:space="preserve">the backtracing control
    verb requires an argument. Since: 2.34</doc>
      </member>
      <member name="invalid_control_char" value="168" c:identifier="G_REGEX_ERROR_INVALID_CONTROL_CHAR">
        <doc xml:space="preserve">"\\c" must be followed by an ASCII
    character. Since: 2.34</doc>
      </member>
      <member name="missing_name" value="169" c:identifier="G_REGEX_ERROR_MISSING_NAME">
        <doc xml:space="preserve">"\\k" is not followed by a braced, angle-bracketed, or
    quoted name. Since: 2.34</doc>
      </member>
      <member name="not_supported_in_class" value="171" c:identifier="G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS">
        <doc xml:space="preserve">"\\N" is not supported in a class. Since: 2.34</doc>
      </member>
      <member name="too_many_forward_references" value="172" c:identifier="G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES">
        <doc xml:space="preserve">too many forward references. Since: 2.34</doc>
      </member>
      <member name="name_too_long" value="175" c:identifier="G_REGEX_ERROR_NAME_TOO_LONG">
        <doc xml:space="preserve">the name is too long in "(*MARK)", "(*PRUNE)",
    "(*SKIP)", or "(*THEN)". Since: 2.34</doc>
      </member>
      <member name="character_value_too_large" value="176" c:identifier="G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE">
        <doc xml:space="preserve">the character value in the \\u sequence is
    too large. Since: 2.34</doc>
      </member>
    </enumeration>
    <callback name="RegexEvalCallback" c:type="GRegexEvalCallback" version="2.14">
      <doc xml:space="preserve">Specifies the type of the function passed to g_regex_replace_eval().
It is called for each occurrence of the pattern in the string passed
to g_regex_replace_eval(), and it should append the replacement to
@result.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%FALSE to continue the replacement process, %TRUE to stop it</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="match_info" transfer-ownership="none">
          <doc xml:space="preserve">the #GMatchInfo generated by the match.
    Use g_match_info_get_regex() and g_match_info_get_string() if you
    need the #GRegex or the matched string.</doc>
          <type name="MatchInfo" c:type="const GMatchInfo*"/>
        </parameter>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">a #GString containing the new string</doc>
          <type name="String" c:type="GString*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data passed to g_regex_replace_eval()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="RegexMatchFlags" version="2.14" c:type="GRegexMatchFlags">
      <doc xml:space="preserve">Flags specifying match-time options.</doc>
      <member name="default" value="0" c:identifier="G_REGEX_MATCH_DEFAULT">
        <doc xml:space="preserve">No special options set. Since: 2.74</doc>
      </member>
      <member name="anchored" value="16" c:identifier="G_REGEX_MATCH_ANCHORED">
        <doc xml:space="preserve">The pattern is forced to be "anchored", that is,
    it is constrained to match only at the first matching point in the
    string that is being searched. This effect can also be achieved by
    appropriate constructs in the pattern itself such as the "^"
    metacharacter.</doc>
      </member>
      <member name="notbol" value="128" c:identifier="G_REGEX_MATCH_NOTBOL">
        <doc xml:space="preserve">Specifies that first character of the string is
    not the beginning of a line, so the circumflex metacharacter should
    not match before it. Setting this without %G_REGEX_MULTILINE (at
    compile time) causes circumflex never to match. This option affects
    only the behaviour of the circumflex metacharacter, it does not
    affect "\A".</doc>
      </member>
      <member name="noteol" value="256" c:identifier="G_REGEX_MATCH_NOTEOL">
        <doc xml:space="preserve">Specifies that the end of the subject string is
    not the end of a line, so the dollar metacharacter should not match
    it nor (except in multiline mode) a newline immediately before it.
    Setting this without %G_REGEX_MULTILINE (at compile time) causes
    dollar never to match. This option affects only the behaviour of
    the dollar metacharacter, it does not affect "\Z" or "\z".</doc>
      </member>
      <member name="notempty" value="1024" c:identifier="G_REGEX_MATCH_NOTEMPTY">
        <doc xml:space="preserve">An empty string is not considered to be a valid
    match if this option is set. If there are alternatives in the pattern,
    they are tried. If all the alternatives match the empty string, the
    entire match fails. For example, if the pattern "a?b?" is applied to
    a string not beginning with "a" or "b", it matches the empty string
    at the start of the string. With this flag set, this match is not
    valid, so GRegex searches further into the string for occurrences
    of "a" or "b".</doc>
      </member>
      <member name="partial" value="32768" c:identifier="G_REGEX_MATCH_PARTIAL">
        <doc xml:space="preserve">Turns on the partial matching feature, for more
    documentation on partial matching see g_match_info_is_partial_match().</doc>
      </member>
      <member name="newline_cr" value="1048576" c:identifier="G_REGEX_MATCH_NEWLINE_CR">
        <doc xml:space="preserve">Overrides the newline definition set when
    creating a new #GRegex, setting the '\r' character as line terminator.</doc>
      </member>
      <member name="newline_lf" value="2097152" c:identifier="G_REGEX_MATCH_NEWLINE_LF">
        <doc xml:space="preserve">Overrides the newline definition set when
    creating a new #GRegex, setting the '\n' character as line terminator.</doc>
      </member>
      <member name="newline_crlf" value="3145728" c:identifier="G_REGEX_MATCH_NEWLINE_CRLF">
        <doc xml:space="preserve">Overrides the newline definition set when
    creating a new #GRegex, setting the '\r\n' characters sequence as line terminator.</doc>
      </member>
      <member name="newline_any" value="4194304" c:identifier="G_REGEX_MATCH_NEWLINE_ANY">
        <doc xml:space="preserve">Overrides the newline definition set when
    creating a new #GRegex, any Unicode newline sequence
    is recognised as a newline. These are '\r', '\n' and '\rn', and the
    single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
    U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
    U+2029 PARAGRAPH SEPARATOR.</doc>
      </member>
      <member name="newline_anycrlf" value="5242880" c:identifier="G_REGEX_MATCH_NEWLINE_ANYCRLF">
        <doc xml:space="preserve">Overrides the newline definition set when
    creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence
    is recognized as a newline. Since: 2.34</doc>
      </member>
      <member name="bsr_anycrlf" value="8388608" c:identifier="G_REGEX_MATCH_BSR_ANYCRLF">
        <doc xml:space="preserve">Overrides the newline definition for "\R" set when
    creating a new #GRegex; only '\r', '\n', or '\r\n' character sequences
    are recognized as a newline by "\R". Since: 2.34</doc>
      </member>
      <member name="bsr_any" value="16777216" c:identifier="G_REGEX_MATCH_BSR_ANY">
        <doc xml:space="preserve">Overrides the newline definition for "\R" set when
    creating a new #GRegex; any Unicode newline character or character sequence
    are recognized as a newline by "\R". These are '\r', '\n' and '\rn', and the
    single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
    U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
    U+2029 PARAGRAPH SEPARATOR. Since: 2.34</doc>
      </member>
      <member name="partial_soft" value="32768" c:identifier="G_REGEX_MATCH_PARTIAL_SOFT">
        <doc xml:space="preserve">An alias for %G_REGEX_MATCH_PARTIAL. Since: 2.34</doc>
      </member>
      <member name="partial_hard" value="134217728" c:identifier="G_REGEX_MATCH_PARTIAL_HARD">
        <doc xml:space="preserve">Turns on the partial matching feature. In contrast to
    to %G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match
    is found, without continuing to search for a possible complete match. See
    g_match_info_is_partial_match() for more information. Since: 2.34</doc>
      </member>
      <member name="notempty_atstart" value="268435456" c:identifier="G_REGEX_MATCH_NOTEMPTY_ATSTART">
        <doc xml:space="preserve">Like %G_REGEX_MATCH_NOTEMPTY, but only applied to
    the start of the matched string. For anchored
    patterns this can only happen for pattern containing "\K". Since: 2.34</doc>
      </member>
    </bitfield>
    <record name="Relation" c:type="GRelation" disguised="1" opaque="1" deprecated="1" deprecated-version="2.26">
      <doc xml:space="preserve">A `GRelation` is a table of data which can be indexed on any number
of fields, rather like simple database tables. A `GRelation` contains
a number of records, called tuples. Each record contains a number of
fields. Records are not ordered, so it is not possible to find the
record at a particular index.

Note that `GRelation` tables are currently limited to 2 fields.

To create a `GRelation`, use [func@GLib.Relation.new].

To specify which fields should be indexed, use [method@GLib.Relation.index].
Note that this must be called before any tuples are added to the
`GRelation`.

To add records to a `GRelation` use [method@GLib.Relation.insert].

To determine if a given record appears in a `GRelation`, use
[method@GLib.Relation.exists]. Note that fields are compared directly, so
pointers must point to the exact same position (i.e. different
copies of the same string will not match.)

To count the number of records which have a particular value in a
given field, use [method@GLib.Relation.count].

To get all the records which have a particular value in a given
field, use [method@GLib.Relation.select]. To access fields of the resulting
records, use [method@GLib.Tuples.index]. To free the resulting records use
[method@GLib.Tuples.destroy].

To delete all records which have a particular value in a given
field, use [method@GLib.Relation.delete].

To destroy the `GRelation`, use [method@GLib.Relation.destroy].

To help debug `GRelation` objects, use [method@GLib.Relation.print].

`GRelation` has been marked as deprecated, since this API has never
been fully implemented, is not very actively maintained and rarely
used.</doc>
      <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
      <method name="count" c:identifier="g_relation_count" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Returns the number of tuples in a #GRelation that have the given
value in the given field.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of matches.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="relation" transfer-ownership="none">
            <doc xml:space="preserve">a #GRelation.</doc>
            <type name="Relation" c:type="GRelation*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value to compare with.</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">the field of each record to match.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="g_relation_delete" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Deletes any records from a #GRelation that have the given key value
in the given field.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of records deleted.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="relation" transfer-ownership="none">
            <doc xml:space="preserve">a #GRelation.</doc>
            <type name="Relation" c:type="GRelation*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value to compare with.</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">the field of each record to match.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="g_relation_destroy" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Destroys the #GRelation, freeing all memory allocated. However, it
does not free memory allocated for the tuple data, so you should
free that first if appropriate.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="relation" transfer-ownership="none">
            <doc xml:space="preserve">a #GRelation.</doc>
            <type name="Relation" c:type="GRelation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="exists" c:identifier="g_relation_exists" introspectable="0" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Returns %TRUE if a record with the given values exists in a
#GRelation. Note that the values are compared directly, so that, for
example, two copies of the same string will not match.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a record matches.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="relation" transfer-ownership="none">
            <doc xml:space="preserve">a #GRelation.</doc>
            <type name="Relation" c:type="GRelation*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the fields of the record to compare. The number must match
      the number of fields in the #GRelation.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="index" c:identifier="g_relation_index" introspectable="0" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Creates an index on the given field. Note that this must be called
before any records are added to the #GRelation.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="relation" transfer-ownership="none">
            <doc xml:space="preserve">a #GRelation.</doc>
            <type name="Relation" c:type="GRelation*"/>
          </instance-parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">the field to index, counting from 0.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hash_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to produce a hash value from the field data.</doc>
            <type name="HashFunc" c:type="GHashFunc"/>
          </parameter>
          <parameter name="key_equal_func" transfer-ownership="none">
            <doc xml:space="preserve">a function to compare two values of the given field.</doc>
            <type name="EqualFunc" c:type="GEqualFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_relation_insert" introspectable="0" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Inserts a record into a #GRelation.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="relation" transfer-ownership="none">
            <doc xml:space="preserve">a #GRelation.</doc>
            <type name="Relation" c:type="GRelation*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the fields of the record to add. These must match the
      number of fields in the #GRelation, and of type #gpointer
      or #gconstpointer.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="print" c:identifier="g_relation_print" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Outputs information about all records in a #GRelation, as well as
the indexes. It is for debugging.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="relation" transfer-ownership="none">
            <doc xml:space="preserve">a #GRelation.</doc>
            <type name="Relation" c:type="GRelation*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="select" c:identifier="g_relation_select" introspectable="0" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Returns all of the tuples which have the given key in the given
field. Use g_tuples_index() to access the returned records. The
returned records should be freed with g_tuples_destroy().</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value>
          <doc xml:space="preserve">the records (tuples) that matched.</doc>
          <type name="Tuples" c:type="GTuples*"/>
        </return-value>
        <parameters>
          <instance-parameter name="relation" transfer-ownership="none">
            <doc xml:space="preserve">a #GRelation.</doc>
            <type name="Relation" c:type="GRelation*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value to compare with.</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">the field of each record to match.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_relation_new" introspectable="0" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Creates a new #GRelation with the given number of fields. Note that
currently the number of fields must be 2.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value>
          <doc xml:space="preserve">a new #GRelation.</doc>
          <type name="Relation" c:type="GRelation*"/>
        </return-value>
        <parameters>
          <parameter name="fields" transfer-ownership="none">
            <doc xml:space="preserve">the number of fields.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <constant name="SEARCHPATH_SEPARATOR" value="58" c:type="G_SEARCHPATH_SEPARATOR">
      <doc xml:space="preserve">The search path separator character.
This is ':' on UNIX machines and ';' under Windows.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SEARCHPATH_SEPARATOR_S" value=":" c:type="G_SEARCHPATH_SEPARATOR_S">
      <doc xml:space="preserve">The search path separator as a string.
This is ":" on UNIX machines and ";" under Windows.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SIZEOF_LONG" value="8" c:type="GLIB_SIZEOF_LONG">
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="SIZEOF_MEMBER" c:identifier="G_SIZEOF_MEMBER" version="2.64" introspectable="0">
      <doc xml:space="preserve">Returns the size of @member in the struct definition without having a
declared instance of @struct_type.</doc>
      <parameters>
        <parameter name="struct_type">
          <doc xml:space="preserve">a structure type, e.g. #GOutputVector</doc>
        </parameter>
        <parameter name="member">
          <doc xml:space="preserve">a field in the structure, e.g. `size`</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="SIZEOF_SIZE_T" value="8" c:type="GLIB_SIZEOF_SIZE_T">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SIZEOF_SSIZE_T" value="8" c:type="GLIB_SIZEOF_SSIZE_T">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SIZEOF_VOID_P" value="8" c:type="GLIB_SIZEOF_VOID_P">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="SList" c:type="GSList">
      <doc xml:space="preserve">The #GSList struct is used for each element in the singly-linked
list.</doc>
      <field name="data" writable="1">
        <doc xml:space="preserve">holds the element's data, which can be a pointer to any kind
       of data, or any integer value using the
       [Type Conversion Macros](conversion-macros.html#conversion-macros)</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="next" writable="1">
        <doc xml:space="preserve">contains the link to the next element in the list.</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <function name="alloc" c:identifier="g_slist_alloc" introspectable="0">
        <doc xml:space="preserve">Allocates space for one #GSList element. It is called by the
g_slist_append(), g_slist_prepend(), g_slist_insert() and
g_slist_insert_sorted() functions and so is rarely used on its own.</doc>
        <return-value>
          <doc xml:space="preserve">a pointer to the newly-allocated #GSList element.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
      </function>
      <function name="append" c:identifier="g_slist_append" introspectable="0">
        <doc xml:space="preserve">Adds a new element on to the end of the list.

Note that the return value is the new start of the list
if @list was empty; make sure you store the new value.

Note that g_slist_append() has to traverse the entire list
to find the end, which is inefficient when adding multiple
elements. A common idiom to avoid the inefficiency is to prepend
the elements and reverse the list when all elements have been added.

|[&lt;!-- language="C" --&gt;
// Notice that these are initialized to the empty list.
GSList *list = NULL, *number_list = NULL;

// This is a list of strings.
list = g_slist_append (list, "first");
list = g_slist_append (list, "second");

// This is a list of integers.
number_list = g_slist_append (number_list, GINT_TO_POINTER (27));
number_list = g_slist_append (number_list, GINT_TO_POINTER (14));
]|</doc>
        <return-value>
          <doc xml:space="preserve">either @list or the new start of the #GSList if @list was %NULL</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="concat" c:identifier="g_slist_concat" introspectable="0">
        <doc xml:space="preserve">Adds the second #GSList onto the end of the first #GSList.
Note that the elements of the second #GSList are not copied.
They are used directly.</doc>
        <return-value>
          <doc xml:space="preserve">the start of the new #GSList</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list1" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="list2" transfer-ownership="none">
            <doc xml:space="preserve">the #GSList to add to the end of the first #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="copy" c:identifier="g_slist_copy" introspectable="0">
        <doc xml:space="preserve">Copies a #GSList.

Note that this is a "shallow" copy. If the list elements
consist of pointers to data, the pointers are copied but
the actual data isn't. See g_slist_copy_deep() if you need
to copy the data as well.</doc>
        <return-value>
          <doc xml:space="preserve">a copy of @list</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="copy_deep" c:identifier="g_slist_copy_deep" version="2.34" introspectable="0">
        <doc xml:space="preserve">Makes a full (deep) copy of a #GSList.

In contrast with g_slist_copy(), this function uses @func to make a copy of
each list element, in addition to copying the list container itself.

@func, as a #GCopyFunc, takes two arguments, the data to be copied
and a @user_data pointer. On common processor architectures, it's safe to
pass %NULL as @user_data if the copy function takes only one argument. You
may get compiler warnings from this though if compiling with GCC&#x2019;s
`-Wcast-function-type` warning.

For instance, if @list holds a list of GObjects, you can do:
|[&lt;!-- language="C" --&gt;
another_list = g_slist_copy_deep (list, (GCopyFunc) g_object_ref, NULL);
]|

And, to entirely free the new list, you could do:
|[&lt;!-- language="C" --&gt;
g_slist_free_full (another_list, g_object_unref);
]|</doc>
        <return-value>
          <doc xml:space="preserve">a full copy of @list, use g_slist_free_full() to free it</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">a copy function used to copy every element in the list</doc>
            <type name="CopyFunc" c:type="GCopyFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to the copy function @func, or #NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="delete_link" c:identifier="g_slist_delete_link" introspectable="0">
        <doc xml:space="preserve">Removes the node link_ from the list and frees it.
Compare this to g_slist_remove_link() which removes the node
without freeing it.

Removing arbitrary nodes from a singly-linked list requires time
that is proportional to the length of the list (ie. O(n)). If you
find yourself using g_slist_delete_link() frequently, you should
consider a different data structure, such as the doubly-linked
#GList.</doc>
        <return-value>
          <doc xml:space="preserve">the new head of @list</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">node to delete</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="find" c:identifier="g_slist_find" introspectable="0">
        <doc xml:space="preserve">Finds the element in a #GSList which
contains the given data.</doc>
        <return-value>
          <doc xml:space="preserve">the found #GSList element,
    or %NULL if it is not found</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the element data to find</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_custom" c:identifier="g_slist_find_custom" introspectable="0">
        <doc xml:space="preserve">Finds an element in a #GSList, using a supplied function to
find the desired element. It iterates over the list, calling
the given function which should return 0 when the desired
element is found. The function takes two #gconstpointer arguments,
the #GSList element's data as the first argument and the
given user data.</doc>
        <return-value>
          <doc xml:space="preserve">the found #GSList element, or %NULL if it is not found</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to the function</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">the function to call for each element.
    It should return 0 when the desired element is found</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="foreach" c:identifier="g_slist_foreach" introspectable="0">
        <doc xml:space="preserve">Calls a function for each element of a #GSList.

It is safe for @func to remove the element from @list, but it must
not modify any part of the list after that element.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call with each element's data</doc>
            <type name="Func" c:type="GFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="free" c:identifier="g_slist_free" introspectable="0">
        <doc xml:space="preserve">Frees all of the memory used by a #GSList.
The freed elements are returned to the slice allocator.

If list elements contain dynamically-allocated memory,
you should either use g_slist_free_full() or free them manually
first.

It can be combined with g_steal_pointer() to ensure the list head pointer
is not left dangling:
|[&lt;!-- language="C" --&gt;
GSList *list_of_borrowed_things = &#x2026;;  /&lt;!-- --&gt;* (transfer container) *&lt;!-- --&gt;/
g_slist_free (g_steal_pointer (&amp;list_of_borrowed_things));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">the first link of a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free_1" c:identifier="g_slist_free_1" introspectable="0">
        <doc xml:space="preserve">Frees one #GSList element.
It is usually used after g_slist_remove_link().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList element</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free_full" c:identifier="g_slist_free_full" version="2.28" introspectable="0">
        <doc xml:space="preserve">Convenience method, which frees all the memory used by a #GSList, and
calls the specified destroy function on every element's data.

@free_func must not modify the list (eg, by removing the freed
element from it).

It can be combined with g_steal_pointer() to ensure the list head pointer
is not left dangling &#xAD;&#x2014; this also has the nice property that the head pointer
is cleared before any of the list elements are freed, to prevent double frees
from @free_func:
|[&lt;!-- language="C" --&gt;
GSList *list_of_owned_things = &#x2026;;  /&lt;!-- --&gt;* (transfer full) (element-type GObject) *&lt;!-- --&gt;/
g_slist_free_full (g_steal_pointer (&amp;list_of_owned_things), g_object_unref);
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">the first link of a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="free_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">the function to be called to free each element's data</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="index" c:identifier="g_slist_index" introspectable="0">
        <doc xml:space="preserve">Gets the position of the element containing
the given data (starting from 0).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the index of the element containing the data,
    or -1 if the data is not found</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to find</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert" c:identifier="g_slist_insert" introspectable="0">
        <doc xml:space="preserve">Inserts a new element into the list at the given position.</doc>
        <return-value>
          <doc xml:space="preserve">the (possibly changed) start of the #GSList</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the position to insert the element.
    If this is negative, or is larger than the number
    of elements in the list, the new element is added on
    to the end of the list.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert_before" c:identifier="g_slist_insert_before" introspectable="0">
        <doc xml:space="preserve">Inserts a node before @sibling containing @data.</doc>
        <return-value>
          <doc xml:space="preserve">the new head of the list.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="slist" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="sibling" transfer-ownership="none">
            <doc xml:space="preserve">node to insert @data before</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to put in the newly-inserted node</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert_sorted" c:identifier="g_slist_insert_sorted" introspectable="0">
        <doc xml:space="preserve">Inserts a new element into the list, using the given
comparison function to determine its position.</doc>
        <return-value>
          <doc xml:space="preserve">the new start of the #GSList</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">the function to compare elements in the list.
    It should return a number &gt; 0 if the first parameter
    comes after the second parameter in the sort order.</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert_sorted_with_data" c:identifier="g_slist_insert_sorted_with_data" version="2.10" introspectable="0">
        <doc xml:space="preserve">Inserts a new element into the list, using the given
comparison function to determine its position.</doc>
        <return-value>
          <doc xml:space="preserve">the new start of the #GSList</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="3">
            <doc xml:space="preserve">the function to compare elements in the list.
    It should return a number &gt; 0 if the first parameter
    comes after the second parameter in the sort order.</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to comparison function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="last" c:identifier="g_slist_last" introspectable="0">
        <doc xml:space="preserve">Gets the last element in a #GSList.

This function iterates over the whole list.</doc>
        <return-value>
          <doc xml:space="preserve">the last element in the #GSList,
    or %NULL if the #GSList has no elements</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="length" c:identifier="g_slist_length" introspectable="0">
        <doc xml:space="preserve">Gets the number of elements in a #GSList.

This function iterates over the whole list to
count its elements. To check whether the list is non-empty, it is faster to
check @list against %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of elements in the #GSList</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="nth" c:identifier="g_slist_nth" introspectable="0">
        <doc xml:space="preserve">Gets the element at the given position in a #GSList.</doc>
        <return-value>
          <doc xml:space="preserve">the element, or %NULL if the position is off
    the end of the #GSList</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the position of the element, counting from 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="nth_data" c:identifier="g_slist_nth_data" introspectable="0">
        <doc xml:space="preserve">Gets the data of the element at the given position.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the element's data, or %NULL if the position
    is off the end of the #GSList</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">the position of the element</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="pop_allocator" c:identifier="g_slist_pop_allocator" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="position" c:identifier="g_slist_position" introspectable="0">
        <doc xml:space="preserve">Gets the position of the given element
in the #GSList (starting from 0).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the position of the element in the #GSList,
    or -1 if the element is not found</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="llink" transfer-ownership="none">
            <doc xml:space="preserve">an element in the #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="prepend" c:identifier="g_slist_prepend" introspectable="0">
        <doc xml:space="preserve">Adds a new element on to the start of the list.

Note that the return value is the new start of the list,
which will have changed, so make sure you store the new value.

|[&lt;!-- language="C" --&gt;
// Notice that it is initialized to the empty list.
GSList *list = NULL;
list = g_slist_prepend (list, "last");
list = g_slist_prepend (list, "first");
]|</doc>
        <return-value>
          <doc xml:space="preserve">a pointer to the newly prepended element,
which is the new start of the #GSList</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new element</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="push_allocator" c:identifier="g_slist_push_allocator" deprecated="1" deprecated-version="2.10">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="allocator" transfer-ownership="none">
            <type name="Allocator" c:type="GAllocator*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove" c:identifier="g_slist_remove" introspectable="0">
        <doc xml:space="preserve">Removes an element from a #GSList.
If two elements contain the same data, only the first is removed.
If none of the elements contain the data, the #GSList is unchanged.</doc>
        <return-value>
          <doc xml:space="preserve">the new start of the #GSList</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data of the element to remove</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_all" c:identifier="g_slist_remove_all" introspectable="0">
        <doc xml:space="preserve">Removes all list nodes with data equal to @data.
Returns the new head of the list. Contrast with
g_slist_remove() which removes only the first node
matching the given data.</doc>
        <return-value>
          <doc xml:space="preserve">new head of @list</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to remove</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_link" c:identifier="g_slist_remove_link" introspectable="0">
        <doc xml:space="preserve">Removes an element from a #GSList, without
freeing the element. The removed element's next
link is set to %NULL, so that it becomes a
self-contained list with one element.

Removing arbitrary nodes from a singly-linked list
requires time that is proportional to the length of the list
(ie. O(n)). If you find yourself using g_slist_remove_link()
frequently, you should consider a different data structure,
such as the doubly-linked #GList.</doc>
        <return-value>
          <doc xml:space="preserve">the new start of the #GSList, without the element</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="link_" transfer-ownership="none">
            <doc xml:space="preserve">an element in the #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="reverse" c:identifier="g_slist_reverse" introspectable="0">
        <doc xml:space="preserve">Reverses a #GSList.</doc>
        <return-value>
          <doc xml:space="preserve">the start of the reversed #GSList</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="sort" c:identifier="g_slist_sort" introspectable="0">
        <doc xml:space="preserve">Sorts a #GSList using the given comparison function. The algorithm
used is a stable sort.</doc>
        <return-value>
          <doc xml:space="preserve">the start of the sorted #GSList</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">the comparison function used to sort the #GSList.
    This function is passed the data from 2 elements of the #GSList
    and should return 0 if they are equal, a negative value if the
    first element comes before the second, or a positive value if
    the first element comes after the second.</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort_with_data" c:identifier="g_slist_sort_with_data" introspectable="0">
        <doc xml:space="preserve">Like g_slist_sort(), but the sort function accepts a user data argument.</doc>
        <return-value>
          <doc xml:space="preserve">new head of the list</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to comparison function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <constant name="SOURCE_CONTINUE" value="true" c:type="G_SOURCE_CONTINUE" version="2.32">
      <doc xml:space="preserve">Use this macro as the return value of a [callback@GLib.SourceFunc] to leave
the [struct@GLib.Source] in the main loop.</doc>
      <type name="gboolean" c:type="gboolean"/>
    </constant>
    <function-macro name="SOURCE_FUNC" c:identifier="G_SOURCE_FUNC" version="2.58" introspectable="0">
      <doc xml:space="preserve">Cast a function pointer to a [callback@GLib.SourceFunc], suppressing
warnings from GCC 8 onwards with `-Wextra` or `-Wcast-function-type` enabled
about the function types being incompatible.

For example, the correct type of callback for a source created by
[func@GLib.child_watch_source_new] is #GChildWatchFunc, which accepts more
arguments than [callback@GLib.SourceFunc]. Casting the function with
`(GSourceFunc)` to call [method@GLib.Source.set_callback] will trigger a
warning, even though it will be cast back to the correct type before it is
called by the source.</doc>
      <parameters>
        <parameter name="f">
          <doc xml:space="preserve">a function pointer.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="SOURCE_REMOVE" value="false" c:type="G_SOURCE_REMOVE" version="2.32">
      <doc xml:space="preserve">Use this macro as the return value of a [callback@GLib.SourceFunc] to remove
the [struct@GLib.Source] from the main loop.</doc>
      <type name="gboolean" c:type="gboolean"/>
    </constant>
    <constant name="SQRT2" value="1.414214" c:type="G_SQRT2">
      <doc xml:space="preserve">The square root of two.</doc>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <function-macro name="STATIC_ASSERT" c:identifier="G_STATIC_ASSERT" version="2.20" introspectable="0">
      <doc xml:space="preserve">The G_STATIC_ASSERT() macro lets the programmer check
a condition at compile time, the condition needs to
be compile time computable. The macro can be used in
any place where a typedef is valid.

A typedef is generally allowed in exactly the same places that
a variable declaration is allowed. For this reason, you should
not use G_STATIC_ASSERT() in the middle of blocks of code.

The macro should only be used once per source code line.</doc>
      <parameters>
        <parameter name="expr">
          <doc xml:space="preserve">a constant expression</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="STATIC_ASSERT_EXPR" c:identifier="G_STATIC_ASSERT_EXPR" version="2.30" introspectable="0">
      <doc xml:space="preserve">The G_STATIC_ASSERT_EXPR() macro lets the programmer check
a condition at compile time. The condition needs to be
compile time computable.

Unlike G_STATIC_ASSERT(), this macro evaluates to an expression
and, as such, can be used in the middle of other expressions.
Its value should be ignored. This can be accomplished by placing
it as the first argument of a comma expression.

|[&lt;!-- language="C" --&gt;
#define ADD_ONE_TO_INT(x) \
  (G_STATIC_ASSERT_EXPR(sizeof (x) == sizeof (int)), ((x) + 1))
]|</doc>
      <parameters>
        <parameter name="expr">
          <doc xml:space="preserve">a constant expression</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="STRINGIFY" c:identifier="G_STRINGIFY" introspectable="0">
      <doc xml:space="preserve">Accepts a macro or a string and converts it into a string after
preprocessor argument expansion. For example, the following code:

|[&lt;!-- language="C" --&gt;
#define AGE 27
const gchar *greeting = G_STRINGIFY (AGE) " today!";
]|

is transformed by the preprocessor into (code equivalent to):

|[&lt;!-- language="C" --&gt;
const gchar *greeting = "27 today!";
]|</doc>
      <parameters>
        <parameter name="macro_or_string">
          <doc xml:space="preserve">a macro or a string</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="STRINGIFY_ARG" c:identifier="G_STRINGIFY_ARG" introspectable="0">
      <parameters>
        <parameter name="contents">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="STRUCT_MEMBER" c:identifier="G_STRUCT_MEMBER" introspectable="0">
      <doc xml:space="preserve">Returns a member of a structure at a given offset, using the given type.</doc>
      <parameters>
        <parameter name="member_type">
          <doc xml:space="preserve">the type of the struct field</doc>
        </parameter>
        <parameter name="struct_p">
          <doc xml:space="preserve">a pointer to a struct</doc>
        </parameter>
        <parameter name="struct_offset">
          <doc xml:space="preserve">the offset of the field from the start of the struct,
    in bytes</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="STRUCT_MEMBER_P" c:identifier="G_STRUCT_MEMBER_P" introspectable="0">
      <doc xml:space="preserve">Returns an untyped pointer to a given offset of a struct.</doc>
      <parameters>
        <parameter name="struct_p">
          <doc xml:space="preserve">a pointer to a struct</doc>
        </parameter>
        <parameter name="struct_offset">
          <doc xml:space="preserve">the offset from the start of the struct, in bytes</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="STRUCT_OFFSET" c:identifier="G_STRUCT_OFFSET" introspectable="0">
      <doc xml:space="preserve">Returns the offset, in bytes, of a member of a struct.

Consider using standard C `offsetof()`, available since at least C89
and C++98, in new code (but note that `offsetof()` returns a `size_t`
rather than a `long`).</doc>
      <parameters>
        <parameter name="struct_type">
          <doc xml:space="preserve">a structure type, e.g. #GtkWidget</doc>
        </parameter>
        <parameter name="member">
          <doc xml:space="preserve">a field in the structure, e.g. @window</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="STR_DELIMITERS" value="_-|&gt; &lt;." c:type="G_STR_DELIMITERS">
      <doc xml:space="preserve">The standard delimiters, used in [func@GLib.strdelimit].</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SYSDEF_AF_INET" value="2" c:type="GLIB_SYSDEF_AF_INET">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SYSDEF_AF_INET6" value="10" c:type="GLIB_SYSDEF_AF_INET6">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SYSDEF_AF_UNIX" value="1" c:type="GLIB_SYSDEF_AF_UNIX">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SYSDEF_MSG_DONTROUTE" value="4" c:type="GLIB_SYSDEF_MSG_DONTROUTE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SYSDEF_MSG_OOB" value="1" c:type="GLIB_SYSDEF_MSG_OOB">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SYSDEF_MSG_PEEK" value="2" c:type="GLIB_SYSDEF_MSG_PEEK">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Scanner" c:type="GScanner">
      <doc xml:space="preserve">`GScanner` provides a general-purpose lexical scanner.

You should set @input_name after creating the scanner, since
it is used by the default message handler when displaying
warnings and errors. If you are scanning a file, the filename
would be a good choice.

The @user_data and @max_parse_errors fields are not used.
If you need to associate extra data with the scanner you
can place them here.

If you want to use your own message handler you can set the
@msg_handler field. The type of the message handler function
is declared by #GScannerMsgFunc.</doc>
      <field name="user_data" writable="1">
        <doc xml:space="preserve">unused</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="max_parse_errors" writable="1">
        <doc xml:space="preserve">unused</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="parse_errors" writable="1">
        <doc xml:space="preserve">g_scanner_error() increments this field</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="input_name" writable="1">
        <doc xml:space="preserve">name of input stream, featured by the default message handler</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="qdata" writable="1">
        <doc xml:space="preserve">quarked data</doc>
        <type name="Data" c:type="GData*"/>
      </field>
      <field name="config" writable="1">
        <doc xml:space="preserve">link into the scanner configuration</doc>
        <type name="ScannerConfig" c:type="GScannerConfig*"/>
      </field>
      <field name="token" writable="1">
        <doc xml:space="preserve">token parsed by the last g_scanner_get_next_token()</doc>
        <type name="TokenType" c:type="GTokenType"/>
      </field>
      <field name="value" writable="1">
        <doc xml:space="preserve">value of the last token from g_scanner_get_next_token()</doc>
        <type name="TokenValue" c:type="GTokenValue"/>
      </field>
      <field name="line" writable="1">
        <doc xml:space="preserve">line number of the last token from g_scanner_get_next_token()</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="position" writable="1">
        <doc xml:space="preserve">char number of the last token from g_scanner_get_next_token()</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="next_token" writable="1">
        <doc xml:space="preserve">token parsed by the last g_scanner_peek_next_token()</doc>
        <type name="TokenType" c:type="GTokenType"/>
      </field>
      <field name="next_value" writable="1">
        <doc xml:space="preserve">value of the last token from g_scanner_peek_next_token()</doc>
        <type name="TokenValue" c:type="GTokenValue"/>
      </field>
      <field name="next_line" writable="1">
        <doc xml:space="preserve">line number of the last token from g_scanner_peek_next_token()</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="next_position" writable="1">
        <doc xml:space="preserve">char number of the last token from g_scanner_peek_next_token()</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="symbol_table" readable="0" private="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="input_fd" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="text" readable="0" private="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="text_end" readable="0" private="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="buffer" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="scope_id" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="msg_handler" writable="1">
        <doc xml:space="preserve">handler function for _warn and _error</doc>
        <type name="ScannerMsgFunc" c:type="GScannerMsgFunc"/>
      </field>
      <method name="cur_line" c:identifier="g_scanner_cur_line">
        <doc xml:space="preserve">Returns the current line in the input stream (counting
from 1). This is the line of the last token parsed via
g_scanner_get_next_token().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current line</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="cur_position" c:identifier="g_scanner_cur_position">
        <doc xml:space="preserve">Returns the current position in the current line (counting
from 0). This is the position of the last token parsed via
g_scanner_get_next_token().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current position on the line</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="cur_token" c:identifier="g_scanner_cur_token">
        <doc xml:space="preserve">Gets the current token type. This is simply the @token
field in the #GScanner structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current token type</doc>
          <type name="TokenType" c:type="GTokenType"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="cur_value" c:identifier="g_scanner_cur_value" introspectable="0">
        <doc xml:space="preserve">Gets the current token value. This is simply the @value
field in the #GScanner structure.</doc>
        <return-value>
          <doc xml:space="preserve">the current token value</doc>
          <type name="TokenValue" c:type="GTokenValue"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="g_scanner_destroy">
        <doc xml:space="preserve">Frees all memory used by the #GScanner.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="eof" c:identifier="g_scanner_eof">
        <doc xml:space="preserve">Returns %TRUE if the scanner has reached the end of
the file or text buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the scanner has reached the end of
    the file or text buffer</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="error" c:identifier="g_scanner_error" introspectable="0">
        <doc xml:space="preserve">Outputs an error message, via the #GScanner message handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the message format. See the printf() documentation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the parameters to insert into the format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_next_token" c:identifier="g_scanner_get_next_token">
        <doc xml:space="preserve">Parses the next token just like g_scanner_peek_next_token()
and also removes it from the input stream. The token data is
placed in the @token, @value, @line, and @position fields of
the #GScanner structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the token</doc>
          <type name="TokenType" c:type="GTokenType"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="input_file" c:identifier="g_scanner_input_file">
        <doc xml:space="preserve">Prepares to scan a file.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
          <parameter name="input_fd" transfer-ownership="none">
            <doc xml:space="preserve">a file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="input_text" c:identifier="g_scanner_input_text">
        <doc xml:space="preserve">Prepares to scan a text buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">the text buffer to scan</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="text_len" transfer-ownership="none">
            <doc xml:space="preserve">the length of the text buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_symbol" c:identifier="g_scanner_lookup_symbol">
        <doc xml:space="preserve">Looks up a symbol in the current scope and return its value.
If the symbol is not bound in the current scope, %NULL is
returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the value of @symbol in the current scope, or %NULL
    if @symbol is not bound in the current scope</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
          <parameter name="symbol" transfer-ownership="none">
            <doc xml:space="preserve">the symbol to look up</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_next_token" c:identifier="g_scanner_peek_next_token">
        <doc xml:space="preserve">Parses the next token, without removing it from the input stream.
The token data is placed in the @next_token, @next_value, @next_line,
and @next_position fields of the #GScanner structure.

Note that, while the token is not removed from the input stream
(i.e. the next call to g_scanner_get_next_token() will return the
same token), it will not be reevaluated. This can lead to surprising
results when changing scope or the scanner configuration after peeking
the next token. Getting the next token after switching the scope or
configuration will return whatever was peeked before, regardless of
any symbols that may have been added or removed in the new scope.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the token</doc>
          <type name="TokenType" c:type="GTokenType"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="scope_add_symbol" c:identifier="g_scanner_scope_add_symbol">
        <doc xml:space="preserve">Adds a symbol to the given scope.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
          <parameter name="scope_id" transfer-ownership="none">
            <doc xml:space="preserve">the scope id</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="symbol" transfer-ownership="none">
            <doc xml:space="preserve">the symbol to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value of the symbol</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="scope_foreach_symbol" c:identifier="g_scanner_scope_foreach_symbol">
        <doc xml:space="preserve">Calls the given function for each of the symbol/value pairs
in the given scope of the #GScanner. The function is passed
the symbol and value of each pair, and the given @user_data
parameter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
          <parameter name="scope_id" transfer-ownership="none">
            <doc xml:space="preserve">the scope id</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call for each symbol/value pair</doc>
            <type name="HFunc" c:type="GHFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="scope_lookup_symbol" c:identifier="g_scanner_scope_lookup_symbol">
        <doc xml:space="preserve">Looks up a symbol in a scope and return its value. If the
symbol is not bound in the scope, %NULL is returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the value of @symbol in the given scope, or %NULL
    if @symbol is not bound in the given scope.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
          <parameter name="scope_id" transfer-ownership="none">
            <doc xml:space="preserve">the scope id</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="symbol" transfer-ownership="none">
            <doc xml:space="preserve">the symbol to look up</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scope_remove_symbol" c:identifier="g_scanner_scope_remove_symbol">
        <doc xml:space="preserve">Removes a symbol from a scope.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
          <parameter name="scope_id" transfer-ownership="none">
            <doc xml:space="preserve">the scope id</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="symbol" transfer-ownership="none">
            <doc xml:space="preserve">the symbol to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_scope" c:identifier="g_scanner_set_scope">
        <doc xml:space="preserve">Sets the current scope.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the old scope id</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
          <parameter name="scope_id" transfer-ownership="none">
            <doc xml:space="preserve">the new scope id</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync_file_offset" c:identifier="g_scanner_sync_file_offset">
        <doc xml:space="preserve">Rewinds the filedescriptor to the current buffer position
and blows the file read ahead buffer. This is useful for
third party uses of the scanners filedescriptor, which hooks
onto the current scanning position.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unexp_token" c:identifier="g_scanner_unexp_token">
        <doc xml:space="preserve">Outputs a message through the scanner's msg_handler,
resulting from an unexpected token in the input stream.
Note that you should not call g_scanner_peek_next_token()
followed by g_scanner_unexp_token() without an intermediate
call to g_scanner_get_next_token(), as g_scanner_unexp_token()
evaluates the scanner's current token (not the peeked token)
to construct part of the message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
          <parameter name="expected_token" transfer-ownership="none">
            <doc xml:space="preserve">the expected token</doc>
            <type name="TokenType" c:type="GTokenType"/>
          </parameter>
          <parameter name="identifier_spec" transfer-ownership="none">
            <doc xml:space="preserve">a string describing how the scanner's user
    refers to identifiers (%NULL defaults to "identifier").
    This is used if @expected_token is %G_TOKEN_IDENTIFIER or
    %G_TOKEN_IDENTIFIER_NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="symbol_spec" transfer-ownership="none">
            <doc xml:space="preserve">a string describing how the scanner's user refers
    to symbols (%NULL defaults to "symbol"). This is used if
    @expected_token is %G_TOKEN_SYMBOL or any token value greater
    than %G_TOKEN_LAST.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="symbol_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the symbol, if the scanner's current
    token is a symbol.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a message string to output at the end of the
    warning/error, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="is_error" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE it is output as an error. If %FALSE it is
    output as a warning.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="warn" c:identifier="g_scanner_warn" introspectable="0">
        <doc xml:space="preserve">Outputs a warning message, via the #GScanner message handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #GScanner</doc>
            <type name="Scanner" c:type="GScanner*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the message format. See the printf() documentation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the parameters to insert into the format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_scanner_new" introspectable="0">
        <doc xml:space="preserve">Creates a new #GScanner.

The @config_templ structure specifies the initial settings
of the scanner, which are copied into the #GScanner
@config field. If you pass %NULL then the default settings
are used.</doc>
        <return-value>
          <doc xml:space="preserve">the new #GScanner</doc>
          <type name="Scanner" c:type="GScanner*"/>
        </return-value>
        <parameters>
          <parameter name="config_templ" transfer-ownership="none">
            <doc xml:space="preserve">the initial scanner settings</doc>
            <type name="ScannerConfig" c:type="const GScannerConfig*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ScannerConfig" c:type="GScannerConfig">
      <doc xml:space="preserve">Specifies the #GScanner parser configuration. Most settings can
be changed during the parsing phase and will affect the lexical
parsing of the next unpeeked token.</doc>
      <field name="cset_skip_characters" writable="1">
        <doc xml:space="preserve">specifies which characters should be skipped
    by the scanner (the default is the whitespace characters: space,
    tab, carriage-return and line-feed).</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="cset_identifier_first" writable="1">
        <doc xml:space="preserve">specifies the characters which can start
    identifiers (the default is %G_CSET_a_2_z, "_", and %G_CSET_A_2_Z).</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="cset_identifier_nth" writable="1">
        <doc xml:space="preserve">specifies the characters which can be used
    in identifiers, after the first character (the default is
    %G_CSET_a_2_z, "_0123456789", %G_CSET_A_2_Z, %G_CSET_LATINS,
    %G_CSET_LATINC).</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="cpair_comment_single" writable="1">
        <doc xml:space="preserve">specifies the characters at the start and
    end of single-line comments. The default is "#\n" which means
    that single-line comments start with a '#' and continue until
    a '\n' (end of line).</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="case_sensitive" writable="1" bits="1">
        <doc xml:space="preserve">specifies if symbols are case sensitive (the
    default is %FALSE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="skip_comment_multi" writable="1" bits="1">
        <doc xml:space="preserve">specifies if multi-line comments are skipped
    and not returned as tokens (the default is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="skip_comment_single" writable="1" bits="1">
        <doc xml:space="preserve">specifies if single-line comments are skipped
    and not returned as tokens (the default is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_comment_multi" writable="1" bits="1">
        <doc xml:space="preserve">specifies if multi-line comments are recognized
    (the default is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_identifier" writable="1" bits="1">
        <doc xml:space="preserve">specifies if identifiers are recognized (the
    default is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_identifier_1char" writable="1" bits="1">
        <doc xml:space="preserve">specifies if single-character
    identifiers are recognized (the default is %FALSE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_identifier_NULL" writable="1" bits="1">
        <doc xml:space="preserve">specifies if %NULL is reported as
    %G_TOKEN_IDENTIFIER_NULL (the default is %FALSE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_symbols" writable="1" bits="1">
        <doc xml:space="preserve">specifies if symbols are recognized (the default
    is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_binary" writable="1" bits="1">
        <doc xml:space="preserve">specifies if binary numbers are recognized (the
    default is %FALSE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_octal" writable="1" bits="1">
        <doc xml:space="preserve">specifies if octal numbers are recognized (the
    default is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_float" writable="1" bits="1">
        <doc xml:space="preserve">specifies if floating point numbers are recognized
    (the default is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_hex" writable="1" bits="1">
        <doc xml:space="preserve">specifies if hexadecimal numbers are recognized (the
    default is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_hex_dollar" writable="1" bits="1">
        <doc xml:space="preserve">specifies if '$' is recognized as a prefix for
    hexadecimal numbers (the default is %FALSE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_string_sq" writable="1" bits="1">
        <doc xml:space="preserve">specifies if strings can be enclosed in single
    quotes (the default is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scan_string_dq" writable="1" bits="1">
        <doc xml:space="preserve">specifies if strings can be enclosed in double
    quotes (the default is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="numbers_2_int" writable="1" bits="1">
        <doc xml:space="preserve">specifies if binary, octal and hexadecimal numbers
    are reported as %G_TOKEN_INT (the default is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="int_2_float" writable="1" bits="1">
        <doc xml:space="preserve">specifies if all numbers are reported as %G_TOKEN_FLOAT
    (the default is %FALSE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="identifier_2_string" writable="1" bits="1">
        <doc xml:space="preserve">specifies if identifiers are reported as strings
    (the default is %FALSE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="char_2_token" writable="1" bits="1">
        <doc xml:space="preserve">specifies if characters are reported by setting
    `token = ch` or as %G_TOKEN_CHAR (the default is %TRUE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="symbol_2_token" writable="1" bits="1">
        <doc xml:space="preserve">specifies if symbols are reported by setting
    `token = v_symbol` or as %G_TOKEN_SYMBOL (the default is %FALSE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="scope_0_fallback" writable="1" bits="1">
        <doc xml:space="preserve">specifies if a symbol is searched for in the
    default scope in addition to the current scope (the default is %FALSE).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="store_int64" writable="1" bits="1">
        <doc xml:space="preserve">use value.v_int64 rather than v_int</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="padding_dummy" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <callback name="ScannerMsgFunc" c:type="GScannerMsgFunc">
      <doc xml:space="preserve">Specifies the type of the message handler function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="scanner" transfer-ownership="none">
          <doc xml:space="preserve">a #GScanner</doc>
          <type name="Scanner" c:type="GScanner*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">the message</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message signals an error,
    %FALSE if it signals a warning.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SeekType" c:type="GSeekType">
      <doc xml:space="preserve">An enumeration specifying the base position for a
g_io_channel_seek_position() operation.</doc>
      <member name="cur" value="0" c:identifier="G_SEEK_CUR">
        <doc xml:space="preserve">the current position in the file.</doc>
      </member>
      <member name="set" value="1" c:identifier="G_SEEK_SET">
        <doc xml:space="preserve">the start of the file.</doc>
      </member>
      <member name="end" value="2" c:identifier="G_SEEK_END">
        <doc xml:space="preserve">the end of the file.</doc>
      </member>
    </enumeration>
    <record name="Sequence" c:type="GSequence" disguised="1" opaque="1">
      <doc xml:space="preserve">The #GSequence struct is an opaque data type representing a
[sequence](data-structures.html#scalable-lists) data type.</doc>
      <method name="append" c:identifier="g_sequence_append" version="2.14">
        <doc xml:space="preserve">Adds a new item to the end of @seq.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an iterator pointing to the new item</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new item</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="g_sequence_foreach" version="2.14">
        <doc xml:space="preserve">Calls @func for each item in the sequence passing @user_data
to the function. @func must not modify the sequence itself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the function to call for each item in @seq</doc>
            <type name="Func" c:type="GFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_sequence_free" version="2.14">
        <doc xml:space="preserve">Frees the memory allocated for @seq. If @seq has a data destroy
function associated with it, that function is called on all items
in @seq.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_begin_iter" c:identifier="g_sequence_get_begin_iter" version="2.14">
        <doc xml:space="preserve">Returns the begin iterator for @seq.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the begin iterator for @seq.</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_end_iter" c:identifier="g_sequence_get_end_iter" version="2.14">
        <doc xml:space="preserve">Returns the end iterator for @seg</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the end iterator for @seq</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_iter_at_pos" c:identifier="g_sequence_get_iter_at_pos" version="2.14">
        <doc xml:space="preserve">Returns the iterator at position @pos. If @pos is negative or larger
than the number of items in @seq, the end iterator is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #GSequenceIter at position @pos</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">a position in @seq, or -1 for the end</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="g_sequence_get_length" version="2.14">
        <doc xml:space="preserve">Returns the positive length (&gt;= 0) of @seq. Note that this method is
O(h) where `h' is the height of the tree. It is thus more efficient
to use g_sequence_is_empty() when comparing the length to zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of @seq</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert_sorted" c:identifier="g_sequence_insert_sorted" version="2.14">
        <doc xml:space="preserve">Inserts @data into @seq using @cmp_func to determine the new
position. The sequence must already be sorted according to @cmp_func;
otherwise the new position of @data is undefined.

@cmp_func is called with two items of the @seq, and @cmp_data.
It should return 0 if the items are equal, a negative value
if the first item comes before the second, and a positive value
if the second item comes before the first.

Note that when adding a large amount of data to a #GSequence,
it is more efficient to do unsorted insertions and then call
g_sequence_sort() or g_sequence_sort_iter().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter pointing to the new item.</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to insert</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="cmp_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function used to compare items in the sequence</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @cmp_func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_sorted_iter" c:identifier="g_sequence_insert_sorted_iter" version="2.14">
        <doc xml:space="preserve">Like g_sequence_insert_sorted(), but uses
a #GSequenceIterCompareFunc instead of a #GCompareDataFunc as
the compare function.

@iter_cmp is called with two iterators pointing into @seq.
It should return 0 if the iterators are equal, a negative
value if the first iterator comes before the second, and a
positive value if the second iterator comes before the first.

Note that when adding a large amount of data to a #GSequence,
it is more efficient to do unsorted insertions and then call
g_sequence_sort() or g_sequence_sort_iter().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter pointing to the new item</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for the new item</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iter_cmp" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function used to compare iterators in the sequence</doc>
            <type name="SequenceIterCompareFunc" c:type="GSequenceIterCompareFunc"/>
          </parameter>
          <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @iter_cmp</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="g_sequence_is_empty" version="2.48">
        <doc xml:space="preserve">Returns %TRUE if the sequence contains zero items.

This function is functionally identical to checking the result of
g_sequence_get_length() being equal to zero. However this function is
implemented in O(1) running time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the sequence is empty, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="g_sequence_lookup" version="2.28">
        <doc xml:space="preserve">Returns an iterator pointing to the position of the first item found
equal to @data according to @cmp_func and @cmp_data. If more than one
item is equal, it is not guaranteed that it is the first which is
returned. In that case, you can use g_sequence_iter_next() and
g_sequence_iter_prev() to get others.

@cmp_func is called with two items of the @seq, and @cmp_data.
It should return 0 if the items are equal, a negative value if
the first item comes before the second, and a positive value if
the second item comes before the first.

This function will fail if the data contained in the sequence is
unsorted.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">an #GSequenceIter pointing to the position of the
    first item found equal to @data according to @cmp_func and
    @cmp_data, or %NULL if no such item exists</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to look up</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="cmp_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function used to compare items in the sequence</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @cmp_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_iter" c:identifier="g_sequence_lookup_iter" version="2.28">
        <doc xml:space="preserve">Like g_sequence_lookup(), but uses a #GSequenceIterCompareFunc
instead of a #GCompareDataFunc as the compare function.

@iter_cmp is called with two iterators pointing into @seq.
It should return 0 if the iterators are equal, a negative value
if the first iterator comes before the second, and a positive
value if the second iterator comes before the first.

This function will fail if the data contained in the sequence is
unsorted.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">an #GSequenceIter pointing to the position of
    the first item found equal to @data according to @iter_cmp
    and @cmp_data, or %NULL if no such item exists</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to look up</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iter_cmp" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function used to compare iterators in the sequence</doc>
            <type name="SequenceIterCompareFunc" c:type="GSequenceIterCompareFunc"/>
          </parameter>
          <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @iter_cmp</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend" c:identifier="g_sequence_prepend" version="2.14">
        <doc xml:space="preserve">Adds a new item to the front of @seq</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an iterator pointing to the new item</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new item</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="search" c:identifier="g_sequence_search" version="2.14">
        <doc xml:space="preserve">Returns an iterator pointing to the position where @data would
be inserted according to @cmp_func and @cmp_data.

@cmp_func is called with two items of the @seq, and @cmp_data.
It should return 0 if the items are equal, a negative value if
the first item comes before the second, and a positive value if
the second item comes before the first.

If you are simply searching for an existing element of the sequence,
consider using g_sequence_lookup().

This function will fail if the data contained in the sequence is
unsorted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #GSequenceIter pointing to the position where @data
    would have been inserted according to @cmp_func and @cmp_data</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for the new item</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="cmp_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function used to compare items in the sequence</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @cmp_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_iter" c:identifier="g_sequence_search_iter" version="2.14">
        <doc xml:space="preserve">Like g_sequence_search(), but uses a #GSequenceIterCompareFunc
instead of a #GCompareDataFunc as the compare function.

@iter_cmp is called with two iterators pointing into @seq.
It should return 0 if the iterators are equal, a negative value
if the first iterator comes before the second, and a positive
value if the second iterator comes before the first.

If you are simply searching for an existing element of the sequence,
consider using g_sequence_lookup_iter().

This function will fail if the data contained in the sequence is
unsorted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter pointing to the position in @seq
    where @data would have been inserted according to @iter_cmp
    and @cmp_data</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for the new item</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iter_cmp" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function used to compare iterators in the sequence</doc>
            <type name="SequenceIterCompareFunc" c:type="GSequenceIterCompareFunc"/>
          </parameter>
          <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @iter_cmp</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="sort" c:identifier="g_sequence_sort" version="2.14">
        <doc xml:space="preserve">Sorts @seq using @cmp_func.

@cmp_func is passed two items of @seq and should
return 0 if they are equal, a negative value if the
first comes before the second, and a positive value
if the second comes before the first.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="cmp_func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the function used to sort the sequence</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @cmp_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="sort_iter" c:identifier="g_sequence_sort_iter" version="2.14">
        <doc xml:space="preserve">Like g_sequence_sort(), but uses a #GSequenceIterCompareFunc instead
of a #GCompareDataFunc as the compare function

@cmp_func is called with two iterators pointing into @seq. It should
return 0 if the iterators are equal, a negative value if the first
iterator comes before the second, and a positive value if the second
iterator comes before the first.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="seq" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequence</doc>
            <type name="Sequence" c:type="GSequence*"/>
          </instance-parameter>
          <parameter name="cmp_func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the function used to compare iterators in the sequence</doc>
            <type name="SequenceIterCompareFunc" c:type="GSequenceIterCompareFunc"/>
          </parameter>
          <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @cmp_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <function name="foreach_range" c:identifier="g_sequence_foreach_range" version="2.14">
        <doc xml:space="preserve">Calls @func for each item in the range (@begin, @end) passing
@user_data to the function. @func must not modify the sequence
itself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="begin" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="3">
            <doc xml:space="preserve">a #GFunc</doc>
            <type name="Func" c:type="GFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="get" c:identifier="g_sequence_get" version="2.14">
        <doc xml:space="preserve">Returns the data that @iter points to.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the data that @iter points to</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="insert_before" c:identifier="g_sequence_insert_before" version="2.14">
        <doc xml:space="preserve">Inserts a new item just before the item pointed to by @iter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an iterator pointing to the new item</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data for the new item</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="move" c:identifier="g_sequence_move" version="2.14">
        <doc xml:space="preserve">Moves the item pointed to by @src to the position indicated by @dest.
After calling this function @dest will point to the position immediately
after @src. It is allowed for @src and @dest to point into different
sequences.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter pointing to the item to move</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter pointing to the position to which
    the item is moved</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="move_range" c:identifier="g_sequence_move_range" version="2.14">
        <doc xml:space="preserve">Inserts the (@begin, @end) range at the destination pointed to by @dest.
The @begin and @end iters must point into the same sequence. It is
allowed for @dest to point to a different sequence than the one pointed
into by @begin and @end.

If @dest is %NULL, the range indicated by @begin and @end is
removed from the sequence. If @dest points to a place within
the (@begin, @end) range, the range does not move.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="begin" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="g_sequence_new" version="2.14" introspectable="0">
        <doc xml:space="preserve">Creates a new GSequence. The @data_destroy function, if non-%NULL will
be called on all items when the sequence is destroyed and on items that
are removed from the sequence.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSequence</doc>
          <type name="Sequence" c:type="GSequence*"/>
        </return-value>
        <parameters>
          <parameter name="data_destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify function, or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="range_get_midpoint" c:identifier="g_sequence_range_get_midpoint" version="2.14">
        <doc xml:space="preserve">Finds an iterator somewhere in the range (@begin, @end). This
iterator will be close to the middle of the range, but is not
guaranteed to be exactly in the middle.

The @begin and @end iterators must both point to the same sequence
and @begin must come before or be equal to @end in the sequence.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter pointing somewhere in the
   (@begin, @end) range</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <parameter name="begin" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove" c:identifier="g_sequence_remove" version="2.14">
        <doc xml:space="preserve">Removes the item pointed to by @iter. It is an error to pass the
end iterator to this function.

If the sequence has a data destroy function associated with it, this
function is called on the data for the removed item.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_range" c:identifier="g_sequence_remove_range" version="2.14">
        <doc xml:space="preserve">Removes all items in the (@begin, @end) range.

If the sequence has a data destroy function associated with it, this
function is called on the data for the removed items.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="begin" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="set" c:identifier="g_sequence_set" version="2.14">
        <doc xml:space="preserve">Changes the data for the item pointed to by @iter to be @data. If
the sequence has a data destroy function associated with it, that
function is called on the existing data that @iter pointed to.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">new data for the item</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort_changed" c:identifier="g_sequence_sort_changed" version="2.14">
        <doc xml:space="preserve">Moves the data pointed to by @iter to a new position as indicated by
@cmp_func. This
function should be called for items in a sequence already sorted according
to @cmp_func whenever some aspect of an item changes so that @cmp_func
may return different values for that item.

@cmp_func is called with two items of the @seq, and @cmp_data.
It should return 0 if the items are equal, a negative value if
the first item comes before the second, and a positive value if
the second item comes before the first.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">A #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="cmp_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function used to compare items in the sequence</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @cmp_func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="sort_changed_iter" c:identifier="g_sequence_sort_changed_iter" version="2.14">
        <doc xml:space="preserve">Like g_sequence_sort_changed(), but uses
a #GSequenceIterCompareFunc instead of a #GCompareDataFunc as
the compare function.

@iter_cmp is called with two iterators pointing into the #GSequence that
@iter points into. It should
return 0 if the iterators are equal, a negative value if the first
iterator comes before the second, and a positive value if the second
iterator comes before the first.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="iter_cmp" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function used to compare iterators in the sequence</doc>
            <type name="SequenceIterCompareFunc" c:type="GSequenceIterCompareFunc"/>
          </parameter>
          <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @cmp_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="swap" c:identifier="g_sequence_swap" version="2.14">
        <doc xml:space="preserve">Swaps the items pointed to by @a and @b. It is allowed for @a and @b
to point into difference sequences.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="SequenceIter" c:type="GSequenceIter" disguised="1" opaque="1">
      <doc xml:space="preserve">The #GSequenceIter struct is an opaque data type representing an
iterator pointing into a #GSequence.</doc>
      <method name="compare" c:identifier="g_sequence_iter_compare" version="2.14">
        <doc xml:space="preserve">Returns a negative number if @a comes before @b, 0 if they are equal,
and a positive number if @a comes after @b.

The @a and @b iterators must point into the same sequence.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a negative number if @a comes before @b, 0 if they are
    equal, and a positive number if @a comes after @b</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_position" c:identifier="g_sequence_iter_get_position" version="2.14">
        <doc xml:space="preserve">Returns the position of @iter</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the position of @iter</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sequence" c:identifier="g_sequence_iter_get_sequence" version="2.14">
        <doc xml:space="preserve">Returns the #GSequence that @iter points into.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GSequence that @iter points into</doc>
          <type name="Sequence" c:type="GSequence*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_begin" c:identifier="g_sequence_iter_is_begin" version="2.14">
        <doc xml:space="preserve">Returns whether @iter is the begin iterator</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @iter is the begin iterator</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_end" c:identifier="g_sequence_iter_is_end" version="2.14">
        <doc xml:space="preserve">Returns whether @iter is the end iterator</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether @iter is the end iterator</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="move" c:identifier="g_sequence_iter_move" version="2.14">
        <doc xml:space="preserve">Returns the #GSequenceIter which is @delta positions away from @iter.
If @iter is closer than -@delta positions to the beginning of the sequence,
the begin iterator is returned. If @iter is closer than @delta positions
to the end of the sequence, the end iterator is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter which is @delta positions away from @iter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </instance-parameter>
          <parameter name="delta" transfer-ownership="none">
            <doc xml:space="preserve">A positive or negative number indicating how many positions away
   from @iter the returned #GSequenceIter will be</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="g_sequence_iter_next" version="2.14">
        <doc xml:space="preserve">Returns an iterator pointing to the next position after @iter.
If @iter is the end iterator, the end iterator is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter pointing to the next position after @iter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="prev" c:identifier="g_sequence_iter_prev" version="2.14">
        <doc xml:space="preserve">Returns an iterator pointing to the previous position before @iter.
If @iter is the begin iterator, the begin iterator is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter pointing to the previous position
    before @iter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GSequenceIter</doc>
            <type name="SequenceIter" c:type="GSequenceIter*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="SequenceIterCompareFunc" c:type="GSequenceIterCompareFunc">
      <doc xml:space="preserve">A #GSequenceIterCompareFunc is a function used to compare iterators.
It must return zero if the iterators compare equal, a negative value
if @a comes before @b, and a positive value if @b comes before @a.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">zero if the iterators are equal, a negative value if @a
    comes before @b, and a positive value if @b comes before @a.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ShellError" c:type="GShellError" glib:error-domain="g-shell-error-quark">
      <doc xml:space="preserve">Error codes returned by shell functions.</doc>
      <member name="bad_quoting" value="0" c:identifier="G_SHELL_ERROR_BAD_QUOTING">
        <doc xml:space="preserve">Mismatched or otherwise mangled quoting.</doc>
      </member>
      <member name="empty_string" value="1" c:identifier="G_SHELL_ERROR_EMPTY_STRING">
        <doc xml:space="preserve">String to be parsed was empty.</doc>
      </member>
      <member name="failed" value="2" c:identifier="G_SHELL_ERROR_FAILED">
        <doc xml:space="preserve">Some other error.</doc>
      </member>
    </enumeration>
    <enumeration name="SliceConfig" c:type="GSliceConfig">
      <member name="always_malloc" value="1" c:identifier="G_SLICE_CONFIG_ALWAYS_MALLOC">
      </member>
      <member name="bypass_magazines" value="2" c:identifier="G_SLICE_CONFIG_BYPASS_MAGAZINES">
      </member>
      <member name="working_set_msecs" value="3" c:identifier="G_SLICE_CONFIG_WORKING_SET_MSECS">
      </member>
      <member name="color_increment" value="4" c:identifier="G_SLICE_CONFIG_COLOR_INCREMENT">
      </member>
      <member name="chunk_sizes" value="5" c:identifier="G_SLICE_CONFIG_CHUNK_SIZES">
      </member>
      <member name="contention_counter" value="6" c:identifier="G_SLICE_CONFIG_CONTENTION_COUNTER">
      </member>
    </enumeration>
    <record name="Source" c:type="GSource" glib:type-name="GSource" glib:get-type="g_source_get_type" c:symbol-prefix="source">
      <doc xml:space="preserve">The `GSource` struct is an opaque data type
representing an event source.</doc>
      <field name="callback_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="callback_funcs" readable="0" private="1">
        <type name="SourceCallbackFuncs" c:type="GSourceCallbackFuncs*"/>
      </field>
      <field name="source_funcs" readable="0" private="1">
        <type name="SourceFuncs" c:type="const GSourceFuncs*"/>
      </field>
      <field name="ref_count" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="context" readable="0" private="1">
        <type name="MainContext" c:type="GMainContext*"/>
      </field>
      <field name="priority" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="flags" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="source_id" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="poll_fds" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="prev" readable="0" private="1">
        <type name="Source" c:type="GSource*"/>
      </field>
      <field name="next" readable="0" private="1">
        <type name="Source" c:type="GSource*"/>
      </field>
      <field name="name" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SourcePrivate" c:type="GSourcePrivate*"/>
      </field>
      <constructor name="new" c:identifier="g_source_new">
        <doc xml:space="preserve">Creates a new [struct@GLib.Source] structure.

The size is specified to
allow creating structures derived from [struct@GLib.Source] that contain
additional data. The size passed in must be at least
`sizeof (GSource)`.

The source will not initially be associated with any [struct@GLib.MainContext]
and must be added to one with [method@GLib.Source.attach] before it will be
executed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly-created source</doc>
          <type name="Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <parameter name="source_funcs" transfer-ownership="none">
            <doc xml:space="preserve">structure containing functions that implement
  the source&#x2018;s behavior</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*"/>
          </parameter>
          <parameter name="struct_size" transfer-ownership="none">
            <doc xml:space="preserve">size of the [struct@GLib.Source] structure to create, in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_child_source" c:identifier="g_source_add_child_source" version="2.28">
        <doc xml:space="preserve">Adds @child_source to @source as a &#x2018;polled&#x2019; source.

When @source is added to a [struct@GLib.MainContext], @child_source will be
automatically added with the same priority. When @child_source is triggered,
it will cause @source to dispatch (in addition to calling its own callback),
and when @source is destroyed, it will destroy @child_source as well.

The @source will also still be dispatched if its own prepare/check functions
indicate that it is ready.

If you don&#x2019;t need @child_source to do anything on its own when it
triggers, you can call `g_source_set_dummy_callback()` on it to set a
callback that does nothing (except return true if appropriate).

The @source will hold a reference on @child_source while @child_source
is attached to it.

This API is only intended to be used by implementations of [struct@GLib.Source].
Do not call this API on a [struct@GLib.Source] that you did not create.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="child_source" transfer-ownership="none">
            <doc xml:space="preserve">a second source that @source should &#x2018;poll&#x2019;</doc>
            <type name="Source" c:type="GSource*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_poll" c:identifier="g_source_add_poll">
        <doc xml:space="preserve">Adds a file descriptor to the set of file descriptors polled for
this source.

This is usually combined with [ctor@GLib.Source.new] to add an
event source. The event source&#x2019;s check function will typically test
the @revents field in the [struct@GLib.PollFD] struct and return true if
events need to be processed.

This API is only intended to be used by implementations of [struct@GLib.Source].
Do not call this API on a [struct@GLib.Source] that you did not create.

Using this API forces the linear scanning of event sources on each
main loop iteration.  Newly-written event sources should try to use
`g_source_add_unix_fd()` instead of this API.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a [struct@GLib.PollFD] structure holding information about a file
  descriptor to watch</doc>
            <type name="PollFD" c:type="GPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_unix_fd" c:identifier="g_source_add_unix_fd" version="2.36">
        <doc xml:space="preserve">Monitors @fd for the IO events in @events.

The tag returned by this function can be used to remove or modify the
monitoring of the @fd using [method@GLib.Source.remove_unix_fd] or
[method@GLib.Source.modify_unix_fd].

It is not necessary to remove the file descriptor before destroying the
source; it will be cleaned up automatically.

This API is only intended to be used by implementations of [struct@GLib.Source].
Do not call this API on a [struct@GLib.Source] that you did not create.

As the name suggests, this function is not available on Windows.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an opaque tag</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">the file descriptor to monitor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="events" transfer-ownership="none">
            <doc xml:space="preserve">an event mask</doc>
            <type name="IOCondition" c:type="GIOCondition"/>
          </parameter>
        </parameters>
      </method>
      <method name="attach" c:identifier="g_source_attach">
        <doc xml:space="preserve">Adds a [struct@GLib.Source] to a @context so that it will be executed within
that context.

Remove it by calling [method@GLib.Source.destroy].

This function is safe to call from any thread, regardless of which thread
the @context is running in.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID (greater than 0) for the source within the
  [struct@GLib.MainContext]</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a main context (if `NULL`, the global-default
  main context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="g_source_destroy">
        <doc xml:space="preserve">Removes a source from its [struct@GLib.MainContext], if any, and marks it as
destroyed.

The source cannot be subsequently added to another
context. It is safe to call this on sources which have already been
removed from their context.

This does not unref the [struct@GLib.Source]: if you still hold a reference,
use [method@GLib.Source.unref] to drop it.

This function is safe to call from any thread, regardless of which thread
the [struct@GLib.MainContext] is running in.

If the source is currently attached to a [struct@GLib.MainContext],
destroying it will effectively unset the callback similar to calling
[method@GLib.Source.set_callback]. This can mean, that the data&#x2019;s
[callback@GLib.DestroyNotify] gets called right away.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_context" c:identifier="g_source_dup_context" version="2.86">
        <doc xml:space="preserve">Gets a reference to the [struct@GLib.MainContext] with which the source is
associated.

You can call this on a source that has been destroyed. You can
always call this function on the source returned from
[func@GLib.main_current_source].</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the [struct@GLib.MainContext] with which
  the source is associated, or `NULL` if the context has not yet been added
  to a source</doc>
          <type name="MainContext" c:type="GMainContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_can_recurse" c:identifier="g_source_get_can_recurse">
        <doc xml:space="preserve">Checks whether a source is allowed to be called recursively.

See [method@GLib.Source.set_can_recurse].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether recursion is allowed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_context" c:identifier="g_source_get_context">
        <doc xml:space="preserve">Gets the [struct@GLib.MainContext] with which the source is associated.

You can call this on a source that has been destroyed, provided
that the [struct@GLib.MainContext] it was attached to still exists (in which
case it will return that [struct@GLib.MainContext]). In particular, you can
always call this function on the source returned from
[func@GLib.main_current_source]. But calling this function on a source
whose [struct@GLib.MainContext] has been destroyed is an error.

If the associated [struct@GLib.MainContext] could be destroy concurrently from
a different thread, then this function is not safe to call and
[method@GLib.Source.dup_context] should be used instead.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the main context with which the
  source is associated, or `NULL` if the context has not yet been added to a
  source</doc>
          <type name="MainContext" c:type="GMainContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_current_time" c:identifier="g_source_get_current_time" deprecated="1" deprecated-version="2.28">
        <doc xml:space="preserve">This function ignores @source and is otherwise the same as
[func@GLib.get_current_time].</doc>
        <doc-deprecated xml:space="preserve">use [method@GLib.Source.get_time] instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="timeval" transfer-ownership="none">
            <doc xml:space="preserve">[struct@GLib.TimeVal] structure in which to store current time</doc>
            <type name="TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="g_source_get_id">
        <doc xml:space="preserve">Returns the numeric ID for a particular source.

The ID of a source
is a positive integer which is unique within a particular main loop
context. The reverse mapping from ID to source is done by
[method@GLib.MainContext.find_source_by_id].

You can only call this function while the source is associated to a
[struct@GLib.MainContext] instance; calling this function before
[method@GLib.Source.attach] or after [method@GLib.Source.destroy] yields
undefined behavior. The ID returned is unique within the
[struct@GLib.MainContext] instance passed to [method@GLib.Source.attach].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID (greater than 0) for the source</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_source_get_name" version="2.26">
        <doc xml:space="preserve">Gets a name for the source, used in debugging and profiling.

The
name may be `NULL` if it has never been set with [method@GLib.Source.set_name].</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the name of the source</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority" c:identifier="g_source_get_priority">
        <doc xml:space="preserve">Gets the priority of a source.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the priority of the source</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ready_time" c:identifier="g_source_get_ready_time">
        <doc xml:space="preserve">Gets the &#x2018;ready time&#x2019; of @source, as set by
[method@GLib.Source.set_ready_time].

Any time before or equal to the current monotonic time (including zero)
is an indication that the source will fire immediately.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the monotonic ready time, `-1` for &#x2018;never&#x2019;</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_time" c:identifier="g_source_get_time" version="2.28">
        <doc xml:space="preserve">Gets the time to be used when checking this source.

The advantage of
calling this function over calling [func@GLib.get_monotonic_time] directly is
that when checking multiple sources, GLib can cache a single value
instead of having to repeatedly get the system monotonic time.

The time here is the system monotonic time, if available, or some
other reasonable alternative otherwise.  See [func@GLib.get_monotonic_time].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the monotonic time in microseconds</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_destroyed" c:identifier="g_source_is_destroyed" version="2.12">
        <doc xml:space="preserve">Returns whether @source has been destroyed.

This is important when you operate upon your objects
from within idle handlers, but may have freed the object
before the dispatch of your idle handler.

```c
static gboolean
idle_callback (gpointer data)
{
  SomeWidget *self = data;
   
  g_mutex_lock (&amp;self-&gt;idle_id_mutex);
  // do stuff with self
  self-&gt;idle_id = 0;
  g_mutex_unlock (&amp;self-&gt;idle_id_mutex);
   
  return G_SOURCE_REMOVE;
}
 
static void
some_widget_do_stuff_later (SomeWidget *self)
{
  g_mutex_lock (&amp;self-&gt;idle_id_mutex);
  self-&gt;idle_id = g_idle_add (idle_callback, self);
  g_mutex_unlock (&amp;self-&gt;idle_id_mutex);
}
 
static void
some_widget_init (SomeWidget *self)
{
  g_mutex_init (&amp;self-&gt;idle_id_mutex);

  // ...
}

static void
some_widget_finalize (GObject *object)
{
  SomeWidget *self = SOME_WIDGET (object);
   
  if (self-&gt;idle_id)
    g_source_remove (self-&gt;idle_id);
   
  g_mutex_clear (&amp;self-&gt;idle_id_mutex);

  G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
}
```

This will fail in a multi-threaded application if the
widget is destroyed before the idle handler fires due
to the use after free in the callback. A solution, to
this particular problem, is to check to if the source
has already been destroy within the callback.

```c
static gboolean
idle_callback (gpointer data)
{
  SomeWidget *self = data;
  
  g_mutex_lock (&amp;self-&gt;idle_id_mutex);
  if (!g_source_is_destroyed (g_main_current_source ()))
    {
      // do stuff with self
    }
  g_mutex_unlock (&amp;self-&gt;idle_id_mutex);
  
  return FALSE;
}
```

Calls to this function from a thread other than the one acquired by the
[struct@GLib.MainContext] the [struct@GLib.Source] is attached to are typically
redundant, as the source could be destroyed immediately after this function
returns. However, once a source is destroyed it cannot be un-destroyed, so
this function can be used for opportunistic checks from any thread.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if the source has been destroyed, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="modify_unix_fd" c:identifier="g_source_modify_unix_fd" version="2.36">
        <doc xml:space="preserve">Updates the event mask to watch for the file descriptor identified by @tag.

The @tag is the tag returned from [method@GLib.Source.add_unix_fd].

If you want to remove a file descriptor, don&#x2019;t set its event mask to zero.
Instead, call [method@GLib.Source.remove_unix_fd].

This API is only intended to be used by implementations of [struct@GLib.Source].
Do not call this API on a [struct@GLib.Source] that you did not create.

As the name suggests, this function is not available on Windows.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:space="preserve">the tag from [method@GLib.Source.add_unix_fd]</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="new_events" transfer-ownership="none">
            <doc xml:space="preserve">the new event mask to watch</doc>
            <type name="IOCondition" c:type="GIOCondition"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_unix_fd" c:identifier="g_source_query_unix_fd" version="2.36">
        <doc xml:space="preserve">Queries the events reported for the file descriptor corresponding to @tag
on @source during the last poll.

The return value of this function is only defined when the function
is called from the check or dispatch functions for @source.

This API is only intended to be used by implementations of [struct@GLib.Source].
Do not call this API on a [struct@GLib.Source] that you did not create.

As the name suggests, this function is not available on Windows.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the conditions reported on the file descriptor</doc>
          <type name="IOCondition" c:type="GIOCondition"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:space="preserve">the tag from [method@GLib.Source.add_unix_fd]</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_source_ref">
        <doc xml:space="preserve">Increases the reference count on a source by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">@source</doc>
          <type name="Source" c:type="GSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_child_source" c:identifier="g_source_remove_child_source" version="2.28">
        <doc xml:space="preserve">Detaches @child_source from @source and destroys it.

This API is only intended to be used by implementations of [struct@GLib.Source].
Do not call this API on a [struct@GLib.Source] that you did not create.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="child_source" transfer-ownership="none">
            <doc xml:space="preserve">a source previously passed to
  [method@GLib.Source.add_child_source]</doc>
            <type name="Source" c:type="GSource*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_poll" c:identifier="g_source_remove_poll">
        <doc xml:space="preserve">Removes a file descriptor from the set of file descriptors polled for
this source.

This API is only intended to be used by implementations of [struct@GLib.Source].
Do not call this API on a [struct@GLib.Source] that you did not create.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a [struct@GLib.PollFD] structure previously passed to
  [method@GLib.Source.add_poll]</doc>
            <type name="PollFD" c:type="GPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_unix_fd" c:identifier="g_source_remove_unix_fd" version="2.36">
        <doc xml:space="preserve">Reverses the effect of a previous call to [method@GLib.Source.add_unix_fd].

You only need to call this if you want to remove a file descriptor from being
watched while keeping the same source around.  In the normal case you
will just want to destroy the source.

This API is only intended to be used by implementations of [struct@GLib.Source].
Do not call this API on a [struct@GLib.Source] that you did not create.

As the name suggests, this function is not available on Windows.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:space="preserve">the tag from [method@GLib.Source.add_unix_fd]</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_callback" c:identifier="g_source_set_callback">
        <doc xml:space="preserve">Sets the callback function for a source. The callback for a source is
called from the source&#x2019;s dispatch function.

The exact type of @func depends on the type of source; ie. you
should not count on @func being called with @data as its first
parameter. Cast @func with [func@GLib.SOURCE_FUNC] to avoid warnings about
incompatible function types.

See [main loop memory management](main-loop.html#memory-management-of-sources) for details
on how to handle memory management of @data.

Typically, you won&#x2019;t use this function. Instead use functions specific
to the type of source you are using, such as [func@GLib.idle_add] or
[func@GLib.timeout_add].

It is safe to call this function multiple times on a source which has already
been attached to a context. The changes will take effect for the next time
the source is dispatched after this call returns.

Note that [method@GLib.Source.destroy] for a currently attached source has the effect
of also unsetting the callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">a callback function</doc>
            <type name="SourceFunc" c:type="GSourceFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to call when @data is no longer in use</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_callback_indirect" c:identifier="g_source_set_callback_indirect">
        <doc xml:space="preserve">Sets the callback function storing the data as a reference counted callback
&#x2018;object&#x2019;.

This is used internally. Note that calling
[method@GLib.Source.set_callback_indirect] assumes
an initial reference count on @callback_data, and thus
`callback_funcs-&gt;unref` will eventually be called once more than
`callback_funcs-&gt;ref`.

It is safe to call this function multiple times on a source which has already
been attached to a context. The changes will take effect for the next time
the source is dispatched after this call returns.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="callback_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">pointer to callback data &#x2018;object&#x2019;</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="callback_funcs" transfer-ownership="none">
            <doc xml:space="preserve">functions for reference counting @callback_data
  and getting the callback and data</doc>
            <type name="SourceCallbackFuncs" c:type="GSourceCallbackFuncs*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_can_recurse" c:identifier="g_source_set_can_recurse">
        <doc xml:space="preserve">Sets whether a source can be called recursively.

If @can_recurse is true, then while the source is being dispatched then this
source will be processed normally. Otherwise, all processing of this
source is blocked until the dispatch function returns.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="can_recurse" transfer-ownership="none">
            <doc xml:space="preserve">whether recursion is allowed for this source</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dispose_function" c:identifier="g_source_set_dispose_function" version="2.64" introspectable="0">
        <doc xml:space="preserve">Set @dispose as dispose function on @source.

The @dispose function will be called once the reference count of @source
reaches zero but before any of the state of the source is freed, especially
before the finalize function (set as part of the [type@GLib.SourceFuncs]) is
called.

This means that at this point @source is still a valid [struct@GLib.Source]
and it is allow for the reference count to increase again until @dispose
returns.

The dispose function can be used to clear any &#x2018;weak&#x2019; references to
the @source in other data structures in a thread-safe way where it is
possible for another thread to increase the reference count of @source again
while it is being freed.

The finalize function can not be used for this purpose as at that
point @source is already partially freed and not valid any more.

This should only ever be called from [struct@GLib.Source] implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source to set the dispose function on</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="dispose" transfer-ownership="none">
            <doc xml:space="preserve">dispose function to set on the source</doc>
            <type name="SourceDisposeFunc" c:type="GSourceDisposeFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_funcs" c:identifier="g_source_set_funcs" version="2.12">
        <doc xml:space="preserve">Sets the source functions of an unattached source.

These can be used to override the default implementations for the type
of @source.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="funcs" transfer-ownership="none">
            <doc xml:space="preserve">the new source functions</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="g_source_set_name" version="2.26">
        <doc xml:space="preserve">Sets a name for the source, used in debugging and profiling.

The name defaults to `NULL`.

The source name should describe in a human-readable way
what the source does. For example, &#x2018;X11 event queue&#x2019;
or &#x2018;GTK repaint idle handler&#x2019;.

It is permitted to call this function multiple times, but is not
recommended due to the potential performance impact.  For example,
one could change the name in the `check` function of a
[struct@GLib.SourceFuncs] to include details like the event type in the
source name.

Use caution if changing the name while another thread may be
accessing it with [method@GLib.Source.get_name]; that function does not copy
the value, and changing the value will free it while the other thread
may be attempting to use it.

Also see [method@GLib.Source.set_static_name].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">debug name for the source</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority" c:identifier="g_source_set_priority">
        <doc xml:space="preserve">Sets the priority of a source.

While the main loop is being run, a
source will be dispatched if it is ready to be dispatched and no
sources at a higher (numerically smaller) priority are ready to be
dispatched.

A child source always has the same priority as its parent.  It is not
permitted to change the priority of a source once it has been added
as a child of another source.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">the new priority</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ready_time" c:identifier="g_source_set_ready_time" version="2.36">
        <doc xml:space="preserve">Sets a source to be dispatched when the given monotonic time is
reached (or passed).

If the monotonic time is in the past (as it
always will be if @ready_time is `0`) then the source will be
dispatched immediately.

If @ready_time is `-1` then the source is never woken up on the basis
of the passage of time.

Dispatching the source does not reset the ready time.  You should do
so yourself, from the source dispatch function.

Note that if you have a pair of sources where the ready time of one
suggests that it will be delivered first but the priority for the
other suggests that it would be delivered first, and the ready time
for both sources is reached during the same main context iteration,
then the order of dispatch is undefined.

It is a no-op to call this function on a [struct@GLib.Source] which has
already been destroyed with [method@GLib.Source.destroy].

This API is only intended to be used by implementations of [struct@GLib.Source].
Do not call this API on a [struct@GLib.Source] that you did not create.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="ready_time" transfer-ownership="none">
            <doc xml:space="preserve">the monotonic time at which the source will be ready;
  `0` for &#x2018;immediately&#x2019;, `-1` for &#x2018;never&#x2019;</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_static_name" c:identifier="g_source_set_static_name" version="2.70">
        <doc xml:space="preserve">A variant of [method@GLib.Source.set_name] that does not
duplicate the @name, and can only be used with
string literals.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">debug name for the source</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_source_unref">
        <doc xml:space="preserve">Decreases the reference count of a source by one.

If the resulting reference count is zero the source and associated
memory will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a source</doc>
            <type name="Source" c:type="GSource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="remove" c:identifier="g_source_remove">
        <doc xml:space="preserve">Removes the source with the given ID from the default main context.

You must
use [method@GLib.Source.destroy] for sources added to a non-default main context.

The ID of a [struct@GLib.Source] is given by [method@GLib.Source.get_id], or will be
returned by the functions [method@GLib.Source.attach], [func@GLib.idle_add],
[func@GLib.idle_add_full], [func@GLib.timeout_add],
[func@GLib.timeout_add_full], [func@GLib.child_watch_add],
[func@GLib.child_watch_add_full], [func@GLib.io_add_watch], and
[func@GLib.io_add_watch_full].

It is a programmer error to attempt to remove a non-existent source.

More specifically: source IDs can be reissued after a source has been
destroyed and therefore it is never valid to use this function with a
source ID which may have already been removed.  An example is when
scheduling an idle to run in another thread with [func@GLib.idle_add]: the
idle may already have run and been removed by the time this function
is called on its (now invalid) source ID.  This source ID may have
been reissued, leading to the operation being performed against the
wrong source.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if the source was found and removed, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the source to remove.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_by_funcs_user_data" c:identifier="g_source_remove_by_funcs_user_data">
        <doc xml:space="preserve">Removes a source from the default main loop context given the
source functions and user data.

If multiple sources exist with the same source functions and user data, only
one will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if a source was found and removed, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="funcs" transfer-ownership="none">
            <doc xml:space="preserve">the @source_funcs passed to [ctor@GLib.Source.new]</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_by_user_data" c:identifier="g_source_remove_by_user_data">
        <doc xml:space="preserve">Removes a source from the default main loop context given the user
data for the callback.

If multiple sources exist with the same user data, only one will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if a source was found and removed, false otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user_data for the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_name_by_id" c:identifier="g_source_set_name_by_id" version="2.26">
        <doc xml:space="preserve">Sets the name of a source using its ID.

This is a convenience utility to set source names from the return
value of [func@GLib.idle_add], [func@GLib.timeout_add], etc.

It is a programmer error to attempt to set the name of a non-existent
source.

More specifically: source IDs can be reissued after a source has been
destroyed and therefore it is never valid to use this function with a
source ID which may have already been removed.  An example is when
scheduling an idle to run in another thread with [func@GLib.idle_add]: the
idle may already have run and been removed by the time this function
is called on its (now invalid) source ID.  This source ID may have
been reissued, leading to the operation being performed against the
wrong source.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:space="preserve">a source ID</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">debug name for the source</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="SourceCallbackFuncs" c:type="GSourceCallbackFuncs">
      <doc xml:space="preserve">The `GSourceCallbackFuncs` struct contains
functions for managing callback objects.</doc>
      <field name="ref">
        <doc xml:space="preserve">Called when a reference is added to the callback object</doc>
        <callback name="ref">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cb_data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unref">
        <doc xml:space="preserve">Called when a reference to the callback object is dropped</doc>
        <callback name="unref">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cb_data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get" introspectable="0">
        <doc xml:space="preserve">Called to extract the callback function and data from the
    callback object.</doc>
        <callback name="get" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cb_data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="source" transfer-ownership="none">
              <type name="Source" c:type="GSource*"/>
            </parameter>
            <parameter name="func" transfer-ownership="none" closure="3">
              <type name="SourceFunc" c:type="GSourceFunc*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="gpointer" c:type="gpointer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="SourceDisposeFunc" c:type="GSourceDisposeFunc" version="2.64">
      <doc xml:space="preserve">Dispose function for @source. See [method@GLib.Source.set_dispose_function]
for details.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">#GSource that is currently being disposed</doc>
          <type name="Source" c:type="GSource*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SourceDummyMarshal" c:type="GSourceDummyMarshal">
      <doc xml:space="preserve">This is just a placeholder for #GClosureMarshal,
which cannot be used here for dependency reasons.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </callback>
    <callback name="SourceFunc" c:type="GSourceFunc">
      <doc xml:space="preserve">Specifies the type of function passed to [func@GLib.timeout_add],
[func@GLib.timeout_add_full], [func@GLib.idle_add], and
[func@GLib.idle_add_full].

When calling [method@GLib.Source.set_callback], you may need to cast a
function of a different type to this type. Use [func@GLib.SOURCE_FUNC] to
avoid warnings about incompatible function types.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%FALSE if the source should be removed.
[const@GLib.SOURCE_CONTINUE] and [const@GLib.SOURCE_REMOVE] are more
memorable names for the return value.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="0">
          <doc xml:space="preserve">data passed to the function, set when the source was
    created with one of the above functions</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SourceFuncs" c:type="GSourceFuncs">
      <doc xml:space="preserve">The `GSourceFuncs` struct contains a table of
functions used to handle event sources in a generic manner.

For idle sources, the prepare and check functions always return %TRUE
to indicate that the source is always ready to be processed. The prepare
function also returns a timeout value of 0 to ensure that the poll() call
doesn't block (since that would be time wasted which could have been spent
running the idle function).

For timeout sources, the prepare and check functions both return %TRUE
if the timeout interval has expired. The prepare function also returns
a timeout value to ensure that the poll() call doesn't block too long
and miss the next timeout.

For file descriptor sources, the prepare function typically returns %FALSE,
since it must wait until poll() has been called before it knows whether
any events need to be processed. It sets the returned timeout to -1 to
indicate that it doesn't mind how long the poll() call blocks. In the
check function, it tests the results of the poll() call to see if the
required condition has been met, and returns %TRUE if so.</doc>
      <field name="prepare" writable="1">
        <doc xml:space="preserve">Called before all the file descriptors are polled. If
    the source can determine that it is ready here (without waiting for the
    results of the poll() call) it should return %TRUE. It can also return
    a @timeout_ value which should be the maximum timeout (in milliseconds)
    which should be passed to the poll() call. The actual timeout used will
    be -1 if all sources returned -1, or it will be the minimum of all
    the @timeout_ values returned which were &gt;= 0.  Since 2.36 this may
    be %NULL, in which case the effect is as if the function always returns
    %FALSE with a timeout of -1.  If @prepare returns a
    timeout and the source also has a ready time set, then the
    lower of the two will be used.</doc>
        <type name="SourceFuncsPrepareFunc" c:type="GSourceFuncsPrepareFunc"/>
      </field>
      <field name="check" writable="1">
        <doc xml:space="preserve">Called after all the file descriptors are polled. The
    source should return %TRUE if it is ready to be dispatched. Note that
    some time may have passed since the previous prepare function was called,
    so the source should be checked again here.  Since 2.36 this may
    be %NULL, in which case the effect is as if the function always returns
    %FALSE.</doc>
        <type name="SourceFuncsCheckFunc" c:type="GSourceFuncsCheckFunc"/>
      </field>
      <field name="dispatch" introspectable="0" writable="1">
        <doc xml:space="preserve">Called to dispatch the event source, after it has returned
    %TRUE in either its @prepare or its @check function, or if a ready time
    has been reached. The @dispatch function receives a callback function and
    user data. The callback function may be %NULL if the source was never
    connected to a callback using [method@GLib.Source.set_callback]. The
    @dispatch function should call the callback function with @user_data and
    whatever additional parameters are needed for this type of event source.
    The return value of the @dispatch function should be
    [const@GLib.SOURCE_REMOVE] if the source should be removed or
    [const@GLib.SOURCE_CONTINUE] to keep it.</doc>
        <type name="SourceFuncsDispatchFunc" c:type="GSourceFuncsDispatchFunc"/>
      </field>
      <field name="finalize" writable="1">
        <doc xml:space="preserve">Called when the source is finalized. At this point,
    the source will have been destroyed, had its callback cleared, and have
    been removed from its [struct@GLib.MainContext], but it will still have
    its final reference count, so methods can be called on it from within
    this function. This may be %NULL, in which case the effect is as if the
    function does nothing and returns.</doc>
        <type name="SourceFuncsFinalizeFunc" c:type="GSourceFuncsFinalizeFunc"/>
      </field>
      <field name="closure_callback" readable="0" private="1">
        <type name="SourceFunc" c:type="GSourceFunc"/>
      </field>
      <field name="closure_marshal" readable="0" private="1">
        <type name="SourceDummyMarshal" c:type="GSourceDummyMarshal"/>
      </field>
    </record>
    <callback name="SourceFuncsCheckFunc" c:type="GSourceFuncsCheckFunc" version="2.82">
      <doc xml:space="preserve">Checks if the source is ready to be dispatched.

Called after all the file descriptors are polled. The source
should return %TRUE if it is ready to be dispatched. Note that some
time may have passed since the previous prepare function was called,
so the source should be checked again here.

Since 2.36 this may be `NULL`, in which case the effect is
as if the function always returns `FALSE`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if ready to be dispatched, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">The #GSource</doc>
          <type name="Source" c:type="GSource*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SourceFuncsDispatchFunc" c:type="GSourceFuncsDispatchFunc" version="2.82" introspectable="0">
      <doc xml:space="preserve">Dispatches the source callback.

Called to dispatch the event source, after it has returned
`TRUE` in either its prepare or its check function, or if a ready time
has been reached. The dispatch function receives a callback function and
user data. The callback function may be `NULL` if the source was never
connected to a callback using [method@GLib.Source.set_callback]. The dispatch
function should call the callback function with @user_data and whatever
additional parameters are needed for this type of event source. The
return value of the dispatch function should be [const@GLib.SOURCE_REMOVE]
if the source should be removed or [const@GLib.SOURCE_CONTINUE] to keep it.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">[const@GLib.SOURCE_REMOVE] if the source should be removed,
  [const@GLib.SOURCE_CONTINUE] otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">The #GSource</doc>
          <type name="Source" c:type="GSource*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">The #GSourceFunc to call</doc>
          <type name="SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">data to pass to @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SourceFuncsFinalizeFunc" c:type="GSourceFuncsFinalizeFunc" version="2.82">
      <doc xml:space="preserve">Finalizes the source.

Called when the source is finalized. At this point, the source
will have been destroyed, had its callback cleared, and have been removed
from its [type@GLib.MainContext], but it will still have its final reference
count, so methods can be called on it from within this function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">The #GSource</doc>
          <type name="Source" c:type="GSource*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SourceFuncsPrepareFunc" c:type="GSourceFuncsPrepareFunc" version="2.82">
      <doc xml:space="preserve">Checks the source for readiness.

Called before all the file descriptors are polled. If the
source can determine that it is ready here (without waiting for the
results of the poll call) it should return %TRUE. It can also return
a @timeout_ value which should be the maximum timeout (in milliseconds)
which should be passed to the poll call. The actual timeout used will
be `-1` if all sources returned `-1`, or it will be the minimum of all
the @timeout_ values returned which were greater than or equal to `0`.
If the prepare function returns a timeout and the source also has a
ready time set, then the lower of the two will be used.

Since 2.36 this may be `NULL`, in which case the effect is as if the
function always returns `FALSE` with a timeout of `-1`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the source is ready, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">The #GSource</doc>
          <type name="Source" c:type="GSource*"/>
        </parameter>
        <parameter name="timeout_" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the maximum timeout (in milliseconds) which should be passed to the poll call</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SourceOnceFunc" c:type="GSourceOnceFunc" version="2.74">
      <doc xml:space="preserve">A source function that is only called once before being removed from the main
context automatically.

See: [func@GLib.idle_add_once], [func@GLib.timeout_add_once]</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="0">
          <doc xml:space="preserve">data passed to the function, set when the source was
  created</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SourcePrivate" c:type="GSourcePrivate" disguised="1" opaque="1"/>
    <callback name="SpawnChildSetupFunc" c:type="GSpawnChildSetupFunc">
      <doc xml:space="preserve">Specifies the type of the setup function passed to g_spawn_async(),
g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very
limited ways, be used to affect the child's execution.

On POSIX platforms, the function is called in the child after GLib
has performed all the setup it plans to perform, but before calling
exec(). Actions taken in this function will only affect the child,
not the parent.

On Windows, the function is called in the parent. Its usefulness on
Windows is thus questionable. In many cases executing the child setup
function in the parent can have ill effects, and you should be very
careful when porting software to Windows that uses child setup
functions.

However, even on POSIX, you are extremely limited in what you can
safely do from a #GSpawnChildSetupFunc, because any mutexes that were
held by other threads in the parent process at the time of the fork()
will still be locked in the child process, and they will never be
unlocked (since the threads that held them don't exist in the child).
POSIX allows only async-signal-safe functions (see signal(7)) to be
called in the child between fork() and exec(), which drastically limits
the usefulness of child setup functions.

In particular, it is not safe to call any function which may
call malloc(), which includes POSIX functions such as setenv().
If you need to set up the child environment differently from
the parent, you should use g_get_environ(), g_environ_setenv(),
and g_environ_unsetenv(), and then pass the complete environment
list to the `g_spawn...` function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to the function.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SpawnError" c:type="GSpawnError" glib:error-domain="g-exec-error-quark">
      <doc xml:space="preserve">Error codes returned by spawning processes.</doc>
      <member name="fork" value="0" c:identifier="G_SPAWN_ERROR_FORK">
        <doc xml:space="preserve">Fork failed due to lack of memory.</doc>
      </member>
      <member name="read" value="1" c:identifier="G_SPAWN_ERROR_READ">
        <doc xml:space="preserve">Read or select on pipes failed.</doc>
      </member>
      <member name="chdir" value="2" c:identifier="G_SPAWN_ERROR_CHDIR">
        <doc xml:space="preserve">Changing to working directory failed.</doc>
      </member>
      <member name="acces" value="3" c:identifier="G_SPAWN_ERROR_ACCES">
        <doc xml:space="preserve">execv() returned `EACCES`</doc>
      </member>
      <member name="perm" value="4" c:identifier="G_SPAWN_ERROR_PERM">
        <doc xml:space="preserve">execv() returned `EPERM`</doc>
      </member>
      <member name="too_big" value="5" c:identifier="G_SPAWN_ERROR_TOO_BIG">
        <doc xml:space="preserve">execv() returned `E2BIG`</doc>
      </member>
      <member name="2big" value="5" c:identifier="G_SPAWN_ERROR_2BIG">
        <doc xml:space="preserve">deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)</doc>
      </member>
      <member name="noexec" value="6" c:identifier="G_SPAWN_ERROR_NOEXEC">
        <doc xml:space="preserve">execv() returned `ENOEXEC`</doc>
      </member>
      <member name="nametoolong" value="7" c:identifier="G_SPAWN_ERROR_NAMETOOLONG">
        <doc xml:space="preserve">execv() returned `ENAMETOOLONG`</doc>
      </member>
      <member name="noent" value="8" c:identifier="G_SPAWN_ERROR_NOENT">
        <doc xml:space="preserve">execv() returned `ENOENT`</doc>
      </member>
      <member name="nomem" value="9" c:identifier="G_SPAWN_ERROR_NOMEM">
        <doc xml:space="preserve">execv() returned `ENOMEM`</doc>
      </member>
      <member name="notdir" value="10" c:identifier="G_SPAWN_ERROR_NOTDIR">
        <doc xml:space="preserve">execv() returned `ENOTDIR`</doc>
      </member>
      <member name="loop" value="11" c:identifier="G_SPAWN_ERROR_LOOP">
        <doc xml:space="preserve">execv() returned `ELOOP`</doc>
      </member>
      <member name="txtbusy" value="12" c:identifier="G_SPAWN_ERROR_TXTBUSY">
        <doc xml:space="preserve">execv() returned `ETXTBUSY`</doc>
      </member>
      <member name="io" value="13" c:identifier="G_SPAWN_ERROR_IO">
        <doc xml:space="preserve">execv() returned `EIO`</doc>
      </member>
      <member name="nfile" value="14" c:identifier="G_SPAWN_ERROR_NFILE">
        <doc xml:space="preserve">execv() returned `ENFILE`</doc>
      </member>
      <member name="mfile" value="15" c:identifier="G_SPAWN_ERROR_MFILE">
        <doc xml:space="preserve">execv() returned `EMFILE`</doc>
      </member>
      <member name="inval" value="16" c:identifier="G_SPAWN_ERROR_INVAL">
        <doc xml:space="preserve">execv() returned `EINVAL`</doc>
      </member>
      <member name="isdir" value="17" c:identifier="G_SPAWN_ERROR_ISDIR">
        <doc xml:space="preserve">execv() returned `EISDIR`</doc>
      </member>
      <member name="libbad" value="18" c:identifier="G_SPAWN_ERROR_LIBBAD">
        <doc xml:space="preserve">execv() returned `ELIBBAD`</doc>
      </member>
      <member name="failed" value="19" c:identifier="G_SPAWN_ERROR_FAILED">
        <doc xml:space="preserve">Some other fatal failure,
  `error-&gt;message` should explain.</doc>
      </member>
    </enumeration>
    <bitfield name="SpawnFlags" c:type="GSpawnFlags">
      <doc xml:space="preserve">Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes().</doc>
      <member name="default" value="0" c:identifier="G_SPAWN_DEFAULT">
        <doc xml:space="preserve">no flags, default behaviour</doc>
      </member>
      <member name="leave_descriptors_open" value="1" c:identifier="G_SPAWN_LEAVE_DESCRIPTORS_OPEN">
        <doc xml:space="preserve">the parent's open file descriptors will
    be inherited by the child; otherwise all descriptors except stdin,
    stdout and stderr will be closed before calling exec() in the child.</doc>
      </member>
      <member name="do_not_reap_child" value="2" c:identifier="G_SPAWN_DO_NOT_REAP_CHILD">
        <doc xml:space="preserve">the child will not be automatically reaped;
    you must use g_child_watch_add() yourself (or call waitpid() or handle
    `SIGCHLD` yourself), or the child will become a zombie.</doc>
      </member>
      <member name="search_path" value="4" c:identifier="G_SPAWN_SEARCH_PATH">
        <doc xml:space="preserve">`argv[0]` need not be an absolute path, it will be
    looked for in the user's `PATH`.</doc>
      </member>
      <member name="stdout_to_dev_null" value="8" c:identifier="G_SPAWN_STDOUT_TO_DEV_NULL">
        <doc xml:space="preserve">the child's standard output will be discarded,
    instead of going to the same location as the parent's standard output.</doc>
      </member>
      <member name="stderr_to_dev_null" value="16" c:identifier="G_SPAWN_STDERR_TO_DEV_NULL">
        <doc xml:space="preserve">the child's standard error will be discarded.</doc>
      </member>
      <member name="child_inherits_stdin" value="32" c:identifier="G_SPAWN_CHILD_INHERITS_STDIN">
        <doc xml:space="preserve">the child will inherit the parent's standard
    input (by default, the child's standard input is attached to `/dev/null`).</doc>
      </member>
      <member name="file_and_argv_zero" value="64" c:identifier="G_SPAWN_FILE_AND_ARGV_ZERO">
        <doc xml:space="preserve">the first element of `argv` is the file to
    execute, while the remaining elements are the actual argument vector
    to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`
    as the file to execute, and passes all of `argv` to the child.</doc>
      </member>
      <member name="search_path_from_envp" value="128" c:identifier="G_SPAWN_SEARCH_PATH_FROM_ENVP">
        <doc xml:space="preserve">if `argv[0]` is not an absolute path,
    it will be looked for in the `PATH` from the passed child environment.
    Since: 2.34</doc>
      </member>
      <member name="cloexec_pipes" value="256" c:identifier="G_SPAWN_CLOEXEC_PIPES">
        <doc xml:space="preserve">create all pipes with the `O_CLOEXEC` flag set.
    Since: 2.40</doc>
      </member>
      <member name="child_inherits_stdout" value="512" c:identifier="G_SPAWN_CHILD_INHERITS_STDOUT" version="2.74">
        <doc xml:space="preserve">The child will inherit the parent's standard output.</doc>
      </member>
      <member name="child_inherits_stderr" value="1024" c:identifier="G_SPAWN_CHILD_INHERITS_STDERR" version="2.74">
        <doc xml:space="preserve">The child will inherit the parent's standard error.</doc>
      </member>
      <member name="stdin_from_dev_null" value="2048" c:identifier="G_SPAWN_STDIN_FROM_DEV_NULL" version="2.74">
        <doc xml:space="preserve">The child's standard input is attached to `/dev/null`.</doc>
      </member>
    </bitfield>
    <record name="StatBuf" c:type="GStatBuf" disguised="1" opaque="1">
      <doc xml:space="preserve">A type corresponding to the appropriate struct type for the stat()
system call, depending on the platform and/or compiler being used.

See g_stat() for more information.</doc>
    </record>
    <record name="StaticMutex" c:type="GStaticMutex" introspectable="0">
      <doc xml:space="preserve">A #GStaticMutex works like a #GMutex.

Prior to GLib 2.32, GStaticMutex had the significant advantage
that it doesn't need to be created at run-time, but can be defined
at compile-time. Since 2.32, #GMutex can be statically allocated
as well, and GStaticMutex has been deprecated.

Here is a version of our give_me_next_number() example using
a GStaticMutex:
|[
  int
  give_me_next_number (void)
  {
    static int current_number = 0;
    int ret_val;
    static GStaticMutex mutex = G_STATIC_MUTEX_INIT;

    g_static_mutex_lock (&amp;mutex);
    ret_val = current_number = calc_next_number (current_number);
    g_static_mutex_unlock (&amp;mutex);

    return ret_val;
  }
]|

Sometimes you would like to dynamically create a mutex. If you don't
want to require prior calling to g_thread_init(), because your code
should also be usable in non-threaded programs, you are not able to
use g_mutex_new() and thus #GMutex, as that requires a prior call to
g_thread_init(). In these cases you can also use a #GStaticMutex.
It must be initialized with g_static_mutex_init() before using it
and freed with with g_static_mutex_free() when not needed anymore to
free up any allocated resources.

Even though #GStaticMutex is not opaque, it should only be used with
the following functions, as it is defined differently on different
platforms.

All of the g_static_mutex_* functions apart from
g_static_mutex_get_mutex() can also be used even if g_thread_init()
has not yet been called. Then they do nothing, apart from
g_static_mutex_trylock() which does nothing but returning %TRUE.

All of the g_static_mutex_* functions are actually macros. Apart from
taking their addresses, you can however use them as if they were
functions.</doc>
      <field name="mutex" writable="1">
        <type name="Mutex" c:type="GMutex*"/>
      </field>
      <method name="free" c:identifier="g_static_mutex_free" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Releases all resources allocated to @mutex.

You don't have to call this functions for a #GStaticMutex with an
unbounded lifetime, i.e. objects declared 'static', but if you have
a #GStaticMutex as a member of a structure and the structure is
freed, you should also free the #GStaticMutex.

Calling g_static_mutex_free() on a locked mutex may result in
undefined behaviour.</doc>
        <doc-deprecated xml:space="preserve">Use g_mutex_clear()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticMutex to be freed.</doc>
            <type name="StaticMutex" c:type="GStaticMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mutex_impl" c:identifier="g_static_mutex_get_mutex_impl">
        <return-value>
          <type name="Mutex" c:type="GMutex*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <type name="StaticMutex" c:type="GStaticMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_static_mutex_init" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Initializes @mutex.
Alternatively you can initialize it with %G_STATIC_MUTEX_INIT.</doc>
        <doc-deprecated xml:space="preserve">Use g_mutex_init()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticMutex to be initialized.</doc>
            <type name="StaticMutex" c:type="GStaticMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="StaticPrivate" c:type="GStaticPrivate" introspectable="0">
      <doc xml:space="preserve">A #GStaticPrivate works almost like a #GPrivate, but it has one
significant advantage. It doesn't need to be created at run-time
like a #GPrivate, but can be defined at compile-time. This is
similar to the difference between #GMutex and #GStaticMutex.

Now look at our give_me_next_number() example with #GStaticPrivate:
|[
  int
  give_me_next_number ()
  {
    static GStaticPrivate current_number_key = G_STATIC_PRIVATE_INIT;
    int *current_number = g_static_private_get (&amp;current_number_key);

    if (!current_number)
      {
        current_number = g_new (int, 1);
        *current_number = 0;
        g_static_private_set (&amp;current_number_key, current_number, g_free);
      }

    *current_number = calc_next_number (*current_number);

    return *current_number;
  }
]|</doc>
      <field name="index" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="free" c:identifier="g_static_private_free" introspectable="0">
        <doc xml:space="preserve">Releases all resources allocated to @private_key.

You don't have to call this functions for a #GStaticPrivate with an
unbounded lifetime, i.e. objects declared 'static', but if you have
a #GStaticPrivate as a member of a structure and the structure is
freed, you should also free the #GStaticPrivate.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="private_key" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticPrivate to be freed</doc>
            <type name="StaticPrivate" c:type="GStaticPrivate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="g_static_private_get" introspectable="0">
        <doc xml:space="preserve">Works like g_private_get() only for a #GStaticPrivate.

This function works even if g_thread_init() has not yet been called.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the corresponding pointer</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="private_key" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticPrivate</doc>
            <type name="StaticPrivate" c:type="GStaticPrivate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_static_private_init" introspectable="0">
        <doc xml:space="preserve">Initializes @private_key. Alternatively you can initialize it with
%G_STATIC_PRIVATE_INIT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="private_key" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticPrivate to be initialized</doc>
            <type name="StaticPrivate" c:type="GStaticPrivate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="g_static_private_set" introspectable="0">
        <doc xml:space="preserve">Sets the pointer keyed to @private_key for the current thread and
the function @notify to be called with that pointer (%NULL or
non-%NULL), whenever the pointer is set again or whenever the
current thread ends.

This function works even if g_thread_init() has not yet been called.
If g_thread_init() is called later, the @data keyed to @private_key
will be inherited only by the main thread, i.e. the one that called
g_thread_init().

@notify is used quite differently from @destructor in g_private_new().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="private_key" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticPrivate</doc>
            <type name="StaticPrivate" c:type="GStaticPrivate*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the new pointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a function to be called with the pointer whenever the
    current thread ends or sets this pointer again</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="StaticRWLock" c:type="GStaticRWLock" introspectable="0" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">The #GStaticRWLock struct represents a read-write lock. A read-write
lock can be used for protecting data that some portions of code only
read from, while others also write. In such situations it is
desirable that several readers can read at once, whereas of course
only one writer may write at a time.

Take a look at the following example:
|[
  GStaticRWLock rwlock = G_STATIC_RW_LOCK_INIT;
  GPtrArray *array;

  gpointer
  my_array_get (guint index)
  {
    gpointer retval = NULL;

    if (!array)
      return NULL;

    g_static_rw_lock_reader_lock (&amp;rwlock);
    if (index &lt; array-&gt;len)
      retval = g_ptr_array_index (array, index);
    g_static_rw_lock_reader_unlock (&amp;rwlock);

    return retval;
  }

  void
  my_array_set (guint index, gpointer data)
  {
    g_static_rw_lock_writer_lock (&amp;rwlock);

    if (!array)
      array = g_ptr_array_new ();

    if (index &gt;= array-&gt;len)
      g_ptr_array_set_size (array, index + 1);
    g_ptr_array_index (array, index) = data;

    g_static_rw_lock_writer_unlock (&amp;rwlock);
  }
]|

This example shows an array which can be accessed by many readers
(the my_array_get() function) simultaneously, whereas the writers
(the my_array_set() function) will only be allowed once at a time
and only if no readers currently access the array. This is because
of the potentially dangerous resizing of the array. Using these
functions is fully multi-thread safe now.

Most of the time, writers should have precedence over readers. That
means, for this implementation, that as soon as a writer wants to
lock the data, no other reader is allowed to lock the data, whereas,
of course, the readers that already have locked the data are allowed
to finish their operation. As soon as the last reader unlocks the
data, the writer will lock it.

Even though #GStaticRWLock is not opaque, it should only be used
with the following functions.

All of the g_static_rw_lock_* functions can be used even if
g_thread_init() has not been called. Then they do nothing, apart
from g_static_rw_lock_*_trylock, which does nothing but returning %TRUE.

A read-write lock has a higher overhead than a mutex. For example, both
g_static_rw_lock_reader_lock() and g_static_rw_lock_reader_unlock() have
to lock and unlock a #GStaticMutex, so it takes at least twice the time
to lock and unlock a #GStaticRWLock that it does to lock and unlock a
#GStaticMutex. So only data structures that are accessed by multiple
readers, and which keep the lock for a considerable time justify a
#GStaticRWLock. The above example most probably would fare better with a
#GStaticMutex.</doc>
      <doc-deprecated xml:space="preserve">Use a #GRWLock instead</doc-deprecated>
      <field name="mutex" readable="0" private="1">
        <type name="StaticMutex" c:type="GStaticMutex"/>
      </field>
      <field name="read_cond" readable="0" private="1">
        <type name="Cond" c:type="GCond*"/>
      </field>
      <field name="write_cond" readable="0" private="1">
        <type name="Cond" c:type="GCond*"/>
      </field>
      <field name="read_counter" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="have_writer" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="want_to_read" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="want_to_write" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="free" c:identifier="g_static_rw_lock_free" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Releases all resources allocated to @lock.

You don't have to call this functions for a #GStaticRWLock with an
unbounded lifetime, i.e. objects declared 'static', but if you have
a #GStaticRWLock as a member of a structure, and the structure is
freed, you should also free the #GStaticRWLock.</doc>
        <doc-deprecated xml:space="preserve">Use a #GRWLock instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRWLock to be freed.</doc>
            <type name="StaticRWLock" c:type="GStaticRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_static_rw_lock_init" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">A #GStaticRWLock must be initialized with this function before it
can be used. Alternatively you can initialize it with
%G_STATIC_RW_LOCK_INIT.</doc>
        <doc-deprecated xml:space="preserve">Use g_rw_lock_init() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRWLock to be initialized.</doc>
            <type name="StaticRWLock" c:type="GStaticRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reader_lock" c:identifier="g_static_rw_lock_reader_lock" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Locks @lock for reading. There may be unlimited concurrent locks for
reading of a #GStaticRWLock at the same time.  If @lock is already
locked for writing by another thread or if another thread is already
waiting to lock @lock for writing, this function will block until
@lock is unlocked by the other writing thread and no other writing
threads want to lock @lock. This lock has to be unlocked by
g_static_rw_lock_reader_unlock().

#GStaticRWLock is not recursive. It might seem to be possible to
recursively lock for reading, but that can result in a deadlock, due
to writer preference.</doc>
        <doc-deprecated xml:space="preserve">Use g_rw_lock_reader_lock() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRWLock to lock for reading.</doc>
            <type name="StaticRWLock" c:type="GStaticRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reader_trylock" c:identifier="g_static_rw_lock_reader_trylock" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Tries to lock @lock for reading. If @lock is already locked for
writing by another thread or if another thread is already waiting to
lock @lock for writing, immediately returns %FALSE. Otherwise locks
@lock for reading and returns %TRUE. This lock has to be unlocked by
g_static_rw_lock_reader_unlock().</doc>
        <doc-deprecated xml:space="preserve">Use g_rw_lock_reader_trylock() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, if @lock could be locked for reading</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRWLock to lock for reading</doc>
            <type name="StaticRWLock" c:type="GStaticRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reader_unlock" c:identifier="g_static_rw_lock_reader_unlock" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Unlocks @lock. If a thread waits to lock @lock for writing and all
locks for reading have been unlocked, the waiting thread is woken up
and can lock @lock for writing.</doc>
        <doc-deprecated xml:space="preserve">Use g_rw_lock_reader_unlock() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRWLock to unlock after reading</doc>
            <type name="StaticRWLock" c:type="GStaticRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="writer_lock" c:identifier="g_static_rw_lock_writer_lock" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Locks @lock for writing. If @lock is already locked for writing or
reading by other threads, this function will block until @lock is
completely unlocked and then lock @lock for writing. While this
functions waits to lock @lock, no other thread can lock @lock for
reading. When @lock is locked for writing, no other thread can lock
@lock (neither for reading nor writing). This lock has to be
unlocked by g_static_rw_lock_writer_unlock().</doc>
        <doc-deprecated xml:space="preserve">Use g_rw_lock_writer_lock() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRWLock to lock for writing</doc>
            <type name="StaticRWLock" c:type="GStaticRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="writer_trylock" c:identifier="g_static_rw_lock_writer_trylock" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Tries to lock @lock for writing. If @lock is already locked (for
either reading or writing) by another thread, it immediately returns
%FALSE. Otherwise it locks @lock for writing and returns %TRUE. This
lock has to be unlocked by g_static_rw_lock_writer_unlock().</doc>
        <doc-deprecated xml:space="preserve">Use g_rw_lock_writer_trylock() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, if @lock could be locked for writing</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRWLock to lock for writing</doc>
            <type name="StaticRWLock" c:type="GStaticRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="writer_unlock" c:identifier="g_static_rw_lock_writer_unlock" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Unlocks @lock. If a thread is waiting to lock @lock for writing and
all locks for reading have been unlocked, the waiting thread is
woken up and can lock @lock for writing. If no thread is waiting to
lock @lock for writing, and some thread or threads are waiting to
lock @lock for reading, the waiting threads are woken up and can
lock @lock for reading.</doc>
        <doc-deprecated xml:space="preserve">Use g_rw_lock_writer_unlock() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="lock" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRWLock to unlock after writing.</doc>
            <type name="StaticRWLock" c:type="GStaticRWLock*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="StaticRecMutex" c:type="GStaticRecMutex" introspectable="0">
      <doc xml:space="preserve">A #GStaticRecMutex works like a #GStaticMutex, but it can be locked
multiple times by one thread. If you enter it n times, you have to
unlock it n times again to let other threads lock it. An exception
is the function g_static_rec_mutex_unlock_full(): that allows you to
unlock a #GStaticRecMutex completely returning the depth, (i.e. the
number of times this mutex was locked). The depth can later be used
to restore the state of the #GStaticRecMutex by calling
g_static_rec_mutex_lock_full(). In GLib 2.32, #GStaticRecMutex has
been deprecated in favor of #GRecMutex.

Even though #GStaticRecMutex is not opaque, it should only be used
with the following functions.

All of the g_static_rec_mutex_* functions can be used even if
g_thread_init() has not been called. Then they do nothing, apart
from g_static_rec_mutex_trylock(), which does nothing but returning
%TRUE.</doc>
      <field name="mutex" readable="0" private="1">
        <type name="StaticMutex" c:type="GStaticMutex"/>
      </field>
      <field name="depth" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="free" c:identifier="g_static_rec_mutex_free" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Releases all resources allocated to a #GStaticRecMutex.

You don't have to call this functions for a #GStaticRecMutex with an
unbounded lifetime, i.e. objects declared 'static', but if you have
a #GStaticRecMutex as a member of a structure and the structure is
freed, you should also free the #GStaticRecMutex.</doc>
        <doc-deprecated xml:space="preserve">Use g_rec_mutex_clear()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRecMutex to be freed.</doc>
            <type name="StaticRecMutex" c:type="GStaticRecMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_static_rec_mutex_init" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">A #GStaticRecMutex must be initialized with this function before it
can be used. Alternatively you can initialize it with
%G_STATIC_REC_MUTEX_INIT.</doc>
        <doc-deprecated xml:space="preserve">Use g_rec_mutex_init()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRecMutex to be initialized.</doc>
            <type name="StaticRecMutex" c:type="GStaticRecMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lock" c:identifier="g_static_rec_mutex_lock" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Locks @mutex. If @mutex is already locked by another thread, the
current thread will block until @mutex is unlocked by the other
thread. If @mutex is already locked by the calling thread, this
functions increases the depth of @mutex and returns immediately.</doc>
        <doc-deprecated xml:space="preserve">Use g_rec_mutex_lock()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRecMutex to lock.</doc>
            <type name="StaticRecMutex" c:type="GStaticRecMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lock_full" c:identifier="g_static_rec_mutex_lock_full" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Works like calling g_static_rec_mutex_lock() for @mutex @depth times.</doc>
        <doc-deprecated xml:space="preserve">Use g_rec_mutex_lock()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRecMutex to lock.</doc>
            <type name="StaticRecMutex" c:type="GStaticRecMutex*"/>
          </instance-parameter>
          <parameter name="depth" transfer-ownership="none">
            <doc xml:space="preserve">number of times this mutex has to be unlocked to be
        completely unlocked.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="trylock" c:identifier="g_static_rec_mutex_trylock" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Tries to lock @mutex. If @mutex is already locked by another thread,
it immediately returns %FALSE. Otherwise it locks @mutex and returns
%TRUE. If @mutex is already locked by the calling thread, this
functions increases the depth of @mutex and immediately returns
%TRUE.</doc>
        <doc-deprecated xml:space="preserve">Use g_rec_mutex_trylock()</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, if @mutex could be locked.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRecMutex to lock.</doc>
            <type name="StaticRecMutex" c:type="GStaticRecMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unlock" c:identifier="g_static_rec_mutex_unlock" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Unlocks @mutex. Another thread will be allowed to lock @mutex only
when it has been unlocked as many times as it had been locked
before. If @mutex is completely unlocked and another thread is
blocked in a g_static_rec_mutex_lock() call for @mutex, it will be
woken and can lock @mutex itself.</doc>
        <doc-deprecated xml:space="preserve">Use g_rec_mutex_unlock()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRecMutex to unlock.</doc>
            <type name="StaticRecMutex" c:type="GStaticRecMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unlock_full" c:identifier="g_static_rec_mutex_unlock_full" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Completely unlocks @mutex. If another thread is blocked in a
g_static_rec_mutex_lock() call for @mutex, it will be woken and can
lock @mutex itself. This function returns the number of times that
@mutex has been locked by the current thread. To restore the state
before the call to g_static_rec_mutex_unlock_full() you can call
g_static_rec_mutex_lock_full() with the depth returned by this
function.</doc>
        <doc-deprecated xml:space="preserve">Use g_rec_mutex_unlock()</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of times @mutex has been locked by the current
         thread.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none">
            <doc xml:space="preserve">a #GStaticRecMutex to completely unlock.</doc>
            <type name="StaticRecMutex" c:type="GStaticRecMutex*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="String" c:type="GString" glib:type-name="GString" glib:get-type="g_gstring_get_type" c:symbol-prefix="gstring">
      <doc xml:space="preserve">A `GString` is an object that handles the memory management of a C string.

The emphasis of `GString` is on text, typically UTF-8. Crucially, the "str" member
of a `GString` is guaranteed to have a trailing nul character, and it is therefore
always safe to call functions such as `strchr()` or `strdup()` on it.

However, a `GString` can also hold arbitrary binary data, because it has a "len" member,
which includes any possible embedded nul characters in the data. Conceptually then,
`GString` is like a `GByteArray` with the addition of many convenience methods for
text, and a guaranteed nul terminator.</doc>
      <field name="str" writable="1">
        <doc xml:space="preserve">points to the character data. It may move as text is added.
  The @str field is null-terminated and so
  can be used as an ordinary C string.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="len" writable="1">
        <doc xml:space="preserve">contains the length of the string, not including the
  terminating nul byte.</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="allocated_len" writable="1">
        <doc xml:space="preserve">the number of bytes that can be stored in the
  string before it needs to be reallocated. May be larger than @len.</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <constructor name="new" c:identifier="g_string_new">
        <doc xml:space="preserve">Creates a new #GString, initialized with the given string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GString</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <parameter name="init" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the initial text to copy into the string, or %NULL to
  start with an empty string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_len" c:identifier="g_string_new_len">
        <doc xml:space="preserve">Creates a new #GString with @len bytes of the @init buffer.
Because a length is provided, @init need not be nul-terminated,
and can contain embedded nul bytes.

Since this function does not stop at nul bytes, it is the caller's
responsibility to ensure that @init has at least @len addressable
bytes.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GString</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <parameter name="init" transfer-ownership="none">
            <doc xml:space="preserve">initial contents of the string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of @init to use</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_take" c:identifier="g_string_new_take" version="2.78">
        <doc xml:space="preserve">Creates a new #GString, initialized with the given string.

After this call, @init belongs to the #GString and may no longer be
modified by the caller. The memory of @init has to be dynamically
allocated and will eventually be freed with g_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GString</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <parameter name="init" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">initial text used as the string.
    Ownership of the string is transferred to the #GString.
    Passing %NULL creates an empty string.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="sized_new" c:identifier="g_string_sized_new">
        <doc xml:space="preserve">Creates a new #GString, with enough space for @dfl_size
bytes. This is useful if you are going to add a lot of
text to the string and don't want it to be reallocated
too often.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GString</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <parameter name="dfl_size" transfer-ownership="none">
            <doc xml:space="preserve">the default size of the space allocated to hold the string</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="g_string_append">
        <doc xml:space="preserve">Adds a string onto the end of a #GString, expanding
it if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">the string to append onto the end of @string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_c" c:identifier="g_string_append_c">
        <doc xml:space="preserve">Adds a byte onto the end of a #GString, expanding
it if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve">the byte to append onto the end of @string</doc>
            <type name="gchar" c:type="gchar"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_len" c:identifier="g_string_append_len">
        <doc xml:space="preserve">Appends @len bytes of @val to @string.

If @len is positive, @val may contain embedded nuls and need
not be nul-terminated. It is the caller's responsibility to
ensure that @val has at least @len addressable bytes.

If @len is negative, @val must be nul-terminated and @len
is considered to request the entire string length. This
makes g_string_append_len() equivalent to g_string_append().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">bytes to append</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes of @val to use, or -1 for all of @val</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_printf" c:identifier="g_string_append_printf" introspectable="0">
        <doc xml:space="preserve">Appends a formatted string onto the end of a #GString.
This function is similar to g_string_printf() except
that the text is appended to the #GString.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the string format. See the printf() documentation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the parameters to insert into the format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="append_unichar" c:identifier="g_string_append_unichar">
        <doc xml:space="preserve">Converts a Unicode character into UTF-8, and appends it
to the string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="wc" transfer-ownership="none">
            <doc xml:space="preserve">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_uri_escaped" c:identifier="g_string_append_uri_escaped" version="2.16">
        <doc xml:space="preserve">Appends @unescaped to @string, escaping any characters that
are reserved in URIs using URI-style escape sequences.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="unescaped" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="reserved_chars_allowed" transfer-ownership="none">
            <doc xml:space="preserve">a string of reserved characters allowed
    to be used, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="allow_utf8" transfer-ownership="none">
            <doc xml:space="preserve">set %TRUE if the escaped string may include UTF8 characters</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_vprintf" c:identifier="g_string_append_vprintf" version="2.14" introspectable="0">
        <doc xml:space="preserve">Appends a formatted string onto the end of a #GString.
This function is similar to g_string_append_printf()
except that the arguments to the format string are passed
as a va_list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the string format. See the printf() documentation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">the list of arguments to insert in the output</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="ascii_down" c:identifier="g_string_ascii_down">
        <doc xml:space="preserve">Converts all uppercase ASCII letters to lowercase ASCII letters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">passed-in @string pointer, with all the
    uppercase characters converted to lowercase in place,
    with semantics that exactly match g_ascii_tolower().</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ascii_up" c:identifier="g_string_ascii_up">
        <doc xml:space="preserve">Converts all lowercase ASCII letters to uppercase ASCII letters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">passed-in @string pointer, with all the
    lowercase characters converted to uppercase in place,
    with semantics that exactly match g_ascii_toupper().</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="assign" c:identifier="g_string_assign">
        <doc xml:space="preserve">Copies the bytes from a string into a #GString,
destroying any previous contents. It is rather like
the standard strcpy() function, except that you do not
have to worry about having enough space to copy the string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the destination #GString. Its current contents
         are destroyed.</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="rval" transfer-ownership="none">
            <doc xml:space="preserve">the string to copy into @string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="g_string_copy" version="2.86">
        <doc xml:space="preserve">Copies the [struct@GLib.String] instance and its contents.

This will preserve the allocation length of the [struct@GLib.String] in the
copy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="down" c:identifier="g_string_down" deprecated="1" deprecated-version="2.2">
        <doc xml:space="preserve">Converts a #GString to lowercase.</doc>
        <doc-deprecated xml:space="preserve">This function uses the locale-specific
    tolower() function, which is almost never the right thing.
    Use g_string_ascii_down() or g_utf8_strdown() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GString</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="g_string_equal">
        <doc xml:space="preserve">Compares two strings for equality, returning %TRUE if they are equal.
For use with #GHashTable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the strings are the same length and contain the
    same bytes</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="const GString*"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">another #GString</doc>
            <type name="String" c:type="const GString*"/>
          </parameter>
        </parameters>
      </method>
      <method name="erase" c:identifier="g_string_erase">
        <doc xml:space="preserve">Removes @len bytes from a #GString, starting at position @pos.
The rest of the #GString is shifted down to fill the gap.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position of the content to remove</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to remove, or -1 to remove all
      following bytes</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_string_free">
        <doc xml:space="preserve">Frees the memory allocated for the #GString.
If @free_segment is %TRUE it also frees the character data.  If
it's %FALSE, the caller gains ownership of the buffer and must
free it after use with g_free().

Instead of passing %FALSE to this function, consider using
g_string_free_and_steal().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the character data of @string
         (i.e. %NULL if @free_segment is %TRUE)</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="full">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="free_segment" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE, the actual character data is freed as well</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="free_and_steal" c:identifier="g_string_free_and_steal" version="2.76">
        <doc xml:space="preserve">Frees the memory allocated for the #GString.

The caller gains ownership of the buffer and
must free it after use with g_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the character data of @string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="full">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_to_bytes" c:identifier="g_string_free_to_bytes" version="2.34">
        <doc xml:space="preserve">Transfers ownership of the contents of @string to a newly allocated
#GBytes.  The #GString structure itself is deallocated, and it is
therefore invalid to use @string after invoking this function.

Note that while #GString ensures that its buffer always has a
trailing nul character (not reflected in its "len"), the returned
#GBytes does not include this extra nul; i.e. it has length exactly
equal to the "len" member.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #GBytes containing contents of @string; @string itself is freed</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="full">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="g_string_hash">
        <doc xml:space="preserve">Creates a hash code for @str; for use with #GHashTable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">hash code for @str</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">a string to hash</doc>
            <type name="String" c:type="const GString*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_string_insert">
        <doc xml:space="preserve">Inserts a copy of a string into a #GString,
expanding it if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position to insert the copy of the string</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">the string to insert</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_c" c:identifier="g_string_insert_c">
        <doc xml:space="preserve">Inserts a byte into a #GString, expanding it if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position to insert the byte</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve">the byte to insert</doc>
            <type name="gchar" c:type="gchar"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_len" c:identifier="g_string_insert_len">
        <doc xml:space="preserve">Inserts @len bytes of @val into @string at @pos.

If @len is positive, @val may contain embedded nuls and need
not be nul-terminated. It is the caller's responsibility to
ensure that @val has at least @len addressable bytes.

If @len is negative, @val must be nul-terminated and @len
is considered to request the entire string length.

If @pos is -1, bytes are inserted at the end of the string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">position in @string where insertion should
      happen, or -1 for at the end</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">bytes to insert</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes of @val to insert, or -1 for all of @val</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_unichar" c:identifier="g_string_insert_unichar">
        <doc xml:space="preserve">Converts a Unicode character into UTF-8, and insert it
into the string at the given position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position at which to insert character, or -1
    to append at the end of the string</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="wc" transfer-ownership="none">
            <doc xml:space="preserve">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar"/>
          </parameter>
        </parameters>
      </method>
      <method name="overwrite" c:identifier="g_string_overwrite" version="2.14">
        <doc xml:space="preserve">Overwrites part of a string, lengthening it if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position at which to start overwriting</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">the string that will overwrite the @string starting at @pos</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="overwrite_len" c:identifier="g_string_overwrite_len" version="2.14">
        <doc xml:space="preserve">Overwrites part of a string, lengthening it if necessary.
This function will work with embedded nuls.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position at which to start overwriting</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">the string that will overwrite the @string starting at @pos</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes to write from @val</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend" c:identifier="g_string_prepend">
        <doc xml:space="preserve">Adds a string on to the start of a #GString,
expanding it if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">the string to prepend on the start of @string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend_c" c:identifier="g_string_prepend_c">
        <doc xml:space="preserve">Adds a byte onto the start of a #GString,
expanding it if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve">the byte to prepend on the start of the #GString</doc>
            <type name="gchar" c:type="gchar"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend_len" c:identifier="g_string_prepend_len">
        <doc xml:space="preserve">Prepends @len bytes of @val to @string.

If @len is positive, @val may contain embedded nuls and need
not be nul-terminated. It is the caller's responsibility to
ensure that @val has at least @len addressable bytes.

If @len is negative, @val must be nul-terminated and @len
is considered to request the entire string length. This
makes g_string_prepend_len() equivalent to g_string_prepend().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">bytes to prepend</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes in @val to prepend, or -1 for all of @val</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend_unichar" c:identifier="g_string_prepend_unichar">
        <doc xml:space="preserve">Converts a Unicode character into UTF-8, and prepends it
to the string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="wc" transfer-ownership="none">
            <doc xml:space="preserve">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar"/>
          </parameter>
        </parameters>
      </method>
      <method name="printf" c:identifier="g_string_printf" introspectable="0">
        <doc xml:space="preserve">Writes a formatted string into a #GString.
This is similar to the standard sprintf() function,
except that the #GString buffer automatically expands
to contain the results. The previous contents of the
#GString are destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the string format. See the printf() documentation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the parameters to insert into the format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="replace" c:identifier="g_string_replace" version="2.68">
        <doc xml:space="preserve">Replaces the string @find with the string @replace in a #GString up to
@limit times. If the number of instances of @find in the #GString is
less than @limit, all instances are replaced. If @limit is `0`,
all instances of @find are replaced.

If @find is the empty string, since versions 2.69.1 and 2.68.4 the
replacement will be inserted no more than once per possible position
(beginning of string, end of string and between characters). This did
not work correctly in earlier versions.

If @limit is zero and more than `G_MAXUINT` instances of @find are in
the input string, they will all be replaced, but the return value will
be capped at `G_MAXUINT`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of find and replace operations performed,
  up to `G_MAXUINT`</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="find" transfer-ownership="none">
            <doc xml:space="preserve">the string to find in @string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="replace" transfer-ownership="none">
            <doc xml:space="preserve">the string to insert in place of @find</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="limit" transfer-ownership="none">
            <doc xml:space="preserve">the maximum instances of @find to replace with @replace, or `0` for
no limit</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_size" c:identifier="g_string_set_size">
        <doc xml:space="preserve">Sets the length of a #GString. If the length is less than
the current length, the string will be truncated. If the
length is greater than the current length, the contents
of the newly added area are undefined. (However, as
always, string-&gt;str[string-&gt;len] will be a nul byte.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the new length</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="truncate" c:identifier="g_string_truncate">
        <doc xml:space="preserve">Cuts off the end of the GString, leaving the first @len bytes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the new size of @string</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="up" c:identifier="g_string_up" deprecated="1" deprecated-version="2.2">
        <doc xml:space="preserve">Converts a #GString to uppercase.</doc>
        <doc-deprecated xml:space="preserve">This function uses the locale-specific
    toupper() function, which is almost never the right thing.
    Use g_string_ascii_up() or g_utf8_strup() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="vprintf" c:identifier="g_string_vprintf" version="2.14" introspectable="0">
        <doc xml:space="preserve">Writes a formatted string into a #GString.
This function is similar to g_string_printf() except that
the arguments to the format string are passed as a va_list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a #GString</doc>
            <type name="String" c:type="GString*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the string format. See the printf() documentation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">the parameters to insert into the format string</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="StringChunk" c:type="GStringChunk" disguised="1" opaque="1">
      <doc xml:space="preserve">`GStringChunk` provides efficient storage of groups of strings

String chunks are used to store groups of strings. Memory is
allocated in blocks, and as strings are added to the `GStringChunk`
they are copied into the next free position in a block. When a block
is full a new block is allocated.

When storing a large number of strings, string chunks are more
efficient than using [func@GLib.strdup] since fewer calls to `malloc()`
are needed, and less memory is wasted in memory allocation overheads.

By adding strings with [method@GLib.StringChunk.insert_const] it is also
possible to remove duplicates.

To create a new `GStringChunk` use [func@GLib.StringChunk.new].

To add strings to a `GStringChunk` use [method@GLib.StringChunk.insert].

To add strings to a `GStringChunk`, but without duplicating strings
which are already in the `GStringChunk`, use [method@GLib.StringChunk.insert_const].

To free the entire `GStringChunk` use [method@GLib.StringChunk.free].
It is not possible to free individual strings.</doc>
      <method name="clear" c:identifier="g_string_chunk_clear" version="2.14">
        <doc xml:space="preserve">Frees all strings contained within the #GStringChunk.
After calling g_string_chunk_clear() it is not safe to
access any of the strings which were contained within it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">a #GStringChunk</doc>
            <type name="StringChunk" c:type="GStringChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_string_chunk_free">
        <doc xml:space="preserve">Frees all memory allocated by the #GStringChunk.
After calling g_string_chunk_free() it is not safe to
access any of the strings which were contained within it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="chunk" transfer-ownership="full">
            <doc xml:space="preserve">a #GStringChunk</doc>
            <type name="StringChunk" c:type="GStringChunk*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_string_chunk_insert">
        <doc xml:space="preserve">Adds a copy of @string to the #GStringChunk.
It returns a pointer to the new copy of the string
in the #GStringChunk. The characters in the string
can be changed, if necessary, though you should not
change anything after the end of the string.

Unlike g_string_chunk_insert_const(), this function
does not check for duplicates. Also strings added
with g_string_chunk_insert() will not be searched
by g_string_chunk_insert_const() when looking for
duplicates.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a pointer to the copy of @string within
    the #GStringChunk</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">a #GStringChunk</doc>
            <type name="StringChunk" c:type="GStringChunk*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_const" c:identifier="g_string_chunk_insert_const">
        <doc xml:space="preserve">Adds a copy of @string to the #GStringChunk, unless the same
string has already been added to the #GStringChunk with
g_string_chunk_insert_const().

This function is useful if you need to copy a large number
of strings but do not want to waste space storing duplicates.
But you must remember that there may be several pointers to
the same string, and so any changes made to the strings
should be done very carefully.

Note that g_string_chunk_insert_const() will not return a
pointer to a string added with g_string_chunk_insert(), even
if they do match.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a pointer to the new or existing copy of @string
    within the #GStringChunk</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">a #GStringChunk</doc>
            <type name="StringChunk" c:type="GStringChunk*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_len" c:identifier="g_string_chunk_insert_len" version="2.4">
        <doc xml:space="preserve">Adds a copy of the first @len bytes of @string to the #GStringChunk.
The copy is nul-terminated.

Since this function does not stop at nul bytes, it is the caller's
responsibility to ensure that @string has at least @len addressable
bytes.

The characters in the returned string can be changed, if necessary,
though you should not change anything after the end of the string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a pointer to the copy of @string within the #GStringChunk</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">a #GStringChunk</doc>
            <type name="StringChunk" c:type="GStringChunk*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">bytes to insert</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes of @string to insert, or -1 to insert a
    nul-terminated string</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_string_chunk_new" introspectable="0">
        <doc xml:space="preserve">Creates a new #GStringChunk.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GStringChunk</doc>
          <type name="StringChunk" c:type="GStringChunk*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the default size of the blocks of memory which are
    allocated to store the strings. If a particular string
    is larger than this default size, a larger block of
    memory will be allocated for it.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="StrvBuilder" c:type="GStrvBuilder" opaque="1" version="2.68" glib:type-name="GStrvBuilder" glib:get-type="g_strv_builder_get_type" c:symbol-prefix="strv_builder">
      <doc xml:space="preserve">`GStrvBuilder` is a helper object to build a %NULL-terminated string arrays.

The following example shows how to build a two element array:

```c
  g_autoptr(GStrvBuilder) builder = g_strv_builder_new ();
  g_strv_builder_add (builder, "hello");
  g_strv_builder_add (builder, "world");

  g_auto(GStrv) array = g_strv_builder_end (builder);

  g_assert_true (g_strv_equal (array, (const char *[]) { "hello", "world", NULL }));
```</doc>
      <constructor name="new" c:identifier="g_strv_builder_new" version="2.68">
        <doc xml:space="preserve">Creates a new #GStrvBuilder with a reference count of 1.
Use g_strv_builder_unref() on the returned value when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GStrvBuilder</doc>
          <type name="StrvBuilder" c:type="GStrvBuilder*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="g_strv_builder_add">
        <doc xml:space="preserve">Add a string to the end of the array.

Since 2.68</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GStrvBuilder</doc>
            <type name="StrvBuilder" c:type="GStrvBuilder*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_many" c:identifier="g_strv_builder_add_many" introspectable="0">
        <doc xml:space="preserve">Appends all the given strings to the builder.

Since 2.70</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GStrvBuilder</doc>
            <type name="StrvBuilder" c:type="GStrvBuilder*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">one or more strings followed by %NULL</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="addv" c:identifier="g_strv_builder_addv">
        <doc xml:space="preserve">Appends all the strings in the given vector to the builder.

Since 2.70</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GStrvBuilder</doc>
            <type name="StrvBuilder" c:type="GStrvBuilder*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the vector of strings to add</doc>
            <array c:type="const char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="end" c:identifier="g_strv_builder_end">
        <doc xml:space="preserve">Ends the builder process and returns the constructed NULL-terminated string
array. The returned value should be freed with g_strfreev() when no longer
needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the constructed string array.

Since 2.68</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GStrvBuilder</doc>
            <type name="StrvBuilder" c:type="GStrvBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_strv_builder_ref" version="2.68">
        <doc xml:space="preserve">Atomically increments the reference count of @builder by one.
This function is thread-safe and may be called from any thread.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The passed in #GStrvBuilder</doc>
          <type name="StrvBuilder" c:type="GStrvBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GStrvBuilder</doc>
            <type name="StrvBuilder" c:type="GStrvBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="take" c:identifier="g_strv_builder_take">
        <doc xml:space="preserve">Add a string to the end of the array. After @value belongs to the
#GStrvBuilder and may no longer be modified by the caller.

Since 2.80</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GStrvBuilder</doc>
            <type name="StrvBuilder" c:type="GStrvBuilder*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="full">
            <doc xml:space="preserve">a string.
    Ownership of the string is transferred to the #GStrvBuilder</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_strv_builder_unref" version="2.68">
        <doc xml:space="preserve">Decreases the reference count on @builder.

In the event that there are no more references, releases all memory
associated with the #GStrvBuilder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="full">
            <doc xml:space="preserve">a #GStrvBuilder allocated by g_strv_builder_new()</doc>
            <type name="StrvBuilder" c:type="GStrvBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref_to_strv" c:identifier="g_strv_builder_unref_to_strv" version="2.82">
        <doc xml:space="preserve">Decreases the reference count on the string vector builder, and returns
its contents as a `NULL`-terminated string array.

This function is especially useful for cases where it's not possible
to use `g_autoptr()`.

```c
GStrvBuilder *builder = g_strv_builder_new ();
g_strv_builder_add (builder, "hello");
g_strv_builder_add (builder, "world");

GStrv array = g_strv_builder_unref_to_strv (builder);

g_assert_true (g_strv_equal (array, (const char *[]) { "hello", "world", NULL }));

g_strfreev (array);
```</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the constructed string
  array</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="full">
            <doc xml:space="preserve">a #GStrvBuilder</doc>
            <type name="StrvBuilder" c:type="GStrvBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <constant name="TEST_OPTION_ISOLATE_DIRS" value="isolate_dirs" c:type="G_TEST_OPTION_ISOLATE_DIRS" version="2.60">
      <doc xml:space="preserve">A value that can be passed as an option to [func@GLib.test_init].

Creates a unique temporary directory for each unit test and uses sets
XDG directories to point into subdirectories of it for the duration of
the unit test. The directory tree is cleaned up after the test finishes
successfully.

Note that this doesn&#x2019;t take effect until [func@GLib.test_run] is called,
so calls to (for example) [func@GLib.get_home_dir] will return the
system-wide value when made in a test program&#x2019;s main() function.

The following functions will return subdirectories of the temporary directory
when this option is used. The specific subdirectory paths in use are not
guaranteed to be stable API &#x2014; always use a getter function to retrieve them.

 - [func@GLib.get_home_dir]
 - [func@GLib.get_user_cache_dir]
 - [func@GLib.get_system_config_dirs]
 - [func@GLib.get_user_config_dir]
 - [func@GLib.get_system_data_dirs]
 - [func@GLib.get_user_data_dir]
 - [func@GLib.get_user_state_dir]
 - [func@GLib.get_user_runtime_dir]

The subdirectories may not be created by the test harness; as with normal
calls to functions like [func@GLib.get_user_cache_dir], the caller must
be prepared to create the directory if it doesn&#x2019;t exist.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TEST_OPTION_NONFATAL_ASSERTIONS" value="nonfatal-assertions" c:type="G_TEST_OPTION_NONFATAL_ASSERTIONS" version="2.84">
      <doc xml:space="preserve">A value that can be passed as an option to [func@GLib.test_init].

If this option is given, assertions will not abort the process, but
call [func@GLib.test_fail]. Equivalent to [func@GLib.test_set_nonfatal_assertions].</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TEST_OPTION_NO_PRGNAME" value="no_g_set_prgname" c:type="G_TEST_OPTION_NO_PRGNAME" version="2.84">
      <doc xml:space="preserve">A value that can be passed as an option to [func@GLib.test_init].

If this option is given, [func@GLib.test_init] will not call [func@GLib.set_prgname].</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TIME_SPAN_DAY" value="86400000000" c:type="G_TIME_SPAN_DAY" version="2.26">
      <doc xml:space="preserve">Evaluates to a time span of one day.</doc>
      <type name="gint64" c:type="gint64"/>
    </constant>
    <constant name="TIME_SPAN_HOUR" value="3600000000" c:type="G_TIME_SPAN_HOUR" version="2.26">
      <doc xml:space="preserve">Evaluates to a time span of one hour.</doc>
      <type name="gint64" c:type="gint64"/>
    </constant>
    <constant name="TIME_SPAN_MILLISECOND" value="1000" c:type="G_TIME_SPAN_MILLISECOND" version="2.26">
      <doc xml:space="preserve">Evaluates to a time span of one millisecond.</doc>
      <type name="gint64" c:type="gint64"/>
    </constant>
    <constant name="TIME_SPAN_MINUTE" value="60000000" c:type="G_TIME_SPAN_MINUTE" version="2.26">
      <doc xml:space="preserve">Evaluates to a time span of one minute.</doc>
      <type name="gint64" c:type="gint64"/>
    </constant>
    <constant name="TIME_SPAN_SECOND" value="1000000" c:type="G_TIME_SPAN_SECOND" version="2.26">
      <doc xml:space="preserve">Evaluates to a time span of one second.</doc>
      <type name="gint64" c:type="gint64"/>
    </constant>
    <function-macro name="TRYLOCK" c:identifier="G_TRYLOCK" introspectable="0">
      <doc xml:space="preserve">Works like g_mutex_trylock(), but for a lock defined with
%G_LOCK_DEFINE.</doc>
      <parameters>
        <parameter name="name">
          <doc xml:space="preserve">the name of the lock</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="TestCase" c:type="GTestCase" disguised="1" opaque="1">
      <doc xml:space="preserve">An opaque structure representing a test case.</doc>
      <method name="free" c:identifier="g_test_case_free" version="2.70">
        <doc xml:space="preserve">Free the @test_case.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="test_case" transfer-ownership="none">
            <doc xml:space="preserve">a test case</doc>
            <type name="TestCase" c:type="GTestCase*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="TestConfig" c:type="GTestConfig">
      <field name="test_initialized" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="test_quick" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="test_perf" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="test_verbose" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="test_quiet" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="test_undefined" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </record>
    <callback name="TestDataFunc" c:type="GTestDataFunc" version="2.28">
      <doc xml:space="preserve">The type used for test case functions that take an extra pointer
argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="0">
          <doc xml:space="preserve">the data provided when registering the test</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="TestFileType" version="2.38" c:type="GTestFileType">
      <doc xml:space="preserve">The type of file to return the filename for, when used with
[func@GLib.test_build_filename].

These two options correspond rather directly to the 'dist' and
'built' terminology that automake uses and are explicitly used to
distinguish between the 'srcdir' and 'builddir' being separate. All
files in your project should either be dist (in the `EXTRA_DIST` or
`dist_schema_DATA` sense, in which case they will always be in the
srcdir) or built (in the `BUILT_SOURCES` sense, in which case they
will always be in the builddir).

Note: As a general rule of automake, files that are generated only as
part of the build-from-git process (but then are distributed with the
tarball) always go in srcdir (even if doing a srcdir != builddir
build from git) and are considered as distributed files.

The same principles apply for other build systems, such as meson.</doc>
      <member name="dist" value="0" c:identifier="G_TEST_DIST">
        <doc xml:space="preserve">a file that was included in the distribution tarball</doc>
      </member>
      <member name="built" value="1" c:identifier="G_TEST_BUILT">
        <doc xml:space="preserve">a file that was built on the compiling machine</doc>
      </member>
    </enumeration>
    <callback name="TestFixtureFunc" c:type="GTestFixtureFunc" version="2.28">
      <doc xml:space="preserve">The type used for functions that operate on test fixtures.

This is used for the fixture setup and teardown functions
as well as for the testcases themselves.

@user_data is a pointer to the data that was given when
registering the test case.

@fixture will be a pointer to the area of memory allocated by the
test framework, of the size requested.  If the requested size was
zero then @fixture will be equal to @user_data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fixture" transfer-ownership="none">
          <doc xml:space="preserve">the test fixture</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="1">
          <doc xml:space="preserve">the data provided when registering the test</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TestFunc" c:type="GTestFunc" version="2.28">
      <doc xml:space="preserve">The type used for test case functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </callback>
    <record name="TestLogBuffer" c:type="GTestLogBuffer">
      <field name="data" readable="0" private="1">
        <type name="String" c:type="GString*"/>
      </field>
      <field name="msgs" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <method name="free" c:identifier="g_test_log_buffer_free">
        <doc xml:space="preserve">Internal function for gtester to free test log messages, no ABI guarantees provided.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tbuffer" transfer-ownership="none">
            <type name="TestLogBuffer" c:type="GTestLogBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="g_test_log_buffer_pop" introspectable="0">
        <doc xml:space="preserve">Internal function for gtester to retrieve test log messages, no ABI guarantees provided.</doc>
        <return-value>
          <type name="TestLogMsg" c:type="GTestLogMsg*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tbuffer" transfer-ownership="none">
            <type name="TestLogBuffer" c:type="GTestLogBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="g_test_log_buffer_push">
        <doc xml:space="preserve">Internal function for gtester to decode test log messages, no ABI guarantees provided.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tbuffer" transfer-ownership="none">
            <type name="TestLogBuffer" c:type="GTestLogBuffer*"/>
          </instance-parameter>
          <parameter name="n_bytes" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <type name="guint8" c:type="const guint8*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_test_log_buffer_new" introspectable="0">
        <doc xml:space="preserve">Internal function for gtester to decode test log messages, no ABI guarantees provided.</doc>
        <return-value>
          <type name="TestLogBuffer" c:type="GTestLogBuffer*"/>
        </return-value>
      </function>
    </record>
    <callback name="TestLogFatalFunc" c:type="GTestLogFatalFunc" version="2.22">
      <doc xml:space="preserve">Specifies the prototype of fatal log handler functions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the program should abort, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none">
          <doc xml:space="preserve">the log domain of the message</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">the log level of the message (including the fatal and recursion flags)</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">the message to process</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">user data, set in g_test_log_set_fatal_handler()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TestLogMsg" c:type="GTestLogMsg">
      <field name="log_type" writable="1">
        <type name="TestLogType" c:type="GTestLogType"/>
      </field>
      <field name="n_strings" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="strings" writable="1">
        <type name="utf8" c:type="gchar**"/>
      </field>
      <field name="n_nums" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="nums" introspectable="0" writable="1">
        <type name="long double" c:type="long double*"/>
      </field>
      <method name="free" c:identifier="g_test_log_msg_free">
        <doc xml:space="preserve">Internal function for gtester to free test log messages, no ABI guarantees provided.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tmsg" transfer-ownership="none">
            <type name="TestLogMsg" c:type="GTestLogMsg*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="TestLogType" c:type="GTestLogType">
      <member name="none" value="0" c:identifier="G_TEST_LOG_NONE">
      </member>
      <member name="error" value="1" c:identifier="G_TEST_LOG_ERROR">
      </member>
      <member name="start_binary" value="2" c:identifier="G_TEST_LOG_START_BINARY">
      </member>
      <member name="list_case" value="3" c:identifier="G_TEST_LOG_LIST_CASE">
      </member>
      <member name="skip_case" value="4" c:identifier="G_TEST_LOG_SKIP_CASE">
      </member>
      <member name="start_case" value="5" c:identifier="G_TEST_LOG_START_CASE">
      </member>
      <member name="stop_case" value="6" c:identifier="G_TEST_LOG_STOP_CASE">
      </member>
      <member name="min_result" value="7" c:identifier="G_TEST_LOG_MIN_RESULT">
      </member>
      <member name="max_result" value="8" c:identifier="G_TEST_LOG_MAX_RESULT">
      </member>
      <member name="message" value="9" c:identifier="G_TEST_LOG_MESSAGE">
      </member>
      <member name="start_suite" value="10" c:identifier="G_TEST_LOG_START_SUITE">
      </member>
      <member name="stop_suite" value="11" c:identifier="G_TEST_LOG_STOP_SUITE">
      </member>
    </enumeration>
    <enumeration name="TestResult" c:type="GTestResult">
      <member name="success" value="0" c:identifier="G_TEST_RUN_SUCCESS">
      </member>
      <member name="skipped" value="1" c:identifier="G_TEST_RUN_SKIPPED">
      </member>
      <member name="failure" value="2" c:identifier="G_TEST_RUN_FAILURE">
      </member>
      <member name="incomplete" value="3" c:identifier="G_TEST_RUN_INCOMPLETE">
      </member>
    </enumeration>
    <bitfield name="TestSubprocessFlags" c:type="GTestSubprocessFlags">
      <doc xml:space="preserve">Flags to pass to [func@GLib.test_trap_subprocess] to control input and output.

Note that in contrast with [func@GLib.test_trap_fork], the default
behavior of [func@GLib.test_trap_subprocess] is to not show stdout
and stderr.</doc>
      <member name="default" value="0" c:identifier="G_TEST_SUBPROCESS_DEFAULT">
        <doc xml:space="preserve">Default behaviour. Since: 2.74</doc>
      </member>
      <member name="inherit_stdin" value="1" c:identifier="G_TEST_SUBPROCESS_INHERIT_STDIN">
        <doc xml:space="preserve">If this flag is given, the child
  process will inherit the parent's stdin. Otherwise, the child's
  stdin is redirected to `/dev/null`.</doc>
      </member>
      <member name="inherit_stdout" value="2" c:identifier="G_TEST_SUBPROCESS_INHERIT_STDOUT">
        <doc xml:space="preserve">If this flag is given, the child
  process will inherit the parent's stdout. Otherwise, the child's
  stdout will not be visible, but it will be captured to allow
  later tests with [func@GLib.test_trap_assert_stdout].</doc>
      </member>
      <member name="inherit_stderr" value="4" c:identifier="G_TEST_SUBPROCESS_INHERIT_STDERR">
        <doc xml:space="preserve">If this flag is given, the child
  process will inherit the parent's stderr. Otherwise, the child's
  stderr will not be visible, but it will be captured to allow
  later tests with [func@GLib.test_trap_assert_stderr].</doc>
      </member>
      <member name="inherit_descriptors" value="8" c:identifier="G_TEST_SUBPROCESS_INHERIT_DESCRIPTORS">
        <doc xml:space="preserve">If this flag is given, the
  child process will inherit the parent&#x2019;s open file descriptors.</doc>
      </member>
    </bitfield>
    <record name="TestSuite" c:type="GTestSuite" disguised="1" opaque="1">
      <doc xml:space="preserve">An opaque structure representing a test suite.</doc>
      <method name="add" c:identifier="g_test_suite_add" version="2.16">
        <doc xml:space="preserve">Adds @test_case to @suite.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="suite" transfer-ownership="none">
            <doc xml:space="preserve">a test suite</doc>
            <type name="TestSuite" c:type="GTestSuite*"/>
          </instance-parameter>
          <parameter name="test_case" transfer-ownership="none">
            <doc xml:space="preserve">a test case</doc>
            <type name="TestCase" c:type="GTestCase*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_suite" c:identifier="g_test_suite_add_suite" version="2.16">
        <doc xml:space="preserve">Adds @nestedsuite to @suite.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="suite" transfer-ownership="none">
            <doc xml:space="preserve">a test suite</doc>
            <type name="TestSuite" c:type="GTestSuite*"/>
          </instance-parameter>
          <parameter name="nestedsuite" transfer-ownership="none">
            <doc xml:space="preserve">another test suite</doc>
            <type name="TestSuite" c:type="GTestSuite*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_test_suite_free" version="2.70">
        <doc xml:space="preserve">Frees the @suite and all nested suites.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="suite" transfer-ownership="none">
            <doc xml:space="preserve">a test suite</doc>
            <type name="TestSuite" c:type="GTestSuite*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="TestTrapFlags" deprecated="1" deprecated-version="2.38" c:type="GTestTrapFlags">
      <doc xml:space="preserve">Flags to pass to [func@GLib.test_trap_fork] to control input and output.

Test traps are guards around forked tests. These flags determine what traps to set.</doc>
      <doc-deprecated xml:space="preserve">`GTestTrapFlags` is used only with [func@GLib.test_trap_fork],
  which is deprecated. Its replacement, [func@GLib.test_trap_subprocess] uses
  [flags@GLib.TestSubprocessFlags].</doc-deprecated>
      <member name="default" value="0" c:identifier="G_TEST_TRAP_DEFAULT">
        <doc xml:space="preserve">Default behaviour. Since: 2.74</doc>
      </member>
      <member name="silence_stdout" value="128" c:identifier="G_TEST_TRAP_SILENCE_STDOUT">
        <doc xml:space="preserve">Redirect stdout of the test child to
    `/dev/null` so it cannot be observed on the console during test
    runs. The actual output is still captured though to allow later
    tests with g_test_trap_assert_stdout().</doc>
      </member>
      <member name="silence_stderr" value="256" c:identifier="G_TEST_TRAP_SILENCE_STDERR">
        <doc xml:space="preserve">Redirect stderr of the test child to
    `/dev/null` so it cannot be observed on the console during test
    runs. The actual output is still captured though to allow later
    tests with g_test_trap_assert_stderr().</doc>
      </member>
      <member name="inherit_stdin" value="512" c:identifier="G_TEST_TRAP_INHERIT_STDIN">
        <doc xml:space="preserve">If this flag is given, stdin of the
    child process is shared with stdin of its parent process.
    It is redirected to `/dev/null` otherwise.</doc>
      </member>
    </bitfield>
    <record name="Thread" c:type="GThread" glib:type-name="GThread" glib:get-type="g_thread_get_type" c:symbol-prefix="thread">
      <doc xml:space="preserve">The #GThread struct represents a running thread. This struct
is returned by g_thread_new() or g_thread_try_new(). You can
obtain the #GThread struct representing the current thread by
calling g_thread_self().

GThread is refcounted, see g_thread_ref() and g_thread_unref().
The thread represented by it holds a reference while it is running,
and g_thread_join() consumes the reference that it is given, so
it is normally not necessary to manage GThread references
explicitly.

The structure is opaque -- none of its fields may be directly
accessed.</doc>
      <field name="func" readable="0" private="1">
        <type name="ThreadFunc" c:type="GThreadFunc"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="joinable" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="priority" introspectable="0" readable="0" private="1">
        <type name="ThreadPriority" c:type="GThreadPriority"/>
      </field>
      <constructor name="new" c:identifier="g_thread_new" version="2.32">
        <doc xml:space="preserve">This function creates a new thread. The new thread starts by invoking
@func with the argument data. The thread will run until @func returns
or until g_thread_exit() is called from the new thread. The return value
of @func becomes the return value of the thread, which can be obtained
with g_thread_join().

The @name can be useful for discriminating threads in a debugger.
It is not used for other purposes and does not have to be unique.
Some systems restrict the length of @name to 16 bytes.

If the thread can not be created the program aborts. See
g_thread_try_new() if you want to attempt to deal with failures.

If you are using threads to offload (potentially many) short-lived tasks,
#GThreadPool may be more appropriate than manually spawning and tracking
multiple #GThreads.

To free the struct returned by this function, use g_thread_unref().
Note that g_thread_join() implicitly unrefs the #GThread as well.

New threads by default inherit their scheduler policy (POSIX) or thread
priority (Windows) of the thread creating the new thread.

This behaviour changed in GLib 2.64: before threads on Windows were not
inheriting the thread priority but were spawned with the default priority.
Starting with GLib 2.64 the behaviour is now consistent between Windows and
POSIX and all threads inherit their parent thread's priority.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GThread</doc>
          <type name="Thread" c:type="GThread*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an (optional) name for the new thread</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="async" closure="2">
            <doc xml:space="preserve">a function to execute in the new thread</doc>
            <type name="ThreadFunc" c:type="GThreadFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an argument to supply to the new thread</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="try_new" c:identifier="g_thread_try_new" version="2.32" throws="1">
        <doc xml:space="preserve">This function is the same as g_thread_new() except that
it allows for the possibility of failure.

If a thread can not be created (due to resource limits),
@error is set and %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GThread, or %NULL if an error occurred</doc>
          <type name="Thread" c:type="GThread*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an (optional) name for the new thread</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="async" closure="2">
            <doc xml:space="preserve">a function to execute in the new thread</doc>
            <type name="ThreadFunc" c:type="GThreadFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an argument to supply to the new thread</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_name" c:identifier="g_thread_get_name" version="2.84">
        <doc xml:space="preserve">Gets the name of the thread.

This function is intended for debugging purposes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the thread</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">a thread</doc>
            <type name="Thread" c:type="GThread*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="join" c:identifier="g_thread_join">
        <doc xml:space="preserve">Waits until @thread finishes, i.e. the function @func, as
given to g_thread_new(), returns or g_thread_exit() is called.
If @thread has already terminated, then g_thread_join()
returns immediately.

Any thread can wait for any other thread by calling g_thread_join(),
not just its 'creator'. Calling g_thread_join() from multiple threads
for the same @thread leads to undefined behaviour.

The value returned by @func or given to g_thread_exit() is
returned by this function.

g_thread_join() consumes the reference to the passed-in @thread.
This will usually cause the #GThread struct and associated resources
to be freed. Use g_thread_ref() to obtain an extra reference if you
want to keep the GThread alive beyond the g_thread_join() call.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the return value of the thread</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="full">
            <doc xml:space="preserve">a #GThread</doc>
            <type name="Thread" c:type="GThread*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_thread_ref" version="2.32">
        <doc xml:space="preserve">Increase the reference count on @thread.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to @thread</doc>
          <type name="Thread" c:type="GThread*"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">a #GThread</doc>
            <type name="Thread" c:type="GThread*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_priority" c:identifier="g_thread_set_priority" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">This function does nothing.</doc>
        <doc-deprecated xml:space="preserve">Thread priorities no longer have any effect.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">a #GThread.</doc>
            <type name="Thread" c:type="GThread*"/>
          </instance-parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">ignored</doc>
            <type name="ThreadPriority" c:type="GThreadPriority"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_thread_unref" version="2.32">
        <doc xml:space="preserve">Decrease the reference count on @thread, possibly freeing all
resources associated with it.

Note that each thread holds a reference to its #GThread while
it is running, so it is safe to drop your own reference to it
if you don't need it anymore.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="full">
            <doc xml:space="preserve">a #GThread</doc>
            <type name="Thread" c:type="GThread*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="create" c:identifier="g_thread_create" introspectable="0" deprecated="1" deprecated-version="2.32" throws="1">
        <doc xml:space="preserve">This function creates a new thread.

The new thread executes the function @func with the argument @data.
If the thread was created successfully, it is returned.

@error can be %NULL to ignore errors, or non-%NULL to report errors.
The error is set, if and only if the function returns %NULL.

This function returns a reference to the created thread only if
@joinable is %TRUE.  In that case, you must free this reference by
calling g_thread_unref() or g_thread_join().  If @joinable is %FALSE
then you should probably not touch the return value.</doc>
        <doc-deprecated xml:space="preserve">Use g_thread_new() instead</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GThread on success</doc>
          <type name="Thread" c:type="GThread*"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">a function to execute in the new thread</doc>
            <type name="ThreadFunc" c:type="GThreadFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an argument to supply to the new thread</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="joinable" transfer-ownership="none">
            <doc xml:space="preserve">should this thread be joinable?</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="create_full" c:identifier="g_thread_create_full" introspectable="0" deprecated="1" deprecated-version="2.32" throws="1">
        <doc xml:space="preserve">This function creates a new thread.</doc>
        <doc-deprecated xml:space="preserve">The @bound and @priority arguments are now ignored.
Use g_thread_new().</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GThread on success.</doc>
          <type name="Thread" c:type="GThread*"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">a function to execute in the new thread.</doc>
            <type name="ThreadFunc" c:type="GThreadFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an argument to supply to the new thread.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="stack_size" transfer-ownership="none">
            <doc xml:space="preserve">a stack size for the new thread.</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
          <parameter name="joinable" transfer-ownership="none">
            <doc xml:space="preserve">should this thread be joinable?</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="bound" transfer-ownership="none">
            <doc xml:space="preserve">ignored</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">ignored</doc>
            <type name="ThreadPriority" c:type="GThreadPriority"/>
          </parameter>
        </parameters>
      </function>
      <function name="error_quark" c:identifier="g_thread_error_quark">
        <return-value transfer-ownership="none">
          <type name="Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="exit" c:identifier="g_thread_exit">
        <doc xml:space="preserve">Terminates the current thread.

If another thread is waiting for us using g_thread_join() then the
waiting thread will be woken up and get @retval as the return value
of g_thread_join().

Calling g_thread_exit() with a parameter @retval is equivalent to
returning @retval from the function @func, as given to g_thread_new().

You must only call g_thread_exit() from a thread that you created
yourself with g_thread_new() or related APIs. You must not call
this function from a thread created with another threading library
or or from within a #GThreadPool.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="retval" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the return value of this thread</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="foreach" c:identifier="g_thread_foreach" version="2.10" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Call @thread_func on all #GThreads that have been
created with g_thread_create().

Note that threads may decide to exit while @thread_func is
running, so without intimate knowledge about the lifetime of
foreign threads, @thread_func shouldn't access the GThread*
pointer passed in as first argument. However, @thread_func will
not be called for threads which are known to have exited already.

Due to thread lifetime checks, this function has an execution complexity
which is quadratic in the number of existing threads.</doc>
        <doc-deprecated xml:space="preserve">There aren't many things you can do with a #GThread,
    except comparing it with one that was returned from g_thread_create().
    There are better ways to find out if your thread is still alive.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="thread_func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">function to call for all #GThread structures</doc>
            <type name="Func" c:type="GFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">second argument to @thread_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_initialized" c:identifier="g_thread_get_initialized" version="2.20" introspectable="0">
        <doc xml:space="preserve">Indicates if g_thread_init() has been called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if threads have been initialized.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </function>
      <function name="init" c:identifier="g_thread_init" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">If you use GLib from more than one thread, you must initialize the
thread system by calling g_thread_init().

Since version 2.24, calling g_thread_init() multiple times is allowed,
but nothing happens except for the first call.

Since version 2.32, GLib does not support custom thread implementations
anymore and the @vtable parameter is ignored and you should pass %NULL.

::: note
    g_thread_init() must not be called directly or indirectly in a
    callback from GLib. Also no mutexes may be currently locked
    while calling g_thread_init().

::: note
    To use g_thread_init() in your program, you have to link with
    the libraries that the command `pkg-config --libs gthread-2.0`
    outputs. This is not the case for all the other thread-related
    functions of GLib. Those can be used without having to link
    with the thread libraries.</doc>
        <doc-deprecated xml:space="preserve">This function is no longer necessary. The GLib
    threading system is automatically initialized at the start
    of your program.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="vtable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a function table of type #GThreadFunctions, that provides
    the entry points to the thread system to be used. Since 2.32,
    this parameter is ignored and should always be %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_with_errorcheck_mutexes" c:identifier="g_thread_init_with_errorcheck_mutexes" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="vtable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="self" c:identifier="g_thread_self">
        <doc xml:space="preserve">This function returns the #GThread corresponding to the
current thread. Note that this function does not increase
the reference count of the returned struct.

This function will return a #GThread even for threads that
were not created by GLib (i.e. those created by other threading
APIs). This may be useful for thread identification purposes
(i.e. comparisons) but you must not use GLib functions (such
as g_thread_join()) on these threads.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GThread representing the current thread</doc>
          <type name="Thread" c:type="GThread*"/>
        </return-value>
      </function>
      <function name="yield" c:identifier="g_thread_yield">
        <doc xml:space="preserve">Causes the calling thread to voluntarily relinquish the CPU, so
that other threads can run.

This function is often used as a method to make busy wait less evil.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
    </record>
    <enumeration name="ThreadError" c:type="GThreadError" glib:error-domain="g_thread_error">
      <doc xml:space="preserve">Possible errors of thread related functions.</doc>
      <member name="thread_error_again" value="0" c:identifier="G_THREAD_ERROR_AGAIN">
        <doc xml:space="preserve">a thread couldn't be created due to resource
                       shortage. Try again later.</doc>
      </member>
    </enumeration>
    <callback name="ThreadFunc" c:type="GThreadFunc">
      <doc xml:space="preserve">Specifies the type of the @func functions passed to g_thread_new()
or g_thread_try_new().</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the return value of the thread</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data passed to the thread</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ThreadFunctions" c:type="GThreadFunctions" introspectable="0">
      <doc xml:space="preserve">This function table is no longer used by g_thread_init()
to initialize the thread system.</doc>
      <field name="mutex_new">
        <doc xml:space="preserve">virtual function pointer for g_mutex_new()</doc>
        <callback name="mutex_new">
          <return-value>
            <type name="Mutex" c:type="GMutex*"/>
          </return-value>
        </callback>
      </field>
      <field name="mutex_lock">
        <doc xml:space="preserve">virtual function pointer for g_mutex_lock()</doc>
        <callback name="mutex_lock">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mutex" transfer-ownership="none">
              <type name="Mutex" c:type="GMutex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mutex_trylock">
        <doc xml:space="preserve">virtual function pointer for g_mutex_trylock()</doc>
        <callback name="mutex_trylock">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mutex" transfer-ownership="none">
              <type name="Mutex" c:type="GMutex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mutex_unlock">
        <doc xml:space="preserve">virtual function pointer for g_mutex_unlock()</doc>
        <callback name="mutex_unlock">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mutex" transfer-ownership="none">
              <type name="Mutex" c:type="GMutex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="mutex_free">
        <doc xml:space="preserve">virtual function pointer for g_mutex_free()</doc>
        <callback name="mutex_free">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mutex" transfer-ownership="none">
              <type name="Mutex" c:type="GMutex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cond_new">
        <doc xml:space="preserve">virtual function pointer for g_cond_new()</doc>
        <callback name="cond_new">
          <return-value>
            <type name="Cond" c:type="GCond*"/>
          </return-value>
        </callback>
      </field>
      <field name="cond_signal">
        <doc xml:space="preserve">virtual function pointer for g_cond_signal()</doc>
        <callback name="cond_signal">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cond" transfer-ownership="none">
              <type name="Cond" c:type="GCond*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cond_broadcast">
        <doc xml:space="preserve">virtual function pointer for g_cond_broadcast()</doc>
        <callback name="cond_broadcast">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cond" transfer-ownership="none">
              <type name="Cond" c:type="GCond*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cond_wait">
        <doc xml:space="preserve">virtual function pointer for g_cond_wait()</doc>
        <callback name="cond_wait">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cond" transfer-ownership="none">
              <type name="Cond" c:type="GCond*"/>
            </parameter>
            <parameter name="mutex" transfer-ownership="none">
              <type name="Mutex" c:type="GMutex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cond_timed_wait">
        <doc xml:space="preserve">virtual function pointer for g_cond_timed_wait()</doc>
        <callback name="cond_timed_wait">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="cond" transfer-ownership="none">
              <type name="Cond" c:type="GCond*"/>
            </parameter>
            <parameter name="mutex" transfer-ownership="none">
              <type name="Mutex" c:type="GMutex*"/>
            </parameter>
            <parameter name="end_time" transfer-ownership="none">
              <type name="TimeVal" c:type="GTimeVal*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cond_free">
        <doc xml:space="preserve">virtual function pointer for g_cond_free()</doc>
        <callback name="cond_free">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cond" transfer-ownership="none">
              <type name="Cond" c:type="GCond*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="private_new">
        <doc xml:space="preserve">virtual function pointer for g_private_new()</doc>
        <callback name="private_new">
          <return-value>
            <type name="Private" c:type="GPrivate*"/>
          </return-value>
          <parameters>
            <parameter name="destructor" transfer-ownership="none" scope="async">
              <type name="DestroyNotify" c:type="GDestroyNotify"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="private_get">
        <doc xml:space="preserve">virtual function pointer for g_private_get()</doc>
        <callback name="private_get">
          <return-value transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="private_key" transfer-ownership="none">
              <type name="Private" c:type="GPrivate*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="private_set">
        <doc xml:space="preserve">virtual function pointer for g_private_set()</doc>
        <callback name="private_set">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="private_key" transfer-ownership="none">
              <type name="Private" c:type="GPrivate*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="thread_create">
        <doc xml:space="preserve">virtual function pointer for g_thread_create()</doc>
        <callback name="thread_create" introspectable="0" throws="1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="func" transfer-ownership="none" closure="1">
              <type name="ThreadFunc" c:type="GThreadFunc"/>
            </parameter>
            <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="stack_size" transfer-ownership="none">
              <type name="gulong" c:type="gulong"/>
            </parameter>
            <parameter name="joinable" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="bound" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="priority" transfer-ownership="none">
              <type name="ThreadPriority" c:type="GThreadPriority"/>
            </parameter>
            <parameter name="thread" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="thread_yield">
        <doc xml:space="preserve">virtual function pointer for g_thread_yield()</doc>
        <callback name="thread_yield">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="thread_join">
        <doc xml:space="preserve">virtual function pointer for g_thread_join()</doc>
        <callback name="thread_join">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="thread" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="thread_exit">
        <doc xml:space="preserve">virtual function pointer for g_thread_exit()</doc>
        <callback name="thread_exit">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="thread_set_priority">
        <doc xml:space="preserve">virtual function pointer for
                      g_thread_set_priority()</doc>
        <callback name="thread_set_priority" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="thread" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="priority" transfer-ownership="none">
              <type name="ThreadPriority" c:type="GThreadPriority"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="thread_self">
        <doc xml:space="preserve">virtual function pointer for g_thread_self()</doc>
        <callback name="thread_self">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="thread" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="thread_equal">
        <doc xml:space="preserve">used internally by recursive mutex locks and by some
               assertion checks</doc>
        <callback name="thread_equal">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="thread1" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="thread2" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="ThreadPool" c:type="GThreadPool">
      <doc xml:space="preserve">The `GThreadPool` struct represents a thread pool.

A thread pool is useful when you wish to asynchronously fork out the execution of work
and continue working in your own thread. If that will happen often, the overhead of starting
and destroying a thread each time might be too high. In such cases reusing already started
threads seems like a good idea. And it indeed is, but implementing this can be tedious
and error-prone.

Therefore GLib provides thread pools for your convenience. An added advantage is, that the
threads can be shared between the different subsystems of your program, when they are using GLib.

To create a new thread pool, you use [func@GLib.ThreadPool.new].
It is destroyed by [method@GLib.ThreadPool.free].

If you want to execute a certain task within a thread pool, use [method@GLib.ThreadPool.push].

To get the current number of running threads you call [method@GLib.ThreadPool.get_num_threads].
To get the number of still unprocessed tasks you call [method@GLib.ThreadPool.unprocessed].
To control the maximum number of threads for a thread pool, you use
[method@GLib.ThreadPool.get_max_threads]. and [method@GLib.ThreadPool.set_max_threads].

Finally you can control the number of unused threads, that are kept alive by GLib for future use.
The current number can be fetched with [func@GLib.ThreadPool.get_num_unused_threads].
The maximum number can be controlled by [func@GLib.ThreadPool.get_max_unused_threads] and
[func@GLib.ThreadPool.set_max_unused_threads]. All currently unused threads
can be stopped by calling [func@GLib.ThreadPool.stop_unused_threads].</doc>
      <field name="func" writable="1">
        <doc xml:space="preserve">the function to execute in the threads of this pool</doc>
        <type name="Func" c:type="GFunc"/>
      </field>
      <field name="user_data" writable="1">
        <doc xml:space="preserve">the user data for the threads of this pool</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="exclusive" writable="1">
        <doc xml:space="preserve">are all threads exclusive to this pool</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <method name="free" c:identifier="g_thread_pool_free">
        <doc xml:space="preserve">Frees all resources allocated for @pool.

If @immediate is %TRUE, no new task is processed for @pool.
Otherwise @pool is not freed before the last task is processed.
Note however, that no thread of this pool is interrupted while
processing a task. Instead at least all still running threads
can finish their tasks before the @pool is freed.

If @wait_ is %TRUE, this function does not return before all
tasks to be processed (dependent on @immediate, whether all
or only the currently running) are ready.
Otherwise this function returns immediately.

After calling this function @pool must not be used anymore.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GThreadPool</doc>
            <type name="ThreadPool" c:type="GThreadPool*"/>
          </instance-parameter>
          <parameter name="immediate" transfer-ownership="none">
            <doc xml:space="preserve">should @pool shut down immediately?</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="wait_" transfer-ownership="none">
            <doc xml:space="preserve">should the function wait for all tasks to be finished?</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_max_threads" c:identifier="g_thread_pool_get_max_threads">
        <doc xml:space="preserve">Returns the maximal number of threads for @pool.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximal number of threads</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GThreadPool</doc>
            <type name="ThreadPool" c:type="GThreadPool*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_threads" c:identifier="g_thread_pool_get_num_threads">
        <doc xml:space="preserve">Returns the number of threads currently running in @pool.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of threads currently running</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GThreadPool</doc>
            <type name="ThreadPool" c:type="GThreadPool*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="move_to_front" c:identifier="g_thread_pool_move_to_front" version="2.46">
        <doc xml:space="preserve">Moves the item to the front of the queue of unprocessed
items, so that it will be processed next.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the item was found and moved</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GThreadPool</doc>
            <type name="ThreadPool" c:type="GThreadPool*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an unprocessed item in the pool</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="g_thread_pool_push" throws="1">
        <doc xml:space="preserve">Inserts @data into the list of tasks to be executed by @pool.

When the number of currently running threads is lower than the
maximal allowed number of threads, a new thread is started (or
reused) with the properties given to g_thread_pool_new().
Otherwise, @data stays in the queue until a thread in this pool
finishes its previous task and processes @data.

@error can be %NULL to ignore errors, or non-%NULL to report
errors. An error can only occur when a new thread couldn't be
created. In that case @data is simply appended to the queue of
work to do.

Before version 2.32, this function did not return a success status.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if an error occurred</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GThreadPool</doc>
            <type name="ThreadPool" c:type="GThreadPool*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a new task for @pool</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_threads" c:identifier="g_thread_pool_set_max_threads" throws="1">
        <doc xml:space="preserve">Sets the maximal allowed number of threads for @pool.
A value of -1 means that the maximal number of threads
is unlimited. If @pool is an exclusive thread pool, setting
the maximal number of threads to -1 is not allowed.

Setting @max_threads to 0 means stopping all work for @pool.
It is effectively frozen until @max_threads is set to a non-zero
value again.

A thread is never terminated while calling @func, as supplied by
g_thread_pool_new(). Instead the maximal number of threads only
has effect for the allocation of new threads in g_thread_pool_push().
A new thread is allocated, whenever the number of currently
running threads in @pool is smaller than the maximal number.

@error can be %NULL to ignore errors, or non-%NULL to report
errors. An error can only occur when a new thread couldn't be
created.

Before version 2.32, this function did not return a success status.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if an error occurred</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GThreadPool</doc>
            <type name="ThreadPool" c:type="GThreadPool*"/>
          </instance-parameter>
          <parameter name="max_threads" transfer-ownership="none">
            <doc xml:space="preserve">a new maximal number of threads for @pool,
    or -1 for unlimited</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sort_function" c:identifier="g_thread_pool_set_sort_function" version="2.10" introspectable="0">
        <doc xml:space="preserve">Sets the function used to sort the list of tasks. This allows the
tasks to be processed by a priority determined by @func, and not
just in the order in which they were added to the pool.

Note, if the maximum number of threads is more than 1, the order
that threads are executed cannot be guaranteed 100%. Threads are
scheduled by the operating system and are executed at random. It
cannot be assumed that threads are executed in the order they are
created.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GThreadPool</doc>
            <type name="ThreadPool" c:type="GThreadPool*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">the #GCompareDataFunc used to sort the list of tasks.
    This function is passed two tasks. It should return
    0 if the order in which they are handled does not matter,
    a negative value if the first task should be processed before
    the second or a positive value if the second task should be
    processed first.</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unprocessed" c:identifier="g_thread_pool_unprocessed">
        <doc xml:space="preserve">Returns the number of tasks still unprocessed in @pool.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of unprocessed tasks</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GThreadPool</doc>
            <type name="ThreadPool" c:type="GThreadPool*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="get_max_idle_time" c:identifier="g_thread_pool_get_max_idle_time" version="2.10">
        <doc xml:space="preserve">This function will return the maximum @interval that a
thread will wait in the thread pool for new tasks before
being stopped.

If this function returns 0, threads waiting in the thread
pool for new work are not stopped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum @interval (milliseconds) to wait
    for new tasks in the thread pool before stopping the
    thread</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </function>
      <function name="get_max_unused_threads" c:identifier="g_thread_pool_get_max_unused_threads">
        <doc xml:space="preserve">Returns the maximal allowed number of unused threads.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximal number of unused threads</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </function>
      <function name="get_num_unused_threads" c:identifier="g_thread_pool_get_num_unused_threads">
        <doc xml:space="preserve">Returns the number of currently unused threads.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of currently unused threads</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </function>
      <function name="new" c:identifier="g_thread_pool_new" introspectable="0" throws="1">
        <doc xml:space="preserve">This function creates a new thread pool.

Whenever you call g_thread_pool_push(), either a new thread is
created or an unused one is reused. At most @max_threads threads
are running concurrently for this thread pool. @max_threads = -1
allows unlimited threads to be created for this thread pool. The
newly created or reused thread now executes the function @func
with the two arguments. The first one is the parameter to
g_thread_pool_push() and the second one is @user_data.

Pass g_get_num_processors() to @max_threads to create as many threads as
there are logical processors on the system. This will not pin each thread to
a specific processor.

The parameter @exclusive determines whether the thread pool owns
all threads exclusive or shares them with other thread pools.
If @exclusive is %TRUE, @max_threads threads are started
immediately and they will run exclusively for this thread pool
until it is destroyed by g_thread_pool_free(). If @exclusive is
%FALSE, threads are created when needed and shared between all
non-exclusive thread pools. This implies that @max_threads may
not be -1 for exclusive thread pools. Besides, exclusive thread
pools are not affected by g_thread_pool_set_max_idle_time()
since their threads are never considered idle and returned to the
global pool.

Note that the threads used by exclusive thread pools will all inherit the
scheduler settings of the current thread while the threads used by
non-exclusive thread pools will inherit the scheduler settings from the
first thread that created such a thread pool.

At least one thread will be spawned when this function is called, either to
create the @max_threads exclusive threads, or to preserve the scheduler
settings of the current thread for future spawns.

@error can be %NULL to ignore errors, or non-%NULL to report
errors. An error can only occur when @exclusive is set to %TRUE
and not all @max_threads threads could be created.
See #GThreadError for possible errors that may occur.
Note, even in case of error a valid #GThreadPool is returned.</doc>
        <return-value>
          <doc xml:space="preserve">the new #GThreadPool</doc>
          <type name="ThreadPool" c:type="GThreadPool*"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">a function to execute in the threads of the new thread pool</doc>
            <type name="Func" c:type="GFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data that is handed over to @func every time it
    is called</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="max_threads" transfer-ownership="none">
            <doc xml:space="preserve">the maximal number of threads to execute concurrently
    in  the new thread pool, -1 means no limit</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="exclusive" transfer-ownership="none">
            <doc xml:space="preserve">should this thread pool be exclusive?</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_full" c:identifier="g_thread_pool_new_full" version="2.70" introspectable="0" throws="1">
        <doc xml:space="preserve">This function creates a new thread pool similar to g_thread_pool_new()
but allowing @item_free_func to be specified to free the data passed
to g_thread_pool_push() in the case that the #GThreadPool is stopped
and freed before all tasks have been executed.

@item_free_func will *not* be called on items successfully passed to @func.
@func is responsible for freeing the items passed to it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GThreadPool</doc>
          <type name="ThreadPool" c:type="GThreadPool*"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">a function to execute in the threads of the new thread pool</doc>
            <type name="Func" c:type="GFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data that is handed over to @func every time it
    is called</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="item_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">used to pass as a free function to
    g_async_queue_new_full()</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="max_threads" transfer-ownership="none">
            <doc xml:space="preserve">the maximal number of threads to execute concurrently
    in the new thread pool, `-1` means no limit</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="exclusive" transfer-ownership="none">
            <doc xml:space="preserve">should this thread pool be exclusive?</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_max_idle_time" c:identifier="g_thread_pool_set_max_idle_time" version="2.10">
        <doc xml:space="preserve">This function will set the maximum @interval that a thread
waiting in the pool for new tasks can be idle for before
being stopped. This function is similar to calling
g_thread_pool_stop_unused_threads() on a regular timeout,
except this is done on a per thread basis.

By setting @interval to 0, idle threads will not be stopped.

The default value is 15000 (15 seconds).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:space="preserve">the maximum @interval (in milliseconds)
    a thread can be idle</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_max_unused_threads" c:identifier="g_thread_pool_set_max_unused_threads">
        <doc xml:space="preserve">Sets the maximal number of unused threads to @max_threads.
If @max_threads is -1, no limit is imposed on the number
of unused threads.

The default value is 8 since GLib 2.84. Previously the default value was 2.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="max_threads" transfer-ownership="none">
            <doc xml:space="preserve">maximal number of unused threads</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="stop_unused_threads" c:identifier="g_thread_pool_stop_unused_threads">
        <doc xml:space="preserve">Stops all currently unused threads. This does not change the
maximal number of unused threads. This function can be used to
regularly stop all unused threads e.g. from g_timeout_add().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
    </record>
    <enumeration name="ThreadPriority" introspectable="0" deprecated="1" deprecated-version="2.32" c:type="GThreadPriority">
      <doc xml:space="preserve">Thread priorities.</doc>
      <doc-deprecated xml:space="preserve">Thread priorities no longer have any effect.</doc-deprecated>
      <member name="low" value="0" c:identifier="G_THREAD_PRIORITY_LOW">
        <doc xml:space="preserve">a priority lower than normal</doc>
      </member>
      <member name="normal" value="1" c:identifier="G_THREAD_PRIORITY_NORMAL">
        <doc xml:space="preserve">the default priority</doc>
      </member>
      <member name="high" value="2" c:identifier="G_THREAD_PRIORITY_HIGH">
        <doc xml:space="preserve">a priority higher than normal</doc>
      </member>
      <member name="urgent" value="3" c:identifier="G_THREAD_PRIORITY_URGENT">
        <doc xml:space="preserve">the highest priority</doc>
      </member>
    </enumeration>
    <enumeration name="TimeType" c:type="GTimeType">
      <doc xml:space="preserve">Disambiguates a given time in two ways.

First, specifies if the given time is in universal or local time.

Second, if the time is in local time, specifies if it is local
standard time or local daylight time.  This is important for the case
where the same local time occurs twice (during daylight savings time
transitions, for example).</doc>
      <member name="standard" value="0" c:identifier="G_TIME_TYPE_STANDARD">
        <doc xml:space="preserve">the time is in local standard time</doc>
      </member>
      <member name="daylight" value="1" c:identifier="G_TIME_TYPE_DAYLIGHT">
        <doc xml:space="preserve">the time is in local daylight time</doc>
      </member>
      <member name="universal" value="2" c:identifier="G_TIME_TYPE_UNIVERSAL">
        <doc xml:space="preserve">the time is in UTC</doc>
      </member>
    </enumeration>
    <record name="TimeVal" c:type="GTimeVal" deprecated="1" deprecated-version="2.62">
      <doc xml:space="preserve">Represents a precise time, with seconds and microseconds.

Similar to the struct timeval returned by the `gettimeofday()`
UNIX system call.

GLib is attempting to unify around the use of 64-bit integers to
represent microsecond-precision time. As such, this type will be
removed from a future version of GLib. A consequence of using `glong` for
`tv_sec` is that on 32-bit systems `GTimeVal` is subject to the year 2038
problem.</doc>
      <doc-deprecated xml:space="preserve">Use #GDateTime or #guint64 instead.</doc-deprecated>
      <field name="tv_sec" writable="1">
        <doc xml:space="preserve">seconds</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="tv_usec" writable="1">
        <doc xml:space="preserve">microseconds</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <method name="add" c:identifier="g_time_val_add" deprecated="1" deprecated-version="2.62">
        <doc xml:space="preserve">Adds the given number of microseconds to @time_. @microseconds can
also be negative to decrease the value of @time_.</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use `guint64` for
   representing microseconds since the epoch, or use #GDateTime.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="time_" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal</doc>
            <type name="TimeVal" c:type="GTimeVal*"/>
          </instance-parameter>
          <parameter name="microseconds" transfer-ownership="none">
            <doc xml:space="preserve">number of microseconds to add to @time</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_iso8601" c:identifier="g_time_val_to_iso8601" version="2.12" deprecated="1" deprecated-version="2.62">
        <doc xml:space="preserve">Converts @time_ into an RFC 3339 encoded string, relative to the
Coordinated Universal Time (UTC). This is one of the many formats
allowed by ISO 8601.

ISO 8601 allows a large number of date/time formats, with or without
punctuation and optional elements. The format returned by this function
is a complete date and time, with optional punctuation included, the
UTC time zone represented as "Z", and the @tv_usec part included if
and only if it is nonzero, i.e. either
"YYYY-MM-DDTHH:MM:SSZ" or "YYYY-MM-DDTHH:MM:SS.fffffZ".

This corresponds to the Internet date/time format defined by
[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt),
and to either of the two most-precise formats defined by
the W3C Note
[Date and Time Formats](http://www.w3.org/TR/NOTE-datetime-19980827).
Both of these documents are profiles of ISO 8601.

Use g_date_time_format() or g_strdup_printf() if a different
variation of ISO 8601 format is required.

If @time_ represents a date which is too large to fit into a `struct tm`,
%NULL will be returned. This is platform dependent. Note also that since
`GTimeVal` stores the number of seconds as a `glong`, on 32-bit systems it
is subject to the year 2038 problem. Accordingly, since GLib 2.62, this
function has been deprecated. Equivalent functionality is available using:
|[
GDateTime *dt = g_date_time_new_from_unix_utc (time_val);
iso8601_string = g_date_time_format_iso8601 (dt);
g_date_time_unref (dt);
]|

The return value of g_time_val_to_iso8601() has been nullable since GLib
2.54; before then, GLib would crash under the same conditions.</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use
   g_date_time_format_iso8601(dt) instead.</doc-deprecated>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated string containing an ISO 8601 date,
   or %NULL if @time_ was too large</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="time_" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal</doc>
            <type name="TimeVal" c:type="GTimeVal*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="from_iso8601" c:identifier="g_time_val_from_iso8601" version="2.12" deprecated="1" deprecated-version="2.62">
        <doc xml:space="preserve">Converts a string containing an ISO 8601 encoded date and time
to a #GTimeVal and puts it into @time_.

@iso_date must include year, month, day, hours, minutes, and
seconds. It can optionally include fractions of a second and a time
zone indicator. (In the absence of any time zone indication, the
timestamp is assumed to be in local time.)

Any leading or trailing space in @iso_date is ignored.

This function was deprecated, along with #GTimeVal itself, in GLib 2.62.
Equivalent functionality is available using code like:
|[
GDateTime *dt = g_date_time_new_from_iso8601 (iso8601_string, NULL);
gint64 time_val = g_date_time_to_unix (dt);
g_date_time_unref (dt);
]|</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use
   g_date_time_new_from_iso8601() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the conversion was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iso_date" transfer-ownership="none">
            <doc xml:space="preserve">an ISO 8601 encoded date string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="time_" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeVal</doc>
            <type name="TimeVal" c:type="GTimeVal*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="TimeZone" c:type="GTimeZone" opaque="1" version="2.26" glib:type-name="GTimeZone" glib:get-type="g_time_zone_get_type" c:symbol-prefix="time_zone">
      <doc xml:space="preserve">A `GTimeZone` represents a time zone, at no particular point in time.

The `GTimeZone` struct is refcounted and immutable.

Each time zone has an identifier (for example, &#x2018;Europe/London&#x2019;) which is
platform dependent. See [ctor@GLib.TimeZone.new] for information on the
identifier formats. The identifier of a time zone can be retrieved using
[method@GLib.TimeZone.get_identifier].

A time zone contains a number of intervals. Each interval has an abbreviation
to describe it (for example, &#x2018;PDT&#x2019;), an offset to UTC and a flag indicating
if the daylight savings time is in effect during that interval. A time zone
always has at least one interval &#x2014; interval 0. Note that interval abbreviations
are not the same as time zone identifiers (apart from &#x2018;UTC&#x2019;), and cannot be
passed to [ctor@GLib.TimeZone.new].

Every UTC time is contained within exactly one interval, but a given
local time may be contained within zero, one or two intervals (due to
incontinuities associated with daylight savings time).

An interval may refer to a specific period of time (eg: the duration
of daylight savings time during 2010) or it may refer to many periods
of time that share the same properties (eg: all periods of daylight
savings time).  It is also possible (usually for political reasons)
that some properties (like the abbreviation) change between intervals
without other properties changing.</doc>
      <constructor name="new" c:identifier="g_time_zone_new" version="2.26" deprecated="1" deprecated-version="2.68">
        <doc xml:space="preserve">A version of g_time_zone_new_identifier() which returns the UTC time zone
if @identifier could not be parsed or loaded.

If you need to check whether @identifier was loaded successfully, use
g_time_zone_new_identifier().</doc>
        <doc-deprecated xml:space="preserve">Use g_time_zone_new_identifier() instead, as it provides
    error reporting. Change your code to handle a potentially %NULL return
    value.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the requested timezone</doc>
          <type name="TimeZone" c:type="GTimeZone*"/>
        </return-value>
        <parameters>
          <parameter name="identifier" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a timezone identifier</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_identifier" c:identifier="g_time_zone_new_identifier" version="2.68">
        <doc xml:space="preserve">Creates a #GTimeZone corresponding to @identifier. If @identifier cannot be
parsed or loaded, %NULL is returned.

@identifier can either be an RFC3339/ISO 8601 time offset or
something that would pass as a valid value for the `TZ` environment
variable (including %NULL).

In Windows, @identifier can also be the unlocalized name of a time
zone for standard time, for example "Pacific Standard Time".

Valid RFC3339 time offsets are `"Z"` (for UTC) or
`"&#xB1;hh:mm"`.  ISO 8601 additionally specifies
`"&#xB1;hhmm"` and `"&#xB1;hh"`.  Offsets are
time values to be added to Coordinated Universal Time (UTC) to get
the local time.

In UNIX, the `TZ` environment variable typically corresponds
to the name of a file in the zoneinfo database, an absolute path to a file
somewhere else, or a string in
"std offset [dst [offset],start[/time],end[/time]]" (POSIX) format.
There  are  no spaces in the specification. The name of standard
and daylight savings time zone must be three or more alphabetic
characters. Offsets are time values to be added to local time to
get Coordinated Universal Time (UTC) and should be
`"[&#xB1;]hh[[:]mm[:ss]]"`.  Dates are either
`"Jn"` (Julian day with n between 1 and 365, leap
years not counted), `"n"` (zero-based Julian day
with n between 0 and 365) or `"Mm.w.d"` (day d
(0 &lt;= d &lt;= 6) of week w (1 &lt;= w &lt;= 5) of month m (1 &lt;= m &lt;= 12), day
0 is a Sunday).  Times are in local wall clock time, the default is
02:00:00.

In Windows, the "tzn[+|&#x2013;]hh[:mm[:ss]][dzn]" format is used, but also
accepts POSIX format.  The Windows format uses US rules for all time
zones; daylight savings time is 60 minutes behind the standard time
with date and time of change taken from Pacific Standard Time.
Offsets are time values to be added to the local time to get
Coordinated Universal Time (UTC).

g_time_zone_new_local() calls this function with the value of the
`TZ` environment variable. This function itself is independent of
the value of `TZ`, but if @identifier is %NULL then `/etc/localtime`
will be consulted to discover the correct time zone on UNIX and the
registry will be consulted or GetTimeZoneInformation() will be used
to get the local time zone on Windows.

If intervals are not available, only time zone rules from `TZ`
environment variable or other means, then they will be computed
from year 1900 to 2037.  If the maximum year for the rules is
available and it is greater than 2037, then it will followed
instead.

See
[RFC3339 &#xA7;5.6](http://tools.ietf.org/html/rfc3339#section-5.6)
for a precise definition of valid RFC3339 time offsets
(the `time-offset` expansion) and ISO 8601 for the
full list of valid time offsets.  See
[The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)
for an explanation of the possible
values of the `TZ` environment variable. See
[Microsoft Time Zone Index Values](http://msdn.microsoft.com/en-us/library/ms912391%28v=winembedded.11%29.aspx)
for the list of time zones on Windows.

You should release the return value by calling g_time_zone_unref()
when you are done with it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the requested timezone, or %NULL on
    failure</doc>
          <type name="TimeZone" c:type="GTimeZone*"/>
        </return-value>
        <parameters>
          <parameter name="identifier" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a timezone identifier</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_local" c:identifier="g_time_zone_new_local" version="2.26">
        <doc xml:space="preserve">Creates a #GTimeZone corresponding to local time.  The local time
zone may change between invocations to this function; for example,
if the system administrator changes it.

This is equivalent to calling g_time_zone_new() with the value of
the `TZ` environment variable (including the possibility of %NULL).

You should release the return value by calling g_time_zone_unref()
when you are done with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the local timezone</doc>
          <type name="TimeZone" c:type="GTimeZone*"/>
        </return-value>
      </constructor>
      <constructor name="new_offset" c:identifier="g_time_zone_new_offset" version="2.58">
        <doc xml:space="preserve">Creates a #GTimeZone corresponding to the given constant offset from UTC,
in seconds.

This is equivalent to calling g_time_zone_new() with a string in the form
`[+|-]hh[:mm[:ss]]`.

It is possible for this function to fail if @seconds is too big (greater than
24 hours), in which case this function will return the UTC timezone for
backwards compatibility. To detect failures like this, use
g_time_zone_new_identifier() directly.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a timezone at the given offset from UTC, or UTC on
  failure</doc>
          <type name="TimeZone" c:type="GTimeZone*"/>
        </return-value>
        <parameters>
          <parameter name="seconds" transfer-ownership="none">
            <doc xml:space="preserve">offset to UTC, in seconds</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_utc" c:identifier="g_time_zone_new_utc" version="2.26">
        <doc xml:space="preserve">Creates a #GTimeZone corresponding to UTC.

This is equivalent to calling g_time_zone_new() with a value like
"Z", "UTC", "+00", etc.

You should release the return value by calling g_time_zone_unref()
when you are done with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the universal timezone</doc>
          <type name="TimeZone" c:type="GTimeZone*"/>
        </return-value>
      </constructor>
      <method name="adjust_time" c:identifier="g_time_zone_adjust_time" version="2.26">
        <doc xml:space="preserve">Finds an interval within @tz that corresponds to the given @time_,
possibly adjusting @time_ if required to fit into an interval.
The meaning of @time_ depends on @type.

This function is similar to g_time_zone_find_interval(), with the
difference that it always succeeds (by making the adjustments
described below).

In any of the cases where g_time_zone_find_interval() succeeds then
this function returns the same value, without modifying @time_.

This function may, however, modify @time_ in order to deal with
non-existent times.  If the non-existent local @time_ of 02:30 were
requested on March 14th 2010 in Toronto then this function would
adjust @time_ to be 03:00 and return the interval containing the
adjusted time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interval containing @time_, never -1</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GTimeType of @time_</doc>
            <type name="TimeType" c:type="GTimeType"/>
          </parameter>
          <parameter name="time_" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a pointer to a number of seconds since January 1, 1970</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_interval" c:identifier="g_time_zone_find_interval" version="2.26">
        <doc xml:space="preserve">Finds an interval within @tz that corresponds to the given @time_.
The meaning of @time_ depends on @type.

If @type is %G_TIME_TYPE_UNIVERSAL then this function will always
succeed (since universal time is monotonic and continuous).

Otherwise @time_ is treated as local time.  The distinction between
%G_TIME_TYPE_STANDARD and %G_TIME_TYPE_DAYLIGHT is ignored except in
the case that the given @time_ is ambiguous.  In Toronto, for example,
01:30 on November 7th 2010 occurred twice (once inside of daylight
savings time and the next, an hour later, outside of daylight savings
time).  In this case, the different value of @type would result in a
different interval being returned.

It is still possible for this function to fail.  In Toronto, for
example, 02:00 on March 14th 2010 does not exist (due to the leap
forward to begin daylight savings time).  -1 is returned in that
case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interval containing @time_, or -1 in case of failure</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GTimeType of @time_</doc>
            <type name="TimeType" c:type="GTimeType"/>
          </parameter>
          <parameter name="time_" transfer-ownership="none">
            <doc xml:space="preserve">a number of seconds since January 1, 1970</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_abbreviation" c:identifier="g_time_zone_get_abbreviation" version="2.26">
        <doc xml:space="preserve">Determines the time zone abbreviation to be used during a particular
@interval of time in the time zone @tz.

For example, in Toronto this is currently "EST" during the winter
months and "EDT" during the summer months when daylight savings time
is in effect.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the time zone abbreviation, which belongs to @tz</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </instance-parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:space="preserve">an interval within the timezone</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_identifier" c:identifier="g_time_zone_get_identifier" version="2.58">
        <doc xml:space="preserve">Get the identifier of this #GTimeZone, as passed to g_time_zone_new().
If the identifier passed at construction time was not recognised, `UTC` will
be returned. If it was %NULL, the identifier of the local timezone at
construction time will be returned.

The identifier will be returned in the same format as provided at
construction time: if provided as a time offset, that will be returned by
this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">identifier for this timezone</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset" c:identifier="g_time_zone_get_offset" version="2.26">
        <doc xml:space="preserve">Determines the offset to UTC in effect during a particular @interval
of time in the time zone @tz.

The offset is the number of seconds that you add to UTC time to
arrive at local time for @tz (ie: negative numbers for time zones
west of GMT, positive numbers for east).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of seconds that should be added to UTC to get the
         local time in @tz</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </instance-parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:space="preserve">an interval within the timezone</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_dst" c:identifier="g_time_zone_is_dst" version="2.26">
        <doc xml:space="preserve">Determines if daylight savings time is in effect during a particular
@interval of time in the time zone @tz.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if daylight savings time is in effect</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </instance-parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:space="preserve">an interval within the timezone</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_time_zone_ref" version="2.26">
        <doc xml:space="preserve">Increases the reference count on @tz.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to @tz.</doc>
          <type name="TimeZone" c:type="GTimeZone*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_time_zone_unref" version="2.26">
        <doc xml:space="preserve">Decreases the reference count on @tz.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Timer" c:type="GTimer" disguised="1" opaque="1">
      <doc xml:space="preserve">`GTimer` records a start time, and counts microseconds elapsed since
that time.

This is done somewhat differently on different platforms, and can be
tricky to get exactly right, so `GTimer` provides a portable/convenient interface.</doc>
      <method name="continue" c:identifier="g_timer_continue" version="2.4">
        <doc xml:space="preserve">Resumes a timer that has previously been stopped with
g_timer_stop(). g_timer_stop() must be called before using this
function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="timer" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimer.</doc>
            <type name="Timer" c:type="GTimer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="g_timer_destroy">
        <doc xml:space="preserve">Destroys a timer, freeing associated resources.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="timer" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimer to destroy.</doc>
            <type name="Timer" c:type="GTimer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="elapsed" c:identifier="g_timer_elapsed">
        <doc xml:space="preserve">If @timer has been started but not stopped, obtains the time since
the timer was started. If @timer has been stopped, obtains the
elapsed time between the time it was started and the time it was
stopped. The return value is the number of seconds elapsed,
including any fractional part. The @microseconds out parameter is
essentially useless.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">seconds elapsed as a floating point value, including any
         fractional part.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="timer" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimer.</doc>
            <type name="Timer" c:type="GTimer*"/>
          </instance-parameter>
          <parameter name="microseconds" transfer-ownership="none">
            <doc xml:space="preserve">return location for the fractional part of seconds
               elapsed, in microseconds (that is, the total number
               of microseconds elapsed, modulo 1000000), or %NULL</doc>
            <type name="gulong" c:type="gulong*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_active" c:identifier="g_timer_is_active" version="2.62">
        <doc xml:space="preserve">Exposes whether the timer is currently active.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the timer is running, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="timer" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimer.</doc>
            <type name="Timer" c:type="GTimer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="g_timer_reset">
        <doc xml:space="preserve">This function is useless; it's fine to call g_timer_start() on an
already-started timer to reset the start time, so g_timer_reset()
serves no purpose.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="timer" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimer.</doc>
            <type name="Timer" c:type="GTimer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="g_timer_start">
        <doc xml:space="preserve">Marks a start time, so that future calls to g_timer_elapsed() will
report the time since g_timer_start() was called. g_timer_new()
automatically marks the start time, so no need to call
g_timer_start() immediately after creating the timer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="timer" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimer.</doc>
            <type name="Timer" c:type="GTimer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="g_timer_stop">
        <doc xml:space="preserve">Marks an end time, so calls to g_timer_elapsed() will return the
difference between this end time and the start time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="timer" transfer-ownership="none">
            <doc xml:space="preserve">a #GTimer.</doc>
            <type name="Timer" c:type="GTimer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_timer_new" introspectable="0">
        <doc xml:space="preserve">Creates a new timer, and starts timing (i.e. g_timer_start() is
implicitly called for you).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GTimer.</doc>
          <type name="Timer" c:type="GTimer*"/>
        </return-value>
      </function>
    </record>
    <enumeration name="TokenType" c:type="GTokenType">
      <doc xml:space="preserve">The possible types of token returned from each
g_scanner_get_next_token() call.</doc>
      <member name="eof" value="0" c:identifier="G_TOKEN_EOF">
        <doc xml:space="preserve">the end of the file</doc>
      </member>
      <member name="left_paren" value="40" c:identifier="G_TOKEN_LEFT_PAREN">
        <doc xml:space="preserve">a '(' character</doc>
      </member>
      <member name="right_paren" value="41" c:identifier="G_TOKEN_RIGHT_PAREN">
        <doc xml:space="preserve">a ')' character</doc>
      </member>
      <member name="left_curly" value="123" c:identifier="G_TOKEN_LEFT_CURLY">
        <doc xml:space="preserve">a '{' character</doc>
      </member>
      <member name="right_curly" value="125" c:identifier="G_TOKEN_RIGHT_CURLY">
        <doc xml:space="preserve">a '}' character</doc>
      </member>
      <member name="left_brace" value="91" c:identifier="G_TOKEN_LEFT_BRACE">
        <doc xml:space="preserve">a '[' character</doc>
      </member>
      <member name="right_brace" value="93" c:identifier="G_TOKEN_RIGHT_BRACE">
        <doc xml:space="preserve">a ']' character</doc>
      </member>
      <member name="equal_sign" value="61" c:identifier="G_TOKEN_EQUAL_SIGN">
        <doc xml:space="preserve">a '=' character</doc>
      </member>
      <member name="comma" value="44" c:identifier="G_TOKEN_COMMA">
        <doc xml:space="preserve">a ',' character</doc>
      </member>
      <member name="none" value="256" c:identifier="G_TOKEN_NONE">
        <doc xml:space="preserve">not a token</doc>
      </member>
      <member name="error" value="257" c:identifier="G_TOKEN_ERROR">
        <doc xml:space="preserve">an error occurred</doc>
      </member>
      <member name="char" value="258" c:identifier="G_TOKEN_CHAR">
        <doc xml:space="preserve">a character</doc>
      </member>
      <member name="binary" value="259" c:identifier="G_TOKEN_BINARY">
        <doc xml:space="preserve">a binary integer</doc>
      </member>
      <member name="octal" value="260" c:identifier="G_TOKEN_OCTAL">
        <doc xml:space="preserve">an octal integer</doc>
      </member>
      <member name="int" value="261" c:identifier="G_TOKEN_INT">
        <doc xml:space="preserve">an integer</doc>
      </member>
      <member name="hex" value="262" c:identifier="G_TOKEN_HEX">
        <doc xml:space="preserve">a hex integer</doc>
      </member>
      <member name="float" value="263" c:identifier="G_TOKEN_FLOAT">
        <doc xml:space="preserve">a floating point number</doc>
      </member>
      <member name="string" value="264" c:identifier="G_TOKEN_STRING">
        <doc xml:space="preserve">a string</doc>
      </member>
      <member name="symbol" value="265" c:identifier="G_TOKEN_SYMBOL">
        <doc xml:space="preserve">a symbol</doc>
      </member>
      <member name="identifier" value="266" c:identifier="G_TOKEN_IDENTIFIER">
        <doc xml:space="preserve">an identifier</doc>
      </member>
      <member name="identifier_null" value="267" c:identifier="G_TOKEN_IDENTIFIER_NULL">
        <doc xml:space="preserve">a null identifier</doc>
      </member>
      <member name="comment_single" value="268" c:identifier="G_TOKEN_COMMENT_SINGLE">
        <doc xml:space="preserve">one line comment</doc>
      </member>
      <member name="comment_multi" value="269" c:identifier="G_TOKEN_COMMENT_MULTI">
        <doc xml:space="preserve">multi line comment</doc>
      </member>
    </enumeration>
    <union name="TokenValue" c:type="GTokenValue">
      <doc xml:space="preserve">A union holding the value of the token.</doc>
      <field name="v_symbol" writable="1">
        <doc xml:space="preserve">token symbol value</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="v_identifier" writable="1">
        <doc xml:space="preserve">token identifier value</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="v_binary" writable="1">
        <doc xml:space="preserve">token binary integer value</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="v_octal" writable="1">
        <doc xml:space="preserve">octal integer value</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="v_int" writable="1">
        <doc xml:space="preserve">integer value</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="v_int64" writable="1">
        <doc xml:space="preserve">64-bit integer value</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="v_float" writable="1">
        <doc xml:space="preserve">floating point value</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="v_hex" writable="1">
        <doc xml:space="preserve">hex integer value</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="v_string" writable="1">
        <doc xml:space="preserve">string value</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="v_comment" writable="1">
        <doc xml:space="preserve">comment value</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="v_char" writable="1">
        <doc xml:space="preserve">character value</doc>
        <type name="guint8" c:type="guchar"/>
      </field>
      <field name="v_error" writable="1">
        <doc xml:space="preserve">error value</doc>
        <type name="guint" c:type="guint"/>
      </field>
    </union>
    <callback name="TranslateFunc" c:type="GTranslateFunc">
      <doc xml:space="preserve">The type of functions which are used to translate user-visible
strings, for &lt;option&gt;--help&lt;/option&gt; output.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a translation of the string for the current locale.
 The returned string is owned by GLib and must not be freed.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the untranslated string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data specified when installing the function, e.g.
 in g_option_group_set_translate_func()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TrashStack" c:type="GTrashStack" deprecated="1" deprecated-version="2.48">
      <doc xml:space="preserve">A `GTrashStack` is an efficient way to keep a stack of unused allocated
memory chunks. Each memory chunk is required to be large enough to hold
a `gpointer`. This allows the stack to be maintained without any space
overhead, since the stack pointers can be stored inside the memory chunks.

There is no function to create a `GTrashStack`. A `NULL` `GTrashStack*`
is a perfectly valid empty stack.

Each piece of memory that is pushed onto the stack is cast to a
`GTrashStack*`.

There is no longer any good reason to use `GTrashStack`.  If you have
extra pieces of memory, `free()` them and allocate them again later.</doc>
      <doc-deprecated xml:space="preserve">`GTrashStack` is deprecated without replacement</doc-deprecated>
      <field name="next" writable="1">
        <doc xml:space="preserve">pointer to the previous element of the stack,
    gets stored in the first `sizeof (gpointer)`
    bytes of the element</doc>
        <type name="TrashStack" c:type="GTrashStack*"/>
      </field>
      <function name="height" c:identifier="g_trash_stack_height" deprecated="1" deprecated-version="2.48">
        <doc xml:space="preserve">Returns the height of a #GTrashStack.

Note that execution of this function is of O(N) complexity
where N denotes the number of items on the stack.</doc>
        <doc-deprecated xml:space="preserve">#GTrashStack is deprecated without replacement</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the height of the stack</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="stack_p" transfer-ownership="none">
            <doc xml:space="preserve">a #GTrashStack</doc>
            <type name="TrashStack" c:type="GTrashStack**"/>
          </parameter>
        </parameters>
      </function>
      <function name="peek" c:identifier="g_trash_stack_peek" deprecated="1" deprecated-version="2.48">
        <doc xml:space="preserve">Returns the element at the top of a #GTrashStack
which may be %NULL.</doc>
        <doc-deprecated xml:space="preserve">#GTrashStack is deprecated without replacement</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the element at the top of the stack</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="stack_p" transfer-ownership="none">
            <doc xml:space="preserve">a #GTrashStack</doc>
            <type name="TrashStack" c:type="GTrashStack**"/>
          </parameter>
        </parameters>
      </function>
      <function name="pop" c:identifier="g_trash_stack_pop" deprecated="1" deprecated-version="2.48">
        <doc xml:space="preserve">Pops a piece of memory off a #GTrashStack.</doc>
        <doc-deprecated xml:space="preserve">#GTrashStack is deprecated without replacement</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the element at the top of the stack</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="stack_p" transfer-ownership="none">
            <doc xml:space="preserve">a #GTrashStack</doc>
            <type name="TrashStack" c:type="GTrashStack**"/>
          </parameter>
        </parameters>
      </function>
      <function name="push" c:identifier="g_trash_stack_push" deprecated="1" deprecated-version="2.48">
        <doc xml:space="preserve">Pushes a piece of memory onto a #GTrashStack.</doc>
        <doc-deprecated xml:space="preserve">#GTrashStack is deprecated without replacement</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stack_p" transfer-ownership="none">
            <doc xml:space="preserve">a #GTrashStack</doc>
            <type name="TrashStack" c:type="GTrashStack**"/>
          </parameter>
          <parameter name="data_p" transfer-ownership="none">
            <doc xml:space="preserve">the piece of memory to push on the stack</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="TraverseFlags" c:type="GTraverseFlags">
      <doc xml:space="preserve">Specifies which nodes are visited during several of the tree
functions, including g_node_traverse() and g_node_find().</doc>
      <member name="leaves" value="1" c:identifier="G_TRAVERSE_LEAVES">
        <doc xml:space="preserve">only leaf nodes should be visited. This name has
                    been introduced in 2.6, for older version use
                    %G_TRAVERSE_LEAFS.</doc>
      </member>
      <member name="non_leaves" value="2" c:identifier="G_TRAVERSE_NON_LEAVES">
        <doc xml:space="preserve">only non-leaf nodes should be visited. This
                        name has been introduced in 2.6, for older
                        version use %G_TRAVERSE_NON_LEAFS.</doc>
      </member>
      <member name="all" value="3" c:identifier="G_TRAVERSE_ALL">
        <doc xml:space="preserve">all nodes should be visited.</doc>
      </member>
      <member name="mask" value="3" c:identifier="G_TRAVERSE_MASK">
        <doc xml:space="preserve">a mask of all traverse flags.</doc>
      </member>
      <member name="leafs" value="1" c:identifier="G_TRAVERSE_LEAFS">
        <doc xml:space="preserve">identical to %G_TRAVERSE_LEAVES.</doc>
      </member>
      <member name="non_leafs" value="2" c:identifier="G_TRAVERSE_NON_LEAFS">
        <doc xml:space="preserve">identical to %G_TRAVERSE_NON_LEAVES.</doc>
      </member>
    </bitfield>
    <callback name="TraverseFunc" c:type="GTraverseFunc">
      <doc xml:space="preserve">Specifies the type of function passed to g_tree_traverse(). It is
passed the key and value of each node, together with the @user_data
parameter passed to g_tree_traverse(). If the function returns
%TRUE, the traversal is stopped.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE to stop the traversal</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a key of a #GTree node</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the value corresponding to the key</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to g_tree_traverse()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TraverseNodeFunc" c:type="GTraverseNodeFunc" version="2.68">
      <doc xml:space="preserve">Specifies the type of function passed to g_tree_foreach_node(). It is
passed each node, together with the @user_data parameter passed to
g_tree_foreach_node(). If the function returns %TRUE, the traversal is
stopped.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE to stop the traversal</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a #GTreeNode</doc>
          <type name="TreeNode" c:type="GTreeNode*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to g_tree_foreach_node()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="TraverseType" c:type="GTraverseType">
      <doc xml:space="preserve">Specifies the type of traversal performed by g_tree_traverse(),
g_node_traverse() and g_node_find().

The different orders are illustrated here:

- In order: A, B, C, D, E, F, G, H, I
  &lt;picture&gt;
    &lt;source srcset="Sorted_binary_tree_inorder-dark.svg"
     media="(prefers-color-scheme: dark)"&gt;
    &lt;img src="Sorted_binary_tree_inorder.svg"
     alt="Sorted binary tree, in-order traversal"&gt;
  &lt;/picture&gt;
- Pre order: F, B, A, D, C, E, G, I, H
  &lt;picture&gt;
    &lt;source srcset="Sorted_binary_tree_preorder-dark.svg"
     media="(prefers-color-scheme: dark)"&gt;
    &lt;img src="Sorted_binary_tree_preorder.svg"
     alt="Sorted binary tree, pre-order traversal"&gt;
  &lt;/picture&gt;
- Post order: A, C, E, D, B, H, I, G, F
  &lt;picture&gt;
    &lt;source srcset="Sorted_binary_tree_postorder-dark.svg"
     media="(prefers-color-scheme: dark)"&gt;
    &lt;img src="Sorted_binary_tree_postorder.svg"
     alt="Sorted binary tree, post-order traversal"&gt;
  &lt;/picture&gt;
- Level order: F, B, G, A, D, I, C, E, H
  &lt;picture&gt;
    &lt;source srcset="Sorted_binary_tree_breadth-first_traversal-dark.svg"
     media="(prefers-color-scheme: dark)"&gt;
    &lt;img src="Sorted_binary_tree_breadth-first_traversal.svg"
     alt="Sorted binary tree, breadth-first level order traversal"&gt;
  &lt;/picture&gt;</doc>
      <member name="in_order" value="0" c:identifier="G_IN_ORDER">
        <doc xml:space="preserve">visits a node's left child first, then the node itself,
             then its right child. This is the one to use if you
             want the output sorted according to the compare
             function.</doc>
      </member>
      <member name="pre_order" value="1" c:identifier="G_PRE_ORDER">
        <doc xml:space="preserve">visits a node, then its children.</doc>
      </member>
      <member name="post_order" value="2" c:identifier="G_POST_ORDER">
        <doc xml:space="preserve">visits the node's children, then the node itself.</doc>
      </member>
      <member name="level_order" value="3" c:identifier="G_LEVEL_ORDER">
        <doc xml:space="preserve">is not implemented for
             [balanced binary trees](data-structures.html#binary-trees).
             For [n-ary trees](data-structures.html#n-ary-trees), it
             visits the root node first, then its children, then
             its grandchildren, and so on. Note that this is less
             efficient than the other orders.</doc>
      </member>
    </enumeration>
    <record name="Tree" c:type="GTree" opaque="1" glib:type-name="GTree" glib:get-type="g_tree_get_type" c:symbol-prefix="tree">
      <doc xml:space="preserve">The GTree struct is an opaque data structure representing a
[balanced binary tree](data-structures.html#binary-trees). It should be
accessed only by using the following functions.</doc>
      <constructor name="new" c:identifier="g_tree_new" introspectable="0">
        <doc xml:space="preserve">Creates a new #GTree.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GTree</doc>
          <type name="Tree" c:type="GTree*"/>
        </return-value>
        <parameters>
          <parameter name="key_compare_func" transfer-ownership="none">
            <doc xml:space="preserve">the function used to order the nodes in the #GTree.
  It should return values similar to the standard strcmp() function -
  0 if the two arguments are equal, a negative value if the first argument
  comes before the second, or a positive value if the first argument comes
  after the second.</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full" c:identifier="g_tree_new_full">
        <doc xml:space="preserve">Creates a new #GTree like g_tree_new() and allows to specify functions
to free the memory allocated for the key and value that get called when
removing the entry from the #GTree.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GTree</doc>
          <type name="Tree" c:type="GTree*"/>
        </return-value>
        <parameters>
          <parameter name="key_compare_func" transfer-ownership="none" scope="notified" closure="1" destroy="3">
            <doc xml:space="preserve">qsort()-style comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="key_compare_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to comparison function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="key_destroy_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a function to free the memory allocated for the key
  used when removing the entry from the #GTree or %NULL if you don't
  want to supply such a function</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="value_destroy_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a function to free the memory allocated for the
  value used when removing the entry from the #GTree or %NULL if you
  don't want to supply such a function</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_data" c:identifier="g_tree_new_with_data" introspectable="0">
        <doc xml:space="preserve">Creates a new #GTree with a comparison function that accepts user data.
See g_tree_new() for more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GTree</doc>
          <type name="Tree" c:type="GTree*"/>
        </return-value>
        <parameters>
          <parameter name="key_compare_func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">qsort()-style comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="key_compare_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to comparison function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="destroy" c:identifier="g_tree_destroy">
        <doc xml:space="preserve">Removes all keys and values from the #GTree and decreases its
reference count by one. If keys and/or values are dynamically
allocated, you should either free them first or create the #GTree
using g_tree_new_full(). In the latter case the destroy functions
you supplied will be called on all keys and values before destroying
the #GTree.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="g_tree_foreach">
        <doc xml:space="preserve">Calls the given function for each of the key/value pairs in the #GTree.
The function is passed the key and value of each pair, and the given
@data parameter. The tree is traversed in sorted order.

The tree may not be modified while iterating over it (you can't
add/remove items). To remove all items matching a predicate, you need
to add each item to a list in your #GTraverseFunc as you walk over
the tree, then walk the list and remove each item.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the function to call for each node visited.
    If this function returns %TRUE, the traversal is stopped.</doc>
            <type name="TraverseFunc" c:type="GTraverseFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_node" c:identifier="g_tree_foreach_node" version="2.68">
        <doc xml:space="preserve">Calls the given function for each of the nodes in the #GTree.
The function is passed the pointer to the particular node, and the given
@data parameter. The tree traversal happens in-order.

The tree may not be modified while iterating over it (you can't
add/remove items). To remove all items matching a predicate, you need
to add each item to a list in your #GTraverseFunc as you walk over
the tree, then walk the list and remove each item.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">the function to call for each node visited.
    If this function returns %TRUE, the traversal is stopped.</doc>
            <type name="TraverseNodeFunc" c:type="GTraverseNodeFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="height" c:identifier="g_tree_height">
        <doc xml:space="preserve">Gets the height of a #GTree.

If the #GTree contains no nodes, the height is 0.
If the #GTree contains only one root node the height is 1.
If the root node has children the height is 2, etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the height of @tree</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_tree_insert">
        <doc xml:space="preserve">Inserts a key/value pair into a #GTree.

Inserts a new key and value into a #GTree as g_tree_insert_node() does,
only this function does not return the inserted or set node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to insert</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value corresponding to the key</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_node" c:identifier="g_tree_insert_node" version="2.68">
        <doc xml:space="preserve">Inserts a key/value pair into a #GTree.

If the given key already exists in the #GTree its corresponding value
is set to the new value. If you supplied a @value_destroy_func when
creating the #GTree, the old value is freed using that function. If
you supplied a @key_destroy_func when creating the #GTree, the passed
key is freed using that function.

The tree is automatically 'balanced' as new key/value pairs are added,
so that the distance from the root to every leaf is as small as possible.
The cost of maintaining a balanced tree while inserting new key/value
result in a O(n log(n)) operation where most of the other operations
are O(log(n)).</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the inserted (or set) node or %NULL
if insertion would overflow the tree node counter.</doc>
          <type name="TreeNode" c:type="GTreeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to insert</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value corresponding to the key</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="g_tree_lookup">
        <doc xml:space="preserve">Gets the value corresponding to the given key. Since a #GTree is
automatically balanced as key/value pairs are added, key lookup
is O(log n) (where n is the number of key/value pairs in the tree).</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the value corresponding to the key, or %NULL
    if the key was not found</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_extended" c:identifier="g_tree_lookup_extended">
        <doc xml:space="preserve">Looks up a key in the #GTree, returning the original key and the
associated value. This is useful if you need to free the memory
allocated for the original key, for example before calling
g_tree_remove().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key was found in the #GTree</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="lookup_key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="orig_key" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">returns the original key</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">returns the value associated with the key</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_node" c:identifier="g_tree_lookup_node" version="2.68">
        <doc xml:space="preserve">Gets the tree node corresponding to the given key. Since a #GTree is
automatically balanced as key/value pairs are added, key lookup
is O(log n) (where n is the number of key/value pairs in the tree).</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the tree node corresponding to
         the key, or %NULL if the key was not found</doc>
          <type name="TreeNode" c:type="GTreeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lower_bound" c:identifier="g_tree_lower_bound" version="2.68">
        <doc xml:space="preserve">Gets the lower bound node corresponding to the given key,
or %NULL if the tree is empty or all the nodes in the tree
have keys that are strictly lower than the searched key.

The lower bound is the first node that has its key greater
than or equal to the searched key.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the tree node corresponding to
         the lower bound, or %NULL if the tree is empty or has only
         keys strictly lower than the searched key.</doc>
          <type name="TreeNode" c:type="GTreeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to calculate the lower bound for</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="nnodes" c:identifier="g_tree_nnodes">
        <doc xml:space="preserve">Gets the number of nodes in a #GTree.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of nodes in @tree

The node counter value type is really a #guint,
but it is returned as a #gint due to backward
compatibility issues (can be cast back to #guint to
support its full range of values).</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="node_first" c:identifier="g_tree_node_first" version="2.68">
        <doc xml:space="preserve">Returns the first in-order node of the tree, or %NULL
for an empty tree.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the first node in the tree</doc>
          <type name="TreeNode" c:type="GTreeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="node_last" c:identifier="g_tree_node_last" version="2.68">
        <doc xml:space="preserve">Returns the last in-order node of the tree, or %NULL
for an empty tree.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the last node in the tree</doc>
          <type name="TreeNode" c:type="GTreeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_tree_ref" version="2.22">
        <doc xml:space="preserve">Increments the reference count of @tree by one.

It is safe to call this function from any thread.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in #GTree</doc>
          <type name="Tree" c:type="GTree*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_tree_remove">
        <doc xml:space="preserve">Removes a key/value pair from a #GTree.

If the #GTree was created using g_tree_new_full(), the key and value
are freed using the supplied destroy functions, otherwise you have to
make sure that any dynamically allocated values are freed yourself.
If the key does not exist in the #GTree, the function does nothing.

The cost of maintaining a balanced tree while removing a key/value
result in a O(n log(n)) operation where most of the other operations
are O(log(n)).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key was found (prior to 2.8, this function
    returned nothing)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to remove</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_all" c:identifier="g_tree_remove_all" version="2.70">
        <doc xml:space="preserve">Removes all nodes from a #GTree and destroys their keys and values,
then resets the #GTree&#x2019;s root to %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="replace" c:identifier="g_tree_replace">
        <doc xml:space="preserve">Inserts a new key and value into a #GTree as g_tree_replace_node() does,
only this function does not return the inserted or set node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to insert</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value corresponding to the key</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_node" c:identifier="g_tree_replace_node" version="2.68">
        <doc xml:space="preserve">Inserts a new key and value into a #GTree similar to g_tree_insert_node().
The difference is that if the key already exists in the #GTree, it gets
replaced by the new key. If you supplied a @value_destroy_func when
creating the #GTree, the old value is freed using that function. If you
supplied a @key_destroy_func when creating the #GTree, the old key is
freed using that function.

The tree is automatically 'balanced' as new key/value pairs are added,
so that the distance from the root to every leaf is as small as possible.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the inserted (or set) node or %NULL
if insertion would overflow the tree node counter.</doc>
          <type name="TreeNode" c:type="GTreeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to insert</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the value corresponding to the key</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="search" c:identifier="g_tree_search">
        <doc xml:space="preserve">Searches a #GTree using @search_func.

The @search_func is called with a pointer to the key of a key/value
pair in the tree, and the passed in @user_data. If @search_func returns
0 for a key/value pair, then the corresponding value is returned as
the result of g_tree_search(). If @search_func returns -1, searching
will proceed among the key/value pairs that have a smaller key; if
@search_func returns 1, searching will proceed among the key/value
pairs that have a larger key.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the value corresponding to the found key, or %NULL
    if the key was not found</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="search_func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">a function used to search the #GTree</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data passed as the second argument to @search_func</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_node" c:identifier="g_tree_search_node" version="2.68">
        <doc xml:space="preserve">Searches a #GTree using @search_func.

The @search_func is called with a pointer to the key of a key/value
pair in the tree, and the passed in @user_data. If @search_func returns
0 for a key/value pair, then the corresponding node is returned as
the result of g_tree_search(). If @search_func returns -1, searching
will proceed among the key/value pairs that have a smaller key; if
@search_func returns 1, searching will proceed among the key/value
pairs that have a larger key.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the node corresponding to the
         found key, or %NULL if the key was not found</doc>
          <type name="TreeNode" c:type="GTreeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="search_func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">a function used to search the #GTree</doc>
            <type name="CompareFunc" c:type="GCompareFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data passed as the second argument to @search_func</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal" c:identifier="g_tree_steal">
        <doc xml:space="preserve">Removes a key and its associated value from a #GTree without calling
the key and value destroy functions.

If the key does not exist in the #GTree, the function does nothing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key was found (prior to 2.8, this function
    returned nothing)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to remove</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="traverse" c:identifier="g_tree_traverse" deprecated="1" deprecated-version="2.2">
        <doc xml:space="preserve">Calls the given function for each node in the #GTree.</doc>
        <doc-deprecated xml:space="preserve">The order of a balanced tree is somewhat arbitrary.
    If you just want to visit all nodes in sorted order, use
    g_tree_foreach() instead. If you really need to visit nodes in
    a different order, consider using an [n-ary tree](data-structures.html#n-ary-trees).</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="traverse_func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call for each node visited. If this
  function returns %TRUE, the traversal is stopped.</doc>
            <type name="TraverseFunc" c:type="GTraverseFunc"/>
          </parameter>
          <parameter name="traverse_type" transfer-ownership="none">
            <doc xml:space="preserve">the order in which nodes are visited, one of %G_IN_ORDER,
  %G_PRE_ORDER and %G_POST_ORDER</doc>
            <type name="TraverseType" c:type="GTraverseType"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_tree_unref" version="2.22">
        <doc xml:space="preserve">Decrements the reference count of @tree by one.
If the reference count drops to 0, all keys and values will
be destroyed (if destroy functions were specified) and all
memory allocated by @tree will be released.

It is safe to call this function from any thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="upper_bound" c:identifier="g_tree_upper_bound" version="2.68">
        <doc xml:space="preserve">Gets the upper bound node corresponding to the given key,
or %NULL if the tree is empty or all the nodes in the tree
have keys that are lower than or equal to the searched key.

The upper bound is the first node that has its key strictly greater
than the searched key.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the tree node corresponding to the
         upper bound, or %NULL if the tree is empty or has only keys
         lower than or equal to the searched key.</doc>
          <type name="TreeNode" c:type="GTreeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree</doc>
            <type name="Tree" c:type="GTree*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the key to calculate the upper bound for</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="TreeNode" c:type="GTreeNode" disguised="1" opaque="1" version="2.68">
      <doc xml:space="preserve">An opaque type which identifies a specific node in a #GTree.</doc>
      <method name="key" c:identifier="g_tree_node_key" version="2.68">
        <doc xml:space="preserve">Gets the key stored at a particular tree node.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the key at the node.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree node</doc>
            <type name="TreeNode" c:type="GTreeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="g_tree_node_next" version="2.68">
        <doc xml:space="preserve">Returns the next in-order node of the tree, or %NULL
if the passed node was already the last one.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the next node in the tree</doc>
          <type name="TreeNode" c:type="GTreeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree node</doc>
            <type name="TreeNode" c:type="GTreeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="previous" c:identifier="g_tree_node_previous" version="2.68">
        <doc xml:space="preserve">Returns the previous in-order node of the tree, or %NULL
if the passed node was already the first one.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the previous node in the tree</doc>
          <type name="TreeNode" c:type="GTreeNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree node</doc>
            <type name="TreeNode" c:type="GTreeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="value" c:identifier="g_tree_node_value" version="2.68">
        <doc xml:space="preserve">Gets the value stored at a particular tree node.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the value at the node.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GTree node</doc>
            <type name="TreeNode" c:type="GTreeNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Tuples" c:type="GTuples" deprecated="1" deprecated-version="2.26">
      <doc xml:space="preserve">The #GTuples struct is used to return records (or tuples) from the
#GRelation by g_relation_select(). It only contains one public
member - the number of records that matched. To access the matched
records, you must use g_tuples_index().</doc>
      <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
      <field name="len" writable="1">
        <doc xml:space="preserve">the number of records that matched.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <method name="destroy" c:identifier="g_tuples_destroy" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Frees the records which were returned by g_relation_select(). This
should always be called after g_relation_select() when you are
finished with the records. The records are not removed from the
#GRelation.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tuples" transfer-ownership="none">
            <doc xml:space="preserve">the tuple data to free.</doc>
            <type name="Tuples" c:type="GTuples*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="index" c:identifier="g_tuples_index" deprecated="1" deprecated-version="2.26">
        <doc xml:space="preserve">Gets a field from the records returned by g_relation_select(). It
returns the given field of the record at the given index. The
returned value should not be changed.</doc>
        <doc-deprecated xml:space="preserve">Rarely used API</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the field of the record.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="tuples" transfer-ownership="none">
            <doc xml:space="preserve">the tuple data, returned by g_relation_select().</doc>
            <type name="Tuples" c:type="GTuples*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the record.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="field" transfer-ownership="none">
            <doc xml:space="preserve">the field to return.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <function-macro name="UNAVAILABLE" c:identifier="GLIB_UNAVAILABLE" introspectable="0">
      <parameters>
        <parameter name="maj">
        </parameter>
        <parameter name="min">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="UNAVAILABLE_ENUMERATOR" c:identifier="GLIB_UNAVAILABLE_ENUMERATOR" introspectable="0">
      <parameters>
        <parameter name="maj">
        </parameter>
        <parameter name="min">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="UNAVAILABLE_MACRO" c:identifier="GLIB_UNAVAILABLE_MACRO" introspectable="0">
      <parameters>
        <parameter name="maj">
        </parameter>
        <parameter name="min">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="UNAVAILABLE_STATIC_INLINE" c:identifier="GLIB_UNAVAILABLE_STATIC_INLINE" introspectable="0">
      <parameters>
        <parameter name="maj">
        </parameter>
        <parameter name="min">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="UNAVAILABLE_TYPE" c:identifier="GLIB_UNAVAILABLE_TYPE" introspectable="0">
      <parameters>
        <parameter name="maj">
        </parameter>
        <parameter name="min">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="UNICHAR_MAX_DECOMPOSITION_LENGTH" value="18" c:type="G_UNICHAR_MAX_DECOMPOSITION_LENGTH" version="2.32">
      <doc xml:space="preserve">The maximum length (in codepoints) of a compatibility or canonical
decomposition of a single Unicode character.

This is as defined by Unicode 6.1.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="UNLIKELY" c:identifier="G_UNLIKELY" version="2.2" introspectable="0">
      <doc xml:space="preserve">Hints the compiler that the expression is unlikely to evaluate to
a true value. The compiler may use this information for optimizations.

|[&lt;!-- language="C" --&gt;
if (G_UNLIKELY (random () == 1))
  g_print ("a random one");
]|</doc>
      <parameters>
        <parameter name="expr">
          <doc xml:space="preserve">the expression</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="UNLOCK" c:identifier="G_UNLOCK" introspectable="0">
      <doc xml:space="preserve">Works like g_mutex_unlock(), but for a lock defined with
%G_LOCK_DEFINE.</doc>
      <parameters>
        <parameter name="name">
          <doc xml:space="preserve">the name of the lock</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="URI_RESERVED_CHARS_GENERIC_DELIMITERS" value=":/?#[]@" c:type="G_URI_RESERVED_CHARS_GENERIC_DELIMITERS" version="2.16">
      <doc xml:space="preserve">Generic delimiters characters as defined in
[RFC 3986](https://tools.ietf.org/html/rfc3986). Includes `:/?#[]@`.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS" value="!$&amp;'()*+,;=" c:type="G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS" version="2.16">
      <doc xml:space="preserve">Subcomponent delimiter characters as defined in
[RFC 3986](https://tools.ietf.org/html/rfc3986). Includes `!$&amp;'()*+,;=`.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="USEC_PER_SEC" value="1000000" c:type="G_USEC_PER_SEC">
      <doc xml:space="preserve">Number of microseconds in one second (1 million).
This macro is provided for code readability.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="UnicodeBreakType" glib:type-name="GUnicodeBreakType" glib:get-type="g_unicode_break_type_get_type" c:type="GUnicodeBreakType">
      <doc xml:space="preserve">These are the possible line break classifications.

Since new Unicode versions may add new types here, applications should be ready
to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.

See [Unicode Line Breaking Algorithm](https://www.unicode.org/reports/tr14/).</doc>
      <member name="mandatory" value="0" c:identifier="G_UNICODE_BREAK_MANDATORY" glib:nick="mandatory" glib:name="G_UNICODE_BREAK_MANDATORY">
        <doc xml:space="preserve">Mandatory Break (BK)</doc>
      </member>
      <member name="carriage_return" value="1" c:identifier="G_UNICODE_BREAK_CARRIAGE_RETURN" glib:nick="carriage-return" glib:name="G_UNICODE_BREAK_CARRIAGE_RETURN">
        <doc xml:space="preserve">Carriage Return (CR)</doc>
      </member>
      <member name="line_feed" value="2" c:identifier="G_UNICODE_BREAK_LINE_FEED" glib:nick="line-feed" glib:name="G_UNICODE_BREAK_LINE_FEED">
        <doc xml:space="preserve">Line Feed (LF)</doc>
      </member>
      <member name="combining_mark" value="3" c:identifier="G_UNICODE_BREAK_COMBINING_MARK" glib:nick="combining-mark" glib:name="G_UNICODE_BREAK_COMBINING_MARK">
        <doc xml:space="preserve">Attached Characters and Combining Marks (CM)</doc>
      </member>
      <member name="surrogate" value="4" c:identifier="G_UNICODE_BREAK_SURROGATE" glib:nick="surrogate" glib:name="G_UNICODE_BREAK_SURROGATE">
        <doc xml:space="preserve">Surrogates (SG)</doc>
      </member>
      <member name="zero_width_space" value="5" c:identifier="G_UNICODE_BREAK_ZERO_WIDTH_SPACE" glib:nick="zero-width-space" glib:name="G_UNICODE_BREAK_ZERO_WIDTH_SPACE">
        <doc xml:space="preserve">Zero Width Space (ZW)</doc>
      </member>
      <member name="inseparable" value="6" c:identifier="G_UNICODE_BREAK_INSEPARABLE" glib:nick="inseparable" glib:name="G_UNICODE_BREAK_INSEPARABLE">
        <doc xml:space="preserve">Inseparable (IN)</doc>
      </member>
      <member name="non_breaking_glue" value="7" c:identifier="G_UNICODE_BREAK_NON_BREAKING_GLUE" glib:nick="non-breaking-glue" glib:name="G_UNICODE_BREAK_NON_BREAKING_GLUE">
        <doc xml:space="preserve">Non-breaking ("Glue") (GL)</doc>
      </member>
      <member name="contingent" value="8" c:identifier="G_UNICODE_BREAK_CONTINGENT" glib:nick="contingent" glib:name="G_UNICODE_BREAK_CONTINGENT">
        <doc xml:space="preserve">Contingent Break Opportunity (CB)</doc>
      </member>
      <member name="space" value="9" c:identifier="G_UNICODE_BREAK_SPACE" glib:nick="space" glib:name="G_UNICODE_BREAK_SPACE">
        <doc xml:space="preserve">Space (SP)</doc>
      </member>
      <member name="after" value="10" c:identifier="G_UNICODE_BREAK_AFTER" glib:nick="after" glib:name="G_UNICODE_BREAK_AFTER">
        <doc xml:space="preserve">Break Opportunity After (BA)</doc>
      </member>
      <member name="before" value="11" c:identifier="G_UNICODE_BREAK_BEFORE" glib:nick="before" glib:name="G_UNICODE_BREAK_BEFORE">
        <doc xml:space="preserve">Break Opportunity Before (BB)</doc>
      </member>
      <member name="before_and_after" value="12" c:identifier="G_UNICODE_BREAK_BEFORE_AND_AFTER" glib:nick="before-and-after" glib:name="G_UNICODE_BREAK_BEFORE_AND_AFTER">
        <doc xml:space="preserve">Break Opportunity Before and After (B2)</doc>
      </member>
      <member name="hyphen" value="13" c:identifier="G_UNICODE_BREAK_HYPHEN" glib:nick="hyphen" glib:name="G_UNICODE_BREAK_HYPHEN">
        <doc xml:space="preserve">Hyphen (HY)</doc>
      </member>
      <member name="non_starter" value="14" c:identifier="G_UNICODE_BREAK_NON_STARTER" glib:nick="non-starter" glib:name="G_UNICODE_BREAK_NON_STARTER">
        <doc xml:space="preserve">Nonstarter (NS)</doc>
      </member>
      <member name="open_punctuation" value="15" c:identifier="G_UNICODE_BREAK_OPEN_PUNCTUATION" glib:nick="open-punctuation" glib:name="G_UNICODE_BREAK_OPEN_PUNCTUATION">
        <doc xml:space="preserve">Opening Punctuation (OP)</doc>
      </member>
      <member name="close_punctuation" value="16" c:identifier="G_UNICODE_BREAK_CLOSE_PUNCTUATION" glib:nick="close-punctuation" glib:name="G_UNICODE_BREAK_CLOSE_PUNCTUATION">
        <doc xml:space="preserve">Closing Punctuation (CL)</doc>
      </member>
      <member name="quotation" value="17" c:identifier="G_UNICODE_BREAK_QUOTATION" glib:nick="quotation" glib:name="G_UNICODE_BREAK_QUOTATION">
        <doc xml:space="preserve">Ambiguous Quotation (QU)</doc>
      </member>
      <member name="exclamation" value="18" c:identifier="G_UNICODE_BREAK_EXCLAMATION" glib:nick="exclamation" glib:name="G_UNICODE_BREAK_EXCLAMATION">
        <doc xml:space="preserve">Exclamation/Interrogation (EX)</doc>
      </member>
      <member name="ideographic" value="19" c:identifier="G_UNICODE_BREAK_IDEOGRAPHIC" glib:nick="ideographic" glib:name="G_UNICODE_BREAK_IDEOGRAPHIC">
        <doc xml:space="preserve">Ideographic (ID)</doc>
      </member>
      <member name="numeric" value="20" c:identifier="G_UNICODE_BREAK_NUMERIC" glib:nick="numeric" glib:name="G_UNICODE_BREAK_NUMERIC">
        <doc xml:space="preserve">Numeric (NU)</doc>
      </member>
      <member name="infix_separator" value="21" c:identifier="G_UNICODE_BREAK_INFIX_SEPARATOR" glib:nick="infix-separator" glib:name="G_UNICODE_BREAK_INFIX_SEPARATOR">
        <doc xml:space="preserve">Infix Separator (Numeric) (IS)</doc>
      </member>
      <member name="symbol" value="22" c:identifier="G_UNICODE_BREAK_SYMBOL" glib:nick="symbol" glib:name="G_UNICODE_BREAK_SYMBOL">
        <doc xml:space="preserve">Symbols Allowing Break After (SY)</doc>
      </member>
      <member name="alphabetic" value="23" c:identifier="G_UNICODE_BREAK_ALPHABETIC" glib:nick="alphabetic" glib:name="G_UNICODE_BREAK_ALPHABETIC">
        <doc xml:space="preserve">Ordinary Alphabetic and Symbol Characters (AL)</doc>
      </member>
      <member name="prefix" value="24" c:identifier="G_UNICODE_BREAK_PREFIX" glib:nick="prefix" glib:name="G_UNICODE_BREAK_PREFIX">
        <doc xml:space="preserve">Prefix (Numeric) (PR)</doc>
      </member>
      <member name="postfix" value="25" c:identifier="G_UNICODE_BREAK_POSTFIX" glib:nick="postfix" glib:name="G_UNICODE_BREAK_POSTFIX">
        <doc xml:space="preserve">Postfix (Numeric) (PO)</doc>
      </member>
      <member name="complex_context" value="26" c:identifier="G_UNICODE_BREAK_COMPLEX_CONTEXT" glib:nick="complex-context" glib:name="G_UNICODE_BREAK_COMPLEX_CONTEXT">
        <doc xml:space="preserve">Complex Content Dependent (South East Asian) (SA)</doc>
      </member>
      <member name="ambiguous" value="27" c:identifier="G_UNICODE_BREAK_AMBIGUOUS" glib:nick="ambiguous" glib:name="G_UNICODE_BREAK_AMBIGUOUS">
        <doc xml:space="preserve">Ambiguous (Alphabetic or Ideographic) (AI)</doc>
      </member>
      <member name="unknown" value="28" c:identifier="G_UNICODE_BREAK_UNKNOWN" glib:nick="unknown" glib:name="G_UNICODE_BREAK_UNKNOWN">
        <doc xml:space="preserve">Unknown (XX)</doc>
      </member>
      <member name="next_line" value="29" c:identifier="G_UNICODE_BREAK_NEXT_LINE" glib:nick="next-line" glib:name="G_UNICODE_BREAK_NEXT_LINE">
        <doc xml:space="preserve">Next Line (NL)</doc>
      </member>
      <member name="word_joiner" value="30" c:identifier="G_UNICODE_BREAK_WORD_JOINER" glib:nick="word-joiner" glib:name="G_UNICODE_BREAK_WORD_JOINER">
        <doc xml:space="preserve">Word Joiner (WJ)</doc>
      </member>
      <member name="hangul_l_jamo" value="31" c:identifier="G_UNICODE_BREAK_HANGUL_L_JAMO" glib:nick="hangul-l-jamo" glib:name="G_UNICODE_BREAK_HANGUL_L_JAMO">
        <doc xml:space="preserve">Hangul L Jamo (JL)</doc>
      </member>
      <member name="hangul_v_jamo" value="32" c:identifier="G_UNICODE_BREAK_HANGUL_V_JAMO" glib:nick="hangul-v-jamo" glib:name="G_UNICODE_BREAK_HANGUL_V_JAMO">
        <doc xml:space="preserve">Hangul V Jamo (JV)</doc>
      </member>
      <member name="hangul_t_jamo" value="33" c:identifier="G_UNICODE_BREAK_HANGUL_T_JAMO" glib:nick="hangul-t-jamo" glib:name="G_UNICODE_BREAK_HANGUL_T_JAMO">
        <doc xml:space="preserve">Hangul T Jamo (JT)</doc>
      </member>
      <member name="hangul_lv_syllable" value="34" c:identifier="G_UNICODE_BREAK_HANGUL_LV_SYLLABLE" glib:nick="hangul-lv-syllable" glib:name="G_UNICODE_BREAK_HANGUL_LV_SYLLABLE">
        <doc xml:space="preserve">Hangul LV Syllable (H2)</doc>
      </member>
      <member name="hangul_lvt_syllable" value="35" c:identifier="G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE" glib:nick="hangul-lvt-syllable" glib:name="G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE">
        <doc xml:space="preserve">Hangul LVT Syllable (H3)</doc>
      </member>
      <member name="close_paranthesis" value="36" c:identifier="G_UNICODE_BREAK_CLOSE_PARANTHESIS" glib:nick="close-paranthesis" glib:name="G_UNICODE_BREAK_CLOSE_PARANTHESIS">
        <doc xml:space="preserve">Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use %G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.</doc>
      </member>
      <member name="close_parenthesis" value="36" c:identifier="G_UNICODE_BREAK_CLOSE_PARENTHESIS" glib:nick="close-parenthesis" glib:name="G_UNICODE_BREAK_CLOSE_PARENTHESIS">
        <doc xml:space="preserve">Closing Parenthesis (CP). Since 2.70</doc>
      </member>
      <member name="conditional_japanese_starter" value="37" c:identifier="G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER" glib:nick="conditional-japanese-starter" glib:name="G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER">
        <doc xml:space="preserve">Conditional Japanese Starter (CJ). Since: 2.32</doc>
      </member>
      <member name="hebrew_letter" value="38" c:identifier="G_UNICODE_BREAK_HEBREW_LETTER" glib:nick="hebrew-letter" glib:name="G_UNICODE_BREAK_HEBREW_LETTER">
        <doc xml:space="preserve">Hebrew Letter (HL). Since: 2.32</doc>
      </member>
      <member name="regional_indicator" value="39" c:identifier="G_UNICODE_BREAK_REGIONAL_INDICATOR" glib:nick="regional-indicator" glib:name="G_UNICODE_BREAK_REGIONAL_INDICATOR">
        <doc xml:space="preserve">Regional Indicator (RI). Since: 2.36</doc>
      </member>
      <member name="emoji_base" value="40" c:identifier="G_UNICODE_BREAK_EMOJI_BASE" glib:nick="emoji-base" glib:name="G_UNICODE_BREAK_EMOJI_BASE">
        <doc xml:space="preserve">Emoji Base (EB). Since: 2.50</doc>
      </member>
      <member name="emoji_modifier" value="41" c:identifier="G_UNICODE_BREAK_EMOJI_MODIFIER" glib:nick="emoji-modifier" glib:name="G_UNICODE_BREAK_EMOJI_MODIFIER">
        <doc xml:space="preserve">Emoji Modifier (EM). Since: 2.50</doc>
      </member>
      <member name="zero_width_joiner" value="42" c:identifier="G_UNICODE_BREAK_ZERO_WIDTH_JOINER" glib:nick="zero-width-joiner" glib:name="G_UNICODE_BREAK_ZERO_WIDTH_JOINER">
        <doc xml:space="preserve">Zero Width Joiner (ZWJ). Since: 2.50</doc>
      </member>
      <member name="aksara" value="43" c:identifier="G_UNICODE_BREAK_AKSARA" glib:nick="aksara" glib:name="G_UNICODE_BREAK_AKSARA">
        <doc xml:space="preserve">Aksara (AK). Since: 2.80</doc>
      </member>
      <member name="aksara_pre_base" value="44" c:identifier="G_UNICODE_BREAK_AKSARA_PRE_BASE" glib:nick="aksara-pre-base" glib:name="G_UNICODE_BREAK_AKSARA_PRE_BASE">
        <doc xml:space="preserve">Aksara Pre-Base (AP). Since: 2.80</doc>
      </member>
      <member name="aksara_start" value="45" c:identifier="G_UNICODE_BREAK_AKSARA_START" glib:nick="aksara-start" glib:name="G_UNICODE_BREAK_AKSARA_START">
        <doc xml:space="preserve">Aksara Start (AS). Since: 2.80</doc>
      </member>
      <member name="virama_final" value="46" c:identifier="G_UNICODE_BREAK_VIRAMA_FINAL" glib:nick="virama-final" glib:name="G_UNICODE_BREAK_VIRAMA_FINAL">
        <doc xml:space="preserve">Virama Final (VF). Since: 2.80</doc>
      </member>
      <member name="virama" value="47" c:identifier="G_UNICODE_BREAK_VIRAMA" glib:nick="virama" glib:name="G_UNICODE_BREAK_VIRAMA">
        <doc xml:space="preserve">Virama (VI). Since: 2.80</doc>
      </member>
      <member name="unambiguous_hyphen" value="48" c:identifier="G_UNICODE_BREAK_UNAMBIGUOUS_HYPHEN" glib:nick="unambiguous-hyphen" glib:name="G_UNICODE_BREAK_UNAMBIGUOUS_HYPHEN">
        <doc xml:space="preserve">Unambiguous Hyphen (HH). Since: 2.88</doc>
      </member>
    </enumeration>
    <enumeration name="UnicodeScript" glib:type-name="GUnicodeScript" glib:get-type="g_unicode_script_get_type" c:type="GUnicodeScript">
      <doc xml:space="preserve">The #GUnicodeScript enumeration identifies different writing
systems. The values correspond to the names as defined in the
Unicode standard. The enumeration has been added in GLib 2.14,
and is interchangeable with #PangoScript.

Note that new types may be added in the future. Applications
should be ready to handle unknown values.
See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/).</doc>
      <member name="invalid_code" value="-1" c:identifier="G_UNICODE_SCRIPT_INVALID_CODE" glib:nick="invalid-code" glib:name="G_UNICODE_SCRIPT_INVALID_CODE">
        <doc xml:space="preserve">a value never returned from g_unichar_get_script()</doc>
      </member>
      <member name="common" value="0" c:identifier="G_UNICODE_SCRIPT_COMMON" glib:nick="common" glib:name="G_UNICODE_SCRIPT_COMMON">
        <doc xml:space="preserve">a character used by multiple different scripts</doc>
      </member>
      <member name="inherited" value="1" c:identifier="G_UNICODE_SCRIPT_INHERITED" glib:nick="inherited" glib:name="G_UNICODE_SCRIPT_INHERITED">
        <doc xml:space="preserve">a mark glyph that takes its script from the
                              base glyph to which it is attached</doc>
      </member>
      <member name="arabic" value="2" c:identifier="G_UNICODE_SCRIPT_ARABIC" glib:nick="arabic" glib:name="G_UNICODE_SCRIPT_ARABIC">
        <doc xml:space="preserve">Arabic</doc>
      </member>
      <member name="armenian" value="3" c:identifier="G_UNICODE_SCRIPT_ARMENIAN" glib:nick="armenian" glib:name="G_UNICODE_SCRIPT_ARMENIAN">
        <doc xml:space="preserve">Armenian</doc>
      </member>
      <member name="bengali" value="4" c:identifier="G_UNICODE_SCRIPT_BENGALI" glib:nick="bengali" glib:name="G_UNICODE_SCRIPT_BENGALI">
        <doc xml:space="preserve">Bengali</doc>
      </member>
      <member name="bopomofo" value="5" c:identifier="G_UNICODE_SCRIPT_BOPOMOFO" glib:nick="bopomofo" glib:name="G_UNICODE_SCRIPT_BOPOMOFO">
        <doc xml:space="preserve">Bopomofo</doc>
      </member>
      <member name="cherokee" value="6" c:identifier="G_UNICODE_SCRIPT_CHEROKEE" glib:nick="cherokee" glib:name="G_UNICODE_SCRIPT_CHEROKEE">
        <doc xml:space="preserve">Cherokee</doc>
      </member>
      <member name="coptic" value="7" c:identifier="G_UNICODE_SCRIPT_COPTIC" glib:nick="coptic" glib:name="G_UNICODE_SCRIPT_COPTIC">
        <doc xml:space="preserve">Coptic</doc>
      </member>
      <member name="cyrillic" value="8" c:identifier="G_UNICODE_SCRIPT_CYRILLIC" glib:nick="cyrillic" glib:name="G_UNICODE_SCRIPT_CYRILLIC">
        <doc xml:space="preserve">Cyrillic</doc>
      </member>
      <member name="deseret" value="9" c:identifier="G_UNICODE_SCRIPT_DESERET" glib:nick="deseret" glib:name="G_UNICODE_SCRIPT_DESERET">
        <doc xml:space="preserve">Deseret</doc>
      </member>
      <member name="devanagari" value="10" c:identifier="G_UNICODE_SCRIPT_DEVANAGARI" glib:nick="devanagari" glib:name="G_UNICODE_SCRIPT_DEVANAGARI">
        <doc xml:space="preserve">Devanagari</doc>
      </member>
      <member name="ethiopic" value="11" c:identifier="G_UNICODE_SCRIPT_ETHIOPIC" glib:nick="ethiopic" glib:name="G_UNICODE_SCRIPT_ETHIOPIC">
        <doc xml:space="preserve">Ethiopic</doc>
      </member>
      <member name="georgian" value="12" c:identifier="G_UNICODE_SCRIPT_GEORGIAN" glib:nick="georgian" glib:name="G_UNICODE_SCRIPT_GEORGIAN">
        <doc xml:space="preserve">Georgian</doc>
      </member>
      <member name="gothic" value="13" c:identifier="G_UNICODE_SCRIPT_GOTHIC" glib:nick="gothic" glib:name="G_UNICODE_SCRIPT_GOTHIC">
        <doc xml:space="preserve">Gothic</doc>
      </member>
      <member name="greek" value="14" c:identifier="G_UNICODE_SCRIPT_GREEK" glib:nick="greek" glib:name="G_UNICODE_SCRIPT_GREEK">
        <doc xml:space="preserve">Greek</doc>
      </member>
      <member name="gujarati" value="15" c:identifier="G_UNICODE_SCRIPT_GUJARATI" glib:nick="gujarati" glib:name="G_UNICODE_SCRIPT_GUJARATI">
        <doc xml:space="preserve">Gujarati</doc>
      </member>
      <member name="gurmukhi" value="16" c:identifier="G_UNICODE_SCRIPT_GURMUKHI" glib:nick="gurmukhi" glib:name="G_UNICODE_SCRIPT_GURMUKHI">
        <doc xml:space="preserve">Gurmukhi</doc>
      </member>
      <member name="han" value="17" c:identifier="G_UNICODE_SCRIPT_HAN" glib:nick="han" glib:name="G_UNICODE_SCRIPT_HAN">
        <doc xml:space="preserve">Han</doc>
      </member>
      <member name="hangul" value="18" c:identifier="G_UNICODE_SCRIPT_HANGUL" glib:nick="hangul" glib:name="G_UNICODE_SCRIPT_HANGUL">
        <doc xml:space="preserve">Hangul</doc>
      </member>
      <member name="hebrew" value="19" c:identifier="G_UNICODE_SCRIPT_HEBREW" glib:nick="hebrew" glib:name="G_UNICODE_SCRIPT_HEBREW">
        <doc xml:space="preserve">Hebrew</doc>
      </member>
      <member name="hiragana" value="20" c:identifier="G_UNICODE_SCRIPT_HIRAGANA" glib:nick="hiragana" glib:name="G_UNICODE_SCRIPT_HIRAGANA">
        <doc xml:space="preserve">Hiragana</doc>
      </member>
      <member name="kannada" value="21" c:identifier="G_UNICODE_SCRIPT_KANNADA" glib:nick="kannada" glib:name="G_UNICODE_SCRIPT_KANNADA">
        <doc xml:space="preserve">Kannada</doc>
      </member>
      <member name="katakana" value="22" c:identifier="G_UNICODE_SCRIPT_KATAKANA" glib:nick="katakana" glib:name="G_UNICODE_SCRIPT_KATAKANA">
        <doc xml:space="preserve">Katakana</doc>
      </member>
      <member name="khmer" value="23" c:identifier="G_UNICODE_SCRIPT_KHMER" glib:nick="khmer" glib:name="G_UNICODE_SCRIPT_KHMER">
        <doc xml:space="preserve">Khmer</doc>
      </member>
      <member name="lao" value="24" c:identifier="G_UNICODE_SCRIPT_LAO" glib:nick="lao" glib:name="G_UNICODE_SCRIPT_LAO">
        <doc xml:space="preserve">Lao</doc>
      </member>
      <member name="latin" value="25" c:identifier="G_UNICODE_SCRIPT_LATIN" glib:nick="latin" glib:name="G_UNICODE_SCRIPT_LATIN">
        <doc xml:space="preserve">Latin</doc>
      </member>
      <member name="malayalam" value="26" c:identifier="G_UNICODE_SCRIPT_MALAYALAM" glib:nick="malayalam" glib:name="G_UNICODE_SCRIPT_MALAYALAM">
        <doc xml:space="preserve">Malayalam</doc>
      </member>
      <member name="mongolian" value="27" c:identifier="G_UNICODE_SCRIPT_MONGOLIAN" glib:nick="mongolian" glib:name="G_UNICODE_SCRIPT_MONGOLIAN">
        <doc xml:space="preserve">Mongolian</doc>
      </member>
      <member name="myanmar" value="28" c:identifier="G_UNICODE_SCRIPT_MYANMAR" glib:nick="myanmar" glib:name="G_UNICODE_SCRIPT_MYANMAR">
        <doc xml:space="preserve">Myanmar</doc>
      </member>
      <member name="ogham" value="29" c:identifier="G_UNICODE_SCRIPT_OGHAM" glib:nick="ogham" glib:name="G_UNICODE_SCRIPT_OGHAM">
        <doc xml:space="preserve">Ogham</doc>
      </member>
      <member name="old_italic" value="30" c:identifier="G_UNICODE_SCRIPT_OLD_ITALIC" glib:nick="old-italic" glib:name="G_UNICODE_SCRIPT_OLD_ITALIC">
        <doc xml:space="preserve">Old Italic</doc>
      </member>
      <member name="oriya" value="31" c:identifier="G_UNICODE_SCRIPT_ORIYA" glib:nick="oriya" glib:name="G_UNICODE_SCRIPT_ORIYA">
        <doc xml:space="preserve">Oriya</doc>
      </member>
      <member name="runic" value="32" c:identifier="G_UNICODE_SCRIPT_RUNIC" glib:nick="runic" glib:name="G_UNICODE_SCRIPT_RUNIC">
        <doc xml:space="preserve">Runic</doc>
      </member>
      <member name="sinhala" value="33" c:identifier="G_UNICODE_SCRIPT_SINHALA" glib:nick="sinhala" glib:name="G_UNICODE_SCRIPT_SINHALA">
        <doc xml:space="preserve">Sinhala</doc>
      </member>
      <member name="syriac" value="34" c:identifier="G_UNICODE_SCRIPT_SYRIAC" glib:nick="syriac" glib:name="G_UNICODE_SCRIPT_SYRIAC">
        <doc xml:space="preserve">Syriac</doc>
      </member>
      <member name="tamil" value="35" c:identifier="G_UNICODE_SCRIPT_TAMIL" glib:nick="tamil" glib:name="G_UNICODE_SCRIPT_TAMIL">
        <doc xml:space="preserve">Tamil</doc>
      </member>
      <member name="telugu" value="36" c:identifier="G_UNICODE_SCRIPT_TELUGU" glib:nick="telugu" glib:name="G_UNICODE_SCRIPT_TELUGU">
        <doc xml:space="preserve">Telugu</doc>
      </member>
      <member name="thaana" value="37" c:identifier="G_UNICODE_SCRIPT_THAANA" glib:nick="thaana" glib:name="G_UNICODE_SCRIPT_THAANA">
        <doc xml:space="preserve">Thaana</doc>
      </member>
      <member name="thai" value="38" c:identifier="G_UNICODE_SCRIPT_THAI" glib:nick="thai" glib:name="G_UNICODE_SCRIPT_THAI">
        <doc xml:space="preserve">Thai</doc>
      </member>
      <member name="tibetan" value="39" c:identifier="G_UNICODE_SCRIPT_TIBETAN" glib:nick="tibetan" glib:name="G_UNICODE_SCRIPT_TIBETAN">
        <doc xml:space="preserve">Tibetan</doc>
      </member>
      <member name="canadian_aboriginal" value="40" c:identifier="G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL" glib:nick="canadian-aboriginal" glib:name="G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL">
        <doc xml:space="preserve">Canadian Aboriginal</doc>
      </member>
      <member name="yi" value="41" c:identifier="G_UNICODE_SCRIPT_YI" glib:nick="yi" glib:name="G_UNICODE_SCRIPT_YI">
        <doc xml:space="preserve">Yi</doc>
      </member>
      <member name="tagalog" value="42" c:identifier="G_UNICODE_SCRIPT_TAGALOG" glib:nick="tagalog" glib:name="G_UNICODE_SCRIPT_TAGALOG">
        <doc xml:space="preserve">Tagalog</doc>
      </member>
      <member name="hanunoo" value="43" c:identifier="G_UNICODE_SCRIPT_HANUNOO" glib:nick="hanunoo" glib:name="G_UNICODE_SCRIPT_HANUNOO">
        <doc xml:space="preserve">Hanunoo</doc>
      </member>
      <member name="buhid" value="44" c:identifier="G_UNICODE_SCRIPT_BUHID" glib:nick="buhid" glib:name="G_UNICODE_SCRIPT_BUHID">
        <doc xml:space="preserve">Buhid</doc>
      </member>
      <member name="tagbanwa" value="45" c:identifier="G_UNICODE_SCRIPT_TAGBANWA" glib:nick="tagbanwa" glib:name="G_UNICODE_SCRIPT_TAGBANWA">
        <doc xml:space="preserve">Tagbanwa</doc>
      </member>
      <member name="braille" value="46" c:identifier="G_UNICODE_SCRIPT_BRAILLE" glib:nick="braille" glib:name="G_UNICODE_SCRIPT_BRAILLE">
        <doc xml:space="preserve">Braille</doc>
      </member>
      <member name="cypriot" value="47" c:identifier="G_UNICODE_SCRIPT_CYPRIOT" glib:nick="cypriot" glib:name="G_UNICODE_SCRIPT_CYPRIOT">
        <doc xml:space="preserve">Cypriot</doc>
      </member>
      <member name="limbu" value="48" c:identifier="G_UNICODE_SCRIPT_LIMBU" glib:nick="limbu" glib:name="G_UNICODE_SCRIPT_LIMBU">
        <doc xml:space="preserve">Limbu</doc>
      </member>
      <member name="osmanya" value="49" c:identifier="G_UNICODE_SCRIPT_OSMANYA" glib:nick="osmanya" glib:name="G_UNICODE_SCRIPT_OSMANYA">
        <doc xml:space="preserve">Osmanya</doc>
      </member>
      <member name="shavian" value="50" c:identifier="G_UNICODE_SCRIPT_SHAVIAN" glib:nick="shavian" glib:name="G_UNICODE_SCRIPT_SHAVIAN">
        <doc xml:space="preserve">Shavian</doc>
      </member>
      <member name="linear_b" value="51" c:identifier="G_UNICODE_SCRIPT_LINEAR_B" glib:nick="linear-b" glib:name="G_UNICODE_SCRIPT_LINEAR_B">
        <doc xml:space="preserve">Linear B</doc>
      </member>
      <member name="tai_le" value="52" c:identifier="G_UNICODE_SCRIPT_TAI_LE" glib:nick="tai-le" glib:name="G_UNICODE_SCRIPT_TAI_LE">
        <doc xml:space="preserve">Tai Le</doc>
      </member>
      <member name="ugaritic" value="53" c:identifier="G_UNICODE_SCRIPT_UGARITIC" glib:nick="ugaritic" glib:name="G_UNICODE_SCRIPT_UGARITIC">
        <doc xml:space="preserve">Ugaritic</doc>
      </member>
      <member name="new_tai_lue" value="54" c:identifier="G_UNICODE_SCRIPT_NEW_TAI_LUE" glib:nick="new-tai-lue" glib:name="G_UNICODE_SCRIPT_NEW_TAI_LUE">
        <doc xml:space="preserve">New Tai Lue</doc>
      </member>
      <member name="buginese" value="55" c:identifier="G_UNICODE_SCRIPT_BUGINESE" glib:nick="buginese" glib:name="G_UNICODE_SCRIPT_BUGINESE">
        <doc xml:space="preserve">Buginese</doc>
      </member>
      <member name="glagolitic" value="56" c:identifier="G_UNICODE_SCRIPT_GLAGOLITIC" glib:nick="glagolitic" glib:name="G_UNICODE_SCRIPT_GLAGOLITIC">
        <doc xml:space="preserve">Glagolitic</doc>
      </member>
      <member name="tifinagh" value="57" c:identifier="G_UNICODE_SCRIPT_TIFINAGH" glib:nick="tifinagh" glib:name="G_UNICODE_SCRIPT_TIFINAGH">
        <doc xml:space="preserve">Tifinagh</doc>
      </member>
      <member name="syloti_nagri" value="58" c:identifier="G_UNICODE_SCRIPT_SYLOTI_NAGRI" glib:nick="syloti-nagri" glib:name="G_UNICODE_SCRIPT_SYLOTI_NAGRI">
        <doc xml:space="preserve">Syloti Nagri</doc>
      </member>
      <member name="old_persian" value="59" c:identifier="G_UNICODE_SCRIPT_OLD_PERSIAN" glib:nick="old-persian" glib:name="G_UNICODE_SCRIPT_OLD_PERSIAN">
        <doc xml:space="preserve">Old Persian</doc>
      </member>
      <member name="kharoshthi" value="60" c:identifier="G_UNICODE_SCRIPT_KHAROSHTHI" glib:nick="kharoshthi" glib:name="G_UNICODE_SCRIPT_KHAROSHTHI">
        <doc xml:space="preserve">Kharoshthi</doc>
      </member>
      <member name="unknown" value="61" c:identifier="G_UNICODE_SCRIPT_UNKNOWN" glib:nick="unknown" glib:name="G_UNICODE_SCRIPT_UNKNOWN">
        <doc xml:space="preserve">an unassigned code point</doc>
      </member>
      <member name="balinese" value="62" c:identifier="G_UNICODE_SCRIPT_BALINESE" glib:nick="balinese" glib:name="G_UNICODE_SCRIPT_BALINESE">
        <doc xml:space="preserve">Balinese</doc>
      </member>
      <member name="cuneiform" value="63" c:identifier="G_UNICODE_SCRIPT_CUNEIFORM" glib:nick="cuneiform" glib:name="G_UNICODE_SCRIPT_CUNEIFORM">
        <doc xml:space="preserve">Cuneiform</doc>
      </member>
      <member name="phoenician" value="64" c:identifier="G_UNICODE_SCRIPT_PHOENICIAN" glib:nick="phoenician" glib:name="G_UNICODE_SCRIPT_PHOENICIAN">
        <doc xml:space="preserve">Phoenician</doc>
      </member>
      <member name="phags_pa" value="65" c:identifier="G_UNICODE_SCRIPT_PHAGS_PA" glib:nick="phags-pa" glib:name="G_UNICODE_SCRIPT_PHAGS_PA">
        <doc xml:space="preserve">Phags-pa</doc>
      </member>
      <member name="nko" value="66" c:identifier="G_UNICODE_SCRIPT_NKO" glib:nick="nko" glib:name="G_UNICODE_SCRIPT_NKO">
        <doc xml:space="preserve">N'Ko</doc>
      </member>
      <member name="kayah_li" value="67" c:identifier="G_UNICODE_SCRIPT_KAYAH_LI" glib:nick="kayah-li" glib:name="G_UNICODE_SCRIPT_KAYAH_LI">
        <doc xml:space="preserve">Kayah Li. Since 2.16.3</doc>
      </member>
      <member name="lepcha" value="68" c:identifier="G_UNICODE_SCRIPT_LEPCHA" glib:nick="lepcha" glib:name="G_UNICODE_SCRIPT_LEPCHA">
        <doc xml:space="preserve">Lepcha. Since 2.16.3</doc>
      </member>
      <member name="rejang" value="69" c:identifier="G_UNICODE_SCRIPT_REJANG" glib:nick="rejang" glib:name="G_UNICODE_SCRIPT_REJANG">
        <doc xml:space="preserve">Rejang. Since 2.16.3</doc>
      </member>
      <member name="sundanese" value="70" c:identifier="G_UNICODE_SCRIPT_SUNDANESE" glib:nick="sundanese" glib:name="G_UNICODE_SCRIPT_SUNDANESE">
        <doc xml:space="preserve">Sundanese. Since 2.16.3</doc>
      </member>
      <member name="saurashtra" value="71" c:identifier="G_UNICODE_SCRIPT_SAURASHTRA" glib:nick="saurashtra" glib:name="G_UNICODE_SCRIPT_SAURASHTRA">
        <doc xml:space="preserve">Saurashtra. Since 2.16.3</doc>
      </member>
      <member name="cham" value="72" c:identifier="G_UNICODE_SCRIPT_CHAM" glib:nick="cham" glib:name="G_UNICODE_SCRIPT_CHAM">
        <doc xml:space="preserve">Cham. Since 2.16.3</doc>
      </member>
      <member name="ol_chiki" value="73" c:identifier="G_UNICODE_SCRIPT_OL_CHIKI" glib:nick="ol-chiki" glib:name="G_UNICODE_SCRIPT_OL_CHIKI">
        <doc xml:space="preserve">Ol Chiki. Since 2.16.3</doc>
      </member>
      <member name="vai" value="74" c:identifier="G_UNICODE_SCRIPT_VAI" glib:nick="vai" glib:name="G_UNICODE_SCRIPT_VAI">
        <doc xml:space="preserve">Vai. Since 2.16.3</doc>
      </member>
      <member name="carian" value="75" c:identifier="G_UNICODE_SCRIPT_CARIAN" glib:nick="carian" glib:name="G_UNICODE_SCRIPT_CARIAN">
        <doc xml:space="preserve">Carian. Since 2.16.3</doc>
      </member>
      <member name="lycian" value="76" c:identifier="G_UNICODE_SCRIPT_LYCIAN" glib:nick="lycian" glib:name="G_UNICODE_SCRIPT_LYCIAN">
        <doc xml:space="preserve">Lycian. Since 2.16.3</doc>
      </member>
      <member name="lydian" value="77" c:identifier="G_UNICODE_SCRIPT_LYDIAN" glib:nick="lydian" glib:name="G_UNICODE_SCRIPT_LYDIAN">
        <doc xml:space="preserve">Lydian. Since 2.16.3</doc>
      </member>
      <member name="avestan" value="78" c:identifier="G_UNICODE_SCRIPT_AVESTAN" glib:nick="avestan" glib:name="G_UNICODE_SCRIPT_AVESTAN">
        <doc xml:space="preserve">Avestan. Since 2.26</doc>
      </member>
      <member name="bamum" value="79" c:identifier="G_UNICODE_SCRIPT_BAMUM" glib:nick="bamum" glib:name="G_UNICODE_SCRIPT_BAMUM">
        <doc xml:space="preserve">Bamum. Since 2.26</doc>
      </member>
      <member name="egyptian_hieroglyphs" value="80" c:identifier="G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS" glib:nick="egyptian-hieroglyphs" glib:name="G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS">
        <doc xml:space="preserve">Egyptian Hieroglpyhs. Since 2.26</doc>
      </member>
      <member name="imperial_aramaic" value="81" c:identifier="G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC" glib:nick="imperial-aramaic" glib:name="G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC">
        <doc xml:space="preserve">Imperial Aramaic. Since 2.26</doc>
      </member>
      <member name="inscriptional_pahlavi" value="82" c:identifier="G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI" glib:nick="inscriptional-pahlavi" glib:name="G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI">
        <doc xml:space="preserve">Inscriptional Pahlavi. Since 2.26</doc>
      </member>
      <member name="inscriptional_parthian" value="83" c:identifier="G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN" glib:nick="inscriptional-parthian" glib:name="G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN">
        <doc xml:space="preserve">Inscriptional Parthian. Since 2.26</doc>
      </member>
      <member name="javanese" value="84" c:identifier="G_UNICODE_SCRIPT_JAVANESE" glib:nick="javanese" glib:name="G_UNICODE_SCRIPT_JAVANESE">
        <doc xml:space="preserve">Javanese. Since 2.26</doc>
      </member>
      <member name="kaithi" value="85" c:identifier="G_UNICODE_SCRIPT_KAITHI" glib:nick="kaithi" glib:name="G_UNICODE_SCRIPT_KAITHI">
        <doc xml:space="preserve">Kaithi. Since 2.26</doc>
      </member>
      <member name="lisu" value="86" c:identifier="G_UNICODE_SCRIPT_LISU" glib:nick="lisu" glib:name="G_UNICODE_SCRIPT_LISU">
        <doc xml:space="preserve">Lisu. Since 2.26</doc>
      </member>
      <member name="meetei_mayek" value="87" c:identifier="G_UNICODE_SCRIPT_MEETEI_MAYEK" glib:nick="meetei-mayek" glib:name="G_UNICODE_SCRIPT_MEETEI_MAYEK">
        <doc xml:space="preserve">Meetei Mayek. Since 2.26</doc>
      </member>
      <member name="old_south_arabian" value="88" c:identifier="G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN" glib:nick="old-south-arabian" glib:name="G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN">
        <doc xml:space="preserve">Old South Arabian. Since 2.26</doc>
      </member>
      <member name="old_turkic" value="89" c:identifier="G_UNICODE_SCRIPT_OLD_TURKIC" glib:nick="old-turkic" glib:name="G_UNICODE_SCRIPT_OLD_TURKIC">
        <doc xml:space="preserve">Old Turkic. Since 2.28</doc>
      </member>
      <member name="samaritan" value="90" c:identifier="G_UNICODE_SCRIPT_SAMARITAN" glib:nick="samaritan" glib:name="G_UNICODE_SCRIPT_SAMARITAN">
        <doc xml:space="preserve">Samaritan. Since 2.26</doc>
      </member>
      <member name="tai_tham" value="91" c:identifier="G_UNICODE_SCRIPT_TAI_THAM" glib:nick="tai-tham" glib:name="G_UNICODE_SCRIPT_TAI_THAM">
        <doc xml:space="preserve">Tai Tham. Since 2.26</doc>
      </member>
      <member name="tai_viet" value="92" c:identifier="G_UNICODE_SCRIPT_TAI_VIET" glib:nick="tai-viet" glib:name="G_UNICODE_SCRIPT_TAI_VIET">
        <doc xml:space="preserve">Tai Viet. Since 2.26</doc>
      </member>
      <member name="batak" value="93" c:identifier="G_UNICODE_SCRIPT_BATAK" glib:nick="batak" glib:name="G_UNICODE_SCRIPT_BATAK">
        <doc xml:space="preserve">Batak. Since 2.28</doc>
      </member>
      <member name="brahmi" value="94" c:identifier="G_UNICODE_SCRIPT_BRAHMI" glib:nick="brahmi" glib:name="G_UNICODE_SCRIPT_BRAHMI">
        <doc xml:space="preserve">Brahmi. Since 2.28</doc>
      </member>
      <member name="mandaic" value="95" c:identifier="G_UNICODE_SCRIPT_MANDAIC" glib:nick="mandaic" glib:name="G_UNICODE_SCRIPT_MANDAIC">
        <doc xml:space="preserve">Mandaic. Since 2.28</doc>
      </member>
      <member name="chakma" value="96" c:identifier="G_UNICODE_SCRIPT_CHAKMA" glib:nick="chakma" glib:name="G_UNICODE_SCRIPT_CHAKMA">
        <doc xml:space="preserve">Chakma. Since: 2.32</doc>
      </member>
      <member name="meroitic_cursive" value="97" c:identifier="G_UNICODE_SCRIPT_MEROITIC_CURSIVE" glib:nick="meroitic-cursive" glib:name="G_UNICODE_SCRIPT_MEROITIC_CURSIVE">
        <doc xml:space="preserve">Meroitic Cursive. Since: 2.32</doc>
      </member>
      <member name="meroitic_hieroglyphs" value="98" c:identifier="G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS" glib:nick="meroitic-hieroglyphs" glib:name="G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS">
        <doc xml:space="preserve">Meroitic Hieroglyphs. Since: 2.32</doc>
      </member>
      <member name="miao" value="99" c:identifier="G_UNICODE_SCRIPT_MIAO" glib:nick="miao" glib:name="G_UNICODE_SCRIPT_MIAO">
        <doc xml:space="preserve">Miao. Since: 2.32</doc>
      </member>
      <member name="sharada" value="100" c:identifier="G_UNICODE_SCRIPT_SHARADA" glib:nick="sharada" glib:name="G_UNICODE_SCRIPT_SHARADA">
        <doc xml:space="preserve">Sharada. Since: 2.32</doc>
      </member>
      <member name="sora_sompeng" value="101" c:identifier="G_UNICODE_SCRIPT_SORA_SOMPENG" glib:nick="sora-sompeng" glib:name="G_UNICODE_SCRIPT_SORA_SOMPENG">
        <doc xml:space="preserve">Sora Sompeng. Since: 2.32</doc>
      </member>
      <member name="takri" value="102" c:identifier="G_UNICODE_SCRIPT_TAKRI" glib:nick="takri" glib:name="G_UNICODE_SCRIPT_TAKRI">
        <doc xml:space="preserve">Takri. Since: 2.32</doc>
      </member>
      <member name="bassa_vah" value="103" c:identifier="G_UNICODE_SCRIPT_BASSA_VAH" glib:nick="bassa-vah" glib:name="G_UNICODE_SCRIPT_BASSA_VAH">
        <doc xml:space="preserve">Bassa. Since: 2.42</doc>
      </member>
      <member name="caucasian_albanian" value="104" c:identifier="G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN" glib:nick="caucasian-albanian" glib:name="G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN">
        <doc xml:space="preserve">Caucasian Albanian. Since: 2.42</doc>
      </member>
      <member name="duployan" value="105" c:identifier="G_UNICODE_SCRIPT_DUPLOYAN" glib:nick="duployan" glib:name="G_UNICODE_SCRIPT_DUPLOYAN">
        <doc xml:space="preserve">Duployan. Since: 2.42</doc>
      </member>
      <member name="elbasan" value="106" c:identifier="G_UNICODE_SCRIPT_ELBASAN" glib:nick="elbasan" glib:name="G_UNICODE_SCRIPT_ELBASAN">
        <doc xml:space="preserve">Elbasan. Since: 2.42</doc>
      </member>
      <member name="grantha" value="107" c:identifier="G_UNICODE_SCRIPT_GRANTHA" glib:nick="grantha" glib:name="G_UNICODE_SCRIPT_GRANTHA">
        <doc xml:space="preserve">Grantha. Since: 2.42</doc>
      </member>
      <member name="khojki" value="108" c:identifier="G_UNICODE_SCRIPT_KHOJKI" glib:nick="khojki" glib:name="G_UNICODE_SCRIPT_KHOJKI">
        <doc xml:space="preserve">Kjohki. Since: 2.42</doc>
      </member>
      <member name="khudawadi" value="109" c:identifier="G_UNICODE_SCRIPT_KHUDAWADI" glib:nick="khudawadi" glib:name="G_UNICODE_SCRIPT_KHUDAWADI">
        <doc xml:space="preserve">Khudawadi, Sindhi. Since: 2.42</doc>
      </member>
      <member name="linear_a" value="110" c:identifier="G_UNICODE_SCRIPT_LINEAR_A" glib:nick="linear-a" glib:name="G_UNICODE_SCRIPT_LINEAR_A">
        <doc xml:space="preserve">Linear A. Since: 2.42</doc>
      </member>
      <member name="mahajani" value="111" c:identifier="G_UNICODE_SCRIPT_MAHAJANI" glib:nick="mahajani" glib:name="G_UNICODE_SCRIPT_MAHAJANI">
        <doc xml:space="preserve">Mahajani. Since: 2.42</doc>
      </member>
      <member name="manichaean" value="112" c:identifier="G_UNICODE_SCRIPT_MANICHAEAN" glib:nick="manichaean" glib:name="G_UNICODE_SCRIPT_MANICHAEAN">
        <doc xml:space="preserve">Manichaean. Since: 2.42</doc>
      </member>
      <member name="mende_kikakui" value="113" c:identifier="G_UNICODE_SCRIPT_MENDE_KIKAKUI" glib:nick="mende-kikakui" glib:name="G_UNICODE_SCRIPT_MENDE_KIKAKUI">
        <doc xml:space="preserve">Mende Kikakui. Since: 2.42</doc>
      </member>
      <member name="modi" value="114" c:identifier="G_UNICODE_SCRIPT_MODI" glib:nick="modi" glib:name="G_UNICODE_SCRIPT_MODI">
        <doc xml:space="preserve">Modi. Since: 2.42</doc>
      </member>
      <member name="mro" value="115" c:identifier="G_UNICODE_SCRIPT_MRO" glib:nick="mro" glib:name="G_UNICODE_SCRIPT_MRO">
        <doc xml:space="preserve">Mro. Since: 2.42</doc>
      </member>
      <member name="nabataean" value="116" c:identifier="G_UNICODE_SCRIPT_NABATAEAN" glib:nick="nabataean" glib:name="G_UNICODE_SCRIPT_NABATAEAN">
        <doc xml:space="preserve">Nabataean. Since: 2.42</doc>
      </member>
      <member name="old_north_arabian" value="117" c:identifier="G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN" glib:nick="old-north-arabian" glib:name="G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN">
        <doc xml:space="preserve">Old North Arabian. Since: 2.42</doc>
      </member>
      <member name="old_permic" value="118" c:identifier="G_UNICODE_SCRIPT_OLD_PERMIC" glib:nick="old-permic" glib:name="G_UNICODE_SCRIPT_OLD_PERMIC">
        <doc xml:space="preserve">Old Permic. Since: 2.42</doc>
      </member>
      <member name="pahawh_hmong" value="119" c:identifier="G_UNICODE_SCRIPT_PAHAWH_HMONG" glib:nick="pahawh-hmong" glib:name="G_UNICODE_SCRIPT_PAHAWH_HMONG">
        <doc xml:space="preserve">Pahawh Hmong. Since: 2.42</doc>
      </member>
      <member name="palmyrene" value="120" c:identifier="G_UNICODE_SCRIPT_PALMYRENE" glib:nick="palmyrene" glib:name="G_UNICODE_SCRIPT_PALMYRENE">
        <doc xml:space="preserve">Palmyrene. Since: 2.42</doc>
      </member>
      <member name="pau_cin_hau" value="121" c:identifier="G_UNICODE_SCRIPT_PAU_CIN_HAU" glib:nick="pau-cin-hau" glib:name="G_UNICODE_SCRIPT_PAU_CIN_HAU">
        <doc xml:space="preserve">Pau Cin Hau. Since: 2.42</doc>
      </member>
      <member name="psalter_pahlavi" value="122" c:identifier="G_UNICODE_SCRIPT_PSALTER_PAHLAVI" glib:nick="psalter-pahlavi" glib:name="G_UNICODE_SCRIPT_PSALTER_PAHLAVI">
        <doc xml:space="preserve">Psalter Pahlavi. Since: 2.42</doc>
      </member>
      <member name="siddham" value="123" c:identifier="G_UNICODE_SCRIPT_SIDDHAM" glib:nick="siddham" glib:name="G_UNICODE_SCRIPT_SIDDHAM">
        <doc xml:space="preserve">Siddham. Since: 2.42</doc>
      </member>
      <member name="tirhuta" value="124" c:identifier="G_UNICODE_SCRIPT_TIRHUTA" glib:nick="tirhuta" glib:name="G_UNICODE_SCRIPT_TIRHUTA">
        <doc xml:space="preserve">Tirhuta. Since: 2.42</doc>
      </member>
      <member name="warang_citi" value="125" c:identifier="G_UNICODE_SCRIPT_WARANG_CITI" glib:nick="warang-citi" glib:name="G_UNICODE_SCRIPT_WARANG_CITI">
        <doc xml:space="preserve">Warang Citi. Since: 2.42</doc>
      </member>
      <member name="ahom" value="126" c:identifier="G_UNICODE_SCRIPT_AHOM" glib:nick="ahom" glib:name="G_UNICODE_SCRIPT_AHOM">
        <doc xml:space="preserve">Ahom. Since: 2.48</doc>
      </member>
      <member name="anatolian_hieroglyphs" value="127" c:identifier="G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS" glib:nick="anatolian-hieroglyphs" glib:name="G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS">
        <doc xml:space="preserve">Anatolian Hieroglyphs. Since: 2.48</doc>
      </member>
      <member name="hatran" value="128" c:identifier="G_UNICODE_SCRIPT_HATRAN" glib:nick="hatran" glib:name="G_UNICODE_SCRIPT_HATRAN">
        <doc xml:space="preserve">Hatran. Since: 2.48</doc>
      </member>
      <member name="multani" value="129" c:identifier="G_UNICODE_SCRIPT_MULTANI" glib:nick="multani" glib:name="G_UNICODE_SCRIPT_MULTANI">
        <doc xml:space="preserve">Multani. Since: 2.48</doc>
      </member>
      <member name="old_hungarian" value="130" c:identifier="G_UNICODE_SCRIPT_OLD_HUNGARIAN" glib:nick="old-hungarian" glib:name="G_UNICODE_SCRIPT_OLD_HUNGARIAN">
        <doc xml:space="preserve">Old Hungarian. Since: 2.48</doc>
      </member>
      <member name="signwriting" value="131" c:identifier="G_UNICODE_SCRIPT_SIGNWRITING" glib:nick="signwriting" glib:name="G_UNICODE_SCRIPT_SIGNWRITING">
        <doc xml:space="preserve">Signwriting. Since: 2.48</doc>
      </member>
      <member name="adlam" value="132" c:identifier="G_UNICODE_SCRIPT_ADLAM" glib:nick="adlam" glib:name="G_UNICODE_SCRIPT_ADLAM">
        <doc xml:space="preserve">Adlam. Since: 2.50</doc>
      </member>
      <member name="bhaiksuki" value="133" c:identifier="G_UNICODE_SCRIPT_BHAIKSUKI" glib:nick="bhaiksuki" glib:name="G_UNICODE_SCRIPT_BHAIKSUKI">
        <doc xml:space="preserve">Bhaiksuki. Since: 2.50</doc>
      </member>
      <member name="marchen" value="134" c:identifier="G_UNICODE_SCRIPT_MARCHEN" glib:nick="marchen" glib:name="G_UNICODE_SCRIPT_MARCHEN">
        <doc xml:space="preserve">Marchen. Since: 2.50</doc>
      </member>
      <member name="newa" value="135" c:identifier="G_UNICODE_SCRIPT_NEWA" glib:nick="newa" glib:name="G_UNICODE_SCRIPT_NEWA">
        <doc xml:space="preserve">Newa. Since: 2.50</doc>
      </member>
      <member name="osage" value="136" c:identifier="G_UNICODE_SCRIPT_OSAGE" glib:nick="osage" glib:name="G_UNICODE_SCRIPT_OSAGE">
        <doc xml:space="preserve">Osage. Since: 2.50</doc>
      </member>
      <member name="tangut" value="137" c:identifier="G_UNICODE_SCRIPT_TANGUT" glib:nick="tangut" glib:name="G_UNICODE_SCRIPT_TANGUT">
        <doc xml:space="preserve">Tangut. Since: 2.50</doc>
      </member>
      <member name="masaram_gondi" value="138" c:identifier="G_UNICODE_SCRIPT_MASARAM_GONDI" glib:nick="masaram-gondi" glib:name="G_UNICODE_SCRIPT_MASARAM_GONDI">
        <doc xml:space="preserve">Masaram Gondi. Since: 2.54</doc>
      </member>
      <member name="nushu" value="139" c:identifier="G_UNICODE_SCRIPT_NUSHU" glib:nick="nushu" glib:name="G_UNICODE_SCRIPT_NUSHU">
        <doc xml:space="preserve">Nushu. Since: 2.54</doc>
      </member>
      <member name="soyombo" value="140" c:identifier="G_UNICODE_SCRIPT_SOYOMBO" glib:nick="soyombo" glib:name="G_UNICODE_SCRIPT_SOYOMBO">
        <doc xml:space="preserve">Soyombo. Since: 2.54</doc>
      </member>
      <member name="zanabazar_square" value="141" c:identifier="G_UNICODE_SCRIPT_ZANABAZAR_SQUARE" glib:nick="zanabazar-square" glib:name="G_UNICODE_SCRIPT_ZANABAZAR_SQUARE">
        <doc xml:space="preserve">Zanabazar Square. Since: 2.54</doc>
      </member>
      <member name="dogra" value="142" c:identifier="G_UNICODE_SCRIPT_DOGRA" glib:nick="dogra" glib:name="G_UNICODE_SCRIPT_DOGRA">
        <doc xml:space="preserve">Dogra. Since: 2.58</doc>
      </member>
      <member name="gunjala_gondi" value="143" c:identifier="G_UNICODE_SCRIPT_GUNJALA_GONDI" glib:nick="gunjala-gondi" glib:name="G_UNICODE_SCRIPT_GUNJALA_GONDI">
        <doc xml:space="preserve">Gunjala Gondi. Since: 2.58</doc>
      </member>
      <member name="hanifi_rohingya" value="144" c:identifier="G_UNICODE_SCRIPT_HANIFI_ROHINGYA" glib:nick="hanifi-rohingya" glib:name="G_UNICODE_SCRIPT_HANIFI_ROHINGYA">
        <doc xml:space="preserve">Hanifi Rohingya. Since: 2.58</doc>
      </member>
      <member name="makasar" value="145" c:identifier="G_UNICODE_SCRIPT_MAKASAR" glib:nick="makasar" glib:name="G_UNICODE_SCRIPT_MAKASAR">
        <doc xml:space="preserve">Makasar. Since: 2.58</doc>
      </member>
      <member name="medefaidrin" value="146" c:identifier="G_UNICODE_SCRIPT_MEDEFAIDRIN" glib:nick="medefaidrin" glib:name="G_UNICODE_SCRIPT_MEDEFAIDRIN">
        <doc xml:space="preserve">Medefaidrin. Since: 2.58</doc>
      </member>
      <member name="old_sogdian" value="147" c:identifier="G_UNICODE_SCRIPT_OLD_SOGDIAN" glib:nick="old-sogdian" glib:name="G_UNICODE_SCRIPT_OLD_SOGDIAN">
        <doc xml:space="preserve">Old Sogdian. Since: 2.58</doc>
      </member>
      <member name="sogdian" value="148" c:identifier="G_UNICODE_SCRIPT_SOGDIAN" glib:nick="sogdian" glib:name="G_UNICODE_SCRIPT_SOGDIAN">
        <doc xml:space="preserve">Sogdian. Since: 2.58</doc>
      </member>
      <member name="elymaic" value="149" c:identifier="G_UNICODE_SCRIPT_ELYMAIC" glib:nick="elymaic" glib:name="G_UNICODE_SCRIPT_ELYMAIC">
        <doc xml:space="preserve">Elym. Since: 2.62</doc>
      </member>
      <member name="nandinagari" value="150" c:identifier="G_UNICODE_SCRIPT_NANDINAGARI" glib:nick="nandinagari" glib:name="G_UNICODE_SCRIPT_NANDINAGARI">
        <doc xml:space="preserve">Nand. Since: 2.62</doc>
      </member>
      <member name="nyiakeng_puachue_hmong" value="151" c:identifier="G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG" glib:nick="nyiakeng-puachue-hmong" glib:name="G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG">
        <doc xml:space="preserve">Rohg. Since: 2.62</doc>
      </member>
      <member name="wancho" value="152" c:identifier="G_UNICODE_SCRIPT_WANCHO" glib:nick="wancho" glib:name="G_UNICODE_SCRIPT_WANCHO">
        <doc xml:space="preserve">Wcho. Since: 2.62</doc>
      </member>
      <member name="chorasmian" value="153" c:identifier="G_UNICODE_SCRIPT_CHORASMIAN" glib:nick="chorasmian" glib:name="G_UNICODE_SCRIPT_CHORASMIAN">
        <doc xml:space="preserve">Chorasmian. Since: 2.66</doc>
      </member>
      <member name="dives_akuru" value="154" c:identifier="G_UNICODE_SCRIPT_DIVES_AKURU" glib:nick="dives-akuru" glib:name="G_UNICODE_SCRIPT_DIVES_AKURU">
        <doc xml:space="preserve">Dives Akuru. Since: 2.66</doc>
      </member>
      <member name="khitan_small_script" value="155" c:identifier="G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT" glib:nick="khitan-small-script" glib:name="G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT">
        <doc xml:space="preserve">Khitan small script. Since: 2.66</doc>
      </member>
      <member name="yezidi" value="156" c:identifier="G_UNICODE_SCRIPT_YEZIDI" glib:nick="yezidi" glib:name="G_UNICODE_SCRIPT_YEZIDI">
        <doc xml:space="preserve">Yezidi. Since: 2.66</doc>
      </member>
      <member name="cypro_minoan" value="157" c:identifier="G_UNICODE_SCRIPT_CYPRO_MINOAN" glib:nick="cypro-minoan" glib:name="G_UNICODE_SCRIPT_CYPRO_MINOAN">
        <doc xml:space="preserve">Cypro-Minoan. Since: 2.72</doc>
      </member>
      <member name="old_uyghur" value="158" c:identifier="G_UNICODE_SCRIPT_OLD_UYGHUR" glib:nick="old-uyghur" glib:name="G_UNICODE_SCRIPT_OLD_UYGHUR">
        <doc xml:space="preserve">Old Uyghur. Since: 2.72</doc>
      </member>
      <member name="tangsa" value="159" c:identifier="G_UNICODE_SCRIPT_TANGSA" glib:nick="tangsa" glib:name="G_UNICODE_SCRIPT_TANGSA">
        <doc xml:space="preserve">Tangsa. Since: 2.72</doc>
      </member>
      <member name="toto" value="160" c:identifier="G_UNICODE_SCRIPT_TOTO" glib:nick="toto" glib:name="G_UNICODE_SCRIPT_TOTO">
        <doc xml:space="preserve">Toto. Since: 2.72</doc>
      </member>
      <member name="vithkuqi" value="161" c:identifier="G_UNICODE_SCRIPT_VITHKUQI" glib:nick="vithkuqi" glib:name="G_UNICODE_SCRIPT_VITHKUQI">
        <doc xml:space="preserve">Vithkuqi. Since: 2.72</doc>
      </member>
      <member name="math" value="162" c:identifier="G_UNICODE_SCRIPT_MATH" glib:nick="math" glib:name="G_UNICODE_SCRIPT_MATH">
        <doc xml:space="preserve">Mathematical notation. Since: 2.72</doc>
      </member>
      <member name="kawi" value="163" c:identifier="G_UNICODE_SCRIPT_KAWI" glib:nick="kawi" glib:name="G_UNICODE_SCRIPT_KAWI">
        <doc xml:space="preserve">Kawi. Since 2.74</doc>
      </member>
      <member name="nag_mundari" value="164" c:identifier="G_UNICODE_SCRIPT_NAG_MUNDARI" glib:nick="nag-mundari" glib:name="G_UNICODE_SCRIPT_NAG_MUNDARI">
        <doc xml:space="preserve">Nag Mundari. Since 2.74</doc>
      </member>
      <member name="todhri" value="165" c:identifier="G_UNICODE_SCRIPT_TODHRI" glib:nick="todhri" glib:name="G_UNICODE_SCRIPT_TODHRI">
        <doc xml:space="preserve">Todhri. Since: 2.84</doc>
      </member>
      <member name="garay" value="166" c:identifier="G_UNICODE_SCRIPT_GARAY" glib:nick="garay" glib:name="G_UNICODE_SCRIPT_GARAY">
        <doc xml:space="preserve">Garay. Since: 2.84</doc>
      </member>
      <member name="tulu_tigalari" value="167" c:identifier="G_UNICODE_SCRIPT_TULU_TIGALARI" glib:nick="tulu-tigalari" glib:name="G_UNICODE_SCRIPT_TULU_TIGALARI">
        <doc xml:space="preserve">Tulu-Tigalari. Since: 2.84</doc>
      </member>
      <member name="sunuwar" value="168" c:identifier="G_UNICODE_SCRIPT_SUNUWAR" glib:nick="sunuwar" glib:name="G_UNICODE_SCRIPT_SUNUWAR">
        <doc xml:space="preserve">Sunuwar. Since: 2.84</doc>
      </member>
      <member name="gurung_khema" value="169" c:identifier="G_UNICODE_SCRIPT_GURUNG_KHEMA" glib:nick="gurung-khema" glib:name="G_UNICODE_SCRIPT_GURUNG_KHEMA">
        <doc xml:space="preserve">Gurung Khema. Since: 2.84</doc>
      </member>
      <member name="kirat_rai" value="170" c:identifier="G_UNICODE_SCRIPT_KIRAT_RAI" glib:nick="kirat-rai" glib:name="G_UNICODE_SCRIPT_KIRAT_RAI">
        <doc xml:space="preserve">Kirat Rai. Since: 2.84</doc>
      </member>
      <member name="ol_onal" value="171" c:identifier="G_UNICODE_SCRIPT_OL_ONAL" glib:nick="ol-onal" glib:name="G_UNICODE_SCRIPT_OL_ONAL">
        <doc xml:space="preserve">Ol Onal. Since: 2.84</doc>
      </member>
      <member name="sidetic" value="172" c:identifier="G_UNICODE_SCRIPT_SIDETIC" glib:nick="sidetic" glib:name="G_UNICODE_SCRIPT_SIDETIC">
        <doc xml:space="preserve">Sidetic. Since: 2.88</doc>
      </member>
      <member name="tolong_siki" value="173" c:identifier="G_UNICODE_SCRIPT_TOLONG_SIKI" glib:nick="tolong-siki" glib:name="G_UNICODE_SCRIPT_TOLONG_SIKI">
        <doc xml:space="preserve">Tolong Siki. Since: 2.88</doc>
      </member>
      <member name="tai_yo" value="174" c:identifier="G_UNICODE_SCRIPT_TAI_YO" glib:nick="tai-yo" glib:name="G_UNICODE_SCRIPT_TAI_YO">
        <doc xml:space="preserve">Tai Yo. Since: 2.88</doc>
      </member>
      <member name="beria_erfe" value="175" c:identifier="G_UNICODE_SCRIPT_BERIA_ERFE" glib:nick="beria-erfe" glib:name="G_UNICODE_SCRIPT_BERIA_ERFE">
        <doc xml:space="preserve">Beria Erfe. Since: 2.88</doc>
      </member>
      <function name="from_iso15924" c:identifier="g_unicode_script_from_iso15924" version="2.30">
        <doc xml:space="preserve">Looks up the Unicode script for @iso15924.  ISO 15924 assigns four-letter
codes to scripts.  For example, the code for Arabic is 'Arab'.
This function accepts four letter codes encoded as a @guint32 in a
big-endian fashion.  That is, the code expected for Arabic is
0x41726162 (0x41 is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).

See
[Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Unicode script for @iso15924, or
  of %G_UNICODE_SCRIPT_INVALID_CODE if @iso15924 is zero and
  %G_UNICODE_SCRIPT_UNKNOWN if @iso15924 is unknown.</doc>
          <type name="UnicodeScript" c:type="GUnicodeScript"/>
        </return-value>
        <parameters>
          <parameter name="iso15924" transfer-ownership="none">
            <doc xml:space="preserve">a Unicode script</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_iso15924" c:identifier="g_unicode_script_to_iso15924" version="2.30">
        <doc xml:space="preserve">Looks up the ISO 15924 code for @script.  ISO 15924 assigns four-letter
codes to scripts.  For example, the code for Arabic is 'Arab'.  The
four letter codes are encoded as a @guint32 by this function in a
big-endian fashion.  That is, the code returned for Arabic is
0x41726162 (0x41 is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).

See
[Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ISO 15924 code for @script, encoded as an integer,
  of zero if @script is %G_UNICODE_SCRIPT_INVALID_CODE or
  ISO 15924 code 'Zzzz' (script code for UNKNOWN) if @script is not understood.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <parameter name="script" transfer-ownership="none">
            <doc xml:space="preserve">a Unicode script</doc>
            <type name="UnicodeScript" c:type="GUnicodeScript"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <enumeration name="UnicodeType" glib:type-name="GUnicodeType" glib:get-type="g_unicode_type_get_type" c:type="GUnicodeType">
      <doc xml:space="preserve">These are the possible character classifications from the
Unicode specification.
See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values).</doc>
      <member name="control" value="0" c:identifier="G_UNICODE_CONTROL" glib:nick="control" glib:name="G_UNICODE_CONTROL">
        <doc xml:space="preserve">General category "Other, Control" (Cc)</doc>
      </member>
      <member name="format" value="1" c:identifier="G_UNICODE_FORMAT" glib:nick="format" glib:name="G_UNICODE_FORMAT">
        <doc xml:space="preserve">General category "Other, Format" (Cf)</doc>
      </member>
      <member name="unassigned" value="2" c:identifier="G_UNICODE_UNASSIGNED" glib:nick="unassigned" glib:name="G_UNICODE_UNASSIGNED">
        <doc xml:space="preserve">General category "Other, Not Assigned" (Cn)</doc>
      </member>
      <member name="private_use" value="3" c:identifier="G_UNICODE_PRIVATE_USE" glib:nick="private-use" glib:name="G_UNICODE_PRIVATE_USE">
        <doc xml:space="preserve">General category "Other, Private Use" (Co)</doc>
      </member>
      <member name="surrogate" value="4" c:identifier="G_UNICODE_SURROGATE" glib:nick="surrogate" glib:name="G_UNICODE_SURROGATE">
        <doc xml:space="preserve">General category "Other, Surrogate" (Cs)</doc>
      </member>
      <member name="lowercase_letter" value="5" c:identifier="G_UNICODE_LOWERCASE_LETTER" glib:nick="lowercase-letter" glib:name="G_UNICODE_LOWERCASE_LETTER">
        <doc xml:space="preserve">General category "Letter, Lowercase" (Ll)</doc>
      </member>
      <member name="modifier_letter" value="6" c:identifier="G_UNICODE_MODIFIER_LETTER" glib:nick="modifier-letter" glib:name="G_UNICODE_MODIFIER_LETTER">
        <doc xml:space="preserve">General category "Letter, Modifier" (Lm)</doc>
      </member>
      <member name="other_letter" value="7" c:identifier="G_UNICODE_OTHER_LETTER" glib:nick="other-letter" glib:name="G_UNICODE_OTHER_LETTER">
        <doc xml:space="preserve">General category "Letter, Other" (Lo)</doc>
      </member>
      <member name="titlecase_letter" value="8" c:identifier="G_UNICODE_TITLECASE_LETTER" glib:nick="titlecase-letter" glib:name="G_UNICODE_TITLECASE_LETTER">
        <doc xml:space="preserve">General category "Letter, Titlecase" (Lt)</doc>
      </member>
      <member name="uppercase_letter" value="9" c:identifier="G_UNICODE_UPPERCASE_LETTER" glib:nick="uppercase-letter" glib:name="G_UNICODE_UPPERCASE_LETTER">
        <doc xml:space="preserve">General category "Letter, Uppercase" (Lu)</doc>
      </member>
      <member name="spacing_mark" value="10" c:identifier="G_UNICODE_SPACING_MARK" glib:nick="spacing-mark" glib:name="G_UNICODE_SPACING_MARK">
        <doc xml:space="preserve">General category "Mark, Spacing" (Mc)</doc>
      </member>
      <member name="enclosing_mark" value="11" c:identifier="G_UNICODE_ENCLOSING_MARK" glib:nick="enclosing-mark" glib:name="G_UNICODE_ENCLOSING_MARK">
        <doc xml:space="preserve">General category "Mark, Enclosing" (Me)</doc>
      </member>
      <member name="non_spacing_mark" value="12" c:identifier="G_UNICODE_NON_SPACING_MARK" glib:nick="non-spacing-mark" glib:name="G_UNICODE_NON_SPACING_MARK">
        <doc xml:space="preserve">General category "Mark, Nonspacing" (Mn)</doc>
      </member>
      <member name="decimal_number" value="13" c:identifier="G_UNICODE_DECIMAL_NUMBER" glib:nick="decimal-number" glib:name="G_UNICODE_DECIMAL_NUMBER">
        <doc xml:space="preserve">General category "Number, Decimal Digit" (Nd)</doc>
      </member>
      <member name="letter_number" value="14" c:identifier="G_UNICODE_LETTER_NUMBER" glib:nick="letter-number" glib:name="G_UNICODE_LETTER_NUMBER">
        <doc xml:space="preserve">General category "Number, Letter" (Nl)</doc>
      </member>
      <member name="other_number" value="15" c:identifier="G_UNICODE_OTHER_NUMBER" glib:nick="other-number" glib:name="G_UNICODE_OTHER_NUMBER">
        <doc xml:space="preserve">General category "Number, Other" (No)</doc>
      </member>
      <member name="connect_punctuation" value="16" c:identifier="G_UNICODE_CONNECT_PUNCTUATION" glib:nick="connect-punctuation" glib:name="G_UNICODE_CONNECT_PUNCTUATION">
        <doc xml:space="preserve">General category "Punctuation, Connector" (Pc)</doc>
      </member>
      <member name="dash_punctuation" value="17" c:identifier="G_UNICODE_DASH_PUNCTUATION" glib:nick="dash-punctuation" glib:name="G_UNICODE_DASH_PUNCTUATION">
        <doc xml:space="preserve">General category "Punctuation, Dash" (Pd)</doc>
      </member>
      <member name="close_punctuation" value="18" c:identifier="G_UNICODE_CLOSE_PUNCTUATION" glib:nick="close-punctuation" glib:name="G_UNICODE_CLOSE_PUNCTUATION">
        <doc xml:space="preserve">General category "Punctuation, Close" (Pe)</doc>
      </member>
      <member name="final_punctuation" value="19" c:identifier="G_UNICODE_FINAL_PUNCTUATION" glib:nick="final-punctuation" glib:name="G_UNICODE_FINAL_PUNCTUATION">
        <doc xml:space="preserve">General category "Punctuation, Final quote" (Pf)</doc>
      </member>
      <member name="initial_punctuation" value="20" c:identifier="G_UNICODE_INITIAL_PUNCTUATION" glib:nick="initial-punctuation" glib:name="G_UNICODE_INITIAL_PUNCTUATION">
        <doc xml:space="preserve">General category "Punctuation, Initial quote" (Pi)</doc>
      </member>
      <member name="other_punctuation" value="21" c:identifier="G_UNICODE_OTHER_PUNCTUATION" glib:nick="other-punctuation" glib:name="G_UNICODE_OTHER_PUNCTUATION">
        <doc xml:space="preserve">General category "Punctuation, Other" (Po)</doc>
      </member>
      <member name="open_punctuation" value="22" c:identifier="G_UNICODE_OPEN_PUNCTUATION" glib:nick="open-punctuation" glib:name="G_UNICODE_OPEN_PUNCTUATION">
        <doc xml:space="preserve">General category "Punctuation, Open" (Ps)</doc>
      </member>
      <member name="currency_symbol" value="23" c:identifier="G_UNICODE_CURRENCY_SYMBOL" glib:nick="currency-symbol" glib:name="G_UNICODE_CURRENCY_SYMBOL">
        <doc xml:space="preserve">General category "Symbol, Currency" (Sc)</doc>
      </member>
      <member name="modifier_symbol" value="24" c:identifier="G_UNICODE_MODIFIER_SYMBOL" glib:nick="modifier-symbol" glib:name="G_UNICODE_MODIFIER_SYMBOL">
        <doc xml:space="preserve">General category "Symbol, Modifier" (Sk)</doc>
      </member>
      <member name="math_symbol" value="25" c:identifier="G_UNICODE_MATH_SYMBOL" glib:nick="math-symbol" glib:name="G_UNICODE_MATH_SYMBOL">
        <doc xml:space="preserve">General category "Symbol, Math" (Sm)</doc>
      </member>
      <member name="other_symbol" value="26" c:identifier="G_UNICODE_OTHER_SYMBOL" glib:nick="other-symbol" glib:name="G_UNICODE_OTHER_SYMBOL">
        <doc xml:space="preserve">General category "Symbol, Other" (So)</doc>
      </member>
      <member name="line_separator" value="27" c:identifier="G_UNICODE_LINE_SEPARATOR" glib:nick="line-separator" glib:name="G_UNICODE_LINE_SEPARATOR">
        <doc xml:space="preserve">General category "Separator, Line" (Zl)</doc>
      </member>
      <member name="paragraph_separator" value="28" c:identifier="G_UNICODE_PARAGRAPH_SEPARATOR" glib:nick="paragraph-separator" glib:name="G_UNICODE_PARAGRAPH_SEPARATOR">
        <doc xml:space="preserve">General category "Separator, Paragraph" (Zp)</doc>
      </member>
      <member name="space_separator" value="29" c:identifier="G_UNICODE_SPACE_SEPARATOR" glib:nick="space-separator" glib:name="G_UNICODE_SPACE_SEPARATOR">
        <doc xml:space="preserve">General category "Separator, Space" (Zs)</doc>
      </member>
    </enumeration>
    <callback name="UnixFDSourceFunc" c:type="GUnixFDSourceFunc">
      <doc xml:space="preserve">The type of functions to be called when a UNIX fd watch source
triggers.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%FALSE if the source should be removed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">the fd that triggered the event</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">the IO conditions reported on @fd</doc>
          <type name="IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data passed to g_unix_fd_add()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="UnixPipe" c:type="GUnixPipe" version="2.80">
      <doc xml:space="preserve">A Unix pipe. The advantage of this type over `int[2]` is that it can
be closed automatically when it goes out of scope, using `g_auto(GUnixPipe)`,
on compilers that support that feature.</doc>
      <field name="fds" writable="1">
        <doc xml:space="preserve">A pair of file descriptors, each negative if closed or not yet opened.
 The file descriptor with index %G_UNIX_PIPE_END_READ is readable.
 The file descriptor with index %G_UNIX_PIPE_END_WRITE is writable.</doc>
        <array zero-terminated="0" fixed-size="2">
          <type name="gint" c:type="int"/>
        </array>
      </field>
      <method-inline name="clear" c:identifier="g_unix_pipe_clear" version="2.80" introspectable="0">
        <doc xml:space="preserve">Close both ends of the pipe, unless they have already been closed or
stolen. Any errors are ignored: use g_unix_pipe_close() or g_clear_fd()
if error-handling is required.

This function is async-signal safe if @error is %NULL and each member
of @fds are either negative or a valid open file descriptor.
As a result, it is safe to call this function or use `g_auto(GUnixPipe)`
(on compilers that support it) in a signal handler or a
#GSpawnChildSetupFunc, as long as those conditions are ensured to be true.
See [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7)) for more details.

This function preserves the value of `errno`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixPipe</doc>
            <type name="UnixPipe" c:type="GUnixPipe*"/>
          </instance-parameter>
        </parameters>
      </method-inline>
      <method-inline name="close" c:identifier="g_unix_pipe_close" version="2.80" introspectable="0" throws="1">
        <doc xml:space="preserve">Close one of the ends of the pipe and set the relevant member of @fds
to `-1` before returning, equivalent to g_clear_fd().

Like g_close(), if closing the file descriptor fails, the error is
stored in both %errno and @error. If this function succeeds,
%errno is undefined.

This function is async-signal safe if @error is %NULL and the relevant
member of @fds is either negative or a valid open file descriptor.
This makes it safe to call from a signal handler or a #GSpawnChildSetupFunc
under those conditions.
See [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7)) for more details.

To close both file descriptors and ignore any errors, use
g_unix_pipe_clear() instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A pair of file descriptors</doc>
            <type name="UnixPipe" c:type="GUnixPipe*"/>
          </instance-parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">One of the ends of the pipe</doc>
            <type name="UnixPipeEnd" c:type="GUnixPipeEnd"/>
          </parameter>
        </parameters>
      </method-inline>
      <method-inline name="get" c:identifier="g_unix_pipe_get" version="2.80" introspectable="0">
        <doc xml:space="preserve">Return one of the ends of the pipe. It remains owned by @self.

This function is async-signal safe (see [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7))), making it safe to call from a
signal handler or a #GSpawnChildSetupFunc.

This function preserves the value of `errno`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a non-negative file descriptor owned by @self, which must not
 be closed by the caller, or a negative number if the corresponding
 end of the pipe was already closed or stolen</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A pair of file descriptors</doc>
            <type name="UnixPipe" c:type="GUnixPipe*"/>
          </instance-parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">One of the ends of the pipe</doc>
            <type name="UnixPipeEnd" c:type="GUnixPipeEnd"/>
          </parameter>
        </parameters>
      </method-inline>
      <method-inline name="open" c:identifier="g_unix_pipe_open" version="2.80" introspectable="0" throws="1">
        <doc xml:space="preserve">Open a pipe. This is the same as g_unix_open_pipe(), but uses the
#GUnixPipe data structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A pair of file descriptors</doc>
            <type name="UnixPipe" c:type="GUnixPipe*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags to pass to g_unix_open_pipe(), typically `O_CLOEXEC`</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method-inline>
      <method-inline name="steal" c:identifier="g_unix_pipe_steal" version="2.80" introspectable="0">
        <doc xml:space="preserve">Return one of the ends of the pipe. It becomes owned by the caller,
and the file descriptor in the data structure is set to `-1`,
similar to g_steal_fd().

This function is async-signal safe (see [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7))), making it safe to call from a
signal handler or a #GSpawnChildSetupFunc.

This function preserves the value of `errno`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a non-negative file descriptor, which becomes owned by the
 caller and must be closed by the caller if required, or a negative
 number if the corresponding end of the pipe was already closed or stolen</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A pair of file descriptors</doc>
            <type name="UnixPipe" c:type="GUnixPipe*"/>
          </instance-parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">One of the ends of the pipe</doc>
            <type name="UnixPipeEnd" c:type="GUnixPipeEnd"/>
          </parameter>
        </parameters>
      </method-inline>
    </record>
    <enumeration name="UnixPipeEnd" version="2.80" c:type="GUnixPipeEnd">
      <doc xml:space="preserve">Mnemonic constants for the ends of a Unix pipe.</doc>
      <member name="read" value="0" c:identifier="G_UNIX_PIPE_END_READ">
        <doc xml:space="preserve">The readable file descriptor 0</doc>
      </member>
      <member name="write" value="1" c:identifier="G_UNIX_PIPE_END_WRITE">
        <doc xml:space="preserve">The writable file descriptor 1</doc>
      </member>
    </enumeration>
    <record name="Uri" c:type="GUri" opaque="1" version="2.66" glib:type-name="GUri" glib:get-type="g_uri_get_type" c:symbol-prefix="uri">
      <doc xml:space="preserve">The `GUri` type and related functions can be used to parse URIs into
their components, and build valid URIs from individual components.

Since `GUri` only represents absolute URIs, all `GUri`s will have a
URI scheme, so [method@GLib.Uri.get_scheme] will always return a non-`NULL`
answer. Likewise, by definition, all URIs have a path component, so
[method@GLib.Uri.get_path] will always return a non-`NULL` string (which may
be empty).

If the URI string has an
[&#x2018;authority&#x2019; component](https://tools.ietf.org/html/rfc3986#section-3) (that
is, if the scheme is followed by `://` rather than just `:`), then the
`GUri` will contain a hostname, and possibly a port and &#x2018;userinfo&#x2019;.
Additionally, depending on how the `GUri` was constructed/parsed (for example,
using the `G_URI_FLAGS_HAS_PASSWORD` and `G_URI_FLAGS_HAS_AUTH_PARAMS` flags),
the userinfo may be split out into a username, password, and
additional authorization-related parameters.

Normally, the components of a `GUri` will have all `%`-encoded
characters decoded. However, if you construct/parse a `GUri` with
`G_URI_FLAGS_ENCODED`, then the `%`-encoding will be preserved instead in
the userinfo, path, and query fields (and in the host field if also
created with `G_URI_FLAGS_NON_DNS`). In particular, this is necessary if
the URI may contain binary data or non-UTF-8 text, or if decoding
the components might change the interpretation of the URI.

For example, with the encoded flag:

```c
g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue", G_URI_FLAGS_ENCODED, &amp;err);
g_assert_cmpstr (g_uri_get_query (uri), ==, "query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue");
```

While the default `%`-decoding behaviour would give:

```c
g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http%3A%2F%2Fhost%2Fpath%3Fparam%3Dvalue", G_URI_FLAGS_NONE, &amp;err);
g_assert_cmpstr (g_uri_get_query (uri), ==, "query=http://host/path?param=value");
```

During decoding, if an invalid UTF-8 string is encountered, parsing will fail
with an error indicating the bad string location:

```c
g_autoptr(GUri) uri = g_uri_parse ("http://host/path?query=http%3A%2F%2Fhost%2Fpath%3Fbad%3D%00alue", G_URI_FLAGS_NONE, &amp;err);
g_assert_error (err, G_URI_ERROR, G_URI_ERROR_BAD_QUERY);
```

You should pass `G_URI_FLAGS_ENCODED` or `G_URI_FLAGS_ENCODED_QUERY` if you
need to handle that case manually. In particular, if the query string
contains `=` characters that are `%`-encoded, you should let
[func@GLib.Uri.parse_params] do the decoding once of the query.

`GUri` is immutable once constructed, and can safely be accessed from
multiple threads. Its reference counting is atomic.

Note that the scope of `GUri` is to help manipulate URIs in various applications,
following [RFC 3986](https://tools.ietf.org/html/rfc3986). In particular,
it doesn't intend to cover web browser needs, and doesn&#x2019;t implement the
[WHATWG URL](https://url.spec.whatwg.org/) standard. No APIs are provided to
help prevent
[homograph attacks](https://en.wikipedia.org/wiki/IDN_homograph_attack), so
`GUri` is not suitable for formatting URIs for display to the user for making
security-sensitive decisions.

## Relative and absolute URIs

As defined in [RFC 3986](https://tools.ietf.org/html/rfc3986#section-4), the
hierarchical nature of URIs means that they can either be &#x2018;relative
references&#x2019; (sometimes referred to as &#x2018;relative URIs&#x2019;) or &#x2018;URIs&#x2019; (for
clarity, &#x2018;URIs&#x2019; are referred to in this documentation as
&#x2018;absolute URIs&#x2019; &#x2014; although
[in contrast to RFC 3986](https://tools.ietf.org/html/rfc3986#section-4.3),
fragment identifiers are always allowed).

Relative references have one or more components of the URI missing. In
particular, they have no scheme. Any other component, such as hostname,
query, etc. may be missing, apart from a path, which has to be specified (but
may be empty). The path may be relative, starting with `./` rather than `/`.

For example, a valid relative reference is `./path?query`,
`/?query#fragment` or `//example.com`.

Absolute URIs have a scheme specified. Any other components of the URI which
are missing are specified as explicitly unset in the URI, rather than being
resolved relative to a base URI using [method@GLib.Uri.parse_relative].

For example, a valid absolute URI is `file:///home/bob` or
`https://search.com?query=string`.

A `GUri` instance is always an absolute URI. A string may be an absolute URI
or a relative reference; see the documentation for individual functions as to
what forms they accept.

## Parsing URIs

The most minimalist APIs for parsing URIs are [func@GLib.Uri.split] and
[func@GLib.Uri.split_with_user]. These split a URI into its component
parts, and return the parts; the difference between the two is that
[func@GLib.Uri.split] treats the &#x2018;userinfo&#x2019; component of the URI as a
single element, while [func@GLib.Uri.split_with_user] can (depending on the
[flags@GLib.UriFlags] you pass) treat it as containing a username, password,
and authentication parameters. Alternatively, [func@GLib.Uri.split_network]
can be used when you are only interested in the components that are
needed to initiate a network connection to the service (scheme,
host, and port).

[func@GLib.Uri.parse] is similar to [func@GLib.Uri.split], but instead of
returning individual strings, it returns a `GUri` structure (and it requires
that the URI be an absolute URI).

[func@GLib.Uri.resolve_relative] and [method@GLib.Uri.parse_relative] allow
you to resolve a relative URI relative to a base URI.
[func@GLib.Uri.resolve_relative] takes two strings and returns a string,
and [method@GLib.Uri.parse_relative] takes a `GUri` and a string and returns a
`GUri`.

All of the parsing functions take a [flags@GLib.UriFlags] argument describing
exactly how to parse the URI; see the documentation for that type
for more details on the specific flags that you can pass. If you
need to choose different flags based on the type of URI, you can
use [func@GLib.Uri.peek_scheme] on the URI string to check the scheme
first, and use that to decide what flags to parse it with.

For example, you might want to use `G_URI_PARAMS_WWW_FORM` when parsing the
params for a web URI, so compare the result of [func@GLib.Uri.peek_scheme]
against `http` and `https`.

## Building URIs

[func@GLib.Uri.join] and [func@GLib.Uri.join_with_user] can be used to construct
valid URI strings from a set of component strings. They are the
inverse of [func@GLib.Uri.split] and [func@GLib.Uri.split_with_user].

Similarly, [func@GLib.Uri.build] and [func@GLib.Uri.build_with_user] can be
used to construct a `GUri` from a set of component strings.

As with the parsing functions, the building functions take a
[flags@GLib.UriFlags] argument. In particular, it is important to keep in mind
whether the URI components you are using are already `%`-encoded. If so,
you must pass the `G_URI_FLAGS_ENCODED` flag.

## `file://` URIs

Note that Windows and Unix both define special rules for parsing
`file://` URIs (involving non-UTF-8 character sets on Unix, and the
interpretation of path separators on Windows). `GUri` does not
implement these rules. Use [func@GLib.filename_from_uri] and
[func@GLib.filename_to_uri] if you want to properly convert between
`file://` URIs and local filenames.

## URI Equality

Note that there is no `g_uri_equal ()` function, because comparing
URIs usefully requires scheme-specific knowledge that `GUri` does
not have. `GUri` can help with normalization if you use the various
encoded [flags@GLib.UriFlags] as well as `G_URI_FLAGS_SCHEME_NORMALIZE`
however it is not comprehensive.
For example, `data:,foo` and `data:;base64,Zm9v` resolve to the same
thing according to the `data:` URI specification which GLib does not
handle.</doc>
      <method name="get_auth_params" c:identifier="g_uri_get_auth_params" version="2.66">
        <doc xml:space="preserve">Gets @uri's authentication parameters, which may contain
`%`-encoding, depending on the flags with which @uri was created.
(If @uri was not created with %G_URI_FLAGS_HAS_AUTH_PARAMS then this will
be %NULL.)

Depending on the URI scheme, g_uri_parse_params() may be useful for
further parsing this information.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@uri's authentication parameters.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_uri_get_flags" version="2.66">
        <doc xml:space="preserve">Gets @uri's flags set upon construction.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's flags.</doc>
          <type name="UriFlags" c:type="GUriFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fragment" c:identifier="g_uri_get_fragment" version="2.66">
        <doc xml:space="preserve">Gets @uri's fragment, which may contain `%`-encoding, depending on
the flags with which @uri was created.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@uri's fragment.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_host" c:identifier="g_uri_get_host" version="2.66">
        <doc xml:space="preserve">Gets @uri's host. This will never have `%`-encoded characters,
unless it is non-UTF-8 (which can only be the case if @uri was
created with %G_URI_FLAGS_NON_DNS).

If @uri contained an IPv6 address literal, this value will be just
that address, without the brackets around it that are necessary in
the string form of the URI. Note that in this case there may also
be a scope ID attached to the address. Eg, `fe80::1234%``em1` (or
`fe80::1234%``25em1` if the string is still encoded).</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@uri's host.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password" c:identifier="g_uri_get_password" version="2.66">
        <doc xml:space="preserve">Gets @uri's password, which may contain `%`-encoding, depending on
the flags with which @uri was created. (If @uri was not created
with %G_URI_FLAGS_HAS_PASSWORD then this will be %NULL.)</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@uri's password.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="g_uri_get_path" version="2.66">
        <doc xml:space="preserve">Gets @uri's path, which may contain `%`-encoding, depending on the
flags with which @uri was created.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's path.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port" c:identifier="g_uri_get_port" version="2.66">
        <doc xml:space="preserve">Gets @uri's port.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's port, or `-1` if no port was specified.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_query" c:identifier="g_uri_get_query" version="2.66">
        <doc xml:space="preserve">Gets @uri's query, which may contain `%`-encoding, depending on the
flags with which @uri was created.

For queries consisting of a series of `name=value` parameters,
#GUriParamsIter or g_uri_parse_params() may be useful.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@uri's query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scheme" c:identifier="g_uri_get_scheme" version="2.66">
        <doc xml:space="preserve">Gets @uri's scheme. Note that this will always be all-lowercase,
regardless of the string or strings that @uri was created from.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@uri's scheme.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user" c:identifier="g_uri_get_user" version="2.66">
        <doc xml:space="preserve">Gets the &#x2018;username&#x2019; component of @uri's userinfo, which may contain
`%`-encoding, depending on the flags with which @uri was created.
If @uri was not created with %G_URI_FLAGS_HAS_PASSWORD or
%G_URI_FLAGS_HAS_AUTH_PARAMS, this is the same as g_uri_get_userinfo().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@uri's user.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_userinfo" c:identifier="g_uri_get_userinfo" version="2.66">
        <doc xml:space="preserve">Gets @uri's userinfo, which may contain `%`-encoding, depending on
the flags with which @uri was created.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@uri's userinfo.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="parse_relative" c:identifier="g_uri_parse_relative" version="2.66" throws="1">
        <doc xml:space="preserve">Parses @uri_ref according to @flags and, if it is a
[relative URI](#relative-and-absolute-uris), resolves it relative to @base_uri.
If the result is not a valid absolute URI, it will be discarded, and an error
returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUri, or NULL on error.</doc>
          <type name="Uri" c:type="GUri*"/>
        </return-value>
        <parameters>
          <instance-parameter name="base_uri" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a base absolute URI</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
          <parameter name="uri_ref" transfer-ownership="none">
            <doc xml:space="preserve">a string representing a relative or absolute URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing how to parse @uri_ref</doc>
            <type name="UriFlags" c:type="GUriFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_uri_ref" version="2.66" introspectable="0">
        <doc xml:space="preserve">Increments the reference count of @uri by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">@uri</doc>
          <type name="Uri" c:type="GUri*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="g_uri_to_string" version="2.66">
        <doc xml:space="preserve">Returns a string representing @uri.

This is not guaranteed to return a string which is identical to the
string that @uri was parsed from. However, if the source URI was
syntactically correct (according to RFC 3986), and it was parsed
with %G_URI_FLAGS_ENCODED, then g_uri_to_string() is guaranteed to return
a string which is at least semantically equivalent to the source
URI (according to RFC 3986).

If @uri might contain sensitive details, such as authentication parameters,
or private data in its query string, and the returned string is going to be
logged, then consider using g_uri_to_string_partial() to redact parts.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string representing @uri,
    which the caller must free.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string_partial" c:identifier="g_uri_to_string_partial" version="2.66">
        <doc xml:space="preserve">Returns a string representing @uri, subject to the options in
@flags. See g_uri_to_string() and #GUriHideFlags for more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string representing
    @uri, which the caller must free.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing what parts of @uri to hide</doc>
            <type name="UriHideFlags" c:type="GUriHideFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_uri_unref" version="2.66" introspectable="0">
        <doc xml:space="preserve">Atomically decrements the reference count of @uri by one.

When the reference count reaches zero, the resources allocated by
@uri are freed</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="Uri" c:type="GUri*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="build" c:identifier="g_uri_build" version="2.66">
        <doc xml:space="preserve">Creates a new #GUri from the given components according to @flags.

See also g_uri_build_with_user(), which allows specifying the
components of the "userinfo" separately.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUri</doc>
          <type name="Uri" c:type="GUri*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing how to build the #GUri</doc>
            <type name="UriFlags" c:type="GUriFlags"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">the URI scheme</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="userinfo" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the userinfo component, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="host" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the host component, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port, or `-1`</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path component</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="query" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the query component, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="fragment" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the fragment, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="build_with_user" c:identifier="g_uri_build_with_user" version="2.66">
        <doc xml:space="preserve">Creates a new #GUri from the given components according to @flags
(%G_URI_FLAGS_HAS_PASSWORD is added unconditionally). The @flags must be
coherent with the passed values, in particular use `%`-encoded values with
%G_URI_FLAGS_ENCODED.

In contrast to g_uri_build(), this allows specifying the components
of the &#x2018;userinfo&#x2019; field separately. Note that @user must be non-%NULL
if either @password or @auth_params is non-%NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUri</doc>
          <type name="Uri" c:type="GUri*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing how to build the #GUri</doc>
            <type name="UriFlags" c:type="GUriFlags"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">the URI scheme</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="user" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user component of the userinfo, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the password component of the userinfo, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="auth_params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the auth params of the userinfo, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="host" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the host component, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port, or `-1`</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path component</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="query" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the query component, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="fragment" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the fragment, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="error_quark" c:identifier="g_uri_error_quark">
        <return-value transfer-ownership="none">
          <type name="Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="escape_bytes" c:identifier="g_uri_escape_bytes" version="2.66">
        <doc xml:space="preserve">Escapes arbitrary data for use in a URI.

Normally all characters that are not &#x2018;unreserved&#x2019; (i.e. ASCII
alphanumerical characters plus dash, dot, underscore and tilde) are
escaped. But if you specify characters in @reserved_chars_allowed
they are not escaped. This is useful for the &#x2018;reserved&#x2019; characters
in the URI specification, since those are allowed unescaped in some
portions of a URI.

Though technically incorrect, this will also allow escaping nul
bytes as `%``00`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an escaped version of @unescaped.
    The returned string should be freed when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="unescaped" transfer-ownership="none">
            <doc xml:space="preserve">the unescaped input data.</doc>
            <array length="1" zero-terminated="0" c:type="const guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @unescaped</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="reserved_chars_allowed" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string of reserved
  characters that are allowed to be used, or %NULL.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="escape_string" c:identifier="g_uri_escape_string" version="2.16">
        <doc xml:space="preserve">Escapes a string for use in a URI.

Normally all characters that are not "unreserved" (i.e. ASCII
alphanumerical characters plus dash, dot, underscore and tilde) are
escaped. But if you specify characters in @reserved_chars_allowed
they are not escaped. This is useful for the "reserved" characters
in the URI specification, since those are allowed unescaped in some
portions of a URI.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an escaped version of @unescaped. The
returned string should be freed when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="unescaped" transfer-ownership="none">
            <doc xml:space="preserve">the unescaped input string.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="reserved_chars_allowed" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string of reserved
  characters that are allowed to be used, or %NULL.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="allow_utf8" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the result can include UTF-8 characters.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_valid" c:identifier="g_uri_is_valid" version="2.66" throws="1">
        <doc xml:space="preserve">Parses @uri_string according to @flags, to determine whether it is a valid
[absolute URI](#relative-and-absolute-uris), i.e. it does not need to be resolved
relative to another URI using g_uri_parse_relative().

If it&#x2019;s not a valid URI, an error is returned explaining how it&#x2019;s invalid.

See g_uri_split(), and the definition of #GUriFlags, for more
information on the effect of @flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @uri_string is a valid absolute URI, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri_string" transfer-ownership="none">
            <doc xml:space="preserve">a string containing an absolute URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags for parsing @uri_string</doc>
            <type name="UriFlags" c:type="GUriFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="join" c:identifier="g_uri_join" version="2.66">
        <doc xml:space="preserve">Joins the given components together according to @flags to create
an absolute URI string. @path may not be %NULL (though it may be the empty
string).

When @host is present, @path must either be empty or begin with a slash (`/`)
character. When @host is not present, @path cannot begin with two slash
characters (`//`). See
[RFC 3986, section 3](https://tools.ietf.org/html/rfc3986#section-3).

See also g_uri_join_with_user(), which allows specifying the
components of the &#x2018;userinfo&#x2019; separately.

%G_URI_FLAGS_HAS_PASSWORD and %G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
in @flags.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an absolute URI string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing how to build the URI string</doc>
            <type name="UriFlags" c:type="GUriFlags"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the URI scheme, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="userinfo" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the userinfo component, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="host" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the host component, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port, or `-1`</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path component</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="query" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the query component, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="fragment" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the fragment, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="join_with_user" c:identifier="g_uri_join_with_user" version="2.66">
        <doc xml:space="preserve">Joins the given components together according to @flags to create
an absolute URI string. @path may not be %NULL (though it may be the empty
string).

In contrast to g_uri_join(), this allows specifying the components
of the &#x2018;userinfo&#x2019; separately. It otherwise behaves the same.

%G_URI_FLAGS_HAS_PASSWORD and %G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
in @flags.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an absolute URI string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing how to build the URI string</doc>
            <type name="UriFlags" c:type="GUriFlags"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the URI scheme, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="user" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the user component of the userinfo, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the password component of the userinfo, or
  %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="auth_params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the auth params of the userinfo, or
  %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="host" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the host component, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port, or `-1`</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path component</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="query" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the query component, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="fragment" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the fragment, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_extract_uris" c:identifier="g_uri_list_extract_uris" version="2.6">
        <doc xml:space="preserve">Splits an URI list conforming to the text/uri-list
mime type defined in RFC 2483 into individual URIs,
discarding any comments. The URIs are not validated.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated %NULL-terminated list
  of strings holding the individual URIs. The array should be freed
  with g_strfreev().</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="uri_list" transfer-ownership="none">
            <doc xml:space="preserve">an URI list</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse" c:identifier="g_uri_parse" version="2.66" throws="1">
        <doc xml:space="preserve">Parses @uri_string according to @flags. If the result is not a
valid [absolute URI](#relative-and-absolute-uris), it will be discarded, and an
error returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GUri, or NULL on error.</doc>
          <type name="Uri" c:type="GUri*"/>
        </return-value>
        <parameters>
          <parameter name="uri_string" transfer-ownership="none">
            <doc xml:space="preserve">a string representing an absolute URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing how to parse @uri_string</doc>
            <type name="UriFlags" c:type="GUriFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_params" c:identifier="g_uri_parse_params" version="2.66" throws="1">
        <doc xml:space="preserve">Many URI schemes include one or more attribute/value pairs as part of the URI
value. This method can be used to parse them into a hash table. When an
attribute has multiple occurrences, the last value is the final returned
value. If you need to handle repeated attributes differently, use
#GUriParamsIter.

The @params string is assumed to still be `%`-encoded, but the returned
values will be fully decoded. (Thus it is possible that the returned values
may contain `=` or @separators, if the value was encoded in the input.)
Invalid `%`-encoding is treated as with the %G_URI_FLAGS_PARSE_RELAXED
rules for g_uri_parse(). (However, if @params is the path or query string
from a #GUri that was parsed without %G_URI_FLAGS_PARSE_RELAXED and
%G_URI_FLAGS_ENCODED, then you already know that it does not contain any
invalid encoding.)

%G_URI_PARAMS_WWW_FORM is handled as documented for g_uri_params_iter_init().

If %G_URI_PARAMS_CASE_INSENSITIVE is passed to @flags, attributes will be
compared case-insensitively, so a params string `attr=123&amp;Attr=456` will only
return a single attribute&#x2013;value pair, `Attr=456`. Case will be preserved in
the returned attributes.

If @params cannot be parsed (for example, it contains two @separators
characters in a row), then @error is set and %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
    A hash table of attribute/value pairs, with both names and values
    fully-decoded; or %NULL on error.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">a `%`-encoded string containing `attribute=value`
  parameters</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @params, or `-1` if it is nul-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="separators" transfer-ownership="none">
            <doc xml:space="preserve">the separator byte character set between parameters. (usually
  `&amp;`, but sometimes `;` or both `&amp;;`). Note that this function works on
  bytes not characters, so it can't be used to delimit UTF-8 strings for
  anything but ASCII characters. You may pass an empty set, in which case
  no splitting will occur.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags to modify the way the parameters are handled.</doc>
            <type name="UriParamsFlags" c:type="GUriParamsFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_scheme" c:identifier="g_uri_parse_scheme" version="2.16">
        <doc xml:space="preserve">Gets the scheme portion of a URI string.
[RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme
as:
|[
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
]|
Common schemes include `file`, `https`, `svn+ssh`, etc.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The &#x2018;scheme&#x2019; component of the URI, or
    %NULL on error. The returned string should be freed when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="peek_scheme" c:identifier="g_uri_peek_scheme" version="2.66">
        <doc xml:space="preserve">Gets the scheme portion of a URI string.
[RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme
as:
|[
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
]|
Common schemes include `file`, `https`, `svn+ssh`, etc.

Unlike g_uri_parse_scheme(), the returned scheme is normalized to
all-lowercase and does not need to be freed.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The &#x2018;scheme&#x2019; component of the URI, or
    %NULL on error. The returned string is normalized to all-lowercase, and
    interned via g_intern_string(), so it does not need to be freed.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a valid URI.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="resolve_relative" c:identifier="g_uri_resolve_relative" version="2.66" throws="1">
        <doc xml:space="preserve">Parses @uri_ref according to @flags and, if it is a
[relative URI](#relative-and-absolute-uris), resolves it relative to
@base_uri_string. If the result is not a valid absolute URI, it will be
discarded, and an error returned.

(If @base_uri_string is %NULL, this just returns @uri_ref, or
%NULL if @uri_ref is invalid or not absolute.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the resolved URI string,
or NULL on error.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="base_uri_string" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string representing a base URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uri_ref" transfer-ownership="none">
            <doc xml:space="preserve">a string representing a relative or absolute URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags describing how to parse @uri_ref</doc>
            <type name="UriFlags" c:type="GUriFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="split" c:identifier="g_uri_split" version="2.66" throws="1">
        <doc xml:space="preserve">Parses @uri_ref (which can be an
[absolute or relative URI](#relative-and-absolute-uris)) according to @flags, and
returns the pieces. Any component that doesn't appear in @uri_ref will be
returned as %NULL (but note that all URIs always have a path component,
though it may be the empty string).

If @flags contains %G_URI_FLAGS_ENCODED, then `%`-encoded characters in
@uri_ref will remain encoded in the output strings. (If not,
then all such characters will be decoded.) Note that decoding will
only work if the URI components are ASCII or UTF-8, so you will
need to use %G_URI_FLAGS_ENCODED if they are not.

Note that the %G_URI_FLAGS_HAS_PASSWORD and
%G_URI_FLAGS_HAS_AUTH_PARAMS @flags are ignored by g_uri_split(),
since it always returns only the full userinfo; use
g_uri_split_with_user() if you want it split up.</doc>
        <return-value transfer-ownership="none" skip="1">
          <doc xml:space="preserve">%TRUE if @uri_ref parsed successfully, %FALSE
  on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri_ref" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a relative or absolute URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags for parsing @uri_ref</doc>
            <type name="UriFlags" c:type="GUriFlags"/>
          </parameter>
          <parameter name="scheme" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains
   the scheme (converted to lowercase), or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="userinfo" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains
   the userinfo, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="host" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains the
   host, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="port" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains the
   port, or `-1`</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains the
   path</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="query" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains the
   query, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="fragment" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains
   the fragment, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </function>
      <function name="split_network" c:identifier="g_uri_split_network" version="2.66" throws="1">
        <doc xml:space="preserve">Parses @uri_string (which must be an [absolute URI](#relative-and-absolute-uris))
according to @flags, and returns the pieces relevant to connecting to a host.
See the documentation for g_uri_split() for more details; this is
mostly a wrapper around that function with simpler arguments.
However, it will return an error if @uri_string is a relative URI,
or does not contain a hostname component.</doc>
        <return-value transfer-ownership="none" skip="1">
          <doc xml:space="preserve">%TRUE if @uri_string parsed successfully,
  %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri_string" transfer-ownership="none">
            <doc xml:space="preserve">a string containing an absolute URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags for parsing @uri_string</doc>
            <type name="UriFlags" c:type="GUriFlags"/>
          </parameter>
          <parameter name="scheme" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains
   the scheme (converted to lowercase), or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="host" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains the
   host, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="port" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains the
   port, or `-1`</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="split_with_user" c:identifier="g_uri_split_with_user" version="2.66" throws="1">
        <doc xml:space="preserve">Parses @uri_ref (which can be an
[absolute or relative URI](#relative-and-absolute-uris)) according to @flags, and
returns the pieces. Any component that doesn't appear in @uri_ref will be
returned as %NULL (but note that all URIs always have a path component,
though it may be the empty string).

See g_uri_split(), and the definition of #GUriFlags, for more
information on the effect of @flags. Note that @password will only
be parsed out if @flags contains %G_URI_FLAGS_HAS_PASSWORD, and
@auth_params will only be parsed out if @flags contains
%G_URI_FLAGS_HAS_AUTH_PARAMS.</doc>
        <return-value transfer-ownership="none" skip="1">
          <doc xml:space="preserve">%TRUE if @uri_ref parsed successfully, %FALSE
  on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri_ref" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a relative or absolute URI</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags for parsing @uri_ref</doc>
            <type name="UriFlags" c:type="GUriFlags"/>
          </parameter>
          <parameter name="scheme" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains
   the scheme (converted to lowercase), or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="user" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains
   the user, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="password" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains
   the password, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="auth_params" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains
   the auth_params, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="host" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains the
   host, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="port" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains the
   port, or `-1`</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains the
   path</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="query" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains the
   query, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="fragment" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains
   the fragment, or %NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </function>
      <function name="unescape_bytes" c:identifier="g_uri_unescape_bytes" version="2.66" throws="1">
        <doc xml:space="preserve">Unescapes a segment of an escaped string as binary data.

Note that in contrast to g_uri_unescape_string(), this does allow
nul bytes to appear in the output.

If any of the characters in @illegal_characters appears as an escaped
character in @escaped_string, then that is an error and %NULL will be
returned. This is useful if you want to avoid for instance having a slash
being expanded in an escaped path element, which might confuse pathname
handling.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an unescaped version of @escaped_string
    or %NULL on error (if decoding failed, using %G_URI_ERROR_FAILED error
    code). The returned #GBytes should be unreffed when no longer needed.</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <parameter name="escaped_string" transfer-ownership="none">
            <doc xml:space="preserve">A URI-escaped string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length (in bytes) of @escaped_string to escape, or `-1` if it
  is nul-terminated.</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="illegal_characters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string of illegal characters
  not to be allowed, or %NULL.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unescape_segment" c:identifier="g_uri_unescape_segment" version="2.16">
        <doc xml:space="preserve">Unescapes a segment of an escaped string.

If any of the characters in @illegal_characters or the NUL
character appears as an escaped character in @escaped_string, then
that is an error and %NULL will be returned. This is useful if you
want to avoid for instance having a slash being expanded in an
escaped path element, which might confuse pathname handling.

Note: `NUL` byte is not accepted in the output, in contrast to
g_uri_unescape_bytes().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">an unescaped version of @escaped_string,
or %NULL on error. The returned string should be freed when no longer
needed.  As a special case if %NULL is given for @escaped_string, this
function will return %NULL.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="escaped_string" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A string, may be %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="escaped_string_end" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Pointer to end of @escaped_string,
  may be %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="illegal_characters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">An optional string of illegal
  characters not to be allowed, may be %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unescape_string" c:identifier="g_uri_unescape_string" version="2.16">
        <doc xml:space="preserve">Unescapes a whole escaped string.

If any of the characters in @illegal_characters or the NUL
character appears as an escaped character in @escaped_string, then
that is an error and %NULL will be returned. This is useful if you
want to avoid for instance having a slash being expanded in an
escaped path element, which might confuse pathname handling.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">an unescaped version of @escaped_string.
The returned string should be freed when no longer needed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="escaped_string" transfer-ownership="none">
            <doc xml:space="preserve">an escaped string to be unescaped.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="illegal_characters" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string of illegal characters
  not to be allowed, or %NULL.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="UriError" version="2.66" c:type="GUriError" glib:error-domain="g-uri-quark">
      <doc xml:space="preserve">Error codes returned by #GUri methods.</doc>
      <member name="failed" value="0" c:identifier="G_URI_ERROR_FAILED">
        <doc xml:space="preserve">Generic error if no more specific error is available.
    See the error message for details.</doc>
      </member>
      <member name="bad_scheme" value="1" c:identifier="G_URI_ERROR_BAD_SCHEME">
        <doc xml:space="preserve">The scheme of a URI could not be parsed.</doc>
      </member>
      <member name="bad_user" value="2" c:identifier="G_URI_ERROR_BAD_USER">
        <doc xml:space="preserve">The user/userinfo of a URI could not be parsed.</doc>
      </member>
      <member name="bad_password" value="3" c:identifier="G_URI_ERROR_BAD_PASSWORD">
        <doc xml:space="preserve">The password of a URI could not be parsed.</doc>
      </member>
      <member name="bad_auth_params" value="4" c:identifier="G_URI_ERROR_BAD_AUTH_PARAMS">
        <doc xml:space="preserve">The authentication parameters of a URI could not be parsed.</doc>
      </member>
      <member name="bad_host" value="5" c:identifier="G_URI_ERROR_BAD_HOST">
        <doc xml:space="preserve">The host of a URI could not be parsed.</doc>
      </member>
      <member name="bad_port" value="6" c:identifier="G_URI_ERROR_BAD_PORT">
        <doc xml:space="preserve">The port of a URI could not be parsed.</doc>
      </member>
      <member name="bad_path" value="7" c:identifier="G_URI_ERROR_BAD_PATH">
        <doc xml:space="preserve">The path of a URI could not be parsed.</doc>
      </member>
      <member name="bad_query" value="8" c:identifier="G_URI_ERROR_BAD_QUERY">
        <doc xml:space="preserve">The query of a URI could not be parsed.</doc>
      </member>
      <member name="bad_fragment" value="9" c:identifier="G_URI_ERROR_BAD_FRAGMENT">
        <doc xml:space="preserve">The fragment of a URI could not be parsed.</doc>
      </member>
    </enumeration>
    <bitfield name="UriFlags" version="2.66" c:type="GUriFlags">
      <doc xml:space="preserve">Flags that describe a URI.

When parsing a URI, if you need to choose different flags based on
the type of URI, you can use g_uri_peek_scheme() on the URI string
to check the scheme first, and use that to decide what flags to
parse it with.</doc>
      <member name="none" value="0" c:identifier="G_URI_FLAGS_NONE">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="parse_relaxed" value="1" c:identifier="G_URI_FLAGS_PARSE_RELAXED">
        <doc xml:space="preserve">Parse the URI more relaxedly than the
    [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,
    fixing up or ignoring common mistakes in URIs coming from external
    sources. This is also needed for some obscure URI schemes where `;`
    separates the host from the path. Don&#x2019;t use this flag unless you need to.</doc>
      </member>
      <member name="has_password" value="2" c:identifier="G_URI_FLAGS_HAS_PASSWORD">
        <doc xml:space="preserve">The userinfo field may contain a password,
    which will be separated from the username by `:`.</doc>
      </member>
      <member name="has_auth_params" value="4" c:identifier="G_URI_FLAGS_HAS_AUTH_PARAMS">
        <doc xml:space="preserve">The userinfo may contain additional
    authentication-related parameters, which will be separated from
    the username and/or password by `;`.</doc>
      </member>
      <member name="encoded" value="8" c:identifier="G_URI_FLAGS_ENCODED">
        <doc xml:space="preserve">When parsing a URI, this indicates that `%`-encoded
    characters in the userinfo, path, query, and fragment fields
    should not be decoded. (And likewise the host field if
    %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates
    that you have already `%`-encoded the components, and so #GUri
    should not do any encoding itself.</doc>
      </member>
      <member name="non_dns" value="16" c:identifier="G_URI_FLAGS_NON_DNS">
        <doc xml:space="preserve">The host component should not be assumed to be a
    DNS hostname or IP address (for example, for `smb` URIs with NetBIOS
    hostnames).</doc>
      </member>
      <member name="encoded_query" value="32" c:identifier="G_URI_FLAGS_ENCODED_QUERY">
        <doc xml:space="preserve">Same as %G_URI_FLAGS_ENCODED, for the query
    field only.</doc>
      </member>
      <member name="encoded_path" value="64" c:identifier="G_URI_FLAGS_ENCODED_PATH">
        <doc xml:space="preserve">Same as %G_URI_FLAGS_ENCODED, for the path only.</doc>
      </member>
      <member name="encoded_fragment" value="128" c:identifier="G_URI_FLAGS_ENCODED_FRAGMENT">
        <doc xml:space="preserve">Same as %G_URI_FLAGS_ENCODED, for the
    fragment only.</doc>
      </member>
      <member name="scheme_normalize" value="256" c:identifier="G_URI_FLAGS_SCHEME_NORMALIZE">
        <doc xml:space="preserve">A scheme-based normalization will be applied.
    For example, when parsing an HTTP URI changing omitted path to `/` and
    omitted port to `80`; and when building a URI, changing empty path to `/`
    and default port `80`). This only supports a subset of known schemes. (Since: 2.68)</doc>
      </member>
    </bitfield>
    <bitfield name="UriHideFlags" version="2.66" c:type="GUriHideFlags">
      <doc xml:space="preserve">Flags describing what parts of the URI to hide in
g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and
%G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with
the corresponding flags.</doc>
      <member name="none" value="0" c:identifier="G_URI_HIDE_NONE">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="userinfo" value="1" c:identifier="G_URI_HIDE_USERINFO">
        <doc xml:space="preserve">Hide the userinfo.</doc>
      </member>
      <member name="password" value="2" c:identifier="G_URI_HIDE_PASSWORD">
        <doc xml:space="preserve">Hide the password.</doc>
      </member>
      <member name="auth_params" value="4" c:identifier="G_URI_HIDE_AUTH_PARAMS">
        <doc xml:space="preserve">Hide the auth_params.</doc>
      </member>
      <member name="query" value="8" c:identifier="G_URI_HIDE_QUERY">
        <doc xml:space="preserve">Hide the query.</doc>
      </member>
      <member name="fragment" value="16" c:identifier="G_URI_HIDE_FRAGMENT">
        <doc xml:space="preserve">Hide the fragment.</doc>
      </member>
    </bitfield>
    <bitfield name="UriParamsFlags" version="2.66" c:type="GUriParamsFlags">
      <doc xml:space="preserve">Flags modifying the way parameters are handled by g_uri_parse_params() and
#GUriParamsIter.</doc>
      <member name="none" value="0" c:identifier="G_URI_PARAMS_NONE">
        <doc xml:space="preserve">No flags set.</doc>
      </member>
      <member name="case_insensitive" value="1" c:identifier="G_URI_PARAMS_CASE_INSENSITIVE">
        <doc xml:space="preserve">Parameter names are case insensitive.</doc>
      </member>
      <member name="www_form" value="2" c:identifier="G_URI_PARAMS_WWW_FORM">
        <doc xml:space="preserve">Replace `+` with space character. Only useful for
    URLs on the web, using the `https` or `http` schemas.</doc>
      </member>
      <member name="parse_relaxed" value="4" c:identifier="G_URI_PARAMS_PARSE_RELAXED">
        <doc xml:space="preserve">See %G_URI_FLAGS_PARSE_RELAXED.</doc>
      </member>
    </bitfield>
    <record name="UriParamsIter" c:type="GUriParamsIter" version="2.66">
      <doc xml:space="preserve">Many URI schemes include one or more attribute/value pairs as part of the URI
value. For example `scheme://server/path?query=string&amp;is=there` has two
attributes &#x2013; `query=string` and `is=there` &#x2013; in its query part.

A #GUriParamsIter structure represents an iterator that can be used to
iterate over the attribute/value pairs of a URI query string. #GUriParamsIter
structures are typically allocated on the stack and then initialized with
g_uri_params_iter_init(). See the documentation for g_uri_params_iter_init()
for a usage example.</doc>
      <field name="dummy0" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="dummy1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy3" readable="0" private="1">
        <array zero-terminated="0" fixed-size="256">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
      <method name="init" c:identifier="g_uri_params_iter_init" version="2.66">
        <doc xml:space="preserve">Initializes an attribute/value pair iterator.

The iterator keeps pointers to the @params and @separators arguments, those
variables must thus outlive the iterator and not be modified during the
iteration.

If %G_URI_PARAMS_WWW_FORM is passed in @flags, `+` characters in the param
string will be replaced with spaces in the output. For example, `foo=bar+baz`
will give attribute `foo` with value `bar baz`. This is commonly used on the
web (the `https` and `http` schemes only), but is deprecated in favour of
the equivalent of encoding spaces as `%20`.

Unlike with g_uri_parse_params(), %G_URI_PARAMS_CASE_INSENSITIVE has no
effect if passed to @flags for g_uri_params_iter_init(). The caller is
responsible for doing their own case-insensitive comparisons.

|[&lt;!-- language="C" --&gt;
GUriParamsIter iter;
GError *error = NULL;
gchar *unowned_attr, *unowned_value;

g_uri_params_iter_init (&amp;iter, "foo=bar&amp;baz=bar&amp;Foo=frob&amp;baz=bar2", -1, "&amp;", G_URI_PARAMS_NONE);
while (g_uri_params_iter_next (&amp;iter, &amp;unowned_attr, &amp;unowned_value, &amp;error))
  {
    g_autofree gchar *attr = g_steal_pointer (&amp;unowned_attr);
    g_autofree gchar *value = g_steal_pointer (&amp;unowned_value);
    // do something with attr and value; this code will be called 4 times
    // for the params string in this example: once with attr=foo and value=bar,
    // then with baz/bar, then Foo/frob, then baz/bar2.
  }
if (error)
  // handle parsing error
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an uninitialized #GUriParamsIter</doc>
            <type name="UriParamsIter" c:type="GUriParamsIter*"/>
          </instance-parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">a `%`-encoded string containing `attribute=value`
  parameters</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @params, or `-1` if it is nul-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="separators" transfer-ownership="none">
            <doc xml:space="preserve">the separator byte character set between parameters. (usually
  `&amp;`, but sometimes `;` or both `&amp;;`). Note that this function works on
  bytes not characters, so it can't be used to delimit UTF-8 strings for
  anything but ASCII characters. You may pass an empty set, in which case
  no splitting will occur.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags to modify the way the parameters are handled.</doc>
            <type name="UriParamsFlags" c:type="GUriParamsFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="g_uri_params_iter_next" version="2.66" throws="1">
        <doc xml:space="preserve">Advances @iter and retrieves the next attribute/value. %FALSE is returned if
an error has occurred (in which case @error is set), or if the end of the
iteration is reached (in which case @attribute and @value are set to %NULL
and the iterator becomes invalid). If %TRUE is returned,
g_uri_params_iter_next() may be called again to receive another
attribute/value pair.

Note that the same @attribute may be returned multiple times, since URIs
allow repeated attributes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the end of the parameters has been reached or an error was
    encountered. %TRUE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">an initialized #GUriParamsIter</doc>
            <type name="UriParamsIter" c:type="GUriParamsIter*"/>
          </instance-parameter>
          <parameter name="attribute" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains
    the attribute, or %NULL.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
            <doc xml:space="preserve">on return, contains
    the value, or %NULL.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="UserDirectory" version="2.14" c:type="GUserDirectory">
      <doc xml:space="preserve">These are logical ids for special directories which are defined
depending on the platform used. You should use g_get_user_special_dir()
to retrieve the full path associated to the logical id.

The #GUserDirectory enumeration can be extended at later date. Not
every platform has a directory for every logical id in this
enumeration.</doc>
      <member name="directory_desktop" value="0" c:identifier="G_USER_DIRECTORY_DESKTOP">
        <doc xml:space="preserve">the user's Desktop directory</doc>
      </member>
      <member name="directory_documents" value="1" c:identifier="G_USER_DIRECTORY_DOCUMENTS">
        <doc xml:space="preserve">the user's Documents directory</doc>
      </member>
      <member name="directory_download" value="2" c:identifier="G_USER_DIRECTORY_DOWNLOAD">
        <doc xml:space="preserve">the user's Downloads directory</doc>
      </member>
      <member name="directory_music" value="3" c:identifier="G_USER_DIRECTORY_MUSIC">
        <doc xml:space="preserve">the user's Music directory</doc>
      </member>
      <member name="directory_pictures" value="4" c:identifier="G_USER_DIRECTORY_PICTURES">
        <doc xml:space="preserve">the user's Pictures directory</doc>
      </member>
      <member name="directory_public_share" value="5" c:identifier="G_USER_DIRECTORY_PUBLIC_SHARE">
        <doc xml:space="preserve">the user's shared directory</doc>
      </member>
      <member name="directory_templates" value="6" c:identifier="G_USER_DIRECTORY_TEMPLATES">
        <doc xml:space="preserve">the user's Templates directory</doc>
      </member>
      <member name="directory_videos" value="7" c:identifier="G_USER_DIRECTORY_VIDEOS">
        <doc xml:space="preserve">the user's Movies directory</doc>
      </member>
      <member name="n_directories" value="8" c:identifier="G_USER_N_DIRECTORIES">
        <doc xml:space="preserve">the number of enum values</doc>
      </member>
    </enumeration>
    <function-macro name="VARIANT_BUILDER_INIT" c:identifier="G_VARIANT_BUILDER_INIT" version="2.50" introspectable="0">
      <doc xml:space="preserve">A stack-allocated [struct@GLib.VariantBuilder] must be initialized
if it is used together with
[`g_auto()`](auto-cleanup.html#variable-declaration). This macro can
be used as initializer when declaring the builder, but it cannot be
assigned to a variable.

The effects of initializing the builder with
`G_VARIANT_BUILDER_INIT` is the same as initializing it with
[func@GLib.VARIANT_BUILDER_INIT_UNSET], followed by a call to
[method@GLib.VariantBuilder.init].

The passed @variant_type should be a static [type@GLib.VariantType]
to avoid lifetime issues, as copying the @variant_type does not
happen in the `G_VARIANT_BUILDER_INIT` call, but rather in functions
that make sure that [struct@GLib.VariantBuilder] is valid.

```c
  g_auto(GVariantBuilder) builder = G_VARIANT_BUILDER_INIT (G_VARIANT_TYPE_BYTESTRING);
```</doc>
      <parameters>
        <parameter name="variant_type">
          <doc xml:space="preserve">a const GVariantType*</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VARIANT_BUILDER_INIT_UNSET" c:identifier="G_VARIANT_BUILDER_INIT_UNSET" version="2.84" introspectable="0">
      <doc xml:space="preserve">A stack-allocated [struct@GLib.VariantBuilder] must be initialized
if it is used together with
[`g_auto()`](auto-cleanup.html#variable-declaration). This macro can
be used as initializer when declaring the builder, but it cannot be
assigned to a variable.

The builder can be initialized to a specific [type@GLib.VariantType]
later with [method@GLib.VariantBuilder.init].

Use [func@GLib.VARIANT_BUILDER_INIT] to directly initialize the
builder with a specific [type@GLib.VariantType].

```c
  g_auto(GVariantBuilder) builder = G_VARIANT_BUILDER_INIT_UNSET ();

  if (condition)
    return NULL;

  g_variant_builder_init (&amp;builder, G_VARIANT_TYPE ("a{su}"));
  return g_variant_ref_sink (g_variant_builder_end (&amp;builder));
```</doc>
    </function-macro>
    <function-macro name="VARIANT_DICT_INIT" c:identifier="G_VARIANT_DICT_INIT" version="2.50" introspectable="0">
      <doc xml:space="preserve">A stack-allocated #GVariantDict must be initialized if it is used
together with g_auto() to avoid warnings or crashes if function
returns before g_variant_dict_init() is called on the builder.

This macro can be used as initializer instead of an explicit
zeroing a variable when declaring it and a following
g_variant_dict_init(), but it cannot be assigned to a variable.

The passed @asv has to live long enough for #GVariantDict to gather
the entries from, as the gathering does not happen in the
G_VARIANT_DICT_INIT() call, but rather in functions that make sure
that #GVariantDict is valid.  In context where the initialization
value has to be a constant expression, the only possible value of
@asv is %NULL.  It is still possible to call g_variant_dict_init()
safely with a different @asv right after the variable was
initialized with G_VARIANT_DICT_INIT().

|[&lt;!-- language="C" --&gt;
  g_autoptr(GVariant) variant = get_asv_variant ();
  g_auto(GVariantDict) dict = G_VARIANT_DICT_INIT (variant);
]|</doc>
      <parameters>
        <parameter name="asv">
          <doc xml:space="preserve">a GVariant*</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VARIANT_TYPE" c:identifier="G_VARIANT_TYPE" introspectable="0">
      <doc xml:space="preserve">Converts a string to a const [type@GLib.VariantType].

Depending on the current debugging level, this function may perform a runtime
check to ensure that @string is a valid [type@GLib.Variant] type string.

It is always a programmer error to use this macro with an invalid
type string. If in doubt, use [func@GLib.variant_type_string_is_valid] to
check if the string is valid.

Since 2.24</doc>
      <parameters>
        <parameter name="type_string">
          <doc xml:space="preserve">a well-formed [type@GLib.VariantType] type string</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="VA_COPY_AS_ARRAY" value="1" c:type="G_VA_COPY_AS_ARRAY">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VERSION_MIN_REQUIRED" value="2" c:type="GLIB_VERSION_MIN_REQUIRED" version="2.32">
      <doc xml:space="preserve">A macro that should be defined by the user prior to including
the glib.h header.
The definition should be one of the predefined GLib version
macros: %GLIB_VERSION_2_26, %GLIB_VERSION_2_28,...

This macro defines the earliest version of GLib that the package is
required to be able to compile against.

If the compiler is configured to warn about the use of deprecated
functions, then using functions that were deprecated in version
%GLIB_VERSION_MIN_REQUIRED or earlier will cause warnings (but
using functions deprecated in later releases will not).</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Variant" c:type="GVariant" opaque="1" copy-function="g_variant_ref_sink" free-function="g_variant_unref" version="2.24" glib:type-name="GVariant" glib:get-type="intern" c:symbol-prefix="variant">
      <doc xml:space="preserve">`GVariant` is a variant datatype; it can contain one or more values
along with information about the type of the values.

A `GVariant` may contain simple types, like an integer, or a boolean value;
or complex types, like an array of two strings, or a dictionary of key
value pairs. A `GVariant` is also immutable: once it&#x2019;s been created neither
its type nor its content can be modified further.

`GVariant` is useful whenever data needs to be serialized, for example when
sending method parameters in D-Bus, or when saving settings using
[`GSettings`](../gio/class.Settings.html).

When creating a new `GVariant`, you pass the data you want to store in it
along with a string representing the type of data you wish to pass to it.

For instance, if you want to create a `GVariant` holding an integer value you
can use:

```c
GVariant *v = g_variant_new ("u", 40);
```

The string `u` in the first argument tells `GVariant` that the data passed to
the constructor (`40`) is going to be an unsigned integer.

More advanced examples of `GVariant` in use can be found in documentation for
[`GVariant` format strings](gvariant-format-strings.html#pointers).

The range of possible values is determined by the type.

The type system used by `GVariant` is [type@GLib.VariantType].

`GVariant` instances always have a type and a value (which are given
at construction time).  The type and value of a `GVariant` instance
can never change other than by the `GVariant` itself being
destroyed.  A `GVariant` cannot contain a pointer.

`GVariant` is reference counted using [method@GLib.Variant.ref] and
[method@GLib.Variant.unref].  `GVariant` also has floating reference counts &#x2014;
see [method@GLib.Variant.ref_sink].

`GVariant` is completely threadsafe.  A `GVariant` instance can be
concurrently accessed in any way from any number of threads without
problems.

`GVariant` is heavily optimised for dealing with data in serialized
form.  It works particularly well with data located in memory-mapped
files.  It can perform nearly all deserialization operations in a
small constant time, usually touching only a single memory page.
Serialized `GVariant` data can also be sent over the network.

`GVariant` is largely compatible with D-Bus.  Almost all types of
`GVariant` instances can be sent over D-Bus.  See [type@GLib.VariantType] for
exceptions.  (However, `GVariant`&#x2019;s serialization format is not the same
as the serialization format of a D-Bus message body: use
[GDBusMessage](../gio/class.DBusMessage.html), in the GIO library, for those.)

For space-efficiency, the `GVariant` serialization format does not
automatically include the variant&#x2019;s length, type or endianness,
which must either be implied from context (such as knowledge that a
particular file format always contains a little-endian
`G_VARIANT_TYPE_VARIANT` which occupies the whole length of the file)
or supplied out-of-band (for instance, a length, type and/or endianness
indicator could be placed at the beginning of a file, network message
or network stream).

A `GVariant`&#x2019;s size is limited mainly by any lower level operating
system constraints, such as the number of bits in `gsize`.  For
example, it is reasonable to have a 2GB file mapped into memory
with [struct@GLib.MappedFile], and call [ctor@GLib.Variant.new_from_data] on
it.

For convenience to C programmers, `GVariant` features powerful
varargs-based value construction and destruction.  This feature is
designed to be embedded in other libraries.

There is a Python-inspired text language for describing `GVariant`
values.  `GVariant` includes a printer for this language and a parser
with type inferencing.

## Memory Use

`GVariant` tries to be quite efficient with respect to memory use.
This section gives a rough idea of how much memory is used by the
current implementation.  The information here is subject to change
in the future.

The memory allocated by `GVariant` can be grouped into 4 broad
purposes: memory for serialized data, memory for the type
information cache, buffer management memory and memory for the
`GVariant` structure itself.

## Serialized Data Memory

This is the memory that is used for storing `GVariant` data in
serialized form.  This is what would be sent over the network or
what would end up on disk, not counting any indicator of the
endianness, or of the length or type of the top-level variant.

The amount of memory required to store a boolean is 1 byte. 16,
32 and 64 bit integers and double precision floating point numbers
use their &#x2018;natural&#x2019; size.  Strings (including object path and
signature strings) are stored with a nul terminator, and as such
use the length of the string plus 1 byte.

&#x2018;Maybe&#x2019; types use no space at all to represent the null value and
use the same amount of space (sometimes plus one byte) as the
equivalent non-maybe-typed value to represent the non-null case.

Arrays use the amount of space required to store each of their
members, concatenated.  Additionally, if the items stored in an
array are not of a fixed-size (ie: strings, other arrays, etc)
then an additional framing offset is stored for each item.  The
size of this offset is either 1, 2 or 4 bytes depending on the
overall size of the container.  Additionally, extra padding bytes
are added as required for alignment of child values.

Tuples (including dictionary entries) use the amount of space
required to store each of their members, concatenated, plus one
framing offset (as per arrays) for each non-fixed-sized item in
the tuple, except for the last one.  Additionally, extra padding
bytes are added as required for alignment of child values.

Variants use the same amount of space as the item inside of the
variant, plus 1 byte, plus the length of the type string for the
item inside the variant.

As an example, consider a dictionary mapping strings to variants.
In the case that the dictionary is empty, 0 bytes are required for
the serialization.

If we add an item &#x2018;width&#x2019; that maps to the int32 value of 500 then
we will use 4 bytes to store the int32 (so 6 for the variant
containing it) and 6 bytes for the string.  The variant must be
aligned to 8 after the 6 bytes of the string, so that&#x2019;s 2 extra
bytes.  6 (string) + 2 (padding) + 6 (variant) is 14 bytes used
for the dictionary entry.  An additional 1 byte is added to the
array as a framing offset making a total of 15 bytes.

If we add another entry, &#x2018;title&#x2019; that maps to a nullable string
that happens to have a value of null, then we use 0 bytes for the
null value (and 3 bytes for the variant to contain it along with
its type string) plus 6 bytes for the string.  Again, we need 2
padding bytes.  That makes a total of 6 + 2 + 3 = 11 bytes.

We now require extra padding between the two items in the array.
After the 14 bytes of the first item, that&#x2019;s 2 bytes required.
We now require 2 framing offsets for an extra two
bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the entire two-item
dictionary.

## Type Information Cache

For each `GVariant` type that currently exists in the program a type
information structure is kept in the type information cache.  The
type information structure is required for rapid deserialization.

Continuing with the above example, if a `GVariant` exists with the
type `a{sv}` then a type information struct will exist for
`a{sv}`, `{sv}`, `s`, and `v`.  Multiple uses of the same type
will share the same type information.  Additionally, all
single-digit types are stored in read-only static memory and do
not contribute to the writable memory footprint of a program using
`GVariant`.

Aside from the type information structures stored in read-only
memory, there are two forms of type information.  One is used for
container types where there is a single element type: arrays and
maybe types.  The other is used for container types where there
are multiple element types: tuples and dictionary entries.

Array type info structures are `6 * sizeof (void *)`, plus the
memory required to store the type string itself.  This means that
on 32-bit systems, the cache entry for `a{sv}` would require 30
bytes of memory (plus allocation overhead).

Tuple type info structures are `6 * sizeof (void *)`, plus `4 *
sizeof (void *)` for each item in the tuple, plus the memory
required to store the type string itself.  A 2-item tuple, for
example, would have a type information structure that consumed
writable memory in the size of `14 * sizeof (void *)` (plus type
string)  This means that on 32-bit systems, the cache entry for
`{sv}` would require 61 bytes of memory (plus allocation overhead).

This means that in total, for our `a{sv}` example, 91 bytes of
type information would be allocated.

The type information cache, additionally, uses a [struct@GLib.HashTable] to
store and look up the cached items and stores a pointer to this
hash table in static storage.  The hash table is freed when there
are zero items in the type cache.

Although these sizes may seem large it is important to remember
that a program will probably only have a very small number of
different types of values in it and that only one type information
structure is required for many different values of the same type.

## Buffer Management Memory

`GVariant` uses an internal buffer management structure to deal
with the various different possible sources of serialized data
that it uses.  The buffer is responsible for ensuring that the
correct call is made when the data is no longer in use by
`GVariant`.  This may involve a [func@GLib.free] or
even [method@GLib.MappedFile.unref].

One buffer management structure is used for each chunk of
serialized data.  The size of the buffer management structure
is `4 * (void *)`.  On 32-bit systems, that&#x2019;s 16 bytes.

## GVariant structure

The size of a `GVariant` structure is `6 * (void *)`.  On 32-bit
systems, that&#x2019;s 24 bytes.

`GVariant` structures only exist if they are explicitly created
with API calls.  For example, if a `GVariant` is constructed out of
serialized data for the example given above (with the dictionary)
then although there are 9 individual values that comprise the
entire dictionary (two keys, two values, two variants containing
the values, two dictionary entries, plus the dictionary itself),
only 1 `GVariant` instance exists &#x2014; the one referring to the
dictionary.

If calls are made to start accessing the other values then
`GVariant` instances will exist for those values only for as long
as they are in use (ie: until you call [method@GLib.Variant.unref]).  The
type information is shared.  The serialized data and the buffer
management structure for that serialized data is shared by the
child.

## Summary

To put the entire example together, for our dictionary mapping
strings to variants (with two entries, as given above), we are
using 91 bytes of memory for type information, 29 bytes of memory
for the serialized data, 16 bytes for buffer management and 24
bytes for the `GVariant` instance, or a total of 160 bytes, plus
allocation overhead.  If we were to use [method@GLib.Variant.get_child_value]
to access the two dictionary entries, we would use an additional 48
bytes.  If we were to have other dictionaries of the same type, we
would use more memory for the serialized data and buffer
management for those dictionaries, but the type information would
be shared.</doc>
      <constructor name="new" c:identifier="g_variant_new" version="2.24" introspectable="0">
        <doc xml:space="preserve">Creates a new #GVariant instance.

Think of this function as an analogue to g_strdup_printf().

The type of the created instance and the arguments that are expected
by this function are determined by @format_string. See the section on
[GVariant format strings](gvariant-format-strings.html). Please note that
the syntax of the format string is very likely to be extended in the
future.

The first character of the format string must not be '*' '?' '@' or
'r'; in essence, a new #GVariant must always be constructed by this
function (and not merely passed through it unmodified).

Note that the arguments must be of the correct width for their types
specified in @format_string. This can be achieved by casting them. See
the [GVariant varargs documentation](gvariant-format-strings.html#varargs).

|[&lt;!-- language="C" --&gt;
MyFlags some_flags = FLAG_ONE | FLAG_TWO;
const gchar *some_strings[] = { "a", "b", "c", NULL };
GVariant *new_variant;

new_variant = g_variant_new ("(t^as)",
                             // This cast is required.
                             (guint64) some_flags,
                             some_strings);
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new floating #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments, as per @format_string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_array" c:identifier="g_variant_new_array" version="2.24">
        <doc xml:space="preserve">Creates a new #GVariant array from @children.

@child_type must be non-%NULL if @n_children is zero.  Otherwise, the
child type is determined by inspecting the first element of the
@children array.  If @child_type is non-%NULL then it must be a
definite type.

The items of the array are taken from the @children array.  No entry
in the @children array may be %NULL.

All items in the array must have the same type, which must be the
same as @child_type, if given.

If the @children are floating references (see g_variant_ref_sink()), the
new instance takes ownership of them as if via g_variant_ref_sink().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new #GVariant array</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="child_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the element type of the new array</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="children" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an array of
           #GVariant pointers, the children</doc>
            <array length="2" zero-terminated="0" c:type="GVariant* const*">
              <type name="Variant" c:type="GVariant*"/>
            </array>
          </parameter>
          <parameter name="n_children" transfer-ownership="none">
            <doc xml:space="preserve">the length of @children</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_boolean" c:identifier="g_variant_new_boolean" version="2.24">
        <doc xml:space="preserve">Creates a new boolean #GVariant instance -- either %TRUE or %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new boolean #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #gboolean value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_byte" c:identifier="g_variant_new_byte" version="2.24">
        <doc xml:space="preserve">Creates a new byte #GVariant instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new byte #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #guint8 value</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_bytestring" c:identifier="g_variant_new_bytestring" version="2.26">
        <doc xml:space="preserve">Creates an array-of-bytes #GVariant with the contents of @string.
This function is just like g_variant_new_string() except that the
string need not be valid UTF-8.

The nul terminator character at the end of the string is stored in
the array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new bytestring #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a normal
         nul-terminated string in no particular encoding</doc>
            <array c:type="const gchar*">
              <type name="guint8"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_bytestring_array" c:identifier="g_variant_new_bytestring_array" version="2.26">
        <doc xml:space="preserve">Constructs an array of bytestring #GVariant from the given array of
strings.

If @length is -1 then @strv is %NULL-terminated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new floating #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="strv" transfer-ownership="none">
            <doc xml:space="preserve">an array of strings</doc>
            <array length="1" zero-terminated="0" c:type="const gchar* const*">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @strv, or -1</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_dict_entry" c:identifier="g_variant_new_dict_entry" version="2.24">
        <doc xml:space="preserve">Creates a new dictionary entry #GVariant. @key and @value must be
non-%NULL. @key must be a value of a basic type (ie: not a container).

If the @key or @value are floating references (see g_variant_ref_sink()),
the new instance takes ownership of them as if via g_variant_ref_sink().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new dictionary entry #GVariant</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a basic #GVariant, the key</doc>
            <type name="Variant" c:type="GVariant*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant, the value</doc>
            <type name="Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_double" c:identifier="g_variant_new_double" version="2.24">
        <doc xml:space="preserve">Creates a new double #GVariant instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new double #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #gdouble floating point value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_fixed_array" c:identifier="g_variant_new_fixed_array" version="2.32">
        <doc xml:space="preserve">Constructs a new array #GVariant instance, where the elements are
of @element_type type.

@elements must be an array with fixed-sized elements.  Numeric types are
fixed-size as are tuples containing only other fixed-sized types.

@element_size must be the size of a single element in the array.
For example, if calling this function for an array of 32-bit integers,
you might say sizeof(gint32). This value isn't used except for the purpose
of a double-check that the form of the serialized data matches the caller's
expectation.

@n_elements must be the length of the @elements array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new array #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="element_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GVariantType of each element</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="elements" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to the fixed array of contiguous elements</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="n_elements" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="element_size" transfer-ownership="none">
            <doc xml:space="preserve">the size of each element</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_bytes" c:identifier="g_variant_new_from_bytes" version="2.36">
        <doc xml:space="preserve">Constructs a new serialized-mode #GVariant instance.  This is the
inner interface for creation of new serialized values that gets
called from various functions in gvariant.c.

A reference is taken on @bytes.

The data in @bytes must be aligned appropriately for the @type being loaded.
Otherwise this function will internally create a copy of the memory (since
GLib 2.60) or (in older versions) fail and exit the process.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #GVariant with a floating reference</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="trusted" transfer-ownership="none">
            <doc xml:space="preserve">if the contents of @bytes are trusted</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_data" c:identifier="g_variant_new_from_data" version="2.24">
        <doc xml:space="preserve">Creates a new #GVariant instance from serialized data.

@type is the type of #GVariant instance that will be constructed.
The interpretation of @data depends on knowing the type.

@data is not modified by this function and must remain valid with an
unchanging value until such a time as @notify is called with
@user_data.  If the contents of @data change before that time then
the result is undefined.

If @data is trusted to be serialized data in normal form then
@trusted should be %TRUE.  This applies to serialized data created
within this process or read from a trusted location on the disk (such
as a file installed in /usr/lib alongside your application).  You
should set trusted to %FALSE if @data is read from the network, a
file in the user's home directory, etc.

If @data was not stored in this machine's native endianness, any multi-byte
numeric values in the returned variant will also be in non-native
endianness. g_variant_byteswap() can be used to recover the original values.

@notify will be called with @user_data when @data is no longer
needed.  The exact time of this call is unspecified and might even be
before this function returns.

Note: @data must be backed by memory that is aligned appropriately for the
@type being loaded. Otherwise this function will internally create a copy of
the memory (since GLib 2.60) or (in older versions) fail and exit the
process.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new floating #GVariant of type @type</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a definite #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the serialized data</doc>
            <array length="2" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">the size of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="trusted" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @data is definitely in normal form</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">function to call when @data is no longer needed</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_handle" c:identifier="g_variant_new_handle" version="2.24">
        <doc xml:space="preserve">Creates a new handle #GVariant instance.

By convention, handles are indexes into an array of file descriptors
that are sent alongside a D-Bus message.  If you're not interacting
with D-Bus, you probably don't need them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new handle #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #gint32 value</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_int16" c:identifier="g_variant_new_int16" version="2.24">
        <doc xml:space="preserve">Creates a new int16 #GVariant instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new int16 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #gint16 value</doc>
            <type name="gint16" c:type="gint16"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_int32" c:identifier="g_variant_new_int32" version="2.24">
        <doc xml:space="preserve">Creates a new int32 #GVariant instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new int32 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #gint32 value</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_int64" c:identifier="g_variant_new_int64" version="2.24">
        <doc xml:space="preserve">Creates a new int64 #GVariant instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new int64 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #gint64 value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_maybe" c:identifier="g_variant_new_maybe" version="2.24">
        <doc xml:space="preserve">Depending on if @child is %NULL, either wraps @child inside of a
maybe container or creates a Nothing instance for the given @type.

At least one of @child_type and @child must be non-%NULL.
If @child_type is non-%NULL then it must be a definite type.
If they are both non-%NULL then @child_type must be the type
of @child.

If @child is a floating reference (see g_variant_ref_sink()), the new
instance takes ownership of @child.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new #GVariant maybe instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="child_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GVariantType of the child, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="child" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the child value, or %NULL</doc>
            <type name="Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_object_path" c:identifier="g_variant_new_object_path" version="2.24">
        <doc xml:space="preserve">Creates a D-Bus object path #GVariant with the contents of @object_path.
@object_path must be a valid D-Bus object path.  Use
g_variant_is_object_path() if you're not sure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new object path #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_objv" c:identifier="g_variant_new_objv" version="2.30">
        <doc xml:space="preserve">Constructs an array of object paths #GVariant from the given array of
strings.

Each string must be a valid #GVariant object path; see
g_variant_is_object_path().

If @length is -1 then @strv is %NULL-terminated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new floating #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="strv" transfer-ownership="none">
            <doc xml:space="preserve">an array of strings</doc>
            <array length="1" zero-terminated="0" c:type="const gchar* const*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @strv, or -1</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_parsed" c:identifier="g_variant_new_parsed" introspectable="0">
        <doc xml:space="preserve">Parses @format and returns the result.

@format must be a text format #GVariant with one extension: at any
point that a value may appear in the text, a '%' character followed
by a GVariant format string (as per g_variant_new()) may appear.  In
that case, the same arguments are collected from the argument list as
g_variant_new() would have collected.

Note that the arguments must be of the correct width for their types
specified in @format. This can be achieved by casting them. See
the [GVariant varargs documentation](gvariant-format-strings.html#varargs).

Consider this simple example:
|[&lt;!-- language="C" --&gt;
 g_variant_new_parsed ("[('one', 1), ('two', %i), (%s, 3)]", 2, "three");
]|

In the example, the variable argument parameters are collected and
filled in as if they were part of the original string to produce the
result of
|[&lt;!-- language="C" --&gt;
[('one', 1), ('two', 2), ('three', 3)]
]|

This function is intended only to be used with @format as a string
literal.  Any parse error is fatal to the calling process.  If you
want to parse data from untrusted sources, use g_variant_parse().

You may not use this function to return, unmodified, a single
#GVariant pointer from the argument list.  ie: @format may not solely
be anything along the lines of "%*", "%?", "\%r", or anything starting
with "%@".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new floating #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a text format #GVariant</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments as per @format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_parsed_va" c:identifier="g_variant_new_parsed_va" introspectable="0">
        <doc xml:space="preserve">Parses @format and returns the result.

This is the version of g_variant_new_parsed() intended to be used
from libraries.

The return value will be floating if it was a newly created GVariant
instance.  In the case that @format simply specified the collection
of a #GVariant pointer (eg: @format was "%*") then the collected
#GVariant pointer will be returned unmodified, without adding any
additional references.

Note that the arguments in @app must be of the correct width for their types
specified in @format when collected into the #va_list. See
the [GVariant varargs documentation](gvariant-format-strings.html#varargs).

In order to behave correctly in all cases it is necessary for the
calling function to g_variant_ref_sink() the return result before
returning control to the user that originally provided the pointer.
At this point, the caller will have their own full reference to the
result.  This can also be done by adding the result to a container,
or by passing it to another g_variant_new() call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new, usually floating, #GVariant</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a text format #GVariant</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="app" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #va_list</doc>
            <type name="va_list" c:type="va_list*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_printf" c:identifier="g_variant_new_printf" version="2.38" introspectable="0">
        <doc xml:space="preserve">Creates a string-type GVariant using printf formatting.

This is similar to calling g_strdup_printf() and then
g_variant_new_string() but it saves a temporary variable and an
unnecessary copy.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new string
  #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a printf-style format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments for @format_string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_signature" c:identifier="g_variant_new_signature" version="2.24">
        <doc xml:space="preserve">Creates a D-Bus type signature #GVariant with the contents of
@string.  @string must be a valid D-Bus type signature.  Use
g_variant_is_signature() if you're not sure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new signature #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="signature" transfer-ownership="none">
            <doc xml:space="preserve">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_string" c:identifier="g_variant_new_string" version="2.24">
        <doc xml:space="preserve">Creates a string #GVariant with the contents of @string.

@string must be valid UTF-8, and must not be %NULL. To encode
potentially-%NULL strings, use g_variant_new() with `ms` as the
[format string](gvariant-format-strings.html#maybe-types).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new string #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a normal UTF-8 nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_strv" c:identifier="g_variant_new_strv" version="2.24">
        <doc xml:space="preserve">Constructs an array of strings #GVariant from the given array of
strings.

If @length is -1 then @strv is %NULL-terminated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new floating #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="strv" transfer-ownership="none">
            <doc xml:space="preserve">an array of strings</doc>
            <array length="1" zero-terminated="0" c:type="const gchar* const*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @strv, or -1</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_take_string" c:identifier="g_variant_new_take_string" version="2.38" introspectable="0">
        <doc xml:space="preserve">Creates a string #GVariant with the contents of @string.

@string must be valid UTF-8, and must not be %NULL. To encode
potentially-%NULL strings, use this with g_variant_new_maybe().

After this call, @string belongs to the #GVariant and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with g_free().

You must not modify or access @string in any other way after passing
it to this function.  It is even possible that @string is immediately
freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new string
  #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a normal UTF-8 nul-terminated string</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_tuple" c:identifier="g_variant_new_tuple" version="2.24">
        <doc xml:space="preserve">Creates a new tuple #GVariant out of the items in @children.  The
type is determined from the types of @children.  No entry in the
@children array may be %NULL.

If @n_children is 0 then the unit tuple is constructed.

If the @children are floating references (see g_variant_ref_sink()), the
new instance takes ownership of them as if via g_variant_ref_sink().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new #GVariant tuple</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="children" transfer-ownership="none">
            <doc xml:space="preserve">the items to make the tuple out of</doc>
            <array length="1" zero-terminated="0" c:type="GVariant* const*">
              <type name="Variant" c:type="GVariant*"/>
            </array>
          </parameter>
          <parameter name="n_children" transfer-ownership="none">
            <doc xml:space="preserve">the length of @children</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_uint16" c:identifier="g_variant_new_uint16" version="2.24">
        <doc xml:space="preserve">Creates a new uint16 #GVariant instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new uint16 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #guint16 value</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_uint32" c:identifier="g_variant_new_uint32" version="2.24">
        <doc xml:space="preserve">Creates a new uint32 #GVariant instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new uint32 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #guint32 value</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_uint64" c:identifier="g_variant_new_uint64" version="2.24">
        <doc xml:space="preserve">Creates a new uint64 #GVariant instance.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new uint64 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #guint64 value</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_va" c:identifier="g_variant_new_va" version="2.24" introspectable="0">
        <doc xml:space="preserve">This function is intended to be used by libraries based on
#GVariant that want to provide g_variant_new()-like functionality
to their users.

The API is more general than g_variant_new() to allow a wider range
of possible uses.

@format_string must still point to a valid format string, but it only
needs to be nul-terminated if @endptr is %NULL.  If @endptr is
non-%NULL then it is updated to point to the first character past the
end of the format string.

@app is a pointer to a #va_list.  The arguments, according to
@format_string, are collected from this #va_list and the list is left
pointing to the argument following the last.

Note that the arguments in @app must be of the correct width for their
types specified in @format_string when collected into the #va_list.
See the [GVariant varargs documentation](gvariant-format-strings.html#varargs).

These two generalisations allow mixing of multiple calls to
g_variant_new_va() and g_variant_get_va() within a single actual
varargs call by the user.

The return value will be floating if it was a newly created GVariant
instance (for example, if the format string was "(ii)").  In the case
that the format_string was '*', '?', 'r', or a format starting with
'@' then the collected #GVariant pointer will be returned unmodified,
without adding any additional references.

In order to behave correctly in all cases it is necessary for the
calling function to g_variant_ref_sink() the return result before
returning control to the user that originally provided the pointer.
At this point, the caller will have their own full reference to the
result.  This can also be done by adding the result to a container,
or by passing it to another g_variant_new() call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new, usually floating, #GVariant</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a string that is prefixed with a format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="endptr" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">location to store the end pointer,
         or %NULL</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="app" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #va_list</doc>
            <type name="va_list" c:type="va_list*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_variant" c:identifier="g_variant_new_variant" version="2.24">
        <doc xml:space="preserve">Boxes @value.  The result is a #GVariant instance representing a
variant containing the original value.

If @child is a floating reference (see g_variant_ref_sink()), the new
instance takes ownership of @child.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new variant #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="byteswap" c:identifier="g_variant_byteswap" version="2.24">
        <doc xml:space="preserve">Performs a byteswapping operation on the contents of @value.  The
result is that all multi-byte numeric data contained in @value is
byteswapped.  That includes 16, 32, and 64bit signed and unsigned
integers as well as file handles and double precision floating point
values.

This function is an identity mapping on any value that does not
contain multi-byte numeric data.  That include strings, booleans,
bytes and containers containing only these things (recursively).

While this function can safely handle untrusted, non-normal data, it is
recommended to check whether the input is in normal form beforehand, using
g_variant_is_normal_form(), and to reject non-normal inputs if your
application can be strict about what inputs it rejects.

The returned value is always in normal form and is marked as trusted.
A full, not floating, reference is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the byteswapped form of @value</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="check_format_string" c:identifier="g_variant_check_format_string" version="2.34">
        <doc xml:space="preserve">Checks if calling g_variant_get() with @format_string on @value would
be valid from a type-compatibility standpoint.  @format_string is
assumed to be a valid format string (from a syntactic standpoint).

If @copy_only is %TRUE then this function additionally checks that it
would be safe to call g_variant_unref() on @value immediately after
the call to g_variant_get() without invalidating the result.  This is
only possible if deep copies are made (ie: there are no pointers to
the data inside of the soon-to-be-freed #GVariant instance).  If this
check fails then a g_critical() is printed and %FALSE is returned.

This function is meant to be used by functions that wish to provide
varargs accessors to #GVariant values of uncertain values (eg:
g_variant_lookup() or g_menu_model_get_item_attribute()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @format_string is safe to use</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="copy_only" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to ensure the format string makes deep copies</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="classify" c:identifier="g_variant_classify" version="2.24">
        <doc xml:space="preserve">Classifies @value according to its top-level type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GVariantClass of @value</doc>
          <type name="VariantClass" c:type="GVariantClass"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="compare" c:identifier="g_variant_compare" version="2.26">
        <doc xml:space="preserve">Compares @one and @two.

The types of @one and @two are #gconstpointer only to allow use of
this function with #GTree, #GPtrArray, etc.  They must each be a
#GVariant.

Comparison is only defined for basic types (ie: booleans, numbers,
strings).  For booleans, %FALSE is less than %TRUE.  Numbers are
ordered in the usual way.  Strings are in ASCII lexographical order.

It is a programmer error to attempt to compare container values or
two values that have types that are not exactly equal.  For example,
you cannot compare a 32-bit signed integer with a 32-bit unsigned
integer.  Also note that this function is not particularly
well-behaved when it comes to comparison of doubles; in particular,
the handling of incomparable values (ie: NaN) is undefined.

If you only require an equality comparison, g_variant_equal() is more
general.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">negative value if a &lt; b;
         zero if a = b;
         positive value if a &gt; b.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="one" transfer-ownership="none">
            <doc xml:space="preserve">a basic-typed #GVariant instance</doc>
            <type name="Variant" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="two" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant instance of the same type</doc>
            <type name="Variant" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_bytestring" c:identifier="g_variant_dup_bytestring" version="2.26">
        <doc xml:space="preserve">Similar to g_variant_get_bytestring() except that instead of
returning a constant string, the string is duplicated.

The return value must be freed using g_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
         a newly allocated string</doc>
          <array length="0" zero-terminated="1" c:type="gchar*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an array-of-bytes #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a pointer to a #gsize, to store
         the length (not including the nul terminator)</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_bytestring_array" c:identifier="g_variant_dup_bytestring_array" version="2.26">
        <doc xml:space="preserve">Gets the contents of an array of array of bytes #GVariant.  This call
makes a deep copy; the return result should be released with
g_strfreev().

If @length is non-%NULL then the number of elements in the result is
stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an array of strings</doc>
          <array length="0" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an array of array of bytes #GVariant ('aay')</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_objv" c:identifier="g_variant_dup_objv" version="2.30">
        <doc xml:space="preserve">Gets the contents of an array of object paths #GVariant.  This call
makes a deep copy; the return result should be released with
g_strfreev().

If @length is non-%NULL then the number of elements in the result
is stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an array of strings</doc>
          <array length="0" zero-terminated="1" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an array of object paths #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_string" c:identifier="g_variant_dup_string" version="2.24">
        <doc xml:space="preserve">Similar to g_variant_get_string() except that instead of returning
a constant string, the string is duplicated.

The string will always be UTF-8 encoded.

The return value must be freed using g_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string, UTF-8 encoded</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a string #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a pointer to a #gsize, to store the length</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_strv" c:identifier="g_variant_dup_strv" version="2.24">
        <doc xml:space="preserve">Gets the contents of an array of strings #GVariant.  This call
makes a deep copy; the return result should be released with
g_strfreev().

If @length is non-%NULL then the number of elements in the result
is stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an array of strings</doc>
          <array length="0" zero-terminated="1" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an array of strings #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="g_variant_equal" version="2.24">
        <doc xml:space="preserve">Checks if @one and @two have the same type and value.

The types of @one and @two are #gconstpointer only to allow use of
this function with #GHashTable.  They must each be a #GVariant.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @one and @two are equal</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="one" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant instance</doc>
            <type name="Variant" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="two" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant instance</doc>
            <type name="Variant" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="g_variant_get" version="2.24" introspectable="0">
        <doc xml:space="preserve">Deconstructs a #GVariant instance.

Think of this function as an analogue to scanf().

The arguments that are expected by this function are entirely
determined by @format_string.  @format_string also restricts the
permissible types of @value.  It is an error to give a value with
an incompatible type.  See the section on
[GVariant format strings](gvariant-format-strings.html).
Please note that the syntax of the format string is very likely to be
extended in the future.

@format_string determines the C types that are used for unpacking
the values and also determines if the values are copied or borrowed,
see the section on
[`GVariant` format strings](gvariant-format-strings.html#pointers).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments, as per @format_string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean" c:identifier="g_variant_get_boolean" version="2.24">
        <doc xml:space="preserve">Returns the boolean value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_BOOLEAN.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE or %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a boolean #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_byte" c:identifier="g_variant_get_byte" version="2.24">
        <doc xml:space="preserve">Returns the byte value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_BYTE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #guint8</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a byte #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bytestring" c:identifier="g_variant_get_bytestring" version="2.26">
        <doc xml:space="preserve">Returns the string value of a #GVariant instance with an
array-of-bytes type.  The string has no particular encoding.

If the array does not end with a nul terminator character, the empty
string is returned.  For this reason, you can always trust that a
non-%NULL nul-terminated string will be returned by this function.

If the array contains a nul terminator character somewhere other than
the last byte then the returned string is the string, up to the first
such nul character.

g_variant_get_fixed_array() should be used instead if the array contains
arbitrary data that could not be nul-terminated or could contain nul bytes.

It is an error to call this function with a @value that is not an
array of bytes.

The return value remains valid as long as @value exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
         the constant string</doc>
          <array c:type="const gchar*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an array-of-bytes #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bytestring_array" c:identifier="g_variant_get_bytestring_array" version="2.26">
        <doc xml:space="preserve">Gets the contents of an array of array of bytes #GVariant.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.

If @length is non-%NULL then the number of elements in the result is
stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">an array of constant strings</doc>
          <array length="0" zero-terminated="0" c:type="const gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an array of array of bytes #GVariant ('aay')</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_child" c:identifier="g_variant_get_child" version="2.24" introspectable="0">
        <doc xml:space="preserve">Reads a child item out of a container #GVariant instance and
deconstructs it according to @format_string.  This call is
essentially a combination of g_variant_get_child_value() and
g_variant_get().

@format_string determines the C types that are used for unpacking
the values and also determines if the values are copied or borrowed,
see the section on
[`GVariant` format strings](gvariant-format-strings.html#pointers).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a container #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the child to deconstruct</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments, as per @format_string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_child_value" c:identifier="g_variant_get_child_value" version="2.24">
        <doc xml:space="preserve">Reads a child item out of a container #GVariant instance.  This
includes variants, maybes, arrays, tuples and dictionary
entries.  It is an error to call this function on any other type of
#GVariant.

It is an error if @index_ is greater than the number of child items
in the container.  See g_variant_n_children().

The returned value is never floating.  You should free it with
g_variant_unref() when you're done with it.

Note that values borrowed from the returned child are not guaranteed to
still be valid after the child is freed even if you still hold a reference
to @value, if @value has not been serialized at the time this function is
called. To avoid this, you can serialize @value by calling
g_variant_get_data() and optionally ignoring the return value.

There may be implementation specific restrictions on deeply nested values,
which would result in the unit tuple being returned as the child value,
instead of further nested children. #GVariant is guaranteed to handle
nesting up to at least 64 levels.

This function is O(1).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the child at the specified index</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a container #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the child to fetch</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="g_variant_get_data" version="2.24">
        <doc xml:space="preserve">Returns a pointer to the serialized form of a #GVariant instance.
The returned data may not be in fully-normalised form if read from an
untrusted source.  The returned data must not be freed; it remains
valid for as long as @value exists.

If @value is a fixed-sized value that was deserialized from a
corrupted serialized container then %NULL may be returned.  In this
case, the proper thing to do is typically to use the appropriate
number of nul bytes in place of @value.  If @value is not fixed-sized
then %NULL is never returned.

In the case that @value is already in serialized form, this function
is O(1).  If the value is not already in serialized form,
serialization occurs implicitly and is approximately O(n) in the size
of the result.

To deserialize the data returned by this function, in addition to the
serialized data, you must know the type of the #GVariant, and (if the
machine might be different) the endianness of the machine that stored
it. As a result, file formats or network messages that incorporate
serialized #GVariants must include this information either
implicitly (for instance "the file always contains a
%G_VARIANT_TYPE_VARIANT and it is always in little-endian order") or
explicitly (by storing the type and/or endianness in addition to the
serialized data).</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the serialized form of @value, or %NULL</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data_as_bytes" c:identifier="g_variant_get_data_as_bytes" version="2.36">
        <doc xml:space="preserve">Returns a pointer to the serialized form of a #GVariant instance.
The semantics of this function are exactly the same as
g_variant_get_data(), except that the returned #GBytes holds
a reference to the variant data.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GBytes representing the variant data</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="g_variant_get_double" version="2.24">
        <doc xml:space="preserve">Returns the double precision floating point value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_DOUBLE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gdouble</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a double #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fixed_array" c:identifier="g_variant_get_fixed_array" version="2.24" introspectable="0">
        <doc xml:space="preserve">Provides access to the serialized data for an array of fixed-sized
items.

@value must be an array with fixed-sized elements.  Numeric types are
fixed-size, as are tuples containing only other fixed-sized types.

@element_size must be the size of a single element in the array,
as given by the section on
[serialized data memory](struct.Variant.html#serialized-data-memory).

In particular, arrays of these fixed-sized types can be interpreted
as an array of the given C type, with @element_size set to the size
the appropriate type:
- %G_VARIANT_TYPE_INT16 (etc.): #gint16 (etc.)
- %G_VARIANT_TYPE_BOOLEAN: #guchar (not #gboolean!)
- %G_VARIANT_TYPE_BYTE: #guint8
- %G_VARIANT_TYPE_HANDLE: #guint32
- %G_VARIANT_TYPE_DOUBLE: #gdouble

For example, if calling this function for an array of 32-bit integers,
you might say `sizeof(gint32)`. This value isn't used except for the purpose
of a double-check that the form of the serialized data matches the caller's
expectation.

@n_elements, which must be non-%NULL, is set equal to the number of
items in the array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to
    the fixed array</doc>
          <array length="0" zero-terminated="0" c:type="gconstpointer">
            <type name="gpointer" c:type="gconstpointer"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant array with fixed-sized elements</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="n_elements" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a pointer to the location to store the number of items</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="element_size" transfer-ownership="none">
            <doc xml:space="preserve">the size of each element</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_handle" c:identifier="g_variant_get_handle" version="2.24">
        <doc xml:space="preserve">Returns the 32-bit signed integer value of @value.

It is an error to call this function with a @value of any type other
than %G_VARIANT_TYPE_HANDLE.

By convention, handles are indexes into an array of file descriptors
that are sent alongside a D-Bus message.  If you're not interacting
with D-Bus, you probably don't need them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gint32</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a handle #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_int16" c:identifier="g_variant_get_int16" version="2.24">
        <doc xml:space="preserve">Returns the 16-bit signed integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_INT16.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gint16</doc>
          <type name="gint16" c:type="gint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an int16 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_int32" c:identifier="g_variant_get_int32" version="2.24">
        <doc xml:space="preserve">Returns the 32-bit signed integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_INT32.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gint32</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an int32 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_int64" c:identifier="g_variant_get_int64" version="2.24">
        <doc xml:space="preserve">Returns the 64-bit signed integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_INT64.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gint64</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an int64 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_maybe" c:identifier="g_variant_get_maybe" version="2.24">
        <doc xml:space="preserve">Given a maybe-typed #GVariant instance, extract its value.  If the
value is Nothing, then this function returns %NULL.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the contents of @value, or %NULL</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a maybe-typed value</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_normal_form" c:identifier="g_variant_get_normal_form" version="2.24">
        <doc xml:space="preserve">Gets a #GVariant instance that has the same value as @value and is
trusted to be in normal form.

If @value is already trusted to be in normal form then a new
reference to @value is returned.

If @value is not already trusted, then it is scanned to check if it
is in normal form.  If it is found to be in normal form then it is
marked as trusted and a new reference to it is returned.

If @value is found not to be in normal form then a new trusted
#GVariant is created with the same value as @value. The non-normal parts of
@value will be replaced with default values which are guaranteed to be in
normal form.

It makes sense to call this function if you've received #GVariant
data from untrusted sources and you want to ensure your serialized
output is definitely in normal form.

If @value is already in normal form, a new reference will be returned
(which will be floating if @value is floating). If it is not in normal form,
the newly created #GVariant will be returned with a single non-floating
reference. Typically, g_variant_take_ref() should be called on the return
value from this function to guarantee ownership of a single non-floating
reference to it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a trusted #GVariant</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_objv" c:identifier="g_variant_get_objv" version="2.30">
        <doc xml:space="preserve">Gets the contents of an array of object paths #GVariant.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.

If @length is non-%NULL then the number of elements in the result
is stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">an array of constant strings</doc>
          <array length="0" zero-terminated="1" c:type="const gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an array of object paths #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="g_variant_get_size" version="2.24">
        <doc xml:space="preserve">Determines the number of bytes that would be required to store @value
with g_variant_store().

If @value has a fixed-sized type then this function always returned
that fixed size.

In the case that @value is already in serialized form or the size has
already been calculated (ie: this function has been called before)
then this function is O(1).  Otherwise, the size is calculated, an
operation which is approximately O(n) in the number of values
involved.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the serialized size of @value</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="g_variant_get_string" version="2.24">
        <doc xml:space="preserve">Returns the string value of a #GVariant instance with a string
type.  This includes the types %G_VARIANT_TYPE_STRING,
%G_VARIANT_TYPE_OBJECT_PATH and %G_VARIANT_TYPE_SIGNATURE.

The string will always be UTF-8 encoded, will never be %NULL, and will never
contain nul bytes.

If @length is non-%NULL then the length of the string (in bytes) is
returned there.  For trusted values, this information is already
known.  Untrusted values will be validated and, if valid, a strlen() will be
performed. If invalid, a default value will be returned &#x2014; for
%G_VARIANT_TYPE_OBJECT_PATH, this is `"/"`, and for other types it is the
empty string.

It is an error to call this function with a @value of any type
other than those three.

The return value remains valid as long as @value exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the constant string, UTF-8 encoded</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a string #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">a pointer to a #gsize,
         to store the length</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_strv" c:identifier="g_variant_get_strv" version="2.24">
        <doc xml:space="preserve">Gets the contents of an array of strings #GVariant.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.

If @length is non-%NULL then the number of elements in the result
is stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">an array of constant strings</doc>
          <array length="0" zero-terminated="1" c:type="const gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">an array of strings #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_type" c:identifier="g_variant_get_type" version="2.24">
        <doc xml:space="preserve">Determines the type of @value.

The return value is valid for the lifetime of @value and must not
be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GVariantType</doc>
          <type name="VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_type_string" c:identifier="g_variant_get_type_string" version="2.24">
        <doc xml:space="preserve">Returns the type string of @value.  Unlike the result of calling
g_variant_type_peek_string(), this string is nul-terminated.  This
string belongs to #GVariant and must not be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type string for the type of @value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uint16" c:identifier="g_variant_get_uint16" version="2.24">
        <doc xml:space="preserve">Returns the 16-bit unsigned integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_UINT16.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #guint16</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a uint16 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uint32" c:identifier="g_variant_get_uint32" version="2.24">
        <doc xml:space="preserve">Returns the 32-bit unsigned integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_UINT32.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #guint32</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a uint32 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uint64" c:identifier="g_variant_get_uint64" version="2.24">
        <doc xml:space="preserve">Returns the 64-bit unsigned integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_UINT64.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #guint64</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a uint64 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_va" c:identifier="g_variant_get_va" version="2.24" introspectable="0">
        <doc xml:space="preserve">This function is intended to be used by libraries based on #GVariant
that want to provide g_variant_get()-like functionality to their
users.

The API is more general than g_variant_get() to allow a wider range
of possible uses.

@format_string must still point to a valid format string, but it only
need to be nul-terminated if @endptr is %NULL.  If @endptr is
non-%NULL then it is updated to point to the first character past the
end of the format string.

@app is a pointer to a #va_list.  The arguments, according to
@format_string, are collected from this #va_list and the list is left
pointing to the argument following the last.

These two generalisations allow mixing of multiple calls to
g_variant_new_va() and g_variant_get_va() within a single actual
varargs call by the user.

@format_string determines the C types that are used for unpacking
the values and also determines if the values are copied or borrowed,
see the section on
[`GVariant` format strings](gvariant-format-strings.html#pointers).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a string that is prefixed with a format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="endptr" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">location to store the end pointer,
         or %NULL</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="app" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #va_list</doc>
            <type name="va_list" c:type="va_list*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_variant" c:identifier="g_variant_get_variant" version="2.24">
        <doc xml:space="preserve">Unboxes @value.  The result is the #GVariant instance that was
contained in @value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the item contained in the variant</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a variant #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="g_variant_hash" version="2.24">
        <doc xml:space="preserve">Generates a hash value for a #GVariant instance.

The output of this function is guaranteed to be the same for a given
value only per-process.  It may change between different processor
architectures or even different versions of GLib.  Do not use this
function as a basis for building protocols or file formats.

The type of @value is #gconstpointer only to allow use of this
function with #GHashTable.  @value must be a #GVariant.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a hash value corresponding to @value</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a basic #GVariant value as a #gconstpointer</doc>
            <type name="Variant" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_container" c:identifier="g_variant_is_container" version="2.24">
        <doc xml:space="preserve">Checks if @value is a container.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @value is a container</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_floating" c:identifier="g_variant_is_floating" version="2.26">
        <doc xml:space="preserve">Checks whether @value has a floating reference count.

This function should only ever be used to assert that a given variant
is or is not floating, or for debug purposes. To acquire a reference
to a variant that might be floating, always use g_variant_ref_sink()
or g_variant_take_ref().

See g_variant_ref_sink() for more information about floating reference
counts.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @value is floating</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_normal_form" c:identifier="g_variant_is_normal_form" version="2.24">
        <doc xml:space="preserve">Checks if @value is in normal form.

The main reason to do this is to detect if a given chunk of
serialized data is in normal form: load the data into a #GVariant
using g_variant_new_from_data() and then use this function to
check.

If @value is found to be in normal form then it will be marked as
being trusted.  If the value was already marked as being trusted then
this function will immediately return %TRUE.

There may be implementation specific restrictions on deeply nested values.
GVariant is guaranteed to handle nesting up to at least 64 levels.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @value is in normal form</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_of_type" c:identifier="g_variant_is_of_type" version="2.24">
        <doc xml:space="preserve">Checks if a value has a type matching the provided type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the type of @value matches @type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_new" c:identifier="g_variant_iter_new" version="2.24" introspectable="0">
        <doc xml:space="preserve">Creates a heap-allocated #GVariantIter for iterating over the items
in @value.

Use g_variant_iter_free() to free the return value when you no longer
need it.

A reference is taken to @value and will be released only when
g_variant_iter_free() is called.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new heap-allocated #GVariantIter</doc>
          <type name="VariantIter" c:type="GVariantIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a container #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="g_variant_lookup" version="2.28" introspectable="0">
        <doc xml:space="preserve">Looks up a value in a dictionary #GVariant.

This function is a wrapper around g_variant_lookup_value() and
g_variant_get().  In the case that %NULL would have been returned,
this function returns %FALSE.  Otherwise, it unpacks the returned
value and returns %TRUE.

@format_string determines the C types that are used for unpacking
the values and also determines if the values are copied or borrowed,
see the section on
[`GVariant` format strings](gvariant-format-strings.html#pointers).

This function is currently implemented with a linear scan.  If you
plan to do many lookups then #GVariantDict may be more efficient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a value was unpacked</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dictionary" transfer-ownership="none">
            <doc xml:space="preserve">a dictionary #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to look up in the dictionary</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the arguments to unpack the value into</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_value" c:identifier="g_variant_lookup_value" version="2.28">
        <doc xml:space="preserve">Looks up a value in a dictionary #GVariant.

This function works with dictionaries of the type a{s*} (and equally
well with type a{o*}, but we only further discuss the string case
for sake of clarity).

In the event that @dictionary has the type a{sv}, the @expected_type
string specifies what type of value is expected to be inside of the
variant. If the value inside the variant has a different type then
%NULL is returned. In the event that @dictionary has a value type other
than v then @expected_type must directly match the value type and it is
used to unpack the value directly or an error occurs.

In either case, if @key is not found in @dictionary, %NULL is returned.

If the key is found and the value has the correct type, it is
returned.  If @expected_type was specified then any non-%NULL return
value will have this type.

This function is currently implemented with a linear scan.  If you
plan to do many lookups then #GVariantDict may be more efficient.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the value of the dictionary key, or %NULL</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dictionary" transfer-ownership="none">
            <doc xml:space="preserve">a dictionary #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to look up in the dictionary</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="expected_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariantType, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="n_children" c:identifier="g_variant_n_children" version="2.24">
        <doc xml:space="preserve">Determines the number of children in a container #GVariant instance.
This includes variants, maybes, arrays, tuples and dictionary
entries.  It is an error to call this function on any other type of
#GVariant.

For variants, the return value is always 1.  For values with maybe
types, it is always zero or one.  For arrays, it is the length of the
array.  For tuples it is the number of tuple items (which depends
only on the type).  For dictionary entries, it is always 2

This function is O(1).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of children in the container</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a container #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="print" c:identifier="g_variant_print" version="2.24">
        <doc xml:space="preserve">Pretty-prints @value in the format understood by g_variant_parse().

The format is described [here](gvariant-text-format.html).

If @type_annotate is %TRUE, then type information is included in
the output.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated string holding the result.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="type_annotate" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if type information should be included in
                the output</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="print_string" c:identifier="g_variant_print_string" version="2.24" introspectable="0">
        <doc xml:space="preserve">Behaves as g_variant_print(), but operates on a #GString.

If @string is non-%NULL then it is appended to and returned.  Else,
a new empty #GString is allocated and it is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GString containing the string</doc>
          <type name="String" c:type="GString*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GString, or %NULL</doc>
            <type name="String" c:type="GString*"/>
          </parameter>
          <parameter name="type_annotate" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if type information should be included in
                the output</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_variant_ref" version="2.24">
        <doc xml:space="preserve">Increases the reference count of @value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the same @value</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref_sink" c:identifier="g_variant_ref_sink" version="2.24">
        <doc xml:space="preserve">#GVariant uses a floating reference count system.  All functions with
names starting with `g_variant_new_` return floating
references.

Calling g_variant_ref_sink() on a #GVariant with a floating reference
will convert the floating reference into a full reference.  Calling
g_variant_ref_sink() on a non-floating #GVariant results in an
additional normal reference being added.

In other words, if the @value is floating, then this call "assumes
ownership" of the floating reference, converting it to a normal
reference.  If the @value is not floating, then this call adds a
new normal reference increasing the reference count by one.

All calls that result in a #GVariant instance being inserted into a
container will call g_variant_ref_sink() on the instance.  This means
that if the value was just created (and has only its floating
reference) then the container will assume sole ownership of the value
at that point and the caller will not need to unreference it.  This
makes certain common styles of programming much easier while still
maintaining normal refcounting semantics in situations where values
are not floating.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the same @value</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="store" c:identifier="g_variant_store" version="2.24">
        <doc xml:space="preserve">Stores the serialized form of @value at @data.  @data should be
large enough.  See g_variant_get_size().

The stored data is in machine native byte order but may not be in
fully-normalised form if read from an untrusted source.  See
g_variant_get_normal_form() for a solution.

As with g_variant_get_data(), to be able to deserialize the
serialized variant successfully, its type and (if the destination
machine might be different) its endianness must also be available.

This function is approximately O(n) in the size of @data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the #GVariant to store</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the location to store the serialized data at</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_ref" c:identifier="g_variant_take_ref">
        <doc xml:space="preserve">If @value is floating, sink it.  Otherwise, do nothing.

Typically you want to use g_variant_ref_sink() in order to
automatically do the correct thing with respect to floating or
non-floating references, but there is one specific scenario where
this function is helpful.

The situation where this function is helpful is when creating an API
that allows the user to provide a callback function that returns a
#GVariant.  We certainly want to allow the user the flexibility to
return a non-floating reference from this callback (for the case
where the value that is being returned already exists).

At the same time, the style of the #GVariant API makes it likely that
for newly-created #GVariant instances, the user can be saved some
typing if they are allowed to return a #GVariant with a floating
reference.

Using this function on the return value of the user's callback allows
the user to do whichever is more convenient for them.  The caller
will always receives exactly one full reference to the value: either
the one that was returned in the first place, or a floating reference
that has been converted to a full reference.

This function has an odd interaction when combined with
g_variant_ref_sink() running at the same time in another thread on
the same #GVariant instance.  If g_variant_ref_sink() runs first then
the result will be that the floating reference is converted to a hard
reference.  If g_variant_take_ref() runs first then the result will
be that the floating reference is converted to a hard reference and
an additional reference on top of that one is added.  It is best to
avoid this situation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the same @value</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_variant_unref" version="2.24">
        <doc xml:space="preserve">Decreases the reference count of @value.  When its reference count
drops to 0, the memory used by the variant is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="is_object_path" c:identifier="g_variant_is_object_path" version="2.24">
        <doc xml:space="preserve">Determines if a given string is a valid D-Bus object path.  You
should ensure that a string is a valid D-Bus object path before
passing it to g_variant_new_object_path().

A valid object path starts with `/` followed by zero or more
sequences of characters separated by `/` characters.  Each sequence
must contain only the characters `[A-Z][a-z][0-9]_`.  No sequence
(including the one following the final `/` character) may be empty.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @string is a D-Bus object path</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_signature" c:identifier="g_variant_is_signature" version="2.24">
        <doc xml:space="preserve">Determines if a given string is a valid D-Bus type signature.  You
should ensure that a string is a valid D-Bus type signature before
passing it to g_variant_new_signature().

D-Bus type signatures consist of zero or more definite #GVariantType
strings in sequence.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @string is a D-Bus type signature</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse" c:identifier="g_variant_parse" throws="1">
        <doc xml:space="preserve">Parses a #GVariant from a text representation.

A single #GVariant is parsed from the content of @text.

The format is described [here](gvariant-text-format.html).

The memory at @limit will never be accessed and the parser behaves as
if the character at @limit is the nul terminator.  This has the
effect of bounding @text.

If @endptr is non-%NULL then @text is permitted to contain data
following the value that this function parses and @endptr will be
updated to point to the first character past the end of the text
parsed by this function.  If @endptr is %NULL and there is extra data
then an error is returned.

If @type is non-%NULL then the value will be parsed to have that
type.  This may result in additional parse errors (in the case that
the parsed value doesn't fit the type) but may also result in fewer
errors (in the case that the type would have been ambiguous, such as
with empty arrays).

In the event that the parsing is successful, the resulting #GVariant
is returned. It is never floating, and must be freed with
[method@GLib.Variant.unref].

In case of any error, %NULL will be returned.  If @error is non-%NULL
then it will be set to reflect the error that occurred.

Officially, the language understood by the parser is &#x201C;any string
produced by [method@GLib.Variant.print]&#x201D;. This explicitly includes
`g_variant_print()`&#x2019;s annotated types like `int64 -1000`.

There may be implementation specific restrictions on deeply nested values,
which would result in a %G_VARIANT_PARSE_ERROR_RECURSION error. #GVariant is
guaranteed to handle nesting up to at least 64 levels.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a non-floating reference to a #GVariant, or %NULL</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariantType, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">a string containing a GVariant in text form</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="limit" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a pointer to the end of @text, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="endptr" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a location to store the end pointer, or %NULL</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_error_print_context" c:identifier="g_variant_parse_error_print_context" version="2.40">
        <doc xml:space="preserve">Pretty-prints a message showing the context of a #GVariant parse
error within the string for which parsing was attempted.

The resulting string is suitable for output to the console or other
monospace media where newlines are treated in the usual way.

The message will typically look something like one of the following:

|[
unterminated string constant:
  (1, 2, 3, 'abc
            ^^^^
]|

or

|[
unable to find a common type:
  [1, 2, 3, 'str']
   ^        ^^^^^
]|

The format of the message may change in a future version.

@error must have come from a failed attempt to g_variant_parse() and
@source_str must be exactly the same string that caused the error.
If @source_str was not nul-terminated when you passed it to
g_variant_parse() then you must add nul termination before using this
function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the printed message</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError from the #GVariantParseError domain</doc>
            <type name="Error" c:type="GError*"/>
          </parameter>
          <parameter name="source_str" transfer-ownership="none">
            <doc xml:space="preserve">the string that was given to the parser</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_error_quark" c:identifier="g_variant_parse_error_quark">
        <return-value transfer-ownership="none">
          <type name="Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="parser_get_error_quark" c:identifier="g_variant_parser_get_error_quark" deprecated="1">
        <doc xml:space="preserve">Same as g_variant_error_quark().</doc>
        <doc-deprecated xml:space="preserve">Use g_variant_parse_error_quark() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </record>
    <record name="VariantBuilder" c:type="GVariantBuilder" glib:type-name="GVariantBuilder" glib:get-type="g_variant_builder_get_type" c:symbol-prefix="variant_builder">
      <doc xml:space="preserve">A utility type for constructing container-type #GVariant instances.

This is an opaque structure and may only be accessed using the
following functions.

#GVariantBuilder is not threadsafe in any way.  Do not attempt to
access it from more than one thread.</doc>
      <union name="u" c:type="u">
        <record name="s" c:type="s">
          <field name="partial_magic" writable="1">
            <type name="gsize" c:type="gsize"/>
          </field>
          <field name="type" writable="1">
            <type name="VariantType" c:type="const GVariantType*"/>
          </field>
          <field name="y" writable="1">
            <array zero-terminated="0" fixed-size="14">
              <type name="guintptr" c:type="guintptr"/>
            </array>
          </field>
        </record>
        <field name="x" writable="1">
          <array zero-terminated="0" fixed-size="16">
            <type name="guintptr" c:type="guintptr"/>
          </array>
        </field>
      </union>
      <constructor name="new" c:identifier="g_variant_builder_new" version="2.24">
        <doc xml:space="preserve">Allocates and initialises a new #GVariantBuilder.

You should call g_variant_builder_unref() on the return value when it
is no longer needed.  The memory will not be automatically freed by
any other call.

In most cases it is easier to place a #GVariantBuilder directly on
the stack of the calling function and initialise it with
g_variant_builder_init_static().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GVariantBuilder</doc>
          <type name="VariantBuilder" c:type="GVariantBuilder*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a container type</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="g_variant_builder_add" version="2.24" introspectable="0">
        <doc xml:space="preserve">Adds to a #GVariantBuilder.

This call is a convenience wrapper that is exactly equivalent to
calling g_variant_new() followed by g_variant_builder_add_value().

Note that the arguments must be of the correct width for their types
specified in @format_string. This can be achieved by casting them. See
the [GVariant varargs documentation](gvariant-format-strings.html#varargs).

This function might be used as follows:

|[&lt;!-- language="C" --&gt;
GVariant *
make_pointless_dictionary (void)
{
  GVariantBuilder builder;
  int i;

  g_variant_builder_init_static (&amp;builder, G_VARIANT_TYPE_ARRAY);
  for (i = 0; i &lt; 16; i++)
    {
      gchar buf[3];

      sprintf (buf, "%d", i);
      g_variant_builder_add (&amp;builder, "{is}", i, buf);
    }

  return g_variant_builder_end (&amp;builder);
}
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*"/>
          </instance-parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant varargs format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments, as per @format_string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_parsed" c:identifier="g_variant_builder_add_parsed" version="2.26" introspectable="0">
        <doc xml:space="preserve">Adds to a #GVariantBuilder.

This call is a convenience wrapper that is exactly equivalent to
calling g_variant_new_parsed() followed by
g_variant_builder_add_value().

Note that the arguments must be of the correct width for their types
specified in @format_string. This can be achieved by casting them. See
the [GVariant varargs documentation](gvariant-format-strings.html#varargs).

This function might be used as follows:

|[&lt;!-- language="C" --&gt;
GVariant *
make_pointless_dictionary (void)
{
  GVariantBuilder builder;
  int i;

  g_variant_builder_init_static (&amp;builder, G_VARIANT_TYPE_ARRAY);
  g_variant_builder_add_parsed (&amp;builder, "{'width', &lt;%i&gt;}", 600);
  g_variant_builder_add_parsed (&amp;builder, "{'title', &lt;%s&gt;}", "foo");
  g_variant_builder_add_parsed (&amp;builder, "{'transparency', &lt;0.5&gt;}");
  return g_variant_builder_end (&amp;builder);
}
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a text format #GVariant</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments as per @format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_value" c:identifier="g_variant_builder_add_value" version="2.24">
        <doc xml:space="preserve">Adds @value to @builder.

It is an error to call this function in any way that would create an
inconsistent value to be constructed.  Some examples of this are
putting different types of items into an array, putting the wrong
types or number of items in a tuple, putting more than one value into
a variant, etc.

If @value is a floating reference (see g_variant_ref_sink()),
the @builder instance takes ownership of @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="g_variant_builder_clear" version="2.24" introspectable="0">
        <doc xml:space="preserve">Releases all memory associated with a #GVariantBuilder without
freeing the #GVariantBuilder structure itself.

It typically only makes sense to do this on a stack-allocated
#GVariantBuilder if you want to abort building the value part-way
through.  This function need not be called if you call
g_variant_builder_end() and it also doesn't need to be called on
builders allocated with g_variant_builder_new() (see
g_variant_builder_unref() for that).

This function leaves the #GVariantBuilder structure set to all-zeros.
It is valid to call this function on either an initialised
#GVariantBuilder or one that is set to all-zeros but it is not valid
to call this function on uninitialised memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="g_variant_builder_close" version="2.24">
        <doc xml:space="preserve">Closes the subcontainer inside the given @builder that was opened by
the most recent call to g_variant_builder_open().

It is an error to call this function in any way that would create an
inconsistent value to be constructed (ie: too few values added to the
subcontainer).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="end" c:identifier="g_variant_builder_end" version="2.24">
        <doc xml:space="preserve">Ends the builder process and returns the constructed value.

It is not permissible to use @builder in any way after this call
except for reference counting operations (in the case of a
heap-allocated #GVariantBuilder) or by reinitialising it with
g_variant_builder_init() (in the case of stack-allocated). This
means that for the stack-allocated builders there is no need to
call g_variant_builder_clear() after the call to
g_variant_builder_end().

It is an error to call this function in any way that would create an
inconsistent value to be constructed (ie: insufficient number of
items added to a container with a specific number of children
required).  It is also an error to call this function if the builder
was created with an indefinite array or maybe type and no children
have been added; in this case it is impossible to infer the type of
the empty array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new, floating, #GVariant</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_variant_builder_init" version="2.24" introspectable="0">
        <doc xml:space="preserve">Initialises a #GVariantBuilder structure.

@type must be non-%NULL.  It specifies the type of container to
construct.  It can be an indefinite type such as
%G_VARIANT_TYPE_ARRAY or a definite type such as "as" or "(ii)".
Maybe, array, tuple, dictionary entry and variant-typed values may be
constructed.

If using a static type such as one of the `G_VARIANT_TYPE_*` constants
or a `G_VARIANT_TYPE ("(ii)")` macro, it is more performant to use
g_variant_builder_init_static() rather than g_variant_builder_init().

After the builder is initialised, values are added using
g_variant_builder_add_value() or g_variant_builder_add().

After all the child values are added, g_variant_builder_end() frees
the memory associated with the builder and returns the #GVariant that
was created.

This function completely ignores the previous contents of @builder.
On one hand this means that it is valid to pass in completely
uninitialised memory.  On the other hand, this means that if you are
initialising over top of an existing #GVariantBuilder you need to
first call g_variant_builder_clear() in order to avoid leaking
memory.

You must not call g_variant_builder_ref() or
g_variant_builder_unref() on a #GVariantBuilder that was initialised
with this function.  If you ever pass a reference to a
#GVariantBuilder outside of the control of your own code then you
should assume that the person receiving that reference may try to use
reference counting; you should use g_variant_builder_new() instead of
this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a container type</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_static" c:identifier="g_variant_builder_init_static" version="2.84" introspectable="0">
        <doc xml:space="preserve">Initialises a #GVariantBuilder structure.

This function works exactly like g_variant_builder_init() but does
not make a copy of @type. Therefore, @type must remain valid for the
lifetime of @builder. This is always true of type constants like
`G_VARIANT_TYPE_*` or `G_VARIANT_TYPE ("(ii)")`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a container type</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="open" c:identifier="g_variant_builder_open" version="2.24">
        <doc xml:space="preserve">Opens a subcontainer inside the given @builder.  When done adding
items to the subcontainer, g_variant_builder_close() must be called. @type
is the type of the container: so to build a tuple of several values, @type
must include the tuple itself.

It is an error to call this function in any way that would cause an
inconsistent value to be constructed (ie: adding too many values or
a value of an incorrect type).

Example of building a nested variant:
|[&lt;!-- language="C" --&gt;
GVariantBuilder builder;
guint32 some_number = get_number ();
g_autoptr (GHashTable) some_dict = get_dict ();
GHashTableIter iter;
const gchar *key;
const GVariant *value;
g_autoptr (GVariant) output = NULL;

g_variant_builder_init (&amp;builder, G_VARIANT_TYPE ("(ua{sv})"));
g_variant_builder_add (&amp;builder, "u", some_number);
g_variant_builder_open (&amp;builder, G_VARIANT_TYPE ("a{sv}"));

g_hash_table_iter_init (&amp;iter, some_dict);
while (g_hash_table_iter_next (&amp;iter, (gpointer *) &amp;key, (gpointer *) &amp;value))
  {
    g_variant_builder_open (&amp;builder, G_VARIANT_TYPE ("{sv}"));
    g_variant_builder_add (&amp;builder, "s", key);
    g_variant_builder_add (&amp;builder, "v", value);
    g_variant_builder_close (&amp;builder);
  }

g_variant_builder_close (&amp;builder);

output = g_variant_builder_end (&amp;builder);
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #GVariantType of the container</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_variant_builder_ref" version="2.24">
        <doc xml:space="preserve">Increases the reference count on @builder.

Don't call this on stack-allocated #GVariantBuilder instances or bad
things will happen.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to @builder</doc>
          <type name="VariantBuilder" c:type="GVariantBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantBuilder allocated by g_variant_builder_new()</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_variant_builder_unref" version="2.24">
        <doc xml:space="preserve">Decreases the reference count on @builder.

In the event that there are no more references, releases all memory
associated with the #GVariantBuilder.

Don't call this on stack-allocated #GVariantBuilder instances or bad
things will happen.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="full">
            <doc xml:space="preserve">a #GVariantBuilder allocated by g_variant_builder_new()</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="VariantClass" version="2.24" c:type="GVariantClass">
      <doc xml:space="preserve">The range of possible top-level types of #GVariant instances.</doc>
      <member name="boolean" value="98" c:identifier="G_VARIANT_CLASS_BOOLEAN">
        <doc xml:space="preserve">The #GVariant is a boolean.</doc>
      </member>
      <member name="byte" value="121" c:identifier="G_VARIANT_CLASS_BYTE">
        <doc xml:space="preserve">The #GVariant is a byte.</doc>
      </member>
      <member name="int16" value="110" c:identifier="G_VARIANT_CLASS_INT16">
        <doc xml:space="preserve">The #GVariant is a signed 16 bit integer.</doc>
      </member>
      <member name="uint16" value="113" c:identifier="G_VARIANT_CLASS_UINT16">
        <doc xml:space="preserve">The #GVariant is an unsigned 16 bit integer.</doc>
      </member>
      <member name="int32" value="105" c:identifier="G_VARIANT_CLASS_INT32">
        <doc xml:space="preserve">The #GVariant is a signed 32 bit integer.</doc>
      </member>
      <member name="uint32" value="117" c:identifier="G_VARIANT_CLASS_UINT32">
        <doc xml:space="preserve">The #GVariant is an unsigned 32 bit integer.</doc>
      </member>
      <member name="int64" value="120" c:identifier="G_VARIANT_CLASS_INT64">
        <doc xml:space="preserve">The #GVariant is a signed 64 bit integer.</doc>
      </member>
      <member name="uint64" value="116" c:identifier="G_VARIANT_CLASS_UINT64">
        <doc xml:space="preserve">The #GVariant is an unsigned 64 bit integer.</doc>
      </member>
      <member name="handle" value="104" c:identifier="G_VARIANT_CLASS_HANDLE">
        <doc xml:space="preserve">The #GVariant is a file handle index.</doc>
      </member>
      <member name="double" value="100" c:identifier="G_VARIANT_CLASS_DOUBLE">
        <doc xml:space="preserve">The #GVariant is a double precision floating
                         point value.</doc>
      </member>
      <member name="string" value="115" c:identifier="G_VARIANT_CLASS_STRING">
        <doc xml:space="preserve">The #GVariant is a normal string.</doc>
      </member>
      <member name="object_path" value="111" c:identifier="G_VARIANT_CLASS_OBJECT_PATH">
        <doc xml:space="preserve">The #GVariant is a D-Bus object path
                              string.</doc>
      </member>
      <member name="signature" value="103" c:identifier="G_VARIANT_CLASS_SIGNATURE">
        <doc xml:space="preserve">The #GVariant is a D-Bus signature string.</doc>
      </member>
      <member name="variant" value="118" c:identifier="G_VARIANT_CLASS_VARIANT">
        <doc xml:space="preserve">The #GVariant is a variant.</doc>
      </member>
      <member name="maybe" value="109" c:identifier="G_VARIANT_CLASS_MAYBE">
        <doc xml:space="preserve">The #GVariant is a maybe-typed value.</doc>
      </member>
      <member name="array" value="97" c:identifier="G_VARIANT_CLASS_ARRAY">
        <doc xml:space="preserve">The #GVariant is an array.</doc>
      </member>
      <member name="tuple" value="40" c:identifier="G_VARIANT_CLASS_TUPLE">
        <doc xml:space="preserve">The #GVariant is a tuple.</doc>
      </member>
      <member name="dict_entry" value="123" c:identifier="G_VARIANT_CLASS_DICT_ENTRY">
        <doc xml:space="preserve">The #GVariant is a dictionary entry.</doc>
      </member>
    </enumeration>
    <record name="VariantDict" c:type="GVariantDict" version="2.40" glib:type-name="GVariantDict" glib:get-type="g_variant_dict_get_type" c:symbol-prefix="variant_dict">
      <doc xml:space="preserve">#GVariantDict is a mutable interface to #GVariant dictionaries.

It can be used for doing a sequence of dictionary lookups in an
efficient way on an existing #GVariant dictionary or it can be used
to construct new dictionaries with a hashtable-like interface.  It
can also be used for taking existing dictionaries and modifying them
in order to create new ones.

#GVariantDict can only be used with %G_VARIANT_TYPE_VARDICT
dictionaries.

It is possible to use #GVariantDict allocated on the stack or on the
heap.  When using a stack-allocated #GVariantDict, you begin with a
call to g_variant_dict_init() and free the resources with a call to
g_variant_dict_clear().

Heap-allocated #GVariantDict follows normal refcounting rules: you
allocate it with g_variant_dict_new() and use g_variant_dict_ref()
and g_variant_dict_unref().

g_variant_dict_end() is used to convert the #GVariantDict back into a
dictionary-type #GVariant.  When used with stack-allocated instances,
this also implicitly frees all associated memory, but for
heap-allocated instances, you must still call g_variant_dict_unref()
afterwards.

You will typically want to use a heap-allocated #GVariantDict when
you expose it as part of an API.  For most other uses, the
stack-allocated form will be more convenient.

Consider the following two examples that do the same thing in each
style: take an existing dictionary and look up the "count" uint32
key, adding 1 to it if it is found, or returning an error if the
key is not found.  Each returns the new dictionary as a floating
#GVariant.

## Using a stack-allocated GVariantDict

|[&lt;!-- language="C" --&gt;
  GVariant *
  add_to_count (GVariant  *orig,
                GError   **error)
  {
    GVariantDict dict;
    guint32 count;

    g_variant_dict_init (&amp;dict, orig);
    if (!g_variant_dict_lookup (&amp;dict, "count", "u", &amp;count))
      {
        g_set_error (...);
        g_variant_dict_clear (&amp;dict);
        return NULL;
      }

    g_variant_dict_insert (&amp;dict, "count", "u", count + 1);

    return g_variant_dict_end (&amp;dict);
  }
]|

## Using heap-allocated GVariantDict

|[&lt;!-- language="C" --&gt;
  GVariant *
  add_to_count (GVariant  *orig,
                GError   **error)
  {
    GVariantDict *dict;
    GVariant *result;
    guint32 count;

    dict = g_variant_dict_new (orig);

    if (g_variant_dict_lookup (dict, "count", "u", &amp;count))
      {
        g_variant_dict_insert (dict, "count", "u", count + 1);
        result = g_variant_dict_end (dict);
      }
    else
      {
        g_set_error (...);
        result = NULL;
      }

    g_variant_dict_unref (dict);

    return result;
  }
]|</doc>
      <union name="u" c:type="u">
        <record name="s" c:type="s">
          <field name="asv" writable="1">
            <type name="Variant" c:type="GVariant*"/>
          </field>
          <field name="partial_magic" writable="1">
            <type name="gsize" c:type="gsize"/>
          </field>
          <field name="y" writable="1">
            <array zero-terminated="0" fixed-size="14">
              <type name="guintptr" c:type="guintptr"/>
            </array>
          </field>
        </record>
        <field name="x" writable="1">
          <array zero-terminated="0" fixed-size="16">
            <type name="guintptr" c:type="guintptr"/>
          </array>
        </field>
      </union>
      <constructor name="new" c:identifier="g_variant_dict_new" version="2.40">
        <doc xml:space="preserve">Allocates and initialises a new #GVariantDict.

You should call g_variant_dict_unref() on the return value when it
is no longer needed.  The memory will not be automatically freed by
any other call.

In some cases it may be easier to place a #GVariantDict directly on
the stack of the calling function and initialise it with
g_variant_dict_init().  This is particularly useful when you are
using #GVariantDict to construct a #GVariant.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GVariantDict</doc>
          <type name="VariantDict" c:type="GVariantDict*"/>
        </return-value>
        <parameters>
          <parameter name="from_asv" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GVariant with which to initialise the
  dictionary</doc>
            <type name="Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="clear" c:identifier="g_variant_dict_clear" version="2.40">
        <doc xml:space="preserve">Releases all memory associated with a #GVariantDict without freeing
the #GVariantDict structure itself.

It typically only makes sense to do this on a stack-allocated
#GVariantDict if you want to abort building the value part-way
through.  This function need not be called if you call
g_variant_dict_end() and it also doesn't need to be called on dicts
allocated with g_variant_dict_new (see g_variant_dict_unref() for
that).

It is valid to call this function on either an initialised
#GVariantDict or one that was previously cleared by an earlier call
to g_variant_dict_clear() but it is not valid to call this function
on uninitialised memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="contains" c:identifier="g_variant_dict_contains" version="2.40">
        <doc xml:space="preserve">Checks if @key exists in @dict.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @key is in @dict</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to look up in the dictionary</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="end" c:identifier="g_variant_dict_end" version="2.40">
        <doc xml:space="preserve">Returns the current value of @dict as a #GVariant of type
%G_VARIANT_TYPE_VARDICT, clearing it in the process.

It is not permissible to use @dict in any way after this call except
for reference counting operations (in the case of a heap-allocated
#GVariantDict) or by reinitialising it with g_variant_dict_init() (in
the case of stack-allocated).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new, floating, #GVariant</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_variant_dict_init" version="2.40" introspectable="0">
        <doc xml:space="preserve">Initialises a #GVariantDict structure.

If @from_asv is given, it is used to initialise the dictionary.

This function completely ignores the previous contents of @dict.  On
one hand this means that it is valid to pass in completely
uninitialised memory.  On the other hand, this means that if you are
initialising over top of an existing #GVariantDict you need to first
call g_variant_dict_clear() in order to avoid leaking memory.

You must not call g_variant_dict_ref() or g_variant_dict_unref() on a
#GVariantDict that was initialised with this function.  If you ever
pass a reference to a #GVariantDict outside of the control of your
own code then you should assume that the person receiving that
reference may try to use reference counting; you should use
g_variant_dict_new() instead of this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*"/>
          </instance-parameter>
          <parameter name="from_asv" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the initial value for @dict</doc>
            <type name="Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_variant_dict_insert" version="2.40" introspectable="0">
        <doc xml:space="preserve">Inserts a value into a #GVariantDict.

This call is a convenience wrapper that is exactly equivalent to
calling g_variant_new() followed by g_variant_dict_insert_value().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to insert a value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariant varargs format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments, as per @format_string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_value" c:identifier="g_variant_dict_insert_value" version="2.40">
        <doc xml:space="preserve">Inserts (or replaces) a key in a #GVariantDict.

@value is consumed if it is floating.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to insert a value for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to insert</doc>
            <type name="Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="g_variant_dict_lookup" version="2.40" introspectable="0">
        <doc xml:space="preserve">Looks up a value in a #GVariantDict.

This function is a wrapper around g_variant_dict_lookup_value() and
g_variant_get().  In the case that %NULL would have been returned,
this function returns %FALSE and does not modify the values of the arguments
passed in to @....  Otherwise, it unpacks the returned
value and returns %TRUE.

@format_string determines the C types that are used for unpacking the
values and also determines if the values are copied or borrowed, see the
section on [`GVariant` format strings](gvariant-format-strings.html#pointers).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a value was unpacked</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to look up in the dictionary</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the arguments to unpack the value into</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_value" c:identifier="g_variant_dict_lookup_value" version="2.40">
        <doc xml:space="preserve">Looks up a value in a #GVariantDict.

If @key is not found in @dictionary, %NULL is returned.

The @expected_type string specifies what type of value is expected.
If the value associated with @key has a different type then %NULL is
returned.

If the key is found and the value has the correct type, it is
returned.  If @expected_type was specified then any non-%NULL return
value will have this type.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the value of the dictionary key, or %NULL</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to look up in the dictionary</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="expected_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariantType, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_variant_dict_ref" version="2.40">
        <doc xml:space="preserve">Increases the reference count on @dict.

Don't call this on stack-allocated #GVariantDict instances or bad
things will happen.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new reference to @dict</doc>
          <type name="VariantDict" c:type="GVariantDict*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none">
            <doc xml:space="preserve">a heap-allocated #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_variant_dict_remove" version="2.40">
        <doc xml:space="preserve">Removes a key and its associated value from a #GVariantDict.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the key was found and removed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_variant_dict_unref" version="2.40">
        <doc xml:space="preserve">Decreases the reference count on @dict.

In the event that there are no more references, releases all memory
associated with the #GVariantDict.

Don't call this on stack-allocated #GVariantDict instances or bad
things will happen.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="full">
            <doc xml:space="preserve">a heap-allocated #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="VariantIter" c:type="GVariantIter" introspectable="0">
      <doc xml:space="preserve">#GVariantIter is an opaque data structure and can only be accessed
using the following functions.</doc>
      <field name="x" readable="0" private="1">
        <array zero-terminated="0" fixed-size="16">
          <type name="guintptr" c:type="guintptr"/>
        </array>
      </field>
      <method name="copy" c:identifier="g_variant_iter_copy" version="2.24" introspectable="0">
        <doc xml:space="preserve">Creates a new heap-allocated #GVariantIter to iterate over the
container that was being iterated over by @iter.  Iteration begins on
the new iterator from the current position of the old iterator but
the two copies are independent past that point.

Use g_variant_iter_free() to free the return value when you no longer
need it.

A reference is taken to the container that @iter is iterating over
and will be related only when g_variant_iter_free() is called.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new heap-allocated #GVariantIter</doc>
          <type name="VariantIter" c:type="GVariantIter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantIter</doc>
            <type name="VariantIter" c:type="GVariantIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_variant_iter_free" version="2.24">
        <doc xml:space="preserve">Frees a heap-allocated #GVariantIter.  Only call this function on
iterators that were returned by g_variant_iter_new() or
g_variant_iter_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="full">
            <doc xml:space="preserve">a heap-allocated #GVariantIter</doc>
            <type name="VariantIter" c:type="GVariantIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_variant_iter_init" version="2.24" introspectable="0">
        <doc xml:space="preserve">Initialises (without allocating) a #GVariantIter.  @iter may be
completely uninitialised prior to this call; its old value is
ignored.

The iterator remains valid for as long as @value exists, and need not
be freed in any way.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of items in @value</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #GVariantIter</doc>
            <type name="VariantIter" c:type="GVariantIter*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a container #GVariant</doc>
            <type name="Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="loop" c:identifier="g_variant_iter_loop" version="2.24" introspectable="0">
        <doc xml:space="preserve">Gets the next item in the container and unpacks it into the variable
argument list according to @format_string, returning %TRUE.

If no more items remain then %FALSE is returned.

On the first call to this function, the pointers appearing on the
variable argument list are assumed to point at uninitialised memory.
On the second and later calls, it is assumed that the same pointers
will be given and that they will point to the memory as set by the
previous call to this function.  This allows the previous values to
be freed, as appropriate.

This function is intended to be used with a while loop as
demonstrated in the following example.  This function can only be
used when iterating over an array.  It is only valid to call this
function with a string constant for the format string and the same
string constant must be used each time.  Mixing calls to this
function and g_variant_iter_next() or g_variant_iter_next_value() on
the same iterator causes undefined behavior.

If you break out of a such a while loop using g_variant_iter_loop() then
you must free or unreference all the unpacked values as you would with
g_variant_get(). Failure to do so will cause a memory leak.

Here is an example for memory management with g_variant_iter_loop():
|[&lt;!-- language="C" --&gt;
  // Iterates a dictionary of type 'a{sv}'
  void
  iterate_dictionary (GVariant *dictionary)
  {
    GVariantIter iter;
    GVariant *value;
    gchar *key;

    g_variant_iter_init (&amp;iter, dictionary);
    while (g_variant_iter_loop (&amp;iter, "{sv}", &amp;key, &amp;value))
      {
        g_print ("Item '%s' has type '%s'\n", key,
                 g_variant_get_type_string (value));

        // no need to free 'key' and 'value' here
        // unless breaking out of this loop
      }
  }
]|

For most cases you should use g_variant_iter_next().

This function is really only useful when unpacking into #GVariant or
#GVariantIter in order to allow you to skip the call to
g_variant_unref() or g_variant_iter_free().

For example, if you are only looping over simple integer and string
types, g_variant_iter_next() is definitely preferred.  For string
types, use the '&amp;' prefix to avoid allocating any memory at all (and
thereby avoiding the need to free anything as well).

@format_string determines the C types that are used for unpacking
the values and also determines if the values are copied or borrowed.

See the section on
[`GVariant` format strings](gvariant-format-strings.html#pointers).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a value was unpacked, or %FALSE if there was no
         value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantIter</doc>
            <type name="VariantIter" c:type="GVariantIter*"/>
          </instance-parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the arguments to unpack the value into</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="n_children" c:identifier="g_variant_iter_n_children" version="2.24">
        <doc xml:space="preserve">Queries the number of child items in the container that we are
iterating over.  This is the total number of items -- not the number
of items remaining.

This function might be useful for preallocation of arrays.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of children in the container</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantIter</doc>
            <type name="VariantIter" c:type="GVariantIter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="g_variant_iter_next" version="2.24" introspectable="0">
        <doc xml:space="preserve">Gets the next item in the container and unpacks it into the variable
argument list according to @format_string, returning %TRUE.

If no more items remain then %FALSE is returned.

All of the pointers given on the variable arguments list of this
function are assumed to point at uninitialised memory.  It is the
responsibility of the caller to free all of the values returned by
the unpacking process.

Here is an example for memory management with g_variant_iter_next():
|[&lt;!-- language="C" --&gt;
  // Iterates a dictionary of type 'a{sv}'
  void
  iterate_dictionary (GVariant *dictionary)
  {
    GVariantIter iter;
    GVariant *value;
    gchar *key;

    g_variant_iter_init (&amp;iter, dictionary);
    while (g_variant_iter_next (&amp;iter, "{sv}", &amp;key, &amp;value))
      {
        g_print ("Item '%s' has type '%s'\n", key,
                 g_variant_get_type_string (value));

        // must free data for ourselves
        g_variant_unref (value);
        g_free (key);
      }
  }
]|

For a solution that is likely to be more convenient to C programmers
when dealing with loops, see g_variant_iter_loop().

@format_string determines the C types that are used for unpacking
the values and also determines if the values are copied or borrowed.

See the section on
[`GVariant` format strings](gvariant-format-strings.html#pointers).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a value was unpacked, or %FALSE if there as no value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantIter</doc>
            <type name="VariantIter" c:type="GVariantIter*"/>
          </instance-parameter>
          <parameter name="format_string" transfer-ownership="none">
            <doc xml:space="preserve">a GVariant format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the arguments to unpack the value into</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="next_value" c:identifier="g_variant_iter_next_value" version="2.24">
        <doc xml:space="preserve">Gets the next item in the container.  If no more items remain then
%NULL is returned.

Use g_variant_unref() to drop your reference on the return value when
you no longer need it.

Here is an example for iterating with g_variant_iter_next_value():
|[&lt;!-- language="C" --&gt;
  // recursively iterate a container
  void
  iterate_container_recursive (GVariant *container)
  {
    GVariantIter iter;
    GVariant *child;

    g_variant_iter_init (&amp;iter, container);
    while ((child = g_variant_iter_next_value (&amp;iter)))
      {
        g_print ("type '%s'\n", g_variant_get_type_string (child));

        if (g_variant_is_container (child))
          iterate_container_recursive (child);

        g_variant_unref (child);
      }
  }
]|</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GVariant, or %NULL</doc>
          <type name="Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve">a #GVariantIter</doc>
            <type name="VariantIter" c:type="GVariantIter*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="VariantParseError" c:type="GVariantParseError" glib:error-domain="g-variant-parse-error-quark">
      <doc xml:space="preserve">Error codes returned by parsing text-format GVariants.</doc>
      <member name="failed" value="0" c:identifier="G_VARIANT_PARSE_ERROR_FAILED">
        <doc xml:space="preserve">generic error (unused)</doc>
      </member>
      <member name="basic_type_expected" value="1" c:identifier="G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED">
        <doc xml:space="preserve">a non-basic #GVariantType was given where a basic type was expected</doc>
      </member>
      <member name="cannot_infer_type" value="2" c:identifier="G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE">
        <doc xml:space="preserve">cannot infer the #GVariantType</doc>
      </member>
      <member name="definite_type_expected" value="3" c:identifier="G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED">
        <doc xml:space="preserve">an indefinite #GVariantType was given where a definite type was expected</doc>
      </member>
      <member name="input_not_at_end" value="4" c:identifier="G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END">
        <doc xml:space="preserve">extra data after parsing finished</doc>
      </member>
      <member name="invalid_character" value="5" c:identifier="G_VARIANT_PARSE_ERROR_INVALID_CHARACTER">
        <doc xml:space="preserve">invalid character in number or unicode escape</doc>
      </member>
      <member name="invalid_format_string" value="6" c:identifier="G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING">
        <doc xml:space="preserve">not a valid #GVariant format string</doc>
      </member>
      <member name="invalid_object_path" value="7" c:identifier="G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH">
        <doc xml:space="preserve">not a valid object path</doc>
      </member>
      <member name="invalid_signature" value="8" c:identifier="G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE">
        <doc xml:space="preserve">not a valid type signature</doc>
      </member>
      <member name="invalid_type_string" value="9" c:identifier="G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING">
        <doc xml:space="preserve">not a valid #GVariant type string</doc>
      </member>
      <member name="no_common_type" value="10" c:identifier="G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE">
        <doc xml:space="preserve">could not find a common type for array entries</doc>
      </member>
      <member name="number_out_of_range" value="11" c:identifier="G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE">
        <doc xml:space="preserve">the numerical value is out of range of the given type</doc>
      </member>
      <member name="number_too_big" value="12" c:identifier="G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG">
        <doc xml:space="preserve">the numerical value is out of range for any type</doc>
      </member>
      <member name="type_error" value="13" c:identifier="G_VARIANT_PARSE_ERROR_TYPE_ERROR">
        <doc xml:space="preserve">cannot parse as variant of the specified type</doc>
      </member>
      <member name="unexpected_token" value="14" c:identifier="G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN">
        <doc xml:space="preserve">an unexpected token was encountered</doc>
      </member>
      <member name="unknown_keyword" value="15" c:identifier="G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD">
        <doc xml:space="preserve">an unknown keyword was encountered</doc>
      </member>
      <member name="unterminated_string_constant" value="16" c:identifier="G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT">
        <doc xml:space="preserve">unterminated string constant</doc>
      </member>
      <member name="value_expected" value="17" c:identifier="G_VARIANT_PARSE_ERROR_VALUE_EXPECTED">
        <doc xml:space="preserve">no value given</doc>
      </member>
      <member name="recursion" value="18" c:identifier="G_VARIANT_PARSE_ERROR_RECURSION">
        <doc xml:space="preserve">variant was too deeply nested; #GVariant is only guaranteed to handle nesting up to 64 levels (Since: 2.64)</doc>
      </member>
    </enumeration>
    <record name="VariantType" c:type="GVariantType" opaque="1" version="2.24" glib:type-name="GVariantType" glib:get-type="g_variant_type_get_gtype" c:symbol-prefix="variant_type">
      <doc xml:space="preserve">A type in the [type@GLib.Variant] type system.

[type@GLib.Variant] types are represented as strings, but have a strict
syntax described below. All [type@GLib.VariantType]s passed to GLib must be
valid, and they are typically expected to be static (i.e. not provided by
user input) as they determine how binary [type@GLib.Variant] data is
interpreted.

To convert a static string to a [type@GLib.VariantType] in C, use the
[func@GLib.VARIANT_TYPE] casting macro. When GLib is compiled with checks
enabled, it will validate the type. To check if an arbitrary string is a
valid [type@GLib.VariantType], use [func@GLib.VariantType.string_is_valid].

## GVariant Type System

This section introduces the [type@GLib.Variant] type system. It is based, in
large part, on the D-Bus type system, with two major changes and
some minor lifting of restrictions. The
[D-Bus specification](http://dbus.freedesktop.org/doc/dbus-specification.html),
therefore, provides a significant amount of
information that is useful when working with [type@GLib.Variant].

The first major change with respect to the D-Bus type system is the
introduction of maybe (or &#x2018;nullable&#x2019;) types.  Any type in [type@GLib.Variant]
can be converted to a maybe type, in which case, `nothing` (or `null`)
becomes a valid value.  Maybe types have been added by introducing the
character `m` to type strings.

The second major change is that the [type@GLib.Variant] type system supports
the concept of &#x2018;indefinite types&#x2019; &#x2014; types that are less specific than
the normal types found in D-Bus.  For example, it is possible to speak
of &#x2018;an array of any type&#x2019; in [type@GLib.Variant], where the D-Bus type system
would require you to speak of &#x2018;an array of integers&#x2019; or &#x2018;an array of
strings&#x2019;.  Indefinite types have been added by introducing the
characters `*`, `?` and `r` to type strings.

Finally, all arbitrary restrictions relating to the complexity of
types are lifted along with the restriction that dictionary entries
may only appear nested inside of arrays.

Just as in D-Bus, [type@GLib.Variant] types are described with strings (&#x2018;type
strings&#x2019;).  Subject to the differences mentioned above, these strings
are of the same form as those found in D-Bus.  Note, however: D-Bus
always works in terms of messages and therefore individual type
strings appear nowhere in its interface.  Instead, &#x2018;signatures&#x2019;
are a concatenation of the strings of the type of each argument in a
message.  [type@GLib.Variant] deals with single values directly so
[type@GLib.Variant] type strings always describe the type of exactly one
value.  This means that a D-Bus signature string is generally not a valid
[type@GLib.Variant] type string &#x2014; except in the case that it is the signature
of a message containing exactly one argument.

An indefinite type is similar in spirit to what may be called an
abstract type in other type systems.  No value can exist that has an
indefinite type as its type, but values can exist that have types
that are subtypes of indefinite types.  That is to say,
[method@GLib.Variant.get_type] will never return an indefinite type, but
calling [method@GLib.Variant.is_of_type] with an indefinite type may return
true.  For example, you cannot have a value that represents &#x2018;an
array of no particular type&#x2019;, but you can have an &#x2018;array of integers&#x2019;
which certainly matches the type of &#x2018;an array of no particular type&#x2019;,
since &#x2018;array of integers&#x2019; is a subtype of &#x2018;array of no particular
type&#x2019;.

This is similar to how instances of abstract classes may not
directly exist in other type systems, but instances of their
non-abstract subtypes may.  For example, in GTK, no object that has
the type of [`GtkWidget`](https://docs.gtk.org/gtk4/class.Widget.html) can
exist (since `GtkWidget` is an abstract class), but a [`GtkWindow`](https://docs.gtk.org/gtk4/class.Window.html)
can certainly be instantiated, and you would say that a `GtkWindow` is a
`GtkWidget` (since `GtkWindow` is a subclass of `GtkWidget`).

Two types may not be compared by value; use [method@GLib.VariantType.equal]
or [method@GLib.VariantType.is_subtype_of]  May be copied using
[method@GLib.VariantType.copy] and freed using [method@GLib.VariantType.free].

## GVariant Type Strings

A [type@GLib.Variant] type string can be any of the following:

- any basic type string (listed below)
- `v`, `r` or `*`
- one of the characters `a` or `m`, followed by another type string
- the character `(`, followed by a concatenation of zero or more other
  type strings, followed by the character `)`
- the character `{`, followed by a basic type string (see below),
  followed by another type string, followed by the character `}`

A basic type string describes a basic type (as per
[method@GLib.VariantType.is_basic]) and is always a single character in
length. The valid basic type strings are `b`, `y`, `n`, `q`, `i`, `u`, `x`,
`t`, `h`, `d`, `s`, `o`, `g` and `?`.

The above definition is recursive to arbitrary depth. `aaaaai` and
`(ui(nq((y)))s)` are both valid type strings, as is
`a(aa(ui)(qna{ya(yd)}))`. In order to not hit memory limits,
[type@GLib.Variant] imposes a limit on recursion depth of 65 nested
containers. This is the limit in the D-Bus specification (64) plus one to
allow a [`GDBusMessage`](../gio/class.DBusMessage.html) to be nested in
a top-level tuple.

The meaning of each of the characters is as follows:

- `b`: the type string of `G_VARIANT_TYPE_BOOLEAN`; a boolean value.
- `y`: the type string of `G_VARIANT_TYPE_BYTE`; a byte.
- `n`: the type string of `G_VARIANT_TYPE_INT16`; a signed 16 bit integer.
- `q`: the type string of `G_VARIANT_TYPE_UINT16`; an unsigned 16 bit integer.
- `i`: the type string of `G_VARIANT_TYPE_INT32`; a signed 32 bit integer.
- `u`: the type string of `G_VARIANT_TYPE_UINT32`; an unsigned 32 bit integer.
- `x`: the type string of `G_VARIANT_TYPE_INT64`; a signed 64 bit integer.
- `t`: the type string of `G_VARIANT_TYPE_UINT64`; an unsigned 64 bit integer.
- `h`: the type string of `G_VARIANT_TYPE_HANDLE`; a signed 32 bit value
  that, by convention, is used as an index into an array of file
  descriptors that are sent alongside a D-Bus message.
- `d`: the type string of `G_VARIANT_TYPE_DOUBLE`; a double precision
  floating point value.
- `s`: the type string of `G_VARIANT_TYPE_STRING`; a string.
- `o`: the type string of `G_VARIANT_TYPE_OBJECT_PATH`; a string in the form
  of a D-Bus object path.
- `g`: the type string of `G_VARIANT_TYPE_SIGNATURE`; a string in the form of
  a D-Bus type signature.
- `?`: the type string of `G_VARIANT_TYPE_BASIC`; an indefinite type that
  is a supertype of any of the basic types.
- `v`: the type string of `G_VARIANT_TYPE_VARIANT`; a container type that
  contain any other type of value.
- `a`: used as a prefix on another type string to mean an array of that
  type; the type string `ai`, for example, is the type of an array of
  signed 32-bit integers.
- `m`: used as a prefix on another type string to mean a &#x2018;maybe&#x2019;, or
  &#x2018;nullable&#x2019;, version of that type; the type string `ms`, for example,
  is the type of a value that maybe contains a string, or maybe contains
  nothing.
- `()`: used to enclose zero or more other concatenated type strings to
  create a tuple type; the type string `(is)`, for example, is the type of
  a pair of an integer and a string.
- `r`: the type string of `G_VARIANT_TYPE_TUPLE`; an indefinite type that is
  a supertype of any tuple type, regardless of the number of items.
- `{}`: used to enclose a basic type string concatenated with another type
  string to create a dictionary entry type, which usually appears inside of
  an array to form a dictionary; the type string `a{sd}`, for example, is
  the type of a dictionary that maps strings to double precision floating
  point values.

  The first type (the basic type) is the key type and the second type is
  the value type. The reason that the first type is restricted to being a
  basic type is so that it can easily be hashed.
- `*`: the type string of `G_VARIANT_TYPE_ANY`; the indefinite type that is
  a supertype of all types.  Note that, as with all type strings, this
  character represents exactly one type. It cannot be used inside of tuples
  to mean &#x2018;any number of items&#x2019;.

Any type string of a container that contains an indefinite type is,
itself, an indefinite type. For example, the type string `a*`
(corresponding to `G_VARIANT_TYPE_ARRAY`) is an indefinite type
that is a supertype of every array type. `(*s)` is a supertype
of all tuples that contain exactly two items where the second
item is a string.

`a{?*}` is an indefinite type that is a supertype of all arrays
containing dictionary entries where the key is any basic type and
the value is any type at all.  This is, by definition, a dictionary,
so this type string corresponds to `G_VARIANT_TYPE_DICTIONARY`. Note
that, due to the restriction that the key of a dictionary entry must
be a basic type, `{**}` is not a valid type string.</doc>
      <constructor name="new" c:identifier="g_variant_type_new" version="2.24">
        <doc xml:space="preserve">Creates a new [type@GLib.VariantType] corresponding to the type string given
by @type_string.

It is appropriate to call [method@GLib.VariantType.free] on the return value.

It is a programmer error to call this function with an invalid type
string.  Use [func@GLib.VariantType.string_is_valid] if you are unsure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new [type@GLib.VariantType]</doc>
          <type name="VariantType" c:type="GVariantType*"/>
        </return-value>
        <parameters>
          <parameter name="type_string" transfer-ownership="none">
            <doc xml:space="preserve">a valid [GVariant type string](./struct.VariantType.html#gvariant-type-strings)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_array" c:identifier="g_variant_type_new_array">
        <doc xml:space="preserve">Constructs the type corresponding to an array of elements of the
type @type.

It is appropriate to call [method@GLib.VariantType.first] on the return value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new array type
Since 2.24</doc>
          <type name="VariantType" c:type="GVariantType*"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:space="preserve">an element type</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_dict_entry" c:identifier="g_variant_type_new_dict_entry">
        <doc xml:space="preserve">Constructs the type corresponding to a dictionary entry with a key
of type @key and a value of type @value.

It is appropriate to call [method@GLib.VariantType.free] on the return value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new dictionary entry type
Since 2.24</doc>
          <type name="VariantType" c:type="GVariantType*"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a basic type to use for the key</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a type to use for the value</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_maybe" c:identifier="g_variant_type_new_maybe">
        <doc xml:space="preserve">Constructs the type corresponding to a &#x2018;maybe&#x2019; instance containing
type @type or `Nothing`.

It is appropriate to call [method@GLib.VariantType.free] on the return value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new &#x2018;maybe&#x2019; type
Since 2.24</doc>
          <type name="VariantType" c:type="GVariantType*"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:space="preserve">an element type</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_tuple" c:identifier="g_variant_type_new_tuple">
        <doc xml:space="preserve">Constructs a new tuple type, from @items.

@length is the number of items in @items, or `-1` to indicate that
@items is `NULL`-terminated.

It is appropriate to call [method@GLib.VariantType.free] on the return value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new tuple type
Since 2.24</doc>
          <type name="VariantType" c:type="GVariantType*"/>
        </return-value>
        <parameters>
          <parameter name="items" transfer-ownership="none">
            <doc xml:space="preserve">an array of types, one for each item</doc>
            <array length="1" zero-terminated="0" c:type="const GVariantType* const*">
              <type name="VariantType" c:type="GVariantType*"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @items, or `-1`</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="g_variant_type_copy">
        <doc xml:space="preserve">Makes a copy of a [type@GLib.VariantType].

It is appropriate to call [method@GLib.VariantType.free] on the return value.
@type may not be `NULL`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new [type@GLib.VariantType]
Since 2.24</doc>
          <type name="VariantType" c:type="GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to copy</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_string" c:identifier="g_variant_type_dup_string">
        <doc xml:space="preserve">Returns a newly-allocated copy of the type string corresponding to @type.

The returned string is nul-terminated.  It is appropriate to call
[func@GLib.free] on the return value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the corresponding type string
Since 2.24</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to copy</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="element" c:identifier="g_variant_type_element">
        <doc xml:space="preserve">Determines the element type of an array or &#x2018;maybe&#x2019; type.

This function may only be used with array or &#x2018;maybe&#x2019; types.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the element type of @type
Since 2.24</doc>
          <type name="VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">an array or &#x2018;maybe&#x2019; type</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="g_variant_type_equal">
        <doc xml:space="preserve">Compares @type1 and @type2 for equality.

Only returns true if the types are exactly equal.  Even if one type
is an indefinite type and the other is a subtype of it, false will
be returned if they are not exactly equal.  If you want to check for
subtypes, use [method@GLib.VariantType.is_subtype_of].

The argument types of @type1 and @type2 are only `gconstpointer` to
allow use with [type@GLib.HashTable] without function pointer casting.  For
both arguments, a valid [type@GLib.VariantType] must be provided.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @type1 and @type2 are exactly equal
Since 2.24</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="type1" transfer-ownership="none">
            <doc xml:space="preserve">type to compare</doc>
            <type name="VariantType" c:type="gconstpointer"/>
          </instance-parameter>
          <parameter name="type2" transfer-ownership="none">
            <doc xml:space="preserve">another type to compare</doc>
            <type name="VariantType" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="first" c:identifier="g_variant_type_first">
        <doc xml:space="preserve">Determines the first item type of a tuple or dictionary entry
type.

This function may only be used with tuple or dictionary entry types,
but must not be used with the generic tuple type
`G_VARIANT_TYPE_TUPLE`.

In the case of a dictionary entry type, this returns the type of
the key.

`NULL` is returned in case of @type being `G_VARIANT_TYPE_UNIT`.

This call, together with [method@GLib.VariantType.next] provides an iterator
interface over tuple and dictionary entry types.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the first item type of @type, or `NULL`
  if the type has no item types
Since 2.24</doc>
          <type name="VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a tuple or dictionary entry type</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_variant_type_free">
        <doc xml:space="preserve">Frees a [type@GLib.VariantType] that was allocated with
[method@GLib.VariantType.copy], [ctor@GLib.VariantType.new] or one of the
container type constructor functions.

In the case that @type is `NULL`, this function does nothing.

Since 2.24</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">type to free</doc>
            <type name="VariantType" c:type="GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string_length" c:identifier="g_variant_type_get_string_length">
        <doc xml:space="preserve">Returns the length of the type string corresponding to the given @type.

This function must be used to determine the valid extent of
the memory region returned by [method@GLib.VariantType.peek_string].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the corresponding type string
Since 2.24</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to measure</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="g_variant_type_hash">
        <doc xml:space="preserve">Hashes @type.

The argument type of @type is only `gconstpointer` to allow use with
[type@GLib.HashTable] without function pointer casting.  A valid
[type@GLib.VariantType] must be provided.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hash value
Since 2.24</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to hash</doc>
            <type name="VariantType" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_array" c:identifier="g_variant_type_is_array">
        <doc xml:space="preserve">Determines if the given @type is an array type.

This is true if the type string for @type starts with an `a`.

This function returns true for any indefinite type for which every
definite subtype is an array type &#x2014; `G_VARIANT_TYPE_ARRAY`, for
example.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @type is an array type
Since 2.24</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to check</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_basic" c:identifier="g_variant_type_is_basic">
        <doc xml:space="preserve">Determines if the given @type is a basic type.

Basic types are booleans, bytes, integers, doubles, strings, object
paths and signatures.

Only a basic type may be used as the key of a dictionary entry.

This function returns `FALSE` for all indefinite types except
`G_VARIANT_TYPE_BASIC`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @type is a basic type
Since 2.24</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to check</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_container" c:identifier="g_variant_type_is_container">
        <doc xml:space="preserve">Determines if the given @type is a container type.

Container types are any array, maybe, tuple, or dictionary
entry types plus the variant type.

This function returns true for any indefinite type for which every
definite subtype is a container &#x2014; `G_VARIANT_TYPE_ARRAY`, for
example.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @type is a container type
Since 2.24</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to check</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_definite" c:identifier="g_variant_type_is_definite">
        <doc xml:space="preserve">Determines if the given @type is definite (ie: not indefinite).

A type is definite if its type string does not contain any indefinite
type characters (`*`, `?`, or `r`).

A [type@GLib.Variant] instance may not have an indefinite type, so calling
this function on the result of [method@GLib.Variant.get_type] will always
result in true being returned.  Calling this function on an
indefinite type like `G_VARIANT_TYPE_ARRAY`, however, will result in
`FALSE` being returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @type is definite
Since 2.24</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to check</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_dict_entry" c:identifier="g_variant_type_is_dict_entry">
        <doc xml:space="preserve">Determines if the given @type is a dictionary entry type.

This is true if the type string for @type starts with a `{`.

This function returns true for any indefinite type for which every
definite subtype is a dictionary entry type &#x2014;
`G_VARIANT_TYPE_DICT_ENTRY`, for example.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @type is a dictionary entry type
Since 2.24</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to check</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_maybe" c:identifier="g_variant_type_is_maybe">
        <doc xml:space="preserve">Determines if the given @type is a &#x2018;maybe&#x2019; type.

This is true if the type string for @type starts with an `m`.

This function returns true for any indefinite type for which every
definite subtype is a &#x2018;maybe&#x2019; type &#x2014; `G_VARIANT_TYPE_MAYBE`, for
example.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @type is a &#x2018;maybe&#x2019; type
Since 2.24</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to check</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_subtype_of" c:identifier="g_variant_type_is_subtype_of">
        <doc xml:space="preserve">Checks if @type is a subtype of @supertype.

This function returns true if @type is a subtype of @supertype.  All
types are considered to be subtypes of themselves.  Aside from that,
only indefinite types can have subtypes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @type is a subtype of @supertype
Since 2.24</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to check</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
          <parameter name="supertype" transfer-ownership="none">
            <doc xml:space="preserve">type of potential supertype</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_tuple" c:identifier="g_variant_type_is_tuple">
        <doc xml:space="preserve">Determines if the given @type is a tuple type.

This is true if the type string for @type starts with a `(` or if @type is
`G_VARIANT_TYPE_TUPLE`.

This function returns true for any indefinite type for which every
definite subtype is a tuple type &#x2014; `G_VARIANT_TYPE_TUPLE`, for
example.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @type is a tuple type
Since 2.24</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to check</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_variant" c:identifier="g_variant_type_is_variant">
        <doc xml:space="preserve">Determines if the given @type is the variant type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @type is the variant type
Since 2.24</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to check</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="key" c:identifier="g_variant_type_key">
        <doc xml:space="preserve">Determines the key type of a dictionary entry type.

This function may only be used with a dictionary entry type.  Other
than the additional restriction, this call is equivalent to
[method@GLib.VariantType.first].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the key type of the dictionary entry
Since 2.24</doc>
          <type name="VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a dictionary entry type</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="n_items" c:identifier="g_variant_type_n_items">
        <doc xml:space="preserve">Determines the number of items contained in a tuple or
dictionary entry type.

This function may only be used with tuple or dictionary entry types,
but must not be used with the generic tuple type
`G_VARIANT_TYPE_TUPLE`.

In the case of a dictionary entry type, this function will always
return `2`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of items in @type
Since 2.24</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a tuple or dictionary entry type</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="g_variant_type_next">
        <doc xml:space="preserve">Determines the next item type of a tuple or dictionary entry
type.

@type must be the result of a previous call to
[method@GLib.VariantType.first] or [method@GLib.VariantType.next].

If called on the key type of a dictionary entry then this call
returns the value type.  If called on the value type of a dictionary
entry then this call returns `NULL`.

For tuples, `NULL` is returned when @type is the last item in the tuple.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the next type after @type, or `NULL` if
  there are no further types
Since 2.24</doc>
          <type name="VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a type from a previous call</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_string" c:identifier="g_variant_type_peek_string" introspectable="0">
        <doc xml:space="preserve">Returns the type string corresponding to the given @type.

The result is not nul-terminated; in order to determine its length you
must call [method@GLib.VariantType.get_string_length].

To get a nul-terminated string, see [method@GLib.VariantType.dup_string].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the corresponding type string (not nul-terminated)
Since 2.24</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type to peek at</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="value" c:identifier="g_variant_type_value">
        <doc xml:space="preserve">Determines the value type of a dictionary entry type.

This function may only be used with a dictionary entry type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value type of the dictionary entry
Since 2.24</doc>
          <type name="VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a dictionary entry type</doc>
            <type name="VariantType" c:type="const GVariantType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="checked_" c:identifier="g_variant_type_checked_">
        <return-value transfer-ownership="none">
          <type name="VariantType" c:type="const GVariantType*"/>
        </return-value>
        <parameters>
          <parameter name="type_string" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="string_get_depth_" c:identifier="g_variant_type_string_get_depth_">
        <return-value transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="type_string" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="string_is_valid" c:identifier="g_variant_type_string_is_valid">
        <doc xml:space="preserve">Checks if @type_string is a valid
[GVariant type string](./struct.VariantType.html#gvariant-type-strings).

This call is equivalent to calling [func@GLib.VariantType.string_scan] and
confirming that the following character is a nul terminator.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if @type_string is exactly one valid type string
Since 2.24</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="type_string" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to any string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="string_scan" c:identifier="g_variant_type_string_scan" version="2.24">
        <doc xml:space="preserve">Scan for a single complete and valid GVariant type string in @string.

The memory pointed to by @limit (or bytes beyond it) is never
accessed.

If a valid type string is found, @endptr is updated to point to the
first character past the end of the string that was found and %TRUE
is returned.

If there is no valid type string starting at @string, or if the type
string does not end before @limit then %FALSE is returned.

For the simple case of checking if a string is a valid type string,
see [func@GLib.VariantType.string_is_valid].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if a valid type string was found</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to any string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="limit" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the end of @string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="endptr" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to store the end pointer</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="VoidFunc" c:type="GVoidFunc">
      <doc xml:space="preserve">Declares a type of function which takes no arguments
and has no return value. It is used to specify the type
function passed to g_atexit().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </callback>
    <function-macro name="WIN32_DLLMAIN_FOR_DLL_NAME" c:identifier="G_WIN32_DLLMAIN_FOR_DLL_NAME" introspectable="0">
      <doc xml:space="preserve">On Windows, this macro defines a DllMain() function that stores
the actual DLL name that the code being compiled will be included in.

On non-Windows platforms, expands to nothing.</doc>
      <parameters>
        <parameter name="static">
          <doc xml:space="preserve">empty or "static"</doc>
        </parameter>
        <parameter name="dll_name">
          <doc xml:space="preserve">the name of the (pointer to the) char array where
    the DLL name will be stored. If this is used, you must also
    include `windows.h`. If you need a more complex DLL entry
    point function, you cannot use this</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="WIN32_MSG_HANDLE" value="19981206" c:type="G_WIN32_MSG_HANDLE">
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="abort" c:identifier="g_abort" version="2.50" introspectable="0">
      <doc xml:space="preserve">A wrapper for the POSIX abort() function.

On Windows it is a function that makes extra effort (including a call
to abort()) to ensure that a debugger-catchable exception is thrown
before the program terminates.

See your C library manual for more details about abort().</doc>
    </function-macro>
    <function name="access" c:identifier="g_access" version="2.8">
      <doc xml:space="preserve">A wrapper for the POSIX access() function. This function is used to
test a pathname for one or several of read, write or execute
permissions, or just existence.

On Windows, the file protection mechanism is not at all POSIX-like,
and the underlying function in the C library only checks the
FAT-style READONLY attribute, and does not look at the ACL of a
file at all. This function is this in practise almost useless on
Windows. Software that needs to handle file permissions on Windows
more exactly should use the Win32 API.

See your C library manual for more details about access().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">zero if the pathname refers to an existing file system
    object that has all the tested permissions, or -1 otherwise
    or on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">as in access()</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="aligned_alloc" c:identifier="g_aligned_alloc" version="2.72">
      <doc xml:space="preserve">This function is similar to g_malloc(), allocating (@n_blocks * @n_block_bytes)
bytes, but care is taken to align the allocated memory to with the given
alignment value. Additionally, it will detect possible overflow during
multiplication.

If the allocation fails (because the system is out of memory),
the program is terminated.

Aligned memory allocations returned by this function can only be
freed using g_aligned_free_sized() or g_aligned_free().</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the allocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_blocks" transfer-ownership="none">
          <doc xml:space="preserve">the number of blocks to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="n_block_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the size of each block in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="alignment" transfer-ownership="none">
          <doc xml:space="preserve">the alignment to be enforced, which must be a positive power of 2
  and a multiple of `sizeof(void*)`</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="aligned_alloc0" c:identifier="g_aligned_alloc0" version="2.72">
      <doc xml:space="preserve">This function is similar to g_aligned_alloc(), but it will
also clear the allocated memory before returning it.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the allocated, cleared memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_blocks" transfer-ownership="none">
          <doc xml:space="preserve">the number of blocks to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="n_block_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the size of each block in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="alignment" transfer-ownership="none">
          <doc xml:space="preserve">the alignment to be enforced, which must be a positive power of 2
  and a multiple of `sizeof(void*)`</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="aligned_free" c:identifier="g_aligned_free" version="2.72">
      <doc xml:space="preserve">Frees the memory allocated by g_aligned_alloc().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the memory to deallocate</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="aligned_free_sized" c:identifier="g_aligned_free_sized" version="2.76">
      <doc xml:space="preserve">Frees the memory pointed to by @mem, assuming it is has the given @size and
@alignment.

If @mem is %NULL this is a no-op (and @size is ignored).

It is an error if @size doesn&#x2019;t match the size, or @alignment doesn&#x2019;t match
the alignment, passed when @mem was allocated. @size and @alignment are
passed to this function to allow optimizations in the allocator. If you
don&#x2019;t know either of them, use g_aligned_free() instead.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the memory to free</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="alignment" transfer-ownership="none">
          <doc xml:space="preserve">alignment of @mem</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">size of @mem, in bytes</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="alloca" c:identifier="g_alloca" introspectable="0">
      <doc xml:space="preserve">Allocates @size bytes on the stack; these bytes will be freed when the current
stack frame is cleaned up. This macro essentially just wraps the alloca()
function present on most UNIX variants.
Thus it provides the same advantages and pitfalls as alloca():

- alloca() is very fast, as on most systems it's implemented by just adjusting
  the stack pointer register.

- It doesn't cause any memory fragmentation, within its scope, separate alloca()
  blocks just build up and are released together at function end.

- Allocation sizes have to fit into the current stack frame. For instance in a
  threaded environment on Linux, the per-thread stack size is limited to 2 Megabytes,
  so be sparse with alloca() uses.

- Allocation failure due to insufficient stack space is not indicated with a %NULL
  return like e.g. with malloc(). Instead, most systems probably handle it the same
  way as out of stack space situations from infinite function recursion, i.e.
  with a segmentation fault.

- Allowing @size to be specified by an untrusted party would allow for them
  to trigger a segmentation fault by specifying a large size, leading to a
  denial of service vulnerability. @size must always be entirely under the
  control of the program.

- Special care has to be taken when mixing alloca() with GNU C variable sized arrays.
  Stack space allocated with alloca() in the same scope as a variable sized array
  will be freed together with the variable sized array upon exit of that scope, and
  not upon exit of the enclosing function scope.</doc>
      <parameters>
        <parameter name="size">
          <doc xml:space="preserve">number of bytes to allocate.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="alloca0" c:identifier="g_alloca0" version="2.72" introspectable="0">
      <doc xml:space="preserve">Wraps g_alloca() and initializes allocated memory to zeroes.
If @size is `0` it returns %NULL.

Note that the @size argument will be evaluated multiple times.</doc>
      <parameters>
        <parameter name="size">
          <doc xml:space="preserve">number of bytes to allocate.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="array_append_val" c:identifier="g_array_append_val" introspectable="0">
      <doc xml:space="preserve">Adds the value on to the end of the array. The array will grow in
size automatically if necessary.

`g_array_append_val()` is a macro which uses a reference to the value
parameter @v. This means that you cannot use it with literal values
such as `"27"`. You must use variables.</doc>
      <parameters>
        <parameter name="a">
          <doc xml:space="preserve">an array</doc>
        </parameter>
        <parameter name="v">
          <doc xml:space="preserve">the value to append to the #GArray</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="array_index" c:identifier="g_array_index" introspectable="0">
      <doc xml:space="preserve">Returns the element of a `GArray` at the given index. The return
value is cast to the given type. This is the main way to read or write an
element in a `GArray`.

Writing an element is typically done by reference, as in the following
example. This example gets a pointer to an element in a `GArray`, and then
writes to a field in it:
```c
  EDayViewEvent *event;
  // This gets a pointer to the 4th element in the array of
  // EDayViewEvent structs.
  event = &amp;g_array_index (events, EDayViewEvent, 3);
  event-&gt;start_time = g_get_current_time ();
```

This example reads from and writes to an array of integers:
```c
  g_autoptr(GArray) int_array = g_array_new (FALSE, FALSE, sizeof (guint));
  for (guint i = 0; i &lt; 10; i++)
    g_array_append_val (int_array, i);

  guint *my_int = &amp;g_array_index (int_array, guint, 1);
  g_print ("Int at index 1 is %u; decrementing it\n", *my_int);
  *my_int = *my_int - 1;
```</doc>
      <parameters>
        <parameter name="a">
          <doc xml:space="preserve">an array</doc>
        </parameter>
        <parameter name="t">
          <doc xml:space="preserve">the type of the elements</doc>
        </parameter>
        <parameter name="i">
          <doc xml:space="preserve">the index of the element to return</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="array_insert_val" c:identifier="g_array_insert_val" introspectable="0">
      <doc xml:space="preserve">Inserts an element into an array at the given index.

`g_array_insert_val()` is a macro which uses a reference to the value
parameter @v. This means that you cannot use it with literal values
such as `"27"`. You must use variables.</doc>
      <parameters>
        <parameter name="a">
          <doc xml:space="preserve">an array</doc>
        </parameter>
        <parameter name="i">
          <doc xml:space="preserve">the index to place the element at</doc>
        </parameter>
        <parameter name="v">
          <doc xml:space="preserve">the value to insert into the array</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="array_new_take" c:identifier="g_array_new_take" moved-to="Array.new_take" version="2.76" introspectable="0">
      <doc xml:space="preserve">Creates a new `GArray` with @data as array data, @len as length and a
reference count of 1.

This avoids having to copy the data manually, when it can just be
inherited.
After this call, @data belongs to the `GArray` and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with [func@GLib.free].

In case the elements need to be cleared when the array is freed, use
[func@GLib.Array.set_clear_func] to set a [callback@GLib.DestroyNotify]
function to perform such task.

Do not use it if @len or @element_size are greater than
 [`G_MAXUINT`](types.html#guint). `GArray` stores the length of its data in
 `guint`, which may be shorter than `gsize`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new #GArray</doc>
        <array name="GLib.Array" c:type="GArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1">
          <doc xml:space="preserve">an array of
  elements of @element_size</doc>
          <array length="1" zero-terminated="0" c:type="gpointer">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the number of elements in @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="clear" transfer-ownership="none">
          <doc xml:space="preserve">if true, `GArray` elements should be automatically cleared
    to 0 when they are allocated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="element_size" transfer-ownership="none">
          <doc xml:space="preserve">the size of each element in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="array_new_take_zero_terminated" c:identifier="g_array_new_take_zero_terminated" moved-to="Array.new_take_zero_terminated" version="2.76" introspectable="0">
      <doc xml:space="preserve">Creates a new `GArray` with @data as array data, computing the length of it
and setting the reference count to 1.

This avoids having to copy the data manually, when it can just be
inherited.
After this call, @data belongs to the `GArray` and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with [func@GLib.free].

The length is calculated by iterating through @data until the first `NULL`
element is found.

In case the elements need to be cleared when the array is freed, use
[func@GLib.Array.set_clear_func] to set a [callback@GLib.DestroyNotify]
function to perform such task.

Do not use it if @data length or @element_size are greater than
[`G_MAXUINT`](types.html#guint). `GArray` stores the length of its data in
`guint`, which may be shorter than `gsize`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new `GArray`</doc>
        <array name="GLib.Array" c:type="GArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1">
          <doc xml:space="preserve">an array
    of elements of @element_size, `NULL` terminated</doc>
          <array c:type="gpointer">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="clear" transfer-ownership="none">
          <doc xml:space="preserve">if true, `GArray` elements should be automatically cleared
    to 0 when they are allocated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="element_size" transfer-ownership="none">
          <doc xml:space="preserve">the size of each element in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="array_prepend_val" c:identifier="g_array_prepend_val" introspectable="0">
      <doc xml:space="preserve">Adds the value on to the start of the array. The array will grow in
size automatically if necessary.

This operation is slower than [func@GLib.array_append_val] since the
existing elements in the array have to be moved to make space for
the new element.

`g_array_prepend_val()` is a macro which uses a reference to the value
parameter @v. This means that you cannot use it with literal values
such as `"27"`. You must use variables.</doc>
      <parameters>
        <parameter name="a">
          <doc xml:space="preserve">an array</doc>
        </parameter>
        <parameter name="v">
          <doc xml:space="preserve">the value to prepend to the #GArray</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="ascii_digit_value" c:identifier="g_ascii_digit_value">
      <doc xml:space="preserve">Determines the numeric value of a character as a decimal digit. If the
character is not a decimal digit according to [func@GLib.ascii_isdigit],
`-1` is returned.

Differs from [func@GLib.unichar_digit_value] because it takes a char, so
there's no worry about sign extension if characters are signed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the numerical value of @c if it is a decimal digit, `-1` otherwise</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">an ASCII character</doc>
          <type name="gchar" c:type="gchar"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_dtostr" c:identifier="g_ascii_dtostr">
      <doc xml:space="preserve">Converts a `gdouble` to a string, using the '.' as
decimal point.

This function generates enough precision that converting
the string back using [func@GLib.ascii_strtod] gives the same machine-number
(on machines with IEEE compatible 64bit doubles). It is
guaranteed that the size of the resulting string will never
be larger than [const@GLib.ASCII_DTOSTR_BUF_SIZE] bytes, including the terminating
nul character, which is always added.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the pointer to the buffer with the converted string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a buffer to place the resulting string in</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="buf_len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the buffer</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="d" transfer-ownership="none">
          <doc xml:space="preserve">the value to convert</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_formatd" c:identifier="g_ascii_formatd">
      <doc xml:space="preserve">Converts a `gdouble` to a string, using the '.' as
decimal point. To format the number you pass in
a `printf()`-style format string. Allowed conversion
specifiers are 'e', 'E', 'f', 'F', 'g' and 'G'.

The @format must just be a single format specifier
starting with `%`, expecting a `gdouble` argument.

The returned buffer is guaranteed to be nul-terminated.

If you just want to want to serialize the value into a
string, use [func@GLib.ascii_dtostr].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the pointer to the buffer with the converted string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a buffer to place the resulting string in</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="buf_len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the buffer</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the `printf()`-style format to use for the
  code to use for converting</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="d" transfer-ownership="none">
          <doc xml:space="preserve">the value to convert</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="ascii_isalnum" c:identifier="g_ascii_isalnum" introspectable="0">
      <doc xml:space="preserve">Determines whether a character is alphanumeric.

Unlike the standard C library `isalnum()` function, this only
recognizes standard ASCII letters and ignores the locale,
returning false for all non-ASCII characters. Also, unlike
the standard library function, this takes a `char`, not an `int`,
so don't call it on `EOF`, but no need to cast to `guchar` before
passing a possibly non-ASCII character in.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">any character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ascii_isalpha" c:identifier="g_ascii_isalpha" introspectable="0">
      <doc xml:space="preserve">Determines whether a character is alphabetic (i.e. a letter).

Unlike the standard C library `isalpha()` function, this only
recognizes standard ASCII letters and ignores the locale,
returning false for all non-ASCII characters. Also, unlike
the standard library function, this takes a `char`, not an `int`,
so don't call it on `EOF`, but no need to cast to `guchar` before
passing a possibly non-ASCII character in.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">any character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ascii_iscntrl" c:identifier="g_ascii_iscntrl" introspectable="0">
      <doc xml:space="preserve">Determines whether a character is a control character.

Unlike the standard C library `iscntrl()` function, this only
recognizes standard ASCII control characters and ignores the
locale, returning false for all non-ASCII characters. Also,
unlike the standard library function, this takes a `char`, not
an `int`, so don't call it on `EOF`, but no need to cast to `guchar`
before passing a possibly non-ASCII character in.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">any character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ascii_isdigit" c:identifier="g_ascii_isdigit" introspectable="0">
      <doc xml:space="preserve">Determines whether a character is digit (0-9).

Unlike the standard C library `isdigit()` function, this takes
a `char`, not an `int`, so don't call it  on `EOF`, but no need to
cast to `guchar` before passing a possibly non-ASCII character in.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">any character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ascii_isgraph" c:identifier="g_ascii_isgraph" introspectable="0">
      <doc xml:space="preserve">Determines whether a character is a printing character and not a space.

Unlike the standard C library `isgraph()` function, this only
recognizes standard ASCII characters and ignores the locale,
returning false for all non-ASCII characters. Also, unlike
the standard library function, this takes a `char`, not an `int`,
so don't call it on `EOF`, but no need to cast to `guchar` before
passing a possibly non-ASCII character in.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">any character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ascii_islower" c:identifier="g_ascii_islower" introspectable="0">
      <doc xml:space="preserve">Determines whether a character is an ASCII lower case letter.

Unlike the standard C library `islower()` function, this only
recognizes standard ASCII letters and ignores the locale,
returning false for all non-ASCII characters. Also, unlike
the standard library function, this takes a `char`, not an `int`,
so don't call it on `EOF`, but no need to worry about casting
to `guchar` before passing a possibly non-ASCII character in.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">any character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ascii_isprint" c:identifier="g_ascii_isprint" introspectable="0">
      <doc xml:space="preserve">Determines whether a character is a printing character.

Unlike the standard C library `isprint()` function, this only
recognizes standard ASCII characters and ignores the locale,
returning false for all non-ASCII characters. Also, unlike
the standard library function, this takes a `char`, not an `int`,
so don't call it on `EOF`, but no need to cast to `guchar` before
passing a possibly non-ASCII character in.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">any character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ascii_ispunct" c:identifier="g_ascii_ispunct" introspectable="0">
      <doc xml:space="preserve">Determines whether a character is a punctuation character.

Unlike the standard C library `ispunct()` function, this only
recognizes standard ASCII letters and ignores the locale,
returning false for all non-ASCII characters. Also, unlike
the standard library function, this takes a `char`, not an `int`,
so don't call it on `EOF`, but no need to cast to `guchar` before
passing a possibly non-ASCII character in.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">any character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ascii_isspace" c:identifier="g_ascii_isspace" introspectable="0">
      <doc xml:space="preserve">Determines whether a character is a white-space character.

Unlike the standard C library `isspace()` function, this only
recognizes standard ASCII white-space and ignores the locale,
returning false for all non-ASCII characters. Also, unlike
the standard library function, this takes a `char`, not an `int`,
so don't call it on `EOF`, but no need to cast to `guchar` before
passing a possibly non-ASCII character in.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">any character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ascii_isupper" c:identifier="g_ascii_isupper" introspectable="0">
      <doc xml:space="preserve">Determines whether a character is an ASCII upper case letter.

Unlike the standard C library `isupper()` function, this only
recognizes standard ASCII letters and ignores the locale,
returning false for all non-ASCII characters. Also, unlike
the standard library function, this takes a `char`, not an `int`,
so don't call it on `EOF`, but no need to worry about casting
to `guchar` before passing a possibly non-ASCII character in.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">any character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ascii_isxdigit" c:identifier="g_ascii_isxdigit" introspectable="0">
      <doc xml:space="preserve">Determines whether a character is a hexadecimal-digit character.

Unlike the standard C library `isxdigit()` function, this takes
a `char`, not an `int`, so don't call it on `EOF`, but no need to
cast to `guchar` before passing a possibly non-ASCII character in.</doc>
      <parameters>
        <parameter name="c">
          <doc xml:space="preserve">any character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="ascii_strcasecmp" c:identifier="g_ascii_strcasecmp">
      <doc xml:space="preserve">Compare two strings, ignoring the case of ASCII characters.

Unlike the BSD `strcasecmp()` function, this only recognizes standard
ASCII letters and ignores the locale, treating all non-ASCII
bytes as if they are not letters.

This function should be used only on strings that are known to be
in encodings where the bytes corresponding to ASCII letters always
represent themselves. This includes UTF-8 and the ISO-8859-*
charsets, but not for instance double-byte encodings like the
Windows Codepage 932, where the trailing bytes of double-byte
characters include all ASCII letters. If you compare two CP932
strings using this function, you will get false matches.

Both @s1 and @s2 must be non-`NULL`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the strings match, a negative value if @s1 &lt; @s2,
  or a positive value if @s1 &gt; @s2</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="s1" transfer-ownership="none">
          <doc xml:space="preserve">string to compare with @s2</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="s2" transfer-ownership="none">
          <doc xml:space="preserve">string to compare with @s1</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_strdown" c:identifier="g_ascii_strdown">
      <doc xml:space="preserve">Converts all upper case ASCII letters to lower case ASCII letters, with
semantics that exactly match [func@GLib.ascii_tolower].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated string, with all the upper case characters in
  @str converted to lower case. (Note that this is unlike the old
  [func@GLib.strdown], which modified the string in place.)</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str in bytes, or `-1` if @str is nul-terminated</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_string_to_signed" c:identifier="g_ascii_string_to_signed" version="2.54" throws="1">
      <doc xml:space="preserve">A convenience function for converting a string to a signed number.

This function assumes that @str contains only a number of the given
@base that is within inclusive bounds limited by @min and @max. If
this is true, then the converted number is stored in @out_num. An
empty string is not a valid input. A string with leading or
trailing whitespace is also an invalid input.

@base can be between 2 and 36 inclusive. Hexadecimal numbers must
not be prefixed with "0x" or "0X". Such a problem does not exist
for octal numbers, since they were usually prefixed with a zero
which does not change the value of the parsed number.

Parsing failures result in an error with the `G_NUMBER_PARSER_ERROR`
domain. If the input is invalid, the error code will be
[error@GLib.NumberParserError.INVALID]. If the parsed number is out of
bounds - [error@GLib.NumberParserError.OUT_OF_BOUNDS].

See [func@GLib.ascii_strtoll] if you have more complex needs such as
parsing a string which starts with a number, but then has other
characters.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if @str was a number, false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string to convert</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="base" transfer-ownership="none">
          <doc xml:space="preserve">base of a parsed number</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="min" transfer-ownership="none">
          <doc xml:space="preserve">a lower bound (inclusive)</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="max" transfer-ownership="none">
          <doc xml:space="preserve">an upper bound (inclusive)</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="out_num" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">a return location for a number</doc>
          <type name="gint64" c:type="gint64*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_string_to_unsigned" c:identifier="g_ascii_string_to_unsigned" version="2.54" throws="1">
      <doc xml:space="preserve">A convenience function for converting a string to an unsigned number.

This function assumes that @str contains only a number of the given
@base that is within inclusive bounds limited by @min and @max. If
this is true, then the converted number is stored in @out_num. An
empty string is not a valid input. A string with leading or
trailing whitespace is also an invalid input. A string with a leading sign
(`-` or `+`) is not a valid input for the unsigned parser.

@base can be between 2 and 36 inclusive. Hexadecimal numbers must
not be prefixed with "0x" or "0X". Such a problem does not exist
for octal numbers, since they were usually prefixed with a zero
which does not change the value of the parsed number.

Parsing failures result in an error with the `G_NUMBER_PARSER_ERROR`
domain. If the input is invalid, the error code will be
[error@GLib.NumberParserError.INVALID]. If the parsed number is out of
bounds - [error@GLib.NumberParserError.OUT_OF_BOUNDS].

See [func@GLib.ascii_strtoull] if you have more complex needs such as
parsing a string which starts with a number, but then has other
characters.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if @str was a number, false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="base" transfer-ownership="none">
          <doc xml:space="preserve">base of a parsed number</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="min" transfer-ownership="none">
          <doc xml:space="preserve">a lower bound (inclusive)</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="max" transfer-ownership="none">
          <doc xml:space="preserve">an upper bound (inclusive)</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="out_num" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">a return location for a number</doc>
          <type name="guint64" c:type="guint64*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_strncasecmp" c:identifier="g_ascii_strncasecmp">
      <doc xml:space="preserve">Compare @s1 and @s2, ignoring the case of ASCII characters and any
characters after the first @n in each string. If either string is
less than @n bytes long, comparison will stop at the first nul byte
encountered.

Unlike the BSD `strncasecmp()` function, this only recognizes standard
ASCII letters and ignores the locale, treating all non-ASCII
characters as if they are not letters.

The same warning as in [func@GLib.ascii_strcasecmp] applies: Use this
function only on strings known to be in encodings where bytes
corresponding to ASCII letters always represent themselves.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the strings match, a negative value if @s1 &lt; @s2,
  or a positive value if @s1 &gt; @s2</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="s1" transfer-ownership="none">
          <doc xml:space="preserve">string to compare with @s2</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="s2" transfer-ownership="none">
          <doc xml:space="preserve">string to compare with @s1</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of characters to compare</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_strtod" c:identifier="g_ascii_strtod">
      <doc xml:space="preserve">Converts a string to a floating point value.

This function behaves like the standard `strtod()` function
does in the C locale. It does this without actually changing
the current locale, since that would not be thread-safe.
A limitation of the implementation is that this function
will still accept localized versions of infinities and NANs.

This function is typically used when reading configuration
files or other non-user input that should be locale independent.
To handle input from the user you should normally use the
locale-sensitive system `strtod()` function.

To convert from a gdouble to a string in a locale-insensitive
way, use [func@GLib.ascii_dtostr].

If the correct value would cause overflow, plus or minus `HUGE_VAL`
is returned (according to the sign of the value), and `ERANGE` is
stored in `errno`. If the correct value would cause underflow,
zero is returned and `ERANGE` is stored in `errno`.

This function resets `errno` before calling `strtod()` so that
you can reliably detect overflow and underflow.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the converted value</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="nptr" transfer-ownership="none">
          <doc xml:space="preserve">the string to convert to a numeric value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="endptr" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-`NULL`, it returns the
  character after the last character used in the conversion</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_strtoll" c:identifier="g_ascii_strtoll" version="2.12">
      <doc xml:space="preserve">Converts a string to a `gint64` value.

This function behaves like the standard `strtoll()` function
does in the C locale. It does this without actually
changing the current locale, since that would not be
thread-safe.

This function is typically used when reading configuration
files or other non-user input that should be locale independent.
To handle input from the user you should normally use the
locale-sensitive system `strtoll()` function.

If the correct value would cause overflow, [const@GLib.MAXINT64] or
[const@GLib.MININT64] is returned, and `ERANGE` is stored in `errno`.
If the base is outside the valid range, zero is returned, and
`EINVAL` is stored in `errno`. If the
string conversion fails, zero is returned, and @endptr returns @nptr
(if @endptr is non-`NULL`).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the converted value, or zero on error</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="nptr" transfer-ownership="none">
          <doc xml:space="preserve">the string to convert to a numeric value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="endptr" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-`NULL`, it returns the
  character after the last character used in the conversion</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="base" transfer-ownership="none">
          <doc xml:space="preserve">to be used for the conversion, 2..36 or 0</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_strtoull" c:identifier="g_ascii_strtoull" version="2.2">
      <doc xml:space="preserve">Converts a string to a `guint64` value.

This function behaves like the standard `strtoull()` function
does in the C locale. It does this without actually
changing the current locale, since that would not be
thread-safe.

Note that input with a leading minus sign (`-`) is accepted, and will return
the negation of the parsed number, unless that would overflow a `guint64`.
Critically, this means you cannot assume that a short fixed length input will
result in a low return value, as the input could have a leading `-`.

This function is typically used when reading configuration
files or other non-user input that should be locale independent.
To handle input from the user you should normally use the
locale-sensitive system `strtoull()` function.

If the correct value would cause overflow, [const@GLib.MAXUINT64]
is returned, and `ERANGE` is stored in `errno`.
If the base is outside the valid range, zero is returned, and
`EINVAL` is stored in `errno`.
If the string conversion fails, zero is returned, and @endptr returns
@nptr (if @endptr is non-`NULL`).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the converted value, or zero on error</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="nptr" transfer-ownership="none">
          <doc xml:space="preserve">the string to convert to a numeric value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="endptr" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-`NULL`, it returns the
  character after the last character used in the conversion</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="base" transfer-ownership="none">
          <doc xml:space="preserve">to be used for the conversion, 2..36 or 0</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_strup" c:identifier="g_ascii_strup">
      <doc xml:space="preserve">Converts all lower case ASCII letters to upper case ASCII letters, with
semantics that exactly match [func@GLib.ascii_toupper].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated string, with all the lower case characters
  in @str converted to upper case. (Note that this is unlike the old
  [func@GLib.strup], which modified the string in place.)</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str in bytes, or `-1` if @str is nul-terminated</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_tolower" c:identifier="g_ascii_tolower">
      <doc xml:space="preserve">Convert a character to ASCII lower case. If the character is not an
ASCII upper case letter, it is returned unchanged.

Unlike the standard C library `tolower()` function, this only
recognizes standard ASCII letters and ignores the locale, returning
all non-ASCII characters unchanged, even if they are lower case
letters in a particular character set. Also unlike the standard
library function, this takes and returns a char, not an int, so
don't call it on `EOF` but no need to worry about casting to `guchar`
before passing a possibly non-ASCII character in.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the result of the conversion</doc>
        <type name="gchar" c:type="gchar"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">any character</doc>
          <type name="gchar" c:type="gchar"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_toupper" c:identifier="g_ascii_toupper">
      <doc xml:space="preserve">Convert a character to ASCII upper case. If the character is not an
ASCII lower case letter, it is returned unchanged.

Unlike the standard C library `toupper()` function, this only
recognizes standard ASCII letters and ignores the locale, returning
all non-ASCII characters unchanged, even if they are upper case
letters in a particular character set. Also unlike the standard
library function, this takes and returns a char, not an int, so
don't call it on `EOF` but no need to worry about casting to `guchar`
before passing a possibly non-ASCII character in.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the result of the conversion</doc>
        <type name="gchar" c:type="gchar"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">any character</doc>
          <type name="gchar" c:type="gchar"/>
        </parameter>
      </parameters>
    </function>
    <function name="ascii_xdigit_value" c:identifier="g_ascii_xdigit_value">
      <doc xml:space="preserve">Determines the numeric value of a character as a hexadecimal digit. If the
character is not a hex digit according to [func@GLib.ascii_isxdigit],
`-1` is returned.

Differs from [func@GLib.unichar_xdigit_value] because it takes a char, so
there's no worry about sign extension if characters are signed.

Differs from [func@GLib.unichar_xdigit_value] because it takes a char, so
there's no worry about sign extension if characters are signed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the numerical value of @c if it is a hex digit, `-1` otherwise</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">an ASCII character</doc>
          <type name="gchar" c:type="gchar"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="assert" c:identifier="g_assert" introspectable="0">
      <doc xml:space="preserve">Debugging macro to terminate the application if the assertion
fails.

If the assertion fails (i.e. the expression is not true),
an error message is logged and the application is terminated.

The macro can be turned off in final releases of code by defining
`G_DISABLE_ASSERT` when compiling the application, so code must not
depend on any side effects from @expr. Similarly, it must not be used
in unit tests, otherwise the unit tests will be ineffective if compiled
with `G_DISABLE_ASSERT`. Use [func@GLib.assert_true] and related macros
in unit tests instead.</doc>
      <parameters>
        <parameter name="expr">
          <doc xml:space="preserve">the expression to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_cmpfloat" c:identifier="g_assert_cmpfloat" version="2.16" introspectable="0">
      <doc xml:space="preserve">Debugging macro to compare two floating point numbers.

The effect of `g_assert_cmpfloat (n1, op, n2)` is the same as
`g_assert_true (n1 op n2)`. The advantage of this macro is
that it can produce a message that includes the actual values
of @n1 and @n2.</doc>
      <parameters>
        <parameter name="n1">
          <doc xml:space="preserve">a floating point number</doc>
        </parameter>
        <parameter name="cmp">
          <doc xml:space="preserve">the comparison operator to use.
  One of `==`, `!=`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=`</doc>
        </parameter>
        <parameter name="n2">
          <doc xml:space="preserve">another floating point number</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_cmpfloat_with_epsilon" c:identifier="g_assert_cmpfloat_with_epsilon" version="2.58" introspectable="0">
      <doc xml:space="preserve">Debugging macro to compare two floating point numbers within an epsilon.

The effect of `g_assert_cmpfloat_with_epsilon (n1, n2, epsilon)` is
the same as `g_assert_true (abs (n1 - n2) &lt; epsilon)`. The advantage
of this macro is that it can produce a message that includes the
actual values of @n1 and @n2.</doc>
      <parameters>
        <parameter name="n1">
          <doc xml:space="preserve">a floating point number</doc>
        </parameter>
        <parameter name="n2">
          <doc xml:space="preserve">another floating point number</doc>
        </parameter>
        <parameter name="epsilon">
          <doc xml:space="preserve">a numeric value that expresses the expected tolerance
  between @n1 and @n2</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_cmphex" c:identifier="g_assert_cmphex" version="2.16" introspectable="0">
      <doc xml:space="preserve">Debugging macro to compare to unsigned integers.

This is a variant of [func@GLib.assert_cmpuint] that displays
the numbers in hexadecimal notation in the message.</doc>
      <parameters>
        <parameter name="n1">
          <doc xml:space="preserve">an unsigned integer</doc>
        </parameter>
        <parameter name="cmp">
          <doc xml:space="preserve">the comparison operator to use.
  One of `==`, `!=`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=`</doc>
        </parameter>
        <parameter name="n2">
          <doc xml:space="preserve">another unsigned integer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_cmpint" c:identifier="g_assert_cmpint" version="2.16" introspectable="0">
      <doc xml:space="preserve">Debugging macro to compare two integers.

The effect of `g_assert_cmpint (n1, op, n2)` is the same as
`g_assert_true (n1 op n2)`. The advantage of this macro is
that it can produce a message that includes the actual values
of @n1 and @n2.</doc>
      <parameters>
        <parameter name="n1">
          <doc xml:space="preserve">an integer</doc>
        </parameter>
        <parameter name="cmp">
          <doc xml:space="preserve">the comparison operator to use.
  One of `==`, `!=`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=`</doc>
        </parameter>
        <parameter name="n2">
          <doc xml:space="preserve">another integer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_cmpmem" c:identifier="g_assert_cmpmem" version="2.46" introspectable="0">
      <doc xml:space="preserve">Debugging macro to compare memory regions.

If the comparison fails, an error message is logged and the
application is either terminated or the testcase marked as failed.

The effect of `g_assert_cmpmem (m1, l1, m2, l2)` is the same as
`g_assert_true (l1 == l2 &amp;&amp; memcmp (m1, m2, l1) == 0)`. The advantage
of this macro is that it can produce a message that includes the actual
values of @l1 and @l2.

@m1 may be `NULL` if (and only if) @l1 is zero; similarly for @m2 and @l2.

```c
  g_assert_cmpmem (buf-&gt;data, buf-&gt;len, expected, sizeof (expected));
```</doc>
      <parameters>
        <parameter name="m1">
          <doc xml:space="preserve">pointer to a buffer</doc>
        </parameter>
        <parameter name="l1">
          <doc xml:space="preserve">length of @m1 in bytes</doc>
        </parameter>
        <parameter name="m2">
          <doc xml:space="preserve">pointer to another buffer</doc>
        </parameter>
        <parameter name="l2">
          <doc xml:space="preserve">length of @m2 in bytes</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_cmpstr" c:identifier="g_assert_cmpstr" version="2.16" introspectable="0">
      <doc xml:space="preserve">Debugging macro to compare two strings.

If the comparison fails, an error message is logged and the
application is either terminated or the testcase marked as failed.
The strings are compared using [GLib.strcmp0].

The effect of `g_assert_cmpstr (s1, op, s2)` is the same as
`g_assert_true (g_strcmp0 (s1, s2) op 0)`. The advantage of this
macro is that it can produce a message that includes the actual
values of @s1 and @s2.

```c
  g_assert_cmpstr (mystring, ==, "fubar");
```</doc>
      <parameters>
        <parameter name="s1">
          <doc xml:space="preserve">a string</doc>
        </parameter>
        <parameter name="cmp">
          <doc xml:space="preserve">the comparison operator to use.
    One of `==`, `!=`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=`</doc>
        </parameter>
        <parameter name="s2">
          <doc xml:space="preserve">another string</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_cmpstrv" c:identifier="g_assert_cmpstrv" version="2.68" introspectable="0">
      <doc xml:space="preserve">Debugging macro to check if two `NULL`-terminated string arrays (i.e. 2
`GStrv`) are equal.

If they are not equal, an error message is logged and the application is
either terminated or the testcase marked as failed. If both arrays are
`NULL`, the check passes. If one array is `NULL` but the other is not,
an error message is logged.

The effect of `g_assert_cmpstrv (strv1, strv2)` is the same as
`g_assert_true (g_strv_equal (strv1, strv2))` (if both arrays are not
`NULL`). The advantage of this macro is that it can produce a message that
includes how @strv1 and @strv2 are different.

```c
  const char *expected[] = { "one", "two", "three", NULL };
  g_assert_cmpstrv (mystrv, expected);
```</doc>
      <parameters>
        <parameter name="strv1">
          <doc xml:space="preserve">a string array</doc>
        </parameter>
        <parameter name="strv2">
          <doc xml:space="preserve">another string array</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_cmpuint" c:identifier="g_assert_cmpuint" version="2.16" introspectable="0">
      <doc xml:space="preserve">Debugging macro to compare two unsigned integers.

The effect of `g_assert_cmpuint (n1, op, n2)` is the same as
`g_assert_true (n1 op n2)`. The advantage of this macro is
that it can produce a message that includes the actual values
of @n1 and @n2.</doc>
      <parameters>
        <parameter name="n1">
          <doc xml:space="preserve">an unsigned integer</doc>
        </parameter>
        <parameter name="cmp">
          <doc xml:space="preserve">the comparison operator to use.
  One of `==`, `!=`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=`</doc>
        </parameter>
        <parameter name="n2">
          <doc xml:space="preserve">another unsigned integer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_cmpvariant" c:identifier="g_assert_cmpvariant" version="2.60" introspectable="0">
      <doc xml:space="preserve">Debugging macro to compare two [struct@GLib.Variant] values.

If the comparison fails, an error message is logged and the
application is either terminated or the testcase marked as failed.
The variants are compared using [method@GLib.Variant.equal].

The effect of `g_assert_cmpvariant (v1, v2)` is the same as
`g_assert_true (g_variant_equal (v1, v2))`. The advantage of
this macro is that it can produce a message that includes the
actual values of @v1 and @v2.</doc>
      <parameters>
        <parameter name="v1">
          <doc xml:space="preserve">pointer to a `GVariant`</doc>
        </parameter>
        <parameter name="v2">
          <doc xml:space="preserve">pointer to another `GVariant`</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_error" c:identifier="g_assert_error" version="2.20" introspectable="0">
      <doc xml:space="preserve">Debugging macro to check that a method has returned
the correct [struct@GLib.Error].

The effect of `g_assert_error (err, dom, c)` is the same as
`g_assert_true (err != NULL &amp;&amp; err-&gt;domain == dom &amp;&amp; err-&gt;code == c)`.
The advantage of this macro is that it can produce a message that
includes the incorrect error message and code.

This can only be used to test for a specific error. If you want to
test that @err is set, but don't care what it's set to, just use
`g_assert_nonnull (err)`.</doc>
      <parameters>
        <parameter name="err">
          <doc xml:space="preserve">a `GError`</doc>
        </parameter>
        <parameter name="dom">
          <doc xml:space="preserve">the expected error domain (a `GQuark`)</doc>
        </parameter>
        <parameter name="c">
          <doc xml:space="preserve">the expected error code</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_false" c:identifier="g_assert_false" version="2.38" introspectable="0">
      <doc xml:space="preserve">Debugging macro to check an expression is false.

If the assertion fails (i.e. the expression is not false),
an error message is logged and the application is either
terminated or the testcase marked as failed.

Note that unlike [func@GLib.assert], this macro is unaffected by whether
`G_DISABLE_ASSERT` is defined. Hence it should only be used in tests and,
conversely, [func@GLib.assert] should not be used in tests.

See [func@GLib.test_set_nonfatal_assertions].</doc>
      <parameters>
        <parameter name="expr">
          <doc xml:space="preserve">the expression to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_no_errno" c:identifier="g_assert_no_errno" version="2.66" introspectable="0">
      <doc xml:space="preserve">Debugging macro to check that an expression has a non-negative return value,
as used by traditional POSIX functions (such as `rmdir()`) to indicate
success.

If the assertion fails (i.e. the @expr returns a negative value), an error
message is logged and the testcase is marked as failed. The error message
will contain the value of `errno` and its human-readable message from
[func@GLib.strerror].

This macro will clear the value of `errno` before executing @expr.</doc>
      <parameters>
        <parameter name="expr">
          <doc xml:space="preserve">the expression to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_no_error" c:identifier="g_assert_no_error" version="2.20" introspectable="0">
      <doc xml:space="preserve">Debugging macro to check that a [struct@GLib.Error] is not set.

The effect of `g_assert_no_error (err)` is the same as
`g_assert_true (err == NULL)`. The advantage of this macro
is that it can produce a message that includes the error
message and code.</doc>
      <parameters>
        <parameter name="err">
          <doc xml:space="preserve">a `GError`</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_nonnull" c:identifier="g_assert_nonnull" version="2.40" introspectable="0">
      <doc xml:space="preserve">Debugging macro to check an expression is not `NULL`.

If the assertion fails (i.e. the expression is `NULL`),
an error message is logged and the application is either
terminated or the testcase marked as failed.

Note that unlike [func@GLib.assert], this macro is unaffected by whether
`G_DISABLE_ASSERT` is defined. Hence it should only be used in tests and,
conversely, [func@GLib.assert] should not be used in tests.

See [func@GLib.test_set_nonfatal_assertions].</doc>
      <parameters>
        <parameter name="expr">
          <doc xml:space="preserve">the expression to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_not_reached" c:identifier="g_assert_not_reached" introspectable="0">
      <doc xml:space="preserve">Debugging macro to terminate the application if it is ever reached.

If it is reached, an error message is logged and the application
is terminated.

The macro can be turned off in final releases of code by defining
`G_DISABLE_ASSERT` when compiling the application. Hence, it should
not be used in unit tests, where assertions should always be effective.</doc>
    </function-macro>
    <function-macro name="assert_null" c:identifier="g_assert_null" version="2.38" introspectable="0">
      <doc xml:space="preserve">Debugging macro to check an expression is `NULL`.

If the assertion fails (i.e. the expression is not `NULL`),
an error message is logged and the application is either
terminated or the testcase marked as failed.

Note that unlike [func@GLib.assert], this macro is unaffected by whether
`G_DISABLE_ASSERT` is defined. Hence it should only be used in tests and,
conversely, [func@GLib.assert] should not be used in tests.

See [func@GLib.test_set_nonfatal_assertions].</doc>
      <parameters>
        <parameter name="expr">
          <doc xml:space="preserve">the expression to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="assert_true" c:identifier="g_assert_true" version="2.38" introspectable="0">
      <doc xml:space="preserve">Debugging macro to check that an expression is true.

If the assertion fails (i.e. the expression is not true),
an error message is logged and the application is either
terminated or the testcase marked as failed.

Note that unlike [func@GLib.assert], this macro is unaffected by
whether `G_DISABLE_ASSERT` is defined. Hence it should only be used
in tests and, conversely, [func@GLib.assert] should not be used
in tests.

See [func@GLib.test_set_nonfatal_assertions].</doc>
      <parameters>
        <parameter name="expr">
          <doc xml:space="preserve">the expression to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="assert_warning" c:identifier="g_assert_warning">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <type name="gint" c:type="const int"/>
        </parameter>
        <parameter name="pretty_function" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="expression" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="assertion_message" c:identifier="g_assertion_message">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="assertion_message_cmpint" c:identifier="g_assertion_message_cmpint">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="expr" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="arg1" transfer-ownership="none">
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="cmp" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="arg2" transfer-ownership="none">
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="numtype" transfer-ownership="none">
          <type name="gchar" c:type="char"/>
        </parameter>
      </parameters>
    </function>
    <function name="assertion_message_cmpnum" c:identifier="g_assertion_message_cmpnum" introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="expr" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="arg1" transfer-ownership="none">
          <type name="long double" c:type="long double"/>
        </parameter>
        <parameter name="cmp" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="arg2" transfer-ownership="none">
          <type name="long double" c:type="long double"/>
        </parameter>
        <parameter name="numtype" transfer-ownership="none">
          <type name="gchar" c:type="char"/>
        </parameter>
      </parameters>
    </function>
    <function name="assertion_message_cmpstr" c:identifier="g_assertion_message_cmpstr">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="expr" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="arg1" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="cmp" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="arg2" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="assertion_message_cmpstrv" c:identifier="g_assertion_message_cmpstrv">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="expr" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="arg1" transfer-ownership="none">
          <type name="utf8" c:type="const char* const*"/>
        </parameter>
        <parameter name="arg2" transfer-ownership="none">
          <type name="utf8" c:type="const char* const*"/>
        </parameter>
        <parameter name="first_wrong_idx" transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="assertion_message_error" c:identifier="g_assertion_message_error">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="expr" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="Error" c:type="const GError*"/>
        </parameter>
        <parameter name="error_domain" transfer-ownership="none">
          <type name="Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="error_code" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="assertion_message_expr" c:identifier="g_assertion_message_expr" introspectable="0">
      <doc xml:space="preserve">Internal function used to print messages from the public
g_assert() and g_assert_not_reached() macros.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">log domain</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <doc xml:space="preserve">file containing the assertion</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <doc xml:space="preserve">line number of the assertion</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:space="preserve">function containing the assertion</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="expr" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">expression which failed</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="async_queue_new" c:identifier="g_async_queue_new" moved-to="AsyncQueue.new">
      <doc xml:space="preserve">Creates a new asynchronous queue.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GAsyncQueue. Free with g_async_queue_unref()</doc>
        <type name="AsyncQueue" c:type="GAsyncQueue*"/>
      </return-value>
    </function>
    <function name="async_queue_new_full" c:identifier="g_async_queue_new_full" moved-to="AsyncQueue.new_full" version="2.16">
      <doc xml:space="preserve">Creates a new asynchronous queue and sets up a destroy notify
function that is used to free any remaining queue items when
the queue is destroyed after the final unref.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GAsyncQueue. Free with g_async_queue_unref()</doc>
        <type name="AsyncQueue" c:type="GAsyncQueue*"/>
      </return-value>
      <parameters>
        <parameter name="item_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">function to free queue elements</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="atexit" c:identifier="g_atexit" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Specifies a function to be called at normal program termination.

Since GLib 2.8.2, on Windows g_atexit() actually is a preprocessor
macro that maps to a call to the atexit() function in the C
library. This means that in case the code that calls g_atexit(),
i.e. atexit(), is in a DLL, the function will be called when the
DLL is detached from the program. This typically makes more sense
than that the function is called when the GLib DLL is detached,
which happened earlier when g_atexit() was a function in the GLib
DLL.

The behaviour of atexit() in the context of dynamically loaded
modules is not formally specified and varies wildly.

On POSIX systems, calling g_atexit() (or atexit()) in a dynamically
loaded module which is unloaded before the program terminates might
well cause a crash at program exit.

Some POSIX systems implement atexit() like Windows, and have each
dynamically loaded module maintain an own atexit chain that is
called when the module is unloaded.

On other POSIX systems, before a dynamically loaded module is
unloaded, the registered atexit functions (if any) residing in that
module are called, regardless where the code that registered them
resided. This is presumably the most robust approach.

As can be seen from the above, for portability it's best to avoid
calling g_atexit() (or atexit()) except in the main executable of a
program.</doc>
      <doc-deprecated xml:space="preserve">It is best to avoid g_atexit().</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="func" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">the function to call on normal program termination.</doc>
          <type name="VoidFunc" c:type="GVoidFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_add" c:identifier="g_atomic_int_add" version="2.4">
      <doc xml:space="preserve">Atomically adds @val to the value of @atomic.

Think of this operation as an atomic version of
`{ tmp = *atomic; *atomic += val; return tmp; }`.

This call acts as a full compiler and hardware memory barrier.

Before version 2.30, this function did not return a value
(but g_atomic_int_exchange_and_add() did, and had the same meaning).

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of @atomic before the add, signed</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint or #guint</doc>
          <type name="gpointer" c:type="volatile gint*"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">the value to add</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_and" c:identifier="g_atomic_int_and" version="2.30">
      <doc xml:space="preserve">Performs an atomic bitwise 'and' of the value of @atomic and @val,
storing the result back in @atomic.

This call acts as a full compiler and hardware memory barrier.

Think of this operation as an atomic version of
`{ tmp = *atomic; *atomic &amp;= val; return tmp; }`.

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of @atomic before the operation, unsigned</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint or #guint</doc>
          <type name="gpointer" c:type="volatile guint*"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">the value to 'and'</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_compare_and_exchange" c:identifier="g_atomic_int_compare_and_exchange" version="2.4">
      <doc xml:space="preserve">Compares @atomic to @oldval and, if equal, sets it to @newval.
If @atomic was not equal to @oldval then no change occurs.

This compare and exchange is done atomically.

Think of this operation as an atomic version of
`{ if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }`.

This call acts as a full compiler and hardware memory barrier.

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the exchange took place</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint or #guint</doc>
          <type name="gpointer" c:type="volatile gint*"/>
        </parameter>
        <parameter name="oldval" transfer-ownership="none">
          <doc xml:space="preserve">the value to compare with</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="newval" transfer-ownership="none">
          <doc xml:space="preserve">the value to conditionally replace with</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_compare_and_exchange_full" c:identifier="g_atomic_int_compare_and_exchange_full" version="2.74">
      <doc xml:space="preserve">Compares @atomic to @oldval and, if equal, sets it to @newval.
If @atomic was not equal to @oldval then no change occurs.
In any case the value of @atomic before this operation is stored in @preval.

This compare and exchange is done atomically.

Think of this operation as an atomic version of
`{ *preval = *atomic; if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }`.

This call acts as a full compiler and hardware memory barrier.

See also g_atomic_int_compare_and_exchange()</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the exchange took place</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint or #guint</doc>
          <type name="gpointer" c:type="gint*"/>
        </parameter>
        <parameter name="oldval" transfer-ownership="none">
          <doc xml:space="preserve">the value to compare with</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="newval" transfer-ownership="none">
          <doc xml:space="preserve">the value to conditionally replace with</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="preval" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the contents of @atomic before this operation</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_dec_and_test" c:identifier="g_atomic_int_dec_and_test" version="2.4">
      <doc xml:space="preserve">Decrements the value of @atomic by 1.

Think of this operation as an atomic version of
`{ *atomic -= 1; return (*atomic == 0); }`.

This call acts as a full compiler and hardware memory barrier.

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the resultant value is zero</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint or #guint</doc>
          <type name="gpointer" c:type="volatile gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_exchange" c:identifier="g_atomic_int_exchange" version="2.74">
      <doc xml:space="preserve">Sets the @atomic to @newval and returns the old value from @atomic.

This exchange is done atomically.

Think of this operation as an atomic version of
`{ tmp = *atomic; *atomic = val; return tmp; }`.

This call acts as a full compiler and hardware memory barrier.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of @atomic before the exchange, signed</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint or #guint</doc>
          <type name="gpointer" c:type="gint*"/>
        </parameter>
        <parameter name="newval" transfer-ownership="none">
          <doc xml:space="preserve">the value to replace with</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_exchange_and_add" c:identifier="g_atomic_int_exchange_and_add" version="2.4" deprecated="1" deprecated-version="2.30">
      <doc xml:space="preserve">This function existed before g_atomic_int_add() returned the prior
value of the integer (which it now does).  It is retained only for
compatibility reasons.  Don't use this function in new code.</doc>
      <doc-deprecated xml:space="preserve">Use g_atomic_int_add() instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of @atomic before the add, signed</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint</doc>
          <type name="gpointer" c:type="volatile gint*"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">the value to add</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_get" c:identifier="g_atomic_int_get" version="2.4">
      <doc xml:space="preserve">Gets the current value of @atomic.

This call acts as a full compiler and hardware
memory barrier (before the get).

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of the integer</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint or #guint</doc>
          <type name="gpointer" c:type="volatile const gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_inc" c:identifier="g_atomic_int_inc" version="2.4">
      <doc xml:space="preserve">Increments the value of @atomic by 1.

Think of this operation as an atomic version of `{ *atomic += 1; }`.

This call acts as a full compiler and hardware memory barrier.

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint or #guint</doc>
          <type name="gpointer" c:type="volatile gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_or" c:identifier="g_atomic_int_or" version="2.30">
      <doc xml:space="preserve">Performs an atomic bitwise 'or' of the value of @atomic and @val,
storing the result back in @atomic.

Think of this operation as an atomic version of
`{ tmp = *atomic; *atomic |= val; return tmp; }`.

This call acts as a full compiler and hardware memory barrier.

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of @atomic before the operation, unsigned</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint or #guint</doc>
          <type name="gpointer" c:type="volatile guint*"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">the value to 'or'</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_set" c:identifier="g_atomic_int_set" version="2.4">
      <doc xml:space="preserve">Sets the value of @atomic to @newval.

This call acts as a full compiler and hardware
memory barrier (after the set).

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint or #guint</doc>
          <type name="gpointer" c:type="volatile gint*"/>
        </parameter>
        <parameter name="newval" transfer-ownership="none">
          <doc xml:space="preserve">a new value to store</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_int_xor" c:identifier="g_atomic_int_xor" version="2.30">
      <doc xml:space="preserve">Performs an atomic bitwise 'xor' of the value of @atomic and @val,
storing the result back in @atomic.

Think of this operation as an atomic version of
`{ tmp = *atomic; *atomic ^= val; return tmp; }`.

This call acts as a full compiler and hardware memory barrier.

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of @atomic before the operation, unsigned</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gint or #guint</doc>
          <type name="gpointer" c:type="volatile guint*"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">the value to 'xor'</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_pointer_add" c:identifier="g_atomic_pointer_add" version="2.30">
      <doc xml:space="preserve">Atomically adds @val to the value of @atomic.

Think of this operation as an atomic version of
`{ tmp = *atomic; *atomic += val; return tmp; }`.

This call acts as a full compiler and hardware memory barrier.

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.

In GLib 2.80, the return type was changed from #gssize to #gintptr to add
support for platforms with 128-bit pointers. This should not affect existing
code.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of @atomic before the add, signed</doc>
        <type name="gintptr" c:type="gintptr"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">the value to add</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_pointer_and" c:identifier="g_atomic_pointer_and" version="2.30">
      <doc xml:space="preserve">Performs an atomic bitwise 'and' of the value of @atomic and @val,
storing the result back in @atomic.

Think of this operation as an atomic version of
`{ tmp = *atomic; *atomic &amp;= val; return tmp; }`.

This call acts as a full compiler and hardware memory barrier.

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.

In GLib 2.80, the return type was changed from #gsize to #guintptr to add
support for platforms with 128-bit pointers. This should not affect existing
code.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of @atomic before the operation, unsigned</doc>
        <type name="guintptr" c:type="guintptr"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">the value to 'and'</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_pointer_compare_and_exchange" c:identifier="g_atomic_pointer_compare_and_exchange" version="2.4">
      <doc xml:space="preserve">Compares @atomic to @oldval and, if equal, sets it to @newval.
If @atomic was not equal to @oldval then no change occurs.

This compare and exchange is done atomically.

Think of this operation as an atomic version of
`{ if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }`.

This call acts as a full compiler and hardware memory barrier.

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the exchange took place</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="oldval" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the value to compare with</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="newval" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the value to conditionally replace with</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_pointer_compare_and_exchange_full" c:identifier="g_atomic_pointer_compare_and_exchange_full" version="2.74">
      <doc xml:space="preserve">Compares @atomic to @oldval and, if equal, sets it to @newval.
If @atomic was not equal to @oldval then no change occurs.
In any case the value of @atomic before this operation is stored in @preval.

This compare and exchange is done atomically.

Think of this operation as an atomic version of
`{ *preval = *atomic; if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }`.

This call acts as a full compiler and hardware memory barrier.

See also g_atomic_pointer_compare_and_exchange()</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the exchange took place</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="oldval" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the value to compare with</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="newval" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the value to conditionally replace with</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="preval" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the contents of @atomic before this operation</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_pointer_exchange" c:identifier="g_atomic_pointer_exchange" version="2.74">
      <doc xml:space="preserve">Sets the @atomic to @newval and returns the old value from @atomic.

This exchange is done atomically.

Think of this operation as an atomic version of
`{ tmp = *atomic; *atomic = val; return tmp; }`.

This call acts as a full compiler and hardware memory barrier.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the value of @atomic before the exchange</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="newval" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the value to replace with</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_pointer_get" c:identifier="g_atomic_pointer_get" version="2.4">
      <doc xml:space="preserve">Gets the current value of @atomic.

This call acts as a full compiler and hardware
memory barrier (before the get).

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the value of the pointer</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_pointer_or" c:identifier="g_atomic_pointer_or" version="2.30">
      <doc xml:space="preserve">Performs an atomic bitwise 'or' of the value of @atomic and @val,
storing the result back in @atomic.

Think of this operation as an atomic version of
`{ tmp = *atomic; *atomic |= val; return tmp; }`.

This call acts as a full compiler and hardware memory barrier.

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.

In GLib 2.80, the return type was changed from #gsize to #guintptr to add
support for platforms with 128-bit pointers. This should not affect existing
code.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of @atomic before the operation, unsigned</doc>
        <type name="guintptr" c:type="guintptr"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">the value to 'or'</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_pointer_set" c:identifier="g_atomic_pointer_set" version="2.4">
      <doc xml:space="preserve">Sets the value of @atomic to @newval.

This call acts as a full compiler and hardware
memory barrier (after the set).

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="newval" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a new value to store</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_pointer_xor" c:identifier="g_atomic_pointer_xor" version="2.30">
      <doc xml:space="preserve">Performs an atomic bitwise 'xor' of the value of @atomic and @val,
storing the result back in @atomic.

Think of this operation as an atomic version of
`{ tmp = *atomic; *atomic ^= val; return tmp; }`.

This call acts as a full compiler and hardware memory barrier.

While @atomic has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.

In GLib 2.80, the return type was changed from #gsize to #guintptr to add
support for platforms with 128-bit pointers. This should not affect existing
code.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value of @atomic before the operation, unsigned</doc>
        <type name="guintptr" c:type="guintptr"/>
      </return-value>
      <parameters>
        <parameter name="atomic" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">the value to 'xor'</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_rc_box_acquire" c:identifier="g_atomic_rc_box_acquire" version="2.58">
      <doc xml:space="preserve">Atomically acquires a reference on the data pointed by @mem_block.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to the data,
  with its reference count increased</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="mem_block" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to reference counted data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_rc_box_alloc" c:identifier="g_atomic_rc_box_alloc" version="2.58">
      <doc xml:space="preserve">Allocates @block_size bytes of memory, and adds atomic
reference counting semantics to it.

The data will be freed when its reference count drops to
zero.

The allocated data is guaranteed to be suitably aligned for any
built-in type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to the allocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="block_size" transfer-ownership="none">
          <doc xml:space="preserve">the size of the allocation, must be greater than 0</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_rc_box_alloc0" c:identifier="g_atomic_rc_box_alloc0" version="2.58">
      <doc xml:space="preserve">Allocates @block_size bytes of memory, and adds atomic
reference counting semantics to it.

The contents of the returned data is set to zero.

The data will be freed when its reference count drops to
zero.

The allocated data is guaranteed to be suitably aligned for any
built-in type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to the allocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="block_size" transfer-ownership="none">
          <doc xml:space="preserve">the size of the allocation, must be greater than 0</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_rc_box_dup" c:identifier="g_atomic_rc_box_dup" version="2.58">
      <doc xml:space="preserve">Allocates a new block of data with atomic reference counting
semantics, and copies @block_size bytes of @mem_block
into it.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to the allocated
  memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="block_size" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to copy, must be greater than 0</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="mem_block" transfer-ownership="none">
          <doc xml:space="preserve">the memory to copy</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_rc_box_get_size" c:identifier="g_atomic_rc_box_get_size" version="2.58">
      <doc xml:space="preserve">Retrieves the size of the reference counted data pointed by @mem_block.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the size of the data, in bytes</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="mem_block" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to reference counted data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="atomic_rc_box_new" c:identifier="g_atomic_rc_box_new" version="2.58" introspectable="0">
      <doc xml:space="preserve">A convenience macro to allocate atomically reference counted
data with the size of the given @type.

This macro calls g_atomic_rc_box_alloc() with `sizeof (@type)` and
casts the returned pointer to a pointer of the given @type,
avoiding a type cast in the source code.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">the type to allocate, typically a structure name</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="atomic_rc_box_new0" c:identifier="g_atomic_rc_box_new0" version="2.58" introspectable="0">
      <doc xml:space="preserve">A convenience macro to allocate atomically reference counted
data with the size of the given @type, and set its contents
to zero.

This macro calls g_atomic_rc_box_alloc0() with `sizeof (@type)` and
casts the returned pointer to a pointer of the given @type,
avoiding a type cast in the source code.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">the type to allocate, typically a structure name</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="atomic_rc_box_release" c:identifier="g_atomic_rc_box_release" version="2.58">
      <doc xml:space="preserve">Atomically releases a reference on the data pointed by @mem_block.

If the reference was the last one, it will free the
resources allocated for @mem_block.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem_block" transfer-ownership="full">
          <doc xml:space="preserve">a pointer to reference counted data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_rc_box_release_full" c:identifier="g_atomic_rc_box_release_full" version="2.58">
      <doc xml:space="preserve">Atomically releases a reference on the data pointed by @mem_block.

If the reference was the last one, it will call @clear_func
to clear the contents of @mem_block, and then will free the
resources allocated for @mem_block.

Note that implementing weak references via @clear_func is not thread-safe:
clearing a pointer to the memory from the callback can race with another
thread trying to access it as @mem_block already has a reference count of 0
when the callback is called and will be freed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem_block" transfer-ownership="full">
          <doc xml:space="preserve">a pointer to reference counted data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="clear_func" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">a function to call when clearing the data</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_ref_count_compare" c:identifier="g_atomic_ref_count_compare" version="2.58">
      <doc xml:space="preserve">Atomically compares the current value of @arc with @val.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the reference count is the same
  as the given value</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="arc" transfer-ownership="none">
          <doc xml:space="preserve">the address of an atomic reference count variable</doc>
          <type name="gint" c:type="gatomicrefcount*"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">the value to compare</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_ref_count_dec" c:identifier="g_atomic_ref_count_dec" version="2.58">
      <doc xml:space="preserve">Atomically decreases the reference count.

If %TRUE is returned, the reference count reached 0. After this point, @arc
is an undefined state and must be reinitialized with
g_atomic_ref_count_init() to be used again.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the reference count reached 0, and %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="arc" transfer-ownership="none">
          <doc xml:space="preserve">the address of an atomic reference count variable</doc>
          <type name="gint" c:type="gatomicrefcount*"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_ref_count_inc" c:identifier="g_atomic_ref_count_inc" version="2.58">
      <doc xml:space="preserve">Atomically increases the reference count.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="arc" transfer-ownership="none">
          <doc xml:space="preserve">the address of an atomic reference count variable</doc>
          <type name="gint" c:type="gatomicrefcount*"/>
        </parameter>
      </parameters>
    </function>
    <function name="atomic_ref_count_init" c:identifier="g_atomic_ref_count_init" version="2.58">
      <doc xml:space="preserve">Initializes a reference count variable to 1.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="arc" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the address of an atomic reference count variable</doc>
          <type name="gint" c:type="gatomicrefcount*"/>
        </parameter>
      </parameters>
    </function>
    <function name="base64_decode" c:identifier="g_base64_decode" version="2.12">
      <doc xml:space="preserve">Decode a sequence of Base-64 encoded text into binary data.  Note
that the returned binary data is not necessarily zero-terminated,
so it should not be used as a character string.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
              newly allocated buffer containing the binary data
              that @text represents. The returned buffer must
              be freed with g_free().</doc>
        <array length="1" zero-terminated="0" c:type="guchar*">
          <type name="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="text" transfer-ownership="none">
          <doc xml:space="preserve">zero-terminated string with base64 text to decode</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="out_len" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">The length of the decoded data is written here</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="base64_decode_inplace" c:identifier="g_base64_decode_inplace" version="2.20">
      <doc xml:space="preserve">Decode a sequence of Base-64 encoded text into binary data
by overwriting the input data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The binary data that @text responds. This pointer
              is the same as the input @text.</doc>
        <type name="guint8" c:type="guchar*"/>
      </return-value>
      <parameters>
        <parameter name="text" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">zero-terminated
       string with base64 text to decode</doc>
          <array length="1" zero-terminated="0" c:type="gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="out_len" direction="inout" caller-allocates="0" transfer-ownership="none">
          <doc xml:space="preserve">The length of the decoded data is written here</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="base64_decode_step" c:identifier="g_base64_decode_step" version="2.12" introspectable="0">
      <doc xml:space="preserve">Incrementally decode a sequence of binary data from its Base-64 stringified
representation. By calling this function multiple times you can convert
data in chunks to avoid having to have the full encoded data in memory.

The output buffer must be large enough to fit all the data that will
be written to it. Since base64 encodes 3 bytes in 4 chars you need
at least: (@len / 4) * 3 + 3 bytes (+ 3 may be needed in case of non-zero
state).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The number of bytes of output that was written</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">binary input data</doc>
          <array length="1" zero-terminated="0" c:type="const gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">max length of @in data to decode</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="out" direction="out" caller-allocates="1" transfer-ownership="none">
          <doc xml:space="preserve">output buffer</doc>
          <array zero-terminated="0" c:type="guchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="state" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">Saved state between steps, initialize to 0</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="save" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">Saved state between steps, initialize to 0</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="base64_encode" c:identifier="g_base64_encode" version="2.12">
      <doc xml:space="preserve">Encode a sequence of binary data into its Base-64 stringified
representation.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated, zero-terminated Base-64
              encoded string representing @data. The returned string must
              be freed with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the binary data to encode</doc>
          <array length="1" zero-terminated="0" c:type="const guchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="base64_encode_close" c:identifier="g_base64_encode_close" version="2.12">
      <doc xml:space="preserve">Flush the status from a sequence of calls to g_base64_encode_step().

The output buffer must be large enough to fit all the data that will
be written to it. It will need up to 4 bytes, or up to 5 bytes if
line-breaking is enabled.

The @out array will not be automatically nul-terminated.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The number of bytes of output that was written</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="break_lines" transfer-ownership="none">
          <doc xml:space="preserve">whether to break long lines</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="out" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">pointer to destination buffer</doc>
          <array zero-terminated="0" c:type="gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="state" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">Saved state from g_base64_encode_step()</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="save" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">Saved state from g_base64_encode_step()</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="base64_encode_step" c:identifier="g_base64_encode_step" version="2.12">
      <doc xml:space="preserve">Incrementally encode a sequence of binary data into its Base-64 stringified
representation. By calling this function multiple times you can convert
data in chunks to avoid having to have the full encoded data in memory.

When all of the data has been converted you must call
g_base64_encode_close() to flush the saved state.

The output buffer must be large enough to fit all the data that will
be written to it. Due to the way base64 encodes you will need
at least: (@len / 3 + 1) * 4 + 4 bytes (+ 4 may be needed in case of
non-zero state). If you enable line-breaking you will need at least:
((@len / 3 + 1) * 4 + 4) / 76 + 1 bytes of extra space.

@break_lines is typically used when putting base64-encoded data in emails.
It breaks the lines at 76 columns instead of putting all of the text on
the same line. This avoids problems with long lines in the email system.
Note however that it breaks the lines with `LF` characters, not
`CR LF` sequences, so the result cannot be passed directly to SMTP
or certain other protocols.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The number of bytes of output that was written</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">the binary data to encode</doc>
          <array length="1" zero-terminated="0" c:type="const guchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of @in</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="break_lines" transfer-ownership="none">
          <doc xml:space="preserve">whether to break long lines</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="out" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">pointer to destination buffer</doc>
          <array zero-terminated="0" c:type="gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="state" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">Saved state between steps, initialize to 0</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="save" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">Saved state between steps, initialize to 0</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="basename" c:identifier="g_basename" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Gets the name of the file without any leading directory
components. It returns a pointer into the given file name
string.</doc>
      <doc-deprecated xml:space="preserve">Use g_path_get_basename() instead, but notice
  that g_path_get_basename() allocates new memory for the
  returned string, unlike this function which returns a pointer
  into the argument.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the name of the file without any leading
  directory components</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="file_name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the file</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_lock" c:identifier="g_bit_lock" version="2.24">
      <doc xml:space="preserve">Sets the indicated @lock_bit in @address.  If the bit is already
set, this call will block until g_bit_unlock() unsets the
corresponding bit.

Attempting to lock on two different bits within the same integer is
not supported and will very probably cause deadlocks.

The value of the bit that is set is (1u &lt;&lt; @bit).  If @bit is not
between 0 and 31 then the result is undefined.

This function accesses @address atomically.  All other accesses to
@address must be atomic in order for this function to work
reliably. While @address has a `volatile` qualifier, this is a historical
artifact and the argument passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to an integer</doc>
          <type name="gpointer" c:type="volatile gint*"/>
        </parameter>
        <parameter name="lock_bit" transfer-ownership="none">
          <doc xml:space="preserve">a bit value between 0 and 31</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_lock_and_get" c:identifier="g_bit_lock_and_get" version="2.86">
      <doc xml:space="preserve">Sets the indicated @lock_bit in @address and atomically returns the new value.

This is like [func@GLib.bit_lock], except it can atomically return the new value at
@address (right after obtaining the lock). Thus the value returned in @out_val
always has the @lock_bit set.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to an integer</doc>
          <type name="gpointer" c:type="gint*"/>
        </parameter>
        <parameter name="lock_bit" transfer-ownership="none">
          <doc xml:space="preserve">a bit value between 0 and 31</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="out_val" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for the new value of the integer</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_nth_lsf" c:identifier="g_bit_nth_lsf">
      <doc xml:space="preserve">Find the position of the first bit set in @mask, searching
from (but not including) @nth_bit upwards. Bits are numbered
from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
usually). To start searching from the 0th bit, set @nth_bit to -1.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the index of the first bit set which is higher than @nth_bit, or -1
   if no higher bits are set</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">a #gulong containing flags</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
        <parameter name="nth_bit" transfer-ownership="none">
          <doc xml:space="preserve">the index of the bit to start the search from</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_nth_msf" c:identifier="g_bit_nth_msf">
      <doc xml:space="preserve">Find the position of the first bit set in @mask, searching
from (but not including) @nth_bit downwards. Bits are numbered
from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
usually). To start searching from the last bit, set @nth_bit to
-1 or GLIB_SIZEOF_LONG * 8.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the index of the first bit set which is lower than @nth_bit, or -1
   if no lower bits are set</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">a #gulong containing flags</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
        <parameter name="nth_bit" transfer-ownership="none">
          <doc xml:space="preserve">the index of the bit to start the search from</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_storage" c:identifier="g_bit_storage">
      <doc xml:space="preserve">Gets the number of bits used to hold @number,
e.g. if @number is 4, 3 bits are needed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bits used to hold @number</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="number" transfer-ownership="none">
          <doc xml:space="preserve">a #guint</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_trylock" c:identifier="g_bit_trylock" version="2.24">
      <doc xml:space="preserve">Sets the indicated @lock_bit in @address, returning %TRUE if
successful.  If the bit is already set, returns %FALSE immediately.

Attempting to lock on two different bits within the same integer is
not supported.

The value of the bit that is set is (1u &lt;&lt; @bit).  If @bit is not
between 0 and 31 then the result is undefined.

This function accesses @address atomically.  All other accesses to
@address must be atomic in order for this function to work
reliably. While @address has a `volatile` qualifier, this is a historical
artifact and the argument passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the lock was acquired</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to an integer</doc>
          <type name="gpointer" c:type="volatile gint*"/>
        </parameter>
        <parameter name="lock_bit" transfer-ownership="none">
          <doc xml:space="preserve">a bit value between 0 and 31</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_unlock" c:identifier="g_bit_unlock" version="2.24">
      <doc xml:space="preserve">Clears the indicated @lock_bit in @address.  If another thread is
currently blocked in g_bit_lock() on this same bit then it will be
woken up.

This function accesses @address atomically.  All other accesses to
@address must be atomic in order for this function to work
reliably. While @address has a `volatile` qualifier, this is a historical
artifact and the argument passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to an integer</doc>
          <type name="gpointer" c:type="volatile gint*"/>
        </parameter>
        <parameter name="lock_bit" transfer-ownership="none">
          <doc xml:space="preserve">a bit value between 0 and 31</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_unlock_and_set" c:identifier="g_bit_unlock_and_set" version="2.86">
      <doc xml:space="preserve">This is like [func@GLib.bit_unlock] but also atomically sets @address to
@val.

If @preserve_mask is not zero, then the @preserve_mask bits will be
preserved in @address and are not set to @val.

Note that the @lock_bit bit will always be unset regardless of
@val, @preserve_mask and the currently set value in @address.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to an integer</doc>
          <type name="gpointer" c:type="gint*"/>
        </parameter>
        <parameter name="lock_bit" transfer-ownership="none">
          <doc xml:space="preserve">a bit value between 0 and 31</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="new_val" transfer-ownership="none">
          <doc xml:space="preserve">the new value to set</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="preserve_mask" transfer-ownership="none">
          <doc xml:space="preserve">mask for bits from @address to preserve</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="blow_chunks" c:identifier="g_blow_chunks" deprecated="1" deprecated-version="2.10">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="bookmark_file_error_quark" c:identifier="g_bookmark_file_error_quark" moved-to="BookmarkFile.error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="build_filename" c:identifier="g_build_filename" introspectable="0">
      <doc xml:space="preserve">Creates a filename from a series of elements using the correct
separator for the current platform.

On Unix, this function behaves identically to `g_build_path
(G_DIR_SEPARATOR_S, first_element, ....)`.

On Windows, it takes into account that either the backslash
(`\` or slash (`/`) can be used as separator in filenames, but
otherwise behaves as on UNIX. When file pathname separators need
to be inserted, the one that last previously occurred in the
parameters (reading from left to right) is used.

No attempt is made to force the resulting filename to be an absolute
path. If the first element is a relative path, the result will
be a relative path.

If you are building a path programmatically you may want to use
#GPathBuf instead.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly allocated path</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="first_element" transfer-ownership="none">
          <doc xml:space="preserve">the first element in the path</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">remaining elements in path, terminated by %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="build_filename_valist" c:identifier="g_build_filename_valist" version="2.56" introspectable="0">
      <doc xml:space="preserve">Creates a filename from a list of elements using the correct
separator for the current platform.

Behaves exactly like g_build_filename(), but takes the path elements
as a va_list.

This function is mainly meant for implementing other variadic arguments
functions.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly allocated path</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="first_element" transfer-ownership="none">
          <doc xml:space="preserve">the first element in the path</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">va_list of remaining elements in path</doc>
          <type name="va_list" c:type="va_list*"/>
        </parameter>
      </parameters>
    </function>
    <function name="build_filenamev" c:identifier="g_build_filenamev" version="2.8">
      <doc xml:space="preserve">Creates a filename from a vector of elements using the correct
separator for the current platform.

This function behaves exactly like g_build_filename(), but takes the path
elements as a string array, instead of varargs. This function is mainly
meant for language bindings.

If you are building a path programmatically you may want to use
#GPathBuf instead.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly allocated path</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated
  array of strings containing the path elements.</doc>
          <array c:type="gchar**">
            <type name="filename"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="build_path" c:identifier="g_build_path" introspectable="0">
      <doc xml:space="preserve">Creates a path from a series of elements using @separator as the
separator between elements.

At the boundary between two elements, any trailing occurrences of
separator in the first element, or leading occurrences of separator
in the second element are removed and exactly one copy of the
separator is inserted.

Empty elements are ignored.

The number of leading copies of the separator on the result is
the same as the number of leading copies of the separator on
the first non-empty element.

The number of trailing copies of the separator on the result is
the same as the number of trailing copies of the separator on
the last non-empty element. (Determination of the number of
trailing copies is done without stripping leading copies, so
if the separator is `ABA`, then `ABABA` has 1 trailing copy.)

However, if there is only a single non-empty element, and there
are no characters in that element not part of the leading or
trailing separators, then the result is exactly the original value
of that element.

Other than for determination of the number of leading and trailing
copies of the separator, elements consisting only of copies
of the separator are ignored.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly allocated path</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="separator" transfer-ownership="none">
          <doc xml:space="preserve">a string used to separate the elements of the path.</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="first_element" transfer-ownership="none">
          <doc xml:space="preserve">the first element in the path</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">remaining elements in path, terminated by %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="build_pathv" c:identifier="g_build_pathv" version="2.8">
      <doc xml:space="preserve">Behaves exactly like g_build_path(), but takes the path elements
as a string array, instead of variadic arguments.

This function is mainly meant for language bindings.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated string that
    must be freed with g_free().</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="separator" transfer-ownership="none">
          <doc xml:space="preserve">a string used to separate the elements of the path.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">%NULL-terminated
  array of strings containing the path elements.</doc>
          <array c:type="gchar**">
            <type name="filename"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_append" c:identifier="g_byte_array_append" moved-to="ByteArray.append">
      <doc xml:space="preserve">Adds the given bytes to the end of the `GByteArray`.
The array will grow in size automatically if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The `GByteArray`</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">the byte data to be added</doc>
          <array length="2" zero-terminated="0" c:type="const guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to add</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_free" c:identifier="g_byte_array_free" moved-to="ByteArray.free">
      <doc xml:space="preserve">Frees the memory allocated by the `GByteArray`. If @free_segment is
true it frees the actual byte data. If the reference count of
@array is greater than one, the `GByteArray` wrapper is preserved but
the size of @array will be set to zero.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">The allocated element data if
  @free_segment is false, otherwise `NULL`.</doc>
        <array zero-terminated="0" c:type="guint8*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="full">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="free_segment" transfer-ownership="none">
          <doc xml:space="preserve">if true, the actual byte data is freed as well</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_free_to_bytes" c:identifier="g_byte_array_free_to_bytes" moved-to="ByteArray.free_to_bytes" version="2.32">
      <doc xml:space="preserve">Transfers the data from the `GByteArray` into a new immutable
[struct@GLib.Bytes].

The `GByteArray` is freed unless the reference count of @array is greater
than one, in which the `GByteArray` wrapper is preserved but the size of
@array will be set to zero.

This is identical to using [ctor@GLib.Bytes.new_take] and
[func@GLib.ByteArray.free] together.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new immutable [struct@GLib.Bytes] representing
  same byte data that was in the array</doc>
        <type name="Bytes" c:type="GBytes*"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="full">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_new" c:identifier="g_byte_array_new" moved-to="ByteArray.new">
      <doc xml:space="preserve">Creates a new `GByteArray` with a reference count of 1.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new `GByteArray`</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
    </function>
    <function name="byte_array_new_take" c:identifier="g_byte_array_new_take" moved-to="ByteArray.new_take" version="2.32">
      <doc xml:space="preserve">Creates a byte array containing the @data.
After this call, @data belongs to the `GByteArray` and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with [func@GLib.free].

Do not use it if @len is greater than [`G_MAXUINT`](types.html#guint).
`GByteArray` stores the length of its data in `guint`, which may be shorter
than `gsize`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new `GByteArray`</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="full">
          <doc xml:space="preserve">the byte data for the array</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_prepend" c:identifier="g_byte_array_prepend" moved-to="ByteArray.prepend">
      <doc xml:space="preserve">Adds the given data to the start of the `GByteArray`.
The array will grow in size automatically if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The `GByteArray`</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">the byte data to be added</doc>
          <array length="2" zero-terminated="0" c:type="const guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to add</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_ref" c:identifier="g_byte_array_ref" moved-to="ByteArray.ref" version="2.22">
      <doc xml:space="preserve">Atomically increments the reference count of @array by one.
This function is thread-safe and may be called from any thread.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The passed in `GByteArray`</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_remove_index" c:identifier="g_byte_array_remove_index" moved-to="ByteArray.remove_index">
      <doc xml:space="preserve">Removes the byte at the given index from a `GByteArray`.
The following bytes are moved down one place.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The `GByteArray`</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="index_" transfer-ownership="none">
          <doc xml:space="preserve">the index of the byte to remove</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_remove_index_fast" c:identifier="g_byte_array_remove_index_fast" moved-to="ByteArray.remove_index_fast">
      <doc xml:space="preserve">Removes the byte at the given index from a `GByteArray`. The last
element in the array is used to fill in the space, so this function
does not preserve the order of the `GByteArray`. But it is faster
than [func@GLib.ByteArray.remove_index].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The `GByteArray`</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="index_" transfer-ownership="none">
          <doc xml:space="preserve">the index of the byte to remove</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_remove_range" c:identifier="g_byte_array_remove_range" moved-to="ByteArray.remove_range" version="2.4">
      <doc xml:space="preserve">Removes the given number of bytes starting at the given index from a
`GByteArray`. The following elements are moved to close the gap.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The `GByteArray`</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="index_" transfer-ownership="none">
          <doc xml:space="preserve">the index of the first byte to remove</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to remove</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_set_size" c:identifier="g_byte_array_set_size" moved-to="ByteArray.set_size">
      <doc xml:space="preserve">Sets the size of the `GByteArray`, expanding it if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The `GByteArray`</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the new size of the `GByteArray`</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_sized_new" c:identifier="g_byte_array_sized_new" moved-to="ByteArray.sized_new">
      <doc xml:space="preserve">Creates a new `GByteArray` with @reserved_size bytes preallocated.
This avoids frequent reallocation, if you are going to add many
bytes to the array. Note however that the size of the array is still
0.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new `GByteArray`</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="reserved_size" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes preallocated</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_sort" c:identifier="g_byte_array_sort" moved-to="ByteArray.sort">
      <doc xml:space="preserve">Sorts a byte array, using @compare_func which should be a
`qsort()`-style comparison function (returns less than zero for first
arg is less than second arg, zero for equal, greater than zero if
first arg is greater than second arg).

If two array elements compare equal, their order in the sorted array
is undefined. If you want equal elements to keep their order (i.e.
you want a stable sort) you can write a comparison function that,
if two elements would otherwise compare equal, compares them by
their addresses.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="compare_func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve">the comparison function</doc>
          <type name="CompareFunc" c:type="GCompareFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_sort_with_data" c:identifier="g_byte_array_sort_with_data" moved-to="ByteArray.sort_with_data">
      <doc xml:space="preserve">Like [func@GLib.ByteArray.sort], but the comparison function takes an extra
user data argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="compare_func" transfer-ownership="none" scope="call" closure="2">
          <doc xml:space="preserve">the comparison function</doc>
          <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data to pass to @compare_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_steal" c:identifier="g_byte_array_steal" moved-to="ByteArray.steal" version="2.64">
      <doc xml:space="preserve">Frees the data in the array and resets the size to zero, while
the underlying array is preserved for use elsewhere and returned
to the caller.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The allocated element data</doc>
        <array length="1" zero-terminated="0" c:type="guint8*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="len" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the pointer to retrieve the number of
   elements of the original array</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_array_unref" c:identifier="g_byte_array_unref" moved-to="ByteArray.unref" version="2.22">
      <doc xml:space="preserve">Atomically decrements the reference count of @array by one. If the
reference count drops to 0, all memory allocated by the array is
released. This function is thread-safe and may be called from any
thread.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="full">
          <doc xml:space="preserve">a byte array</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="canonicalize_filename" c:identifier="g_canonicalize_filename" version="2.58">
      <doc xml:space="preserve">Gets the canonical file name from @filename. All triple slashes are turned into
single slashes, and all `..` and `.`s resolved against @relative_to.

Symlinks are not followed, and the returned path is guaranteed to be absolute.

If @filename is an absolute path, @relative_to is ignored. Otherwise,
@relative_to will be prepended to @filename to make it absolute. @relative_to
must be an absolute path, or %NULL. If @relative_to is %NULL, it'll fallback
to g_get_current_dir().

This function never fails, and will canonicalize file paths even if they don't
exist.

No file system I/O is done.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string with the
  canonical file path</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">the name of the file</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="relative_to" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the relative directory, or %NULL
to use the current working directory</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="chdir" c:identifier="g_chdir" version="2.8">
      <doc xml:space="preserve">A wrapper for the POSIX chdir() function. The function changes the
current directory of the process to @path.

See your C library manual for more details about chdir().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 if an error occurred.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_version" c:identifier="glib_check_version" version="2.6">
      <doc xml:space="preserve">Checks that the GLib library in use is compatible with the
given version.

Generally you would pass in the constants %GLIB_MAJOR_VERSION,
%GLIB_MINOR_VERSION, %GLIB_MICRO_VERSION as the three arguments
to this function; that produces a check that the library in use
is compatible with the version of GLib the application or module
was compiled against.

Compatibility is defined by two things: first the version
of the running library is newer than the version
`@required_major.required_minor.@required_micro`. Second
the running library must be binary compatible with the
version `@required_major.@required_minor.@required_micro`
(same major version.)</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">%NULL if the GLib library is
  compatible with the given version, or a string describing the
  version mismatch. The returned string is owned by GLib and must
  not be modified or freed.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="required_major" transfer-ownership="none">
          <doc xml:space="preserve">the required major version</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="required_minor" transfer-ownership="none">
          <doc xml:space="preserve">the required minor version</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="required_micro" transfer-ownership="none">
          <doc xml:space="preserve">the required micro version</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="checksum_type_get_length" c:identifier="g_checksum_type_get_length" moved-to="Checksum.type_get_length" version="2.16">
      <doc xml:space="preserve">Gets the length in bytes of digests of type @checksum_type</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the checksum length, or -1 if @checksum_type is
not supported.</doc>
        <type name="gssize" c:type="gssize"/>
      </return-value>
      <parameters>
        <parameter name="checksum_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GChecksumType</doc>
          <type name="ChecksumType" c:type="GChecksumType"/>
        </parameter>
      </parameters>
    </function>
    <function name="child_watch_add" c:identifier="g_child_watch_add" shadowed-by="child_watch_add_full" version="2.4" introspectable="0">
      <doc xml:space="preserve">Sets a function to be called when the child indicated by @pid
exits, at a default priority, [const@GLib.PRIORITY_DEFAULT].

If you obtain @pid from [func@GLib.spawn_async] or
[func@GLib.spawn_async_with_pipes] you will need to pass
[flags@GLib.SpawnFlags.DO_NOT_REAP_CHILD] as a flag to the spawn function for
the child watching to work.

Note that on platforms where [type@GLib.Pid] must be explicitly closed
(see [func@GLib.spawn_close_pid]) @pid must not be closed while the
source is still active. Typically, you will want to call
[func@GLib.spawn_close_pid] in the callback function for the source.

GLib supports only a single callback per process ID.
On POSIX platforms, the same restrictions mentioned for
[func@GLib.child_watch_source_new] apply to this function.

This internally creates a main loop source using
[func@GLib.child_watch_source_new] and attaches it to the main loop context
using [method@GLib.Source.attach]. You can do these steps manually if you
need greater control.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="pid" transfer-ownership="none">
          <doc xml:space="preserve">process to watch &#x2014; on POSIX systems, this is the positive PID of a
  child process; on Windows it is a handle for a process (which doesn&#x2019;t have
  to be a child)</doc>
          <type name="Pid" c:type="GPid"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">function to call</doc>
          <type name="ChildWatchFunc" c:type="GChildWatchFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="child_watch_add_full" c:identifier="g_child_watch_add_full" shadows="child_watch_add" version="2.4">
      <doc xml:space="preserve">Sets a function to be called when the child indicated by @pid
exits, at the priority @priority.

If you obtain @pid from [func@GLib.spawn_async] or
[func@GLib.spawn_async_with_pipes] you will need to pass
[flags@GLib.SpawnFlags.DO_NOT_REAP_CHILD] as a flag to the spawn function for
the child watching to work.

In many programs, you will want to call [func@GLib.spawn_check_wait_status]
in the callback to determine whether or not the child exited
successfully.

Also, note that on platforms where [type@GLib.Pid] must be explicitly closed
(see [func@GLib.spawn_close_pid]) @pid must not be closed while the source
is still active.  Typically, you should invoke [func@GLib.spawn_close_pid]
in the callback function for the source.

GLib supports only a single callback per process ID.
On POSIX platforms, the same restrictions mentioned for
[func@GLib.child_watch_source_new] apply to this function.

This internally creates a main loop source using
[func@GLib.child_watch_source_new] and attaches it to the main loop context
using [method@GLib.Source.attach]. You can do these steps manually if you
need greater control.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve">the priority of the idle source; typically this will be in the
  range between [const@GLib.PRIORITY_DEFAULT_IDLE] and
  [const@GLib.PRIORITY_HIGH_IDLE]</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="pid" transfer-ownership="none">
          <doc xml:space="preserve">process to watch &#x2014; on POSIX systems, this is the positive PID of a
  child process; on Windows it is a handle for a process (which doesn&#x2019;t have
  to be a child)</doc>
          <type name="Pid" c:type="GPid"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" scope="notified" closure="3" destroy="4">
          <doc xml:space="preserve">function to call</doc>
          <type name="ChildWatchFunc" c:type="GChildWatchFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">function to call when the idle is removed</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="child_watch_source_new" c:identifier="g_child_watch_source_new" version="2.4">
      <doc xml:space="preserve">Creates a new child watch source.

The source will not initially be associated with any
[struct@GLib.MainContext] and must be added to one with
[method@GLib.Source.attach] before it will be executed.

Note that child watch sources can only be used in conjunction with
`g_spawn...` when the [flags@GLib.SpawnFlags.DO_NOT_REAP_CHILD] flag is used.

Note that on platforms where [type@GLib.Pid] must be explicitly closed
(see [func@GLib.spawn_close_pid]) @pid must not be closed while the
source is still active. Typically, you will want to call
[func@GLib.spawn_close_pid] in the callback function for the source.

On POSIX platforms, the following restrictions apply to this API
due to limitations in POSIX process interfaces:

* @pid must be a child of this process.
* @pid must be positive.
* The application must not call [`waitpid()`](man:waitpid(1)) with a
  non-positive first argument, for instance in another thread.
* The application must not wait for @pid to exit by any other
  mechanism, including `waitpid(pid, ...)` or a second child-watch
  source for the same @pid.
* The application must not ignore `SIGCHLD`.
* Before 2.78, the application could not send a signal ([`kill()`](man:kill(2))) to the
  watched @pid in a race free manner. Since 2.78, you can do that while the
  associated [struct@GLib.MainContext] is acquired.
* Before 2.78, even after destroying the [struct@GLib.Source], you could not
  be sure that @pid wasn&#x2019;t already reaped. Hence, it was also not
  safe to `kill()` or `waitpid()` on the process ID after the child watch
  source was gone. Destroying the source before it fired made it
  impossible to reliably reap the process.

If any of those conditions are not met, this and related APIs will
not work correctly. This can often be diagnosed via a GLib warning
stating that `ECHILD` was received by `waitpid()`.

Calling [`waitpid()`](man:waitpid(2)) for specific processes other than @pid
remains a valid thing to do.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly-created child watch source</doc>
        <type name="Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="pid" transfer-ownership="none">
          <doc xml:space="preserve">process to watch &#x2014; on POSIX systems, this is the positive PID of a
  child process; on Windows it is a handle for a process (which doesn&#x2019;t have
  to be a child)</doc>
          <type name="Pid" c:type="GPid"/>
        </parameter>
      </parameters>
    </function>
    <function name="chmod" c:identifier="g_chmod" version="2.8">
      <doc xml:space="preserve">A wrapper for the POSIX chmod() function. The chmod() function is
used to set the permissions of a file system object.

On Windows the file protection mechanism is not at all POSIX-like,
and the underlying chmod() function in the C library just sets or
clears the FAT-style READONLY attribute. It does not touch any
ACL. Software that needs to manage file permissions on Windows
exactly should use the Win32 API.

See your C library manual for more details about chmod().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the operation succeeded, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">as in chmod()</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="chunk_free" c:identifier="g_chunk_free" introspectable="0" deprecated="1" deprecated-version="2.10">
      <parameters>
        <parameter name="mem">
        </parameter>
        <parameter name="mem_chunk">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="chunk_new" c:identifier="g_chunk_new" introspectable="0" deprecated="1" deprecated-version="2.10">
      <parameters>
        <parameter name="type">
        </parameter>
        <parameter name="chunk">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="chunk_new0" c:identifier="g_chunk_new0" introspectable="0" deprecated="1" deprecated-version="2.10">
      <parameters>
        <parameter name="type">
        </parameter>
        <parameter name="chunk">
        </parameter>
      </parameters>
    </function-macro>
    <function name="clear_error" c:identifier="g_clear_error" throws="1">
      <doc xml:space="preserve">If @err or `*err` is %NULL, does nothing. Otherwise,
calls g_error_free() on `*err` and sets `*err` to %NULL.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function-inline name="clear_fd" c:identifier="g_clear_fd" version="2.76" introspectable="0" throws="1">
      <doc xml:space="preserve">If @fd_ptr points to a file descriptor, close it and return
whether closing it was successful, like g_close().
If @fd_ptr points to a negative number, return %TRUE without closing
anything.
In both cases, set @fd_ptr to `-1` before returning.

Like g_close(), if closing the file descriptor fails, the error is
stored in both %errno and @error. If this function succeeds,
%errno is undefined.

On POSIX platforms, this function is async-signal safe
if @error is %NULL and @fd_ptr points to either a negative number or a
valid open file descriptor.
This makes it safe to call from a signal handler or a #GSpawnChildSetupFunc
under those conditions.
See [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7)) for more details.

It is a programming error for @fd_ptr to point to a non-negative
number that is not a valid file descriptor.

A typical use of this function is to clean up a file descriptor at
the end of its scope, whether it has been set successfully or not:

|[
gboolean
operate_on_fd (GError **error)
{
  gboolean ret = FALSE;
  int fd = -1;

  fd = open_a_fd (error);

  if (fd &lt; 0)
    goto out;

  if (!do_something (fd, error))
    goto out;

  if (!g_clear_fd (&amp;fd, error))
    goto out;

  ret = TRUE;

out:
  // OK to call even if fd was never opened or was already closed
  g_clear_fd (&amp;fd, NULL);
  return ret;
}
]|

This function is also useful in conjunction with #g_autofd.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fd_ptr" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">a pointer to a file descriptor</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function-inline>
    <function name="clear_handle_id" c:identifier="g_clear_handle_id" version="2.56" introspectable="0">
      <doc xml:space="preserve">Clears a numeric handler, such as a [struct@GLib.Source] ID.

The @tag_ptr must be a valid pointer to the variable holding the handler.

If the ID is zero then this function does nothing.
Otherwise, @clear_func is called with the ID as a parameter, and the tag is
set to zero.

A macro is also included that allows this function to be used without
pointer casts.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="tag_ptr" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the handler ID</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="clear_func" transfer-ownership="none">
          <doc xml:space="preserve">the function to call to clear the handler</doc>
          <type name="ClearHandleFunc" c:type="GClearHandleFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="clear_list" c:identifier="g_clear_list" version="2.64" introspectable="0">
      <doc xml:space="preserve">Clears a pointer to a #GList, freeing it and, optionally, freeing its elements using @destroy.

@list_ptr must be a valid pointer. If @list_ptr points to a null #GList, this does nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list_ptr" transfer-ownership="none">
          <doc xml:space="preserve">a #GList return location</doc>
          <type name="GLib.List" c:type="GList**">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">the function to pass to g_list_free_full() or %NULL to not free elements</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="clear_pointer" c:identifier="g_clear_pointer" version="2.34" introspectable="0">
      <doc xml:space="preserve">Clears a reference to a variable.

@pp must not be %NULL.

If the reference is %NULL then this function does nothing.
Otherwise, the variable is destroyed using @destroy and the
pointer is set to %NULL.

A macro is also included that allows this function to be used without
pointer casts. This will mask any warnings about incompatible function types
or calling conventions, so you must ensure that your @destroy function is
compatible with being called as [callback@GLib.DestroyNotify] using the
standard calling convention for the platform that GLib was compiled for;
otherwise the program will experience undefined behaviour.

Examples of this kind of undefined behaviour include using many Windows Win32
APIs, as well as many if not all OpenGL and Vulkan calls on 32-bit Windows,
which typically use the `__stdcall` calling convention rather than the
`__cdecl` calling convention.

The affected functions can be used by wrapping them in a
[callback@GLib.DestroyNotify] that is declared with the standard calling
convention:

```c
// Wrapper needed to avoid mismatched calling conventions on Windows
static void
destroy_sync (void *sync)
{
  glDeleteSync (sync);
}

// &#x2026;

g_clear_pointer (&amp;sync, destroy_sync);
```</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pp" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">a pointer to a
  variable, struct member etc. holding a pointer</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">a function to which a gpointer can be passed, to destroy `*pp`</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="clear_slist" c:identifier="g_clear_slist" version="2.64" introspectable="0">
      <doc xml:space="preserve">Clears a pointer to a #GSList, freeing it and, optionally, freeing its elements using @destroy.

@slist_ptr must be a valid pointer. If @slist_ptr points to a null #GSList, this does nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="slist_ptr" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList return location</doc>
          <type name="GLib.SList" c:type="GSList**">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">the function to pass to g_slist_free_full() or %NULL to not free elements</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="close" c:identifier="g_close" version="2.36" throws="1">
      <doc xml:space="preserve">This wraps the close() call. In case of error, %errno will be
preserved, but the error will also be stored as a #GError in @error.
In case of success, %errno is undefined.

Besides using #GError, there is another major reason to prefer this
function over the call provided by the system; on Unix, it will
attempt to correctly handle %EINTR, which has platform-specific
semantics.

It is a bug to call this function with an invalid file descriptor.

On POSIX platforms since GLib 2.76, this function is async-signal safe
if (and only if) @error is %NULL and @fd is a valid open file descriptor.
This makes it safe to call from a signal handler or a #GSpawnChildSetupFunc
under those conditions.
See [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7)) for more details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if there was an error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">A file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="closefrom" c:identifier="g_closefrom" version="2.80">
      <doc xml:space="preserve">Close every file descriptor equal to or greater than @lowfd.

Typically @lowfd will be 3, to leave standard input, standard output
and standard error open.

This is the same as Linux `close_range (lowfd, ~0U, 0)`,
but portable to other OSs and to older versions of Linux.
Equivalently, it is the same as BSD `closefrom (lowfd)`, but portable,
and async-signal-safe on all OSs.

This function is async-signal safe, making it safe to call from a
signal handler or a [callback@GLib.SpawnChildSetupFunc], as long as @lowfd is
non-negative.
See [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7)) for more details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 with errno set on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="lowfd" transfer-ownership="none">
          <doc xml:space="preserve">Minimum fd to close, which must be non-negative</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="compute_checksum_for_bytes" c:identifier="g_compute_checksum_for_bytes" version="2.34">
      <doc xml:space="preserve">Computes the checksum for a binary @data. This is a
convenience wrapper for g_checksum_new(), g_checksum_get_string()
and g_checksum_free().

The hexadecimal string returned will be in lower case.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the digest of the binary data as a
  string in hexadecimal, or %NULL if g_checksum_new() fails for
  @checksum_type. The returned string should be freed with g_free() when
  done using it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="checksum_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GChecksumType</doc>
          <type name="ChecksumType" c:type="GChecksumType"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">binary blob to compute the digest of</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </parameter>
      </parameters>
    </function>
    <function name="compute_checksum_for_data" c:identifier="g_compute_checksum_for_data" version="2.16">
      <doc xml:space="preserve">Computes the checksum for a binary @data of @length. This is a
convenience wrapper for g_checksum_new(), g_checksum_get_string()
and g_checksum_free().

The hexadecimal string returned will be in lower case.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the digest of the binary data as a
  string in hexadecimal, or %NULL if g_checksum_new() fails for
  @checksum_type. The returned string should be freed with g_free() when
  done using it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="checksum_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GChecksumType</doc>
          <type name="ChecksumType" c:type="GChecksumType"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">binary blob to compute the digest of</doc>
          <array length="2" zero-terminated="0" c:type="const guchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="compute_checksum_for_string" c:identifier="g_compute_checksum_for_string" version="2.16">
      <doc xml:space="preserve">Computes the checksum of a string.

The hexadecimal string returned will be in lower case.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the checksum as a hexadecimal string,
  or %NULL if g_checksum_new() fails for @checksum_type. The returned string
  should be freed with g_free() when done using it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="checksum_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GChecksumType</doc>
          <type name="ChecksumType" c:type="GChecksumType"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the string to compute the checksum of</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of the string, or -1 if the string is null-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="compute_hmac_for_bytes" c:identifier="g_compute_hmac_for_bytes" version="2.50">
      <doc xml:space="preserve">Computes the HMAC for a binary @data. This is a
convenience wrapper for g_hmac_new(), g_hmac_get_string()
and g_hmac_unref().

The hexadecimal string returned will be in lower case.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the HMAC of the binary data as a string in hexadecimal.
  The returned string should be freed with g_free() when done using it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="digest_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GChecksumType to use for the HMAC</doc>
          <type name="ChecksumType" c:type="GChecksumType"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">the key to use in the HMAC</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">binary blob to compute the HMAC of</doc>
          <type name="Bytes" c:type="GBytes*"/>
        </parameter>
      </parameters>
    </function>
    <function name="compute_hmac_for_data" c:identifier="g_compute_hmac_for_data" version="2.30">
      <doc xml:space="preserve">Computes the HMAC for a binary @data of @length. This is a
convenience wrapper for g_hmac_new(), g_hmac_get_string()
and g_hmac_unref().

The hexadecimal string returned will be in lower case.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the HMAC of the binary data as a string in hexadecimal.
  The returned string should be freed with g_free() when done using it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="digest_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GChecksumType to use for the HMAC</doc>
          <type name="ChecksumType" c:type="GChecksumType"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">the key to use in the HMAC</doc>
          <array length="2" zero-terminated="0" c:type="const guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="key_len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the key</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">binary blob to compute the HMAC of</doc>
          <array length="4" zero-terminated="0" c:type="const guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="compute_hmac_for_string" c:identifier="g_compute_hmac_for_string" version="2.30">
      <doc xml:space="preserve">Computes the HMAC for a string.

The hexadecimal string returned will be in lower case.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the HMAC as a hexadecimal string.
    The returned string should be freed with g_free()
    when done using it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="digest_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GChecksumType to use for the HMAC</doc>
          <type name="ChecksumType" c:type="GChecksumType"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">the key to use in the HMAC</doc>
          <array length="2" zero-terminated="0" c:type="const guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="key_len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the key</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the string to compute the HMAC for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of the string, or -1 if the string is nul-terminated</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="cond_new" c:identifier="g_cond_new" moved-to="Cond.new" introspectable="0" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Allocates and initializes a new #GCond.</doc>
      <doc-deprecated xml:space="preserve">GCond can now be statically allocated, or embedded
in structures and initialised with g_cond_init().</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated #GCond. Free with g_cond_free()</doc>
        <type name="Cond" c:type="GCond*"/>
      </return-value>
    </function>
    <function name="convert" c:identifier="g_convert" throws="1">
      <doc xml:space="preserve">Converts a string from one character set to another.

Note that you should use g_iconv() for streaming conversions.
Despite the fact that @bytes_read can return information about partial
characters, the g_convert_... functions are not generally suitable
for streaming. If the underlying converter maintains internal state,
then this won't be preserved across successive calls to g_convert(),
g_convert_with_iconv() or g_convert_with_fallback(). (An example of
this is the GNU C converter for CP1255 which does not emit a base
character until it knows that the next character is not a mark that
could combine with the base character.)

Using extensions such as "//TRANSLIT" may not work (or may not work
well) on many platforms.  Consider using g_str_to_ascii() instead.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
         If the conversion was successful, a newly allocated buffer
         containing the converted string, which must be freed with g_free().
         Otherwise %NULL and @error will be set.</doc>
        <array length="5" zero-terminated="0" c:type="gchar*">
          <type name="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">
                the string to convert.</doc>
          <array length="1" zero-terminated="0" c:type="const gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the string in bytes, or -1 if the string is
                nul-terminated (Note that some encodings may allow nul
                bytes to occur inside strings. In that case, using -1
                for the @len parameter is unsafe)</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="to_codeset" transfer-ownership="none">
          <doc xml:space="preserve">name of character set into which to convert @str</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="from_codeset" transfer-ownership="none">
          <doc xml:space="preserve">character set of @str.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store the number of bytes in
                the input string that were successfully converted, or %NULL.
                Even if the conversion was successful, this may be
                less than @len if there were partial characters
                at the end of the input. If the error
                %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
                stored will be the byte offset after the last valid
                input sequence.</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the number of bytes stored in
                the output buffer (not including the terminating nul).</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="convert_error_quark" c:identifier="g_convert_error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="convert_with_fallback" c:identifier="g_convert_with_fallback" throws="1">
      <doc xml:space="preserve">Converts a string from one character set to another, possibly
including fallback sequences for characters not representable
in the output. Note that it is not guaranteed that the specification
for the fallback sequences in @fallback will be honored. Some
systems may do an approximate conversion from @from_codeset
to @to_codeset in their iconv() functions,
in which case GLib will simply return that approximate conversion.

Note that you should use g_iconv() for streaming conversions.
Despite the fact that @bytes_read can return information about partial
characters, the g_convert_... functions are not generally suitable
for streaming. If the underlying converter maintains internal state,
then this won't be preserved across successive calls to g_convert(),
g_convert_with_iconv() or g_convert_with_fallback(). (An example of
this is the GNU C converter for CP1255 which does not emit a base
character until it knows that the next character is not a mark that
could combine with the base character.)</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
         If the conversion was successful, a newly allocated buffer
         containing the converted string, which must be freed with g_free().
         Otherwise %NULL and @error will be set.</doc>
        <array length="6" zero-terminated="0" c:type="gchar*">
          <type name="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">
               the string to convert.</doc>
          <array length="1" zero-terminated="0" c:type="const gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the string in bytes, or -1 if the string is
                nul-terminated (Note that some encodings may allow nul
                bytes to occur inside strings. In that case, using -1
                for the @len parameter is unsafe)</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="to_codeset" transfer-ownership="none">
          <doc xml:space="preserve">name of character set into which to convert @str</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="from_codeset" transfer-ownership="none">
          <doc xml:space="preserve">character set of @str.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="fallback" transfer-ownership="none">
          <doc xml:space="preserve">UTF-8 string to use in place of characters not
               present in the target encoding. (The string must be
               representable in the target encoding).
               If %NULL, characters not in the target encoding will
               be represented as Unicode escapes \uxxxx or \Uxxxxyyyy.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store the number of bytes in
               the input string that were successfully converted, or %NULL.
               Even if the conversion was successful, this may be
               less than @len if there were partial characters
               at the end of the input.</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the number of bytes stored in
                the output buffer (not including the terminating nul).</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="convert_with_iconv" c:identifier="g_convert_with_iconv" introspectable="0" throws="1">
      <doc xml:space="preserve">Converts a string from one character set to another.

Note that you should use g_iconv() for streaming conversions.
Despite the fact that @bytes_read can return information about partial
characters, the g_convert_... functions are not generally suitable
for streaming. If the underlying converter maintains internal state,
then this won't be preserved across successive calls to g_convert(),
g_convert_with_iconv() or g_convert_with_fallback(). (An example of
this is the GNU C converter for CP1255 which does not emit a base
character until it knows that the next character is not a mark that
could combine with the base character.)

Characters which are valid in the input character set, but which have no
representation in the output character set will result in a
%G_CONVERT_ERROR_ILLEGAL_SEQUENCE error. This is in contrast to the iconv()
specification, which leaves this behaviour implementation defined. Note that
this is the same error code as is returned for an invalid byte sequence in
the input character set. To get defined behaviour for conversion of
unrepresentable characters, use g_convert_with_fallback().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
              If the conversion was successful, a newly allocated buffer
              containing the converted string, which must be freed with
              g_free(). Otherwise %NULL and @error will be set.</doc>
        <array length="4" zero-terminated="0" c:type="gchar*">
          <type name="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">
                the string to convert.</doc>
          <array length="1" zero-terminated="0" c:type="const gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the string in bytes, or -1 if the string is
                nul-terminated (Note that some encodings may allow nul
                bytes to occur inside strings. In that case, using -1
                for the @len parameter is unsafe)</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="converter" transfer-ownership="none">
          <doc xml:space="preserve">conversion descriptor from g_iconv_open()</doc>
          <type name="IConv" c:type="GIConv"/>
        </parameter>
        <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store the number of bytes in
                the input string that were successfully converted, or %NULL.
                Even if the conversion was successful, this may be
                less than @len if there were partial characters
                at the end of the input. If the error
                %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
                stored will be the byte offset after the last valid
                input sequence.</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the number of bytes stored in
                the output buffer (not including the terminating nul).</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="creat" c:identifier="g_creat" version="2.8">
      <doc xml:space="preserve">A wrapper for the POSIX creat() function. The creat() function is
used to convert a pathname into a file descriptor, creating a file
if necessary.

On POSIX systems file descriptors are implemented by the operating
system. On Windows, it's the C library that implements creat() and
file descriptors. The actual Windows API for opening files is
different, see MSDN documentation for CreateFile(). The Win32 API
uses file handles, which are more randomish integers, not small
integers like file descriptors.

Because file descriptors are specific to the C library on Windows,
the file descriptor returned by this function makes sense only to
functions in the same C library. Thus if the GLib-using code uses a
different C library than GLib does, the file descriptor returned by
this function cannot be passed to C library functions like write()
or read().

See your C library manual for more details about creat().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new file descriptor, or -1 if an error occurred.
    The return value can be used exactly like the return value
    from creat().</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">as in creat()</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="critical" c:identifier="g_critical" introspectable="0">
      <doc xml:space="preserve">Logs a &#x2018;critical warning&#x2019; ([flags@GLib.LogLevelFlags.LEVEL_CRITICAL]).

Critical warnings are intended to be used in the event of an error
that originated in the current process (a programmer error).
Logging of a critical error is by definition an indication of a bug
somewhere in the current program (or its libraries).

[func@GLib.return_if_fail], [func@GLib.return_val_if_fail], [func@GLib.return_if_reached] and
[func@GLib.return_val_if_reached] log at [flags@GLib.LogLevelFlags.LEVEL_CRITICAL].

You can make critical warnings fatal at runtime by
setting the `G_DEBUG` environment variable (see
[Running GLib Applications](running.html)):

```
G_DEBUG=fatal-warnings gdb ./my-program
```

You can also use [func@GLib.log_set_always_fatal].

Any unrelated failures can be skipped over in
[gdb](https://www.gnu.org/software/gdb/) using the `continue` command.

The message should typically *not* be translated to the
user&#x2019;s language.

If [func@GLib.log_default_handler] is used as the log handler function, a new-line
character will automatically be appended to @..., and need not be entered
manually.

If structured logging is enabled, this will use [func@GLib.log_structured];
otherwise it will use [func@GLib.log]. See
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <parameters>
        <parameter name="...">
          <doc xml:space="preserve">format string, followed by parameters to insert into the format string
  (as with `printf()`)</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="datalist_clear" c:identifier="g_datalist_clear" introspectable="0">
      <doc xml:space="preserve">Frees all the data elements of the datalist.
The data elements' destroy functions are called
if they have been set.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">a datalist.</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
      </parameters>
    </function>
    <function name="datalist_foreach" c:identifier="g_datalist_foreach">
      <doc xml:space="preserve">Calls the given function for each data element of the datalist. The
function is called with each data element's #GQuark id and data,
together with the given @user_data parameter. Note that this
function is NOT thread-safe. So unless @datalist can be protected
from any modifications during invocation of this function, it should
not be called.

@func can make changes to @datalist, but the iteration will not
reflect changes made during the g_datalist_foreach() call, other
than skipping over elements that are removed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">a datalist.</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call" closure="2">
          <doc xml:space="preserve">the function to call for each data element.</doc>
          <type name="DataForeachFunc" c:type="GDataForeachFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to the function.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="datalist_get_data" c:identifier="g_datalist_get_data">
      <doc xml:space="preserve">Gets a data element, using its string identifier. This is slower than
g_datalist_id_get_data() because it compares strings.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the data element, or %NULL if it
         is not found.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">a datalist.</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">the string identifying a data element.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="datalist_get_flags" c:identifier="g_datalist_get_flags" version="2.8">
      <doc xml:space="preserve">Gets flags values packed in together with the datalist.
See g_datalist_set_flags().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the flags of the datalist</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">pointer to the location that holds a list</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
      </parameters>
    </function>
    <function name="datalist_id_dup_data" c:identifier="g_datalist_id_dup_data" version="2.34" introspectable="0">
      <doc xml:space="preserve">This is a variant of g_datalist_id_get_data() which
returns a 'duplicate' of the value. @dup_func defines the
meaning of 'duplicate' in this context, it could e.g.
take a reference on a ref-counted object.

If the @key_id is not set in the datalist then @dup_func
will be called with a %NULL argument.

Note that @dup_func is called while the datalist is locked, so it
is not allowed to read or modify the datalist.

This function can be useful to avoid races when multiple
threads are using the same datalist and the same key.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the result of calling @dup_func on the value
    associated with @key_id in @datalist, or %NULL if not set.
    If @dup_func is %NULL, the value is returned unmodified.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">location of a datalist</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark identifying a data element</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="dup_func" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="3">
          <doc xml:space="preserve">function to
  duplicate the old value</doc>
          <type name="DuplicateFunc" c:type="GDuplicateFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">passed as user_data to @dup_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="datalist_id_get_data" c:identifier="g_datalist_id_get_data">
      <doc xml:space="preserve">Retrieves the data element corresponding to @key_id.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the data element, or %NULL if
         it is not found.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">a datalist.</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark identifying a data element.</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="datalist_id_remove_data" c:identifier="g_datalist_id_remove_data" introspectable="0">
      <doc xml:space="preserve">Removes an element, using its #GQuark identifier.</doc>
      <parameters>
        <parameter name="dl">
          <doc xml:space="preserve">a datalist.</doc>
        </parameter>
        <parameter name="q">
          <doc xml:space="preserve">the #GQuark identifying the data element.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="datalist_id_remove_multiple" c:identifier="g_datalist_id_remove_multiple" version="2.74">
      <doc xml:space="preserve">Removes multiple keys from a datalist.

This is more efficient than calling g_datalist_id_remove_data()
multiple times in a row.

Before 2.80, @n_keys had to be not larger than 16.
Since 2.84, performance is improved for larger number of keys.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">a datalist</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
        <parameter name="keys" transfer-ownership="none">
          <doc xml:space="preserve">keys to remove</doc>
          <array length="2" zero-terminated="0" c:type="GQuark*">
            <type name="Quark" c:type="GQuark"/>
          </array>
        </parameter>
        <parameter name="n_keys" transfer-ownership="none">
          <doc xml:space="preserve">length of @keys.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="datalist_id_remove_no_notify" c:identifier="g_datalist_id_remove_no_notify" introspectable="0">
      <doc xml:space="preserve">Removes an element, without calling its destroy notification
function.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the data previously stored at @key_id,
         or %NULL if none.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">a datalist.</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark identifying a data element.</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="datalist_id_replace_data" c:identifier="g_datalist_id_replace_data" version="2.34" introspectable="0">
      <doc xml:space="preserve">Compares the member that is associated with @key_id in
@datalist to @oldval, and if they are the same, replace
@oldval with @newval.

This is like a typical atomic compare-and-exchange
operation, for a member of @datalist.

If the previous value was replaced then ownership of the
old value (@oldval) is passed to the caller, including
the registered destroy notify for it (passed out in @old_destroy).
Its up to the caller to free this as they wish, which may
or may not include using @old_destroy as sometimes replacement
should not destroy the object in the normal way.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the existing value for @key_id was replaced
 by @newval, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">location of a datalist</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark identifying a data element</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="oldval" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the old value to compare against</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="newval" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the new value to replace it with</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">destroy notify for the new value</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="old_destroy" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1" scope="async">
          <doc xml:space="preserve">destroy notify for the existing value</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="datalist_id_set_data" c:identifier="g_datalist_id_set_data" introspectable="0">
      <doc xml:space="preserve">Sets the data corresponding to the given #GQuark id. Any previous
data with the same key is removed, and its destroy function is
called.</doc>
      <parameters>
        <parameter name="dl">
          <doc xml:space="preserve">a datalist.</doc>
        </parameter>
        <parameter name="q">
          <doc xml:space="preserve">the #GQuark to identify the data element.</doc>
        </parameter>
        <parameter name="d">
          <doc xml:space="preserve">the data element, or %NULL to remove any previous element
    corresponding to @q.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="datalist_id_set_data_full" c:identifier="g_datalist_id_set_data_full" introspectable="0">
      <doc xml:space="preserve">Sets the data corresponding to the given #GQuark id, and the
function to be called when the element is removed from the datalist.
Any previous data with the same key is removed, and its destroy
function is called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">a datalist.</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark to identify the data element.</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data element or %NULL to remove any previous element
       corresponding to @key_id.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">the function to call when the data element is
               removed. This function will be called with the data
               element and can be used to free any memory allocated
               for it. If @data is %NULL, then @destroy_func must
               also be %NULL.</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="datalist_init" c:identifier="g_datalist_init" introspectable="0">
      <doc xml:space="preserve">Resets the datalist to %NULL. It does not free any memory or call
any destroy functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a pointer to a datalist.</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="datalist_remove_data" c:identifier="g_datalist_remove_data" introspectable="0">
      <doc xml:space="preserve">Removes an element using its string identifier. The data element's
destroy function is called if it has been set.</doc>
      <parameters>
        <parameter name="dl">
          <doc xml:space="preserve">a datalist.</doc>
        </parameter>
        <parameter name="k">
          <doc xml:space="preserve">the string identifying the data element.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="datalist_remove_no_notify" c:identifier="g_datalist_remove_no_notify" introspectable="0">
      <doc xml:space="preserve">Removes an element, without calling its destroy notifier.</doc>
      <parameters>
        <parameter name="dl">
          <doc xml:space="preserve">a datalist.</doc>
        </parameter>
        <parameter name="k">
          <doc xml:space="preserve">the string identifying the data element.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="datalist_set_data" c:identifier="g_datalist_set_data" introspectable="0">
      <doc xml:space="preserve">Sets the data element corresponding to the given string identifier.</doc>
      <parameters>
        <parameter name="dl">
          <doc xml:space="preserve">a datalist.</doc>
        </parameter>
        <parameter name="k">
          <doc xml:space="preserve">the string to identify the data element.</doc>
        </parameter>
        <parameter name="d">
          <doc xml:space="preserve">the data element, or %NULL to remove any previous element
    corresponding to @k.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="datalist_set_data_full" c:identifier="g_datalist_set_data_full" introspectable="0">
      <doc xml:space="preserve">Sets the data element corresponding to the given string identifier,
and the function to be called when the data element is removed.</doc>
      <parameters>
        <parameter name="dl">
          <doc xml:space="preserve">a datalist.</doc>
        </parameter>
        <parameter name="k">
          <doc xml:space="preserve">the string to identify the data element.</doc>
        </parameter>
        <parameter name="d">
          <doc xml:space="preserve">the data element, or %NULL to remove any previous element
    corresponding to @k.</doc>
        </parameter>
        <parameter name="f">
          <doc xml:space="preserve">the function to call when the data element is removed.
    This function will be called with the data element and can be used to
    free any memory allocated for it. If @d is %NULL, then @f must
    also be %NULL.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="datalist_set_flags" c:identifier="g_datalist_set_flags" version="2.8">
      <doc xml:space="preserve">Turns on flag values for a data list. This function is used
to keep a small number of boolean flags in an object with
a data list without using any additional space. It is
not generally useful except in circumstances where space
is very tight. (It is used in the base #GObject type, for
example.)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">pointer to the location that holds a list</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">the flags to turn on. The values of the flags are
  restricted by %G_DATALIST_FLAGS_MASK (currently
  3; giving two possible boolean flags).
  A value for @flags that doesn't fit within the mask is
  an error.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="datalist_unset_flags" c:identifier="g_datalist_unset_flags" version="2.8">
      <doc xml:space="preserve">Turns off flag values for a data list. See g_datalist_unset_flags()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="datalist" transfer-ownership="none">
          <doc xml:space="preserve">pointer to the location that holds a list</doc>
          <type name="Data" c:type="GData**"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">the flags to turn off. The values of the flags are
  restricted by %G_DATALIST_FLAGS_MASK (currently
  3: giving two possible boolean flags).
  A value for @flags that doesn't fit within the mask is
  an error.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="dataset_destroy" c:identifier="g_dataset_destroy">
      <doc xml:space="preserve">Destroys the dataset, freeing all memory allocated, and calling any
destroy functions set for data elements.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dataset_location" transfer-ownership="none">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dataset_foreach" c:identifier="g_dataset_foreach">
      <doc xml:space="preserve">Calls the given function for each data element which is associated
with the given location. Note that this function is NOT thread-safe.
So unless @dataset_location can be protected from any modifications
during invocation of this function, it should not be called.

@func can make changes to the dataset, but the iteration will not
reflect changes made during the g_dataset_foreach() call, other
than skipping over elements that are removed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dataset_location" transfer-ownership="none">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call" closure="2">
          <doc xml:space="preserve">the function to call for each data element.</doc>
          <type name="DataForeachFunc" c:type="GDataForeachFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to the function.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="dataset_get_data" c:identifier="g_dataset_get_data" introspectable="0">
      <doc xml:space="preserve">Gets the data element corresponding to a string.</doc>
      <parameters>
        <parameter name="l">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
        </parameter>
        <parameter name="k">
          <doc xml:space="preserve">the string identifying the data element.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="dataset_id_get_data" c:identifier="g_dataset_id_get_data">
      <doc xml:space="preserve">Gets the data element corresponding to a #GQuark.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the data element corresponding to
         the #GQuark, or %NULL if it is not found.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="dataset_location" transfer-ownership="none">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark id to identify the data element.</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="dataset_id_remove_data" c:identifier="g_dataset_id_remove_data" introspectable="0">
      <doc xml:space="preserve">Removes a data element from a dataset. The data element's destroy
function is called if it has been set.</doc>
      <parameters>
        <parameter name="l">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
        </parameter>
        <parameter name="k">
          <doc xml:space="preserve">the #GQuark id identifying the data element.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="dataset_id_remove_no_notify" c:identifier="g_dataset_id_remove_no_notify" introspectable="0">
      <doc xml:space="preserve">Removes an element, without calling its destroy notification
function.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the data previously stored at @key_id,
         or %NULL if none.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="dataset_location" transfer-ownership="none">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark ID identifying the data element.</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="dataset_id_set_data" c:identifier="g_dataset_id_set_data" introspectable="0">
      <doc xml:space="preserve">Sets the data element associated with the given #GQuark id. Any
previous data with the same key is removed, and its destroy function
is called.</doc>
      <parameters>
        <parameter name="l">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
        </parameter>
        <parameter name="k">
          <doc xml:space="preserve">the #GQuark id to identify the data element.</doc>
        </parameter>
        <parameter name="d">
          <doc xml:space="preserve">the data element.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="dataset_id_set_data_full" c:identifier="g_dataset_id_set_data_full" introspectable="0">
      <doc xml:space="preserve">Sets the data element associated with the given #GQuark id, and also
the function to call when the data element is destroyed. Any
previous data with the same key is removed, and its destroy function
is called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dataset_location" transfer-ownership="none">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark id to identify the data element.</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data element.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy_func" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">the function to call when the data element is
               removed. This function will be called with the data
               element and can be used to free any memory allocated
               for it.</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="dataset_remove_data" c:identifier="g_dataset_remove_data" introspectable="0">
      <doc xml:space="preserve">Removes a data element corresponding to a string. Its destroy
function is called if it has been set.</doc>
      <parameters>
        <parameter name="l">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
        </parameter>
        <parameter name="k">
          <doc xml:space="preserve">the string identifying the data element.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="dataset_remove_no_notify" c:identifier="g_dataset_remove_no_notify" introspectable="0">
      <doc xml:space="preserve">Removes an element, without calling its destroy notifier.</doc>
      <parameters>
        <parameter name="l">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
        </parameter>
        <parameter name="k">
          <doc xml:space="preserve">the string identifying the data element.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="dataset_set_data" c:identifier="g_dataset_set_data" introspectable="0">
      <doc xml:space="preserve">Sets the data corresponding to the given string identifier.</doc>
      <parameters>
        <parameter name="l">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
        </parameter>
        <parameter name="k">
          <doc xml:space="preserve">the string to identify the data element.</doc>
        </parameter>
        <parameter name="d">
          <doc xml:space="preserve">the data element.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="dataset_set_data_full" c:identifier="g_dataset_set_data_full" introspectable="0">
      <doc xml:space="preserve">Sets the data corresponding to the given string identifier, and the
function to call when the data element is destroyed.</doc>
      <parameters>
        <parameter name="l">
          <doc xml:space="preserve">the location identifying the dataset.</doc>
        </parameter>
        <parameter name="k">
          <doc xml:space="preserve">the string to identify the data element.</doc>
        </parameter>
        <parameter name="d">
          <doc xml:space="preserve">the data element.</doc>
        </parameter>
        <parameter name="f">
          <doc xml:space="preserve">the function to call when the data element is removed. This
    function will be called with the data element and can be used to
    free any memory allocated for it.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="date_get_days_in_month" c:identifier="g_date_get_days_in_month" moved-to="Date.get_days_in_month">
      <doc xml:space="preserve">Returns the number of days in a month, taking leap
years into account.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of days in @month during the @year</doc>
        <type name="guint8" c:type="guint8"/>
      </return-value>
      <parameters>
        <parameter name="month" transfer-ownership="none">
          <doc xml:space="preserve">month</doc>
          <type name="DateMonth" c:type="GDateMonth"/>
        </parameter>
        <parameter name="year" transfer-ownership="none">
          <doc xml:space="preserve">year</doc>
          <type name="DateYear" c:type="GDateYear"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_get_monday_weeks_in_year" c:identifier="g_date_get_monday_weeks_in_year" moved-to="Date.get_monday_weeks_in_year">
      <doc xml:space="preserve">Returns the number of weeks in the year, where weeks
are taken to start on Monday. Will be 52 or 53. The
date must be valid. (Years always have 52 7-day periods,
plus 1 or 2 extra days depending on whether it's a leap
year. This function is basically telling you how many
Mondays are in the year, i.e. there are 53 Mondays if
one of the extra days happens to be a Monday.)</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of Mondays in the year</doc>
        <type name="guint8" c:type="guint8"/>
      </return-value>
      <parameters>
        <parameter name="year" transfer-ownership="none">
          <doc xml:space="preserve">a year</doc>
          <type name="DateYear" c:type="GDateYear"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_get_sunday_weeks_in_year" c:identifier="g_date_get_sunday_weeks_in_year" moved-to="Date.get_sunday_weeks_in_year">
      <doc xml:space="preserve">Returns the number of weeks in the year, where weeks
are taken to start on Sunday. Will be 52 or 53. The
date must be valid. (Years always have 52 7-day periods,
plus 1 or 2 extra days depending on whether it's a leap
year. This function is basically telling you how many
Sundays are in the year, i.e. there are 53 Sundays if
one of the extra days happens to be a Sunday.)</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of weeks in @year</doc>
        <type name="guint8" c:type="guint8"/>
      </return-value>
      <parameters>
        <parameter name="year" transfer-ownership="none">
          <doc xml:space="preserve">year to count weeks in</doc>
          <type name="DateYear" c:type="GDateYear"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_get_weeks_in_year" c:identifier="g_date_get_weeks_in_year" moved-to="Date.get_weeks_in_year" version="2.86">
      <doc xml:space="preserve">Calculates the number of weeks in the year.

The result depends on which day is considered the first day of the week,
which varies by locale. `first_day_of_week` must be valid.

The result will be either 52 or 53. Years always have 52 seven-day periods,
plus one or two extra days depending on whether it&#x2019;s a leap year. This
function effectively calculates how many @first_day_of_week days there are in
the year.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of weeks in @year</doc>
        <type name="guint8" c:type="guint8"/>
      </return-value>
      <parameters>
        <parameter name="year" transfer-ownership="none">
          <doc xml:space="preserve">year to count weeks in</doc>
          <type name="DateYear" c:type="GDateYear"/>
        </parameter>
        <parameter name="first_day_of_week" transfer-ownership="none">
          <doc xml:space="preserve">the day which is considered the first day of the week
   (for example, this would be [enum@GLib.DateWeekday.SUNDAY] in US locales,
   [enum@GLib.DateWeekday.MONDAY] in British locales, and
   [enum@GLib.DateWeekday.SATURDAY] in Egyptian locales</doc>
          <type name="DateWeekday" c:type="GDateWeekday"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_is_leap_year" c:identifier="g_date_is_leap_year" moved-to="Date.is_leap_year">
      <doc xml:space="preserve">Returns %TRUE if the year is a leap year.

For the purposes of this function, leap year is every year
divisible by 4 unless that year is divisible by 100. If it
is divisible by 100 it would be a leap year only if that year
is also divisible by 400.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the year is a leap year</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="year" transfer-ownership="none">
          <doc xml:space="preserve">year to check</doc>
          <type name="DateYear" c:type="GDateYear"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_strftime" c:identifier="g_date_strftime" moved-to="Date.strftime">
      <doc xml:space="preserve">Generates a printed representation of the date, in a
[locale](running.html#locale)-specific way.
Works just like the platform's C library strftime() function,
but only accepts date-related formats; time-related formats
give undefined results. Date must be valid. Unlike strftime()
(which uses the locale encoding), works on a UTF-8 format
string and stores a UTF-8 result.

This function does not provide any conversion specifiers in
addition to those implemented by the platform's C library.
For example, don't expect that using g_date_strftime() would
make the \%F provided by the C99 strftime() work on Windows
where the C library only complies to C89.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of characters written to the buffer, or `0` if the buffer was too small</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="s" transfer-ownership="none">
          <doc xml:space="preserve">destination buffer</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="slen" transfer-ownership="none">
          <doc xml:space="preserve">buffer size</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">format string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="date" transfer-ownership="none">
          <doc xml:space="preserve">valid #GDate</doc>
          <type name="Date" c:type="const GDate*"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_valid_day" c:identifier="g_date_valid_day" moved-to="Date.valid_day">
      <doc xml:space="preserve">Returns %TRUE if the day of the month is valid (a day is valid if it's
between 1 and 31 inclusive).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the day is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="day" transfer-ownership="none">
          <doc xml:space="preserve">day to check</doc>
          <type name="DateDay" c:type="GDateDay"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_valid_dmy" c:identifier="g_date_valid_dmy" moved-to="Date.valid_dmy">
      <doc xml:space="preserve">Returns %TRUE if the day-month-year triplet forms a valid, existing day
in the range of days #GDate understands (Year 1 or later, no more than
a few thousand years in the future).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the date is a valid one</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="day" transfer-ownership="none">
          <doc xml:space="preserve">day</doc>
          <type name="DateDay" c:type="GDateDay"/>
        </parameter>
        <parameter name="month" transfer-ownership="none">
          <doc xml:space="preserve">month</doc>
          <type name="DateMonth" c:type="GDateMonth"/>
        </parameter>
        <parameter name="year" transfer-ownership="none">
          <doc xml:space="preserve">year</doc>
          <type name="DateYear" c:type="GDateYear"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_valid_julian" c:identifier="g_date_valid_julian" moved-to="Date.valid_julian">
      <doc xml:space="preserve">Returns %TRUE if the Julian day is valid. Anything greater than zero
is basically a valid Julian, though there is a 32-bit limit.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the Julian day is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="julian_date" transfer-ownership="none">
          <doc xml:space="preserve">Julian day to check</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_valid_month" c:identifier="g_date_valid_month" moved-to="Date.valid_month">
      <doc xml:space="preserve">Returns %TRUE if the month value is valid. The 12 #GDateMonth
enumeration values are the only valid months.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the month is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="month" transfer-ownership="none">
          <doc xml:space="preserve">month</doc>
          <type name="DateMonth" c:type="GDateMonth"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_valid_weekday" c:identifier="g_date_valid_weekday" moved-to="Date.valid_weekday">
      <doc xml:space="preserve">Returns %TRUE if the weekday is valid. The seven #GDateWeekday enumeration
values are the only valid weekdays.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the weekday is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="weekday" transfer-ownership="none">
          <doc xml:space="preserve">weekday</doc>
          <type name="DateWeekday" c:type="GDateWeekday"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_valid_year" c:identifier="g_date_valid_year" moved-to="Date.valid_year">
      <doc xml:space="preserve">Returns %TRUE if the year is valid. Any year greater than 0 is valid,
though there is a 16-bit limit to what #GDate will understand.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the year is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="year" transfer-ownership="none">
          <doc xml:space="preserve">year</doc>
          <type name="DateYear" c:type="GDateYear"/>
        </parameter>
      </parameters>
    </function>
    <function name="dcgettext" c:identifier="g_dcgettext" version="2.26">
      <doc xml:space="preserve">This is a variant of g_dgettext() that allows specifying a locale
category instead of always using `LC_MESSAGES`. See g_dgettext() for
more information about how this functions differs from calling
dcgettext() directly.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the translated string for the given locale category</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the translation domain to use, or %NULL to use
  the domain set with textdomain()</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="msgid" transfer-ownership="none">
          <doc xml:space="preserve">message to translate</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="category" transfer-ownership="none">
          <doc xml:space="preserve">a locale category</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="debug" c:identifier="g_debug" version="2.6" introspectable="0">
      <doc xml:space="preserve">A convenience function/macro to log a debug message.

The message should typically *not* be translated to the user&#x2019;s language.

If [func@GLib.log_default_handler] is used as the log handler function, a new-line
character will automatically be appended to @..., and need not be entered
manually.

Such messages are suppressed by the [func@GLib.log_default_handler] and
[func@GLib.log_writer_default] unless the `G_MESSAGES_DEBUG` or
`DEBUG_INVOCATION` environment variables are set appropriately. If you need
to set the allowed domains at runtime, use
[func@GLib.log_writer_default_set_debug_domains].

If structured logging is enabled, this will use [func@GLib.log_structured];
otherwise it will use [func@GLib.log]. See
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <parameters>
        <parameter name="...">
          <doc xml:space="preserve">format string, followed by parameters to insert into the format string
  (as with `printf()`)</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="dgettext" c:identifier="g_dgettext" version="2.18">
      <doc xml:space="preserve">This function is a wrapper of dgettext() which does not translate
the message if the default domain as set with textdomain() has no
translations for the current locale.

The advantage of using this function over dgettext() proper is that
libraries using this function (like GTK) will not use translations
if the application using the library does not have translations for
the current locale.  This results in a consistent English-only
interface instead of one having partial translations.  For this
feature to work, the call to textdomain() and setlocale() should
precede any g_dgettext() invocations.  For GTK, it means calling
textdomain() before gtk_init or its variants.

This function disables translations if and only if upon its first
call all the following conditions hold:

- @domain is not %NULL

- textdomain() has been called to set a default text domain

- there is no translations available for the default text domain
  and the current locale

- current locale is not "C" or any English locales (those
  starting with "en_")

Note that this behavior may not be desired for example if an application
has its untranslated messages in a language other than English. In those
cases the application should call textdomain() after initializing GTK.

Applications should normally not use this function directly,
but use the _() macro for translations.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The translated string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the translation domain to use, or %NULL to use
  the domain set with textdomain()</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="msgid" transfer-ownership="none">
          <doc xml:space="preserve">message to translate</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dir_make_tmp" c:identifier="g_dir_make_tmp" moved-to="Dir.make_tmp" version="2.30" throws="1">
      <doc xml:space="preserve">Creates a subdirectory in the preferred directory for temporary
files (as returned by g_get_tmp_dir()).

@tmpl should be a string in the GLib file name encoding containing
a sequence of six 'X' characters, as the parameter to g_mkstemp().
However, unlike these functions, the template should only be a
basename, no directory components are allowed. If template is
%NULL, a default template is used.

Note that in contrast to g_mkdtemp() (and mkdtemp()) @tmpl is not
modified, and might thus be a read-only literal string.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The actual name used. This string
  should be freed with g_free() when not needed any longer and is
  is in the GLib file name encoding. In case of errors, %NULL is
  returned and @error will be set.</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="tmpl" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Template for directory name,
  as in g_mkdtemp(), basename only, or %NULL for a default template</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="direct_equal" c:identifier="g_direct_equal">
      <doc xml:space="preserve">Compares two #gpointer arguments and returns %TRUE if they are equal.
It can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using opaque pointers compared by pointer value as
keys in a #GHashTable.

This equality function is also appropriate for keys that are integers
stored in pointers, such as `GINT_TO_POINTER (n)`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the two keys match.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a key</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a key to compare with @v1</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="direct_hash" c:identifier="g_direct_hash">
      <doc xml:space="preserve">Converts a gpointer to a hash value.
It can be passed to g_hash_table_new() as the @hash_func parameter,
when using opaque pointers compared by pointer value as keys in a
#GHashTable.

This hash function is also appropriate for keys that are integers
stored in pointers, such as `GINT_TO_POINTER (n)`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a hash value corresponding to the key.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="v" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #gpointer key</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dngettext" c:identifier="g_dngettext" version="2.18">
      <doc xml:space="preserve">This function is a wrapper of dngettext() which does not translate
the message if the default domain as set with textdomain() has no
translations for the current locale.

See g_dgettext() for details of how this differs from dngettext()
proper.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The translated string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the translation domain to use, or %NULL to use
  the domain set with textdomain()</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="msgid" transfer-ownership="none">
          <doc xml:space="preserve">message to translate</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="msgid_plural" transfer-ownership="none">
          <doc xml:space="preserve">plural form of the message</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">the quantity for which translation is needed</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="double_equal" c:identifier="g_double_equal" version="2.22">
      <doc xml:space="preserve">Compares the two #gdouble values being pointed to and returns
%TRUE if they are equal.
It can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using non-%NULL pointers to doubles as keys in a
#GHashTable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the two keys match.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gdouble key</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gdouble key to compare with @v1</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="double_hash" c:identifier="g_double_hash" version="2.22">
      <doc xml:space="preserve">Converts a pointer to a #gdouble to a hash value.
It can be passed to g_hash_table_new() as the @hash_func parameter,
It can be passed to g_hash_table_new() as the @hash_func parameter,
when using non-%NULL pointers to doubles as keys in a #GHashTable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a hash value corresponding to the key.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="v" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gdouble key</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dpgettext" c:identifier="g_dpgettext" version="2.16">
      <doc xml:space="preserve">This function is a variant of g_dgettext() which supports
a disambiguating message context. GNU gettext uses the
'\004' character to separate the message context and
message id in @msgctxtid.
If 0 is passed as @msgidoffset, this function will fall back to
trying to use the deprecated convention of using "|" as a separation
character.

This uses g_dgettext() internally. See that functions for differences
with dgettext() proper.

Applications should normally not use this function directly,
but use the C_() macro for translations with context.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The translated string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the translation domain to use, or %NULL to use
  the domain set with textdomain()</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="msgctxtid" transfer-ownership="none">
          <doc xml:space="preserve">a combined message context and message id, separated
  by a \004 character</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="msgidoffset" transfer-ownership="none">
          <doc xml:space="preserve">the offset of the message id in @msgctxid</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="dpgettext2" c:identifier="g_dpgettext2" version="2.18">
      <doc xml:space="preserve">This function is a variant of g_dgettext() which supports
a disambiguating message context. GNU gettext uses the
'\004' character to separate the message context and
message id in @msgctxtid.

This uses g_dgettext() internally. See that functions for differences
with dgettext() proper.

This function differs from C_() in that it is not a macro and
thus you may use non-string-literals as context and msgid arguments.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The translated string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the translation domain to use, or %NULL to use
  the domain set with textdomain()</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve">the message context</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="msgid" transfer-ownership="none">
          <doc xml:space="preserve">the message</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="environ_getenv" c:identifier="g_environ_getenv" version="2.32">
      <doc xml:space="preserve">Returns the value of the environment variable @variable in the
provided list @envp.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the value of the environment variable, or %NULL if
    the environment variable is not set in @envp. The returned
    string is owned by @envp, and will be freed if @variable is
    set or unset again.</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="envp" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">
    an environment list (eg, as returned from g_get_environ()), or %NULL
    for an empty environment list</doc>
          <array c:type="gchar**">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="variable" transfer-ownership="none">
          <doc xml:space="preserve">the environment variable to get</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="environ_setenv" c:identifier="g_environ_setenv" version="2.32">
      <doc xml:space="preserve">Sets the environment variable @variable in the provided list
@envp to @value.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
    the updated environment list. Free it using g_strfreev().</doc>
        <array c:type="gchar**">
          <type name="filename"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="envp" transfer-ownership="full" nullable="1" allow-none="1">
          <doc xml:space="preserve">
    an environment list that can be freed using g_strfreev() (e.g., as
    returned from g_get_environ()), or %NULL for an empty
    environment list</doc>
          <array c:type="gchar**">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="variable" transfer-ownership="none">
          <doc xml:space="preserve">the environment variable to set, must not
    contain '='</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value for to set the variable to</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="overwrite" transfer-ownership="none">
          <doc xml:space="preserve">whether to change the variable if it already exists</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="environ_unsetenv" c:identifier="g_environ_unsetenv" version="2.32">
      <doc xml:space="preserve">Removes the environment variable @variable from the provided
environment @envp.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
    the updated environment list. Free it using g_strfreev().</doc>
        <array c:type="gchar**">
          <type name="filename"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="envp" transfer-ownership="full" nullable="1" allow-none="1">
          <doc xml:space="preserve">
    an environment list that can be freed using g_strfreev() (e.g., as
    returned from g_get_environ()), or %NULL for an empty environment list</doc>
          <array c:type="gchar**">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="variable" transfer-ownership="none">
          <doc xml:space="preserve">the environment variable to remove, must not
    contain '='</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="error" c:identifier="g_error" introspectable="0">
      <doc xml:space="preserve">A convenience function/macro to log an error message.

The message should typically *not* be translated to the user&#x2019;s language.

This is not intended for end user error reporting. Use of [type@GLib.Error] is
preferred for that instead, as it allows calling functions to perform actions
conditional on the type of error.

Error messages are always fatal, resulting in a call to [func@GLib.BREAKPOINT]
to terminate the application. This function will
result in a core dump; don&#x2019;t use it for errors you expect.
Using this function indicates a bug in your program, i.e.
an assertion failure.

If [func@GLib.log_default_handler] is used as the log handler function, a new-line
character will automatically be appended to @..., and need not be entered
manually.

If structured logging is enabled, this will use [func@GLib.log_structured];
otherwise it will use [func@GLib.log]. See
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <parameters>
        <parameter name="...">
          <doc xml:space="preserve">format string, followed by parameters to insert into the format string
  (as with `printf()`)</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="error_domain_register" c:identifier="g_error_domain_register" moved-to="Error.domain_register" version="2.68">
      <doc xml:space="preserve">This function registers an extended #GError domain.
@error_type_name will be duplicated. Otherwise does the same as
g_error_domain_register_static().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">#GQuark representing the error domain</doc>
        <type name="Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="error_type_name" transfer-ownership="none">
          <doc xml:space="preserve">string to create a #GQuark from</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="error_type_private_size" transfer-ownership="none">
          <doc xml:space="preserve">size of the private error data in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="error_type_init" transfer-ownership="none" scope="forever">
          <doc xml:space="preserve">function initializing fields of the private error data</doc>
          <type name="ErrorInitFunc" c:type="GErrorInitFunc"/>
        </parameter>
        <parameter name="error_type_copy" transfer-ownership="none" scope="forever">
          <doc xml:space="preserve">function copying fields of the private error data</doc>
          <type name="ErrorCopyFunc" c:type="GErrorCopyFunc"/>
        </parameter>
        <parameter name="error_type_clear" transfer-ownership="none" scope="forever">
          <doc xml:space="preserve">function freeing fields of the private error data</doc>
          <type name="ErrorClearFunc" c:type="GErrorClearFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_domain_register_static" c:identifier="g_error_domain_register_static" moved-to="Error.domain_register_static" version="2.68">
      <doc xml:space="preserve">This function registers an extended #GError domain.

@error_type_name should not be freed. @error_type_private_size must
be greater than 0.

@error_type_init receives an initialized #GError and should then initialize
the private data.

@error_type_copy is a function that receives both original and a copy
#GError and should copy the fields of the private error data. The standard
#GError fields are already handled.

@error_type_clear receives the pointer to the error, and it should free the
fields of the private error data. It should not free the struct itself though.

Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it
already takes care of passing valid information to this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">#GQuark representing the error domain</doc>
        <type name="Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="error_type_name" transfer-ownership="none">
          <doc xml:space="preserve">static string to create a #GQuark from</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="error_type_private_size" transfer-ownership="none">
          <doc xml:space="preserve">size of the private error data in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="error_type_init" transfer-ownership="none" scope="forever">
          <doc xml:space="preserve">function initializing fields of the private error data</doc>
          <type name="ErrorInitFunc" c:type="GErrorInitFunc"/>
        </parameter>
        <parameter name="error_type_copy" transfer-ownership="none" scope="forever">
          <doc xml:space="preserve">function copying fields of the private error data</doc>
          <type name="ErrorCopyFunc" c:type="GErrorCopyFunc"/>
        </parameter>
        <parameter name="error_type_clear" transfer-ownership="none" scope="forever">
          <doc xml:space="preserve">function freeing fields of the private error data</doc>
          <type name="ErrorClearFunc" c:type="GErrorClearFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="fdwalk_set_cloexec" c:identifier="g_fdwalk_set_cloexec" version="2.80">
      <doc xml:space="preserve">Mark every file descriptor equal to or greater than @lowfd to be closed
at the next `execve()` or similar, as if via the `FD_CLOEXEC` flag.

Typically @lowfd will be 3, to leave standard input, standard output
and standard error open after exec.

This is the same as Linux `close_range (lowfd, ~0U, CLOSE_RANGE_CLOEXEC)`,
but portable to other OSs and to older versions of Linux.

This function is async-signal safe, making it safe to call from a
signal handler or a [callback@GLib.SpawnChildSetupFunc], as long as @lowfd is
non-negative.
See [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7)) for more details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 with errno set on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="lowfd" transfer-ownership="none">
          <doc xml:space="preserve">Minimum fd to act on, which must be non-negative</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_error_from_errno" c:identifier="g_file_error_from_errno">
      <doc xml:space="preserve">Gets a #GFileError constant based on the passed-in @err_no.

For example, if you pass in `EEXIST` this function returns
%G_FILE_ERROR_EXIST. Unlike `errno` values, you can portably
assume that all #GFileError values will exist.

Normally a #GFileError value goes into a #GError returned
from a function that manipulates files. So you would use
g_file_error_from_errno() when constructing a #GError.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">#GFileError corresponding to the given @err_no</doc>
        <type name="FileError" c:type="GFileError"/>
      </return-value>
      <parameters>
        <parameter name="err_no" transfer-ownership="none">
          <doc xml:space="preserve">an "errno" value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_error_quark" c:identifier="g_file_error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="file_get_contents" c:identifier="g_file_get_contents" throws="1">
      <doc xml:space="preserve">Reads an entire file into allocated memory, with good error
checking.

If the call was successful, it returns %TRUE and sets @contents to the file
contents and @length to the length of the file contents in bytes. The string
stored in @contents will be nul-terminated, so for text files you can pass
%NULL for the @length argument. If the call was not successful, it returns
%FALSE and sets @error. The error domain is %G_FILE_ERROR. Possible error
codes are those in the #GFileError enumeration. In the error case,
@contents is set to %NULL and @length is set to zero.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if an error occurred</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">name of a file to read contents from, in the GLib file name encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="contents" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">location to store an allocated string, use g_free() to free
    the returned string</doc>
          <array length="2" zero-terminated="0" c:type="gchar**">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">location to store length in bytes of the contents, or %NULL</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_open_tmp" c:identifier="g_file_open_tmp" throws="1">
      <doc xml:space="preserve">Opens a file for writing in the preferred directory for temporary
files (as returned by g_get_tmp_dir()).

@tmpl should be a string in the GLib file name encoding containing
a sequence of six 'X' characters, as the parameter to g_mkstemp().
However, unlike these functions, the template should only be a
basename, no directory components are allowed. If template is
%NULL, a default template is used.

Note that in contrast to g_mkstemp() (and mkstemp()) @tmpl is not
modified, and might thus be a read-only literal string.

Upon success, and if @name_used is non-%NULL, the actual name used
is returned in @name_used. This string should be freed with g_free()
when not needed any longer. The returned name is in the GLib file
name encoding.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A file handle (as from open()) to the file opened for
  reading and writing. The file is opened in binary mode on platforms
  where there is a difference. The file handle should be closed with
  close(). In case of errors, -1 is returned and @error will be set.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="tmpl" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Template for file name, as in
  g_mkstemp(), basename only, or %NULL for a default template</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="name_used" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">location to store actual name used,
  or %NULL</doc>
          <type name="filename" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_read_link" c:identifier="g_file_read_link" version="2.4" throws="1">
      <doc xml:space="preserve">Reads the contents of the symbolic link @filename like the POSIX
`readlink()` function.

The returned string is in the encoding used for filenames. Use
g_filename_to_utf8() to convert it to UTF-8.

The returned string may also be a relative path. Use g_build_filename()
to convert it to an absolute path:

|[&lt;!-- language="C" --&gt;
g_autoptr(GError) local_error = NULL;
g_autofree gchar *link_target = g_file_read_link ("/etc/localtime", &amp;local_error);

if (local_error != NULL)
  g_error ("Error reading link: %s", local_error-&gt;message);

if (!g_path_is_absolute (link_target))
  {
    g_autofree gchar *absolute_link_target = g_build_filename ("/etc", link_target, NULL);
    g_free (link_target);
    link_target = g_steal_pointer (&amp;absolute_link_target);
  }
]|</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A newly-allocated string with
  the contents of the symbolic link, or %NULL if an error occurred.</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">the symbolic link</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_set_contents" c:identifier="g_file_set_contents" version="2.8" throws="1">
      <doc xml:space="preserve">Writes all of @contents to a file named @filename. This is a convenience
wrapper around calling g_file_set_contents_full() with `flags` set to
`G_FILE_SET_CONTENTS_CONSISTENT | G_FILE_SET_CONTENTS_ONLY_EXISTING` and
`mode` set to `0666`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if an error occurred</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">name of a file to write @contents to, in the GLib file name
  encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="contents" transfer-ownership="none">
          <doc xml:space="preserve">string to write to the file</doc>
          <array length="2" zero-terminated="0" c:type="const gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of @contents, or -1 if @contents is a nul-terminated string</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_set_contents_full" c:identifier="g_file_set_contents_full" version="2.66" throws="1">
      <doc xml:space="preserve">Writes all of @contents to a file named @filename, with good error checking.
If a file called @filename already exists it will be overwritten.

@flags control the properties of the write operation: whether it&#x2019;s atomic,
and what the tradeoff is between returning quickly or being resilient to
system crashes.

As this function performs file I/O, it is recommended to not call it anywhere
where blocking would cause problems, such as in the main loop of a graphical
application. In particular, if @flags has any value other than
%G_FILE_SET_CONTENTS_NONE then this function may call `fsync()`.

If %G_FILE_SET_CONTENTS_CONSISTENT is set in @flags, the operation is atomic
in the sense that it is first written to a temporary file which is then
renamed to the final name.

Notes:

- On UNIX, if @filename already exists hard links to @filename will break.
  Also since the file is recreated, existing permissions, access control
  lists, metadata etc. may be lost. If @filename is a symbolic link,
  the link itself will be replaced, not the linked file.

- On UNIX, if @filename already exists and is non-empty, and if the system
  supports it (via a journalling filesystem or equivalent), and if
  %G_FILE_SET_CONTENTS_CONSISTENT is set in @flags, the `fsync()` call (or
  equivalent) will be used to ensure atomic replacement: @filename
  will contain either its old contents or @contents, even in the face of
  system power loss, the disk being unsafely removed, etc.

- On UNIX, if @filename does not already exist or is empty, there is a
  possibility that system power loss etc. after calling this function will
  leave @filename empty or full of NUL bytes, depending on the underlying
  filesystem, unless %G_FILE_SET_CONTENTS_DURABLE and
  %G_FILE_SET_CONTENTS_CONSISTENT are set in @flags.

- On Windows renaming a file will not remove an existing file with the
  new name, so on Windows there is a race condition between the existing
  file being removed and the temporary file being renamed.

- On Windows there is no way to remove a file that is open to some
  process, or mapped into memory. Thus, this function will fail if
  @filename already exists and is open.

If the call was successful, it returns %TRUE. If the call was not successful,
it returns %FALSE and sets @error. The error domain is %G_FILE_ERROR.
Possible error codes are those in the #GFileError enumeration.

Note that the name for the temporary file is constructed by appending up
to 7 characters to @filename.

If the file didn&#x2019;t exist before and is created, it will be given the
permissions from @mode. Otherwise, the permissions of the existing file will
remain unchanged.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if an error occurred</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">name of a file to write @contents to, in the GLib file name
  encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="contents" transfer-ownership="none">
          <doc xml:space="preserve">string to write to the file</doc>
          <array length="2" zero-terminated="0" c:type="const gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of @contents, or -1 if @contents is a nul-terminated string</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags controlling the safety vs speed of the operation</doc>
          <type name="FileSetContentsFlags" c:type="GFileSetContentsFlags"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">file mode, as passed to `open()`; typically this will be `0666`</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_test" c:identifier="g_file_test">
      <doc xml:space="preserve">Returns %TRUE if any of the tests in the bitfield @test are
%TRUE. For example, `(G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)`
will return %TRUE if the file exists; the check whether it's a
directory doesn't matter since the existence test is %TRUE. With
the current set of available tests, there's no point passing in
more than one test at a time.

Apart from %G_FILE_TEST_IS_SYMLINK all tests follow symbolic links,
so for a symbolic link to a regular file g_file_test() will return
%TRUE for both %G_FILE_TEST_IS_SYMLINK and %G_FILE_TEST_IS_REGULAR.

Note, that for a dangling symbolic link g_file_test() will return
%TRUE for %G_FILE_TEST_IS_SYMLINK and %FALSE for all other flags.

You should never use g_file_test() to test whether it is safe
to perform an operation, because there is always the possibility
of the condition changing before you actually perform the operation,
see [TOCTOU](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use).

For example, you might think you could use %G_FILE_TEST_IS_SYMLINK
to know whether it is safe to write to a file without being
tricked into writing into a different location. It doesn't work!

|[&lt;!-- language="C" --&gt;
 // DON'T DO THIS
 if (!g_file_test (filename, G_FILE_TEST_IS_SYMLINK))
   {
     fd = g_open (filename, O_WRONLY);
     // write to fd
   }

 // DO THIS INSTEAD
 fd = g_open (filename, O_WRONLY | O_NOFOLLOW | O_CLOEXEC);
 if (fd == -1)
   {
     // check error
     if (errno == ELOOP)
       // file is a symlink and can be ignored
     else
       // handle errors as before
   }
 else
   {
     // write to fd
   }
]|

Another thing to note is that %G_FILE_TEST_EXISTS and
%G_FILE_TEST_IS_EXECUTABLE are implemented using the access()
system call. This usually doesn't matter, but if your program
is setuid or setgid it means that these tests will give you
the answer for the real user ID and group ID, rather than the
effective user ID and group ID.

On Windows, there are no symlinks, so testing for
%G_FILE_TEST_IS_SYMLINK will always return %FALSE. Testing for
%G_FILE_TEST_IS_EXECUTABLE will just check that the file exists and
its name indicates that it is executable, checking for well-known
extensions and those listed in the `PATHEXT` environment variable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether a test was %TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a filename to test in the
    GLib file name encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="test" transfer-ownership="none">
          <doc xml:space="preserve">bitfield of #GFileTest flags</doc>
          <type name="FileTest" c:type="GFileTest"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_display_basename" c:identifier="g_filename_display_basename" version="2.6">
      <doc xml:space="preserve">Returns the display basename for the particular filename, guaranteed
to be valid UTF-8. The display name might not be identical to the filename,
for instance there might be problems converting it to UTF-8, and some files
can be translated in the display.

If GLib cannot make sense of the encoding of @filename, as a last resort it
replaces unknown characters with U+FFFD, the Unicode replacement character.
You can search the result for the UTF-8 encoding of this character (which is
"\357\277\275" in octal notation) to find out if @filename was in an invalid
encoding.

You must pass the whole absolute pathname to this functions so that
translation of well known locations can be done.

This function is preferred over g_filename_display_name() if you know the
whole path, as it allows translation.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string containing
  a rendition of the basename of the filename in valid UTF-8</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">an absolute pathname in the
    GLib file name encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_display_name" c:identifier="g_filename_display_name" version="2.6">
      <doc xml:space="preserve">Converts a filename into a valid UTF-8 string. The conversion is
not necessarily reversible, so you should keep the original around
and use the return value of this function only for display purposes.
Unlike g_filename_to_utf8(), the result is guaranteed to be non-%NULL
even if the filename actually isn't in the GLib file name encoding.

If GLib cannot make sense of the encoding of @filename, as a last resort it
replaces unknown characters with U+FFFD, the Unicode replacement character.
You can search the result for the UTF-8 encoding of this character (which is
"\357\277\275" in octal notation) to find out if @filename was in an invalid
encoding.

If you know the whole pathname of the file you should use
g_filename_display_basename(), since that allows location-based
translation of filenames.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string containing
  a rendition of the filename in valid UTF-8</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname hopefully in the
    GLib file name encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_from_uri" c:identifier="g_filename_from_uri" throws="1">
      <doc xml:space="preserve">Converts an escaped ASCII-encoded URI to a local filename in the
encoding used for filenames.

Since GLib 2.78, the query string and fragment can be present in the URI,
but are not part of the resulting filename.
We take inspiration from https://url.spec.whatwg.org/#file-state,
but we don't support the entire standard.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated string holding
              the resulting filename, or %NULL on an error.</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">a uri describing a filename (escaped, encoded in ASCII).</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="hostname" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">Location to store hostname for the URI.
           If there is no hostname in the URI, %NULL will be
           stored in this location.</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_from_utf8" c:identifier="g_filename_from_utf8" throws="1">
      <doc xml:space="preserve">Converts a string from UTF-8 to the encoding GLib uses for
filenames. Note that on Windows GLib uses UTF-8 for filenames;
on other platforms, this function indirectly depends on the
[current locale](running.html#locale).

The input string shall not contain nul characters even if the @len
argument is positive. A nul character found inside the string will result
in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the filename encoding is
not UTF-8 and the conversion output contains a nul character, the error
%G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns %NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
              The converted string, or %NULL on an error.</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="utf8string" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the string, or -1 if the string is
                nul-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store the number of bytes in
                the input string that were successfully converted, or %NULL.
                Even if the conversion was successful, this may be
                less than @len if there were partial characters
                at the end of the input. If the error
                %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
                stored will be the byte offset after the last valid
                input sequence.</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the number of bytes stored in
                the output buffer (not including the terminating nul).</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_to_uri" c:identifier="g_filename_to_uri" throws="1">
      <doc xml:space="preserve">Converts an absolute filename to an escaped ASCII-encoded URI, with the path
component following Section 3.3. of RFC 2396.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated string holding the resulting
              URI, or %NULL on an error.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">an absolute filename specified in the GLib file
    name encoding, which is the on-disk file name bytes on Unix, and UTF-8
    on Windows</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="hostname" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">A UTF-8 encoded hostname, or %NULL for none.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_to_utf8" c:identifier="g_filename_to_utf8" throws="1">
      <doc xml:space="preserve">Converts a string which is in the encoding used by GLib for
filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8
for filenames; on other platforms, this function indirectly depends on
the [current locale](running.html#locale).

The input string shall not contain nul characters even if the @len
argument is positive. A nul character found inside the string will result
in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
If the source encoding is not UTF-8 and the conversion output contains a
nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
function returns %NULL. Use g_convert() to produce output that
may contain embedded nul characters.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The converted string, or %NULL on an error.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="opsysstring" transfer-ownership="none">
          <doc xml:space="preserve">a string in the encoding for filenames</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the string, or -1 if the string is
                nul-terminated (Note that some encodings may allow nul
                bytes to occur inside strings. In that case, using -1
                for the @len parameter is unsafe)</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store the number of bytes in the
                input string that were successfully converted, or %NULL.
                Even if the conversion was successful, this may be
                less than @len if there were partial characters
                at the end of the input. If the error
                %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
                stored will be the byte offset after the last valid
                input sequence.</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the number of bytes stored in the output
                buffer (not including the terminating nul).</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="find_program_in_path" c:identifier="g_find_program_in_path">
      <doc xml:space="preserve">Locates the first executable named @program in the user's path, in the
same way that execvp() would locate it. Returns an allocated string
with the absolute path name, or %NULL if the program is not found in
the path. If @program is already an absolute path, returns a copy of
@program if @program exists and is executable, and %NULL otherwise.
 
On Windows, if @program does not have a file type suffix, tries
with the suffixes .exe, .cmd, .bat and .com, and the suffixes in
the `PATHEXT` environment variable.

On Windows, it looks for the file in the same way as CreateProcess()
would. This means first in the directory where the executing
program was loaded from, then in the current directory, then in the
Windows 32-bit system directory, then in the Windows directory, and
finally in the directories in the `PATH` environment variable. If
the program is found, the return value contains the full name
including the type suffix.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a newly-allocated
  string with the absolute path, or %NULL</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve">a program name in the GLib file name encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="fopen" c:identifier="g_fopen" version="2.6">
      <doc xml:space="preserve">A wrapper for the stdio `fopen()` function. The `fopen()` function
opens a file and associates a new stream with it.

Because file descriptors are specific to the C library on Windows,
and a file descriptor is part of the `FILE` struct, the `FILE*` returned
by this function makes sense only to functions in the same C library.
Thus if the GLib-using code uses a different C library than GLib does,
the FILE* returned by this function cannot be passed to C library
functions like `fprintf()` or `fread()`.

See your C library manual for more details about `fopen()`.

As `close()` and `fclose()` are part of the C library, this implies that it is
currently impossible to close a file if the application C library and the C library
used by GLib are different. Convenience functions like g_file_set_contents_full()
avoid this problem.

Since GLib 2.86, the `e` option is supported in @mode on all platforms. On
Unix platforms it will set `O_CLOEXEC` on the opened file descriptor. On
Windows platforms it will be converted to the
[`N` modifier](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/fopen-wfopen?view=msvc-170).
It is recommended to set `e` unconditionally, unless you know the returned
file should be shared between this process and a new fork.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">A `FILE*` if the file was successfully opened, or %NULL if
    an error occurred</doc>
        <type name="gpointer" c:type="FILE*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">a string describing the mode in which the file should be opened</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_size" c:identifier="g_format_size" version="2.30">
      <doc xml:space="preserve">Formats a size (for example the size of a file) into a human readable
string.  Sizes are rounded to the nearest size prefix (kB, MB, GB)
and are displayed rounded to the nearest tenth. E.g. the file size
3292528 bytes will be converted into the string "3.2 MB". The returned string
is UTF-8, and may use a non-breaking space to separate the number and units,
to ensure they aren&#x2019;t separated when line wrapped.

The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).

This string should be freed with g_free() when not needed any longer.

See g_format_size_full() for more options about how the size might be
formatted.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated formatted string containing
  a human readable file size</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">a size in bytes</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_size_for_display" c:identifier="g_format_size_for_display" version="2.16" deprecated="1" deprecated-version="2.30">
      <doc xml:space="preserve">Formats a size (for example the size of a file) into a human
readable string. Sizes are rounded to the nearest size prefix
(KB, MB, GB) and are displayed rounded to the nearest tenth.
E.g. the file size 3292528 bytes will be converted into the
string "3.1 MB".

The prefix units base is 1024 (i.e. 1 KB is 1024 bytes).

This string should be freed with g_free() when not needed any longer.</doc>
      <doc-deprecated xml:space="preserve">This function is broken due to its use of SI
    suffixes to denote IEC units. Use g_format_size() instead.</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated formatted string
  containing a human readable file size</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">a size in bytes</doc>
          <type name="gint64" c:type="goffset"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_size_full" c:identifier="g_format_size_full" version="2.30">
      <doc xml:space="preserve">Formats a size.

This function is similar to g_format_size() but allows for flags
that modify the output. See #GFormatSizeFlags.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated formatted string
  containing a human readable file size</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">a size in bytes</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">#GFormatSizeFlags to modify the output</doc>
          <type name="FormatSizeFlags" c:type="GFormatSizeFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="fprintf" c:identifier="g_fprintf" version="2.2" introspectable="0">
      <doc xml:space="preserve">An implementation of the standard `fprintf()` function which supports
positional parameters, as specified in the Single Unix Specification.

`glib/gprintf.h` must be explicitly included in order to use this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes printed</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="file" transfer-ownership="none">
          <doc xml:space="preserve">the stream to write to</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a standard `printf()` format string, but notice
  [string precision pitfalls](string-utils.html#string-precision-pitfalls)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the arguments to insert in the output</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="free" c:identifier="g_free">
      <doc xml:space="preserve">Frees the memory pointed to by @mem.

If you know the allocated size of @mem, calling g_free_sized() may be faster,
depending on the libc implementation in use.

Starting from GLib 2.78, this may happen automatically in case a GCC
compatible compiler is used with some optimization level and the allocated
size is known at compile time (see [documentation of
`__builtin_object_size()`](https://gcc.gnu.org/onlinedocs/gcc/Object-Size-Checking.html)
to understand its caveats).

If @mem is %NULL it simply returns, so there is no need to check @mem
against %NULL before calling this function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the memory to free</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="free_sized" c:identifier="g_free_sized" version="2.76">
      <doc xml:space="preserve">Frees the memory pointed to by @mem, assuming it is has the given @size.

If @mem is %NULL this is a no-op (and @size is ignored).

It is an error if @size doesn&#x2019;t match the size passed when @mem was
allocated. @size is passed to this function to allow optimizations in the
allocator. If you don&#x2019;t know the allocation size, use g_free() instead.

In case a GCC compatible compiler is used, this function may be used
automatically via g_free() if the allocated size is known at compile time,
since GLib 2.78.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the memory to free</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">size of @mem, in bytes</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="freopen" c:identifier="g_freopen" version="2.6">
      <doc xml:space="preserve">A wrapper for the POSIX freopen() function. The freopen() function
opens a file and associates it with an existing stream.

See your C library manual for more details about freopen().

Since GLib 2.86, the `e` option is supported in @mode on all platforms. See
the documentation for [func@GLib.fopen] for more details.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">A FILE* if the file was successfully opened, or %NULL if
    an error occurred.</doc>
        <type name="gpointer" c:type="FILE*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">a string describing the mode in which the file should be  opened</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="stream" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">an existing stream which will be reused, or %NULL</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
      </parameters>
    </function>
    <function name="fsync" c:identifier="g_fsync" version="2.64">
      <doc xml:space="preserve">A wrapper for the POSIX `fsync()` function. On Windows, `_commit()` will be
used. On macOS, `fcntl(F_FULLFSYNC)` will be used.
The `fsync()` function is used to synchronize a file's in-core
state with that of the disk.

This wrapper will handle retrying on `EINTR`.

See the C library manual for more details about fsync().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, or -1 if an error occurred.
The return value can be used exactly like the return value from fsync().</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_application_name" c:identifier="g_get_application_name" version="2.2">
      <doc xml:space="preserve">Gets a human-readable name for the application, as set by
g_set_application_name(). This name should be localized if
possible, and is intended for display to the user.  Contrast with
g_get_prgname(), which gets a non-localized name. If
g_set_application_name() has not been called, returns the result of
g_get_prgname() (which may be %NULL if g_set_prgname() has also not
been called).</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">human-readable application
  name. May return %NULL</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="get_charset" c:identifier="g_get_charset">
      <doc xml:space="preserve">Obtains the character set for the [current locale](running.html#locale);
you might use this character set as an argument to g_convert(), to convert
from the current locale's encoding to some other encoding. (Frequently
g_locale_to_utf8() and g_locale_from_utf8() are nice shortcuts, though.)

On Windows the character set returned by this function is the
so-called system default ANSI code-page. That is the character set
used by the "narrow" versions of C library and Win32 functions that
handle file names. It might be different from the character set
used by the C library's current locale.

On Linux, the character set is found by consulting nl_langinfo() if
available. If not, the environment variables `LC_ALL`, `LC_CTYPE`, `LANG`
and `CHARSET` are queried in order. nl_langinfo() returns the C locale if
no locale has been loaded by setlocale().

The return value is %TRUE if the locale's encoding is UTF-8, in that
case you can perhaps avoid calling g_convert().

The string returned in @charset is not allocated, and should not be
freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the returned charset is UTF-8</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="charset" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for character set
  name, or %NULL.</doc>
          <type name="utf8" c:type="const char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_codeset" c:identifier="g_get_codeset">
      <doc xml:space="preserve">Gets the character set for the current locale.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string containing the name
    of the character set. This string must be freed with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
    </function>
    <function name="get_console_charset" c:identifier="g_get_console_charset" version="2.62">
      <doc xml:space="preserve">Obtains the character set used by the console attached to the process,
which is suitable for printing output to the terminal.

Usually this matches the result returned by g_get_charset(), but in
environments where the locale's character set does not match the encoding
of the console this function tries to guess a more suitable value instead.

On Windows the character set returned by this function is the
output code page used by the console associated with the calling process.
If the codepage can't be determined (for example because there is no
console attached) UTF-8 is assumed.

The return value is %TRUE if the locale's encoding is UTF-8, in that
case you can perhaps avoid calling g_convert().

The string returned in @charset is not allocated, and should not be
freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the returned charset is UTF-8</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="charset" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for character set
  name, or %NULL.</doc>
          <type name="utf8" c:type="const char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_current_dir" c:identifier="g_get_current_dir">
      <doc xml:space="preserve">Gets the current directory.

The returned string should be freed when no longer needed.
The encoding of the returned string is system defined.
On Windows, it is always UTF-8.

Since GLib 2.40, this function will return the value of the "PWD"
environment variable if it is set and it happens to be the same as
the current directory.  This can make a difference in the case that
the current directory is the target of a symbolic link.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the current directory</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
    </function>
    <function name="get_current_time" c:identifier="g_get_current_time" deprecated="1" deprecated-version="2.62">
      <doc xml:space="preserve">Queries the system wall-clock time.

This is equivalent to the UNIX [`gettimeofday()`](man:gettimeofday(2))
function, but portable.

You may find [func@GLib.get_real_time] to be more convenient.</doc>
      <doc-deprecated xml:space="preserve">[struct@GLib.TimeVal] is not year-2038-safe. Use
   [func@GLib.get_real_time] instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">[struct@GLib.TimeVal] structure in which to store current time</doc>
          <type name="TimeVal" c:type="GTimeVal*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_environ" c:identifier="g_get_environ" version="2.28">
      <doc xml:space="preserve">Gets the list of environment variables for the current process.

The list is %NULL terminated and each item in the list is of the
form 'NAME=VALUE'.

This is equivalent to direct access to the 'environ' global variable,
except portable.

The return value is freshly allocated and it should be freed with
g_strfreev() when it is no longer needed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
    the list of environment variables</doc>
        <array c:type="gchar**">
          <type name="filename"/>
        </array>
      </return-value>
    </function>
    <function name="get_filename_charsets" c:identifier="g_get_filename_charsets" version="2.6">
      <doc xml:space="preserve">Determines the preferred character sets used for filenames.
The first character set from the @charsets is the filename encoding, the
subsequent character sets are used when trying to generate a displayable
representation of a filename, see g_filename_display_name().

On Unix, the character sets are determined by consulting the
environment variables `G_FILENAME_ENCODING` and `G_BROKEN_FILENAMES`.
On Windows, the character set used in the GLib API is always UTF-8
and said environment variables have no effect.

`G_FILENAME_ENCODING` may be set to a comma-separated list of
character set names. The special token `@locale` is taken to mean the
character set for the [current locale](running.html#locale).
If `G_FILENAME_ENCODING` is not set, but `G_BROKEN_FILENAMES` is,
the character set of the current locale is taken as the filename
encoding. If neither environment variable  is set, UTF-8 is taken
as the filename encoding, but the character set of the current locale
is also put in the list of encodings.

The returned @charsets belong to GLib and must not be freed.

Note that on Unix, regardless of the locale character set or
`G_FILENAME_ENCODING` value, the actual file names present
on a system might be in any random encoding or just gibberish.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the filename encoding is UTF-8.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename_charsets" direction="out" caller-allocates="0" transfer-ownership="none">
          <doc xml:space="preserve">
   return location for the %NULL-terminated list of encoding names</doc>
          <array c:type="const gchar***">
            <type name="utf8" c:type="gchar**"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="get_home_dir" c:identifier="g_get_home_dir">
      <doc xml:space="preserve">Gets the current user's home directory.

As with most UNIX tools, this function will return the value of the
`HOME` environment variable if it is set to an existing absolute path
name, falling back to the `passwd` file in the case that it is unset.

If the path given in `HOME` is non-absolute, does not exist, or is
not a directory, the result is undefined.

Before version 2.36 this function would ignore the `HOME` environment
variable, taking the value from the `passwd` database instead. This was
changed to increase the compatibility of GLib with other programs (and
the XDG basedir specification) and to increase testability of programs
based on GLib (by making it easier to run them from test frameworks).

If your program has a strong requirement for either the new or the
old behaviour (and if you don't wish to increase your GLib
dependency to ensure that the new behaviour is in effect) then you
should either directly check the `HOME` environment variable yourself
or unset it before calling any functions in GLib.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the current user's home directory</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="get_host_name" c:identifier="g_get_host_name" version="2.8">
      <doc xml:space="preserve">Return a name for the machine.

The returned name is not necessarily a fully-qualified domain name,
or even present in DNS or some other name service at all. It need
not even be unique on your local network or site, but usually it
is. Callers should not rely on the return value having any specific
properties like uniqueness for security purposes. Even if the name
of the machine is changed while an application is running, the
return value from this function does not change. The returned
string is owned by GLib and should not be modified or freed. If no
name can be determined, a default fixed string "localhost" is
returned.

The encoding of the returned string is UTF-8.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the host name of the machine.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="get_language_names" c:identifier="g_get_language_names" version="2.6">
      <doc xml:space="preserve">Computes a list of applicable locale names, which can be used to
e.g. construct locale-dependent filenames or search paths. The returned
list is sorted from most desirable to least desirable and always contains
the default locale "C".

For example, if LANGUAGE=de:en_US, then the returned list is
"de", "en_US", "en", "C".

This function consults the environment variables `LANGUAGE`, `LC_ALL`,
`LC_MESSAGES` and `LANG` to find the list of locales specified by the
user.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a %NULL-terminated array of strings owned by GLib
   that must not be modified or freed.</doc>
        <array c:type="const gchar* const*">
          <type name="utf8"/>
        </array>
      </return-value>
    </function>
    <function name="get_language_names_with_category" c:identifier="g_get_language_names_with_category" version="2.58">
      <doc xml:space="preserve">Computes a list of applicable locale names with a locale category name,
which can be used to construct the fallback locale-dependent filenames
or search paths. The returned list is sorted from most desirable to
least desirable and always contains the default locale "C".

This function consults the environment variables `LANGUAGE`, `LC_ALL`,
@category_name, and `LANG` to find the list of locales specified by the
user.

g_get_language_names() returns g_get_language_names_with_category("LC_MESSAGES").</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a %NULL-terminated array of strings owned by
   the thread g_get_language_names_with_category was called from.
   It must not be modified or freed. It must be copied if planned to be used in another thread.</doc>
        <array c:type="const gchar* const*">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="category_name" transfer-ownership="none">
          <doc xml:space="preserve">a locale category name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_locale_variants" c:identifier="g_get_locale_variants" version="2.28">
      <doc xml:space="preserve">Returns a list of derived variants of @locale, which can be used to
e.g. construct locale-dependent filenames or search paths. The returned
list is sorted from most desirable to least desirable.
This function handles territory, charset and extra locale modifiers. See
[`setlocale(3)`](man:setlocale) for information about locales and their format.

@locale itself is guaranteed to be returned in the output.

For example, if @locale is `fr_BE`, then the returned list
is `fr_BE`, `fr`. If @locale is `en_GB.UTF-8@euro`, then the returned list
is `en_GB.UTF-8@euro`, `en_GB.UTF-8`, `en_GB@euro`, `en_GB`, `en.UTF-8@euro`,
`en.UTF-8`, `en@euro`, `en`.

If you need the list of variants for the current locale,
use g_get_language_names().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly
  allocated array of newly allocated strings with the locale variants. Free with
  g_strfreev().</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="locale" transfer-ownership="none">
          <doc xml:space="preserve">a locale identifier</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_monotonic_time" c:identifier="g_get_monotonic_time" version="2.28">
      <doc xml:space="preserve">Queries the system monotonic time.

The monotonic clock will always increase and doesn&#x2019;t suffer
discontinuities when the user (or NTP) changes the system time.  It
may or may not continue to tick during times where the machine is
suspended.

We try to use the clock that corresponds as closely as possible to
the passage of time as measured by system calls such as
[`poll()`](man:poll(2)) but it
may not always be possible to do this.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the monotonic time, in microseconds</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
    </function>
    <function name="get_num_processors" c:identifier="g_get_num_processors" version="2.36">
      <doc xml:space="preserve">Determine the approximate number of threads that the system will
schedule simultaneously for this process.  This is intended to be
used as a parameter to g_thread_pool_new() for CPU bound tasks and
similar cases.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Number of schedulable threads, always greater than 0</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
    </function>
    <function name="get_os_info" c:identifier="g_get_os_info" version="2.64">
      <doc xml:space="preserve">Get information about the operating system.

On Linux this comes from the `/etc/os-release` file. On other systems, it may
come from a variety of sources. You can either use the standard key names
like %G_OS_INFO_KEY_NAME or pass any UTF-8 string key name. For example,
`/etc/os-release` provides a number of other less commonly used values that may
be useful. No key is guaranteed to be provided, so the caller should always
check if the result is %NULL.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">The associated value for the requested key or %NULL if
  this information is not provided.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="key_name" transfer-ownership="none">
          <doc xml:space="preserve">a key for the OS info being requested, for example %G_OS_INFO_KEY_NAME.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_prgname" c:identifier="g_get_prgname">
      <doc xml:space="preserve">Gets the name of the program. This name should not be localized,
in contrast to g_get_application_name().

If you are using #GApplication the program name is set in
g_application_run(). In case of GDK or GTK it is set in
gdk_init(), which is called by gtk_init() and the
#GtkApplication::startup handler. The program name is found by
taking the last component of @argv[0].</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the name of the program,
  or %NULL if it has not been set yet. The returned string belongs
  to GLib and must not be modified or freed.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="get_real_name" c:identifier="g_get_real_name">
      <doc xml:space="preserve">Gets the real name of the user. This usually comes from the user's
entry in the `passwd` file. The encoding of the returned string is
system-defined. (On Windows, it is, however, always UTF-8.) If the
real user name cannot be determined, the string "Unknown" is
returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the user's real name.</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="get_real_time" c:identifier="g_get_real_time" version="2.28">
      <doc xml:space="preserve">Queries the system wall-clock time.

This is equivalent to the UNIX [`gettimeofday()`](man:gettimeofday(2))
function, but portable.

You should only use this call if you are actually interested in the real
wall-clock time. [func@GLib.get_monotonic_time] is probably more useful for
measuring intervals.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of microseconds since
  [January 1, 1970 UTC](https://en.wikipedia.org/wiki/Unix_time)</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
    </function>
    <function name="get_system_config_dirs" c:identifier="g_get_system_config_dirs" version="2.6">
      <doc xml:space="preserve">Returns an ordered list of base directories in which to access
system-wide configuration information.

On UNIX platforms this is determined using the mechanisms described
in the
[XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
In this case the list of directories retrieved will be `XDG_CONFIG_DIRS`.

On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_DIRS` is defined.
If `XDG_CONFIG_DIRS` is undefined, the directory that contains application
data for all users is used instead. A typical path is
`C:\Documents and Settings\All Users\Application Data`.
This folder is used for application data
that is not user specific. For example, an application can store
a spell-check dictionary, a database of clip art, or a log file in the
FOLDERID_ProgramData folder. This information will not roam and is available
to anyone using the computer.

The return value is cached and modifying it at runtime is not supported, as
it&#x2019;s not thread-safe to modify environment variables at runtime.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">
    a %NULL-terminated array of strings owned by GLib that must not be
    modified or freed.</doc>
        <array c:type="const gchar* const*">
          <type name="filename"/>
        </array>
      </return-value>
    </function>
    <function name="get_system_data_dirs" c:identifier="g_get_system_data_dirs" version="2.6">
      <doc xml:space="preserve">Returns an ordered list of base directories in which to access
system-wide application data.

On UNIX platforms this is determined using the mechanisms described
in the
[XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec)
In this case the list of directories retrieved will be `XDG_DATA_DIRS`.

On Windows it follows XDG Base Directory Specification if `XDG_DATA_DIRS` is defined.
If `XDG_DATA_DIRS` is undefined,
the first elements in the list are the Application Data
and Documents folders for All Users. (These can be determined only
on Windows 2000 or later and are not present in the list on other
Windows versions.) See documentation for FOLDERID_ProgramData and
FOLDERID_PublicDocuments.

Then follows the "share" subfolder in the installation folder for
the package containing the DLL that calls this function, if it can
be determined.

Finally the list contains the "share" subfolder in the installation
folder for GLib, and in the installation folder for the package the
application's .exe file belongs to.

The installation folders above are determined by looking up the
folder where the module (DLL or EXE) in question is located. If the
folder's name is "bin", its parent is used, otherwise the folder
itself.

Note that on Windows the returned list can vary depending on where
this function is called.

The return value is cached and modifying it at runtime is not supported, as
it&#x2019;s not thread-safe to modify environment variables at runtime.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">
    a %NULL-terminated array of strings owned by GLib that must not be
    modified or freed.</doc>
        <array c:type="const gchar* const*">
          <type name="filename"/>
        </array>
      </return-value>
    </function>
    <function name="get_tmp_dir" c:identifier="g_get_tmp_dir">
      <doc xml:space="preserve">Gets the directory to use for temporary files.

On UNIX, this is taken from the `TMPDIR` environment variable.
If the variable is not set, `P_tmpdir` is
used, as defined by the system C library. Failing that, a
hard-coded default of "/tmp" is returned.

On Windows, the `TEMP` environment variable is used, with the
root directory of the Windows installation (eg: "C:\") used
as a default.

The encoding of the returned string is system-defined. On Windows,
it is always UTF-8. The return value is never %NULL or the empty
string.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the directory to use for temporary files.</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="get_user_cache_dir" c:identifier="g_get_user_cache_dir" version="2.6">
      <doc xml:space="preserve">Returns a base directory in which to store non-essential, cached
data specific to particular user.

On UNIX platforms this is determined using the mechanisms described
in the
[XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
In this case the directory retrieved will be `XDG_CACHE_HOME`.

On Windows it follows XDG Base Directory Specification if `XDG_CACHE_HOME` is defined.
If `XDG_CACHE_HOME` is undefined, the directory that serves as a common
repository for temporary Internet files is used instead. A typical path is
`C:\Documents and Settings\username\Local Settings\Temporary Internet Files`.
See the [documentation for `FOLDERID_InternetCache`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).

The return value is cached and modifying it at runtime is not supported, as
it&#x2019;s not thread-safe to modify environment variables at runtime.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a string owned by GLib that
  must not be modified or freed.</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="get_user_config_dir" c:identifier="g_get_user_config_dir" version="2.6">
      <doc xml:space="preserve">Returns a base directory in which to store user-specific application
configuration information such as user preferences and settings.

On UNIX platforms this is determined using the mechanisms described
in the
[XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
In this case the directory retrieved will be `XDG_CONFIG_HOME`.

On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_HOME` is defined.
If `XDG_CONFIG_HOME` is undefined, the folder to use for local (as opposed
to roaming) application data is used instead. See the
[documentation for `FOLDERID_LocalAppData`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
Note that in this case on Windows it will be  the same
as what g_get_user_data_dir() returns.

The return value is cached and modifying it at runtime is not supported, as
it&#x2019;s not thread-safe to modify environment variables at runtime.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a string owned by GLib that
  must not be modified or freed.</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="get_user_data_dir" c:identifier="g_get_user_data_dir" version="2.6">
      <doc xml:space="preserve">Returns a base directory in which to access application data such
as icons that is customized for a particular user.

On UNIX platforms this is determined using the mechanisms described
in the
[XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
In this case the directory retrieved will be `XDG_DATA_HOME`.

On Windows it follows XDG Base Directory Specification if `XDG_DATA_HOME`
is defined. If `XDG_DATA_HOME` is undefined, the folder to use for local (as
opposed to roaming) application data is used instead. See the
[documentation for `FOLDERID_LocalAppData`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
Note that in this case on Windows it will be the same
as what g_get_user_config_dir() returns.

The return value is cached and modifying it at runtime is not supported, as
it&#x2019;s not thread-safe to modify environment variables at runtime.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a string owned by GLib that must
  not be modified or freed.</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="get_user_name" c:identifier="g_get_user_name">
      <doc xml:space="preserve">Gets the user name of the current user. The encoding of the returned
string is system-defined. On UNIX, it might be the preferred file name
encoding, or something else, and there is no guarantee that it is even
consistent on a machine. On Windows, it is always UTF-8.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the user name of the current user.</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="get_user_runtime_dir" c:identifier="g_get_user_runtime_dir" version="2.28">
      <doc xml:space="preserve">Returns a directory that is unique to the current user on the local
system.

This is determined using the mechanisms described
in the
[XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
This is the directory
specified in the `XDG_RUNTIME_DIR` environment variable.
In the case that this variable is not set, we return the value of
g_get_user_cache_dir(), after verifying that it exists.

The return value is cached and modifying it at runtime is not supported, as
it&#x2019;s not thread-safe to modify environment variables at runtime.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a string owned by GLib that must not be
    modified or freed.</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="get_user_special_dir" c:identifier="g_get_user_special_dir" version="2.14">
      <doc xml:space="preserve">Returns the full path of a special directory using its logical id.

On UNIX this is done using the XDG special user directories.
For compatibility with existing practise, %G_USER_DIRECTORY_DESKTOP
falls back to `$HOME/Desktop` when XDG special user directories have
not been set up.

Depending on the platform, the user might be able to change the path
of the special directory without requiring the session to restart; GLib
will not reflect any change once the special directories are loaded.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the path to the specified special
  directory, or %NULL if the logical id was not found. The returned string is
  owned by GLib and should not be modified or freed.</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="directory" transfer-ownership="none">
          <doc xml:space="preserve">the logical id of special directory</doc>
          <type name="UserDirectory" c:type="GUserDirectory"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_user_state_dir" c:identifier="g_get_user_state_dir" version="2.72">
      <doc xml:space="preserve">Returns a base directory in which to store state files specific to
particular user.

On UNIX platforms this is determined using the mechanisms described
in the
[XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
In this case the directory retrieved will be `XDG_STATE_HOME`.

On Windows it follows XDG Base Directory Specification if `XDG_STATE_HOME` is defined.
If `XDG_STATE_HOME` is undefined, the folder to use for local (as opposed
to roaming) application data is used instead. See the
[documentation for `FOLDERID_LocalAppData`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
Note that in this case on Windows it will be the same
as what g_get_user_data_dir() returns.

The return value is cached and modifying it at runtime is not supported, as
it&#x2019;s not thread-safe to modify environment variables at runtime.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a string owned by GLib that
  must not be modified or freed.</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="getenv" c:identifier="g_getenv">
      <doc xml:space="preserve">Returns the value of an environment variable.

On UNIX, the name and value are byte strings which might or might not
be in some consistent character set and encoding. On Windows, they are
in UTF-8.
On Windows, in case the environment variable's value contains
references to other environment variables, they are expanded.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the value of the environment variable, or %NULL if
    the environment variable is not found. The returned string
    may be overwritten by the next call to g_getenv(), g_setenv()
    or g_unsetenv().</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="variable" transfer-ownership="none">
          <doc xml:space="preserve">the environment variable to get</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_add" c:identifier="g_hash_table_add" moved-to="HashTable.add" version="2.32">
      <doc xml:space="preserve">This is a convenience function for using a #GHashTable as a set.  It
is equivalent to calling g_hash_table_replace() with @key as both the
key and the value.

In particular, this means that if @key already exists in the hash table, then
the old copy of @key in the hash table is freed and @key replaces it in the
table.

When a hash table only ever contains keys that have themselves as the
corresponding value it is able to be stored more efficiently.  See
the discussion in the section description.

Starting from GLib 2.40, this function returns a boolean value to
indicate whether the newly added value was already in the hash table
or not.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the key did not exist yet</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="full" nullable="1" allow-none="1">
          <doc xml:space="preserve">a key to insert</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_contains" c:identifier="g_hash_table_contains" moved-to="HashTable.contains" version="2.32">
      <doc xml:space="preserve">Checks if @key is in @hash_table.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @key is in @hash_table, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a key to check</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_destroy" c:identifier="g_hash_table_destroy" moved-to="HashTable.destroy">
      <doc xml:space="preserve">Destroys all keys and values in the #GHashTable and decrements its
reference count by 1. If keys and/or values are dynamically allocated,
you should either free them first or create the #GHashTable with destroy
notifiers using g_hash_table_new_full(). In the latter case the destroy
functions you supplied will be called on all keys and values during the
destruction phase.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_find" c:identifier="g_hash_table_find" moved-to="HashTable.find" version="2.4">
      <doc xml:space="preserve">Calls the given function for key/value pairs in the #GHashTable
until @predicate returns %TRUE. The function is passed the key
and value of each pair, and the given @user_data parameter. The
hash table may not be modified while iterating over it (you can't
add/remove items).

Note, that hash tables are really only optimized for forward
lookups, i.e. g_hash_table_lookup(). So code that frequently issues
g_hash_table_find() or g_hash_table_foreach() (e.g. in the order of
once per every entry in a hash table) should probably be reworked
to use additional or different data structures for reverse lookups
(keep in mind that an O(n) find/foreach operation issued for all n
values in a hash table ends up needing O(n*n) operations).</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">The value of the first key/value pair is returned,
    for which @predicate evaluates to %TRUE. If no pair with the
    requested property is found, %NULL is returned.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="predicate" transfer-ownership="none" scope="call" closure="2">
          <doc xml:space="preserve">function to test the key/value pairs for a certain property</doc>
          <type name="HRFunc" c:type="GHRFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_foreach" c:identifier="g_hash_table_foreach" moved-to="HashTable.foreach">
      <doc xml:space="preserve">Calls the given function for each of the key/value pairs in the
#GHashTable.  The function is passed the key and value of each
pair, and the given @user_data parameter.  The hash table may not
be modified while iterating over it (you can't add/remove
items). To remove all items matching a predicate, use
g_hash_table_foreach_remove().

The order in which g_hash_table_foreach() iterates over the keys/values in
the hash table is not defined.

See g_hash_table_find() for performance caveats for linear
order searches in contrast to g_hash_table_lookup().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call" closure="2">
          <doc xml:space="preserve">the function to call for each key/value pair</doc>
          <type name="HFunc" c:type="GHFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_foreach_remove" c:identifier="g_hash_table_foreach_remove" moved-to="HashTable.foreach_remove">
      <doc xml:space="preserve">Calls the given function for each key/value pair in the
#GHashTable. If the function returns %TRUE, then the key/value
pair is removed from the #GHashTable. If you supplied key or
value destroy functions when creating the #GHashTable, they are
used to free the memory allocated for the removed keys and values.

See #GHashTableIter for an alternative way to loop over the
key/value pairs in the hash table.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of key/value pairs removed</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call" closure="2">
          <doc xml:space="preserve">the function to call for each key/value pair</doc>
          <type name="HRFunc" c:type="GHRFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_foreach_steal" c:identifier="g_hash_table_foreach_steal" moved-to="HashTable.foreach_steal">
      <doc xml:space="preserve">Calls the given function for each key/value pair in the
#GHashTable. If the function returns %TRUE, then the key/value
pair is removed from the #GHashTable, but no key or value
destroy functions are called.

See #GHashTableIter for an alternative way to loop over the
key/value pairs in the hash table.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of key/value pairs removed.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call" closure="2">
          <doc xml:space="preserve">the function to call for each key/value pair</doc>
          <type name="HRFunc" c:type="GHRFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="hash_table_freeze" c:identifier="g_hash_table_freeze" introspectable="0">
      <doc xml:space="preserve">This function is deprecated and will be removed in the next major
release of GLib. It does nothing.</doc>
      <parameters>
        <parameter name="hash_table">
          <doc xml:space="preserve">a #GHashTable</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="hash_table_get_keys_as_ptr_array" c:identifier="g_hash_table_get_keys_as_ptr_array" moved-to="HashTable.get_keys_as_ptr_array" version="2.76" introspectable="0">
      <doc xml:space="preserve">Retrieves every key inside @hash_table, as a #GPtrArray.
The returned data is valid until changes to the hash release those keys.

This iterates over every entry in the hash table to build its return value.
To iterate over the entries in a #GHashTable more efficiently, use a
#GHashTableIter.

You should always unref the returned array with g_ptr_array_unref().</doc>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">a #GPtrArray containing each key from
the table. Unref with g_ptr_array_unref() when done.</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_get_values_as_ptr_array" c:identifier="g_hash_table_get_values_as_ptr_array" moved-to="HashTable.get_values_as_ptr_array" version="2.76" introspectable="0">
      <doc xml:space="preserve">Retrieves every value inside @hash_table, as a #GPtrArray.
The returned data is valid until changes to the hash release those values.

This iterates over every entry in the hash table to build its return value.
To iterate over the entries in a #GHashTable more efficiently, use a
#GHashTableIter.

You should always unref the returned array with g_ptr_array_unref().</doc>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">a #GPtrArray containing each value from
the table. Unref with g_ptr_array_unref() when done.</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_insert" c:identifier="g_hash_table_insert" moved-to="HashTable.insert">
      <doc xml:space="preserve">Inserts a new key and value into a #GHashTable.

If the key already exists in the #GHashTable its current
value is replaced with the new value. If you supplied a
@value_destroy_func when creating the #GHashTable, the old
value is freed using that function. If you supplied a
@key_destroy_func when creating the #GHashTable, the passed
key is freed using that function.

Starting from GLib 2.40, this function returns a boolean value to
indicate whether the newly added value was already in the hash table
or not.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the key did not exist yet</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a key to insert</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the value to associate with the key</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_lookup" c:identifier="g_hash_table_lookup" moved-to="HashTable.lookup">
      <doc xml:space="preserve">Looks up a key in a #GHashTable. Note that this function cannot
distinguish between a key that is not present and one which is present
and has the value %NULL. If you need this distinction, use
g_hash_table_lookup_extended().</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the associated value, or %NULL if the key is not found</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the key to look up</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_lookup_extended" c:identifier="g_hash_table_lookup_extended" moved-to="HashTable.lookup_extended">
      <doc xml:space="preserve">Looks up a key in the #GHashTable, returning the original key and the
associated value and a #gboolean which is %TRUE if the key was found. This
is useful if you need to free the memory allocated for the original key,
for example before calling g_hash_table_remove().

You can actually pass %NULL for @lookup_key to test
whether the %NULL key exists, provided the hash and equal functions
of @hash_table are %NULL-safe.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the key was found in the #GHashTable</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="lookup_key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the key to look up</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="orig_key" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for the original key</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
        <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for the value associated
with the key</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_new_similar" c:identifier="g_hash_table_new_similar" moved-to="HashTable.new_similar" version="2.72">
      <doc xml:space="preserve">Creates a new #GHashTable like g_hash_table_new_full() with a reference
count of 1.

It inherits the hash function, the key equal function, the key destroy function,
as well as the value destroy function, from @other_hash_table.

The returned hash table will be empty; it will not contain the keys
or values from @other_hash_table.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GHashTable</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="other_hash_table" transfer-ownership="none">
          <doc xml:space="preserve">Another #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_ref" c:identifier="g_hash_table_ref" moved-to="HashTable.ref" version="2.10">
      <doc xml:space="preserve">Atomically increments the reference count of @hash_table by one.
This function is MT-safe and may be called from any thread.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the passed in #GHashTable</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a valid #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_remove" c:identifier="g_hash_table_remove" moved-to="HashTable.remove">
      <doc xml:space="preserve">Removes a key and its associated value from a #GHashTable.

If the #GHashTable was created using g_hash_table_new_full(), the
key and value are freed using the supplied destroy functions, otherwise
you have to make sure that any dynamically allocated values are freed
yourself.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the key was found and removed from the #GHashTable</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the key to remove</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_remove_all" c:identifier="g_hash_table_remove_all" moved-to="HashTable.remove_all" version="2.12">
      <doc xml:space="preserve">Removes all keys and their associated values from a #GHashTable.

If the #GHashTable was created using g_hash_table_new_full(),
the keys and values are freed using the supplied destroy functions,
otherwise you have to make sure that any dynamically allocated
values are freed yourself.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_replace" c:identifier="g_hash_table_replace" moved-to="HashTable.replace">
      <doc xml:space="preserve">Inserts a new key and value into a #GHashTable similar to
g_hash_table_insert(). The difference is that if the key
already exists in the #GHashTable, it gets replaced by the
new key. If you supplied a @value_destroy_func when creating
the #GHashTable, the old value is freed using that function.
If you supplied a @key_destroy_func when creating the
#GHashTable, the old key is freed using that function.

Starting from GLib 2.40, this function returns a boolean value to
indicate whether the newly added value was already in the hash table
or not.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the key did not exist yet</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a key to insert</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the value to associate with the key</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_size" c:identifier="g_hash_table_size" moved-to="HashTable.size">
      <doc xml:space="preserve">Returns the number of elements contained in the #GHashTable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of key/value pairs in the #GHashTable.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_steal" c:identifier="g_hash_table_steal" moved-to="HashTable.steal">
      <doc xml:space="preserve">Removes a key and its associated value from a #GHashTable without
calling the key and value destroy functions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the key was found and removed from the #GHashTable</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the key to remove</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_steal_all" c:identifier="g_hash_table_steal_all" moved-to="HashTable.steal_all" version="2.12">
      <doc xml:space="preserve">Removes all keys and their associated values from a #GHashTable
without calling the key and value destroy functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_steal_all_keys" c:identifier="g_hash_table_steal_all_keys" moved-to="HashTable.steal_all_keys" version="2.76" introspectable="0">
      <doc xml:space="preserve">Removes all keys and their associated values from a #GHashTable
without calling the key destroy functions, returning the keys
as a #GPtrArray with the free func set to the @hash_table key
destroy function.</doc>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">a #GPtrArray containing each key of
the table. Unref with g_ptr_array_unref() when done.</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_steal_all_values" c:identifier="g_hash_table_steal_all_values" moved-to="HashTable.steal_all_values" version="2.76" introspectable="0">
      <doc xml:space="preserve">Removes all keys and their associated values from a #GHashTable
without calling the value destroy functions, returning the values
as a #GPtrArray with the free func set to the @hash_table value
destroy function.</doc>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">a #GPtrArray containing each value of
the table. Unref with g_ptr_array_unref() when done.</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="hash_table_steal_extended" c:identifier="g_hash_table_steal_extended" moved-to="HashTable.steal_extended" version="2.58">
      <doc xml:space="preserve">Looks up a key in the #GHashTable, stealing the original key and the
associated value and returning %TRUE if the key was found. If the key was
not found, %FALSE is returned.

If found, the stolen key and value are removed from the hash table without
calling the key and value destroy functions, and ownership is transferred to
the caller of this method, as with g_hash_table_steal(). That is the case
regardless whether @stolen_key or @stolen_value output parameters are
requested.

You can pass %NULL for @lookup_key, provided the hash and equal functions
of @hash_table are %NULL-safe.

The dictionary implementation optimizes for having all values identical to
their keys, for example by using g_hash_table_add(). Before 2.82, when
stealing both the key and the value from such a dictionary, the value was
%NULL. Since 2.82, the returned value and key will be the same.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the key was found in the #GHashTable</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="lookup_key" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the key to look up</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="stolen_key" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for the
   original key</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
        <parameter name="stolen_value" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">return location
   for the value associated with the key</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="hash_table_thaw" c:identifier="g_hash_table_thaw" introspectable="0">
      <doc xml:space="preserve">This function is deprecated and will be removed in the next major
release of GLib. It does nothing.</doc>
      <parameters>
        <parameter name="hash_table">
          <doc xml:space="preserve">a #GHashTable</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="hash_table_unref" c:identifier="g_hash_table_unref" moved-to="HashTable.unref" version="2.10">
      <doc xml:space="preserve">Atomically decrements the reference count of @hash_table by one.
If the reference count drops to 0, all keys and values will be
destroyed, and all memory allocated by the hash table is released.
This function is MT-safe and may be called from any thread.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hash_table" transfer-ownership="full">
          <doc xml:space="preserve">a valid #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function-macro name="hook_append" c:identifier="g_hook_append" introspectable="0">
      <doc xml:space="preserve">Appends a #GHook onto the end of a #GHookList.</doc>
      <parameters>
        <parameter name="hook_list">
          <doc xml:space="preserve">a #GHookList</doc>
        </parameter>
        <parameter name="hook">
          <doc xml:space="preserve">the #GHook to add to the end of @hook_list</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="hook_destroy" c:identifier="g_hook_destroy" moved-to="Hook.destroy">
      <doc xml:space="preserve">Destroys a #GHook, given its ID.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the #GHook was found in the #GHookList and destroyed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hook_list" transfer-ownership="none">
          <doc xml:space="preserve">a #GHookList</doc>
          <type name="HookList" c:type="GHookList*"/>
        </parameter>
        <parameter name="hook_id" transfer-ownership="none">
          <doc xml:space="preserve">a hook ID</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="hook_destroy_link" c:identifier="g_hook_destroy_link" moved-to="Hook.destroy_link">
      <doc xml:space="preserve">Removes one #GHook from a #GHookList, marking it
inactive and calling g_hook_unref() on it.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hook_list" transfer-ownership="none">
          <doc xml:space="preserve">a #GHookList</doc>
          <type name="HookList" c:type="GHookList*"/>
        </parameter>
        <parameter name="hook" transfer-ownership="none">
          <doc xml:space="preserve">the #GHook to remove</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hook_free" c:identifier="g_hook_free" moved-to="Hook.free">
      <doc xml:space="preserve">Calls the #GHookList @finalize_hook function if it exists,
and frees the memory allocated for the #GHook.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hook_list" transfer-ownership="none">
          <doc xml:space="preserve">a #GHookList</doc>
          <type name="HookList" c:type="GHookList*"/>
        </parameter>
        <parameter name="hook" transfer-ownership="none">
          <doc xml:space="preserve">the #GHook to free</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hook_insert_before" c:identifier="g_hook_insert_before" moved-to="Hook.insert_before">
      <doc xml:space="preserve">Inserts a #GHook into a #GHookList, before a given #GHook.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hook_list" transfer-ownership="none">
          <doc xml:space="preserve">a #GHookList</doc>
          <type name="HookList" c:type="GHookList*"/>
        </parameter>
        <parameter name="sibling" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the #GHook to insert the new #GHook before</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
        <parameter name="hook" transfer-ownership="none">
          <doc xml:space="preserve">the #GHook to insert</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hook_insert_sorted" c:identifier="g_hook_insert_sorted" moved-to="Hook.insert_sorted">
      <doc xml:space="preserve">Inserts a #GHook into a #GHookList, sorted by the given function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hook_list" transfer-ownership="none">
          <doc xml:space="preserve">a #GHookList</doc>
          <type name="HookList" c:type="GHookList*"/>
        </parameter>
        <parameter name="hook" transfer-ownership="none">
          <doc xml:space="preserve">the #GHook to insert</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve">the comparison function used to sort the #GHook elements</doc>
          <type name="HookCompareFunc" c:type="GHookCompareFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="hook_prepend" c:identifier="g_hook_prepend" moved-to="Hook.prepend">
      <doc xml:space="preserve">Prepends a #GHook on the start of a #GHookList.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hook_list" transfer-ownership="none">
          <doc xml:space="preserve">a #GHookList</doc>
          <type name="HookList" c:type="GHookList*"/>
        </parameter>
        <parameter name="hook" transfer-ownership="none">
          <doc xml:space="preserve">the #GHook to add to the start of @hook_list</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hook_unref" c:identifier="g_hook_unref" moved-to="Hook.unref">
      <doc xml:space="preserve">Decrements the reference count of a #GHook.
If the reference count falls to 0, the #GHook is removed
from the #GHookList and g_hook_free() is called to free it.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="hook_list" transfer-ownership="none">
          <doc xml:space="preserve">a #GHookList</doc>
          <type name="HookList" c:type="GHookList*"/>
        </parameter>
        <parameter name="hook" transfer-ownership="none">
          <doc xml:space="preserve">the #GHook to unref</doc>
          <type name="Hook" c:type="GHook*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hostname_is_ascii_encoded" c:identifier="g_hostname_is_ascii_encoded" version="2.22">
      <doc xml:space="preserve">Tests if @hostname contains segments with an ASCII-compatible
encoding of an Internationalized Domain Name. If this returns
%TRUE, you should decode the hostname with g_hostname_to_unicode()
before displaying it to the user.

Note that a hostname might contain a mix of encoded and unencoded
segments, and so it is possible for g_hostname_is_non_ascii() and
g_hostname_is_ascii_encoded() to both return %TRUE for a name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @hostname contains any ASCII-encoded
segments.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hostname" transfer-ownership="none">
          <doc xml:space="preserve">a hostname</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hostname_is_ip_address" c:identifier="g_hostname_is_ip_address" version="2.22">
      <doc xml:space="preserve">Tests if @hostname is the string form of an IPv4 or IPv6 address.
(Eg, "192.168.0.1".)

Since 2.66, IPv6 addresses with a zone-id are accepted (RFC6874).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @hostname is an IP address</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hostname" transfer-ownership="none">
          <doc xml:space="preserve">a hostname (or IP address in string form)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hostname_is_non_ascii" c:identifier="g_hostname_is_non_ascii" version="2.22">
      <doc xml:space="preserve">Tests if @hostname contains Unicode characters. If this returns
%TRUE, you need to encode the hostname with g_hostname_to_ascii()
before using it in non-IDN-aware contexts.

Note that a hostname might contain a mix of encoded and unencoded
segments, and so it is possible for g_hostname_is_non_ascii() and
g_hostname_is_ascii_encoded() to both return %TRUE for a name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @hostname contains any non-ASCII characters</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="hostname" transfer-ownership="none">
          <doc xml:space="preserve">a hostname</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hostname_to_ascii" c:identifier="g_hostname_to_ascii" version="2.22">
      <doc xml:space="preserve">Converts @hostname to its canonical ASCII form; an ASCII-only
string containing no uppercase letters and not ending with a
trailing dot.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">an ASCII hostname, which must be freed,
   or %NULL if @hostname is in some way invalid.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="hostname" transfer-ownership="none">
          <doc xml:space="preserve">a valid UTF-8 or ASCII hostname</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="hostname_to_unicode" c:identifier="g_hostname_to_unicode" version="2.22">
      <doc xml:space="preserve">Converts @hostname to its canonical presentation form; a UTF-8
string in Unicode normalization form C, containing no uppercase
letters, no forbidden characters, and no ASCII-encoded segments,
and not ending with a trailing dot.

Of course if @hostname is not an internationalized hostname, then
the canonical presentation form will be entirely ASCII.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a UTF-8 hostname, which must be freed,
   or %NULL if @hostname is in some way invalid.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="hostname" transfer-ownership="none">
          <doc xml:space="preserve">a valid UTF-8 or ASCII hostname</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="htonl" c:identifier="g_htonl" introspectable="0">
      <doc xml:space="preserve">Converts a 32-bit integer value from host to network byte order.</doc>
      <parameters>
        <parameter name="val">
          <doc xml:space="preserve">a 32-bit integer value in host byte order</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="htons" c:identifier="g_htons" introspectable="0">
      <doc xml:space="preserve">Converts a 16-bit integer value from host to network byte order.</doc>
      <parameters>
        <parameter name="val">
          <doc xml:space="preserve">a 16-bit integer value in host byte order</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="iconv" c:identifier="g_iconv" introspectable="0">
      <doc xml:space="preserve">Same as the standard UNIX routine iconv(), but
may be implemented via libiconv on UNIX flavors that lack
a native implementation.

GLib provides g_convert() and g_locale_to_utf8() which are likely
more convenient than the raw iconv wrappers.

Note that the behaviour of iconv() for characters which are valid in the
input character set, but which have no representation in the output character
set, is implementation defined. This function may return success (with a
positive number of non-reversible conversions as replacement characters were
used), or it may return -1 and set an error such as %EILSEQ, in such a
situation.

See [`iconv(3posix)`](man:iconv(3posix)) and [`iconv(3)`](man:iconv(3)) for more details about behavior when an
error occurs.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">count of non-reversible conversions, or -1 on error</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="converter" transfer-ownership="none">
          <doc xml:space="preserve">conversion descriptor from g_iconv_open()</doc>
          <type name="IConv" c:type="GIConv"/>
        </parameter>
        <parameter name="inbuf" transfer-ownership="none">
          <doc xml:space="preserve">bytes to convert</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="inbytes_left" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">inout parameter, bytes remaining to convert in @inbuf</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="outbuf" transfer-ownership="none">
          <doc xml:space="preserve">converted output bytes</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="outbytes_left" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">inout parameter, bytes available to fill in @outbuf</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="iconv_open" c:identifier="g_iconv_open" moved-to="IConv.open" introspectable="0">
      <doc xml:space="preserve">Same as the standard UNIX routine iconv_open(), but
may be implemented via libiconv on UNIX flavors that lack
a native implementation.

GLib provides g_convert() and g_locale_to_utf8() which are likely
more convenient than the raw iconv wrappers.</doc>
      <return-value>
        <doc xml:space="preserve">a "conversion descriptor", or (GIConv)-1 if
 opening the converter failed.</doc>
        <type name="IConv" c:type="GIConv"/>
      </return-value>
      <parameters>
        <parameter name="to_codeset" transfer-ownership="none">
          <doc xml:space="preserve">destination codeset</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="from_codeset" transfer-ownership="none">
          <doc xml:space="preserve">source codeset</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="idle_add" c:identifier="g_idle_add" shadowed-by="idle_add_full" introspectable="0">
      <doc xml:space="preserve">Adds a function to be called whenever there are no higher priority
events pending to the default main loop.

The function is given the
default idle priority, [const@GLib.PRIORITY_DEFAULT_IDLE].  If the function
returns [const@GLib.SOURCE_REMOVE] it is automatically removed from the list
of event sources and will not be called again.

See [main loop memory management](main-loop.html#memory-management-of-sources) for details
on how to handle the return value and memory management of @data.

This internally creates a main loop source using [func@GLib.idle_source_new]
and attaches it to the global [struct@GLib.MainContext] using
[method@GLib.Source.attach], so the callback will be invoked in whichever
thread is running that main context. You can do these steps manually if you
need greater control or to use a custom main context.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="function" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">function to call</doc>
          <type name="SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="idle_add_full" c:identifier="g_idle_add_full" shadows="idle_add">
      <doc xml:space="preserve">Adds a function to be called whenever there are no higher priority
events pending.

If the function returns [const@GLib.SOURCE_REMOVE] it is automatically
removed from the list of event sources and will not be called again.

See [main loop memory management](main-loop.html#memory-management-of-sources) for details
on how to handle the return value and memory management of @data.

This internally creates a main loop source using [func@GLib.idle_source_new]
and attaches it to the global [struct@GLib.MainContext] using
[method@GLib.Source.attach], so the callback will be invoked in whichever
thread is running that main context. You can do these steps manually if you
need greater control or to use a custom main context.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve">the priority of the idle source; typically this will be in the
  range between [const@GLib.PRIORITY_DEFAULT_IDLE] and
  [const@GLib.PRIORITY_HIGH_IDLE]</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" scope="notified" closure="2" destroy="3">
          <doc xml:space="preserve">function to call</doc>
          <type name="SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">function to call when the idle is removed</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="idle_add_once" c:identifier="g_idle_add_once" version="2.74" introspectable="0">
      <doc xml:space="preserve">Adds a function to be called whenever there are no higher priority
events pending to the default main loop.

The function is given the
default idle priority, [const@GLib.PRIORITY_DEFAULT_IDLE].

The function will only be called once and then the source will be
automatically removed from the main context.

This function otherwise behaves like [func@GLib.idle_add].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="function" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">function to call</doc>
          <type name="SourceOnceFunc" c:type="GSourceOnceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="idle_remove_by_data" c:identifier="g_idle_remove_by_data">
      <doc xml:space="preserve">Removes the idle function with the given data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if an idle source was found and removed, false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data for the idle source&#x2019;s callback.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="idle_source_new" c:identifier="g_idle_source_new">
      <doc xml:space="preserve">Creates a new idle source.

The source will not initially be associated with any
[struct@GLib.MainContext] and must be added to one with
[method@GLib.Source.attach] before it will be executed. Note that the
default priority for idle sources is [const@GLib.PRIORITY_DEFAULT_IDLE], as
compared to other sources which have a default priority of
[const@GLib.PRIORITY_DEFAULT].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly-created idle source</doc>
        <type name="Source" c:type="GSource*"/>
      </return-value>
    </function>
    <function-macro name="info" c:identifier="g_info" version="2.40" introspectable="0">
      <doc xml:space="preserve">A convenience function/macro to log an informational message.

Seldom used.

If [func@GLib.log_default_handler] is used as the log handler function, a new-line
character will automatically be appended to @..., and need not be entered
manually.

Such messages are suppressed by the [func@GLib.log_default_handler] and
[func@GLib.log_writer_default] unless the `G_MESSAGES_DEBUG` or
`DEBUG_INVOCATION` environment variables are set appropriately. If you need
to set the allowed domains at runtime, use
[func@GLib.log_writer_default_set_debug_domains].

If structured logging is enabled, this will use [func@GLib.log_structured];
otherwise it will use [func@GLib.log]. See
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <parameters>
        <parameter name="...">
          <doc xml:space="preserve">format string, followed by parameters to insert into the format string
  (as with `printf()`)</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="int64_equal" c:identifier="g_int64_equal" version="2.22">
      <doc xml:space="preserve">Compares the two #gint64 values being pointed to and returns
%TRUE if they are equal.
It can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using non-%NULL pointers to 64-bit integers as keys in a
#GHashTable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the two keys match.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gint64 key</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gint64 key to compare with @v1</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="int64_hash" c:identifier="g_int64_hash" version="2.22">
      <doc xml:space="preserve">Converts a pointer to a #gint64 to a hash value.

It can be passed to g_hash_table_new() as the @hash_func parameter,
when using non-%NULL pointers to 64-bit integer values as keys in a
#GHashTable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a hash value corresponding to the key.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="v" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gint64 key</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="int_equal" c:identifier="g_int_equal">
      <doc xml:space="preserve">Compares the two #gint values being pointed to and returns
%TRUE if they are equal.
It can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using non-%NULL pointers to integers as keys in a
#GHashTable.

Note that this function acts on pointers to #gint, not on #gint
directly: if your hash table's keys are of the form
`GINT_TO_POINTER (n)`, use g_direct_equal() instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the two keys match.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gint key</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gint key to compare with @v1</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="int_hash" c:identifier="g_int_hash">
      <doc xml:space="preserve">Converts a pointer to a #gint to a hash value.
It can be passed to g_hash_table_new() as the @hash_func parameter,
when using non-%NULL pointers to integer values as keys in a #GHashTable.

Note that this function acts on pointers to #gint, not on #gint
directly: if your hash table's keys are of the form
`GINT_TO_POINTER (n)`, use g_direct_hash() instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a hash value corresponding to the key.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="v" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gint key</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="intern_static_string" c:identifier="g_intern_static_string" version="2.10">
      <doc xml:space="preserve">Returns a canonical representation for @string. Interned strings
can be compared for equality by comparing the pointers, instead of
using strcmp(). g_intern_static_string() does not copy the string,
therefore @string must not be freed or modified.

This function must not be used before library constructors have finished
running. In particular, this means it cannot be used to initialize global
variables in C++.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a canonical representation for the string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a static string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="intern_string" c:identifier="g_intern_string" version="2.10">
      <doc xml:space="preserve">Returns a canonical representation for @string. Interned strings
can be compared for equality by comparing the pointers, instead of
using strcmp().

This function must not be used before library constructors have finished
running. In particular, this means it cannot be used to initialize global
variables in C++.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a canonical representation for the string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_add_watch" c:identifier="g_io_add_watch" shadowed-by="io_add_watch_full" introspectable="0">
      <doc xml:space="preserve">Adds the #GIOChannel into the default main loop context
with the default priority.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the event source id</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:space="preserve">a #GIOChannel</doc>
          <type name="IOChannel" c:type="GIOChannel*"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">the condition to watch for</doc>
          <type name="IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">the function to call when the condition is satisfied</doc>
          <type name="IOFunc" c:type="GIOFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to @func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_add_watch_full" c:identifier="g_io_add_watch_full" shadows="io_add_watch">
      <doc xml:space="preserve">Adds the #GIOChannel into the default main loop context
with the given priority.

This internally creates a main loop source using g_io_create_watch()
and attaches it to the main loop context with g_source_attach().
You can do these steps manually if you need greater control.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the event source id</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:space="preserve">a #GIOChannel</doc>
          <type name="IOChannel" c:type="GIOChannel*"/>
        </parameter>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve">the priority of the #GIOChannel source</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">the condition to watch for</doc>
          <type name="IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="notified" closure="4" destroy="5">
          <doc xml:space="preserve">the function to call when the condition is satisfied</doc>
          <type name="IOFunc" c:type="GIOFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to @func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">the function to call when the source is removed</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_channel_error_from_errno" c:identifier="g_io_channel_error_from_errno" moved-to="IOChannel.error_from_errno">
      <doc xml:space="preserve">Converts an `errno` error number to a #GIOChannelError.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GIOChannelError error number, e.g.
     %G_IO_CHANNEL_ERROR_INVAL.</doc>
        <type name="IOChannelError" c:type="GIOChannelError"/>
      </return-value>
      <parameters>
        <parameter name="en" transfer-ownership="none">
          <doc xml:space="preserve">an `errno` error number, e.g. `EINVAL`</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="io_channel_error_quark" c:identifier="g_io_channel_error_quark" moved-to="IOChannel.error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="io_create_watch" c:identifier="g_io_create_watch">
      <doc xml:space="preserve">Creates a #GSource that's dispatched when @condition is met for the
given @channel. For example, if condition is %G_IO_IN, the source will
be dispatched when there's data available for reading.

The callback function invoked by the #GSource should be added with
g_source_set_callback(), but it has type #GIOFunc (not #GSourceFunc).

g_io_add_watch() is a simpler interface to this same functionality, for
the case where you want to add the source to the default main loop context
at the default priority.

On Windows, polling a #GSource created to watch a channel for a socket
puts the socket in non-blocking mode. This is a side-effect of the
implementation and unavoidable.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GSource</doc>
        <type name="Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:space="preserve">a #GIOChannel to watch</doc>
          <type name="IOChannel" c:type="GIOChannel*"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">conditions to watch for</doc>
          <type name="IOCondition" c:type="GIOCondition"/>
        </parameter>
      </parameters>
    </function>
    <function name="key_file_error_quark" c:identifier="g_key_file_error_quark" moved-to="KeyFile.error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function-macro name="list_next" c:identifier="g_list_next" introspectable="0">
      <doc xml:space="preserve">A convenience macro to get the next element in a #GList.
Note that it is considered perfectly acceptable to access
@list-&gt;next directly.</doc>
      <parameters>
        <parameter name="list">
          <doc xml:space="preserve">an element in a #GList</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="list_pop_allocator" c:identifier="g_list_pop_allocator" moved-to="List.pop_allocator" deprecated="1" deprecated-version="2.10">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function-macro name="list_previous" c:identifier="g_list_previous" introspectable="0">
      <doc xml:space="preserve">A convenience macro to get the previous element in a #GList.
Note that it is considered perfectly acceptable to access
@list-&gt;prev directly.</doc>
      <parameters>
        <parameter name="list">
          <doc xml:space="preserve">an element in a #GList</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="list_push_allocator" c:identifier="g_list_push_allocator" moved-to="List.push_allocator" deprecated="1" deprecated-version="2.10">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="allocator" transfer-ownership="none">
          <type name="Allocator" c:type="GAllocator*"/>
        </parameter>
      </parameters>
    </function>
    <function name="listenv" c:identifier="g_listenv" version="2.8">
      <doc xml:space="preserve">Gets the names of all variables set in the environment.

Programs that want to be portable to Windows should typically use
this function and g_getenv() instead of using the environ array
from the C library directly. On Windows, the strings in the environ
array are in system codepage encoding, while in most of the typical
use cases for environment variables in GLib-using programs you want
the UTF-8 encoding that this function and g_getenv() provide.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
    a %NULL-terminated list of strings which must be freed with
    g_strfreev().</doc>
        <array c:type="gchar**">
          <type name="filename"/>
        </array>
      </return-value>
    </function>
    <function name="locale_from_utf8" c:identifier="g_locale_from_utf8" throws="1">
      <doc xml:space="preserve">Converts a string from UTF-8 to the encoding used for strings by
the C runtime (usually the same as that used by the operating
system) in the [current locale](running.html#locale).
On Windows this means the system codepage.

The input string shall not contain nul characters even if the @len
argument is positive. A nul character found inside the string will result
in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Use g_convert() to convert
input that may contain embedded nul characters.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
         A newly-allocated buffer containing the converted string,
         or %NULL on an error, and error will be set.</doc>
        <array length="3" zero-terminated="0" c:type="gchar*">
          <type name="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="utf8string" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the string, or -1 if the string is
                nul-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store the number of bytes in the
                input string that were successfully converted, or %NULL.
                Even if the conversion was successful, this may be
                less than @len if there were partial characters
                at the end of the input. If the error
                %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
                stored will be the byte offset after the last valid
                input sequence.</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the number of bytes stored in the output
                buffer (not including the terminating nul).</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="locale_to_utf8" c:identifier="g_locale_to_utf8" throws="1">
      <doc xml:space="preserve">Converts a string which is in the encoding used for strings by
the C runtime (usually the same as that used by the operating
system) in the [current locale](running.html#locale) into a UTF-8 string.

If the source encoding is not UTF-8 and the conversion output contains a
nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
function returns %NULL.
If the source encoding is UTF-8, an embedded nul character is treated with
the %G_CONVERT_ERROR_ILLEGAL_SEQUENCE error for backward compatibility with
earlier versions of this library. Use g_convert() to produce output that
may contain embedded nul characters.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The converted string, or %NULL on an error.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="opsysstring" transfer-ownership="none">
          <doc xml:space="preserve">a string in the
                encoding of the current locale. On Windows
                this means the system codepage.</doc>
          <array length="1" zero-terminated="0" c:type="const gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the string, or -1 if the string is
                nul-terminated (Note that some encodings may allow nul
                bytes to occur inside strings. In that case, using -1
                for the @len parameter is unsafe)</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store the number of bytes in the
                input string that were successfully converted, or %NULL.
                Even if the conversion was successful, this may be
                less than @len if there were partial characters
                at the end of the input. If the error
                %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
                stored will be the byte offset after the last valid
                input sequence.</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the number of bytes stored in the output
                buffer (not including the terminating nul).</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="log" c:identifier="g_log" introspectable="0">
      <doc xml:space="preserve">Logs an error or debugging message.

If the log level has been set as fatal, [func@GLib.BREAKPOINT] is called
to terminate the program. See the documentation for [func@GLib.BREAKPOINT] for
details of the debugging options this provides.

If [func@GLib.log_default_handler] is used as the log handler function, a new-line
character will automatically be appended to @..., and need not be entered
manually.

If [structured logging is enabled](logging.html#using-structured-logging) this will
output via the structured log writer function (see [func@GLib.log_set_writer_func]).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the log domain, usually `G_LOG_DOMAIN`, or `NULL`
  for the default</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">the log level, either from [type@GLib.LogLevelFlags]
  or a user-defined level</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the message format. See the `printf()` documentation</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the parameters to insert into the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="log_default_handler" c:identifier="g_log_default_handler">
      <doc xml:space="preserve">The default log handler set up by GLib; [func@GLib.log_set_default_handler]
allows to install an alternate default log handler.

This is used if no log handler has been set for the particular log
domain and log level combination. It outputs the message to `stderr`
or `stdout` and if the log level is fatal it calls [func@GLib.BREAKPOINT]. It automatically
prints a new-line character after the message, so one does not need to be
manually included in @message.

The behavior of this log handler can be influenced by a number of
environment variables:

  - `G_MESSAGES_PREFIXED`: A `:`-separated list of log levels for which
    messages should be prefixed by the program name and PID of the
    application.
  - `G_MESSAGES_DEBUG`: A space-separated list of log domains for
    which debug and informational messages are printed. By default
    these messages are not printed. If you need to set the allowed
    domains at runtime, use [func@GLib.log_writer_default_set_debug_domains].
  - `DEBUG_INVOCATION`: If set to `1`, this is equivalent to
    `G_MESSAGES_DEBUG=all`. `DEBUG_INVOCATION` is a standard environment
    variable set by systemd to prompt debug output. (Since: 2.84)

`stderr` is used for levels [flags@GLib.LogLevelFlags.LEVEL_ERROR],
[flags@GLib.LogLevelFlags.LEVEL_CRITICAL], [flags@GLib.LogLevelFlags.LEVEL_WARNING] and
[flags@GLib.LogLevelFlags.LEVEL_MESSAGE]. `stdout` is used for
the rest, unless `stderr` was requested by
[func@GLib.log_writer_default_set_use_stderr].

This has no effect if structured logging is enabled; see
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the log domain of the message, or `NULL` for the
  default `""` application domain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">the level of the message</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="message" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the message</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="unused_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data passed from [func@GLib.log] which is unused</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_get_always_fatal" c:identifier="g_log_get_always_fatal" version="2.86">
      <doc xml:space="preserve">Gets the current fatal mask.

This is mostly used by custom log writers to make fatal messages
(`fatal-warnings`, `fatal-criticals`) work as expected, when using the
`G_DEBUG` environment variable (see [Running GLib Applications](running.html)).

An example usage is shown below:

```c
static GLogWriterOutput
my_custom_log_writer_fn (GLogLevelFlags log_level,
                         const GLogField *fields,
                         gsize n_fields,
                         gpointer user_data)
{

   // abort if the message was fatal
   if (log_level &amp; g_log_get_always_fatal ())
     g_abort ();

   // custom log handling code
   ...
   ...

   // success
   return G_LOG_WRITER_HANDLED;
}
```</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the current fatal mask</doc>
        <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
      </return-value>
    </function>
    <function name="log_get_debug_enabled" c:identifier="g_log_get_debug_enabled" version="2.72">
      <doc xml:space="preserve">Return whether debug output from the GLib logging system is enabled.

Note that this should not be used to conditionalise calls to [func@GLib.debug] or
other logging functions; it should only be used from [type@GLib.LogWriterFunc]
implementations.

Note also that the value of this does not depend on `G_MESSAGES_DEBUG`, nor
`DEBUG_INVOCATION`, nor [func@GLib.log_writer_default_set_debug_domains]; see
the docs for [func@GLib.log_set_debug_enabled].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if debug output is enabled, `FALSE` otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="log_remove_handler" c:identifier="g_log_remove_handler">
      <doc xml:space="preserve">Removes the log handler.

This has no effect if structured logging is enabled; see
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none">
          <doc xml:space="preserve">the log domain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="handler_id" transfer-ownership="none">
          <doc xml:space="preserve">the ID of the handler, which was returned
  in [func@GLib.log_set_handler]</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_set_always_fatal" c:identifier="g_log_set_always_fatal">
      <doc xml:space="preserve">Sets the message levels which are always fatal, in any log domain.

When a message with any of these levels is logged the program terminates.
You can only set the levels defined by GLib to be fatal.
[flags@GLib.LogLevelFlags.LEVEL_ERROR] is always fatal.

You can also make some message levels fatal at runtime by setting
the `G_DEBUG` environment variable (see
[Running GLib Applications](running.html)).

Libraries should not call this function, as it affects all messages logged
by a process, including those from other libraries.

Structured log messages (using [func@GLib.log_structured] and
[func@GLib.log_structured_array]) are fatal only if the default log writer is used;
otherwise it is up to the writer function to determine which log messages
are fatal. See [Using Structured Logging](logging.html#using-structured-logging).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the old fatal mask</doc>
        <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
      </return-value>
      <parameters>
        <parameter name="fatal_mask" transfer-ownership="none">
          <doc xml:space="preserve">the mask containing bits set for each level of error which is
  to be fatal</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_set_debug_enabled" c:identifier="g_log_set_debug_enabled" version="2.72">
      <doc xml:space="preserve">Enable or disable debug output from the GLib logging system for all domains.

This value interacts disjunctively with `G_MESSAGES_DEBUG`, `DEBUG_INVOCATION` and
[func@GLib.log_writer_default_set_debug_domains] &#x2014; if any of them would allow
a debug message to be outputted, it will be.

Note that this should not be used from within library code to enable debug
output &#x2014; it is intended for external use.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="enabled" transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` to enable debug output, `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_set_default_handler" c:identifier="g_log_set_default_handler" version="2.6" introspectable="0">
      <doc xml:space="preserve">Installs a default log handler which is used if no
log handler has been set for the particular log domain
and log level combination.

By default, GLib uses [func@GLib.log_default_handler] as default log handler.

This has no effect if structured logging is enabled; see
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <return-value>
        <doc xml:space="preserve">the previous default log handler</doc>
        <type name="LogFunc" c:type="GLogFunc"/>
      </return-value>
      <parameters>
        <parameter name="log_func" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">the log handler function</doc>
          <type name="LogFunc" c:type="GLogFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data passed to the log handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_set_fatal_mask" c:identifier="g_log_set_fatal_mask">
      <doc xml:space="preserve">Sets the log levels which are fatal in the given domain.

[flags@GLib.LogLevelFlags.LEVEL_ERROR] is always fatal.

This has no effect on structured log messages (using [func@GLib.log_structured] or
[func@GLib.log_structured_array]). To change the fatal behaviour for specific log
messages, programs must install a custom log writer function using
[func@GLib.log_set_writer_func]. See
[Using Structured Logging](logging.html#using-structured-logging).

This function is mostly intended to be used with
[flags@GLib.LogLevelFlags.LEVEL_CRITICAL].  You should typically not set
[flags@GLib.LogLevelFlags.LEVEL_WARNING], [flags@GLib.LogLevelFlags.LEVEL_MESSAGE], [flags@GLib.LogLevelFlags.LEVEL_INFO] or
[flags@GLib.LogLevelFlags.LEVEL_DEBUG] as fatal except inside of test programs.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the old fatal mask for the log domain</doc>
        <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none">
          <doc xml:space="preserve">the log domain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="fatal_mask" transfer-ownership="none">
          <doc xml:space="preserve">the new fatal mask</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_set_handler" c:identifier="g_log_set_handler" shadowed-by="log_set_handler_full" introspectable="0">
      <doc xml:space="preserve">Sets the log handler for a domain and a set of log levels.

To handle fatal and recursive messages the @log_levels parameter
must be combined with the [flags@GLib.LogLevelFlags.FLAG_FATAL] and [flags@GLib.LogLevelFlags.FLAG_RECURSION]
bit flags.

Note that since the [flags@GLib.LogLevelFlags.LEVEL_ERROR] log level is always fatal, if
you want to set a handler for this log level you must combine it with
[flags@GLib.LogLevelFlags.FLAG_FATAL].

This has no effect if structured logging is enabled; see
[Using Structured Logging](logging.html#using-structured-logging).

The `log_domain` parameter can be set to `NULL` or an empty string to use the default
application domain.

Here is an example for adding a log handler for all warning messages
in the default domain:

```c
g_log_set_handler (NULL, G_LOG_LEVEL_WARNING | G_LOG_FLAG_FATAL
                   | G_LOG_FLAG_RECURSION, my_log_handler, NULL);
```

This example adds a log handler for all critical messages from GTK:

```c
g_log_set_handler ("Gtk", G_LOG_LEVEL_CRITICAL | G_LOG_FLAG_FATAL
                   | G_LOG_FLAG_RECURSION, my_log_handler, NULL);
```

This example adds a log handler for all messages from GLib:

```c
g_log_set_handler ("GLib", G_LOG_LEVEL_MASK | G_LOG_FLAG_FATAL
                   | G_LOG_FLAG_RECURSION, my_log_handler, NULL);
```</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the id of the new handler</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the log domain
   application domain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_levels" transfer-ownership="none">
          <doc xml:space="preserve">the log levels to apply the log handler for.
   To handle fatal and recursive messages as well, combine
   the log levels with the [flags@GLib.LogLevelFlags.FLAG_FATAL] and
   [flags@GLib.LogLevelFlags.FLAG_RECURSION] bit flags.</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="log_func" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">the log handler function</doc>
          <type name="LogFunc" c:type="GLogFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data passed to the log handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_set_handler_full" c:identifier="g_log_set_handler_full" shadows="log_set_handler" version="2.46">
      <doc xml:space="preserve">Like [func@GLib.log_set_handler], but takes a destroy notify for the @user_data.

This has no effect if structured logging is enabled; see
[Using Structured Logging](logging.html#using-structured-logging).

The `log_domain` parameter can be set to `NULL` or an empty string to use the default
application domain.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID of the new handler</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the log domain
  application domain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_levels" transfer-ownership="none">
          <doc xml:space="preserve">the log levels to apply the log handler for.
  To handle fatal and recursive messages as well, combine
  the log levels with the [flags@GLib.LogLevelFlags.FLAG_FATAL] and
  [flags@GLib.LogLevelFlags.FLAG_RECURSION] bit flags.</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="log_func" transfer-ownership="none" scope="notified" closure="3" destroy="4">
          <doc xml:space="preserve">the log handler function</doc>
          <type name="LogFunc" c:type="GLogFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data passed to the log handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">destroy notify for @user_data, or `NULL`</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_set_writer_func" c:identifier="g_log_set_writer_func" version="2.50">
      <doc xml:space="preserve">Set a writer function which will be called to format and write out each log
message.

Each program should set a writer function, or the default writer
([func@GLib.log_writer_default]) will be used.

Libraries **must not** call this function &#x2014; only programs are allowed to
install a writer function, as there must be a single, central point where
log messages are formatted and outputted.

There can only be one writer function. It is an error to set more than one.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="func" transfer-ownership="none" scope="notified" closure="1" destroy="2">
          <doc xml:space="preserve">log writer function, which must not be `NULL`</doc>
          <type name="LogWriterFunc" c:type="GLogWriterFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to @func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="user_data_free" transfer-ownership="none" scope="async" destroy="0">
          <doc xml:space="preserve">function to free @user_data once it&#x2019;s
   finished with, if non-`NULL`</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_structured" c:identifier="g_log_structured" version="2.50" introspectable="0">
      <doc xml:space="preserve">Log a message with structured data.

The message will be passed through to the log writer set by the application
using [func@GLib.log_set_writer_func]. If the message is fatal (i.e. its log level
is [flags@GLib.LogLevelFlags.LEVEL_ERROR]), the program will be aborted by calling
[func@GLib.BREAKPOINT] at the end of this function. If the log writer returns
[enum@GLib.LogWriterOutput.UNHANDLED] (failure), no other fallback writers will be tried.
See the documentation for [type@GLib.LogWriterFunc] for information on chaining
writers.

The structured data is provided as key&#x2013;value pairs, where keys are UTF-8
strings, and values are arbitrary pointers &#x2014; typically pointing to UTF-8
strings, but that is not a requirement. To pass binary (non-nul-terminated)
structured data, use [func@GLib.log_structured_array]. The keys for structured data
should follow the [systemd journal
fields](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html)
specification. It is suggested that custom keys are namespaced according to
the code which sets them. For example, custom keys from GLib all have a
`GLIB_` prefix.

Note that keys that expect UTF-8 strings (specifically `"MESSAGE"` and
`"GLIB_DOMAIN"`) must be passed as nul-terminated UTF-8 strings until GLib
version 2.74.1 because the default log handler did not consider the length of
the `GLogField`. Starting with GLib 2.74.1 this is fixed and
non-nul-terminated UTF-8 strings can be passed with their correct length,
with the exception of `"GLIB_DOMAIN"` which was only fixed with GLib 2.82.3.

The @log_domain will be converted into a `GLIB_DOMAIN` field. @log_level will
be converted into a
[`PRIORITY`](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html#PRIORITY=)
field. The format string will have its placeholders substituted for the provided
values and be converted into a
[`MESSAGE`](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html#MESSAGE=)
field.

Other fields you may commonly want to pass into this function:

 * [`MESSAGE_ID`](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html#MESSAGE_ID=)
 * [`CODE_FILE`](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html#CODE_FILE=)
 * [`CODE_LINE`](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html#CODE_LINE=)
 * [`CODE_FUNC`](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html#CODE_FUNC=)
 * [`ERRNO`](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html#ERRNO=)

Note that `CODE_FILE`, `CODE_LINE` and `CODE_FUNC` are automatically set by
the logging macros, [func@GLib.DEBUG_HERE], [func@GLib.message], [func@GLib.warning], [func@GLib.critical],
[func@GLib.error], etc, if the symbol `G_LOG_USE_STRUCTURED` is defined before including
`glib.h`.

For example:

```c
g_log_structured (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,
                  "MESSAGE_ID", "06d4df59e6c24647bfe69d2c27ef0b4e",
                  "MY_APPLICATION_CUSTOM_FIELD", "some debug string",
                  "MESSAGE", "This is a debug message about pointer %p and integer %u.",
                  some_pointer, some_integer);
```

Note that each `MESSAGE_ID` must be [uniquely and randomly
generated](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html#MESSAGE_ID=).
If adding a `MESSAGE_ID`, consider shipping a [message
catalog](https://www.freedesktop.org/wiki/Software/systemd/catalog/) with
your software.

To pass a user data pointer to the log writer function which is specific to
this logging call, you must use [func@GLib.log_structured_array] and pass the pointer
as a field with `GLogField.length` set to zero, otherwise it will be
interpreted as a string.

For example:

```c
const GLogField fields[] = {
  { "MESSAGE", "This is a debug message.", -1 },
  { "MESSAGE_ID", "fcfb2e1e65c3494386b74878f1abf893", -1 },
  { "MY_APPLICATION_CUSTOM_FIELD", "some debug string", -1 },
  { "MY_APPLICATION_STATE", state_object, 0 },
};
g_log_structured_array (G_LOG_LEVEL_DEBUG, fields, G_N_ELEMENTS (fields));
```

Note also that, even if no other structured fields are specified, there
must always be a `MESSAGE` key before the format string. The `MESSAGE`-format
pair has to be the last of the key-value pairs, and `MESSAGE` is the only
field for which `printf()`-style formatting is supported.

The default writer function for `stdout` and `stderr` will automatically
append a new-line character after the message, so you should not add one
manually to the format string.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none">
          <doc xml:space="preserve">log domain, usually `G_LOG_DOMAIN`</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">log level, either from [type@GLib.LogLevelFlags], or a user-defined
   level</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">key-value pairs of structured data to add to the log entry, followed
   by the key `MESSAGE`, followed by a `printf()`-style message format,
   followed by parameters to insert in the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="log_structured_array" c:identifier="g_log_structured_array" version="2.50">
      <doc xml:space="preserve">Log a message with structured data.

The message will be passed through to the log writer set by the application
using [func@GLib.log_set_writer_func]. If the
message is fatal (i.e. its log level is [flags@GLib.LogLevelFlags.LEVEL_ERROR]), the program will
be aborted at the end of this function.

See [func@GLib.log_structured] for more documentation.

This assumes that @log_level is already present in @fields (typically as the
`PRIORITY` field).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">log level, either from [type@GLib.LogLevelFlags], or a user-defined
   level</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="fields" transfer-ownership="none">
          <doc xml:space="preserve">key&#x2013;value pairs of structured data to add
   to the log message</doc>
          <array length="2" zero-terminated="0" c:type="const GLogField*">
            <type name="LogField" c:type="GLogField"/>
          </array>
        </parameter>
        <parameter name="n_fields" transfer-ownership="none">
          <doc xml:space="preserve">number of elements in the @fields array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_structured_standard" c:identifier="g_log_structured_standard" introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="message_format" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="log_variant" c:identifier="g_log_variant" version="2.50">
      <doc xml:space="preserve">Log a message with structured data, accepting the data within a [type@GLib.Variant].

This version is especially useful for use in other languages, via introspection.

The only mandatory item in the @fields dictionary is the `"MESSAGE"` which must
contain the text shown to the user.

The values in the @fields dictionary are likely to be of type `G_VARIANT_TYPE_STRING`.
Array of bytes (`G_VARIANT_TYPE_BYTESTRING`) is also
supported. In this case the message is handled as binary and will be forwarded
to the log writer as such. The size of the array should not be higher than
`G_MAXSSIZE`. Otherwise it will be truncated to this size. For other types
[method@GLib.Variant.print] will be used to convert the value into a string.

For more details on its usage and about the parameters, see [func@GLib.log_structured].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">log domain, usually `G_LOG_DOMAIN`</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">log level, either from [type@GLib.LogLevelFlags], or a user-defined
   level</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="fields" transfer-ownership="none">
          <doc xml:space="preserve">a dictionary ([type@GLib.Variant] of the type `G_VARIANT_TYPE_VARDICT`)
containing the key-value pairs of message data.</doc>
          <type name="Variant" c:type="GVariant*"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_writer_default" c:identifier="g_log_writer_default" version="2.50">
      <doc xml:space="preserve">Format a structured log message and output it to the default log destination
for the platform.

On Linux, this is typically the systemd journal, falling
back to `stdout` or `stderr` if running from the terminal or if output is
being redirected to a file.

Support for other platform-specific logging mechanisms may be added in
future. Distributors of GLib may modify this function to impose their own
(documented) platform-specific log writing policies.

This is suitable for use as a [type@GLib.LogWriterFunc], and is the default writer used
if no other is set using [func@GLib.log_set_writer_func].

As with [func@GLib.log_default_handler], this function drops debug and informational
messages unless their log domain (or `all`) is listed in the space-separated
`G_MESSAGES_DEBUG` environment variable, or `DEBUG_INVOCATION=1` is set in
the environment, or set at runtime by [func@GLib.log_writer_default_set_debug_domains].

[func@GLib.log_writer_default] uses the mask set by [func@GLib.log_set_always_fatal] to
determine which messages are fatal. When using a custom writer function instead it is
up to the writer function to determine which log messages are fatal.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">[enum@GLib.LogWriterOutput.HANDLED] on success,
  [enum@GLib.LogWriterOutput.UNHANDLED] otherwise</doc>
        <type name="LogWriterOutput" c:type="GLogWriterOutput"/>
      </return-value>
      <parameters>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">log level, either from [type@GLib.LogLevelFlags], or a user-defined
   level</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="fields" transfer-ownership="none">
          <doc xml:space="preserve">key&#x2013;value pairs of structured data forming
   the log message</doc>
          <array length="2" zero-terminated="0" c:type="const GLogField*">
            <type name="LogField" c:type="GLogField"/>
          </array>
        </parameter>
        <parameter name="n_fields" transfer-ownership="none">
          <doc xml:space="preserve">number of elements in the @fields array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to [func@GLib.log_set_writer_func]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_writer_default_set_debug_domains" c:identifier="g_log_writer_default_set_debug_domains" version="2.80">
      <doc xml:space="preserve">Reset the list of domains to be logged, that might be initially set by the
`G_MESSAGES_DEBUG` or `DEBUG_INVOCATION` environment variables.

This function is thread-safe.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domains" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">`NULL`-terminated array with domains to be printed.
  `NULL` or an array with no values means none. Array with a single value `"all"` means all.</doc>
          <type name="utf8" c:type="const gchar* const*"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_writer_default_set_use_stderr" c:identifier="g_log_writer_default_set_use_stderr" version="2.68">
      <doc xml:space="preserve">Configure whether the built-in log functions will output all log messages to
`stderr`.

The built-in log functions are [func@GLib.log_default_handler] for the
old-style API, and both [func@GLib.log_writer_default] and
[func@GLib.log_writer_standard_streams] for the structured API.

By default, log messages of levels [flags@GLib.LogLevelFlags.LEVEL_INFO] and
[flags@GLib.LogLevelFlags.LEVEL_DEBUG] are sent to `stdout`, and other log messages are
sent to `stderr`. This is problematic for applications that intend
to reserve `stdout` for structured output such as JSON or XML.

This function sets global state. It is not thread-aware, and should be
called at the very start of a program, before creating any other threads
or creating objects that could create worker threads of their own.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="use_stderr" transfer-ownership="none">
          <doc xml:space="preserve">If `TRUE`, use `stderr` for log messages that would
 normally have appeared on `stdout`</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_writer_default_would_drop" c:identifier="g_log_writer_default_would_drop" version="2.68">
      <doc xml:space="preserve">Check whether [func@GLib.log_writer_default] and [func@GLib.log_default_handler] would
ignore a message with the given domain and level.

As with [func@GLib.log_default_handler], this function drops debug and informational
messages unless their log domain (or `all`) is listed in the space-separated
`G_MESSAGES_DEBUG` environment variable, or `DEBUG_INVOCATION=1` is set in
the environment, or by [func@GLib.log_writer_default_set_debug_domains].

This can be used when implementing log writers with the same filtering
behaviour as the default, but a different destination or output format:

```c
if (g_log_writer_default_would_drop (log_level, log_domain))
  return G_LOG_WRITER_HANDLED;
]|

or to skip an expensive computation if it is only needed for a debugging
message, and `G_MESSAGES_DEBUG` and `DEBUG_INVOCATION` are not set:

```c
if (!g_log_writer_default_would_drop (G_LOG_LEVEL_DEBUG, G_LOG_DOMAIN))
  {
    g_autofree gchar *result = expensive_computation (my_object);

    g_debug ("my_object result: %s", result);
  }
```</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if the log message would be dropped by GLib&#x2019;s
  default log handlers</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">log level, either from [type@GLib.LogLevelFlags], or a user-defined
   level</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="log_domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">log domain</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_writer_format_fields" c:identifier="g_log_writer_format_fields" version="2.50">
      <doc xml:space="preserve">Format a structured log message as a string suitable for outputting to the
terminal (or elsewhere).

This will include the values of all fields it knows
how to interpret, which includes `MESSAGE` and `GLIB_DOMAIN` (see the
documentation for [func@GLib.log_structured]). It does not include values from
unknown fields.

The returned string does **not** have a trailing new-line character. It is
encoded in the character set of the current locale, which is not necessarily
UTF-8.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">string containing the formatted log message, in
   the character set of the current locale</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">log level, either from [type@GLib.LogLevelFlags], or a user-defined
   level</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="fields" transfer-ownership="none">
          <doc xml:space="preserve">key&#x2013;value pairs of structured data forming
   the log message</doc>
          <array length="2" zero-terminated="0" c:type="const GLogField*">
            <type name="LogField" c:type="GLogField"/>
          </array>
        </parameter>
        <parameter name="n_fields" transfer-ownership="none">
          <doc xml:space="preserve">number of elements in the @fields array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="use_color" transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` to use
  [ANSI color escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code)
  when formatting the message, `FALSE` to not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_writer_is_journald" c:identifier="g_log_writer_is_journald" version="2.50">
      <doc xml:space="preserve">Check whether the given @output_fd file descriptor is a connection to the
systemd journal, or something else (like a log file or `stdout` or
`stderr`).

Invalid file descriptors are accepted and return `FALSE`, which allows for
the following construct without needing any additional error handling:
```c
is_journald = g_log_writer_is_journald (fileno (stderr));
```</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if @output_fd points to the journal, `FALSE` otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="output_fd" transfer-ownership="none">
          <doc xml:space="preserve">output file descriptor to check</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_writer_journald" c:identifier="g_log_writer_journald" version="2.50">
      <doc xml:space="preserve">Format a structured log message and send it to the systemd journal as a set
of key&#x2013;value pairs.

All fields are sent to the journal, but if a field has
length zero (indicating program-specific data) then only its key will be
sent.

This is suitable for use as a [type@GLib.LogWriterFunc].

If GLib has been compiled without systemd support, this function is still
defined, but will always return [enum@GLib.LogWriterOutput.UNHANDLED].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">[enum@GLib.LogWriterOutput.HANDLED] on success, [enum@GLib.LogWriterOutput.UNHANDLED] otherwise</doc>
        <type name="LogWriterOutput" c:type="GLogWriterOutput"/>
      </return-value>
      <parameters>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">log level, either from [type@GLib.LogLevelFlags], or a user-defined
   level</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="fields" transfer-ownership="none">
          <doc xml:space="preserve">key&#x2013;value pairs of structured data forming
   the log message</doc>
          <array length="2" zero-terminated="0" c:type="const GLogField*">
            <type name="LogField" c:type="GLogField"/>
          </array>
        </parameter>
        <parameter name="n_fields" transfer-ownership="none">
          <doc xml:space="preserve">number of elements in the @fields array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to [func@GLib.log_set_writer_func]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_writer_standard_streams" c:identifier="g_log_writer_standard_streams" version="2.50">
      <doc xml:space="preserve">Format a structured log message and print it to either `stdout` or `stderr`,
depending on its log level.

[flags@GLib.LogLevelFlags.LEVEL_INFO] and [flags@GLib.LogLevelFlags.LEVEL_DEBUG] messages
are sent to `stdout`, or to `stderr` if requested by
[func@GLib.log_writer_default_set_use_stderr];
all other log levels are sent to `stderr`. Only fields
which are understood by this function are included in the formatted string
which is printed.

If the output stream supports
[ANSI color escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code),
they will be used in the output.

A trailing new-line character is added to the log message when it is printed.

This is suitable for use as a [type@GLib.LogWriterFunc].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">[enum@GLib.LogWriterOutput.HANDLED] on success,
  [enum@GLib.LogWriterOutput.UNHANDLED] otherwise</doc>
        <type name="LogWriterOutput" c:type="GLogWriterOutput"/>
      </return-value>
      <parameters>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">log level, either from [type@GLib.LogLevelFlags], or a user-defined
   level</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="fields" transfer-ownership="none">
          <doc xml:space="preserve">key&#x2013;value pairs of structured data forming
   the log message</doc>
          <array length="2" zero-terminated="0" c:type="const GLogField*">
            <type name="LogField" c:type="GLogField"/>
          </array>
        </parameter>
        <parameter name="n_fields" transfer-ownership="none">
          <doc xml:space="preserve">number of elements in the @fields array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to [func@GLib.log_set_writer_func]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_writer_supports_color" c:identifier="g_log_writer_supports_color" version="2.50">
      <doc xml:space="preserve">Check whether the given @output_fd file descriptor supports
[ANSI color escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code).

If so, they can safely be used when formatting log messages.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if ANSI color escapes are supported, `FALSE` otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="output_fd" transfer-ownership="none">
          <doc xml:space="preserve">output file descriptor to check</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="log_writer_syslog" c:identifier="g_log_writer_syslog" version="2.80">
      <doc xml:space="preserve">Format a structured log message and send it to the syslog daemon. Only fields
which are understood by this function are included in the formatted string
which is printed.

Log facility will be defined via the SYSLOG_FACILITY field and accepts the following
values: "auth", "daemon", and "user". If SYSLOG_FACILITY is not specified, LOG_USER
facility will be used.

This is suitable for use as a [type@GLib.LogWriterFunc].

If syslog is not supported, this function is still defined, but will always
return [enum@GLib.LogWriterOutput.UNHANDLED].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">[enum@GLib.LogWriterOutput.HANDLED] on success, [enum@GLib.LogWriterOutput.UNHANDLED] otherwise</doc>
        <type name="LogWriterOutput" c:type="GLogWriterOutput"/>
      </return-value>
      <parameters>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">log level, either from [type@GLib.LogLevelFlags], or a user-defined
   level</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="fields" transfer-ownership="none">
          <doc xml:space="preserve">key&#x2013;value pairs of structured data forming
   the log message</doc>
          <array length="2" zero-terminated="0" c:type="const GLogField*">
            <type name="LogField" c:type="GLogField"/>
          </array>
        </parameter>
        <parameter name="n_fields" transfer-ownership="none">
          <doc xml:space="preserve">number of elements in the @fields array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to [func@GLib.log_set_writer_func]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="logv" c:identifier="g_logv" introspectable="0">
      <doc xml:space="preserve">Logs an error or debugging message.

If the log level has been set as fatal, [func@GLib.BREAKPOINT] is called
to terminate the program. See the documentation for [func@GLib.BREAKPOINT] for
details of the debugging options this provides.

If [func@GLib.log_default_handler] is used as the log handler function, a new-line
character will automatically be appended to @..., and need not be entered
manually.

If [structured logging is enabled](logging.html#using-structured-logging) this will
output via the structured log writer function (see [func@GLib.log_set_writer_func]).

The `log_domain` parameter can be set to `NULL` or an empty string to use the default
application domain.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the log domain
  application domain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">the log level</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the message format. See the `printf()` documentation</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">the parameters to insert into the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="lstat" c:identifier="g_lstat" version="2.6">
      <doc xml:space="preserve">A wrapper for the POSIX lstat() function. The lstat() function is
like stat() except that in the case of symbolic links, it returns
information about the symbolic link itself and not the file that it
refers to. If the system does not support symbolic links g_lstat()
is identical to g_stat().

See your C library manual for more details about lstat().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the information was successfully retrieved,
    -1 if an error occurred</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a stat struct, which will be filled with the file
    information</doc>
          <type name="StatBuf" c:type="GStatBuf*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="macro__has_attribute" c:identifier="g_macro__has_attribute" introspectable="0">
      <parameters>
        <parameter name="x">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="macro__has_attribute___noreturn__" value="0" c:type="g_macro__has_attribute___noreturn__">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="macro__has_attribute_ifunc" value="0" c:type="g_macro__has_attribute_ifunc">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="macro__has_attribute_no_sanitize_address" value="0" c:type="g_macro__has_attribute_no_sanitize_address">
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="macro__has_builtin" c:identifier="g_macro__has_builtin" introspectable="0">
      <parameters>
        <parameter name="x">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="macro__has_extension" c:identifier="g_macro__has_extension" introspectable="0">
      <parameters>
        <parameter name="x">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="macro__has_feature" c:identifier="g_macro__has_feature" introspectable="0">
      <parameters>
        <parameter name="x">
        </parameter>
      </parameters>
    </function-macro>
    <function name="main_context_default" c:identifier="g_main_context_default" moved-to="MainContext.default">
      <doc xml:space="preserve">Returns the global-default main context.

This is the main context
used for main loop functions when a main loop is not explicitly
specified, and corresponds to the &#x2018;main&#x2019; main loop. See also
[func@GLib.MainContext.get_thread_default].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the global-default main context.</doc>
        <type name="MainContext" c:type="GMainContext*"/>
      </return-value>
    </function>
    <function name="main_context_get_thread_default" c:identifier="g_main_context_get_thread_default" moved-to="MainContext.get_thread_default" version="2.22">
      <doc xml:space="preserve">Gets the thread-default main context for this thread.

Asynchronous operations that want to be able to be run in contexts other than
the default one should call this method or
[func@GLib.MainContext.ref_thread_default] to get a
[struct@GLib.MainContext] to add their [struct@GLib.Source]s to. (Note that
even in single-threaded programs applications may sometimes want to
temporarily push a non-default context, so it is not safe to assume that
this will always return `NULL` if you are running in the default thread.)

If you need to hold a reference on the context, use
[func@GLib.MainContext.ref_thread_default] instead.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the thread-default main context, or
  `NULL` if the thread-default context is the global-default main context</doc>
        <type name="MainContext" c:type="GMainContext*"/>
      </return-value>
    </function>
    <function name="main_context_ref_thread_default" c:identifier="g_main_context_ref_thread_default" moved-to="MainContext.ref_thread_default" version="2.32">
      <doc xml:space="preserve">Gets a reference to the thread-default [struct@GLib.MainContext] for this
thread

This is the same as [func@GLib.MainContext.get_thread_default], but it also
adds a reference to the returned main context with [method@GLib.MainContext.ref].
In addition, unlike
[func@GLib.MainContext.get_thread_default], if the thread-default context
is the global-default context, this will return that
[struct@GLib.MainContext] (with a ref added to it) rather than returning
`NULL`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the thread-default main context</doc>
        <type name="MainContext" c:type="GMainContext*"/>
      </return-value>
    </function>
    <function name="main_current_source" c:identifier="g_main_current_source" version="2.12">
      <doc xml:space="preserve">Returns the currently firing source for this thread.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the currently firing source, or `NULL`
  if none is firing</doc>
        <type name="Source" c:type="GSource*"/>
      </return-value>
    </function>
    <function name="main_depth" c:identifier="g_main_depth">
      <doc xml:space="preserve">Returns the depth of the stack of calls to
[method@GLib.MainContext.dispatch] on any #GMainContext in the current thread.

That is, when called from the top level, it gives `0`. When
called from within a callback from [method@GLib.MainContext.iteration]
(or [method@GLib.MainLoop.run], etc.) it returns `1`. When called from within
a callback to a recursive call to [method@GLib.MainContext.iteration],
it returns `2`. And so forth.

This function is useful in a situation like the following:
Imagine an extremely simple &#x2018;garbage collected&#x2019; system.

```c
static GList *free_list;

gpointer
allocate_memory (gsize size)
{
  gpointer result = g_malloc (size);
  free_list = g_list_prepend (free_list, result);
  return result;
}

void
free_allocated_memory (void)
{
  GList *l;
  for (l = free_list; l; l = l-&gt;next);
    g_free (l-&gt;data);
  g_list_free (free_list);
  free_list = NULL;
 }

[...]

while (TRUE);
 {
   g_main_context_iteration (NULL, TRUE);
   free_allocated_memory();
  }
```

This works from an application, however, if you want to do the same
thing from a library, it gets more difficult, since you no longer
control the main loop. You might think you can simply use an idle
function to make the call to `free_allocated_memory()`, but that
doesn&#x2019;t work, since the idle function could be called from a
recursive callback. This can be fixed by using [func@GLib.main_depth]

```c
gpointer
allocate_memory (gsize size)
{
  FreeListBlock *block = g_new (FreeListBlock, 1);
  block-&gt;mem = g_malloc (size);
  block-&gt;depth = g_main_depth ();
  free_list = g_list_prepend (free_list, block);
  return block-&gt;mem;
}

void
free_allocated_memory (void)
{
  GList *l;
  
  int depth = g_main_depth ();
  for (l = free_list; l; );
    {
      GList *next = l-&gt;next;
      FreeListBlock *block = l-&gt;data;
      if (block-&gt;depth &gt; depth)
        {
          g_free (block-&gt;mem);
          g_free (block);
          free_list = g_list_delete_link (free_list, l);
        }
              
      l = next;
    }
  }
```

There is a temptation to use [func@GLib.main_depth] to solve
problems with reentrancy. For instance, while waiting for data
to be received from the network in response to a menu item,
the menu item might be selected again. It might seem that
one could make the menu item&#x2019;s callback return immediately
and do nothing if [func@GLib.main_depth] returns a value greater than 1.
However, this should be avoided since the user then sees selecting
the menu item do nothing. Furthermore, you&#x2019;ll find yourself adding
these checks all over your code, since there are doubtless many,
many things that the user could do. Instead, you can use the
following techniques:

1. Use `gtk_widget_set_sensitive()` or modal dialogs to prevent
   the user from interacting with elements while the main
   loop is recursing.

2. Avoid main loop recursion in situations where you can&#x2019;t handle
   arbitrary  callbacks. Instead, structure your code so that you
   simply return to the main loop and then get called again when
   there is more work to do.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the main loop recursion level in the current thread</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
    </function>
    <function-macro name="main_destroy" c:identifier="g_main_destroy" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Frees the memory allocated for the #GMainLoop.</doc>
      <doc-deprecated xml:space="preserve">Use g_main_loop_unref() instead</doc-deprecated>
      <parameters>
        <parameter name="loop">
          <doc xml:space="preserve">a #GMainLoop</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="main_is_running" c:identifier="g_main_is_running" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Checks if the main loop is running.</doc>
      <doc-deprecated xml:space="preserve">Use g_main_loop_is_running() instead</doc-deprecated>
      <parameters>
        <parameter name="loop">
          <doc xml:space="preserve">a #GMainLoop</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="main_iteration" c:identifier="g_main_iteration" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Runs a single iteration for the default #GMainContext.</doc>
      <doc-deprecated xml:space="preserve">Use g_main_context_iteration() instead.</doc-deprecated>
      <parameters>
        <parameter name="may_block">
          <doc xml:space="preserve">set to %TRUE if it should block (i.e. wait) until an event
    source becomes ready. It will return after an event source has been
    processed. If set to %FALSE it will return immediately if no event
    source is ready to be processed.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="main_new" c:identifier="g_main_new" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Creates a new #GMainLoop for th default main context.</doc>
      <doc-deprecated xml:space="preserve">Use g_main_loop_new() instead</doc-deprecated>
      <parameters>
        <parameter name="is_running">
          <doc xml:space="preserve">set to %TRUE to indicate that the loop is running. This
    is not very important since calling g_main_run() will set this
    to %TRUE anyway.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="main_pending" c:identifier="g_main_pending" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Checks if any events are pending for the default #GMainContext
(i.e. ready to be processed).</doc>
      <doc-deprecated xml:space="preserve">Use g_main_context_pending() instead.</doc-deprecated>
    </function-macro>
    <function-macro name="main_quit" c:identifier="g_main_quit" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Stops the #GMainLoop.
If g_main_run() was called to run the #GMainLoop, it will now return.</doc>
      <doc-deprecated xml:space="preserve">Use g_main_loop_quit() instead</doc-deprecated>
      <parameters>
        <parameter name="loop">
          <doc xml:space="preserve">a #GMainLoop</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="main_run" c:identifier="g_main_run" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Runs a main loop until it stops running.</doc>
      <doc-deprecated xml:space="preserve">Use g_main_loop_run() instead</doc-deprecated>
      <parameters>
        <parameter name="loop">
          <doc xml:space="preserve">a #GMainLoop</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="main_set_poll_func" c:identifier="g_main_set_poll_func" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Sets the function to use for the handle polling of file descriptors
for the default main context.</doc>
      <doc-deprecated xml:space="preserve">Use g_main_context_set_poll_func() again</doc-deprecated>
      <parameters>
        <parameter name="func">
          <doc xml:space="preserve">the function to call to poll all file descriptors</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="malloc" c:identifier="g_malloc">
      <doc xml:space="preserve">Allocates @n_bytes bytes of memory.
If @n_bytes is 0 it returns %NULL.

If the allocation fails (because the system is out of memory),
the program is terminated.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the allocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="malloc0" c:identifier="g_malloc0">
      <doc xml:space="preserve">Allocates @n_bytes bytes of memory, initialized to 0's.
If @n_bytes is 0 it returns %NULL.

If the allocation fails (because the system is out of memory),
the program is terminated.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the allocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="malloc0_n" c:identifier="g_malloc0_n" version="2.24">
      <doc xml:space="preserve">This function is similar to g_malloc0(), allocating (@n_blocks * @n_block_bytes) bytes,
but care is taken to detect possible overflow during multiplication.

If the allocation fails (because the system is out of memory),
the program is terminated.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the allocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_blocks" transfer-ownership="none">
          <doc xml:space="preserve">the number of blocks to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="n_block_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the size of each block in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="malloc_n" c:identifier="g_malloc_n" version="2.24">
      <doc xml:space="preserve">This function is similar to g_malloc(), allocating (@n_blocks * @n_block_bytes) bytes,
but care is taken to detect possible overflow during multiplication.

If the allocation fails (because the system is out of memory),
the program is terminated.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the allocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_blocks" transfer-ownership="none">
          <doc xml:space="preserve">the number of blocks to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="n_block_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the size of each block in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="markup_collect_attributes" c:identifier="g_markup_collect_attributes" version="2.16" introspectable="0">
      <doc xml:space="preserve">Collects the attributes of the element from the data passed to the
#GMarkupParser start_element function, dealing with common error
conditions and supporting boolean values.

This utility function is not required to write a parser but can save
a lot of typing.

The @element_name, @attribute_names, @attribute_values and @error
parameters passed to the start_element callback should be passed
unmodified to this function.

Following these arguments is a list of "supported" attributes to collect.
It is an error to specify multiple attributes with the same name. If any
attribute not in the list appears in the @attribute_names array then an
unknown attribute error will result.

The #GMarkupCollectType field allows specifying the type of collection
to perform and if a given attribute must appear or is optional.

The attribute name is simply the name of the attribute to collect.

The pointer should be of the appropriate type (see the descriptions
under #GMarkupCollectType) and may be %NULL in case a particular
attribute is to be allowed but ignored.

This function deals with issuing errors for missing attributes
(of type %G_MARKUP_ERROR_MISSING_ATTRIBUTE), unknown attributes
(of type %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE) and duplicate
attributes (of type %G_MARKUP_ERROR_INVALID_CONTENT) as well
as parse errors for boolean-valued attributes (again of type
%G_MARKUP_ERROR_INVALID_CONTENT). In all of these cases %FALSE
will be returned and @error will be set as appropriate.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if successful</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="element_name" transfer-ownership="none">
          <doc xml:space="preserve">the current tag name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="attribute_names" transfer-ownership="none">
          <doc xml:space="preserve">the attribute names</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
        <parameter name="attribute_values" transfer-ownership="none">
          <doc xml:space="preserve">the attribute values</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #GError or %NULL</doc>
          <type name="Error" c:type="GError**"/>
        </parameter>
        <parameter name="first_type" transfer-ownership="none">
          <doc xml:space="preserve">the #GMarkupCollectType of the first attribute</doc>
          <type name="MarkupCollectType" c:type="GMarkupCollectType"/>
        </parameter>
        <parameter name="first_attr" transfer-ownership="none">
          <doc xml:space="preserve">the name of the first attribute</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the storage location of the first attribute
    (or %NULL), followed by more types names and pointers, ending
    with %G_MARKUP_COLLECT_INVALID</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="markup_error_quark" c:identifier="g_markup_error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="markup_escape_text" c:identifier="g_markup_escape_text">
      <doc xml:space="preserve">Escapes text so that the markup parser will parse it verbatim.
Less than, greater than, ampersand, etc. are replaced with the
corresponding entities. This function would typically be used
when writing out a file to be parsed with the markup parser.

Note that this function doesn't protect whitespace and line endings
from being processed according to the XML rules for normalization
of line endings and attribute values.

Note also that this function will produce character references in
the range of &amp;#x1; ... &amp;#x1f; for all control sequences
except for tabstop, newline and carriage return.  The character
references in this range are not valid XML 1.0, but they are
valid XML 1.1 and will be accepted by the GMarkup parser.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string with the escaped text</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="text" transfer-ownership="none">
          <doc xml:space="preserve">some valid UTF-8 text</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">length of @text in bytes, or -1 if the text is nul-terminated</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="markup_printf_escaped" c:identifier="g_markup_printf_escaped" version="2.4" introspectable="0">
      <doc xml:space="preserve">Formats arguments according to @format, escaping
all string and character arguments in the fashion
of g_markup_escape_text(). This is useful when you
want to insert literal strings into XML-style markup
output, without having to worry that the strings
might themselves contain markup.

|[&lt;!-- language="C" --&gt;
const char *store = "Fortnum &amp; Mason";
const char *item = "Tea";
char *output;

output = g_markup_printf_escaped ("&lt;purchase&gt;"
                                  "&lt;store&gt;%s&lt;/store&gt;"
                                  "&lt;item&gt;%s&lt;/item&gt;"
                                  "&lt;/purchase&gt;",
                                  store, item);
]|</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">newly allocated result from formatting
   operation. Free with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">printf() style format string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the arguments to insert in the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="markup_vprintf_escaped" c:identifier="g_markup_vprintf_escaped" version="2.4" introspectable="0">
      <doc xml:space="preserve">Formats the data in @args according to @format, escaping
all string and character arguments in the fashion
of g_markup_escape_text(). See g_markup_printf_escaped().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">newly allocated result from formatting
 operation. Free with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">printf() style format string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">variable argument list, similar to vprintf()</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="mem_chunk_create" c:identifier="g_mem_chunk_create" introspectable="0" deprecated="1" deprecated-version="2.10">
      <parameters>
        <parameter name="type">
        </parameter>
        <parameter name="x">
        </parameter>
        <parameter name="y">
        </parameter>
      </parameters>
    </function-macro>
    <function name="mem_chunk_info" c:identifier="g_mem_chunk_info" moved-to="MemChunk.info" deprecated="1" deprecated-version="2.10">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="mem_is_system_malloc" c:identifier="g_mem_is_system_malloc" deprecated="1" deprecated-version="2.46">
      <doc xml:space="preserve">Checks whether the allocator used by g_malloc() is the system's
malloc implementation. If it returns %TRUE memory allocated with
malloc() can be used interchangeably with memory allocated using g_malloc().
This function is useful for avoiding an extra copy of allocated memory returned
by a non-GLib-based API.</doc>
      <doc-deprecated xml:space="preserve">GLib always uses the system malloc, so this function always
returns %TRUE.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">if %TRUE, malloc() and g_malloc() can be mixed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="mem_profile" c:identifier="g_mem_profile" deprecated="1" deprecated-version="2.46">
      <doc xml:space="preserve">GLib used to support some tools for memory profiling, but this
no longer works. There are many other useful tools for memory
profiling these days which can be used instead.</doc>
      <doc-deprecated xml:space="preserve">Use other memory profiling tools instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="mem_set_vtable" c:identifier="g_mem_set_vtable" deprecated="1" deprecated-version="2.46">
      <doc xml:space="preserve">This function used to let you override the memory allocation function.
However, its use was incompatible with the use of global constructors
in GLib and GIO, because those use the GLib allocators before main is
reached. Therefore this function is now deprecated and is just a stub.</doc>
      <doc-deprecated xml:space="preserve">This function now does nothing. Use other memory
profiling tools instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vtable" transfer-ownership="none">
          <doc xml:space="preserve">table of memory allocation routines.</doc>
          <type name="MemVTable" c:type="GMemVTable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="memdup" c:identifier="g_memdup" deprecated="1" deprecated-version="2.68">
      <doc xml:space="preserve">Allocates @byte_size bytes of memory, and copies @byte_size bytes into it
from @mem. If @mem is `NULL` it returns `NULL`.</doc>
      <doc-deprecated xml:space="preserve">Use [func@GLib.memdup2] instead, as it accepts a gsize argument
  for @byte_size, avoiding the possibility of overflow in a `gsize` &#x2192; `guint`
  conversion</doc-deprecated>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a pointer to the newly-allocated copy of the memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the memory to copy</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="byte_size" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to copy</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="memdup2" c:identifier="g_memdup2" version="2.68">
      <doc xml:space="preserve">Allocates @byte_size bytes of memory, and copies @byte_size bytes into it
from @mem. If @mem is `NULL` it returns `NULL`.

This replaces [func@GLib.memdup], which was prone to integer overflows when
converting the argument from a `gsize` to a `guint`.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a pointer to the newly-allocated copy of the memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the memory to copy</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="byte_size" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to copy</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="memmove" c:identifier="g_memmove" introspectable="0" deprecated="1" deprecated-version="2.40">
      <doc xml:space="preserve">Copies a block of memory @len bytes long, from @src to @dest.
The source and destination areas may overlap.</doc>
      <doc-deprecated xml:space="preserve">Just use memmove().</doc-deprecated>
      <parameters>
        <parameter name="dest">
          <doc xml:space="preserve">the destination address to copy the bytes to.</doc>
        </parameter>
        <parameter name="src">
          <doc xml:space="preserve">the source address to copy the bytes from.</doc>
        </parameter>
        <parameter name="len">
          <doc xml:space="preserve">the number of bytes to copy.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="message" c:identifier="g_message" introspectable="0">
      <doc xml:space="preserve">A convenience function/macro to log a normal message.

If [func@GLib.log_default_handler] is used as the log handler function, a new-line
character will automatically be appended to @..., and need not be entered
manually.

If structured logging is enabled, this will use [func@GLib.log_structured];
otherwise it will use [func@GLib.log]. See
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <parameters>
        <parameter name="...">
          <doc xml:space="preserve">format string, followed by parameters to insert into the format string
  (as with `printf()`)</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="mkdir" c:identifier="g_mkdir" version="2.6">
      <doc xml:space="preserve">A wrapper for the POSIX mkdir() function. The mkdir() function
attempts to create a directory with the given name and permissions.
The mode argument is ignored on Windows.

See your C library manual for more details about mkdir().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the directory was successfully created, -1 if an error
   occurred</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">permissions to use for the newly created directory</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="mkdir_with_parents" c:identifier="g_mkdir_with_parents" version="2.8">
      <doc xml:space="preserve">Create a directory if it doesn't already exist. Create intermediate
parent directories as needed, too.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the directory already exists, or was successfully
created. Returns -1 if an error occurred, with errno set.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="pathname" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">permissions to use for newly created directories</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="mkdtemp" c:identifier="g_mkdtemp" version="2.30" introspectable="0">
      <doc xml:space="preserve">Creates a temporary directory in the current directory.

See the [`mkdtemp()`](man:mkdtemp(3)) documentation on most UNIX-like systems.

The parameter is a string that should follow the rules for
mkdtemp() templates, i.e. contain the string "XXXXXX".
g_mkdtemp() is slightly more flexible than mkdtemp() in that the
sequence does not have to occur at the very end of the template.
The X string will be modified to form the name of a directory that
didn't exist.
The string should be in the GLib file name encoding. Most importantly,
on Windows it should be in UTF-8.

If you are going to be creating a temporary directory inside the
directory returned by g_get_tmp_dir(), you might want to use
g_dir_make_tmp() instead.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">A pointer to @tmpl, which has been
  modified to hold the directory name.  In case of errors, %NULL is
  returned and %errno will be set.</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="tmpl" transfer-ownership="none">
          <doc xml:space="preserve">template directory name</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mkdtemp_full" c:identifier="g_mkdtemp_full" version="2.30" introspectable="0">
      <doc xml:space="preserve">Creates a temporary directory in the current directory.

See the [`mkdtemp()`](man:mkdtemp(3)) documentation on most UNIX-like systems.

The parameter is a string that should follow the rules for
mkdtemp() templates, i.e. contain the string "XXXXXX".
g_mkdtemp_full() is slightly more flexible than mkdtemp() in that the
sequence does not have to occur at the very end of the template
and you can pass a @mode. The X string will be modified to form
the name of a directory that didn't exist. The string should be
in the GLib file name encoding. Most importantly, on Windows it
should be in UTF-8.

If you are going to be creating a temporary directory inside the
directory returned by g_get_tmp_dir(), you might want to use
g_dir_make_tmp() instead.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">A pointer to @tmpl, which has been
  modified to hold the directory name. In case of errors, %NULL is
  returned, and %errno will be set.</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="tmpl" transfer-ownership="none">
          <doc xml:space="preserve">template directory name</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">permissions to create the temporary directory with</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="mkstemp" c:identifier="g_mkstemp" introspectable="0">
      <doc xml:space="preserve">Opens a temporary file in the current directory.

See the [`mkstemp()`](man:mkstemp(3)) documentation on most UNIX-like systems.

The parameter is a string that should follow the rules for
mkstemp() templates, i.e. contain the string "XXXXXX".
g_mkstemp() is slightly more flexible than mkstemp() in that the
sequence does not have to occur at the very end of the template.
The X string will be modified to form the name of a file that
didn't exist. The string should be in the GLib file name encoding.
Most importantly, on Windows it should be in UTF-8.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A file handle (as from open()) to the file
  opened for reading and writing. The file is opened in binary
  mode on platforms where there is a difference. The file handle
  should be closed with close(). In case of errors, -1 is
  returned and %errno will be set.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="tmpl" transfer-ownership="none">
          <doc xml:space="preserve">template filename</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mkstemp_full" c:identifier="g_mkstemp_full" version="2.22" introspectable="0">
      <doc xml:space="preserve">Opens a temporary file in the current directory.

See the [`mkstemp()`](man:mkstemp(3)) documentation on most UNIX-like systems.

The parameter is a string that should follow the rules for
mkstemp() templates, i.e. contain the string "XXXXXX".
g_mkstemp_full() is slightly more flexible than mkstemp()
in that the sequence does not have to occur at the very end of the
template and you can pass a @mode and additional @flags. The X
string will be modified to form the name of a file that didn't exist.
The string should be in the GLib file name encoding. Most importantly,
on Windows it should be in UTF-8.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A file handle (as from open()) to the file
  opened for reading and writing. The file handle should be
  closed with close(). In case of errors, -1 is returned
  and %errno will be set.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="tmpl" transfer-ownership="none">
          <doc xml:space="preserve">template filename</doc>
          <type name="filename" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags to pass to an open() call in addition to O_EXCL
  and O_CREAT, which are passed automatically</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">permissions to create the temporary file with</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="mutex_new" c:identifier="g_mutex_new" moved-to="Mutex.new" introspectable="0" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Allocates and initializes a new #GMutex.</doc>
      <doc-deprecated xml:space="preserve">GMutex can now be statically allocated, or embedded
in structures and initialised with g_mutex_init().</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated #GMutex. Use g_mutex_free() to free</doc>
        <type name="Mutex" c:type="GMutex*"/>
      </return-value>
    </function>
    <function-macro name="new" c:identifier="g_new" introspectable="0">
      <doc xml:space="preserve">Allocates @n_structs elements of type @struct_type.
The returned pointer is cast to a pointer to the given type.
If @n_structs is 0 it returns %NULL.
Care is taken to avoid overflow when calculating the size of the allocated block.

Since the returned pointer is already casted to the right type,
it is normally unnecessary to cast it explicitly, and doing
so might hide memory allocation errors.</doc>
      <parameters>
        <parameter name="struct_type">
          <doc xml:space="preserve">the type of the elements to allocate</doc>
        </parameter>
        <parameter name="n_structs">
          <doc xml:space="preserve">the number of elements to allocate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="new0" c:identifier="g_new0" introspectable="0">
      <doc xml:space="preserve">Allocates @n_structs elements of type @struct_type, initialized to 0's.
The returned pointer is cast to a pointer to the given type.
If @n_structs is 0 it returns %NULL.
Care is taken to avoid overflow when calculating the size of the allocated block.

Since the returned pointer is already casted to the right type,
it is normally unnecessary to cast it explicitly, and doing
so might hide memory allocation errors.</doc>
      <parameters>
        <parameter name="struct_type">
          <doc xml:space="preserve">the type of the elements to allocate.</doc>
        </parameter>
        <parameter name="n_structs">
          <doc xml:space="preserve">the number of elements to allocate.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="newa" c:identifier="g_newa" introspectable="0">
      <doc xml:space="preserve">Wraps g_alloca() in a more typesafe manner.

As mentioned in the documentation for g_alloca(), @n_structs must always be
entirely under the control of the program, or you may introduce a denial of
service vulnerability. In addition, the multiplication of @struct_type by
@n_structs is not checked, so an overflow may lead to a remote code execution
vulnerability.</doc>
      <parameters>
        <parameter name="struct_type">
          <doc xml:space="preserve">Type of memory chunks to be allocated</doc>
        </parameter>
        <parameter name="n_structs">
          <doc xml:space="preserve">Number of chunks to be allocated</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="newa0" c:identifier="g_newa0" version="2.72" introspectable="0">
      <doc xml:space="preserve">Wraps g_alloca0() in a more typesafe manner.</doc>
      <parameters>
        <parameter name="struct_type">
          <doc xml:space="preserve">the type of the elements to allocate.</doc>
        </parameter>
        <parameter name="n_structs">
          <doc xml:space="preserve">the number of elements to allocate.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="node_append" c:identifier="g_node_append" introspectable="0">
      <doc xml:space="preserve">Inserts a #GNode as the last child of the given parent.</doc>
      <parameters>
        <parameter name="parent">
          <doc xml:space="preserve">the #GNode to place the new #GNode under</doc>
        </parameter>
        <parameter name="node">
          <doc xml:space="preserve">the #GNode to insert</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="node_append_data" c:identifier="g_node_append_data" introspectable="0">
      <doc xml:space="preserve">Inserts a new #GNode as the last child of the given parent.</doc>
      <parameters>
        <parameter name="parent">
          <doc xml:space="preserve">the #GNode to place the new #GNode under</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">the data for the new #GNode</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="node_first_child" c:identifier="g_node_first_child" introspectable="0">
      <doc xml:space="preserve">Gets the first child of a #GNode.</doc>
      <parameters>
        <parameter name="node">
          <doc xml:space="preserve">a #GNode</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="node_insert_data" c:identifier="g_node_insert_data" introspectable="0">
      <doc xml:space="preserve">Inserts a new #GNode at the given position.</doc>
      <parameters>
        <parameter name="parent">
          <doc xml:space="preserve">the #GNode to place the new #GNode under</doc>
        </parameter>
        <parameter name="position">
          <doc xml:space="preserve">the position to place the new #GNode at. If position is -1,
    the new #GNode is inserted as the last child of @parent</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">the data for the new #GNode</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="node_insert_data_after" c:identifier="g_node_insert_data_after" introspectable="0">
      <doc xml:space="preserve">Inserts a new #GNode after the given sibling.</doc>
      <parameters>
        <parameter name="parent">
          <doc xml:space="preserve">the #GNode to place the new #GNode under</doc>
        </parameter>
        <parameter name="sibling">
          <doc xml:space="preserve">the sibling #GNode to place the new #GNode after</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">the data for the new #GNode</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="node_insert_data_before" c:identifier="g_node_insert_data_before" introspectable="0">
      <doc xml:space="preserve">Inserts a new #GNode before the given sibling.</doc>
      <parameters>
        <parameter name="parent">
          <doc xml:space="preserve">the #GNode to place the new #GNode under</doc>
        </parameter>
        <parameter name="sibling">
          <doc xml:space="preserve">the sibling #GNode to place the new #GNode before</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">the data for the new #GNode</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="node_next_sibling" c:identifier="g_node_next_sibling" introspectable="0">
      <doc xml:space="preserve">Gets the next sibling of a #GNode.</doc>
      <parameters>
        <parameter name="node">
          <doc xml:space="preserve">a #GNode</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="node_pop_allocator" c:identifier="g_node_pop_allocator" moved-to="Node.pop_allocator" deprecated="1" deprecated-version="2.10">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function-macro name="node_prepend_data" c:identifier="g_node_prepend_data" introspectable="0">
      <doc xml:space="preserve">Inserts a new #GNode as the first child of the given parent.</doc>
      <parameters>
        <parameter name="parent">
          <doc xml:space="preserve">the #GNode to place the new #GNode under</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">the data for the new #GNode</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="node_prev_sibling" c:identifier="g_node_prev_sibling" introspectable="0">
      <doc xml:space="preserve">Gets the previous sibling of a #GNode.</doc>
      <parameters>
        <parameter name="node">
          <doc xml:space="preserve">a #GNode</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="node_push_allocator" c:identifier="g_node_push_allocator" moved-to="Node.push_allocator" deprecated="1" deprecated-version="2.10">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="allocator" transfer-ownership="none">
          <type name="Allocator" c:type="GAllocator*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="ntohl" c:identifier="g_ntohl" introspectable="0">
      <doc xml:space="preserve">Converts a 32-bit integer value from network to host byte order.</doc>
      <parameters>
        <parameter name="val">
          <doc xml:space="preserve">a 32-bit integer value in network byte order</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ntohs" c:identifier="g_ntohs" introspectable="0">
      <doc xml:space="preserve">Converts a 16-bit integer value from network to host byte order.</doc>
      <parameters>
        <parameter name="val">
          <doc xml:space="preserve">a 16-bit integer value in network byte order</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="nullify_pointer" c:identifier="g_nullify_pointer">
      <doc xml:space="preserve">Set the pointer at the specified location to %NULL.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="nullify_location" transfer-ownership="none">
          <doc xml:space="preserve">the memory address of the pointer.</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="number_parser_error_quark" c:identifier="g_number_parser_error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="on_error_query" c:identifier="g_on_error_query">
      <doc xml:space="preserve">Prompts the user with
`[E]xit, [H]alt, show [S]tack trace or [P]roceed`.
This function is intended to be used for debugging use only.
The following example shows how it can be used together with
the g_log() functions.

|[&lt;!-- language="C" --&gt;
#include &lt;glib.h&gt;

static void
log_handler (const gchar   *log_domain,
             GLogLevelFlags log_level,
             const gchar   *message,
             gpointer       user_data)
{
  g_log_default_handler (log_domain, log_level, message, user_data);

  g_on_error_query (MY_PROGRAM_NAME);
}

int
main (int argc, char *argv[])
{
  g_log_set_handler (MY_LOG_DOMAIN,
                     G_LOG_LEVEL_WARNING |
                     G_LOG_LEVEL_ERROR |
                     G_LOG_LEVEL_CRITICAL,
                     log_handler,
                     NULL);
  ...
]|

If "[E]xit" is selected, the application terminates with a call
to _exit(0).

If "[S]tack" trace is selected, g_on_error_stack_trace() is called.
This invokes gdb, which attaches to the current process and shows
a stack trace. The prompt is then shown again.

If "[P]roceed" is selected, the function returns.

This function may cause different actions on non-UNIX platforms.

On Windows consider using the `G_DEBUGGER` environment
variable (see [Running GLib Applications](running.html)) and
calling g_on_error_stack_trace() instead.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="prg_name" transfer-ownership="none">
          <doc xml:space="preserve">the program name, needed by gdb for the "[S]tack trace"
    option. If @prg_name is %NULL, g_get_prgname() is called to get
    the program name (which will work correctly if gdk_init() or
    gtk_init() has been called)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="on_error_stack_trace" c:identifier="g_on_error_stack_trace">
      <doc xml:space="preserve">Invokes gdb, which attaches to the current process and shows a
stack trace. Called by g_on_error_query() when the "[S]tack trace"
option is selected. You can get the current process's program name
with g_get_prgname(), assuming that you have called gtk_init() or
gdk_init().

This function may cause different actions on non-UNIX platforms.

When running on Windows, this function is *not* called by
g_on_error_query(). If called directly, it will raise an
exception, which will crash the program. If the `G_DEBUGGER` environment
variable is set, a debugger will be invoked to attach and
handle that exception (see [Running GLib Applications](running.html)).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="prg_name" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the program name, needed by gdb for the
  "[S]tack trace" option, or `NULL` to use a default string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="once" c:identifier="g_once" version="2.4" introspectable="0">
      <doc xml:space="preserve">The first call to this routine by a process with a given #GOnce
struct calls @func with the given argument. Thereafter, subsequent
calls to g_once()  with the same #GOnce struct do not call @func
again, but return the stored result of the first call. On return
from g_once(), the status of @once will be %G_ONCE_STATUS_READY.

For example, a mutex or a thread-specific data key must be created
exactly once. In a threaded environment, calling g_once() ensures
that the initialization is serialized across multiple threads.

Calling g_once() recursively on the same #GOnce struct in
@func will lead to a deadlock.

|[&lt;!-- language="C" --&gt;
  gpointer
  get_debug_flags (void)
  {
    static GOnce my_once = G_ONCE_INIT;

    g_once (&amp;my_once, parse_debug_flags, NULL);

    return my_once.retval;
  }
]|</doc>
      <parameters>
        <parameter name="once">
          <doc xml:space="preserve">a #GOnce structure</doc>
        </parameter>
        <parameter name="func">
          <doc xml:space="preserve">the #GThreadFunc function associated to @once. This function
       is called only once, regardless of the number of times it and
       its associated #GOnce struct are passed to g_once().</doc>
        </parameter>
        <parameter name="arg">
          <doc xml:space="preserve">data to be passed to @func</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="once_init_enter" c:identifier="g_once_init_enter" moved-to="Once.init_enter" version="2.14">
      <doc xml:space="preserve">Function to be called when starting a critical initialization
section. The argument @location must point to a static
0-initialized variable that will be set to a value other than 0 at
the end of the initialization section. In combination with
g_once_init_leave() and the unique address @value_location, it can
be ensured that an initialization section will be executed only once
during a program's life time, and that concurrent threads are
blocked until initialization completed. To be used in constructs
like this:

|[&lt;!-- language="C" --&gt;
  static gsize initialization_value = 0;

  if (g_once_init_enter (&amp;initialization_value))
    {
      gsize setup_value = 42; // initialization code here

      g_once_init_leave (&amp;initialization_value, setup_value);
    }

  // use initialization_value here
]|

While @location has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the initialization section should be entered,
    %FALSE and blocks otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="location" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">location of a static initializable variable
   containing 0</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="once_init_enter_impl" c:identifier="g_once_init_enter_impl" moved-to="Once.init_enter_impl">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="location" transfer-ownership="none">
          <type name="gsize" c:type="volatile gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="once_init_enter_pointer" c:identifier="g_once_init_enter_pointer" moved-to="Once.init_enter_pointer" version="2.80">
      <doc xml:space="preserve">This functions behaves in the same way as g_once_init_enter(), but can
can be used to initialize pointers (or #guintptr) instead of #gsize.

|[&lt;!-- language="C" --&gt;
  static MyStruct *interesting_struct = NULL;

  if (g_once_init_enter_pointer (&amp;interesting_struct))
    {
      MyStruct *setup_value = allocate_my_struct (); // initialization code here

      g_once_init_leave_pointer (&amp;interesting_struct, g_steal_pointer (&amp;setup_value));
    }

  // use interesting_struct here
]|</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the initialization section should be entered,
    %FALSE and blocks otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="location" transfer-ownership="none">
          <doc xml:space="preserve">location of a static initializable variable
   containing `NULL`</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="once_init_leave" c:identifier="g_once_init_leave" moved-to="Once.init_leave" version="2.14">
      <doc xml:space="preserve">Counterpart to g_once_init_enter(). Expects a location of a static
0-initialized initialization variable, and an initialization value
other than 0. Sets the variable to the initialization value, and
releases concurrent threads blocking in g_once_init_enter() on this
initialization variable.

While @location has a `volatile` qualifier, this is a historical artifact and
the pointer passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="location" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">location of a static initializable variable
   containing 0</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">new non-0 value for `*value_location`</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="once_init_leave_pointer" c:identifier="g_once_init_leave_pointer" moved-to="Once.init_leave_pointer" version="2.80">
      <doc xml:space="preserve">Counterpart to g_once_init_enter_pointer(). Expects a location of a static
`NULL`-initialized initialization variable, and an initialization value
other than `NULL`. Sets the variable to the initialization value, and
releases concurrent threads blocking in g_once_init_enter_pointer() on this
initialization variable.

This functions behaves in the same way as g_once_init_leave(), but
can be used to initialize pointers (or #guintptr) instead of #gsize.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="location" transfer-ownership="none">
          <doc xml:space="preserve">location of a static initializable variable
   containing `NULL`</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="result" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">new non-`NULL` value for `*location`</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="open" c:identifier="g_open" version="2.6">
      <doc xml:space="preserve">A wrapper for the POSIX open() function. The open() function is
used to convert a pathname into a file descriptor.

On POSIX systems file descriptors are implemented by the operating
system. On Windows, it's the C library that implements open() and
file descriptors. The actual Win32 API for opening files is quite
different, see MSDN documentation for CreateFile(). The Win32 API
uses file handles, which are more randomish integers, not small
integers like file descriptors.

Because file descriptors are specific to the C library on Windows,
the file descriptor returned by this function makes sense only to
functions in the same C library. Thus if the GLib-using code uses a
different C library than GLib does, the file descriptor returned by
this function cannot be passed to C library functions like write()
or read().

See your C library manual for more details about open().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new file descriptor, or -1 if an error occurred.
    The return value can be used exactly like the return value
    from open().</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">as in open()</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">as in open()</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="option_error_quark" c:identifier="g_option_error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="parse_debug_string" c:identifier="g_parse_debug_string">
      <doc xml:space="preserve">Parses a string containing debugging options
into a %guint containing bit flags. This is used
within GDK and GTK to parse the debug options passed on the
command line or through environment variables.

If @string is equal to "all", all flags are set. Any flags
specified along with "all" in @string are inverted; thus,
"all,foo,bar" or "foo,bar,all" sets all flags except those
corresponding to "foo" and "bar".

If @string is equal to "help", all the available keys in @keys
are printed out to standard error.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the combined set of bit flags.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a list of debug options separated by colons, spaces, or
commas, or %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="keys" transfer-ownership="none">
          <doc xml:space="preserve">pointer to an array of #GDebugKey which associate
    strings with bit flags.</doc>
          <array length="2" zero-terminated="0" c:type="const GDebugKey*">
            <type name="DebugKey" c:type="GDebugKey"/>
          </array>
        </parameter>
        <parameter name="nkeys" transfer-ownership="none">
          <doc xml:space="preserve">the number of #GDebugKeys in the array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_buf_equal" c:identifier="g_path_buf_equal" moved-to="PathBuf.equal" version="2.76">
      <doc xml:space="preserve">Compares two path buffers for equality and returns `TRUE`
if they are equal.

The paths inside the path buffers are not going to be normalized,
so `X/Y/Z/A/..`, `X/./Y/Z` and `X/Y/Z` are not going to be considered
equal.

This function can be passed to g_hash_table_new() as the
`key_equal_func` parameter.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if the two path buffers are equal,
  and `FALSE` otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <doc xml:space="preserve">a path buffer to compare</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <doc xml:space="preserve">a path buffer to compare</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_get_basename" c:identifier="g_path_get_basename">
      <doc xml:space="preserve">Gets the last component of the filename.

If @file_name ends with a directory separator it gets the component
before the last slash. If @file_name consists only of directory
separators (and on Windows, possibly a drive letter), a single
separator is returned. If @file_name is empty, it gets ".".</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string
  containing the last component of the filename</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="file_name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the file</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_get_dirname" c:identifier="g_path_get_dirname">
      <doc xml:space="preserve">Gets the directory components of a file name. For example, the directory
component of `/usr/bin/test` is `/usr/bin`. The directory component of `/`
is `/`.

If the file name has no directory components "." is returned.
The returned string should be freed when no longer needed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the directory components of the file</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="file_name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the file</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_is_absolute" c:identifier="g_path_is_absolute">
      <doc xml:space="preserve">Returns %TRUE if the given @file_name is an absolute file name.
Note that this is a somewhat vague concept on Windows.

On POSIX systems, an absolute file name is well-defined. It always
starts from the single root directory. For example "/usr/local".

On Windows, the concepts of current drive and drive-specific
current directory introduce vagueness. This function interprets as
an absolute file name one that either begins with a directory
separator such as "\Users\tml" or begins with the root on a drive,
for example "C:\Windows". The first case also includes UNC paths
such as "\\\\myserver\docs\foo". In all cases, either slashes or
backslashes are accepted.

Note that a file name relative to the current drive root does not
truly specify a file uniquely over time and across processes, as
the current drive is a per-process value and can be changed.

File names relative the current directory on some specific drive,
such as "D:foo/bar", are not interpreted as absolute by this
function, but they obviously are not relative to the normal current
directory as returned by getcwd() or g_get_current_dir()
either. Such paths should be avoided, or need to be handled using
Windows-specific code.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @file_name is absolute</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="file_name" transfer-ownership="none">
          <doc xml:space="preserve">a file name</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_skip_root" c:identifier="g_path_skip_root">
      <doc xml:space="preserve">Returns a pointer into @file_name after the root component,
i.e. after the "/" in UNIX or "C:\" under Windows. If @file_name
is not an absolute path it returns %NULL.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer into @file_name after the
    root component</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="file_name" transfer-ownership="none">
          <doc xml:space="preserve">a file name</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pattern_match" c:identifier="g_pattern_match" introspectable="0" deprecated="1" deprecated-version="2.70">
      <doc xml:space="preserve">Matches a string against a compiled pattern.

Passing the correct
length of the string given is mandatory. The reversed string can be
omitted by passing `NULL`, this is more efficient if the reversed
version of the string to be matched is not at hand, as
`g_pattern_match()` will only construct it if the compiled pattern
requires reverse matches.

Note that, if the user code will (possibly) match a string against a
multitude of patterns containing wildcards, chances are high that
some patterns will require a reversed string. In this case, it&#x2019;s
more efficient to provide the reversed string to avoid multiple
constructions thereof in the various calls to `g_pattern_match()`.

Note also that the reverse of a UTF-8 encoded string can in general
not be obtained by [func@GLib.strreverse]. This works only if the string
does not contain any multibyte characters. GLib offers the
[func@GLib.utf8_strreverse] function to reverse UTF-8 encoded strings.</doc>
      <doc-deprecated xml:space="preserve">Use [method@GLib.PatternSpec.match] instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @string matches @pspec</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:space="preserve">a #GPatternSpec</doc>
          <type name="PatternSpec" c:type="GPatternSpec*"/>
        </parameter>
        <parameter name="string_length" transfer-ownership="none">
          <doc xml:space="preserve">the length of @string (in bytes, i.e. `strlen()`,
   not [func@GLib.utf8_strlen])</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the UTF-8 encoded string to match</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="string_reversed" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the reverse of @string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pattern_match_simple" c:identifier="g_pattern_match_simple">
      <doc xml:space="preserve">Matches a string against a pattern given as a string.

If this
function is to be called in a loop, it&#x2019;s more efficient to compile
the pattern once with [ctor@GLib.PatternSpec.new] and call
[method@GLib.PatternSpec.match_string] repeatedly.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @string matches @pspec</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve">the UTF-8 encoded pattern</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the UTF-8 encoded string to match</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pattern_match_string" c:identifier="g_pattern_match_string" introspectable="0" deprecated="1" deprecated-version="2.70">
      <doc xml:space="preserve">Matches a string against a compiled pattern.

If the string is to be
matched against more than one pattern, consider using
[method@GLib.PatternSpec.match] instead while supplying the reversed string.</doc>
      <doc-deprecated xml:space="preserve">Use [method@GLib.PatternSpec.match_string] instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @string matches @pspec</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:space="preserve">a #GPatternSpec</doc>
          <type name="PatternSpec" c:type="GPatternSpec*"/>
        </parameter>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the UTF-8 encoded string to match</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pointer_bit_lock" c:identifier="g_pointer_bit_lock" version="2.30">
      <doc xml:space="preserve">This is equivalent to g_bit_lock, but working on pointers (or other
pointer-sized values).

For portability reasons, you may only lock on the bottom 32 bits of
the pointer.

While @address has a `volatile` qualifier, this is a historical
artifact and the argument passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="lock_bit" transfer-ownership="none">
          <doc xml:space="preserve">a bit value between 0 and 31</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="pointer_bit_lock_and_get" c:identifier="g_pointer_bit_lock_and_get" version="2.80">
      <doc xml:space="preserve">This is equivalent to g_bit_lock, but working on pointers (or other
pointer-sized values).

For portability reasons, you may only lock on the bottom 32 bits of
the pointer.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="lock_bit" transfer-ownership="none">
          <doc xml:space="preserve">a bit value between 0 and 31</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="out_ptr" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">returns the set pointer atomically.
  This is the value after setting the lock, it thus always has the
  lock bit set, while previously @address had the lockbit unset.
  You may also use g_pointer_bit_lock_mask_ptr() to clear the lock bit.</doc>
          <type name="guintptr" c:type="guintptr*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pointer_bit_lock_mask_ptr" c:identifier="g_pointer_bit_lock_mask_ptr" version="2.80">
      <doc xml:space="preserve">This mangles @ptr as g_pointer_bit_lock() and g_pointer_bit_unlock()
do.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the mangled pointer.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="ptr" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the pointer to mask</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="lock_bit" transfer-ownership="none">
          <doc xml:space="preserve">the bit to set/clear. If set to `G_MAXUINT`, the
  lockbit is taken from @preserve_ptr or @ptr (depending on @preserve_mask).</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="set" transfer-ownership="none">
          <doc xml:space="preserve">whether to set (lock) the bit or unset (unlock). This
  has no effect, if @lock_bit is set to `G_MAXUINT`.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="preserve_mask" transfer-ownership="none">
          <doc xml:space="preserve">if non-zero, a bit-mask for @preserve_ptr. The
  @preserve_mask bits from @preserve_ptr are set in the result.
  Note that the @lock_bit bit will be always set according to @set,
  regardless of @preserve_mask and @preserve_ptr (unless @lock_bit is
  `G_MAXUINT`).</doc>
          <type name="guintptr" c:type="guintptr"/>
        </parameter>
        <parameter name="preserve_ptr" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">if @preserve_mask is non-zero, the bits
  from this pointer are set in the result.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="pointer_bit_trylock" c:identifier="g_pointer_bit_trylock" version="2.30">
      <doc xml:space="preserve">This is equivalent to g_bit_trylock(), but working on pointers (or
other pointer-sized values).

For portability reasons, you may only lock on the bottom 32 bits of
the pointer.

While @address has a `volatile` qualifier, this is a historical
artifact and the argument passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the lock was acquired</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="lock_bit" transfer-ownership="none">
          <doc xml:space="preserve">a bit value between 0 and 31</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="pointer_bit_unlock" c:identifier="g_pointer_bit_unlock" version="2.30">
      <doc xml:space="preserve">This is equivalent to g_bit_unlock, but working on pointers (or other
pointer-sized values).

For portability reasons, you may only lock on the bottom 32 bits of
the pointer.

While @address has a `volatile` qualifier, this is a historical
artifact and the argument passed to it should not be `volatile`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="lock_bit" transfer-ownership="none">
          <doc xml:space="preserve">a bit value between 0 and 31</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="pointer_bit_unlock_and_set" c:identifier="g_pointer_bit_unlock_and_set" version="2.80">
      <doc xml:space="preserve">This is equivalent to g_pointer_bit_unlock() and atomically setting
the pointer value.

Note that the lock bit will be cleared from the pointer. If the unlocked
pointer that was set is not identical to @ptr, an assertion fails. In other
words, @ptr must have @lock_bit unset. This also means, you usually can
only use this on the lowest bits.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="address" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #gpointer-sized value</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="lock_bit" transfer-ownership="none">
          <doc xml:space="preserve">a bit value between 0 and 31</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="ptr" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the new pointer value to set</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="preserve_mask" transfer-ownership="none">
          <doc xml:space="preserve">if non-zero, those bits of the current pointer in @address
  are preserved.
  Note that the @lock_bit bit will be always unset regardless of
  @ptr, @preserve_mask and the currently set value in @address.</doc>
          <type name="guintptr" c:type="guintptr"/>
        </parameter>
      </parameters>
    </function>
    <function name="poll" c:identifier="g_poll" version="2.20">
      <doc xml:space="preserve">Polls @fds, as with the poll() system call, but portably. (On
systems that don't have poll(), it is emulated using select().)
This is used internally by #GMainContext, but it can be called
directly if you need to block until a file descriptor is ready, but
don't want to run the full main loop.

Each element of @fds is a #GPollFD describing a single file
descriptor to poll. The @fd field indicates the file descriptor,
and the @events field indicates the events to poll for. On return,
the @revents fields will be filled with the events that actually
occurred.

On POSIX systems, the file descriptors in @fds can be any sort of
file descriptor, but the situation is much more complicated on
Windows. If you need to use g_poll() in code that has to run on
Windows, the easiest solution is to construct all of your
#GPollFDs with g_io_channel_win32_make_pollfd().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of entries in @fds whose @revents fields
were filled in, or 0 if the operation timed out, or -1 on error or
if the call was interrupted.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="fds" transfer-ownership="none">
          <doc xml:space="preserve">file descriptors to poll</doc>
          <type name="PollFD" c:type="GPollFD*"/>
        </parameter>
        <parameter name="nfds" transfer-ownership="none">
          <doc xml:space="preserve">the number of file descriptors in @fds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="timeout" transfer-ownership="none">
          <doc xml:space="preserve">amount of time to wait, in milliseconds, or -1 to wait forever</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="prefix_error" c:identifier="g_prefix_error" version="2.16" introspectable="0">
      <doc xml:space="preserve">Formats a string according to @format and prefix it to an existing
error message. If @err is %NULL (ie: no error variable) then do
nothing.

If `*err` is %NULL (ie: an error variable is present but there is no
error condition) then also do nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="err" direction="inout" caller-allocates="0" transfer-ownership="full" nullable="1" allow-none="1" optional="1">
          <doc xml:space="preserve">a return location for a #GError</doc>
          <type name="Error" c:type="GError**"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">arguments to @format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="prefix_error_literal" c:identifier="g_prefix_error_literal" version="2.70">
      <doc xml:space="preserve">Prefixes @prefix to an existing error message. If @err or `*err` is
%NULL (i.e.: no error variable) then do nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="err" direction="inout" caller-allocates="0" transfer-ownership="full" nullable="1" allow-none="1" optional="1">
          <doc xml:space="preserve">a return location for a #GError, or %NULL</doc>
          <type name="Error" c:type="GError**"/>
        </parameter>
        <parameter name="prefix" transfer-ownership="none">
          <doc xml:space="preserve">string to prefix @err with</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="print" c:identifier="g_print" introspectable="0">
      <doc xml:space="preserve">Outputs a formatted message via the print handler.

The default print handler outputs the encoded message to `stdout`, without
appending a trailing new-line character. Typically, @format should end with
its own new-line character.

This function should not be used from within libraries for debugging
messages, since it may be redirected by applications to special
purpose message windows or even files. Instead, libraries should
use [func@GLib.log], [func@GLib.log_structured], or the convenience macros
[func@GLib.message], [func@GLib.warning] and [func@GLib.error].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the message format. See the `printf()` documentation</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the parameters to insert into the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="printerr" c:identifier="g_printerr" introspectable="0">
      <doc xml:space="preserve">Outputs a formatted message via the error message handler.

The default handler outputs the encoded message to `stderr`, without appending
a trailing new-line character. Typically, @format should end with its own
new-line character.

This function should not be used from within libraries.
Instead [func@GLib.log] or [func@GLib.log_structured] should be used, or the convenience
macros [func@GLib.message], [func@GLib.warning] and [func@GLib.error].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the message format. See the `printf()` documentation</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the parameters to insert into the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="printf" c:identifier="g_printf" version="2.2" introspectable="0">
      <doc xml:space="preserve">An implementation of the standard `printf()` function which supports
positional parameters, as specified in the Single Unix Specification.

As with the standard `printf()`, this does not automatically append a trailing
new-line character to the message, so typically @format should end with its
own new-line character.

`glib/gprintf.h` must be explicitly included in order to use this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes printed</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a standard `printf()` format string, but notice
  [string precision pitfalls](string-utils.html#string-precision-pitfalls)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the arguments to insert in the output</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="printf_string_upper_bound" c:identifier="g_printf_string_upper_bound" introspectable="0">
      <doc xml:space="preserve">Calculates the maximum space needed to store the output
of the `sprintf()` function.

If @format or @args are invalid, `0` is returned. This could happen if, for
example, @format contains an `%lc` or `%ls` placeholder and @args contains a
wide character which cannot be represented in multibyte encoding. `0`
can also be returned legitimately if, for example, @format is `%s` and @args
is an empty string. The caller is responsible for differentiating these two
return cases if necessary. It is recommended to not use `%lc` or `%ls`
placeholders in any case, as their behaviour is locale-dependent.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the maximum space needed to store the formatted string, or `0` on error</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the format string. See the `printf()` documentation</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">the parameters to be inserted into the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="private_new" c:identifier="g_private_new" moved-to="Private.new" introspectable="0" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Creates a new #GPrivate.</doc>
      <doc-deprecated xml:space="preserve">dynamic allocation of #GPrivate is a bad idea.  Use
                 static storage and G_PRIVATE_INIT() instead.</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated #GPrivate (which can never be destroyed)</doc>
        <type name="Private" c:type="GPrivate*"/>
      </return-value>
      <parameters>
        <parameter name="notify" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">a #GDestroyNotify</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="propagate_error" c:identifier="g_propagate_error">
      <doc xml:space="preserve">If @dest is %NULL, free @src; otherwise, moves @src into `*dest`.
The error variable @dest points to must be %NULL.

@src must be non-%NULL.

Note that @src is no longer valid after this call. If you want
to keep using the same GError*, you need to set it to %NULL
after calling this function on it.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">error return location</doc>
          <type name="Error" c:type="GError**"/>
        </parameter>
        <parameter name="src" transfer-ownership="full">
          <doc xml:space="preserve">error to move into the return location</doc>
          <type name="Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="propagate_prefixed_error" c:identifier="g_propagate_prefixed_error" version="2.16" introspectable="0">
      <doc xml:space="preserve">If @dest is %NULL, free @src; otherwise, moves @src into `*dest`.
`*dest` must be %NULL. After the move, add a prefix as with
g_prefix_error().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">error return location</doc>
          <type name="Error" c:type="GError**"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">error to move into the return location</doc>
          <type name="Error" c:type="GError*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">arguments to @format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="ptr_array_find" c:identifier="g_ptr_array_find" moved-to="PtrArray.find" version="2.54" introspectable="0">
      <doc xml:space="preserve">Checks whether @needle exists in @haystack. If the element is found, true
is returned and the element&#x2019;s index is returned in @index_ (if non-`NULL`).
Otherwise, false is returned and @index_ is undefined. If @needle exists
multiple times in @haystack, the index of the first instance is returned.

This does pointer comparisons only. If you want to use more complex equality
checks, such as string comparisons, use
[func@GLib.PtrArray.find_with_equal_func].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if @needle is one of the elements of @haystack; false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="haystack" transfer-ownership="none">
          <doc xml:space="preserve">the pointer array to be searched</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="needle" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the pointer to look for</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="index_" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the return location for the index of
   the element, if found</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ptr_array_find_with_equal_func" c:identifier="g_ptr_array_find_with_equal_func" moved-to="PtrArray.find_with_equal_func" version="2.54" introspectable="0">
      <doc xml:space="preserve">Checks whether @needle exists in @haystack, using the given @equal_func.
If the element is found, true is returned and the element&#x2019;s index is
returned in @index_ (if non-`NULL`). Otherwise, false is returned and @index_
is undefined. If @needle exists multiple times in @haystack, the index of
the first instance is returned.

@equal_func is called with the element from the array as its first parameter,
and @needle as its second parameter. If @equal_func is `NULL`, pointer
equality is used.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if @needle is one of the elements of @haystack; false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="haystack" transfer-ownership="none">
          <doc xml:space="preserve">the pointer array to be searched</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="needle" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the pointer to look for</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="equal_func" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the function to call for each element, which should
   return true when the desired element is found; or `NULL` to use pointer
   equality</doc>
          <type name="EqualFunc" c:type="GEqualFunc"/>
        </parameter>
        <parameter name="index_" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">the return location for the index of
   the element, if found</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="ptr_array_index" c:identifier="g_ptr_array_index" introspectable="0">
      <doc xml:space="preserve">Returns the pointer at the given index of the pointer array.

This does not perform bounds checking on the given @index_,
so you are responsible for checking it against the array length.</doc>
      <parameters>
        <parameter name="array">
          <doc xml:space="preserve">a pointer array</doc>
        </parameter>
        <parameter name="index_">
          <doc xml:space="preserve">the index of the pointer to return</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="ptr_array_new_from_array" c:identifier="g_ptr_array_new_from_array" moved-to="PtrArray.new_from_array" version="2.76" introspectable="0">
      <doc xml:space="preserve">Creates a new `GPtrArray`, copying @len pointers from @data, and setting
the array&#x2019;s reference count to 1.

This avoids having to manually add each element one by one.

If @copy_func is provided, then it is used to copy each element before
adding them to the new array. If it is `NULL` then the pointers are copied
directly.

It also sets @element_free_func for freeing each element when the array is
destroyed either via [func@GLib.PtrArray.unref], when
[func@GLib.PtrArray.free] is called with @free_segment set to true or when
removing elements.

Do not use it if @len is greater than [`G_MAXUINT`](types.html#guint).
`GPtrArray` stores the length of its data in `guint`, which may be shorter
than `gsize`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new `GPtrArray`</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">an array of pointers</doc>
          <array length="1" zero-terminated="0" c:type="gpointer*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the number of pointers in @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="copy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="3" destroy="4">
          <doc xml:space="preserve">a copy function used to copy every element in the
  array</doc>
          <type name="CopyFunc" c:type="GCopyFunc"/>
        </parameter>
        <parameter name="copy_func_user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the user data passed to @copy_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">a function to free elements on @array
  destruction</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="ptr_array_new_from_null_terminated_array" c:identifier="g_ptr_array_new_from_null_terminated_array" moved-to="PtrArray.new_from_null_terminated_array" version="2.76" introspectable="0">
      <doc xml:space="preserve">Creates a new `GPtrArray` copying the pointers from @data after having
computed the length of it and with a reference count of 1.
This avoids having to manually add each element one by one.
If @copy_func is provided, then it is used to copy the data in the new
array.
It also sets @element_free_func for freeing each element when the array is
destroyed either via [func@GLib.PtrArray.unref], when
[func@GLib.PtrArray.free] is called with @free_segment set to true or when
removing elements.

Do not use it if the @data has more than [`G_MAXUINT`](types.html#guint)
elements. `GPtrArray` stores the length of its data in `guint`, which may be
shorter than `gsize`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new `GPtrArray`</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">an array of
  pointers, `NULL` terminated</doc>
          <array c:type="gpointer*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="copy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="2" destroy="3">
          <doc xml:space="preserve">a copy function used to copy every element in the
  array</doc>
          <type name="CopyFunc" c:type="GCopyFunc"/>
        </parameter>
        <parameter name="copy_func_user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the user data passed to @copy_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">a function to free elements on @array
  destruction</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="ptr_array_new_take" c:identifier="g_ptr_array_new_take" moved-to="PtrArray.new_take" version="2.76" introspectable="0">
      <doc xml:space="preserve">Creates a new `GPtrArray` with @data as pointers, @len as length and a
reference count of 1.

This avoids having to copy such data manually.
After this call, @data belongs to the `GPtrArray` and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with [func@GLib.free].

It also sets @element_free_func for freeing each element when the array is
destroyed either via [func@GLib.PtrArray.unref], when
[func@GLib.PtrArray.free] is called with @free_segment set to true or when
removing elements.

Do not use it if @len is greater than [`G_MAXUINT`](types.html#guint).
`GPtrArray` stores the length of its data in `guint`, which may be shorter
than `gsize`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new `GPtrArray`</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1">
          <doc xml:space="preserve">an array of pointers</doc>
          <array length="1" zero-terminated="0" c:type="gpointer*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the number of pointers in @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">a function to free elements on @array
  destruction</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="ptr_array_new_take_null_terminated" c:identifier="g_ptr_array_new_take_null_terminated" moved-to="PtrArray.new_take_null_terminated" version="2.76" introspectable="0">
      <doc xml:space="preserve">Creates a new `GPtrArray` with @data as pointers, computing the length of it
and setting the reference count to 1.

This avoids having to copy such data manually.
After this call, @data belongs to the `GPtrArray` and may no longer be
modified by the caller. The memory of @data has to be dynamically
allocated and will eventually be freed with [func@GLib.free].

The length is calculated by iterating through @data until the first `NULL`
element is found.

It also sets @element_free_func for freeing each element when the array is
destroyed either via [func@GLib.PtrArray.unref], when
[func@GLib.PtrArray.free] is called with @free_segment set to true or when
removing elements.

Do not use it if the @data length is greater than
[`G_MAXUINT`](types.html#guint). `GPtrArray` stores the length of its data
in `guint`, which may be shorter than `gsize`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new `GPtrArray`</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1">
          <doc xml:space="preserve">an array
 of pointers, `NULL` terminated</doc>
          <array c:type="gpointer*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">a function to free elements on @array
  destruction</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="qsort_with_data" c:identifier="g_qsort_with_data" deprecated="1" deprecated-version="2.82">
      <doc xml:space="preserve">This is just like the standard C [`qsort()`](man:qsort(3)) function, but
the comparison routine accepts a user data argument
(like [`qsort_r()`](man:qsort_r(3))).

Unlike `qsort()`, this is guaranteed to be a stable sort (since GLib 2.32).</doc>
      <doc-deprecated xml:space="preserve">`total_elems` is too small to represent larger arrays; use
  [func@GLib.sort_array] instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pbase" transfer-ownership="none">
          <doc xml:space="preserve">start of array to sort</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="total_elems" transfer-ownership="none">
          <doc xml:space="preserve">elements in the array</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">size of each element</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="compare_func" transfer-ownership="none" scope="call" closure="4">
          <doc xml:space="preserve">function to compare elements</doc>
          <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @compare_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="quark_from_static_string" c:identifier="g_quark_from_static_string">
      <doc xml:space="preserve">Gets the #GQuark identifying the given (static) string. If the
string does not currently have an associated #GQuark, a new #GQuark
is created, linked to the given string.

Note that this function is identical to g_quark_from_string() except
that if a new #GQuark is created the string itself is used rather
than a copy. This saves memory, but can only be used if the string
will continue to exist until the program terminates. It can be used
with statically allocated strings in the main program, but not with
statically allocated memory in dynamically loaded modules, if you
expect to ever unload the module again (e.g. do not use this
function in GTK theme engines).

This function must not be used before library constructors have finished
running. In particular, this means it cannot be used to initialize global
variables in C++.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GQuark identifying the string, or 0 if @string is %NULL</doc>
        <type name="Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="quark_from_string" c:identifier="g_quark_from_string">
      <doc xml:space="preserve">Gets the #GQuark identifying the given string. If the string does
not currently have an associated #GQuark, a new #GQuark is created,
using a copy of the string.

This function must not be used before library constructors have finished
running. In particular, this means it cannot be used to initialize global
variables in C++.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GQuark identifying the string, or 0 if @string is %NULL</doc>
        <type name="Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="quark_to_string" c:identifier="g_quark_to_string">
      <doc xml:space="preserve">Gets the string associated with the given #GQuark.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the string associated with the #GQuark</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="quark" transfer-ownership="none">
          <doc xml:space="preserve">a #GQuark.</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="quark_try_string" c:identifier="g_quark_try_string">
      <doc xml:space="preserve">Gets the #GQuark associated with the given string, or 0 if string is
%NULL or it has no associated #GQuark.

If you want the GQuark to be created if it doesn't already exist,
use g_quark_from_string() or g_quark_from_static_string().

This function must not be used before library constructors have finished
running.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GQuark associated with the string, or 0 if @string is
    %NULL or there is no #GQuark associated with it</doc>
        <type name="Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="rand_boolean" c:identifier="g_rand_boolean" introspectable="0">
      <doc xml:space="preserve">Returns a random #gboolean from @rand_.
This corresponds to an unbiased coin toss.</doc>
      <parameters>
        <parameter name="rand_">
          <doc xml:space="preserve">a #GRand</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="random_boolean" c:identifier="g_random_boolean" introspectable="0">
      <doc xml:space="preserve">Returns a random #gboolean.
This corresponds to an unbiased coin toss.</doc>
    </function-macro>
    <function name="random_double" c:identifier="g_random_double">
      <doc xml:space="preserve">Returns a random #gdouble equally distributed over the range [0..1).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a random number</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
    </function>
    <function name="random_double_range" c:identifier="g_random_double_range">
      <doc xml:space="preserve">Returns a random #gdouble equally distributed over the range
[@begin..@end).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a random number</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="begin" transfer-ownership="none">
          <doc xml:space="preserve">lower closed bound of the interval</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">upper open bound of the interval</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function name="random_int" c:identifier="g_random_int">
      <doc xml:space="preserve">Return a random #guint32 equally distributed over the range
[0..2^32-1].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a random number</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
    </function>
    <function name="random_int_range" c:identifier="g_random_int_range">
      <doc xml:space="preserve">Returns a random #gint32 equally distributed over the range
[@begin..@end-1].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a random number</doc>
        <type name="gint32" c:type="gint32"/>
      </return-value>
      <parameters>
        <parameter name="begin" transfer-ownership="none">
          <doc xml:space="preserve">lower closed bound of the interval</doc>
          <type name="gint32" c:type="gint32"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">upper open bound of the interval</doc>
          <type name="gint32" c:type="gint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="random_set_seed" c:identifier="g_random_set_seed">
      <doc xml:space="preserve">Sets the seed for the global random number generator, which is used
by the g_random_* functions, to @seed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="seed" transfer-ownership="none">
          <doc xml:space="preserve">a value to reinitialize the global random number generator</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="rc_box_acquire" c:identifier="g_rc_box_acquire" version="2.58">
      <doc xml:space="preserve">Acquires a reference on the data pointed by @mem_block.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to the data,
  with its reference count increased</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="mem_block" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to reference counted data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="rc_box_alloc" c:identifier="g_rc_box_alloc" version="2.58">
      <doc xml:space="preserve">Allocates @block_size bytes of memory, and adds reference
counting semantics to it.

The data will be freed when its reference count drops to
zero.

The allocated data is guaranteed to be suitably aligned for any
built-in type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to the allocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="block_size" transfer-ownership="none">
          <doc xml:space="preserve">the size of the allocation, must be greater than 0</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="rc_box_alloc0" c:identifier="g_rc_box_alloc0" version="2.58">
      <doc xml:space="preserve">Allocates @block_size bytes of memory, and adds reference
counting semantics to it.

The contents of the returned data is set to zero.

The data will be freed when its reference count drops to
zero.

The allocated data is guaranteed to be suitably aligned for any
built-in type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to the allocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="block_size" transfer-ownership="none">
          <doc xml:space="preserve">the size of the allocation, must be greater than 0</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="rc_box_dup" c:identifier="g_rc_box_dup" version="2.58">
      <doc xml:space="preserve">Allocates a new block of data with reference counting
semantics, and copies @block_size bytes of @mem_block
into it.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to the allocated
  memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="block_size" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to copy, must be greater than 0</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="mem_block" transfer-ownership="none">
          <doc xml:space="preserve">the memory to copy</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="rc_box_get_size" c:identifier="g_rc_box_get_size" version="2.58">
      <doc xml:space="preserve">Retrieves the size of the reference counted data pointed by @mem_block.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the size of the data, in bytes</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="mem_block" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to reference counted data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="rc_box_new" c:identifier="g_rc_box_new" version="2.58" introspectable="0">
      <doc xml:space="preserve">A convenience macro to allocate reference counted data with
the size of the given @type.

This macro calls g_rc_box_alloc() with `sizeof (@type)` and
casts the returned pointer to a pointer of the given @type,
avoiding a type cast in the source code.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">the type to allocate, typically a structure name</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="rc_box_new0" c:identifier="g_rc_box_new0" version="2.58" introspectable="0">
      <doc xml:space="preserve">A convenience macro to allocate reference counted data with
the size of the given @type, and set its contents to zero.

This macro calls g_rc_box_alloc0() with `sizeof (@type)` and
casts the returned pointer to a pointer of the given @type,
avoiding a type cast in the source code.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">the type to allocate, typically a structure name</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="rc_box_release" c:identifier="g_rc_box_release" version="2.58">
      <doc xml:space="preserve">Releases a reference on the data pointed by @mem_block.

If the reference was the last one, it will free the
resources allocated for @mem_block.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem_block" transfer-ownership="full">
          <doc xml:space="preserve">a pointer to reference counted data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="rc_box_release_full" c:identifier="g_rc_box_release_full" version="2.58">
      <doc xml:space="preserve">Releases a reference on the data pointed by @mem_block.

If the reference was the last one, it will call @clear_func
to clear the contents of @mem_block, and then will free the
resources allocated for @mem_block.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem_block" transfer-ownership="full">
          <doc xml:space="preserve">a pointer to reference counted data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="clear_func" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">a function to call when clearing the data</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="realloc" c:identifier="g_realloc">
      <doc xml:space="preserve">Reallocates the memory pointed to by @mem, so that it now has space for
@n_bytes bytes of memory. It returns the new address of the memory, which may
have been moved. @mem may be %NULL, in which case it's considered to
have zero-length. @n_bytes may be 0, in which case %NULL will be returned
and @mem will be freed unless it is %NULL.

If the allocation fails (because the system is out of memory),
the program is terminated.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the new address of the allocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the memory to reallocate</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="n_bytes" transfer-ownership="none">
          <doc xml:space="preserve">new size of the memory in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="realloc_n" c:identifier="g_realloc_n" version="2.24">
      <doc xml:space="preserve">This function is similar to g_realloc(), allocating (@n_blocks * @n_block_bytes) bytes,
but care is taken to detect possible overflow during multiplication.

If the allocation fails (because the system is out of memory),
the program is terminated.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the new address of the allocated memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the memory to reallocate</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="n_blocks" transfer-ownership="none">
          <doc xml:space="preserve">the number of blocks to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="n_block_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the size of each block in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="ref_count_compare" c:identifier="g_ref_count_compare" version="2.58">
      <doc xml:space="preserve">Compares the current value of @rc with @val.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the reference count is the same
  as the given value</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="rc" transfer-ownership="none">
          <doc xml:space="preserve">the address of a reference count variable</doc>
          <type name="gint" c:type="grefcount*"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">the value to compare</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="ref_count_dec" c:identifier="g_ref_count_dec" version="2.58">
      <doc xml:space="preserve">Decreases the reference count.

If %TRUE is returned, the reference count reached 0. After this point, @rc
is an undefined state and must be reinitialized with
g_ref_count_init() to be used again.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the reference count reached 0, and %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="rc" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the address of a reference count variable</doc>
          <type name="gint" c:type="grefcount*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ref_count_inc" c:identifier="g_ref_count_inc" version="2.58">
      <doc xml:space="preserve">Increases the reference count.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="rc" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the address of a reference count variable</doc>
          <type name="gint" c:type="grefcount*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ref_count_init" c:identifier="g_ref_count_init" version="2.58">
      <doc xml:space="preserve">Initializes a reference count variable to 1.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="rc" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the address of a reference count variable</doc>
          <type name="gint" c:type="grefcount*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ref_string_acquire" c:identifier="g_ref_string_acquire" version="2.58">
      <doc xml:space="preserve">Acquires a reference on a string.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the given string, with its reference count increased</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a reference counted string</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ref_string_equal" c:identifier="g_ref_string_equal" version="2.84">
      <doc xml:space="preserve">Compares two ref-counted strings for byte-by-byte equality.

It can be passed to [func@GLib.HashTable.new] as the key equality function,
and behaves exactly the same as [func@GLib.str_equal] (or `strcmp()`), but
can return slightly faster as it can check the string lengths before checking
all the bytes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if the strings are equal, otherwise `FALSE`</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str1" transfer-ownership="none">
          <doc xml:space="preserve">a reference counted string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="str2" transfer-ownership="none">
          <doc xml:space="preserve">a reference counted string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ref_string_length" c:identifier="g_ref_string_length" version="2.58">
      <doc xml:space="preserve">Retrieves the length of @str.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the length of the given string, in bytes</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a reference counted string</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ref_string_new" c:identifier="g_ref_string_new" version="2.58">
      <doc xml:space="preserve">Creates a new reference counted string and copies the contents of @str
into it.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly created reference counted string</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a NUL-terminated string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ref_string_new_intern" c:identifier="g_ref_string_new_intern" version="2.58">
      <doc xml:space="preserve">Creates a new reference counted string and copies the content of @str
into it.

If you call this function multiple times with the same @str, or with
the same contents of @str, it will return a new reference, instead of
creating a new string.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly created reference
  counted string, or a new reference to an existing string</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a NUL-terminated string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ref_string_new_len" c:identifier="g_ref_string_new_len" version="2.58">
      <doc xml:space="preserve">Creates a new reference counted string and copies the contents of @str
into it, up to @len bytes.

Since this function does not stop at nul bytes, it is the caller's
responsibility to ensure that @str has at least @len addressable bytes.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly created reference counted string</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str to use, or -1 if @str is nul-terminated</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="ref_string_release" c:identifier="g_ref_string_release" version="2.58">
      <doc xml:space="preserve">Releases a reference on a string; if it was the last reference, the
resources allocated by the string are freed as well.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a reference counted string</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="regex_check_replacement" c:identifier="g_regex_check_replacement" moved-to="Regex.check_replacement" version="2.14" throws="1">
      <doc xml:space="preserve">Checks whether @replacement is a valid replacement string
(see g_regex_replace()), i.e. that all escape sequences in
it are valid.

If @has_references is not %NULL then @replacement is checked
for pattern references. For instance, replacement text 'foo\n'
does not contain references and may be evaluated without information
about actual match, but '\0\1' (whole match followed by first
subpattern) requires valid #GMatchInfo object.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether @replacement is a valid replacement string</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="replacement" transfer-ownership="none">
          <doc xml:space="preserve">the replacement string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="has_references" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store information about
  references in @replacement or %NULL</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="regex_error_quark" c:identifier="g_regex_error_quark" moved-to="Regex.error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="regex_escape_nul" c:identifier="g_regex_escape_nul" moved-to="Regex.escape_nul" version="2.30">
      <doc xml:space="preserve">Escapes the nul characters in @string to "\x00".  It can be used
to compile a regex with embedded nul characters.

For completeness, @length can be -1 for a nul-terminated string.
In this case the output string will be of course equal to @string.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated escaped string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the string to escape</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of @string</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="regex_escape_string" c:identifier="g_regex_escape_string" moved-to="Regex.escape_string" version="2.14">
      <doc xml:space="preserve">Escapes the special characters used for regular expressions
in @string, for instance "a.b*c" becomes "a\.b\*c". This
function is useful to dynamically generate regular expressions.

@string can contain nul characters that are replaced with "\0",
in this case remember to specify the correct length of @string
in @length.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated escaped string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the string to escape</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of @string, in bytes, or -1 if @string is nul-terminated</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="regex_match_simple" c:identifier="g_regex_match_simple" moved-to="Regex.match_simple" version="2.14">
      <doc xml:space="preserve">Scans for a match in @string for @pattern.

This function is equivalent to g_regex_match() but it does not
require to compile the pattern with g_regex_new(), avoiding some
lines of code when you need just to do a match without extracting
substrings, capture counts, and so on.

If this function is to be called on the same @pattern more than
once, it's more efficient to compile the pattern once with
g_regex_new() and then use g_regex_match().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the string matched, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve">the regular expression</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the string to scan for matches</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="compile_options" transfer-ownership="none">
          <doc xml:space="preserve">compile options for the regular expression, or 0</doc>
          <type name="RegexCompileFlags" c:type="GRegexCompileFlags"/>
        </parameter>
        <parameter name="match_options" transfer-ownership="none">
          <doc xml:space="preserve">match options, or 0</doc>
          <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="regex_split_simple" c:identifier="g_regex_split_simple" moved-to="Regex.split_simple" version="2.14">
      <doc xml:space="preserve">Breaks the string on the pattern, and returns an array of
the tokens. If the pattern contains capturing parentheses,
then the text for each of the substrings will also be returned.
If the pattern does not match anywhere in the string, then the
whole string is returned as the first token.

This function is equivalent to g_regex_split() but it does
not require to compile the pattern with g_regex_new(), avoiding
some lines of code when you need just to do a split without
extracting substrings, capture counts, and so on.

If this function is to be called on the same @pattern more than
once, it's more efficient to compile the pattern once with
g_regex_new() and then use g_regex_split().

As a special case, the result of splitting the empty string ""
is an empty vector, not a vector containing a single string.
The reason for this special case is that being able to represent
an empty vector is typically more useful than consistent handling
of empty elements. If you do need to represent empty elements,
you'll need to check for the empty string before calling this
function.

A pattern that can match empty strings splits @string into
separate characters wherever it matches the empty string between
characters. For example splitting "ab c" using as a separator
"\s*", you will get "a", "b" and "c".</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a %NULL-terminated array of strings. Free
it using g_strfreev()</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve">the regular expression</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the string to scan for matches</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="compile_options" transfer-ownership="none">
          <doc xml:space="preserve">compile options for the regular expression, or 0</doc>
          <type name="RegexCompileFlags" c:type="GRegexCompileFlags"/>
        </parameter>
        <parameter name="match_options" transfer-ownership="none">
          <doc xml:space="preserve">match options, or 0</doc>
          <type name="RegexMatchFlags" c:type="GRegexMatchFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="reload_user_special_dirs_cache" c:identifier="g_reload_user_special_dirs_cache" version="2.22">
      <doc xml:space="preserve">Resets the cache used for g_get_user_special_dir(), so
that the latest on-disk version is used. Call this only
if you just changed the data on disk yourself.

Due to thread safety issues this may cause leaking of strings
that were previously returned from g_get_user_special_dir()
that can't be freed. We ensure to only leak the data for
the directories that actually changed value though.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="remove" c:identifier="g_remove" version="2.6">
      <doc xml:space="preserve">A wrapper for the POSIX remove() function. The remove() function
deletes a name from the filesystem.

See your C library manual for more details about how remove() works
on your system. On Unix, remove() removes also directories, as it
calls unlink() for files and rmdir() for directories. On Windows,
although remove() in the C library only works for files, this
function tries first remove() and then if that fails rmdir(), and
thus works for both files and directories. Note however, that on
Windows, it is in general not possible to remove a file that is
open to some process, or mapped into memory.

If this function fails on Windows you can't infer too much from the
errno value. rmdir() is tried regardless of what caused remove() to
fail. Any errno value set by remove() will be overwritten by that
set by rmdir().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the file was successfully removed, -1 if an error
   occurred</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="rename" c:identifier="g_rename" version="2.6">
      <doc xml:space="preserve">A wrapper for the POSIX rename() function. The rename() function
renames a file, moving it between directories if required.

See your C library manual for more details about how rename() works
on your system. It is not possible in general on Windows to rename
a file that is open to some process.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the renaming succeeded, -1 if an error occurred</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="oldfilename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="newfilename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="renew" c:identifier="g_renew" introspectable="0">
      <doc xml:space="preserve">Reallocates the memory pointed to by @mem, so that it now has space for
@n_structs elements of type @struct_type. It returns the new address of
the memory, which may have been moved.
Care is taken to avoid overflow when calculating the size of the allocated block.</doc>
      <parameters>
        <parameter name="struct_type">
          <doc xml:space="preserve">the type of the elements to allocate</doc>
        </parameter>
        <parameter name="mem">
          <doc xml:space="preserve">the currently allocated memory</doc>
        </parameter>
        <parameter name="n_structs">
          <doc xml:space="preserve">the number of elements to allocate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="return_if_fail" c:identifier="g_return_if_fail" introspectable="0">
      <parameters>
        <parameter name="expr">
        </parameter>
      </parameters>
    </function-macro>
    <function name="return_if_fail_warning" c:identifier="g_return_if_fail_warning" introspectable="0">
      <doc xml:space="preserve">Internal function used to print messages from the public [func@GLib.return_if_fail]
and [func@GLib.return_val_if_fail] macros.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">log domain</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="pretty_function" transfer-ownership="none">
          <doc xml:space="preserve">function containing the assertion</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="expression" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">expression which failed</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="return_if_reached" c:identifier="g_return_if_reached" introspectable="0"/>
    <function-macro name="return_val_if_fail" c:identifier="g_return_val_if_fail" introspectable="0">
      <parameters>
        <parameter name="expr">
        </parameter>
        <parameter name="val">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="return_val_if_reached" c:identifier="g_return_val_if_reached" introspectable="0">
      <parameters>
        <parameter name="val">
        </parameter>
      </parameters>
    </function-macro>
    <function name="rmdir" c:identifier="g_rmdir" version="2.6">
      <doc xml:space="preserve">A wrapper for the POSIX rmdir() function. The rmdir() function
deletes a directory from the filesystem.

See your C library manual for more details about how rmdir() works
on your system.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the directory was successfully removed, -1 if an error
   occurred</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="scanner_add_symbol" c:identifier="g_scanner_add_symbol" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Adds a symbol to the default scope.</doc>
      <doc-deprecated xml:space="preserve">Use g_scanner_scope_add_symbol() instead.</doc-deprecated>
      <parameters>
        <parameter name="scanner">
          <doc xml:space="preserve">a #GScanner</doc>
        </parameter>
        <parameter name="symbol">
          <doc xml:space="preserve">the symbol to add</doc>
        </parameter>
        <parameter name="value">
          <doc xml:space="preserve">the value of the symbol</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="scanner_foreach_symbol" c:identifier="g_scanner_foreach_symbol" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Calls a function for each symbol in the default scope.</doc>
      <doc-deprecated xml:space="preserve">Use g_scanner_scope_foreach_symbol() instead.</doc-deprecated>
      <parameters>
        <parameter name="scanner">
          <doc xml:space="preserve">a #GScanner</doc>
        </parameter>
        <parameter name="func">
          <doc xml:space="preserve">the function to call with each symbol</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">data to pass to the function</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="scanner_freeze_symbol_table" c:identifier="g_scanner_freeze_symbol_table" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">There is no reason to use this macro, since it does nothing.</doc>
      <doc-deprecated xml:space="preserve">This macro does nothing.</doc-deprecated>
      <parameters>
        <parameter name="scanner">
          <doc xml:space="preserve">a #GScanner</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="scanner_remove_symbol" c:identifier="g_scanner_remove_symbol" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Removes a symbol from the default scope.</doc>
      <doc-deprecated xml:space="preserve">Use g_scanner_scope_remove_symbol() instead.</doc-deprecated>
      <parameters>
        <parameter name="scanner">
          <doc xml:space="preserve">a #GScanner</doc>
        </parameter>
        <parameter name="symbol">
          <doc xml:space="preserve">the symbol to remove</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="scanner_thaw_symbol_table" c:identifier="g_scanner_thaw_symbol_table" introspectable="0" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">There is no reason to use this macro, since it does nothing.</doc>
      <doc-deprecated xml:space="preserve">This macro does nothing.</doc-deprecated>
      <parameters>
        <parameter name="scanner">
          <doc xml:space="preserve">a #GScanner</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="sequence_foreach_range" c:identifier="g_sequence_foreach_range" moved-to="Sequence.foreach_range" version="2.14">
      <doc xml:space="preserve">Calls @func for each item in the range (@begin, @end) passing
@user_data to the function. @func must not modify the sequence
itself.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="begin" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call" closure="3">
          <doc xml:space="preserve">a #GFunc</doc>
          <type name="Func" c:type="GFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to @func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequence_get" c:identifier="g_sequence_get" moved-to="Sequence.get" version="2.14">
      <doc xml:space="preserve">Returns the data that @iter points to.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the data that @iter points to</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequence_insert_before" c:identifier="g_sequence_insert_before" moved-to="Sequence.insert_before" version="2.14">
      <doc xml:space="preserve">Inserts a new item just before the item pointed to by @iter.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">an iterator pointing to the new item</doc>
        <type name="SequenceIter" c:type="GSequenceIter*"/>
      </return-value>
      <parameters>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data for the new item</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequence_move" c:identifier="g_sequence_move" moved-to="Sequence.move" version="2.14">
      <doc xml:space="preserve">Moves the item pointed to by @src to the position indicated by @dest.
After calling this function @dest will point to the position immediately
after @src. It is allowed for @src and @dest to point into different
sequences.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter pointing to the item to move</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter pointing to the position to which
    the item is moved</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequence_move_range" c:identifier="g_sequence_move_range" moved-to="Sequence.move_range" version="2.14">
      <doc xml:space="preserve">Inserts the (@begin, @end) range at the destination pointed to by @dest.
The @begin and @end iters must point into the same sequence. It is
allowed for @dest to point to a different sequence than the one pointed
into by @begin and @end.

If @dest is %NULL, the range indicated by @begin and @end is
removed from the sequence. If @dest points to a place within
the (@begin, @end) range, the range does not move.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="begin" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequence_range_get_midpoint" c:identifier="g_sequence_range_get_midpoint" moved-to="Sequence.range_get_midpoint" version="2.14">
      <doc xml:space="preserve">Finds an iterator somewhere in the range (@begin, @end). This
iterator will be close to the middle of the range, but is not
guaranteed to be exactly in the middle.

The @begin and @end iterators must both point to the same sequence
and @begin must come before or be equal to @end in the sequence.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GSequenceIter pointing somewhere in the
   (@begin, @end) range</doc>
        <type name="SequenceIter" c:type="GSequenceIter*"/>
      </return-value>
      <parameters>
        <parameter name="begin" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequence_remove" c:identifier="g_sequence_remove" moved-to="Sequence.remove" version="2.14">
      <doc xml:space="preserve">Removes the item pointed to by @iter. It is an error to pass the
end iterator to this function.

If the sequence has a data destroy function associated with it, this
function is called on the data for the removed item.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequence_remove_range" c:identifier="g_sequence_remove_range" moved-to="Sequence.remove_range" version="2.14">
      <doc xml:space="preserve">Removes all items in the (@begin, @end) range.

If the sequence has a data destroy function associated with it, this
function is called on the data for the removed items.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="begin" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequence_set" c:identifier="g_sequence_set" moved-to="Sequence.set" version="2.14">
      <doc xml:space="preserve">Changes the data for the item pointed to by @iter to be @data. If
the sequence has a data destroy function associated with it, that
function is called on the existing data that @iter pointed to.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">new data for the item</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequence_sort_changed" c:identifier="g_sequence_sort_changed" moved-to="Sequence.sort_changed" version="2.14">
      <doc xml:space="preserve">Moves the data pointed to by @iter to a new position as indicated by
@cmp_func. This
function should be called for items in a sequence already sorted according
to @cmp_func whenever some aspect of an item changes so that @cmp_func
may return different values for that item.

@cmp_func is called with two items of the @seq, and @cmp_data.
It should return 0 if the items are equal, a negative value if
the first item comes before the second, and a positive value if
the second item comes before the first.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">A #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="cmp_func" transfer-ownership="none" scope="call" closure="2">
          <doc xml:space="preserve">the function used to compare items in the sequence</doc>
          <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
        </parameter>
        <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to @cmp_func.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequence_sort_changed_iter" c:identifier="g_sequence_sort_changed_iter" moved-to="Sequence.sort_changed_iter" version="2.14">
      <doc xml:space="preserve">Like g_sequence_sort_changed(), but uses
a #GSequenceIterCompareFunc instead of a #GCompareDataFunc as
the compare function.

@iter_cmp is called with two iterators pointing into the #GSequence that
@iter points into. It should
return 0 if the iterators are equal, a negative value if the first
iterator comes before the second, and a positive value if the second
iterator comes before the first.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="iter" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="iter_cmp" transfer-ownership="none" scope="call" closure="2">
          <doc xml:space="preserve">the function used to compare iterators in the sequence</doc>
          <type name="SequenceIterCompareFunc" c:type="GSequenceIterCompareFunc"/>
        </parameter>
        <parameter name="cmp_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data passed to @cmp_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequence_swap" c:identifier="g_sequence_swap" moved-to="Sequence.swap" version="2.14">
      <doc xml:space="preserve">Swaps the items pointed to by @a and @b. It is allowed for @a and @b
to point into difference sequences.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve">a #GSequenceIter</doc>
          <type name="SequenceIter" c:type="GSequenceIter*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_application_name" c:identifier="g_set_application_name" version="2.2">
      <doc xml:space="preserve">Sets a human-readable name for the application. This name should be
localized if possible, and is intended for display to the user.
Contrast with g_set_prgname(), which sets a non-localized name.
g_set_prgname() will be called automatically by gtk_init(),
but g_set_application_name() will not.

Note that for thread safety reasons, this function can only
be called once.

The application name will be used in contexts such as error messages,
or when displaying an application's name in the task list.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="application_name" transfer-ownership="none">
          <doc xml:space="preserve">localized name of the application</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_error" c:identifier="g_set_error" introspectable="0">
      <doc xml:space="preserve">Does nothing if @err is %NULL; if @err is non-%NULL, then `*err`
must be %NULL. A new #GError is created and assigned to `*err`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="err" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">a return location for a #GError</doc>
          <type name="Error" c:type="GError**"/>
        </parameter>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">error domain</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="code" transfer-ownership="none">
          <doc xml:space="preserve">error code</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">printf()-style format</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">args for @format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="set_error_literal" c:identifier="g_set_error_literal" version="2.18">
      <doc xml:space="preserve">Does nothing if @err is %NULL; if @err is non-%NULL, then `*err`
must be %NULL. A new #GError is created and assigned to `*err`.
Unlike g_set_error(), @message is not a printf()-style format string.
Use this function if @message contains text you don't have control over,
that could include printf() escape sequences.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="err" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">a return location for a #GError</doc>
          <type name="Error" c:type="GError**"/>
        </parameter>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">error domain</doc>
          <type name="Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="code" transfer-ownership="none">
          <doc xml:space="preserve">error code</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">error message</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_prgname" c:identifier="g_set_prgname">
      <doc xml:space="preserve">Sets the name of the program. This name should not be localized,
in contrast to g_set_application_name().

If you are using #GApplication the program name is set in
g_application_run(). In case of GDK or GTK it is set in
gdk_init(), which is called by gtk_init() and the
#GtkApplication::startup handler. By default, the program name is
found by taking the last component of @argv[0].

Since GLib 2.72, this function can be called multiple times
and is fully thread safe. Prior to GLib 2.72, this function
could only be called once per process.

See the [GTK documentation](https://docs.gtk.org/gtk4/migrating-3to4.html#set-a-proper-application-id)
for requirements on integrating g_set_prgname() with GTK applications.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="prgname" transfer-ownership="none">
          <doc xml:space="preserve">the name of the program.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_print_handler" c:identifier="g_set_print_handler" introspectable="0">
      <doc xml:space="preserve">Sets the print handler to @func, or resets it to the
default GLib handler if `NULL`.

Any messages passed to [func@GLib.print] will be output via
the new handler. The default handler outputs
the encoded message to `stdout`. By providing your own handler
you can redirect the output, to a GTK widget or a
log file for example.

Since 2.76 this functions always returns a valid
[type@GLib.PrintFunc], and never returns `NULL`. If no custom
print handler was set, it will return the GLib
default print handler and that can be re-used to
decorate its output and/or to write to `stderr`
in all platforms. Before GLib 2.76, this was `NULL`.</doc>
      <return-value>
        <doc xml:space="preserve">the old print handler</doc>
        <type name="PrintFunc" c:type="GPrintFunc"/>
      </return-value>
      <parameters>
        <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the new print handler or `NULL` to
  reset to the default</doc>
          <type name="PrintFunc" c:type="GPrintFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_printerr_handler" c:identifier="g_set_printerr_handler" introspectable="0">
      <doc xml:space="preserve">Sets the handler for printing error messages to @func,
or resets it to the default GLib handler if `NULL`.

Any messages passed to [func@GLib.printerr] will be output via
the new handler. The default handler outputs the encoded
message to `stderr`. By providing your own handler you can
redirect the output, to a GTK widget or a log file for
example.

Since 2.76 this functions always returns a valid
[type@GLib.PrintFunc], and never returns `NULL`. If no custom error
print handler was set, it will return the GLib default
error print handler and that can be re-used to decorate
its output and/or to write to `stderr` in all platforms.
Before GLib 2.76, this was `NULL`.</doc>
      <return-value>
        <doc xml:space="preserve">the old error message handler</doc>
        <type name="PrintFunc" c:type="GPrintFunc"/>
      </return-value>
      <parameters>
        <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">he new error message handler or `NULL`
  to reset to the default</doc>
          <type name="PrintFunc" c:type="GPrintFunc"/>
        </parameter>
      </parameters>
    </function>
    <function-inline name="set_str" c:identifier="g_set_str" version="2.76" introspectable="0">
      <doc xml:space="preserve">Updates a pointer to a string to a copy of @new_str and returns whether the
string was changed.

If @new_str matches the previous string, this function is a no-op. If
@new_str is different, a copy of it will be assigned to @str_pointer and
the previous string pointed to by @str_pointer will be freed with
[func@GLib.free].

@str_pointer must not be `NULL`, but can point to a `NULL` value.

One convenient usage of this function is in implementing property settings:
```C
void
foo_set_bar (Foo        *foo,
             const char *new_bar)
{
  g_return_if_fail (IS_FOO (foo));

  if (g_set_str (&amp;foo-&gt;bar, new_bar))
    g_object_notify (foo, "bar");
}
```</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if the value of @str_pointer changed, false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str_pointer" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">a pointer to either
  a string or `NULL`</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="new_str" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string to assign to @str_pointer</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function-inline>
    <function name="setenv" c:identifier="g_setenv" version="2.4">
      <doc xml:space="preserve">Sets an environment variable. On UNIX, both the variable's name and
value can be arbitrary byte strings, except that the variable's name
cannot contain '='. On Windows, they should be in UTF-8.

Note that on some systems, when variables are overwritten, the memory
used for the previous variables and its value isn't reclaimed.

You should be mindful of the fact that environment variable handling
in UNIX is not thread-safe, and your program may crash if one thread
calls g_setenv() while another thread is calling getenv(). (And note
that many functions, such as gettext(), call getenv() internally.)
This function is only safe to use at the very start of your program,
before creating any other threads (or creating objects that create
worker threads of their own).

If you need to set up the environment for a child process, you can
use g_get_environ() to get an environment array, modify that with
g_environ_setenv() and g_environ_unsetenv(), and then pass that
array directly to execvpe(), g_spawn_async(), or the like.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%FALSE if the environment variable couldn't be set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="variable" transfer-ownership="none">
          <doc xml:space="preserve">the environment variable to set, must not
    contain '='.</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value for to set the variable to.</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="overwrite" transfer-ownership="none">
          <doc xml:space="preserve">whether to change the variable if it already exists.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="shell_error_quark" c:identifier="g_shell_error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="shell_parse_argv" c:identifier="g_shell_parse_argv" throws="1">
      <doc xml:space="preserve">Parses a command line into an argument vector, in much the same way
the shell would, but without many of the expansions the shell would
perform (variable expansion, globs, operators, filename expansion,
etc. are not supported).

The results are defined to be the same as those you would get from
a UNIX98 `/bin/sh`, as long as the input contains none of the
unsupported shell expansions. If the input does contain such expansions,
they are passed through literally.

Possible errors are those from the %G_SHELL_ERROR domain.

In particular, if @command_line is an empty string (or a string containing
only whitespace), %G_SHELL_ERROR_EMPTY_STRING will be returned. It&#x2019;s
guaranteed that @argvp will be a non-empty array if this function returns
successfully.

Free the returned vector with g_strfreev().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if error set</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="command_line" transfer-ownership="none">
          <doc xml:space="preserve">command line to parse</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="argcp" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for number of args</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="argvp" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">
  return location for array of args</doc>
          <array length="1" zero-terminated="1" c:type="gchar***">
            <type name="filename"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="shell_quote" c:identifier="g_shell_quote">
      <doc xml:space="preserve">Quotes a string so that the shell (/bin/sh) will interpret the
quoted string to mean @unquoted_string.

If you pass a filename to the shell, for example, you should first
quote it with this function.

The return value must be freed with g_free().

The quoting style used is undefined (single or double quotes may be
used).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">quoted string</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="unquoted_string" transfer-ownership="none">
          <doc xml:space="preserve">a literal string</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="shell_unquote" c:identifier="g_shell_unquote" throws="1">
      <doc xml:space="preserve">Unquotes a string as the shell (/bin/sh) would.

This function only handles quotes; if a string contains file globs,
arithmetic operators, variables, backticks, redirections, or other
special-to-the-shell features, the result will be different from the
result a real shell would produce (the variables, backticks, etc.
will be passed through literally instead of being expanded).

This function is guaranteed to succeed if applied to the result of
g_shell_quote(). If it fails, it returns %NULL and sets the
error.

The @quoted_string need not actually contain quoted or escaped text;
g_shell_unquote() simply goes through the string and unquotes/unescapes
anything that the shell would. Both single and double quotes are
handled, as are escapes including escaped newlines.

The return value must be freed with g_free().

Possible errors are in the %G_SHELL_ERROR domain.

Shell quoting rules are a bit strange. Single quotes preserve the
literal string exactly. escape sequences are not allowed; not even
`\'` - if you want a `'` in the quoted text, you have to do something
like `'foo'\''bar'`. Double quotes allow `$`, ```, `"`, `\`, and
newline to be escaped with backslash. Otherwise double quotes
preserve things literally.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">an unquoted string</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="quoted_string" transfer-ownership="none">
          <doc xml:space="preserve">shell-quoted string</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="size_checked_add" c:identifier="g_size_checked_add" version="2.48" introspectable="0">
      <doc xml:space="preserve">Performs a checked addition of @a and @b, storing the result in
@dest.

If the operation is successful, %TRUE is returned.  If the operation
overflows then the state of @dest is undefined and %FALSE is
returned.</doc>
      <parameters>
        <parameter name="dest">
          <doc xml:space="preserve">a pointer to the #gsize destination</doc>
        </parameter>
        <parameter name="a">
          <doc xml:space="preserve">the #gsize left operand</doc>
        </parameter>
        <parameter name="b">
          <doc xml:space="preserve">the #gsize right operand</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="size_checked_mul" c:identifier="g_size_checked_mul" version="2.48" introspectable="0">
      <doc xml:space="preserve">Performs a checked multiplication of @a and @b, storing the result in
@dest.

If the operation is successful, %TRUE is returned.  If the operation
overflows then the state of @dest is undefined and %FALSE is
returned.</doc>
      <parameters>
        <parameter name="dest">
          <doc xml:space="preserve">a pointer to the #gsize destination</doc>
        </parameter>
        <parameter name="a">
          <doc xml:space="preserve">the #gsize left operand</doc>
        </parameter>
        <parameter name="b">
          <doc xml:space="preserve">the #gsize right operand</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="slice_alloc" c:identifier="g_slice_alloc" version="2.10">
      <doc xml:space="preserve">Allocates a block of memory from the libc allocator.

The block address handed out can be expected to be aligned
to at least `1 * sizeof (void*)`.

Since GLib 2.76 this always uses the system malloc() implementation
internally.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the allocated memory block, which will
  be %NULL if and only if @mem_size is 0</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="block_size" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="slice_alloc0" c:identifier="g_slice_alloc0" version="2.10">
      <doc xml:space="preserve">Allocates a block of memory via g_slice_alloc() and initializes
the returned memory to 0.

Since GLib 2.76 this always uses the system malloc() implementation
internally.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the allocated block, which will be %NULL
   if and only if @mem_size is 0</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="block_size" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="slice_copy" c:identifier="g_slice_copy" version="2.14">
      <doc xml:space="preserve">Allocates a block of memory from the slice allocator
and copies @block_size bytes into it from @mem_block.

@mem_block must be non-%NULL if @block_size is non-zero.

Since GLib 2.76 this always uses the system malloc() implementation
internally.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the allocated memory block,
   which will be %NULL if and only if @mem_size is 0</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="block_size" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="mem_block" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the memory to copy</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="slice_dup" c:identifier="g_slice_dup" version="2.14" introspectable="0">
      <doc xml:space="preserve">A convenience macro to duplicate a block of memory using
the slice allocator.

It calls g_slice_copy() with `sizeof (@type)`
and casts the returned pointer to a pointer of the given type,
avoiding a type cast in the source code.

This can never return %NULL.

Since GLib 2.76 this always uses the system malloc() implementation
internally.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">the type to duplicate, typically a structure name</doc>
        </parameter>
        <parameter name="mem">
          <doc xml:space="preserve">the memory to copy into the allocated block</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="slice_free" c:identifier="g_slice_free" version="2.10" introspectable="0">
      <doc xml:space="preserve">A convenience macro to free a block of memory that has
been allocated from the slice allocator.

It calls g_slice_free1() using `sizeof (type)`
as the block size.
Note that the exact release behaviour can be changed with the
[`G_DEBUG=gc-friendly`](running.html#environment-variables) environment variable.

If @mem is %NULL, this macro does nothing.

Since GLib 2.76 this always uses the system free() implementation internally.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">the type of the block to free, typically a structure name</doc>
        </parameter>
        <parameter name="mem">
          <doc xml:space="preserve">a pointer to the block to free</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="slice_free1" c:identifier="g_slice_free1" version="2.10">
      <doc xml:space="preserve">Frees a block of memory.

The memory must have been allocated via g_slice_alloc() or
g_slice_alloc0() and the @block_size has to match the size
specified upon allocation. Note that the exact release behaviour
can be changed with the [`G_DEBUG=gc-friendly`](running.html#environment-variables) environment
variable.

If @mem_block is %NULL, this function does nothing.

Since GLib 2.76 this always uses the system free_sized() implementation
internally.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="block_size" transfer-ownership="none">
          <doc xml:space="preserve">the size of the block</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="mem_block" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to the block to free</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="slice_free_chain" c:identifier="g_slice_free_chain" version="2.10" introspectable="0">
      <doc xml:space="preserve">Frees a linked list of memory blocks of structure type @type.

The memory blocks must be equal-sized, allocated via
g_slice_alloc() or g_slice_alloc0() and linked together by
a @next pointer (similar to #GSList). The name of the
@next field in @type is passed as third argument.
Note that the exact release behaviour can be changed with the
[`G_DEBUG=gc-friendly`](running.html#environment-variables) environment variable.

If @mem_chain is %NULL, this function does nothing.

Since GLib 2.76 this always uses the system free() implementation internally.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">the type of the @mem_chain blocks</doc>
        </parameter>
        <parameter name="mem_chain">
          <doc xml:space="preserve">a pointer to the first block of the chain</doc>
        </parameter>
        <parameter name="next">
          <doc xml:space="preserve">the field name of the next pointer in @type</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="slice_free_chain_with_offset" c:identifier="g_slice_free_chain_with_offset" version="2.10">
      <doc xml:space="preserve">Frees a linked list of memory blocks of structure type @type.

The memory blocks must be equal-sized, allocated via
g_slice_alloc() or g_slice_alloc0() and linked together by a
@next pointer (similar to #GSList). The offset of the @next
field in each block is passed as third argument.
Note that the exact release behaviour can be changed with the
[`G_DEBUG=gc-friendly`](running.html#environment-variables) environment variable.

If @mem_chain is %NULL, this function does nothing.

Since GLib 2.76 this always uses the system free_sized() implementation
internally.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="block_size" transfer-ownership="none">
          <doc xml:space="preserve">the size of the blocks</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="mem_chain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to the first block of the chain</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="next_offset" transfer-ownership="none">
          <doc xml:space="preserve">the offset of the @next field in the blocks</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="slice_get_config" c:identifier="g_slice_get_config">
      <return-value transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="ckey" transfer-ownership="none">
          <type name="SliceConfig" c:type="GSliceConfig"/>
        </parameter>
      </parameters>
    </function>
    <function name="slice_get_config_state" c:identifier="g_slice_get_config_state">
      <return-value transfer-ownership="none">
        <type name="gint64" c:type="gint64*"/>
      </return-value>
      <parameters>
        <parameter name="ckey" transfer-ownership="none">
          <type name="SliceConfig" c:type="GSliceConfig"/>
        </parameter>
        <parameter name="address" transfer-ownership="none">
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="n_values" transfer-ownership="none">
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="slice_new" c:identifier="g_slice_new" version="2.10" introspectable="0">
      <doc xml:space="preserve">A convenience macro to allocate a block of memory from the
slice allocator.

It calls g_slice_alloc() with `sizeof (@type)` and casts the
returned pointer to a pointer of the given type, avoiding a type
cast in the source code.

This can never return %NULL as the minimum allocation size from
`sizeof (@type)` is 1 byte.

Since GLib 2.76 this always uses the system malloc() implementation
internally.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">the type to allocate, typically a structure name</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="slice_new0" c:identifier="g_slice_new0" version="2.10" introspectable="0">
      <doc xml:space="preserve">A convenience macro to allocate a block of memory from the
slice allocator and set the memory to 0.

It calls g_slice_alloc0() with `sizeof (@type)`
and casts the returned pointer to a pointer of the given type,
avoiding a type cast in the source code.

This can never return %NULL as the minimum allocation size from
`sizeof (@type)` is 1 byte.

Since GLib 2.76 this always uses the system malloc() implementation
internally.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">the type to allocate, typically a structure name</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="slice_set_config" c:identifier="g_slice_set_config">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="ckey" transfer-ownership="none">
          <type name="SliceConfig" c:type="GSliceConfig"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="slist_next" c:identifier="g_slist_next" introspectable="0">
      <doc xml:space="preserve">A convenience macro to get the next element in a #GSList.
Note that it is considered perfectly acceptable to access
@slist-&gt;next directly.</doc>
      <parameters>
        <parameter name="slist">
          <doc xml:space="preserve">an element in a #GSList.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="slist_pop_allocator" c:identifier="g_slist_pop_allocator" moved-to="SList.pop_allocator" deprecated="1" deprecated-version="2.10">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="slist_push_allocator" c:identifier="g_slist_push_allocator" moved-to="SList.push_allocator" deprecated="1" deprecated-version="2.10">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="allocator" transfer-ownership="none">
          <type name="Allocator" c:type="GAllocator*"/>
        </parameter>
      </parameters>
    </function>
    <function name="snprintf" c:identifier="g_snprintf" introspectable="0">
      <doc xml:space="preserve">A safer form of the standard sprintf() function. The output is guaranteed
to not exceed @n characters (including the terminating nul character), so
it is easy to ensure that a buffer overflow cannot occur.

See also [func@GLib.strdup_printf].

In versions of GLib prior to 1.2.3, this function may return -1 if the
output was truncated, and the truncated string may not be nul-terminated.
In versions prior to 1.3.12, this function returns the length of the output
string.

The return value of g_snprintf() conforms to the snprintf()
function as standardized in ISO C99. Note that this is different from
traditional `snprintf()`, which returns the length of the output string.

The format string may contain positional parameters, as specified in
the Single Unix Specification.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes which would be produced if the buffer
  was large enough</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the buffer to hold the output</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of bytes to produce (including the
  terminating nul character)</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a standard `printf()` format string, but notice
  [string precision pitfalls](string-utils.html#string-precision-pitfalls)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the arguments to insert in the output</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="sort_array" c:identifier="g_sort_array" version="2.82" introspectable="0">
      <doc xml:space="preserve">This is just like the standard C [`qsort()`](man:qsort(3)) function, but
the comparison routine accepts a user data argument
(like [`qsort_r()`](man:qsort_r(3))).

Unlike `qsort()`, this is guaranteed to be a stable sort.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:space="preserve">start of array to sort</doc>
          <array length="1" zero-terminated="0" c:type="void*">
            <type name="gpointer" c:type="void"/>
          </array>
        </parameter>
        <parameter name="n_elements" transfer-ownership="none">
          <doc xml:space="preserve">number of elements in the array</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="element_size" transfer-ownership="none">
          <doc xml:space="preserve">size of each element</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="compare_func" transfer-ownership="none" scope="call" closure="4">
          <doc xml:space="preserve">function to compare elements</doc>
          <type name="CompareDataFunc" c:type="GCompareDataFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @compare_func</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="source_remove" c:identifier="g_source_remove" moved-to="Source.remove">
      <doc xml:space="preserve">Removes the source with the given ID from the default main context.

You must
use [method@GLib.Source.destroy] for sources added to a non-default main context.

The ID of a [struct@GLib.Source] is given by [method@GLib.Source.get_id], or will be
returned by the functions [method@GLib.Source.attach], [func@GLib.idle_add],
[func@GLib.idle_add_full], [func@GLib.timeout_add],
[func@GLib.timeout_add_full], [func@GLib.child_watch_add],
[func@GLib.child_watch_add_full], [func@GLib.io_add_watch], and
[func@GLib.io_add_watch_full].

It is a programmer error to attempt to remove a non-existent source.

More specifically: source IDs can be reissued after a source has been
destroyed and therefore it is never valid to use this function with a
source ID which may have already been removed.  An example is when
scheduling an idle to run in another thread with [func@GLib.idle_add]: the
idle may already have run and been removed by the time this function
is called on its (now invalid) source ID.  This source ID may have
been reissued, leading to the operation being performed against the
wrong source.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if the source was found and removed, false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:space="preserve">the ID of the source to remove.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="source_remove_by_funcs_user_data" c:identifier="g_source_remove_by_funcs_user_data" moved-to="Source.remove_by_funcs_user_data">
      <doc xml:space="preserve">Removes a source from the default main loop context given the
source functions and user data.

If multiple sources exist with the same source functions and user data, only
one will be destroyed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if a source was found and removed, false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="funcs" transfer-ownership="none">
          <doc xml:space="preserve">the @source_funcs passed to [ctor@GLib.Source.new]</doc>
          <type name="SourceFuncs" c:type="GSourceFuncs*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the user data for the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="source_remove_by_user_data" c:identifier="g_source_remove_by_user_data" moved-to="Source.remove_by_user_data">
      <doc xml:space="preserve">Removes a source from the default main loop context given the user
data for the callback.

If multiple sources exist with the same user data, only one will be destroyed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if a source was found and removed, false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the user_data for the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="source_set_name_by_id" c:identifier="g_source_set_name_by_id" moved-to="Source.set_name_by_id" version="2.26">
      <doc xml:space="preserve">Sets the name of a source using its ID.

This is a convenience utility to set source names from the return
value of [func@GLib.idle_add], [func@GLib.timeout_add], etc.

It is a programmer error to attempt to set the name of a non-existent
source.

More specifically: source IDs can be reissued after a source has been
destroyed and therefore it is never valid to use this function with a
source ID which may have already been removed.  An example is when
scheduling an idle to run in another thread with [func@GLib.idle_add]: the
idle may already have run and been removed by the time this function
is called on its (now invalid) source ID.  This source ID may have
been reissued, leading to the operation being performed against the
wrong source.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:space="preserve">a source ID</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">debug name for the source</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="spaced_primes_closest" c:identifier="g_spaced_primes_closest">
      <doc xml:space="preserve">Gets the smallest prime number from a built-in array of primes which
is larger than @num. This is used within GLib to calculate the optimum
size of a #GHashTable.

The built-in array of primes ranges from 11 to 13845163 such that
each prime is approximately 1.5-2 times the previous prime.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the smallest prime number from a built-in array of primes
    which is larger than @num</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="num" transfer-ownership="none">
          <doc xml:space="preserve">a #guint</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="spawn_async" c:identifier="g_spawn_async" throws="1">
      <doc xml:space="preserve">Executes a child program asynchronously.

See g_spawn_async_with_pipes_and_fds() for a full description; this function
simply calls the g_spawn_async_with_pipes() without any pipes, which in turn
calls g_spawn_async_with_pipes_and_fds().

You should call g_spawn_close_pid() on the returned child process
reference when you don't need it any more.

If you are writing a GTK application, and the program you are spawning is a
graphical application too, then to ensure that the spawned program opens its
windows on the right screen, you may want to use #GdkAppLaunchContext,
#GAppLaunchContext, or set the %DISPLAY environment variable.

Note that the returned @child_pid on Windows is a handle to the child
process and not its identifier. Process handles and process identifiers
are different concepts on Windows.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if error is set</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="working_directory" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">child's current working
    directory, or %NULL to inherit parent's</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:space="preserve">
    child's argument vector</doc>
          <array c:type="gchar**">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="envp" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">
    child's environment, or %NULL to inherit parent's</doc>
          <array c:type="gchar**">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags from #GSpawnFlags</doc>
          <type name="SpawnFlags" c:type="GSpawnFlags"/>
        </parameter>
        <parameter name="child_setup" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
          <doc xml:space="preserve">function to run
    in the child just before `exec()`</doc>
          <type name="SpawnChildSetupFunc" c:type="GSpawnChildSetupFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data for @child_setup</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="child_pid" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for child process reference, or %NULL</doc>
          <type name="Pid" c:type="GPid*"/>
        </parameter>
      </parameters>
    </function>
    <function name="spawn_async_with_fds" c:identifier="g_spawn_async_with_fds" version="2.58" throws="1">
      <doc xml:space="preserve">Executes a child program asynchronously.

Identical to g_spawn_async_with_pipes_and_fds() but with `n_fds` set to zero,
so no FD assignments are used.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if an error was set</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="working_directory" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">child's current working directory, or %NULL to inherit parent's, in the GLib file name encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:space="preserve">child's argument vector, in the GLib file name encoding;
  it must be non-empty and %NULL-terminated</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="envp" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">child's environment, or %NULL to inherit parent's, in the GLib file name encoding</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags from #GSpawnFlags</doc>
          <type name="SpawnFlags" c:type="GSpawnFlags"/>
        </parameter>
        <parameter name="child_setup" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
          <doc xml:space="preserve">function to run
  in the child just before `exec()`</doc>
          <type name="SpawnChildSetupFunc" c:type="GSpawnChildSetupFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data for @child_setup</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="child_pid" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for child process ID, or %NULL</doc>
          <type name="Pid" c:type="GPid*"/>
        </parameter>
        <parameter name="stdin_fd" transfer-ownership="none">
          <doc xml:space="preserve">file descriptor to use for child's stdin, or `-1`</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="stdout_fd" transfer-ownership="none">
          <doc xml:space="preserve">file descriptor to use for child's stdout, or `-1`</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="stderr_fd" transfer-ownership="none">
          <doc xml:space="preserve">file descriptor to use for child's stderr, or `-1`</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="spawn_async_with_pipes" c:identifier="g_spawn_async_with_pipes" throws="1">
      <doc xml:space="preserve">Identical to g_spawn_async_with_pipes_and_fds() but with `n_fds` set to zero,
so no FD assignments are used.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if an error was set</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="working_directory" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">child's current working
    directory, or %NULL to inherit parent's, in the GLib file name encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:space="preserve">child's argument
    vector, in the GLib file name encoding; it must be non-empty and %NULL-terminated</doc>
          <array c:type="gchar**">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="envp" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">
    child's environment, or %NULL to inherit parent's, in the GLib file
    name encoding</doc>
          <array c:type="gchar**">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags from #GSpawnFlags</doc>
          <type name="SpawnFlags" c:type="GSpawnFlags"/>
        </parameter>
        <parameter name="child_setup" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
          <doc xml:space="preserve">function to run
    in the child just before `exec()`</doc>
          <type name="SpawnChildSetupFunc" c:type="GSpawnChildSetupFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data for @child_setup</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="child_pid" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for child process ID, or %NULL</doc>
          <type name="Pid" c:type="GPid*"/>
        </parameter>
        <parameter name="standard_input" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for file descriptor to write to child's stdin, or %NULL</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="standard_output" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for file descriptor to read child's stdout, or %NULL</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="standard_error" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for file descriptor to read child's stderr, or %NULL</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="spawn_async_with_pipes_and_fds" c:identifier="g_spawn_async_with_pipes_and_fds" version="2.68" throws="1">
      <doc xml:space="preserve">Executes a child program asynchronously (your program will not
block waiting for the child to exit).

The child program is specified by the only argument that must be
provided, @argv. @argv should be a %NULL-terminated array of strings,
to be passed as the argument vector for the child. The first string
in @argv is of course the name of the program to execute. By default,
the name of the program must be a full path. If @flags contains the
%G_SPAWN_SEARCH_PATH flag, the `PATH` environment variable is used to
search for the executable. If @flags contains the
%G_SPAWN_SEARCH_PATH_FROM_ENVP flag, the `PATH` variable from @envp
is used to search for the executable. If both the
%G_SPAWN_SEARCH_PATH and %G_SPAWN_SEARCH_PATH_FROM_ENVP flags are
set, the `PATH` variable from @envp takes precedence over the
environment variable.

If the program name is not a full path and %G_SPAWN_SEARCH_PATH flag
is not used, then the program will be run from the current directory
(or @working_directory, if specified); this might be unexpected or even
dangerous in some cases when the current directory is world-writable.

On Windows, note that all the string or string vector arguments to
this function and the other `g_spawn*()` functions are in UTF-8, the
GLib file name encoding. Unicode characters that are not part of
the system codepage passed in these arguments will be correctly
available in the spawned program only if it uses wide character API
to retrieve its command line. For C programs built with Microsoft's
tools it is enough to make the program have a `wmain()` instead of
`main()`. `wmain()` has a wide character argument vector as parameter.

At least currently, mingw doesn't support `wmain()`, so if you use
mingw to develop the spawned program, it should call
g_win32_get_command_line() to get arguments in UTF-8.

On Windows the low-level child process creation API `CreateProcess()`
doesn't use argument vectors, but a command line. The C runtime
library's `spawn*()` family of functions (which g_spawn_async_with_pipes()
eventually calls) paste the argument vector elements together into
a command line, and the C runtime startup code does a corresponding
reconstruction of an argument vector from the command line, to be
passed to `main()`. Complications arise when you have argument vector
elements that contain spaces or double quotes. The `spawn*()` functions
don't do any quoting or escaping, but on the other hand the startup
code does do unquoting and unescaping in order to enable receiving
arguments with embedded spaces or double quotes. To work around this
asymmetry, g_spawn_async_with_pipes() will do quoting and escaping on
argument vector elements that need it before calling the C runtime
`spawn()` function.

The returned @child_pid on Windows is a handle to the child
process, not its identifier. Process handles and process
identifiers are different concepts on Windows.

@envp is a %NULL-terminated array of strings, where each string
has the form `KEY=VALUE`. This will become the child's environment.
If @envp is %NULL, the child inherits its parent's environment.

@flags should be the bitwise OR of any flags you want to affect the
function's behaviour. The %G_SPAWN_DO_NOT_REAP_CHILD means that the
child will not automatically be reaped; you must use a child watch
(g_child_watch_add()) to be notified about the death of the child process,
otherwise it will stay around as a zombie process until this process exits.
Eventually you must call g_spawn_close_pid() on the @child_pid, in order to
free resources which may be associated with the child process. (On Unix,
using a child watch is equivalent to calling waitpid() or handling
the `SIGCHLD` signal manually. On Windows, calling g_spawn_close_pid()
is equivalent to calling `CloseHandle()` on the process handle returned
in @child_pid). See g_child_watch_add().

Open UNIX file descriptors marked as `FD_CLOEXEC` will be automatically
closed in the child process. %G_SPAWN_LEAVE_DESCRIPTORS_OPEN means that
other open file descriptors will be inherited by the child; otherwise all
descriptors except stdin/stdout/stderr will be closed before calling `exec()`
in the child. %G_SPAWN_SEARCH_PATH means that @argv[0] need not be an
absolute path, it will be looked for in the `PATH` environment
variable. %G_SPAWN_SEARCH_PATH_FROM_ENVP means need not be an
absolute path, it will be looked for in the `PATH` variable from
@envp. If both %G_SPAWN_SEARCH_PATH and %G_SPAWN_SEARCH_PATH_FROM_ENVP
are used, the value from @envp takes precedence over the environment.

%G_SPAWN_CHILD_INHERITS_STDIN means that the child will inherit the parent's
standard input (by default, the child's standard input is attached to
`/dev/null`). %G_SPAWN_STDIN_FROM_DEV_NULL explicitly imposes the default
behavior. Both flags cannot be enabled at the same time and, in both cases,
the @stdin_pipe_out argument is ignored.

%G_SPAWN_STDOUT_TO_DEV_NULL means that the child's standard output
will be discarded (by default, it goes to the same location as the parent's
standard output). %G_SPAWN_CHILD_INHERITS_STDOUT explicitly imposes the
default behavior. Both flags cannot be enabled at the same time and, in
both cases, the @stdout_pipe_out argument is ignored.

%G_SPAWN_STDERR_TO_DEV_NULL means that the child's standard error
will be discarded (by default, it goes to the same location as the parent's
standard error). %G_SPAWN_CHILD_INHERITS_STDERR explicitly imposes the
default behavior. Both flags cannot be enabled at the same time and, in
both cases, the @stderr_pipe_out argument is ignored.

It is valid to pass the same FD in multiple parameters (e.g. you can pass
a single FD for both @stdout_fd and @stderr_fd, and include it in
@source_fds too).

@source_fds and @target_fds allow zero or more FDs from this process to be
remapped to different FDs in the spawned process. If @n_fds is greater than
zero, @source_fds and @target_fds must both be non-%NULL and the same length.
Each FD in @source_fds is remapped to the FD number at the same index in
@target_fds. The source and target FD may be equal to simply propagate an FD
to the spawned process. FD remappings are processed after standard FDs, so
any target FDs which equal @stdin_fd, @stdout_fd or @stderr_fd will overwrite
them in the spawned process.

@source_fds is supported on Windows since 2.72.

%G_SPAWN_FILE_AND_ARGV_ZERO means that the first element of @argv is
the file to execute, while the remaining elements are the actual
argument vector to pass to the file. Normally g_spawn_async_with_pipes()
uses @argv[0] as the file to execute, and passes all of @argv to the child.

@child_setup and @user_data are a function and user data. On POSIX
platforms, the function is called in the child after GLib has
performed all the setup it plans to perform (including creating
pipes, closing file descriptors, etc.) but before calling `exec()`.
That is, @child_setup is called just before calling `exec()` in the
child. Obviously actions taken in this function will only affect
the child, not the parent.

On Windows, there is no separate `fork()` and `exec()` functionality.
Child processes are created and run with a single API call,
`CreateProcess()`. There is no sensible thing @child_setup
could be used for on Windows so it is ignored and not called.

If non-%NULL, @child_pid will on Unix be filled with the child's
process ID. You can use the process ID to send signals to the child,
or to use g_child_watch_add() (or `waitpid()`) if you specified the
%G_SPAWN_DO_NOT_REAP_CHILD flag. On Windows, @child_pid will be
filled with a handle to the child process only if you specified the
%G_SPAWN_DO_NOT_REAP_CHILD flag. You can then access the child
process using the Win32 API, for example wait for its termination
with the `WaitFor*()` functions, or examine its exit code with
`GetExitCodeProcess()`. You should close the handle with `CloseHandle()`
or g_spawn_close_pid() when you no longer need it.

If non-%NULL, the @stdin_pipe_out, @stdout_pipe_out, @stderr_pipe_out
locations will be filled with file descriptors for writing to the child's
standard input or reading from its standard output or standard error.
The caller of g_spawn_async_with_pipes() must close these file descriptors
when they are no longer in use. If these parameters are %NULL, the
corresponding pipe won't be created.

If @stdin_pipe_out is %NULL, the child's standard input is attached to
`/dev/null` unless %G_SPAWN_CHILD_INHERITS_STDIN is set.

If @stderr_pipe_out is NULL, the child's standard error goes to the same
location as the parent's standard error unless %G_SPAWN_STDERR_TO_DEV_NULL
is set.

If @stdout_pipe_out is NULL, the child's standard output goes to the same
location as the parent's standard output unless %G_SPAWN_STDOUT_TO_DEV_NULL
is set.

@error can be %NULL to ignore errors, or non-%NULL to report errors.
If an error is set, the function returns %FALSE. Errors are reported
even if they occur in the child (for example if the executable in
`@argv[0]` is not found). Typically the `message` field of returned
errors should be displayed to users. Possible errors are those from
the %G_SPAWN_ERROR domain.

If an error occurs, @child_pid, @stdin_pipe_out, @stdout_pipe_out,
and @stderr_pipe_out will not be filled with valid values.

If @child_pid is not %NULL and an error does not occur then the returned
process reference must be closed using g_spawn_close_pid().

On modern UNIX platforms, GLib can use an efficient process launching
codepath driven internally by `posix_spawn()`. This has the advantage of
avoiding the fork-time performance costs of cloning the parent process
address space, and avoiding associated memory overcommit checks that are
not relevant in the context of immediately executing a distinct process.
This optimized codepath will be used provided that the following conditions
are met:

1. %G_SPAWN_DO_NOT_REAP_CHILD is set
2. %G_SPAWN_LEAVE_DESCRIPTORS_OPEN is set
3. %G_SPAWN_SEARCH_PATH_FROM_ENVP is not set
4. @working_directory is %NULL
5. @child_setup is %NULL
6. The program is of a recognised binary format, or has a shebang.
   Otherwise, GLib will have to execute the program through the
   shell, which is not done using the optimized codepath.

If you are writing a GTK application, and the program you are spawning is a
graphical application too, then to ensure that the spawned program opens its
windows on the right screen, you may want to use #GdkAppLaunchContext,
#GAppLaunchContext, or set the `DISPLAY` environment variable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if an error was set</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="working_directory" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">child's current working
    directory, or %NULL to inherit parent's, in the GLib file name encoding</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:space="preserve">child's argument
    vector, in the GLib file name encoding; it must be non-empty and %NULL-terminated</doc>
          <array c:type="const gchar* const*">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="envp" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">
    child's environment, or %NULL to inherit parent's, in the GLib file
    name encoding</doc>
          <array c:type="const gchar* const*">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags from #GSpawnFlags</doc>
          <type name="SpawnFlags" c:type="GSpawnFlags"/>
        </parameter>
        <parameter name="child_setup" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
          <doc xml:space="preserve">function to run
    in the child just before `exec()`</doc>
          <type name="SpawnChildSetupFunc" c:type="GSpawnChildSetupFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data for @child_setup</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="stdin_fd" transfer-ownership="none">
          <doc xml:space="preserve">file descriptor to use for child's stdin, or `-1`</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="stdout_fd" transfer-ownership="none">
          <doc xml:space="preserve">file descriptor to use for child's stdout, or `-1`</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="stderr_fd" transfer-ownership="none">
          <doc xml:space="preserve">file descriptor to use for child's stderr, or `-1`</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="source_fds" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">array of FDs from the parent
   process to make available in the child process</doc>
          <array length="11" zero-terminated="0" c:type="const gint*">
            <type name="gint" c:type="gint"/>
          </array>
        </parameter>
        <parameter name="target_fds" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">array of FDs to remap
   @source_fds to in the child process</doc>
          <array length="11" zero-terminated="0" c:type="const gint*">
            <type name="gint" c:type="gint"/>
          </array>
        </parameter>
        <parameter name="n_fds" transfer-ownership="none">
          <doc xml:space="preserve">number of FDs in @source_fds and @target_fds</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="child_pid_out" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for child process ID, or %NULL</doc>
          <type name="Pid" c:type="GPid*"/>
        </parameter>
        <parameter name="stdin_pipe_out" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for file descriptor to write to child's stdin, or %NULL</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="stdout_pipe_out" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for file descriptor to read child's stdout, or %NULL</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="stderr_pipe_out" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for file descriptor to read child's stderr, or %NULL</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="spawn_check_exit_status" c:identifier="g_spawn_check_exit_status" version="2.34" deprecated="1" deprecated-version="2.70" throws="1">
      <doc xml:space="preserve">An old name for g_spawn_check_wait_status(), deprecated because its
name is misleading.

Despite the name of the function, @wait_status must be the wait status
as returned by g_spawn_sync(), g_subprocess_get_status(), `waitpid()`,
etc. On Unix platforms, it is incorrect for it to be the exit status
as passed to `exit()` or returned by g_subprocess_get_exit_status() or
`WEXITSTATUS()`.</doc>
      <doc-deprecated xml:space="preserve">Use g_spawn_check_wait_status() instead, and check whether your code is conflating wait and exit statuses.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if child exited successfully, %FALSE otherwise (and
    @error will be set)</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="wait_status" transfer-ownership="none">
          <doc xml:space="preserve">A status as returned from g_spawn_sync()</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="spawn_check_wait_status" c:identifier="g_spawn_check_wait_status" version="2.70" throws="1">
      <doc xml:space="preserve">Set @error if @wait_status indicates the child exited abnormally
(e.g. with a nonzero exit code, or via a fatal signal).

The g_spawn_sync() and g_child_watch_add() family of APIs return the
status of subprocesses encoded in a platform-specific way.
On Unix, this is guaranteed to be in the same format waitpid() returns,
and on Windows it is guaranteed to be the result of GetExitCodeProcess().

Prior to the introduction of this function in GLib 2.34, interpreting
@wait_status required use of platform-specific APIs, which is problematic
for software using GLib as a cross-platform layer.

Additionally, many programs simply want to determine whether or not
the child exited successfully, and either propagate a #GError or
print a message to standard error. In that common case, this function
can be used. Note that the error message in @error will contain
human-readable information about the wait status.

The @domain and @code of @error have special semantics in the case
where the process has an "exit code", as opposed to being killed by
a signal. On Unix, this happens if WIFEXITED() would be true of
@wait_status. On Windows, it is always the case.

The special semantics are that the actual exit code will be the
code set in @error, and the domain will be %G_SPAWN_EXIT_ERROR.
This allows you to differentiate between different exit codes.

If the process was terminated by some means other than an exit
status (for example if it was killed by a signal), the domain will be
%G_SPAWN_ERROR and the code will be %G_SPAWN_ERROR_FAILED.

This function just offers convenience; you can of course also check
the available platform via a macro such as %G_OS_UNIX, and use
WIFEXITED() and WEXITSTATUS() on @wait_status directly. Do not attempt
to scan or parse the error message string; it may be translated and/or
change in future versions of GLib.

Prior to version 2.70, g_spawn_check_exit_status() provides the same
functionality, although under a misleading name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if child exited successfully, %FALSE otherwise (and
  @error will be set)</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="wait_status" transfer-ownership="none">
          <doc xml:space="preserve">A platform-specific wait status as returned from g_spawn_sync()</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="spawn_close_pid" c:identifier="g_spawn_close_pid">
      <doc xml:space="preserve">On some platforms, notably Windows, the #GPid type represents a resource
which must be closed to prevent resource leaking. g_spawn_close_pid()
is provided for this purpose. It should be used on all platforms, even
though it doesn't do anything under UNIX.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pid" transfer-ownership="none">
          <doc xml:space="preserve">The process reference to close</doc>
          <type name="Pid" c:type="GPid"/>
        </parameter>
      </parameters>
    </function>
    <function name="spawn_command_line_async" c:identifier="g_spawn_command_line_async" throws="1">
      <doc xml:space="preserve">A simple version of g_spawn_async() that parses a command line with
g_shell_parse_argv() and passes it to g_spawn_async().

Runs a command line in the background. Unlike g_spawn_async(), the
%G_SPAWN_SEARCH_PATH flag is enabled, other flags are not. Note
that %G_SPAWN_SEARCH_PATH can have security implications, so
consider using g_spawn_async() directly if appropriate. Possible
errors are those from g_shell_parse_argv() and g_spawn_async().

The same concerns on Windows apply as for g_spawn_command_line_sync().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if error is set</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="command_line" transfer-ownership="none">
          <doc xml:space="preserve">a command line</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="spawn_command_line_sync" c:identifier="g_spawn_command_line_sync" throws="1">
      <doc xml:space="preserve">A simple version of g_spawn_sync() with little-used parameters
removed, taking a command line instead of an argument vector.

See g_spawn_sync() for full details.

The @command_line argument will be parsed by g_shell_parse_argv().

Unlike g_spawn_sync(), the %G_SPAWN_SEARCH_PATH flag is enabled.
Note that %G_SPAWN_SEARCH_PATH can have security implications, so
consider using g_spawn_sync() directly if appropriate.

Possible errors are those from g_spawn_sync() and those
from g_shell_parse_argv().

If @wait_status is non-%NULL, the platform-specific status of
the child is stored there; see the documentation of
g_spawn_check_wait_status() for how to use and interpret this.
On Unix platforms, note that it is usually not equal
to the integer passed to `exit()` or returned from `main()`.

On Windows, please note the implications of g_shell_parse_argv()
parsing @command_line. Parsing is done according to Unix shell rules, not
Windows command interpreter rules.
Space is a separator, and backslashes are
special. Thus you cannot simply pass a @command_line containing
canonical Windows paths, like "c:\\program files\\app\\app.exe", as
the backslashes will be eaten, and the space will act as a
separator. You need to enclose such paths with single quotes, like
"'c:\\program files\\app\\app.exe' 'e:\\folder\\argument.txt'".</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if an error was set</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="command_line" transfer-ownership="none">
          <doc xml:space="preserve">a command line</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="standard_output" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for child output</doc>
          <array c:type="gchar**">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="standard_error" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for child errors</doc>
          <array c:type="gchar**">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="wait_status" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for child wait status, as returned by waitpid()</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="spawn_error_quark" c:identifier="g_spawn_error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="spawn_exit_error_quark" c:identifier="g_spawn_exit_error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="spawn_sync" c:identifier="g_spawn_sync" throws="1">
      <doc xml:space="preserve">Executes a child synchronously (waits for the child to exit before returning).

All output from the child is stored in @standard_output and @standard_error,
if those parameters are non-%NULL. Note that you must set the
%G_SPAWN_STDOUT_TO_DEV_NULL and %G_SPAWN_STDERR_TO_DEV_NULL flags when
passing %NULL for @standard_output and @standard_error.

If @wait_status is non-%NULL, the platform-specific status of
the child is stored there; see the documentation of
g_spawn_check_wait_status() for how to use and interpret this.
On Unix platforms, note that it is usually not equal
to the integer passed to `exit()` or returned from `main()`.

Note that it is invalid to pass %G_SPAWN_DO_NOT_REAP_CHILD in
@flags, and on POSIX platforms, the same restrictions as for
g_child_watch_source_new() apply.

If an error occurs, no data is returned in @standard_output,
@standard_error, or @wait_status.

This function calls g_spawn_async_with_pipes() internally; see that
function for full details on the other parameters and details on
how these functions work on Windows.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if an error was set</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="working_directory" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">child's current working
    directory, or %NULL to inherit parent's</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:space="preserve">
    child's argument vector, which must be non-empty and %NULL-terminated</doc>
          <array c:type="gchar**">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="envp" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">
    child's environment, or %NULL to inherit parent's</doc>
          <array c:type="gchar**">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags from #GSpawnFlags</doc>
          <type name="SpawnFlags" c:type="GSpawnFlags"/>
        </parameter>
        <parameter name="child_setup" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="5">
          <doc xml:space="preserve">function to run
    in the child just before `exec()`</doc>
          <type name="SpawnChildSetupFunc" c:type="GSpawnChildSetupFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data for @child_setup</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="standard_output" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for child output, or %NULL</doc>
          <array c:type="gchar**">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="standard_error" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for child error messages, or %NULL</doc>
          <array c:type="gchar**">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="wait_status" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for child wait status, as returned by waitpid(), or %NULL</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="sprintf" c:identifier="g_sprintf" version="2.2" introspectable="0">
      <doc xml:space="preserve">An implementation of the standard `sprintf()` function which supports
positional parameters, as specified in the Single Unix Specification.

Note that it is usually better to use [func@GLib.snprintf], to avoid the
risk of buffer overflow.

`glib/gprintf.h` must be explicitly included in order to use this function.

See also [func@GLib.strdup_printf].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes printed</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">A pointer to a memory buffer to contain the resulting string. It
  is up to the caller to ensure that the allocated buffer is large
  enough to hold the formatted result.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a standard `printf()` format string, but notice
  [string precision pitfalls](string-utils.html#string-precision-pitfalls)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the arguments to insert in the output</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="stat" c:identifier="g_stat" version="2.6">
      <doc xml:space="preserve">A wrapper for the POSIX stat() function. The stat() function
returns information about a file. On Windows the stat() function in
the C library checks only the FAT-style READONLY attribute and does
not look at the ACL at all. Thus on Windows the protection bits in
the @st_mode field are a fabrication of little use.

On Windows the Microsoft C libraries have several variants of the
stat struct and stat() function with names like _stat(), _stat32(),
_stat32i64() and _stat64i32(). The one used here is for 32-bit code
the one with 32-bit size and time fields, specifically called _stat32().

In Microsoft's compiler, by default struct stat means one with
64-bit time fields while in MinGW struct stat is the legacy one
with 32-bit fields. To hopefully clear up this messs, the gstdio.h
header defines a type #GStatBuf which is the appropriate struct type
depending on the platform and/or compiler being used. On POSIX it
is just struct stat, but note that even on POSIX platforms, stat()
might be a macro.

See your C library manual for more details about stat().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the information was successfully retrieved,
    -1 if an error occurred</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a stat struct, which will be filled with the file
    information</doc>
          <type name="StatBuf" c:type="GStatBuf*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="static_mutex_lock" c:identifier="g_static_mutex_lock" introspectable="0" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Works like g_mutex_lock(), but for a #GStaticMutex.</doc>
      <doc-deprecated xml:space="preserve">Use g_mutex_lock()</doc-deprecated>
      <parameters>
        <parameter name="mutex">
          <doc xml:space="preserve">a #GStaticMutex.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="static_mutex_trylock" c:identifier="g_static_mutex_trylock" introspectable="0" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Works like g_mutex_trylock(), but for a #GStaticMutex.</doc>
      <doc-deprecated xml:space="preserve">Use g_mutex_trylock()</doc-deprecated>
      <parameters>
        <parameter name="mutex">
          <doc xml:space="preserve">a #GStaticMutex.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="static_mutex_unlock" c:identifier="g_static_mutex_unlock" introspectable="0" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Works like g_mutex_unlock(), but for a #GStaticMutex.</doc>
      <doc-deprecated xml:space="preserve">Use g_mutex_unlock()</doc-deprecated>
      <parameters>
        <parameter name="mutex">
          <doc xml:space="preserve">a #GStaticMutex.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-inline name="steal_fd" c:identifier="g_steal_fd" version="2.70" introspectable="0">
      <doc xml:space="preserve">Sets @fd_ptr to `-1`, returning the value that was there before.

Conceptually, this transfers the ownership of the file descriptor
from the referenced variable to the caller of the function (i.e.
&#x2018;steals&#x2019; the reference). This is very similar to [func@GLib.steal_pointer],
but for file descriptors.

On POSIX platforms, this function is async-signal safe
(see [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7))), making it safe to call from a
signal handler or a #GSpawnChildSetupFunc.

This function preserves the value of `errno`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the value that @fd_ptr previously had</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="fd_ptr" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">A pointer to a file descriptor</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function-inline>
    <function-inline name="steal_handle_id" c:identifier="g_steal_handle_id" version="2.84" introspectable="0">
      <doc xml:space="preserve">Sets @handle_pointer to `0`, returning the value that was there before.

Conceptually, this transfers the ownership of the handle ID from the
referenced variable to the &#x2018;caller&#x2019; of the macro (ie: &#x2018;steals&#x2019; the
handle ID).

This can be very useful to make ownership transfer explicit, or to prevent
a handle from being released multiple times. For example:

```c
void
maybe_unsubscribe_signal (ContextStruct *data)
{
  if (some_complex_logic (data))
    {
      g_dbus_connection_signal_unsubscribe (data-&gt;connection,
                                            g_steal_handle_id (&amp;data-&gt;subscription_id));
      // now data-&gt;subscription_id isn&#x2019;t a dangling handle
    }
}
```

While [func@GLib.clear_handle_id] can be used in many of the same situations
as `g_steal_handle_id()`, this is one situation where it cannot be used, as
there is no way to pass the `GDBusConnection` to a
[type@GLib.ClearHandleFunc].</doc>
      <return-value transfer-ownership="none">
        <type name="guint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="handle_pointer" direction="inout" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">a pointer to a handle ID</doc>
          <type name="guint" c:type="unsigned int*"/>
        </parameter>
      </parameters>
    </function-inline>
    <function-inline name="steal_pointer" c:identifier="g_steal_pointer" version="2.44" introspectable="0">
      <doc xml:space="preserve">Sets @pp to %NULL, returning the value that was there before.

Conceptually, this transfers the ownership of the pointer from the
referenced variable to the "caller" of the macro (ie: "steals" the
reference).

The return value will be properly typed, according to the type of
@pp.

This can be very useful when combined with g_autoptr() to prevent the
return value of a function from being automatically freed.  Consider
the following example (which only works on GCC and clang):

|[
GObject *
create_object (void)
{
  g_autoptr(GObject) obj = g_object_new (G_TYPE_OBJECT, NULL);

  if (early_error_case)
    return NULL;

  return g_steal_pointer (&amp;obj);
}
]|

It can also be used in similar ways for 'out' parameters and is
particularly useful for dealing with optional out parameters:

|[
gboolean
get_object (GObject **obj_out)
{
  g_autoptr(GObject) obj = g_object_new (G_TYPE_OBJECT, NULL);

  if (early_error_case)
    return FALSE;

  if (obj_out)
    *obj_out = g_steal_pointer (&amp;obj);

  return TRUE;
}
]|

In the above example, the object will be automatically freed in the
early error case and also in the case that %NULL was given for
@obj_out.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="pp" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a pointer</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function-inline>
    <function name="stpcpy" c:identifier="g_stpcpy">
      <doc xml:space="preserve">Copies a nul-terminated string into the destination buffer, including
the trailing nul byte, and returns a pointer to the trailing nul byte
in `dest`.  The return value is useful for concatenating multiple
strings without having to repeatedly scan for the end.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to the trailing nul byte in `dest`</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">destination buffer</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">source string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="str_equal" c:identifier="g_str_equal">
      <doc xml:space="preserve">Compares two strings for byte-by-byte equality and returns %TRUE
if they are equal. It can be passed to g_hash_table_new() as the
@key_equal_func parameter, when using non-%NULL strings as keys in a
#GHashTable.

This function is typically used for hash table comparisons, but can be used
for general purpose comparisons of non-%NULL strings. For a %NULL-safe string
comparison function, see g_strcmp0().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the two keys match</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <doc xml:space="preserve">a key</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <doc xml:space="preserve">a key to compare with @v1</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="str_has_prefix" c:identifier="g_str_has_prefix" version="2.2">
      <doc xml:space="preserve">Looks whether the string @str begins with @prefix.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if @str begins with @prefix, false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string to look in</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="prefix" transfer-ownership="none">
          <doc xml:space="preserve">the prefix to look for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="str_has_suffix" c:identifier="g_str_has_suffix" version="2.2">
      <doc xml:space="preserve">Looks whether a string ends with @suffix.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if @str ends with @suffix, false otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string to look in</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="suffix" transfer-ownership="none">
          <doc xml:space="preserve">the suffix to look for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="str_hash" c:identifier="g_str_hash">
      <doc xml:space="preserve">Converts a string to a hash value.

This function implements the widely used "djb" hash apparently
posted by Daniel Bernstein to comp.lang.c some time ago.  The 32
bit unsigned hash value starts at 5381 and for each byte 'c' in
the string, is updated: `hash = hash * 33 + c`. This function
uses the signed value of each byte.

It can be passed to g_hash_table_new() as the @hash_func parameter,
when using non-%NULL strings as keys in a #GHashTable.

Note that this function may not be a perfect fit for all use cases.
For example, it produces some hash collisions with strings as short
as 2.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a hash value corresponding to the key</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="v" transfer-ownership="none">
          <doc xml:space="preserve">a string key</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="str_is_ascii" c:identifier="g_str_is_ascii" version="2.40">
      <doc xml:space="preserve">Determines if a string is pure ASCII. A string is pure ASCII if it
contains no bytes with the high bit set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if @str is ASCII</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="str_match_string" c:identifier="g_str_match_string" version="2.40">
      <doc xml:space="preserve">Checks if a search conducted for @search_term should match
@potential_hit.

This function calls [func@GLib.str_tokenize_and_fold] on both
@search_term and @potential_hit. ASCII alternates are never taken
for @search_term but will be taken for @potential_hit according to
the value of @accept_alternates.

A hit occurs when each folded token in @search_term is a prefix of a
folded token from @potential_hit.

Depending on how you're performing the search, it will typically be
faster to call `g_str_tokenize_and_fold()` on each string in
your corpus and build an index on the returned folded tokens, then
call `g_str_tokenize_and_fold()` on the search term and
perform lookups into that index.

As some examples, searching for &#x2018;fred&#x2019; would match the potential hit
&#x2018;Smith, Fred&#x2019; and also &#x2018;Fr&#xE9;d&#xE9;ric&#x2019;.  Searching for &#x2018;Fr&#xE9;d&#x2019; would match
&#x2018;Fr&#xE9;d&#xE9;ric&#x2019; but not &#x2018;Frederic&#x2019; (due to the one-directional nature of
accent matching).  Searching &#x2018;fo&#x2019; would match &#x2018;Foo&#x2019; and &#x2018;Bar Foo
Baz&#x2019;, but not &#x2018;SFO&#x2019; (because no word has &#x2018;fo&#x2019; as a prefix).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if @potential_hit is a hit</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="search_term" transfer-ownership="none">
          <doc xml:space="preserve">the search term from the user</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="potential_hit" transfer-ownership="none">
          <doc xml:space="preserve">the text that may be a hit</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="accept_alternates" transfer-ownership="none">
          <doc xml:space="preserve">if true, ASCII alternates are accepted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="str_to_ascii" c:identifier="g_str_to_ascii" version="2.40">
      <doc xml:space="preserve">Transliterate @str to plain ASCII.

For best results, @str should be in composed normalised form.

This function performs a reasonably good set of character
replacements.  The particular set of replacements that is done may
change by version or even by runtime environment.

If the source language of @str is known, it can used to improve the
accuracy of the translation by passing it as @from_locale.  It should
be a valid POSIX locale string (of the form
`language[_territory][.codeset][@modifier]`).

If @from_locale is %NULL then the current locale is used.

If you want to do translation for no specific locale, and you want it
to be done independently of the currently locale, specify `"C"` for
@from_locale.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a string in plain ASCII</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string, in UTF-8</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="from_locale" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the source locale, if known</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="str_tokenize_and_fold" c:identifier="g_str_tokenize_and_fold" version="2.40">
      <doc xml:space="preserve">Tokenizes @string and performs folding on each token.

A token is a non-empty sequence of alphanumeric characters in the
source string, separated by non-alphanumeric characters.  An
"alphanumeric" character for this purpose is one that matches
[func@GLib.unichar_isalnum] or [func@GLib.unichar_ismark].

Each token is then (Unicode) normalised and case-folded.  If
@ascii_alternates is non-`NULL` and some of the returned tokens
contain non-ASCII characters, ASCII alternatives will be generated.

The number of ASCII alternatives that are generated and the method
for doing so is unspecified, but @translit_locale (if specified) may
improve the transliteration if the language of the source string is
known.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the folded tokens</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a string to tokenize</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="translit_locale" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the language code (like 'de' or
  'en_GB') from which @string originates</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="ascii_alternates" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">
  a return location for ASCII alternates</doc>
          <array c:type="gchar***">
            <type name="utf8" c:type="gchar**"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="strcanon" c:identifier="g_strcanon">
      <doc xml:space="preserve">For each character in @string, if the character is not in @valid_chars,
replaces the character with @substitutor.

Modifies @string in place, and return @string itself, not a copy. The
return value is to allow nesting such as:
```C
g_ascii_strup (g_strcanon (str, "abc", '?'))
```

In order to modify a copy, you may use [func@GLib.strdup]:
```C
reformatted = g_strcanon (g_strdup (const_str), "abc", '?');
&#x2026;
g_free (reformatted);
```</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the modified @string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a nul-terminated array of bytes</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid_chars" transfer-ownership="none">
          <doc xml:space="preserve">bytes permitted in @string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="substitutor" transfer-ownership="none">
          <doc xml:space="preserve">replacement character for disallowed bytes</doc>
          <type name="gchar" c:type="gchar"/>
        </parameter>
      </parameters>
    </function>
    <function name="strcasecmp" c:identifier="g_strcasecmp" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">A case-insensitive string comparison, corresponding to the standard
`strcasecmp()` function on platforms which support it.</doc>
      <doc-deprecated xml:space="preserve">See [func@GLib.strncasecmp] for a discussion of why this
  function is deprecated and how to replace it.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the strings match, a negative value if @s1 &lt; @s2,
  or a positive value if @s1 &gt; @s2</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="s1" transfer-ownership="none">
          <doc xml:space="preserve">string to compare with @s2</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="s2" transfer-ownership="none">
          <doc xml:space="preserve">string to compare with @s1</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strchomp" c:identifier="g_strchomp">
      <doc xml:space="preserve">Removes trailing whitespace from a string.

This function doesn't allocate or reallocate any memory;
it modifies @string in place. Therefore, it cannot be used
on statically allocated strings.

The pointer to @string is returned to allow the nesting of functions.

Also see [func@GLib.strchug] and [func@GLib.strstrip].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the modified @string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a string to remove the trailing whitespace from</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strchug" c:identifier="g_strchug">
      <doc xml:space="preserve">Removes leading whitespace from a string, by moving the rest
of the characters forward.

This function doesn't allocate or reallocate any memory;
it modifies @string in place. Therefore, it cannot be used on
statically allocated strings.

The pointer to @string is returned to allow the nesting of functions.

Also see [func@GLib.strchomp] and [func@GLib.strstrip].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the modified @string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a string to remove the leading whitespace from</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strcmp0" c:identifier="g_strcmp0" version="2.16">
      <doc xml:space="preserve">Compares @str1 and @str2 like `strcmp()`.

Handles `NULL` gracefully by sorting it before non-`NULL` strings.
Comparing two `NULL` pointers returns 0.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">an integer less than, equal to, or greater than zero,
  if @str1 is &lt;, == or &gt; than @str2</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="str1" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="str2" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">another string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strcompress" c:identifier="g_strcompress">
      <doc xml:space="preserve">Makes a copy of a string replacing C string-style escape
sequences with their one byte equivalent:

- `\b` &#x2192; [U+0008 Backspace](https://en.wikipedia.org/wiki/Backspace)
- `\f` &#x2192; [U+000C Form Feed](https://en.wikipedia.org/wiki/Form_feed)
- `\n` &#x2192; [U+000A Line Feed](https://en.wikipedia.org/wiki/Newline)
- `\r` &#x2192; [U+000D Carriage Return](https://en.wikipedia.org/wiki/Carriage_return)
- `\t` &#x2192; [U+0009 Horizontal Tabulation](https://en.wikipedia.org/wiki/Tab_character)
- `\v` &#x2192; [U+000B Vertical Tabulation](https://en.wikipedia.org/wiki/Vertical_Tab)
- `\` followed by one to three octal digits &#x2192; the numeric value (mod 255)
- `\` followed by any other character &#x2192; the character as is.
  For example, `\\` will turn into a backslash (`\`) and `\"` into a double quote (`"`).

[func@GLib.strescape] does the reverse conversion.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated copy of @source with all escaped
  character compressed</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">a string to compress</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strconcat" c:identifier="g_strconcat" introspectable="0">
      <doc xml:space="preserve">Concatenates all of the given strings into one long string.

The variable argument list must end with `NULL`. If you forget the `NULL`,
`g_strconcat()` will start appending random memory junk to your string.

Note that this function is usually not the right function to use to
assemble a translated message from pieces, since proper translation
often requires the pieces to be reordered.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated string containing all the string arguments</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string1" transfer-ownership="none">
          <doc xml:space="preserve">the first string to add, which must not be `NULL`</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a `NULL`-terminated list of strings to append to the string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="strdelimit" c:identifier="g_strdelimit">
      <doc xml:space="preserve">Converts any delimiter characters in @string to @new_delimiter.

Any characters in @string which are found in @delimiters are
changed to the @new_delimiter character. Modifies @string in place,
and returns @string itself, not a copy.

The return value is to allow nesting such as:
```C
g_ascii_strup (g_strdelimit (str, "abc", '?'))
```

In order to modify a copy, you may use [func@GLib.strdup]:
```C
reformatted = g_strdelimit (g_strdup (const_str), "abc", '?');
&#x2026;
g_free (reformatted);
```</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the modified @string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the string to convert</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="delimiters" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string containing the current delimiters, or
  `NULL` to use the standard delimiters defined in [const@GLib.STR_DELIMITERS]</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="new_delimiter" transfer-ownership="none">
          <doc xml:space="preserve">the new delimiter character</doc>
          <type name="gchar" c:type="gchar"/>
        </parameter>
      </parameters>
    </function>
    <function name="strdown" c:identifier="g_strdown" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Converts a string to lower case.</doc>
      <doc-deprecated xml:space="preserve">This function is totally broken for the reasons discussed
  in the [func@GLib.strncasecmp] docs &#x2014; use [func@GLib.ascii_strdown] or
  [func@GLib.utf8_strdown] instead.</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the string to convert</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strdup" c:identifier="g_strdup">
      <doc xml:space="preserve">Duplicates a string. If @str is `NULL` it returns `NULL`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated copy of @str</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the string to duplicate</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strdup_printf" c:identifier="g_strdup_printf" introspectable="0">
      <doc xml:space="preserve">Similar to the standard C `sprintf()` function but safer, since it
calculates the maximum space required and allocates memory to hold
the result.

The returned string is guaranteed to be non-NULL, unless @format
contains `%lc` or `%ls` conversions, which can fail if no multibyte
representation is available for the given character.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a newly-allocated string holding the
  result</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a standard `printf()` format string, but notice
  [string precision pitfalls](string-utils.html#string-precision-pitfalls)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the parameters to insert into the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="strdup_vprintf" c:identifier="g_strdup_vprintf" introspectable="0">
      <doc xml:space="preserve">Similar to the standard C `vsprintf()` function but safer, since it
calculates the maximum space required and allocates memory to hold
the result.

The returned string is guaranteed to be non-NULL, unless @format
contains `%lc` or `%ls` conversions, which can fail if no multibyte
representation is available for the given character.

See also [func@GLib.vasprintf], which offers the same functionality, but
additionally returns the length of the allocated string.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a newly-allocated string holding the
  result</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a standard `printf()` format string, but notice
  [string precision pitfalls](string-utils.html#string-precision-pitfalls)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">the list of parameters to insert into the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="strdupv" c:identifier="g_strdupv">
      <doc xml:space="preserve">Copies an array of strings. The copy is a deep copy; each string is also
copied.

If called on a `NULL` value, `g_strdupv()` simply returns `NULL`.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a
  newly-allocated array of strings. Use [func@GLib.strfreev] to free it.</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="str_array" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">an array of strings to copy</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="strerror" c:identifier="g_strerror">
      <doc xml:space="preserve">Returns a string corresponding to the given error code, e.g. "no
such process".

Unlike `strerror()`, this always returns a string in
UTF-8 encoding, and the pointer is guaranteed to remain valid for
the lifetime of the process. If the error code is unknown, it returns a
string like &#x201C;Unknown error &lt;code\&gt;&#x201D;.

Note that the string may be translated according to the current locale.

The value of `errno` will not be changed by this function. However, it may
be changed by intermediate function calls, so you should save its value
as soon as the call returns:
```C
int saved_errno;

ret = read (blah);
saved_errno = errno;

g_strerror (saved_errno);
```</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the string describing the error code</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="errnum" transfer-ownership="none">
          <doc xml:space="preserve">the system error number. See the standard C `errno` documentation</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="strescape" c:identifier="g_strescape">
      <doc xml:space="preserve">It replaces the following special characters in the string @source
with their corresponding C escape sequence:

| Symbol                                                                      | Escape |
|-----------------------------------------------------------------------------|--------|
| [U+0008 Backspace](https://en.wikipedia.org/wiki/Backspace)                 | `\b`   |
| [U+000C Form Feed](https://en.wikipedia.org/wiki/Form_feed)                 | `\f`   |
| [U+000A Line Feed](https://en.wikipedia.org/wiki/Newline)                   | `\n`   |
| [U+000D Carriage Return](https://en.wikipedia.org/wiki/Carriage_return)     | `\r`   |
| [U+0009 Horizontal Tabulation](https://en.wikipedia.org/wiki/Tab_character) | `\t`   |
| [U+000B Vertical Tabulation](https://en.wikipedia.org/wiki/Vertical_Tab)    | `\v`   |

It also inserts a backslash (`\`) before any backslash or a double quote (`"`).
Additionally all characters in the range 0x01-0x1F (everything
below SPACE) and in the range 0x7F-0xFF (all non-ASCII chars) are
replaced with a backslash followed by their octal representation.
Characters supplied in @exceptions are not escaped.

[func@GLib.strcompress] does the reverse conversion.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated copy of @source with special characters escaped</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">a string to escape</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="exceptions" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string of characters not to escape in @source</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strfreev" c:identifier="g_strfreev">
      <doc xml:space="preserve">Frees an array of strings, as well as each string it contains.

If @str_array is `NULL`, this function simply returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="str_array" transfer-ownership="full" nullable="1" allow-none="1">
          <doc xml:space="preserve">an
  array of strings to free</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="strip_context" c:identifier="g_strip_context" version="2.4">
      <doc xml:space="preserve">An auxiliary function for gettext() support (see Q_()).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">@msgval, unless @msgval is identical to @msgid
    and contains a '|' character, in which case a pointer to
    the substring of msgid after the first '|' character is returned.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="msgid" transfer-ownership="none">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="msgval" transfer-ownership="none">
          <doc xml:space="preserve">another string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strjoin" c:identifier="g_strjoin" introspectable="0">
      <doc xml:space="preserve">Joins a number of strings together to form one long string, with the
optional @separator inserted between each of them.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated string containing all of the strings joined
  together, with @separator between them</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="separator" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string to insert between each of the strings</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a `NULL`-terminated list of strings to join</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="strjoinv" c:identifier="g_strjoinv">
      <doc xml:space="preserve">Joins an array of strings together to form one long string, with the
optional @separator inserted between each of them.

If @str_array has no items, the return value will be an
empty string. If @str_array contains a single item, @separator will not
appear in the resulting string.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated string containing all of the strings joined
  together, with @separator between them</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="separator" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string to insert between each of the strings</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="str_array" transfer-ownership="none">
          <doc xml:space="preserve">an array of strings to join</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="strlcat" c:identifier="g_strlcat">
      <doc xml:space="preserve">Portability wrapper that calls `strlcat()` on systems which have it,
and emulates it otherwise. Appends nul-terminated @src string to @dest,
guaranteeing nul-termination for @dest. The total size of @dest won't
exceed @dest_size.

At most @dest_size - 1 characters will be copied. Unlike `strncat()`,
@dest_size is the full size of dest, not the space left over. This
function does not allocate memory. It always nul-terminates (unless
@dest_size == 0 or there were no nul characters in the @dest_size
characters of dest to start with).

Caveat: this is supposedly a more secure alternative to `strcat()` or
`strncat()`, but for real security [func@GLib.strconcat] is harder to mess up.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">size of attempted result, which is `MIN (dest_size, strlen
  (original dest)) + strlen (src)`, so if @retval &gt;= @dest_size,
  truncation occurred</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">destination buffer, already containing one nul-terminated string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">source buffer</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="dest_size" transfer-ownership="none">
          <doc xml:space="preserve">length of @dest buffer in bytes (not length of existing string
  inside @dest)</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="strlcpy" c:identifier="g_strlcpy">
      <doc xml:space="preserve">Portability wrapper that calls `strlcpy()` on systems which have it,
and emulates `strlcpy()` otherwise. Copies @src to @dest; @dest is
guaranteed to be nul-terminated; @src must be nul-terminated;
@dest_size is the buffer size, not the number of bytes to copy.

At most @dest_size - 1 characters will be copied. Always nul-terminates
(unless @dest_size is 0). This function does not allocate memory. Unlike
`strncpy()`, this function doesn't pad @dest (so it's often faster). It
returns the size of the attempted result, `strlen (src)`, so if
@retval &gt;= @dest_size, truncation occurred.

Caveat: `strlcpy()` is supposedly more secure than `strcpy()` or `strncpy()`,
but if you really want to avoid screwups, [func@GLib.strdup] is an even better
idea.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">length of @src</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">destination buffer</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">source buffer</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="dest_size" transfer-ownership="none">
          <doc xml:space="preserve">length of @dest in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="strncasecmp" c:identifier="g_strncasecmp" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">A case-insensitive string comparison, corresponding to the standard
`strncasecmp()` function on platforms which support it. It is similar
to [func@GLib.strcasecmp] except it only compares the first @n characters of
the strings.</doc>
      <doc-deprecated xml:space="preserve">The problem with `g_strncasecmp()` is that it does
  the comparison by calling `toupper()`/`tolower()`. These functions
  are locale-specific and operate on single bytes. However, it is
  impossible to handle things correctly from an internationalization
  standpoint by operating on bytes, since characters may be multibyte.
  Thus `g_strncasecmp()` is broken if your string is guaranteed to be
  ASCII, since it is locale-sensitive, and it's broken if your string
  is localized, since it doesn't work on many encodings at all,
  including UTF-8, EUC-JP, etc.

  There are therefore two replacement techniques: [func@GLib.ascii_strncasecmp],
  which only works on ASCII and is not locale-sensitive, and
  [func@GLib.utf8_casefold] followed by `strcmp()` on the resulting strings,
  which is good for case-insensitive sorting of UTF-8.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the strings match, a negative value if @s1 &lt; @s2,
  or a positive value if @s1 &gt; @s2</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="s1" transfer-ownership="none">
          <doc xml:space="preserve">string to compare with @s2</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="s2" transfer-ownership="none">
          <doc xml:space="preserve">string to compare with @s1</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of characters to compare</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="strndup" c:identifier="g_strndup">
      <doc xml:space="preserve">Duplicates the first @n bytes of a string, returning a newly-allocated
buffer @n + 1 bytes long which will always be nul-terminated. If @str
is less than @n bytes long the buffer is padded with nuls. If @str is
`NULL` it returns `NULL`.

To copy a number of characters from a UTF-8 encoded string,
use [func@GLib.utf8_strncpy] instead.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a newly-allocated buffer containing the first
   @n bytes of @str</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the string to duplicate</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of bytes to copy from @str</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="strnfill" c:identifier="g_strnfill">
      <doc xml:space="preserve">Creates a new string @length bytes long filled with @fill_char.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated string filled with @fill_char</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of the new string</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="fill_char" transfer-ownership="none">
          <doc xml:space="preserve">the byte to fill the string with</doc>
          <type name="gchar" c:type="gchar"/>
        </parameter>
      </parameters>
    </function>
    <function name="strreverse" c:identifier="g_strreverse">
      <doc xml:space="preserve">Reverses all of the bytes in a string. For example,
`g_strreverse ("abcdef")` will result in "fedcba".

Note that `g_strreverse()` doesn't work on UTF-8 strings
containing multibyte characters. For that purpose, use
[func@GLib.utf8_strreverse].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the @string, reversed in place</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the string to reverse</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strrstr" c:identifier="g_strrstr">
      <doc xml:space="preserve">Searches the string @haystack for the last occurrence
of the string @needle.

The fact that this function returns `gchar *` rather than `const gchar *` is
a historical artifact.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the found occurrence, or
   `NULL` if not found</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="haystack" transfer-ownership="none">
          <doc xml:space="preserve">a string to search in</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="needle" transfer-ownership="none">
          <doc xml:space="preserve">the string to search for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strrstr_len" c:identifier="g_strrstr_len">
      <doc xml:space="preserve">Searches the string @haystack for the last occurrence
of the string @needle, limiting the length of the search
to @haystack_len.

The fact that this function returns `gchar *` rather than `const gchar *` is
a historical artifact.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the found occurrence, or
   `NULL` if not found</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="haystack" transfer-ownership="none">
          <doc xml:space="preserve">a string to search in</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="haystack_len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length of @haystack in bytes. A length of `-1`
  can be used to mean "search the entire string", like [func@GLib.strrstr]</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="needle" transfer-ownership="none">
          <doc xml:space="preserve">the string to search for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strsignal" c:identifier="g_strsignal">
      <doc xml:space="preserve">Returns a string describing the given signal, e.g. "Segmentation fault".
If the signal is unknown, it returns &#x201C;unknown signal (&lt;signum\&gt;)&#x201D;.

You should use this function in preference to `strsignal()`, because it
returns a string in UTF-8 encoding, and since not all platforms support
the `strsignal()` function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the string describing the signal</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="signum" transfer-ownership="none">
          <doc xml:space="preserve">the signal number. See the `signal` documentation</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="strsplit" c:identifier="g_strsplit">
      <doc xml:space="preserve">Splits a string into a maximum of @max_tokens pieces, using the given
@delimiter. If @max_tokens is reached, the remainder of @string is
appended to the last token.

As an example, the result of `g_strsplit (":a:bc::d:", ":", -1)` is an array
containing the six strings "", "a", "bc", "", "d" and "".

As a special case, the result of splitting the empty string "" is an empty
array, not an array containing a single string. The reason for this
special case is that being able to represent an empty array is typically
more useful than consistent handling of empty elements. If you do need
to represent empty elements, you'll need to check for the empty string
before calling `g_strsplit()`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated array of strings, freed with
  [func@GLib.strfreev]</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a string to split</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="delimiter" transfer-ownership="none">
          <doc xml:space="preserve">a string which specifies the places at which to split
  the string. The delimiter is not included in any of the resulting
  strings, unless @max_tokens is reached.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="max_tokens" transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of pieces to split @string into
  If this is less than 1, the string is split completely</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="strsplit_set" c:identifier="g_strsplit_set" version="2.4">
      <doc xml:space="preserve">Splits @string into a number of tokens not containing any of the characters
in @delimiters. A token is the (possibly empty) longest string that does not
contain any of the characters in @delimiters. If @max_tokens is reached, the
remainder is appended to the last token.

For example, the result of g_strsplit_set ("abc:def/ghi", ":/", -1) is an
array containing the three strings "abc", "def", and "ghi".

The result of g_strsplit_set (":def/ghi:", ":/", -1) is an array containing
the four strings "", "def", "ghi", and "".

As a special case, the result of splitting the empty string "" is an empty
array, not an array containing a single string. The reason for this
special case is that being able to represent an empty array is typically
more useful than consistent handling of empty elements. If you do need
to represent empty elements, you'll need to check for the empty string
before calling `g_strsplit_set()`.

Note that this function works on bytes not characters, so it can't be used
to delimit UTF-8 strings for anything but ASCII characters.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated array of strings. Use
  [func@GLib.strfreev] to free it.</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a string to split</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="delimiters" transfer-ownership="none">
          <doc xml:space="preserve">a string containing characters that are used to split the
  string. Can be empty, which will result in no string splitting</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="max_tokens" transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of tokens to split @string into.
  If this is less than 1, the string is split completely</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="strstr_len" c:identifier="g_strstr_len">
      <doc xml:space="preserve">Searches the string @haystack for the first occurrence
of the string @needle, limiting the length of the search
to @haystack_len or a nul terminator byte (whichever is reached first).

A length of `-1` can be used to mean &#x201C;search the entire string&#x201D;, like
`strstr()`.

The fact that this function returns `gchar *` rather than `const gchar *` is
a historical artifact.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the found occurrence, or
   `NULL` if not found</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="haystack" transfer-ownership="none">
          <doc xml:space="preserve">a string to search in</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="haystack_len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length of @haystack in bytes, or `-1` to
  search it entirely</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="needle" transfer-ownership="none">
          <doc xml:space="preserve">the string to search for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="strstrip" c:identifier="g_strstrip" introspectable="0">
      <doc xml:space="preserve">Removes leading and trailing whitespace from a string.

See [func@GLib.strchomp] and [func@GLib.strchug].</doc>
      <parameters>
        <parameter name="string">
          <doc xml:space="preserve">a string to remove the leading and trailing whitespace from</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="strtod" c:identifier="g_strtod">
      <doc xml:space="preserve">Converts a string to a floating point value.

It calls the standard `strtod()` function to handle the conversion, but
if the string is not completely converted it attempts the conversion
again with [func@GLib.ascii_strtod], and returns the best match.

This function should seldom be used. The normal situation when reading
numbers not for human consumption is to use [func@GLib.ascii_strtod]. Only when
you know that you must expect both locale formatted and C formatted numbers
should you use this. Make sure that you don't pass strings such as comma
separated lists of values, since the commas may be interpreted as a decimal
point in some locales, causing unexpected results.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the converted value</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="nptr" transfer-ownership="none">
          <doc xml:space="preserve">the string to convert to a numeric value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="endptr" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-`NULL`, it returns the
  character after the last character used in the conversion</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="strup" c:identifier="g_strup" deprecated="1" deprecated-version="2.2">
      <doc xml:space="preserve">Converts a string to upper case.</doc>
      <doc-deprecated xml:space="preserve">This function is totally broken for the reasons discussed
  in the [func@GLib.strncasecmp] docs &#x2014; use [func@GLib.ascii_strup] or
  [func@GLib.utf8_strup] instead.</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the string to convert</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strv_contains" c:identifier="g_strv_contains" version="2.44">
      <doc xml:space="preserve">Checks if an array of strings contains the string @str according to
[func@GLib.str_equal]. @strv must not be `NULL`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if @str is an element of @strv</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="strv" transfer-ownership="none">
          <doc xml:space="preserve">an array of strings to search in</doc>
          <array c:type="const gchar* const*">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the string to search for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strv_equal" c:identifier="g_strv_equal" version="2.60">
      <doc xml:space="preserve">Checks if two arrays of strings contain exactly the same elements in
exactly the same order.

Elements are compared using [func@GLib.str_equal]. To match independently
of order, sort the arrays first (using [func@GLib.qsort_with_data]
or similar).

Two empty arrays are considered equal. Neither @strv1 nor @strv2 may be
`NULL`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if @strv1 and @strv2 are equal</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="strv1" transfer-ownership="none">
          <doc xml:space="preserve">an array of strings to compare to @strv2</doc>
          <array c:type="const gchar* const*">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="strv2" transfer-ownership="none">
          <doc xml:space="preserve">an array of strings to compare to @strv1</doc>
          <array c:type="const gchar* const*">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="strv_get_type" c:identifier="g_strv_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="strv_length" c:identifier="g_strv_length" version="2.6">
      <doc xml:space="preserve">Returns the length of an array of strings. @str_array must not be `NULL`.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">length of @str_array</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="str_array" transfer-ownership="none">
          <doc xml:space="preserve">an array of strings</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function-macro name="test_add" c:identifier="g_test_add" version="2.16" introspectable="0">
      <doc xml:space="preserve">Hooks up a new test case at @testpath.

This function is similar to [func@GLib.test_add_func].

A fixture data structure with setup and teardown functions
may be provided, similar to [func@GLib.test_create_case].

`g_test_add()` is implemented as a macro, so that the @fsetup,
@ftest and @fteardown callbacks can expect a @Fixture pointer
as their first argument in a type safe manner. They otherwise
have type `GTestFixtureFunc`.</doc>
      <parameters>
        <parameter name="testpath">
          <doc xml:space="preserve">the test path for a new test case</doc>
        </parameter>
        <parameter name="Fixture">
          <doc xml:space="preserve">the type of a fixture data structure</doc>
        </parameter>
        <parameter name="tdata">
          <doc xml:space="preserve">data argument for the test functions</doc>
        </parameter>
        <parameter name="fsetup">
          <doc xml:space="preserve">the function to set up the fixture data</doc>
        </parameter>
        <parameter name="ftest">
          <doc xml:space="preserve">the actual test function</doc>
        </parameter>
        <parameter name="fteardown">
          <doc xml:space="preserve">the function to tear down the fixture data</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="test_add_data_func" c:identifier="g_test_add_data_func" version="2.16">
      <doc xml:space="preserve">Creates a new test case.

This function is similar to [func@GLib.test_create_case].
However the test is assumed to use no fixture, and test suites are
automatically created on the fly and added to the root fixture,
based on the /-separated portions of @testpath. The @test_data
argument will be passed as first argument to @test_func.

If @testpath includes the component "subprocess" anywhere in it,
the test will be skipped by default, and only run if explicitly
required via the `-p` command-line option or [func@GLib.test_trap_subprocess].

No component of @testpath may start with a dot (`.`) if the
[const@GLib.TEST_OPTION_ISOLATE_DIRS] option is being used;
and it is recommended to do so even if it isn&#x2019;t.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="testpath" transfer-ownership="none">
          <doc xml:space="preserve">a /-separated name for the test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="test_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data for the @test_func</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="test_func" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">the test function to invoke for this test</doc>
          <type name="TestDataFunc" c:type="GTestDataFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_add_data_func_full" c:identifier="g_test_add_data_func_full" version="2.34">
      <doc xml:space="preserve">Creates a new test case.

In contrast to [func@GLib.test_add_data_func], this function
is freeing @test_data after the test run is complete.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="testpath" transfer-ownership="none">
          <doc xml:space="preserve">a /-separated name for the test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="test_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data for @test_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="test_func" transfer-ownership="none" scope="notified" destroy="3">
          <doc xml:space="preserve">the test function to invoke for this test</doc>
          <type name="TestDataFunc" c:type="GTestDataFunc"/>
        </parameter>
        <parameter name="data_free_func" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">#GDestroyNotify for @test_data</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_add_func" c:identifier="g_test_add_func" version="2.16">
      <doc xml:space="preserve">Creates a new test case.

This function is similar to [func@GLib.test_create_case].
However the test is assumed to use no fixture, and test suites are
automatically created on the fly and added to the root fixture,
based on the /-separated portions of @testpath.

If @testpath includes the component "subprocess" anywhere in it,
the test will be skipped by default, and only run if explicitly
required via the `-p` command-line option or [func@GLib.test_trap_subprocess].

No component of @testpath may start with a dot (`.`) if the
[const@GLib.TEST_OPTION_ISOLATE_DIRS] option is being used; and
it is recommended to do so even if it isn&#x2019;t.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="testpath" transfer-ownership="none">
          <doc xml:space="preserve">a /-separated name for the test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="test_func" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">the test function to invoke for this test</doc>
          <type name="TestFunc" c:type="GTestFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_add_vtable" c:identifier="g_test_add_vtable" introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="testpath" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="data_size" transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="test_data" transfer-ownership="none" nullable="1" allow-none="1">
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="data_setup" transfer-ownership="none">
          <type name="TestFixtureFunc" c:type="GTestFixtureFunc"/>
        </parameter>
        <parameter name="data_test" transfer-ownership="none">
          <type name="TestFixtureFunc" c:type="GTestFixtureFunc"/>
        </parameter>
        <parameter name="data_teardown" transfer-ownership="none">
          <type name="TestFixtureFunc" c:type="GTestFixtureFunc"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="test_assert_expected_messages" c:identifier="g_test_assert_expected_messages" version="2.34" introspectable="0">
      <doc xml:space="preserve">Asserts that all messages previously indicated via
[func@GLib.test_expect_message] have been seen and suppressed.

This API may only be used with the old logging API ([func@GLib.log] without
`G_LOG_USE_STRUCTURED` defined). It will not work with the structured logging
API. See [Testing for Messages](logging.html#testing-for-messages).

If messages at [flags@GLib.LogLevelFlags.LEVEL_DEBUG] are emitted, but not explicitly
expected via [func@GLib.test_expect_message] then they will be ignored.</doc>
    </function-macro>
    <function name="test_assert_expected_messages_internal" c:identifier="g_test_assert_expected_messages_internal">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_bug" c:identifier="g_test_bug" version="2.16">
      <doc xml:space="preserve">Adds a message to test reports that associates a bug URI with a test case.

Bug URIs are constructed from a base URI set with [func@GLib.test_bug_base]
and @bug_uri_snippet. If [func@GLib.test_bug_base] has not been called, it is
assumed to be the empty string, so a full URI can be provided to
[func@GLib.test_bug] instead.

See also [func@GLib.test_summary].

Since GLib 2.70, the base URI is not prepended to @bug_uri_snippet
if it is already a valid URI.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bug_uri_snippet" transfer-ownership="none">
          <doc xml:space="preserve">Bug specific bug tracker URI or URI portion.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_bug_base" c:identifier="g_test_bug_base" version="2.16">
      <doc xml:space="preserve">Specifies the base URI for bug reports.

The base URI is used to construct bug report messages for
[func@GLib.test_message] when [func@GLib.test_bug] is called.
Calling this function outside of a test case sets the
default base URI for all test cases. Calling it from within
a test case changes the base URI for the scope of the test
case only.
Bug URIs are constructed by appending a bug specific URI
portion to @uri_pattern, or by replacing the special string
`%s` within @uri_pattern if that is present.

If [func@GLib.test_bug_base] is not called, bug URIs are formed
solely from the value provided by [func@GLib.test_bug].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uri_pattern" transfer-ownership="none">
          <doc xml:space="preserve">the base pattern for bug URIs</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_build_filename" c:identifier="g_test_build_filename" version="2.38" introspectable="0">
      <doc xml:space="preserve">Creates the pathname to a data file that is required for a test.

This function is conceptually similar to [func@GLib.build_filename]
except that the first argument has been replaced with a
[enum@GLib.TestFileType] argument.

The data file should either have been distributed with the module
containing the test ([enum@GLib.TestFileType.dist] or built as part of the
buildcsystem of that module ([enum@GLib.TestFileType.built]).

In order for this function to work in srcdir != builddir situations,
the `G_TEST_SRCDIR` and `G_TEST_BUILDDIR` environment variables need
to have been defined. As of 2.38, this is done by the glib.mk that is
included in GLib. Please ensure that your copy is up to date before
using this function.

In case neither variable is set, this function will fall back to
using the dirname portion of `argv[0]`, possibly removing ".libs".
This allows for casual running of tests directly from the commandline
in the srcdir == builddir case and should also support running of
installed tests, assuming the data files have been installed in the
same relative path as the test binary.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the path of the file, to be freed using [func@GLib.free]</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="file_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of file (built vs. distributed)</doc>
          <type name="TestFileType" c:type="GTestFileType"/>
        </parameter>
        <parameter name="first_path" transfer-ownership="none">
          <doc xml:space="preserve">the first segment of the pathname</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">`NULL`-terminated additional path segments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="test_create_case" c:identifier="g_test_create_case" version="2.16" introspectable="0">
      <doc xml:space="preserve">Creates a new [struct@GLib.TestCase].

This API is fairly low level, and calling [func@GLib.test_add] or
[func@GLib.test_add_func] is preferable.

When this test is executed, a fixture structure of size @data_size
will be automatically allocated and filled with zeros. Then @data_setup
is called to initialize the fixture. After fixture setup, the actual test
function @data_test is called. Once the test run completes, the
fixture structure is torn down by calling @data_teardown and after
that the memory is automatically released by the test framework.

Splitting up a test run into fixture setup, test function and
fixture teardown is most useful if the same fixture type is used for
multiple tests. In this cases, [func@GLib.test_create_case] will be
called with the same type of fixture (the @data_size argument), but
varying @test_name and @data_test arguments.</doc>
      <return-value>
        <doc xml:space="preserve">a newly allocated test case</doc>
        <type name="TestCase" c:type="GTestCase*"/>
      </return-value>
      <parameters>
        <parameter name="test_name" transfer-ownership="none">
          <doc xml:space="preserve">the name for the test case</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="data_size" transfer-ownership="none">
          <doc xml:space="preserve">the size of the fixture data structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="test_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">test data argument for the test functions</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="data_setup" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">the function to set up the fixture data</doc>
          <type name="TestFixtureFunc" c:type="GTestFixtureFunc"/>
        </parameter>
        <parameter name="data_test" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">the actual test function</doc>
          <type name="TestFixtureFunc" c:type="GTestFixtureFunc"/>
        </parameter>
        <parameter name="data_teardown" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">the function to teardown the fixture data</doc>
          <type name="TestFixtureFunc" c:type="GTestFixtureFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_create_suite" c:identifier="g_test_create_suite" version="2.16" introspectable="0">
      <doc xml:space="preserve">Creates a new test suite with the name @suite_name.</doc>
      <return-value>
        <doc xml:space="preserve">a newly allocated test suite</doc>
        <type name="TestSuite" c:type="GTestSuite*"/>
      </return-value>
      <parameters>
        <parameter name="suite_name" transfer-ownership="none">
          <doc xml:space="preserve">a name for the suite</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_disable_crash_reporting" c:identifier="g_test_disable_crash_reporting" version="2.78">
      <doc xml:space="preserve">Attempts to disable system crash reporting infrastructure.

This function should be called before exercising code paths that are
expected or intended to crash, to avoid wasting resources in system-wide
crash collection infrastructure such as systemd-coredump or abrt.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="test_expect_message" c:identifier="g_test_expect_message" version="2.34">
      <doc xml:space="preserve">Indicates that a message with the given @log_domain and @log_level,
with text matching @pattern, is expected to be logged.

When this message is logged, it will not be printed, and the test case will
not abort.

This API may only be used with the old logging API ([func@GLib.log] without
`G_LOG_USE_STRUCTURED` defined). It will not work with the structured logging
API. See [Testing for Messages](logging.html#testing-for-messages).

Use [func@GLib.test_assert_expected_messages] to assert that all
previously-expected messages have been seen and suppressed.

You can call this multiple times in a row, if multiple messages are
expected as a result of a single call. (The messages must appear in
the same order as the calls to [func@GLib.test_expect_message].)

For example:

```c
// g_main_context_push_thread_default() should fail if the
// context is already owned by another thread.
g_test_expect_message (G_LOG_DOMAIN,
                       G_LOG_LEVEL_CRITICAL,
                       "assertion*acquired_context*failed");
g_main_context_push_thread_default (bad_context);
g_test_assert_expected_messages ();
```

Note that you cannot use this to test [func@GLib.error] messages, since
[func@GLib.error] intentionally never returns even if the program doesn&#x2019;t
abort; use [func@GLib.test_trap_subprocess] in this case.

If messages at [flags@GLib.LogLevelFlags.LEVEL_DEBUG] are emitted, but not explicitly
expected via [func@GLib.test_expect_message] then they will be ignored.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the log domain of the message</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:space="preserve">the log level of the message</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="pattern" transfer-ownership="none">
          <doc xml:space="preserve">a glob-style pattern (see [type@GLib.PatternSpec])</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_fail" c:identifier="g_test_fail" version="2.30">
      <doc xml:space="preserve">Indicates that a test failed.

This function can be called multiple times from the same test.
You can use this function if your test failed in a recoverable way.

Do not use this function if the failure of a test could cause
other tests to malfunction.

Calling this function will not stop the test from running, you
need to return from the test function yourself. So you can
produce additional diagnostic messages or even continue running
the test.

If not called from inside a test, this function does nothing.

Note that unlike [func@GLib.test_skip] and [func@GLib.test_incomplete],
this function does not log a message alongside the test failure.
If details of the test failure are available, either log them with
[func@GLib.test_message] before [func@GLib.test_fail], or use
[func@GLib.test_fail_printf] instead.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="test_fail_printf" c:identifier="g_test_fail_printf" version="2.70" introspectable="0">
      <doc xml:space="preserve">Indicates that a test failed and records a message.

Also see [func@GLib.test_fail].

The message is formatted as if by [func@GLib.strdup_printf].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the format string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">printf-like arguments to @format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="test_failed" c:identifier="g_test_failed" version="2.38">
      <doc xml:space="preserve">Returns whether a test has already failed.

This will be the case when [func@GLib.test_fail],
[func@GLib.test_incomplete] or [func@GLib.test_skip] have
been called, but also if an assertion has failed.

This can be useful to return early from a test if
continuing after a failed assertion might be harmful.

The return value of this function is only meaningful
if it is called from inside a test function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if the test has failed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="test_get_dir" c:identifier="g_test_get_dir" version="2.38">
      <doc xml:space="preserve">Gets the pathname of the directory containing test files of the type
specified by @file_type.

This is approximately the same as calling `g_test_build_filename(".")`,
but you don't need to free the return value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the path of the directory, owned by GLib</doc>
        <type name="filename" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="file_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of file (built vs. distributed)</doc>
          <type name="TestFileType" c:type="GTestFileType"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_get_filename" c:identifier="g_test_get_filename" version="2.38" introspectable="0">
      <doc xml:space="preserve">Gets the pathname to a data file that is required for a test.

This is the same as [func@GLib.test_build_filename] with two differences.
The first difference is that you must only use this function from within
a testcase function. The second difference is that you need not free
the return value &#x2014; it will be automatically freed when the testcase
finishes running.

It is safe to use this function from a thread inside of a testcase
but you must ensure that all such uses occur before the main testcase
function returns (ie: it is best to ensure that all threads have been
joined).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the path, automatically freed at the end of the testcase</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="file_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of file (built vs. distributed)</doc>
          <type name="TestFileType" c:type="GTestFileType"/>
        </parameter>
        <parameter name="first_path" transfer-ownership="none">
          <doc xml:space="preserve">the first segment of the pathname</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">`NULL`-terminated additional path segments</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="test_get_path" c:identifier="g_test_get_path" version="2.68">
      <doc xml:space="preserve">Gets the test path for the test currently being run.

In essence, it will be the same string passed as the first argument
to e.g. [func@GLib.test_add] when the test was added.

This function returns a valid string only within a test function.

Note that this is a test path, not a file system path.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the test path for the test currently being run</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
    </function>
    <function name="test_get_root" c:identifier="g_test_get_root" version="2.16" introspectable="0">
      <doc xml:space="preserve">Gets the toplevel test suite for the test path API.</doc>
      <return-value>
        <doc xml:space="preserve">the toplevel test suite</doc>
        <type name="TestSuite" c:type="GTestSuite*"/>
      </return-value>
    </function>
    <function name="test_incomplete" c:identifier="g_test_incomplete" version="2.38">
      <doc xml:space="preserve">Indicates that a test failed because of some incomplete
functionality.

This function can be called multiple times from the same test.

Calling this function will not stop the test from running, you
need to return from the test function yourself. So you can
produce additional diagnostic messages or even continue running
the test.

If not called from inside a test, this function does nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">explanation</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_incomplete_printf" c:identifier="g_test_incomplete_printf" version="2.70" introspectable="0">
      <doc xml:space="preserve">Indicates that a test failed because of some incomplete
functionality.

Equivalent to [func@GLib.test_incomplete], but the explanation
is formatted as if by [func@GLib.strdup_printf].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the format string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">printf-like arguments to @format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="test_init" c:identifier="g_test_init" version="2.16" introspectable="0">
      <doc xml:space="preserve">Initializes the GLib testing framework.

This includes seeding the test random number generator,
setting the program name, and parsing test-related commandline args.

This should be called before calling any other `g_test_*()` functions.

The following arguments are understood:

- `-l`: List test cases available in a test executable.
- `--seed=SEED`: Provide a random seed to reproduce test
  runs using random numbers.
- `--verbose`: Run tests verbosely.
- `-q`, `--quiet`: Run tests quietly.
- `-p PATH`: Execute all tests matching the given path.
- `-s PATH`: Skip all tests matching the given path.
  This can also be used to force a test to run that would otherwise
  be skipped (ie, a test whose name contains "/subprocess").
- `-m {perf|slow|thorough|quick|undefined|no-undefined}`: Execute tests according
  to these test modes:

  `perf`: Performance tests, may take long and report results (off by default).

  `slow`, `thorough`: Slow and thorough tests, may take quite long and maximize
  coverage (off by default).

  `quick`: Quick tests, should run really quickly and give good coverage (the default).

  `undefined`: Tests for undefined behaviour, may provoke programming errors
  under [func@GLib.test_trap_subprocess] or [func@GLib.test_expect_message]
  to check that appropriate assertions or warnings are given (the default).

  `no-undefined`: Avoid tests for undefined behaviour.

- `--debug-log`: Debug test logging output.

Any parsed arguments are removed from @argv, and @argc is adjust accordingly.

The following options are supported:

- `G_TEST_OPTION_NO_PRGNAME`: Causes g_test_init() to not call
  [func@GLib.set_prgname]. Since. 2.84
- `G_TEST_OPTION_ISOLATE_DIRS`: Creates a unique temporary directory for each
  unit test and sets XDG directories to point there for the duration of the unit
  test. See [const@GLib.TEST_OPTION_ISOLATE_DIRS].
- `G_TEST_OPTION_NONFATAL_ASSERTIONS`: This has the same effect as
  [func@GLib.test_set_nonfatal_assertions]. Since 2.84

Since 2.58, if tests are compiled with `G_DISABLE_ASSERT` defined, `g_test_init()`
will print an error and exit. This is to prevent no-op tests from being executed,
as [func@GLib.assert] is commonly (erroneously) used in unit tests, and is a no-op
when compiled with `G_DISABLE_ASSERT`. Ensure your tests are compiled without
`G_DISABLE_ASSERT` defined.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="argc" transfer-ownership="none">
          <doc xml:space="preserve">address of the @argc parameter of `main()`</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:space="preserve">address of the @argv parameter of `main()`</doc>
          <type name="utf8" c:type="char***"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">`NULL`-terminated list of special options</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="test_initialized" c:identifier="g_test_initialized" version="2.36" introspectable="0">
      <doc xml:space="preserve">Returns true if [func@GLib.test_init] has been called.</doc>
    </function-macro>
    <function name="test_log_set_fatal_handler" c:identifier="g_test_log_set_fatal_handler" version="2.22" introspectable="0">
      <doc xml:space="preserve">Installs a non-error fatal log handler which can be
used to decide whether log messages which are counted
as fatal abort the program.

The use case here is that you are running a test case
that depends on particular libraries or circumstances
and cannot prevent certain known critical or warning
messages. So you install a handler that compares the
domain and message to precisely not abort in such a case.

Note that the handler is reset at the beginning of
any test case, so you have to set it inside each test
function which needs the special behavior.

This handler has no effect on g_error messages.

This handler also has no effect on structured log messages (using
[func@GLib.log_structured] or [func@GLib.log_structured_array]). To change the fatal
behaviour for specific log messages, programs must install a custom log
writer function using [func@GLib.log_set_writer_func].See
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_func" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">the log handler function.</doc>
          <type name="TestLogFatalFunc" c:type="GTestLogFatalFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data passed to the log handler.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_log_type_name" c:identifier="g_test_log_type_name">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="log_type" transfer-ownership="none">
          <type name="TestLogType" c:type="GTestLogType"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_maximized_result" c:identifier="g_test_maximized_result" version="2.16" introspectable="0">
      <doc xml:space="preserve">Reports the result of a performance or measurement test.

The test should generally strive to maximize the reported
quantities (larger values are better than smaller ones),
this and @maximized_quantity can determine sorting
order for test result reports.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="maximized_quantity" transfer-ownership="none">
          <doc xml:space="preserve">the reported value</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the format string of the report message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">printf-like arguments to @format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="test_message" c:identifier="g_test_message" version="2.16" introspectable="0">
      <doc xml:space="preserve">Adds a message to the test report.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the format string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">printf-like arguments to @format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="test_minimized_result" c:identifier="g_test_minimized_result" version="2.16" introspectable="0">
      <doc xml:space="preserve">Reports the result of a performance or measurement test.

The test should generally strive to minimize the reported
quantities (smaller values are better than larger ones),
this and @minimized_quantity can determine sorting
order for test result reports.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="minimized_quantity" transfer-ownership="none">
          <doc xml:space="preserve">the reported value</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the format string of the report message</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">printf-like arguments to @format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="test_perf" c:identifier="g_test_perf" introspectable="0">
      <doc xml:space="preserve">Returns true if tests are run in performance mode.

By default, tests are run in quick mode. In tests that use
[func@GLib.test_init], the option `-m perf` enables performance tests, while
`-m quick` disables them.</doc>
    </function-macro>
    <function name="test_queue_destroy" c:identifier="g_test_queue_destroy" version="2.16">
      <doc xml:space="preserve">Enqueues a callback @destroy_func to be executed during the next test case
teardown phase.

This is most useful to auto destroy allocated test resources at the end
of a test run. Resources are released in reverse queue order, that means
enqueueing callback `A` before callback `B` will cause `B()` to be called
before `A()` during teardown.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="destroy_func" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">destroy callback for teardown phase</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="destroy_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">destroy callback data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_queue_free" c:identifier="g_test_queue_free" version="2.16">
      <doc xml:space="preserve">Enqueues a pointer to be released with [func@GLib.free]
during the next teardown phase.

This is equivalent to calling [func@GLib.test_queue_destroy]
with a destroy callback of [func@GLib.free].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="gfree_pointer" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the pointer to be stored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="test_queue_unref" c:identifier="g_test_queue_unref" version="2.16" introspectable="0">
      <doc xml:space="preserve">Enqueue an object to be released with g_object_unref() during
the next teardown phase.

This is equivalent to calling [func@GLib.test_queue_destroy]
with a destroy callback of g_object_unref().</doc>
      <parameters>
        <parameter name="gobject">
          <doc xml:space="preserve">the object to unref</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="test_quick" c:identifier="g_test_quick" introspectable="0">
      <doc xml:space="preserve">Returns true if tests are run in quick mode.

Tests are always run in slow mode or in fast mode; there is no "medium speed".

By default, tests are run in quick mode. In tests that use
[func@GLib.test_init], the options `-m quick`, `-m slow` and `-m thorough`
can be used to change this.</doc>
    </function-macro>
    <function-macro name="test_quiet" c:identifier="g_test_quiet" introspectable="0">
      <doc xml:space="preserve">Returns true if tests are run in quiet mode.

In tests that use [func@GLib.test_init], the option `-q` or `--quiet` enables
this, while `--verbose` disables it.

The default is neither verbose nor quiet.</doc>
    </function-macro>
    <function-macro name="test_rand_bit" c:identifier="g_test_rand_bit" version="2.16" introspectable="0">
      <doc xml:space="preserve">Get a reproducible random bit (0 or 1).

See [func@GLib.test_rand_int] for details on test case random numbers.</doc>
    </function-macro>
    <function name="test_rand_double" c:identifier="g_test_rand_double" version="2.16">
      <doc xml:space="preserve">Gets a reproducible random floating point number.

See [func@GLib.test_rand_int] for details on test case random numbers.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a random number from the seeded random number generator</doc>
        <type name="gdouble" c:type="double"/>
      </return-value>
    </function>
    <function name="test_rand_double_range" c:identifier="g_test_rand_double_range" version="2.16">
      <doc xml:space="preserve">Gets a reproducible random floating point number out of a specified range.

See [func@GLib.test_rand_int] for details on test case random numbers.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a number with @range_start &lt;= number &lt; @range_end</doc>
        <type name="gdouble" c:type="double"/>
      </return-value>
      <parameters>
        <parameter name="range_start" transfer-ownership="none">
          <doc xml:space="preserve">the minimum value returned by this function</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="range_end" transfer-ownership="none">
          <doc xml:space="preserve">the minimum value not returned by this function</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_rand_int" c:identifier="g_test_rand_int" version="2.16">
      <doc xml:space="preserve">Gets a reproducible random integer number.

The random numbers generated by the g_test_rand_*() family of functions
change with every new test program start, unless the --seed option is
given when starting test programs.

For individual test cases however, the random number generator is
reseeded, to avoid dependencies between tests and to make --seed
effective for all test cases.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a random number from the seeded random number generator</doc>
        <type name="gint32" c:type="gint32"/>
      </return-value>
    </function>
    <function name="test_rand_int_range" c:identifier="g_test_rand_int_range" version="2.16">
      <doc xml:space="preserve">Gets a reproducible random integer number out of a specified range.

See [func@GLib.test_rand_int] for details on test case random numbers.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a number with @begin &lt;= number &lt; @end</doc>
        <type name="gint32" c:type="gint32"/>
      </return-value>
      <parameters>
        <parameter name="begin" transfer-ownership="none">
          <doc xml:space="preserve">the minimum value returned by this function</doc>
          <type name="gint32" c:type="gint32"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">the smallest value not to be returned by this function</doc>
          <type name="gint32" c:type="gint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_run" c:identifier="g_test_run" version="2.16">
      <doc xml:space="preserve">Runs all tests under the toplevel suite.

The toplevel suite can be retrieved with [func@GLib.test_get_root].

Similar to [func@GLib.test_run_suite], the test cases to be run are
filtered according to test path arguments (`-p testpath` and `-s testpath`)
as parsed by [func@GLib.test_init]. [func@GLib.test_run_suite] or
[func@GLib.test_run] may only be called once in a program.

In general, the tests and sub-suites within each suite are run in
the order in which they are defined. However, note that prior to
GLib 2.36, there was a bug in the `g_test_add_*`
functions which caused them to create multiple suites with the same
name, meaning that if you created tests "/foo/simple",
"/bar/simple", and "/foo/using-bar" in that order, they would get
run in that order (since [func@GLib.test_run] would run the first "/foo"
suite, then the "/bar" suite, then the second "/foo" suite). As of
2.36, this bug is fixed, and adding the tests in that order would
result in a running order of "/foo/simple", "/foo/using-bar",
"/bar/simple". If this new ordering is sub-optimal (because it puts
more-complicated tests before simpler ones, making it harder to
figure out exactly what has failed), you can fix it by changing the
test paths to group tests by suite in a way that will result in the
desired running order. Eg, "/simple/foo", "/simple/bar",
"/complex/foo-using-bar".

However, you should never make the actual result of a test depend
on the order that tests are run in. If you need to ensure that some
particular code runs before or after a given test case, use
[func@GLib.test_add], which lets you specify setup and teardown functions.

If all tests are skipped or marked as incomplete (expected failures),
this function will return 0 if producing TAP output, or 77 (treated
as "skip test" by Automake) otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, 1 on failure (assuming it returns at all),
  0 or 77 if all tests were skipped or marked as incomplete</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="test_run_suite" c:identifier="g_test_run_suite" version="2.16">
      <doc xml:space="preserve">Executes the tests within @suite and all nested test suites.

The test suites to be executed are filtered according to
test path arguments (`-p testpath` and `-s testpath`) as parsed by
[func@GLib.test_init]. See the [func@GLib.test_run] documentation
for more information on the order that tests are run in.

[func@GLib.test_run_suite] or [func@GLib.test_run] may only be
called once in a program.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="suite" transfer-ownership="none">
          <doc xml:space="preserve">a test suite</doc>
          <type name="TestSuite" c:type="GTestSuite*"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_set_nonfatal_assertions" c:identifier="g_test_set_nonfatal_assertions" version="2.38">
      <doc xml:space="preserve">Changes the behaviour of the various assertion macros.

The `g_assert_*()` macros, `g_test_assert_expected_messages()`
and the various `g_test_trap_assert_*()` macros are changed
to not abort to program.

Instead, they will call [func@GLib.test_fail] and continue.
(This also changes the behavior of [func@GLib.test_fail] so that
it will not cause the test program to abort after completing
the failed test.)

Note that the [func@GLib.assert_not_reached] and [func@GLib.assert]
macros are not affected by this.

This function can only be called after [func@GLib.test_init].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="test_skip" c:identifier="g_test_skip" version="2.38">
      <doc xml:space="preserve">Indicates that a test was skipped.

Calling this function will not stop the test from running, you
need to return from the test function yourself. So you can
produce additional diagnostic messages or even continue running
the test.

If not called from inside a test, this function does nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">explanation</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_skip_printf" c:identifier="g_test_skip_printf" version="2.70" introspectable="0">
      <doc xml:space="preserve">Indicates that a test was skipped.

Equivalent to [func@GLib.test_skip], but the explanation
is formatted as if by [func@GLib.strdup_printf].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the format string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">printf-like arguments to @format</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="test_slow" c:identifier="g_test_slow" introspectable="0">
      <doc xml:space="preserve">Returns true if tests are run in slow mode.

Tests are always run in slow mode or in fast mode; there is no "medium speed".

By default, tests are run in quick mode. In tests that use
[func@GLib.test_init], the options `-m quick`, `-m slow` and `-m thorough`
can be used to change this.</doc>
    </function-macro>
    <function name="test_subprocess" c:identifier="g_test_subprocess" version="2.38">
      <doc xml:space="preserve">Returns true if the test program is running under [func@GLib.test_trap_subprocess].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if the test program is running under [func@GLib.test_trap_subprocess]</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="test_summary" c:identifier="g_test_summary" version="2.62">
      <doc xml:space="preserve">Sets the summary for a test.

This may be included in test report output, and is useful documentation for
anyone reading the source code or modifying a test in future. It must be a
single line, and it should summarise what the test checks, and how.

This should be called at the top of a test function.

For example:

```c
static void
test_array_sort (void)
{
  g_test_summary ("Test my_array_sort() sorts the array correctly and stably, "
                  "including testing zero length and one-element arrays.");

  // ...
}
```

See also [func@GLib.test_bug].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="summary" transfer-ownership="none">
          <doc xml:space="preserve">summary of the test purpose</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="test_thorough" c:identifier="g_test_thorough" introspectable="0">
      <doc xml:space="preserve">Returns true if tests are run in thorough mode.

Thorough mode is equivalent to slow mode.

By default, tests are run in quick mode. In tests that use
[func@GLib.test_init], the options `-m quick`, `-m slow` and `-m thorough`
can be used to change this.</doc>
    </function-macro>
    <function name="test_timer_elapsed" c:identifier="g_test_timer_elapsed" version="2.16">
      <doc xml:space="preserve">Gets the number of seconds since the last start of the timer with
[func@GLib.test_timer_start].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the time since the last start of the timer in seconds</doc>
        <type name="gdouble" c:type="double"/>
      </return-value>
    </function>
    <function name="test_timer_last" c:identifier="g_test_timer_last" version="2.16">
      <doc xml:space="preserve">Reports the last result of [func@GLib.test_timer_elapsed].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the last result of [func@GLib.test_timer_elapsed]</doc>
        <type name="gdouble" c:type="double"/>
      </return-value>
    </function>
    <function name="test_timer_start" c:identifier="g_test_timer_start" version="2.16">
      <doc xml:space="preserve">Starts a timing test.

Call [func@GLib.test_timer_elapsed] when the task is supposed
to be done. Call this function again to restart the timer.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function-macro name="test_trap_assert_failed" c:identifier="g_test_trap_assert_failed" version="2.16" introspectable="0">
      <doc xml:space="preserve">Assert that the last test subprocess failed.

See [func@GLib.test_trap_subprocess].

This is sometimes used to test situations that are formally considered to
be undefined behaviour, like inputs that fail a [func@GLib.return_if_fail]
check. In these situations you should skip the entire test, including the
call to [func@GLib.test_trap_subprocess], unless [func@GLib.test_undefined]
returns true to indicate that undefined behaviour may be tested.</doc>
    </function-macro>
    <function-macro name="test_trap_assert_passed" c:identifier="g_test_trap_assert_passed" version="2.16" introspectable="0">
      <doc xml:space="preserve">Assert that the last test subprocess passed.

See [func@GLib.test_trap_subprocess].</doc>
    </function-macro>
    <function-macro name="test_trap_assert_stderr" c:identifier="g_test_trap_assert_stderr" version="2.16" introspectable="0">
      <doc xml:space="preserve">Assert that the stderr output of the last test subprocess
matches @serrpattern.

See [func@GLib.test_trap_subprocess].

This is sometimes used to test situations that are formally considered
to be undefined behaviour, like code that hits a [func@GLib.assert] or
[func@GLib.error]. In these situations you should skip the entire test,
including the call to [func@GLib.test_trap_subprocess], unless
[func@GLib.test_undefined] returns true to indicate that undefined
behaviour may be tested.</doc>
      <parameters>
        <parameter name="serrpattern">
          <doc xml:space="preserve">a string that follows glob-style [pattern][struct@PatternSpec] rules</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="test_trap_assert_stderr_unmatched" c:identifier="g_test_trap_assert_stderr_unmatched" version="2.16" introspectable="0">
      <doc xml:space="preserve">Assert that the stderr output of the last test subprocess
does not match @serrpattern.

See [func@GLib.test_trap_subprocess].</doc>
      <parameters>
        <parameter name="serrpattern">
          <doc xml:space="preserve">a string that follows glob-style [pattern][struct@PatternSpec] rules</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="test_trap_assert_stdout" c:identifier="g_test_trap_assert_stdout" version="2.16" introspectable="0">
      <doc xml:space="preserve">Assert that the stdout output of the last test subprocess matches
@soutpattern.

See [func@GLib.test_trap_subprocess].</doc>
      <parameters>
        <parameter name="soutpattern">
          <doc xml:space="preserve">a string that follows glob-style [pattern][struct@PatternSpec] rules</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="test_trap_assert_stdout_unmatched" c:identifier="g_test_trap_assert_stdout_unmatched" version="2.16" introspectable="0">
      <doc xml:space="preserve">Assert that the stdout output of the last test subprocess
does not match @soutpattern.

See [func@GLib.test_trap_subprocess].</doc>
      <parameters>
        <parameter name="soutpattern">
          <doc xml:space="preserve">a string that follows glob-style [pattern][struct@PatternSpec] rules</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="test_trap_assertions" c:identifier="g_test_trap_assertions">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="assertion_flags" transfer-ownership="none">
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="pattern" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_trap_fork" c:identifier="g_test_trap_fork" version="2.16" deprecated="1">
      <doc xml:space="preserve">Forks the current test program to execute a test case that might
not return or that might abort.

If @usec_timeout is non-0, the forked test case is aborted and
considered failing if its run time exceeds it.

The forking behavior can be configured with [flags@GLib.TestTrapFlags]
flags.

In the following example, the test code forks, the forked child
process produces some sample output and exits successfully.
The forking parent process then asserts successful child program
termination and validates child program outputs.

```c
  static void
  test_fork_patterns (void)
  {
    if (g_test_trap_fork (0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR))
      {
        g_print ("some stdout text: somagic17
");
        g_printerr ("some stderr text: semagic43
");
        exit (0); // successful test run
      }
    g_test_trap_assert_passed ();
    g_test_trap_assert_stdout ("*somagic17*");
    g_test_trap_assert_stderr ("*semagic43*");
  }
```</doc>
      <doc-deprecated xml:space="preserve">This function is implemented only on Unix platforms,
is not always reliable due to problems inherent in fork-without-exec
and doesn't set close-on-exec flag on its file descriptors.
Use func@GLib.test_trap_subprocess] instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true for the forked child and false for the executing parent process.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="usec_timeout" transfer-ownership="none">
          <doc xml:space="preserve">timeout for the forked test in microseconds</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="test_trap_flags" transfer-ownership="none">
          <doc xml:space="preserve">flags to modify forking behaviour</doc>
          <type name="TestTrapFlags" c:type="GTestTrapFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_trap_has_passed" c:identifier="g_test_trap_has_passed" version="2.16">
      <doc xml:space="preserve">Checks the result of the last [func@GLib.test_trap_subprocess] call.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if the last test subprocess terminated successfully</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="test_trap_reached_timeout" c:identifier="g_test_trap_reached_timeout" version="2.16">
      <doc xml:space="preserve">Checks the result of the last [func@GLib.test_trap_subprocess] call.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if the last test subprocess got killed due to a timeout</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="test_trap_subprocess" c:identifier="g_test_trap_subprocess" version="2.38">
      <doc xml:space="preserve">Respawns the test program to run only @test_path in a subprocess.

This is equivalent to calling [func@GLib.test_trap_subprocess_with_envp]
with `envp` set to `NULL`. See the documentation for that function
for full details.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="test_path" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">test to run in a subprocess</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="usec_timeout" transfer-ownership="none">
          <doc xml:space="preserve">timeout for the subprocess test in microseconds.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="test_flags" transfer-ownership="none">
          <doc xml:space="preserve">flags to modify subprocess behaviour</doc>
          <type name="TestSubprocessFlags" c:type="GTestSubprocessFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="test_trap_subprocess_with_envp" c:identifier="g_test_trap_subprocess_with_envp" version="2.80">
      <doc xml:space="preserve">Respawns the test program to run only @test_path in a subprocess with
a given environment.

This can be used for a test case that might not return, or that
might abort.

If @test_path is `NULL` then the same test is re-run in a subprocess.
You can use [func@GLib.test_subprocess] to determine whether the test
is in a subprocess or not.

@test_path can also be the name of the parent test, followed by
"`/subprocess/`" and then a name for the specific subtest (or just
ending with "`/subprocess`" if the test only has one child test);
tests with names of this form will automatically be skipped in the
parent process.

If @envp is `NULL`, the parent process&#x2019; environment will be inherited.

If @usec_timeout is non-0, the test subprocess is aborted and
considered failing if its run time exceeds it.

The subprocess behavior can be configured with [flags@GLib.TestSubprocessFlags]
flags.

You can use methods such as [func@GLib.test_trap_assert_passed],
[func@GLib.test_trap_assert_failed], and [func@GLib.test_trap_assert_stderr] to
check the results of the subprocess. (But note that
[func@GLib.test_trap_assert_stdout] and [func@GLib.test_trap_assert_stderr]
cannot be used if @test_flags specifies that the child should
inherit the parent stdout/stderr.)

If your `main ()` needs to behave differently in the subprocess, you can
call [func@GLib.test_subprocess] (after calling [func@GLib.test_init])
to see whether you are in a subprocess.

Internally, this function tracks the child process using
[func@GLib.child_watch_source_new], so your process must not ignore
`SIGCHLD`, and must not attempt to watch or wait for the child process
via another mechanism.

The following example tests that calling `my_object_new(1000000)` will
abort with an error message.

```c
  static void
  test_create_large_object (void)
  {
    if (g_test_subprocess ())
      {
        my_object_new (1000000);
        return;
      }

    // Reruns this same test in a subprocess
    g_test_trap_subprocess (NULL, 0, G_TEST_SUBPROCESS_DEFAULT);
    g_test_trap_assert_failed ();
    g_test_trap_assert_stderr ("*ERROR*too large*");
  }

  static void
  test_different_username (void)
  {
    if (g_test_subprocess ())
      {
        // Code under test goes here
        g_message ("Username is now simulated as %s", g_getenv ("USER"));
        return;
      }

    // Reruns this same test in a subprocess
    g_auto(GStrv) envp = g_get_environ ();
    envp = g_environ_setenv (g_steal_pointer (&amp;envp), "USER", "charlie", TRUE);
    g_test_trap_subprocess_with_envp (NULL, envp, 0, G_TEST_SUBPROCESS_DEFAULT);
    g_test_trap_assert_passed ();
    g_test_trap_assert_stdout ("Username is now simulated as charlie");
  }

  int
  main (int argc, char **argv)
  {
    g_test_init (&amp;argc, &amp;argv, NULL);

    g_test_add_func ("/myobject/create-large-object",
                     test_create_large_object);
    g_test_add_func ("/myobject/different-username",
                     test_different_username);
    return g_test_run ();
  }
```</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="test_path" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">test to run in a subprocess</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="envp" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">environment
  to run the test in</doc>
          <array c:type="const char* const*">
            <type name="filename"/>
          </array>
        </parameter>
        <parameter name="usec_timeout" transfer-ownership="none">
          <doc xml:space="preserve">timeout for the subprocess test in microseconds</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="test_flags" transfer-ownership="none">
          <doc xml:space="preserve">flags to modify subprocess behaviour</doc>
          <type name="TestSubprocessFlags" c:type="GTestSubprocessFlags"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="test_undefined" c:identifier="g_test_undefined" introspectable="0">
      <doc xml:space="preserve">Returns true if tests may provoke assertions and other formally-undefined
behaviour, to verify that appropriate warnings are given.

This might, in some cases, be useful to turn this off (e.g. if running tests
under valgrind).

In tests that use [func@GLib.test_init], the option `-m no-undefined` disables
those tests, while `-m undefined` explicitly enables them (normally
the default behaviour).

Since GLib 2.68, if GLib was compiled with gcc or clang and
[AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer)
is enabled, the default changes to not exercising undefined behaviour.</doc>
    </function-macro>
    <function-macro name="test_verbose" c:identifier="g_test_verbose" introspectable="0">
      <doc xml:space="preserve">Returns true if tests are run in verbose mode.

In tests that use [func@GLib.test_init], the option `--verbose` enables this,
while `-q` or `--quiet` disables it.

The default is neither verbose nor quiet.</doc>
    </function-macro>
    <function name="thread_create" c:identifier="g_thread_create" moved-to="Thread.create" introspectable="0" deprecated="1" deprecated-version="2.32" throws="1">
      <doc xml:space="preserve">This function creates a new thread.

The new thread executes the function @func with the argument @data.
If the thread was created successfully, it is returned.

@error can be %NULL to ignore errors, or non-%NULL to report errors.
The error is set, if and only if the function returns %NULL.

This function returns a reference to the created thread only if
@joinable is %TRUE.  In that case, you must free this reference by
calling g_thread_unref() or g_thread_join().  If @joinable is %FALSE
then you should probably not touch the return value.</doc>
      <doc-deprecated xml:space="preserve">Use g_thread_new() instead</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new #GThread on success</doc>
        <type name="Thread" c:type="GThread*"/>
      </return-value>
      <parameters>
        <parameter name="func" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">a function to execute in the new thread</doc>
          <type name="ThreadFunc" c:type="GThreadFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">an argument to supply to the new thread</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="joinable" transfer-ownership="none">
          <doc xml:space="preserve">should this thread be joinable?</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="thread_create_full" c:identifier="g_thread_create_full" moved-to="Thread.create_full" introspectable="0" deprecated="1" deprecated-version="2.32" throws="1">
      <doc xml:space="preserve">This function creates a new thread.</doc>
      <doc-deprecated xml:space="preserve">The @bound and @priority arguments are now ignored.
Use g_thread_new().</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new #GThread on success.</doc>
        <type name="Thread" c:type="GThread*"/>
      </return-value>
      <parameters>
        <parameter name="func" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">a function to execute in the new thread.</doc>
          <type name="ThreadFunc" c:type="GThreadFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">an argument to supply to the new thread.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="stack_size" transfer-ownership="none">
          <doc xml:space="preserve">a stack size for the new thread.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
        <parameter name="joinable" transfer-ownership="none">
          <doc xml:space="preserve">should this thread be joinable?</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="bound" transfer-ownership="none">
          <doc xml:space="preserve">ignored</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve">ignored</doc>
          <type name="ThreadPriority" c:type="GThreadPriority"/>
        </parameter>
      </parameters>
    </function>
    <function name="thread_error_quark" c:identifier="g_thread_error_quark" moved-to="Thread.error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="thread_exit" c:identifier="g_thread_exit" moved-to="Thread.exit">
      <doc xml:space="preserve">Terminates the current thread.

If another thread is waiting for us using g_thread_join() then the
waiting thread will be woken up and get @retval as the return value
of g_thread_join().

Calling g_thread_exit() with a parameter @retval is equivalent to
returning @retval from the function @func, as given to g_thread_new().

You must only call g_thread_exit() from a thread that you created
yourself with g_thread_new() or related APIs. You must not call
this function from a thread created with another threading library
or or from within a #GThreadPool.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="retval" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the return value of this thread</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="thread_foreach" c:identifier="g_thread_foreach" moved-to="Thread.foreach" version="2.10" introspectable="0" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Call @thread_func on all #GThreads that have been
created with g_thread_create().

Note that threads may decide to exit while @thread_func is
running, so without intimate knowledge about the lifetime of
foreign threads, @thread_func shouldn't access the GThread*
pointer passed in as first argument. However, @thread_func will
not be called for threads which are known to have exited already.

Due to thread lifetime checks, this function has an execution complexity
which is quadratic in the number of existing threads.</doc>
      <doc-deprecated xml:space="preserve">There aren't many things you can do with a #GThread,
    except comparing it with one that was returned from g_thread_create().
    There are better ways to find out if your thread is still alive.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="thread_func" transfer-ownership="none" scope="call" closure="1">
          <doc xml:space="preserve">function to call for all #GThread structures</doc>
          <type name="Func" c:type="GFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">second argument to @thread_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="thread_get_initialized" c:identifier="g_thread_get_initialized" moved-to="Thread.get_initialized" version="2.20" introspectable="0">
      <doc xml:space="preserve">Indicates if g_thread_init() has been called.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if threads have been initialized.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="thread_init" c:identifier="g_thread_init" moved-to="Thread.init" introspectable="0" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">If you use GLib from more than one thread, you must initialize the
thread system by calling g_thread_init().

Since version 2.24, calling g_thread_init() multiple times is allowed,
but nothing happens except for the first call.

Since version 2.32, GLib does not support custom thread implementations
anymore and the @vtable parameter is ignored and you should pass %NULL.

::: note
    g_thread_init() must not be called directly or indirectly in a
    callback from GLib. Also no mutexes may be currently locked
    while calling g_thread_init().

::: note
    To use g_thread_init() in your program, you have to link with
    the libraries that the command `pkg-config --libs gthread-2.0`
    outputs. This is not the case for all the other thread-related
    functions of GLib. Those can be used without having to link
    with the thread libraries.</doc>
      <doc-deprecated xml:space="preserve">This function is no longer necessary. The GLib
    threading system is automatically initialized at the start
    of your program.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vtable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a function table of type #GThreadFunctions, that provides
    the entry points to the thread system to be used. Since 2.32,
    this parameter is ignored and should always be %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="thread_init_with_errorcheck_mutexes" c:identifier="g_thread_init_with_errorcheck_mutexes" moved-to="Thread.init_with_errorcheck_mutexes" introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vtable" transfer-ownership="none" nullable="1" allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="thread_pool_get_max_idle_time" c:identifier="g_thread_pool_get_max_idle_time" moved-to="ThreadPool.get_max_idle_time" version="2.10">
      <doc xml:space="preserve">This function will return the maximum @interval that a
thread will wait in the thread pool for new tasks before
being stopped.

If this function returns 0, threads waiting in the thread
pool for new work are not stopped.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the maximum @interval (milliseconds) to wait
    for new tasks in the thread pool before stopping the
    thread</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
    </function>
    <function name="thread_pool_get_max_unused_threads" c:identifier="g_thread_pool_get_max_unused_threads" moved-to="ThreadPool.get_max_unused_threads">
      <doc xml:space="preserve">Returns the maximal allowed number of unused threads.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the maximal number of unused threads</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
    </function>
    <function name="thread_pool_get_num_unused_threads" c:identifier="g_thread_pool_get_num_unused_threads" moved-to="ThreadPool.get_num_unused_threads">
      <doc xml:space="preserve">Returns the number of currently unused threads.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of currently unused threads</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
    </function>
    <function name="thread_pool_set_max_idle_time" c:identifier="g_thread_pool_set_max_idle_time" moved-to="ThreadPool.set_max_idle_time" version="2.10">
      <doc xml:space="preserve">This function will set the maximum @interval that a thread
waiting in the pool for new tasks can be idle for before
being stopped. This function is similar to calling
g_thread_pool_stop_unused_threads() on a regular timeout,
except this is done on a per thread basis.

By setting @interval to 0, idle threads will not be stopped.

The default value is 15000 (15 seconds).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="interval" transfer-ownership="none">
          <doc xml:space="preserve">the maximum @interval (in milliseconds)
    a thread can be idle</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="thread_pool_set_max_unused_threads" c:identifier="g_thread_pool_set_max_unused_threads" moved-to="ThreadPool.set_max_unused_threads">
      <doc xml:space="preserve">Sets the maximal number of unused threads to @max_threads.
If @max_threads is -1, no limit is imposed on the number
of unused threads.

The default value is 8 since GLib 2.84. Previously the default value was 2.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="max_threads" transfer-ownership="none">
          <doc xml:space="preserve">maximal number of unused threads</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="thread_pool_stop_unused_threads" c:identifier="g_thread_pool_stop_unused_threads" moved-to="ThreadPool.stop_unused_threads">
      <doc xml:space="preserve">Stops all currently unused threads. This does not change the
maximal number of unused threads. This function can be used to
regularly stop all unused threads e.g. from g_timeout_add().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="thread_self" c:identifier="g_thread_self" moved-to="Thread.self">
      <doc xml:space="preserve">This function returns the #GThread corresponding to the
current thread. Note that this function does not increase
the reference count of the returned struct.

This function will return a #GThread even for threads that
were not created by GLib (i.e. those created by other threading
APIs). This may be useful for thread identification purposes
(i.e. comparisons) but you must not use GLib functions (such
as g_thread_join()) on these threads.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GThread representing the current thread</doc>
        <type name="Thread" c:type="GThread*"/>
      </return-value>
    </function>
    <function-macro name="thread_supported" c:identifier="g_thread_supported" introspectable="0">
      <doc xml:space="preserve">This macro returns %TRUE if the thread system is initialized,
and %FALSE if it is not.

For language bindings, g_thread_get_initialized() provides
the same functionality as a function.</doc>
    </function-macro>
    <function name="thread_yield" c:identifier="g_thread_yield" moved-to="Thread.yield">
      <doc xml:space="preserve">Causes the calling thread to voluntarily relinquish the CPU, so
that other threads can run.

This function is often used as a method to make busy wait less evil.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="time_val_from_iso8601" c:identifier="g_time_val_from_iso8601" moved-to="TimeVal.from_iso8601" version="2.12" deprecated="1" deprecated-version="2.62">
      <doc xml:space="preserve">Converts a string containing an ISO 8601 encoded date and time
to a #GTimeVal and puts it into @time_.

@iso_date must include year, month, day, hours, minutes, and
seconds. It can optionally include fractions of a second and a time
zone indicator. (In the absence of any time zone indication, the
timestamp is assumed to be in local time.)

Any leading or trailing space in @iso_date is ignored.

This function was deprecated, along with #GTimeVal itself, in GLib 2.62.
Equivalent functionality is available using code like:
|[
GDateTime *dt = g_date_time_new_from_iso8601 (iso8601_string, NULL);
gint64 time_val = g_date_time_to_unix (dt);
g_date_time_unref (dt);
]|</doc>
      <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use
   g_date_time_new_from_iso8601() instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the conversion was successful.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="iso_date" transfer-ownership="none">
          <doc xml:space="preserve">an ISO 8601 encoded date string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="time_" direction="out" caller-allocates="1" transfer-ownership="none">
          <doc xml:space="preserve">a #GTimeVal</doc>
          <type name="TimeVal" c:type="GTimeVal*"/>
        </parameter>
      </parameters>
    </function>
    <function name="timeout_add" c:identifier="g_timeout_add" shadowed-by="timeout_add_full" introspectable="0">
      <doc xml:space="preserve">Sets a function to be called at regular intervals, with the default
priority, [const@GLib.PRIORITY_DEFAULT].

The given @function is called repeatedly until it returns
[const@GLib.SOURCE_REMOVE], at which point the timeout is
automatically destroyed and the function will not be called again. The first
call to the function will be at the end of the first @interval.

Note that timeout functions may be delayed, due to the processing of other
event sources. Thus they should not be relied on for precise timing.
After each call to the timeout function, the time of the next
timeout is recalculated based on the current time and the given interval
(it does not try to &#x2018;catch up&#x2019; time lost in delays).

See [main loop memory management](main-loop.html#memory-management-of-sources) for details
on how to handle the return value and memory management of @data.

If you want to have a timer in the &#x2018;seconds&#x2019; range and do not care
about the exact time of the first call of the timer, use the
[func@GLib.timeout_add_seconds] function; this function allows for more
optimizations and more efficient system power usage.

This internally creates a main loop source using
[func@GLib.timeout_source_new] and attaches it to the global
[struct@GLib.MainContext] using [method@GLib.Source.attach], so the callback
will be invoked in whichever thread is running that main context. You can do
these steps manually if you need greater control or to use a custom main
context.

It is safe to call this function from any thread.

The interval given is in terms of monotonic time, not wall clock
time. See [func@GLib.get_monotonic_time].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="interval" transfer-ownership="none">
          <doc xml:space="preserve">the time between calls to the function, in milliseconds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">function to call</doc>
          <type name="SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="timeout_add_full" c:identifier="g_timeout_add_full" shadows="timeout_add">
      <doc xml:space="preserve">Sets a function to be called at regular intervals, with the given
priority.

The function is called repeatedly until it returns
[const@GLib.SOURCE_REMOVE], at which point the timeout is automatically
destroyed and
the function will not be called again.  The @notify function is
called when the timeout is destroyed.  The first call to the
function will be at the end of the first @interval.

Note that timeout functions may be delayed, due to the processing of other
event sources. Thus they should not be relied on for precise timing.
After each call to the timeout function, the time of the next
timeout is recalculated based on the current time and the given interval
(it does not try to &#x2018;catch up&#x2019; time lost in delays).

See [main loop memory management](main-loop.html#memory-management-of-sources) for details
on how to handle the return value and memory management of @data.

This internally creates a main loop source using
[func@GLib.timeout_source_new] and attaches it to the global
[struct@GLib.MainContext] using [method@GLib.Source.attach], so the callback
will be invoked in whichever thread is running that main context. You can do
these steps manually if you need greater control or to use a custom main
context.

The interval given is in terms of monotonic time, not wall clock time.
See [func@GLib.get_monotonic_time].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve">the priority of the timeout source; typically this will be in
  the range between [const@GLib.PRIORITY_DEFAULT] and
  [const@GLib.PRIORITY_HIGH]</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="interval" transfer-ownership="none">
          <doc xml:space="preserve">the time between calls to the function, in milliseconds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" scope="notified" closure="3" destroy="4">
          <doc xml:space="preserve">function to call</doc>
          <type name="SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">function to call when the timeout is removed</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="timeout_add_once" c:identifier="g_timeout_add_once" version="2.74" introspectable="0">
      <doc xml:space="preserve">Sets a function to be called after @interval milliseconds have elapsed,
with the default priority, [const@GLib.PRIORITY_DEFAULT].

The given @function is called once and then the source will be automatically
removed from the main context.

This function otherwise behaves like [func@GLib.timeout_add].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="interval" transfer-ownership="none">
          <doc xml:space="preserve">the time after which the function will be called, in milliseconds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">function to call</doc>
          <type name="SourceOnceFunc" c:type="GSourceOnceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="timeout_add_seconds" c:identifier="g_timeout_add_seconds" shadowed-by="timeout_add_seconds_full" version="2.14" introspectable="0">
      <doc xml:space="preserve">Sets a function to be called at regular intervals with the default
priority, [const@GLib.PRIORITY_DEFAULT].

The function is called repeatedly until it returns [const@GLib.SOURCE_REMOVE],
at which point the timeout is automatically destroyed
and the function will not be called again.

This internally creates a main loop source using
[func@GLib.timeout_source_new_seconds] and attaches it to the main loop context
using [method@GLib.Source.attach]. You can do these steps manually if you need
greater control. Also see [func@GLib.timeout_add_seconds_full].

It is safe to call this function from any thread.

Note that the first call of the timer may not be precise for timeouts
of one second. If you need finer precision and have such a timeout,
you may want to use [func@GLib.timeout_add] instead.

See [main loop memory management](main-loop.html#memory-management-of-sources) for details
on how to handle the return value and memory management of @data.

The interval given is in terms of monotonic time, not wall clock
time. See [func@GLib.get_monotonic_time].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="interval" transfer-ownership="none">
          <doc xml:space="preserve">the time between calls to the function, in seconds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">function to call</doc>
          <type name="SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="timeout_add_seconds_full" c:identifier="g_timeout_add_seconds_full" shadows="timeout_add_seconds" version="2.14">
      <doc xml:space="preserve">Sets a function to be called at regular intervals, with @priority.

The function is called repeatedly until it returns [const@GLib.SOURCE_REMOVE],
at which point the timeout is automatically destroyed and
the function will not be called again.

Unlike [func@GLib.timeout_add], this function operates at whole second
granularity. The initial starting point of the timer is determined by the
implementation and the implementation is expected to group multiple timers
together so that they fire all at the same time. To allow this grouping,
the @interval to the first timer is rounded and can deviate up to one second
from the specified interval. Subsequent timer iterations will generally run
at the specified interval.

Note that timeout functions may be delayed, due to the processing of other
event sources. Thus they should not be relied on for precise timing.
After each call to the timeout function, the time of the next
timeout is recalculated based on the current time and the given @interval

See [main loop memory management](main-loop.html#memory-management-of-sources) for details
on how to handle the return value and memory management of @data.

If you want timing more precise than whole seconds, use
[func@GLib.timeout_add] instead.

The grouping of timers to fire at the same time results in a more power
and CPU efficient behavior so if your timer is in multiples of seconds
and you don&#x2019;t require the first timer exactly one second from now, the
use of [func@GLib.timeout_add_seconds] is preferred over
[func@GLib.timeout_add].

This internally creates a main loop source using
[func@GLib.timeout_source_new_seconds] and attaches it to the main loop
context using [method@GLib.Source.attach]. You can do these steps manually
if you need greater control.

It is safe to call this function from any thread.

The interval given is in terms of monotonic time, not wall clock
time. See [func@GLib.get_monotonic_time].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve">the priority of the timeout source; typically this will be in
  the range between [const@GLib.PRIORITY_DEFAULT] and
  [const@GLib.PRIORITY_HIGH]</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="interval" transfer-ownership="none">
          <doc xml:space="preserve">the time between calls to the function, in seconds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" scope="notified" closure="3" destroy="4">
          <doc xml:space="preserve">function to call</doc>
          <type name="SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
          <doc xml:space="preserve">function to call when the timeout is removed</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="timeout_add_seconds_once" c:identifier="g_timeout_add_seconds_once" version="2.78" introspectable="0">
      <doc xml:space="preserve">This function behaves like [func@GLib.timeout_add_once] but with a range in
seconds.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="interval" transfer-ownership="none">
          <doc xml:space="preserve">the time after which the function will be called, in seconds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">function to call</doc>
          <type name="SourceOnceFunc" c:type="GSourceOnceFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="timeout_source_new" c:identifier="g_timeout_source_new">
      <doc xml:space="preserve">Creates a new timeout source.

The source will not initially be associated with any [struct@GLib.MainContext]
and must be added to one with [method@GLib.Source.attach] before it will be
executed.

The interval given is in terms of monotonic time, not wall clock
time.  See [func@GLib.get_monotonic_time].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly-created timeout source</doc>
        <type name="Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="interval" transfer-ownership="none">
          <doc xml:space="preserve">the timeout interval in milliseconds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="timeout_source_new_seconds" c:identifier="g_timeout_source_new_seconds" version="2.14">
      <doc xml:space="preserve">Creates a new timeout source.

The source will not initially be associated with any
[struct@GLib.MainContext] and must be added to one with
[method@GLib.Source.attach] before it will be executed.

The scheduling granularity/accuracy of this timeout source will be
in seconds.

The interval given is in terms of monotonic time, not wall clock time.
See [func@GLib.get_monotonic_time].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly-created timeout source</doc>
        <type name="Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="interval" transfer-ownership="none">
          <doc xml:space="preserve">the timeout interval in seconds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="trash_stack_height" c:identifier="g_trash_stack_height" moved-to="TrashStack.height" deprecated="1" deprecated-version="2.48">
      <doc xml:space="preserve">Returns the height of a #GTrashStack.

Note that execution of this function is of O(N) complexity
where N denotes the number of items on the stack.</doc>
      <doc-deprecated xml:space="preserve">#GTrashStack is deprecated without replacement</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the height of the stack</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="stack_p" transfer-ownership="none">
          <doc xml:space="preserve">a #GTrashStack</doc>
          <type name="TrashStack" c:type="GTrashStack**"/>
        </parameter>
      </parameters>
    </function>
    <function name="trash_stack_peek" c:identifier="g_trash_stack_peek" moved-to="TrashStack.peek" deprecated="1" deprecated-version="2.48">
      <doc xml:space="preserve">Returns the element at the top of a #GTrashStack
which may be %NULL.</doc>
      <doc-deprecated xml:space="preserve">#GTrashStack is deprecated without replacement</doc-deprecated>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the element at the top of the stack</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="stack_p" transfer-ownership="none">
          <doc xml:space="preserve">a #GTrashStack</doc>
          <type name="TrashStack" c:type="GTrashStack**"/>
        </parameter>
      </parameters>
    </function>
    <function name="trash_stack_pop" c:identifier="g_trash_stack_pop" moved-to="TrashStack.pop" deprecated="1" deprecated-version="2.48">
      <doc xml:space="preserve">Pops a piece of memory off a #GTrashStack.</doc>
      <doc-deprecated xml:space="preserve">#GTrashStack is deprecated without replacement</doc-deprecated>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the element at the top of the stack</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="stack_p" transfer-ownership="none">
          <doc xml:space="preserve">a #GTrashStack</doc>
          <type name="TrashStack" c:type="GTrashStack**"/>
        </parameter>
      </parameters>
    </function>
    <function name="trash_stack_push" c:identifier="g_trash_stack_push" moved-to="TrashStack.push" deprecated="1" deprecated-version="2.48">
      <doc xml:space="preserve">Pushes a piece of memory onto a #GTrashStack.</doc>
      <doc-deprecated xml:space="preserve">#GTrashStack is deprecated without replacement</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="stack_p" transfer-ownership="none">
          <doc xml:space="preserve">a #GTrashStack</doc>
          <type name="TrashStack" c:type="GTrashStack**"/>
        </parameter>
        <parameter name="data_p" transfer-ownership="none">
          <doc xml:space="preserve">the piece of memory to push on the stack</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="try_malloc" c:identifier="g_try_malloc">
      <doc xml:space="preserve">Attempts to allocate @n_bytes, and returns %NULL on failure.
Contrast with g_malloc(), which aborts the program on failure.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the allocated memory, or %NULL.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_bytes" transfer-ownership="none">
          <doc xml:space="preserve">number of bytes to allocate.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="try_malloc0" c:identifier="g_try_malloc0" version="2.8">
      <doc xml:space="preserve">Attempts to allocate @n_bytes, initialized to 0's, and returns %NULL on
failure. Contrast with g_malloc0(), which aborts the program on failure.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the allocated memory, or %NULL</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_bytes" transfer-ownership="none">
          <doc xml:space="preserve">number of bytes to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="try_malloc0_n" c:identifier="g_try_malloc0_n" version="2.24">
      <doc xml:space="preserve">This function is similar to g_try_malloc0(), allocating (@n_blocks * @n_block_bytes) bytes,
but care is taken to detect possible overflow during multiplication.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the allocated memory, or %NULL</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_blocks" transfer-ownership="none">
          <doc xml:space="preserve">the number of blocks to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="n_block_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the size of each block in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="try_malloc_n" c:identifier="g_try_malloc_n" version="2.24">
      <doc xml:space="preserve">This function is similar to g_try_malloc(), allocating (@n_blocks * @n_block_bytes) bytes,
but care is taken to detect possible overflow during multiplication.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the allocated memory, or %NULL.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_blocks" transfer-ownership="none">
          <doc xml:space="preserve">the number of blocks to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="n_block_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the size of each block in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="try_new" c:identifier="g_try_new" version="2.8" introspectable="0">
      <doc xml:space="preserve">Attempts to allocate @n_structs elements of type @struct_type, and returns
%NULL on failure. Contrast with g_new(), which aborts the program on failure.
The returned pointer is cast to a pointer to the given type.
The function returns %NULL when @n_structs is 0 of if an overflow occurs.</doc>
      <parameters>
        <parameter name="struct_type">
          <doc xml:space="preserve">the type of the elements to allocate</doc>
        </parameter>
        <parameter name="n_structs">
          <doc xml:space="preserve">the number of elements to allocate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="try_new0" c:identifier="g_try_new0" version="2.8" introspectable="0">
      <doc xml:space="preserve">Attempts to allocate @n_structs elements of type @struct_type, initialized
to 0's, and returns %NULL on failure. Contrast with g_new0(), which aborts
the program on failure.
The returned pointer is cast to a pointer to the given type.
The function returns %NULL when @n_structs is 0 or if an overflow occurs.</doc>
      <parameters>
        <parameter name="struct_type">
          <doc xml:space="preserve">the type of the elements to allocate</doc>
        </parameter>
        <parameter name="n_structs">
          <doc xml:space="preserve">the number of elements to allocate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="try_realloc" c:identifier="g_try_realloc">
      <doc xml:space="preserve">Attempts to realloc @mem to a new size, @n_bytes, and returns %NULL
on failure. Contrast with g_realloc(), which aborts the program
on failure.

If @mem is %NULL, behaves the same as g_try_malloc().</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the allocated memory, or %NULL.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">previously-allocated memory, or %NULL.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="n_bytes" transfer-ownership="none">
          <doc xml:space="preserve">number of bytes to allocate.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="try_realloc_n" c:identifier="g_try_realloc_n" version="2.24">
      <doc xml:space="preserve">This function is similar to g_try_realloc(), allocating (@n_blocks * @n_block_bytes) bytes,
but care is taken to detect possible overflow during multiplication.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the allocated memory, or %NULL.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">previously-allocated memory, or %NULL.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="n_blocks" transfer-ownership="none">
          <doc xml:space="preserve">the number of blocks to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="n_block_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the size of each block in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="try_renew" c:identifier="g_try_renew" version="2.8" introspectable="0">
      <doc xml:space="preserve">Attempts to reallocate the memory pointed to by @mem, so that it now has
space for @n_structs elements of type @struct_type, and returns %NULL on
failure. Contrast with g_renew(), which aborts the program on failure.
It returns the new address of the memory, which may have been moved.
The function returns %NULL if an overflow occurs.</doc>
      <parameters>
        <parameter name="struct_type">
          <doc xml:space="preserve">the type of the elements to allocate</doc>
        </parameter>
        <parameter name="mem">
          <doc xml:space="preserve">the currently allocated memory</doc>
        </parameter>
        <parameter name="n_structs">
          <doc xml:space="preserve">the number of elements to allocate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="typeof" c:identifier="glib_typeof" introspectable="0">
      <parameters>
        <parameter name="t">
        </parameter>
      </parameters>
    </function-macro>
    <function name="ucs4_to_utf16" c:identifier="g_ucs4_to_utf16" throws="1">
      <doc xml:space="preserve">Convert a string from UCS-4 to UTF-16.

A nul character (U+0000) will be added to the result after the converted text.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to a newly allocated UTF-16 string.
  This value must be freed with [func@GLib.free].</doc>
        <type name="guint16" c:type="gunichar2*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UCS-4 encoded string</doc>
          <array length="1" zero-terminated="0" c:type="const gunichar*">
            <type name="gunichar"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length (number of characters) of @str to use.
  If @len is negative, then the string is nul-terminated.</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="items_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number of
  bytes read, or `NULL`. If an error occurs then the index of the invalid
  input is stored here.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
        <parameter name="items_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number
  of `gunichar2` written, or `NULL`. The value stored here does not include
  the trailing nul.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ucs4_to_utf8" c:identifier="g_ucs4_to_utf8" throws="1">
      <doc xml:space="preserve">Convert a string from a 32-bit fixed width representation as UCS-4.
to UTF-8.

The result will be terminated with a nul byte.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to a newly allocated UTF-8 string.
  This value must be freed with [func@GLib.free]. If an error occurs,
  @items_read will be set to the position of the first invalid input
  character.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UCS-4 encoded string</doc>
          <array length="1" zero-terminated="0" c:type="const gunichar*">
            <type name="gunichar"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length (number of characters) of @str to use.
  If @len is negative, then the string is nul-terminated.</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="items_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number of
  characters read, or `NULL`.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
        <parameter name="items_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number
  of bytes written or `NULL`. The value here stored does not include the
  trailing nul byte.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="uint64_checked_add" c:identifier="g_uint64_checked_add" version="2.48" introspectable="0">
      <doc xml:space="preserve">Performs a checked addition of @a and @b, storing the result in
@dest.

If the operation is successful, %TRUE is returned.  If the operation
overflows then the state of @dest is undefined and %FALSE is
returned.</doc>
      <parameters>
        <parameter name="dest">
          <doc xml:space="preserve">a pointer to the #guint64 destination</doc>
        </parameter>
        <parameter name="a">
          <doc xml:space="preserve">the #guint64 left operand</doc>
        </parameter>
        <parameter name="b">
          <doc xml:space="preserve">the #guint64 right operand</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="uint64_checked_mul" c:identifier="g_uint64_checked_mul" version="2.48" introspectable="0">
      <doc xml:space="preserve">Performs a checked multiplication of @a and @b, storing the result in
@dest.

If the operation is successful, %TRUE is returned.  If the operation
overflows then the state of @dest is undefined and %FALSE is
returned.</doc>
      <parameters>
        <parameter name="dest">
          <doc xml:space="preserve">a pointer to the #guint64 destination</doc>
        </parameter>
        <parameter name="a">
          <doc xml:space="preserve">the #guint64 left operand</doc>
        </parameter>
        <parameter name="b">
          <doc xml:space="preserve">the #guint64 right operand</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="uint_checked_add" c:identifier="g_uint_checked_add" version="2.48" introspectable="0">
      <doc xml:space="preserve">Performs a checked addition of @a and @b, storing the result in
@dest.

If the operation is successful, %TRUE is returned.  If the operation
overflows then the state of @dest is undefined and %FALSE is
returned.</doc>
      <parameters>
        <parameter name="dest">
          <doc xml:space="preserve">a pointer to the #guint destination</doc>
        </parameter>
        <parameter name="a">
          <doc xml:space="preserve">the #guint left operand</doc>
        </parameter>
        <parameter name="b">
          <doc xml:space="preserve">the #guint right operand</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="uint_checked_mul" c:identifier="g_uint_checked_mul" version="2.48" introspectable="0">
      <doc xml:space="preserve">Performs a checked multiplication of @a and @b, storing the result in
@dest.

If the operation is successful, %TRUE is returned.  If the operation
overflows then the state of @dest is undefined and %FALSE is
returned.</doc>
      <parameters>
        <parameter name="dest">
          <doc xml:space="preserve">a pointer to the #guint destination</doc>
        </parameter>
        <parameter name="a">
          <doc xml:space="preserve">the #guint left operand</doc>
        </parameter>
        <parameter name="b">
          <doc xml:space="preserve">the #guint right operand</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="unichar_break_type" c:identifier="g_unichar_break_type">
      <doc xml:space="preserve">Determines the break type of @c. @c should be a Unicode character
(to derive a character from UTF-8 encoded text, use
g_utf8_get_char()). The break type is used to find word and line
breaks ("text boundaries"), Pango implements the Unicode boundary
resolution algorithms and normally you would use a function such
as pango_break() instead of caring about break types yourself.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the break type of @c</doc>
        <type name="UnicodeBreakType" c:type="GUnicodeBreakType"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_combining_class" c:identifier="g_unichar_combining_class" version="2.14">
      <doc xml:space="preserve">Determines the canonical combining class of a Unicode character.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the combining class of the character</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="uc" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_compose" c:identifier="g_unichar_compose" version="2.30">
      <doc xml:space="preserve">Performs a single composition step of the
Unicode canonical composition algorithm.

This function includes algorithmic Hangul Jamo composition,
but it is not exactly the inverse of g_unichar_decompose().
No composition can have either of @a or @b equal to zero.
To be precise, this function composes if and only if
there exists a Primary Composite P which is canonically
equivalent to the sequence &lt;@a,@b&gt;.  See the Unicode
Standard for the definition of Primary Composite.

If @a and @b do not compose a new character, @ch is set to zero.

See
[UAX#15](http://unicode.org/reports/tr15/)
for details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the characters could be composed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
        <parameter name="ch" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">return location for the composed character</doc>
          <type name="gunichar" c:type="gunichar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_decompose" c:identifier="g_unichar_decompose" version="2.30">
      <doc xml:space="preserve">Performs a single decomposition step of the
Unicode canonical decomposition algorithm.

This function does not include compatibility
decompositions. It does, however, include algorithmic
Hangul Jamo decomposition, as well as 'singleton'
decompositions which replace a character by a single
other character. In the case of singletons `*b` will
be set to zero.

If @ch is not decomposable, `*a` is set to @ch and `*b`
is set to zero.

Note that the way Unicode decomposition pairs are
defined, it is guaranteed that @b would not decompose
further, but @a may itself decompose.  To get the full
canonical decomposition for @ch, one would need to
recursively call this function on @a.  Or use
g_unichar_fully_decompose().

See
[UAX#15](http://unicode.org/reports/tr15/)
for details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the character could be decomposed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ch" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
        <parameter name="a" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">return location for the first component of @ch</doc>
          <type name="gunichar" c:type="gunichar*"/>
        </parameter>
        <parameter name="b" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">return location for the second component of @ch</doc>
          <type name="gunichar" c:type="gunichar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_digit_value" c:identifier="g_unichar_digit_value">
      <doc xml:space="preserve">Determines the numeric value of a character as a decimal
digit.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">If @c is a decimal digit (according to
g_unichar_isdigit()), its numeric value. Otherwise, -1.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_fully_decompose" c:identifier="g_unichar_fully_decompose" version="2.30">
      <doc xml:space="preserve">Computes the canonical or compatibility decomposition of a
Unicode character.  For compatibility decomposition,
pass %TRUE for @compat; for canonical decomposition
pass %FALSE for @compat.

The decomposed sequence is placed in @result.  Only up to
@result_len characters are written into @result.  The length
of the full decomposition (irrespective of @result_len) is
returned by the function.  For canonical decomposition,
currently all decompositions are of length at most 4, but
this may change in the future (very unlikely though).
At any rate, Unicode does guarantee that a buffer of length
18 is always enough for both compatibility and canonical
decompositions, so that is the size recommended. This is provided
as %G_UNICHAR_MAX_DECOMPOSITION_LENGTH.

See
[UAX#15](http://unicode.org/reports/tr15/)
for details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the length of the full decomposition.</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="ch" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character.</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
        <parameter name="compat" transfer-ownership="none">
          <doc xml:space="preserve">whether perform canonical or compatibility decomposition</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="result" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store decomposed result, or %NULL</doc>
          <type name="gunichar" c:type="gunichar*"/>
        </parameter>
        <parameter name="result_len" transfer-ownership="none">
          <doc xml:space="preserve">length of @result</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_get_mirror_char" c:identifier="g_unichar_get_mirror_char" version="2.4">
      <doc xml:space="preserve">In Unicode, some characters are "mirrored". This means that their
images are mirrored horizontally in text that is laid out from right
to left. For instance, "(" would become its mirror image, ")", in
right-to-left text.

If @ch has the Unicode mirrored property and there is another unicode
character that typically has a glyph that is the mirror image of @ch's
glyph and @mirrored_ch is set, it puts that character in the address
pointed to by @mirrored_ch.  Otherwise the original character is put.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @ch has a mirrored character, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ch" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
        <parameter name="mirrored_ch" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">location to store the mirrored character</doc>
          <type name="gunichar" c:type="gunichar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_get_script" c:identifier="g_unichar_get_script" version="2.14">
      <doc xml:space="preserve">Looks up the #GUnicodeScript for a particular character (as defined
by Unicode Standard Annex \#24). No check is made for @ch being a
valid Unicode character; if you pass in invalid character, the
result is undefined.

This function is equivalent to pango_script_for_unichar() and the
two are interchangeable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GUnicodeScript for the character.</doc>
        <type name="UnicodeScript" c:type="GUnicodeScript"/>
      </return-value>
      <parameters>
        <parameter name="ch" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_isalnum" c:identifier="g_unichar_isalnum">
      <doc xml:space="preserve">Determines whether a character is alphanumeric.
Given some UTF-8 text, obtain a character value
with g_utf8_get_char().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @c is an alphanumeric character</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_isalpha" c:identifier="g_unichar_isalpha">
      <doc xml:space="preserve">Determines whether a character is alphabetic (i.e. a letter).
Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @c is an alphabetic character</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_iscntrl" c:identifier="g_unichar_iscntrl">
      <doc xml:space="preserve">Determines whether a character is a control character.
Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @c is a control character</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_isdefined" c:identifier="g_unichar_isdefined">
      <doc xml:space="preserve">Determines if a given character is assigned in the Unicode
standard.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the character has an assigned value</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_isdigit" c:identifier="g_unichar_isdigit">
      <doc xml:space="preserve">Determines whether a character is numeric (i.e. a digit).  This
covers ASCII 0-9 and also digits in other languages/scripts.  Given
some UTF-8 text, obtain a character value with g_utf8_get_char().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @c is a digit</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_isgraph" c:identifier="g_unichar_isgraph">
      <doc xml:space="preserve">Determines whether a character is printable and not a space
(returns %FALSE for control characters, format characters, and
spaces). g_unichar_isprint() is similar, but returns %TRUE for
spaces. Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @c is printable unless it's a space</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_islower" c:identifier="g_unichar_islower">
      <doc xml:space="preserve">Determines whether a character is a lowercase letter.
Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @c is a lowercase letter</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_ismark" c:identifier="g_unichar_ismark" version="2.14">
      <doc xml:space="preserve">Determines whether a character is a mark (non-spacing mark,
combining mark, or enclosing mark in Unicode speak).
Given some UTF-8 text, obtain a character value
with g_utf8_get_char().

Note: in most cases where isalpha characters are allowed,
ismark characters should be allowed to as they are essential
for writing most European languages as well as many non-Latin
scripts.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @c is a mark character</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_isprint" c:identifier="g_unichar_isprint">
      <doc xml:space="preserve">Determines whether a character is printable.
Unlike g_unichar_isgraph(), returns %TRUE for spaces.
Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @c is printable</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_ispunct" c:identifier="g_unichar_ispunct">
      <doc xml:space="preserve">Determines whether a character is punctuation or a symbol.
Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @c is a punctuation or symbol character</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_isspace" c:identifier="g_unichar_isspace">
      <doc xml:space="preserve">Determines whether a character is a space, tab, or line separator
(newline, carriage return, etc.).  Given some UTF-8 text, obtain a
character value with g_utf8_get_char().

(Note: don't use this to do word breaking; you have to use
Pango or equivalent to get word breaking right, the algorithm
is fairly complex.)</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @c is a space character</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_istitle" c:identifier="g_unichar_istitle">
      <doc xml:space="preserve">Determines if a character is titlecase. Some characters in
Unicode which are composites, such as the DZ digraph
have three case variants instead of just two. The titlecase
form is used at the beginning of a word where only the
first letter is capitalized. The titlecase form of the DZ
digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the character is titlecase</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_isupper" c:identifier="g_unichar_isupper">
      <doc xml:space="preserve">Determines if a character is uppercase.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @c is an uppercase character</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_iswide" c:identifier="g_unichar_iswide">
      <doc xml:space="preserve">Determines if a character is typically rendered in a double-width
cell.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the character is wide</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_iswide_cjk" c:identifier="g_unichar_iswide_cjk" version="2.12">
      <doc xml:space="preserve">Determines if a character is typically rendered in a double-width
cell under legacy East Asian locales.  If a character is wide according to
g_unichar_iswide(), then it is also reported wide with this function, but
the converse is not necessarily true. See the
[Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)
for details.

If a character passes the g_unichar_iswide() test then it will also pass
this test, but not the other way around.  Note that some characters may
pass both this test and g_unichar_iszerowidth().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the character is wide in legacy East Asian locales</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_isxdigit" c:identifier="g_unichar_isxdigit">
      <doc xml:space="preserve">Determines if a character is a hexadecimal digit.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the character is a hexadecimal digit</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character.</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_iszerowidth" c:identifier="g_unichar_iszerowidth" version="2.14">
      <doc xml:space="preserve">Determines if a given character typically takes zero width when rendered.
The return value is %TRUE for all non-spacing and enclosing marks
(e.g., combining accents), format characters, zero-width
space, but not U+00AD SOFT HYPHEN.

A typical use of this function is with one of g_unichar_iswide() or
g_unichar_iswide_cjk() to determine the number of cells a string occupies
when displayed on a grid display (terminals).  However, note that not all
terminals support zero-width rendering of zero-width marks.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the character has zero width</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_to_utf8" c:identifier="g_unichar_to_utf8">
      <doc xml:space="preserve">Converts a single character to UTF-8.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of bytes written, guaranteed to be in the range [1, 6]</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character code</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
        <parameter name="outbuf" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
          <doc xml:space="preserve">output buffer, must have at
  least 6 bytes of space. If `NULL`, the length will be computed and
  returned and nothing will be written to @outbuf.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_tolower" c:identifier="g_unichar_tolower">
      <doc xml:space="preserve">Converts a character to lower case.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the result of converting @c to lower case.
              If @c is not an upperlower or titlecase character,
              or has no lowercase equivalent @c is returned unchanged.</doc>
        <type name="gunichar" c:type="gunichar"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character.</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_totitle" c:identifier="g_unichar_totitle">
      <doc xml:space="preserve">Converts a character to the titlecase.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the result of converting @c to titlecase.
              If @c is not an uppercase or lowercase character,
              @c is returned unchanged.</doc>
        <type name="gunichar" c:type="gunichar"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_toupper" c:identifier="g_unichar_toupper">
      <doc xml:space="preserve">Converts a character to uppercase.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the result of converting @c to uppercase.
              If @c is not a lowercase or titlecase character,
              or has no upper case equivalent @c is returned unchanged.</doc>
        <type name="gunichar" c:type="gunichar"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_type" c:identifier="g_unichar_type">
      <doc xml:space="preserve">Classifies a Unicode character by type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the type of the character.</doc>
        <type name="UnicodeType" c:type="GUnicodeType"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_validate" c:identifier="g_unichar_validate">
      <doc xml:space="preserve">Checks whether @ch is a valid Unicode character.

Some possible integer values of @ch will not be valid. U+0000 is considered a
valid character, though it&#x2019;s normally a string terminator.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if @ch is a valid Unicode character</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ch" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unichar_xdigit_value" c:identifier="g_unichar_xdigit_value">
      <doc xml:space="preserve">Determines the numeric value of a character as a hexadecimal
digit.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">If @c is a hex digit (according to
g_unichar_isxdigit()), its numeric value. Otherwise, -1.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="unicode_canonical_decomposition" c:identifier="g_unicode_canonical_decomposition" deprecated="1" deprecated-version="2.30">
      <doc xml:space="preserve">Computes the canonical decomposition of a Unicode character.</doc>
      <doc-deprecated xml:space="preserve">Use the more flexible g_unichar_fully_decompose()
  instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a newly allocated string of Unicode characters.
  @result_len is set to the resulting length of the string.</doc>
        <type name="gunichar" c:type="gunichar*"/>
      </return-value>
      <parameters>
        <parameter name="ch" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character.</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
        <parameter name="result_len" transfer-ownership="none">
          <doc xml:space="preserve">location to store the length of the return value.</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unicode_canonical_ordering" c:identifier="g_unicode_canonical_ordering">
      <doc xml:space="preserve">Computes the canonical ordering of a string in-place.
This rearranges decomposed characters in the string
according to their combining classes.  See the Unicode
manual for more information.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a UCS-4 encoded string.</doc>
          <array length="1" zero-terminated="0" c:type="gunichar*">
            <type name="gunichar"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length of @string to use.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="unicode_script_from_iso15924" c:identifier="g_unicode_script_from_iso15924" moved-to="UnicodeScript.from_iso15924" version="2.30">
      <doc xml:space="preserve">Looks up the Unicode script for @iso15924.  ISO 15924 assigns four-letter
codes to scripts.  For example, the code for Arabic is 'Arab'.
This function accepts four letter codes encoded as a @guint32 in a
big-endian fashion.  That is, the code expected for Arabic is
0x41726162 (0x41 is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).

See
[Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
for details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the Unicode script for @iso15924, or
  of %G_UNICODE_SCRIPT_INVALID_CODE if @iso15924 is zero and
  %G_UNICODE_SCRIPT_UNKNOWN if @iso15924 is unknown.</doc>
        <type name="UnicodeScript" c:type="GUnicodeScript"/>
      </return-value>
      <parameters>
        <parameter name="iso15924" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode script</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="unicode_script_to_iso15924" c:identifier="g_unicode_script_to_iso15924" moved-to="UnicodeScript.to_iso15924" version="2.30">
      <doc xml:space="preserve">Looks up the ISO 15924 code for @script.  ISO 15924 assigns four-letter
codes to scripts.  For example, the code for Arabic is 'Arab'.  The
four letter codes are encoded as a @guint32 by this function in a
big-endian fashion.  That is, the code returned for Arabic is
0x41726162 (0x41 is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).

See
[Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
for details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ISO 15924 code for @script, encoded as an integer,
  of zero if @script is %G_UNICODE_SCRIPT_INVALID_CODE or
  ISO 15924 code 'Zzzz' (script code for UNKNOWN) if @script is not understood.</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="script" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode script</doc>
          <type name="UnicodeScript" c:type="GUnicodeScript"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_error_quark" c:identifier="g_unix_error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="unix_fd_add" c:identifier="g_unix_fd_add" version="2.36" introspectable="0">
      <doc xml:space="preserve">Sets a function to be called when the IO condition, as specified by
@condition becomes true for @fd.

@function will be called when the specified IO condition becomes
%TRUE.  The function is expected to clear whatever event caused the
IO condition to become true and return %TRUE in order to be notified
when it happens again.  If @function returns %FALSE then the watch
will be cancelled.

The return value of this function can be passed to g_source_remove()
to cancel the watch at any time that it exists.

The source will never close the fd -- you must do it yourself.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">IO conditions to watch for on @fd</doc>
          <type name="IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">a #GUnixFDSourceFunc</doc>
          <type name="UnixFDSourceFunc" c:type="GUnixFDSourceFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_fd_add_full" c:identifier="g_unix_fd_add_full" version="2.36">
      <doc xml:space="preserve">Sets a function to be called when the IO condition, as specified by
@condition becomes true for @fd.

This is the same as g_unix_fd_add(), except that it allows you to
specify a non-default priority and a provide a #GDestroyNotify for
@user_data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve">the priority of the source</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">IO conditions to watch for on @fd</doc>
          <type name="IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" scope="notified" closure="4" destroy="5">
          <doc xml:space="preserve">a #GUnixFDSourceFunc</doc>
          <type name="UnixFDSourceFunc" c:type="GUnixFDSourceFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">function to call when the idle is removed, or %NULL</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_fd_query_path" c:identifier="g_unix_fd_query_path" version="2.88" throws="1">
      <doc xml:space="preserve">Queries the file path for the given FD opened by the current process.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The file path, or `NULL` on error</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">The file descriptor to query.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_fd_source_new" c:identifier="g_unix_fd_source_new" version="2.36">
      <doc xml:space="preserve">Creates a #GSource to watch for a particular I/O condition on a file
descriptor.

The source will never close the @fd &#x2014; you must do it yourself.

Any callback attached to the returned #GSource must have type
#GUnixFDSourceFunc.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly created #GSource</doc>
        <type name="Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">I/O conditions to watch for on @fd</doc>
          <type name="IOCondition" c:type="GIOCondition"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_get_passwd_entry" c:identifier="g_unix_get_passwd_entry" version="2.64" throws="1">
      <doc xml:space="preserve">Get the `passwd` file entry for the given @user_name using `getpwnam_r()`.
This can fail if the given @user_name doesn&#x2019;t exist.

The returned `struct passwd` has been allocated using g_malloc() and should
be freed using g_free(). The strings referenced by the returned struct are
included in the same allocation, so are valid until the `struct passwd` is
freed.

This function is safe to call from multiple threads concurrently.

You will need to include `pwd.h` to get the definition of `struct passwd`.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">passwd entry, or %NULL on error; free the returned
   value with g_free()</doc>
        <type name="gpointer" c:type="passwd*"/>
      </return-value>
      <parameters>
        <parameter name="user_name" transfer-ownership="none">
          <doc xml:space="preserve">the username to get the passwd file entry for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_open_pipe" c:identifier="g_unix_open_pipe" version="2.30" throws="1">
      <doc xml:space="preserve">Similar to the UNIX pipe() call, but on modern systems like Linux
uses the pipe2() system call, which atomically creates a pipe with
the configured flags.

As of GLib 2.78, the supported flags are `O_CLOEXEC`/`FD_CLOEXEC` (see below)
and `O_NONBLOCK`. Prior to GLib 2.78, only `FD_CLOEXEC` was supported &#x2014; if
you wanted to configure `O_NONBLOCK` then that had to be done separately with
`fcntl()`.

Since GLib 2.80, the constants %G_UNIX_PIPE_END_READ and
%G_UNIX_PIPE_END_WRITE can be used as mnemonic indexes in @fds.

It is a programmer error to call this function with unsupported flags, and a
critical warning will be raised.

As of GLib 2.78, it is preferred to pass `O_CLOEXEC` in, rather than
`FD_CLOEXEC`, as that matches the underlying `pipe()` API more closely. Prior
to 2.78, only `FD_CLOEXEC` was supported. Support for `FD_CLOEXEC` may be
deprecated and removed in future.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if not (and errno will be set).</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fds" transfer-ownership="none">
          <doc xml:space="preserve">Array of two integers</doc>
          <array zero-terminated="0" c:type="gint*" fixed-size="2">
            <type name="gint" c:type="gint"/>
          </array>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">Bitfield of file descriptor flags, as for fcntl()</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_set_fd_nonblocking" c:identifier="g_unix_set_fd_nonblocking" version="2.30" throws="1">
      <doc xml:space="preserve">Control the non-blocking state of the given file descriptor,
according to @nonblock. On most systems this uses %O_NONBLOCK, but
on some older ones may use %O_NDELAY.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if successful</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">A file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="nonblock" transfer-ownership="none">
          <doc xml:space="preserve">If %TRUE, set the descriptor to be non-blocking</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_signal_add" c:identifier="g_unix_signal_add" shadowed-by="unix_signal_add_full" version="2.30" introspectable="0">
      <doc xml:space="preserve">A convenience function for g_unix_signal_source_new(), which
attaches to the default #GMainContext.  You can remove the watch
using g_source_remove().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">An ID (greater than 0) for the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="signum" transfer-ownership="none">
          <doc xml:space="preserve">Signal number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="handler" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">Callback</doc>
          <type name="SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Data for @handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_signal_add_full" c:identifier="g_unix_signal_add_full" shadows="unix_signal_add" version="2.30">
      <doc xml:space="preserve">A convenience function for g_unix_signal_source_new(), which
attaches to the default #GMainContext.  You can remove the watch
using g_source_remove().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">An ID (greater than 0) for the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve">the priority of the signal source. Typically this will be in
           the range between %G_PRIORITY_DEFAULT and %G_PRIORITY_HIGH.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="signum" transfer-ownership="none">
          <doc xml:space="preserve">Signal number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="handler" transfer-ownership="none" scope="notified" closure="3" destroy="4">
          <doc xml:space="preserve">Callback</doc>
          <type name="SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Data for @handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">#GDestroyNotify for @handler</doc>
          <type name="DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="unix_signal_source_new" c:identifier="g_unix_signal_source_new" version="2.30">
      <doc xml:space="preserve">Create a #GSource that will be dispatched upon delivery of the UNIX
signal @signum.  In GLib versions before 2.36, only `SIGHUP`, `SIGINT`,
`SIGTERM` can be monitored.  In GLib 2.36, `SIGUSR1` and `SIGUSR2`
were added. In GLib 2.54, `SIGWINCH` was added.

Note that unlike the UNIX default, all sources which have created a
watch will be dispatched, regardless of which underlying thread
invoked g_unix_signal_source_new().

For example, an effective use of this function is to handle `SIGTERM`
cleanly; flushing any outstanding files, and then calling
g_main_loop_quit().  It is not safe to do any of this from a regular
UNIX signal handler; such a handler may be invoked while malloc() or
another library function is running, causing reentrancy issues if the
handler attempts to use those functions.  None of the GLib/GObject
API is safe against this kind of reentrancy.

The interaction of this source when combined with native UNIX
functions like sigprocmask() is not defined.

The source will not initially be associated with any #GMainContext
and must be added to one with g_source_attach() before it will be
executed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A newly created #GSource</doc>
        <type name="Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="signum" transfer-ownership="none">
          <doc xml:space="preserve">A signal number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="unlink" c:identifier="g_unlink" version="2.6">
      <doc xml:space="preserve">A wrapper for the POSIX unlink() function. The unlink() function
deletes a name from the filesystem. If this was the last link to the
file and no processes have it opened, the diskspace occupied by the
file is freed.

See your C library manual for more details about unlink(). Note
that on Windows, it is in general not possible to delete files that
are open to some process, or mapped into memory.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the name was successfully deleted, -1 if an error
   occurred</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unsetenv" c:identifier="g_unsetenv" version="2.4">
      <doc xml:space="preserve">Removes an environment variable from the environment.

Note that on some systems, when variables are overwritten, the
memory used for the previous variables and its value isn't reclaimed.

You should be mindful of the fact that environment variable handling
in UNIX is not thread-safe, and your program may crash if one thread
calls g_unsetenv() while another thread is calling getenv(). (And note
that many functions, such as gettext(), call getenv() internally.) This
function is only safe to use at the very start of your program, before
creating any other threads (or creating objects that create worker
threads of their own).

If you need to set up the environment for a child process, you can
use g_get_environ() to get an environment array, modify that with
g_environ_setenv() and g_environ_unsetenv(), and then pass that
array directly to execvpe(), g_spawn_async(), or the like.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="variable" transfer-ownership="none">
          <doc xml:space="preserve">the environment variable to remove, must
    not contain '='</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_build" c:identifier="g_uri_build" moved-to="Uri.build" version="2.66">
      <doc xml:space="preserve">Creates a new #GUri from the given components according to @flags.

See also g_uri_build_with_user(), which allows specifying the
components of the "userinfo" separately.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GUri</doc>
        <type name="Uri" c:type="GUri*"/>
      </return-value>
      <parameters>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags describing how to build the #GUri</doc>
          <type name="UriFlags" c:type="GUriFlags"/>
        </parameter>
        <parameter name="scheme" transfer-ownership="none">
          <doc xml:space="preserve">the URI scheme</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="userinfo" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the userinfo component, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="host" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the host component, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="port" transfer-ownership="none">
          <doc xml:space="preserve">the port, or `-1`</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">the path component</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="query" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the query component, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="fragment" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the fragment, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_build_with_user" c:identifier="g_uri_build_with_user" moved-to="Uri.build_with_user" version="2.66">
      <doc xml:space="preserve">Creates a new #GUri from the given components according to @flags
(%G_URI_FLAGS_HAS_PASSWORD is added unconditionally). The @flags must be
coherent with the passed values, in particular use `%`-encoded values with
%G_URI_FLAGS_ENCODED.

In contrast to g_uri_build(), this allows specifying the components
of the &#x2018;userinfo&#x2019; field separately. Note that @user must be non-%NULL
if either @password or @auth_params is non-%NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GUri</doc>
        <type name="Uri" c:type="GUri*"/>
      </return-value>
      <parameters>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags describing how to build the #GUri</doc>
          <type name="UriFlags" c:type="GUriFlags"/>
        </parameter>
        <parameter name="scheme" transfer-ownership="none">
          <doc xml:space="preserve">the URI scheme</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the user component of the userinfo, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the password component of the userinfo, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="auth_params" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the auth params of the userinfo, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="host" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the host component, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="port" transfer-ownership="none">
          <doc xml:space="preserve">the port, or `-1`</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">the path component</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="query" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the query component, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="fragment" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the fragment, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_error_quark" c:identifier="g_uri_error_quark" moved-to="Uri.error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="uri_escape_bytes" c:identifier="g_uri_escape_bytes" moved-to="Uri.escape_bytes" version="2.66">
      <doc xml:space="preserve">Escapes arbitrary data for use in a URI.

Normally all characters that are not &#x2018;unreserved&#x2019; (i.e. ASCII
alphanumerical characters plus dash, dot, underscore and tilde) are
escaped. But if you specify characters in @reserved_chars_allowed
they are not escaped. This is useful for the &#x2018;reserved&#x2019; characters
in the URI specification, since those are allowed unescaped in some
portions of a URI.

Though technically incorrect, this will also allow escaping nul
bytes as `%``00`.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">an escaped version of @unescaped.
    The returned string should be freed when no longer needed.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="unescaped" transfer-ownership="none">
          <doc xml:space="preserve">the unescaped input data.</doc>
          <array length="1" zero-terminated="0" c:type="const guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of @unescaped</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="reserved_chars_allowed" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string of reserved
  characters that are allowed to be used, or %NULL.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_escape_string" c:identifier="g_uri_escape_string" moved-to="Uri.escape_string" version="2.16">
      <doc xml:space="preserve">Escapes a string for use in a URI.

Normally all characters that are not "unreserved" (i.e. ASCII
alphanumerical characters plus dash, dot, underscore and tilde) are
escaped. But if you specify characters in @reserved_chars_allowed
they are not escaped. This is useful for the "reserved" characters
in the URI specification, since those are allowed unescaped in some
portions of a URI.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">an escaped version of @unescaped. The
returned string should be freed when no longer needed.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="unescaped" transfer-ownership="none">
          <doc xml:space="preserve">the unescaped input string.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="reserved_chars_allowed" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string of reserved
  characters that are allowed to be used, or %NULL.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="allow_utf8" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the result can include UTF-8 characters.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_is_valid" c:identifier="g_uri_is_valid" moved-to="Uri.is_valid" version="2.66" throws="1">
      <doc xml:space="preserve">Parses @uri_string according to @flags, to determine whether it is a valid
[absolute URI](#relative-and-absolute-uris), i.e. it does not need to be resolved
relative to another URI using g_uri_parse_relative().

If it&#x2019;s not a valid URI, an error is returned explaining how it&#x2019;s invalid.

See g_uri_split(), and the definition of #GUriFlags, for more
information on the effect of @flags.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @uri_string is a valid absolute URI, %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="uri_string" transfer-ownership="none">
          <doc xml:space="preserve">a string containing an absolute URI</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for parsing @uri_string</doc>
          <type name="UriFlags" c:type="GUriFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_join" c:identifier="g_uri_join" moved-to="Uri.join" version="2.66">
      <doc xml:space="preserve">Joins the given components together according to @flags to create
an absolute URI string. @path may not be %NULL (though it may be the empty
string).

When @host is present, @path must either be empty or begin with a slash (`/`)
character. When @host is not present, @path cannot begin with two slash
characters (`//`). See
[RFC 3986, section 3](https://tools.ietf.org/html/rfc3986#section-3).

See also g_uri_join_with_user(), which allows specifying the
components of the &#x2018;userinfo&#x2019; separately.

%G_URI_FLAGS_HAS_PASSWORD and %G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
in @flags.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">an absolute URI string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags describing how to build the URI string</doc>
          <type name="UriFlags" c:type="GUriFlags"/>
        </parameter>
        <parameter name="scheme" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the URI scheme, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="userinfo" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the userinfo component, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="host" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the host component, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="port" transfer-ownership="none">
          <doc xml:space="preserve">the port, or `-1`</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">the path component</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="query" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the query component, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="fragment" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the fragment, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_join_with_user" c:identifier="g_uri_join_with_user" moved-to="Uri.join_with_user" version="2.66">
      <doc xml:space="preserve">Joins the given components together according to @flags to create
an absolute URI string. @path may not be %NULL (though it may be the empty
string).

In contrast to g_uri_join(), this allows specifying the components
of the &#x2018;userinfo&#x2019; separately. It otherwise behaves the same.

%G_URI_FLAGS_HAS_PASSWORD and %G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
in @flags.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">an absolute URI string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags describing how to build the URI string</doc>
          <type name="UriFlags" c:type="GUriFlags"/>
        </parameter>
        <parameter name="scheme" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the URI scheme, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the user component of the userinfo, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the password component of the userinfo, or
  %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="auth_params" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the auth params of the userinfo, or
  %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="host" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the host component, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="port" transfer-ownership="none">
          <doc xml:space="preserve">the port, or `-1`</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">the path component</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="query" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the query component, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="fragment" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the fragment, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_list_extract_uris" c:identifier="g_uri_list_extract_uris" moved-to="Uri.list_extract_uris" version="2.6">
      <doc xml:space="preserve">Splits an URI list conforming to the text/uri-list
mime type defined in RFC 2483 into individual URIs,
discarding any comments. The URIs are not validated.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated %NULL-terminated list
  of strings holding the individual URIs. The array should be freed
  with g_strfreev().</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="uri_list" transfer-ownership="none">
          <doc xml:space="preserve">an URI list</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_parse" c:identifier="g_uri_parse" moved-to="Uri.parse" version="2.66" throws="1">
      <doc xml:space="preserve">Parses @uri_string according to @flags. If the result is not a
valid [absolute URI](#relative-and-absolute-uris), it will be discarded, and an
error returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GUri, or NULL on error.</doc>
        <type name="Uri" c:type="GUri*"/>
      </return-value>
      <parameters>
        <parameter name="uri_string" transfer-ownership="none">
          <doc xml:space="preserve">a string representing an absolute URI</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags describing how to parse @uri_string</doc>
          <type name="UriFlags" c:type="GUriFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_parse_params" c:identifier="g_uri_parse_params" moved-to="Uri.parse_params" version="2.66" throws="1">
      <doc xml:space="preserve">Many URI schemes include one or more attribute/value pairs as part of the URI
value. This method can be used to parse them into a hash table. When an
attribute has multiple occurrences, the last value is the final returned
value. If you need to handle repeated attributes differently, use
#GUriParamsIter.

The @params string is assumed to still be `%`-encoded, but the returned
values will be fully decoded. (Thus it is possible that the returned values
may contain `=` or @separators, if the value was encoded in the input.)
Invalid `%`-encoding is treated as with the %G_URI_FLAGS_PARSE_RELAXED
rules for g_uri_parse(). (However, if @params is the path or query string
from a #GUri that was parsed without %G_URI_FLAGS_PARSE_RELAXED and
%G_URI_FLAGS_ENCODED, then you already know that it does not contain any
invalid encoding.)

%G_URI_PARAMS_WWW_FORM is handled as documented for g_uri_params_iter_init().

If %G_URI_PARAMS_CASE_INSENSITIVE is passed to @flags, attributes will be
compared case-insensitively, so a params string `attr=123&amp;Attr=456` will only
return a single attribute&#x2013;value pair, `Attr=456`. Case will be preserved in
the returned attributes.

If @params cannot be parsed (for example, it contains two @separators
characters in a row), then @error is set and %NULL is returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
    A hash table of attribute/value pairs, with both names and values
    fully-decoded; or %NULL on error.</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="params" transfer-ownership="none">
          <doc xml:space="preserve">a `%`-encoded string containing `attribute=value`
  parameters</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of @params, or `-1` if it is nul-terminated</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="separators" transfer-ownership="none">
          <doc xml:space="preserve">the separator byte character set between parameters. (usually
  `&amp;`, but sometimes `;` or both `&amp;;`). Note that this function works on
  bytes not characters, so it can't be used to delimit UTF-8 strings for
  anything but ASCII characters. You may pass an empty set, in which case
  no splitting will occur.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags to modify the way the parameters are handled.</doc>
          <type name="UriParamsFlags" c:type="GUriParamsFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_parse_scheme" c:identifier="g_uri_parse_scheme" moved-to="Uri.parse_scheme" version="2.16">
      <doc xml:space="preserve">Gets the scheme portion of a URI string.
[RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme
as:
|[
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
]|
Common schemes include `file`, `https`, `svn+ssh`, etc.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">The &#x2018;scheme&#x2019; component of the URI, or
    %NULL on error. The returned string should be freed when no longer needed.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">a valid URI.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_peek_scheme" c:identifier="g_uri_peek_scheme" moved-to="Uri.peek_scheme" version="2.66">
      <doc xml:space="preserve">Gets the scheme portion of a URI string.
[RFC 3986](https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme
as:
|[
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
]|
Common schemes include `file`, `https`, `svn+ssh`, etc.

Unlike g_uri_parse_scheme(), the returned scheme is normalized to
all-lowercase and does not need to be freed.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">The &#x2018;scheme&#x2019; component of the URI, or
    %NULL on error. The returned string is normalized to all-lowercase, and
    interned via g_intern_string(), so it does not need to be freed.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">a valid URI.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_resolve_relative" c:identifier="g_uri_resolve_relative" moved-to="Uri.resolve_relative" version="2.66" throws="1">
      <doc xml:space="preserve">Parses @uri_ref according to @flags and, if it is a
[relative URI](#relative-and-absolute-uris), resolves it relative to
@base_uri_string. If the result is not a valid absolute URI, it will be
discarded, and an error returned.

(If @base_uri_string is %NULL, this just returns @uri_ref, or
%NULL if @uri_ref is invalid or not absolute.)</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the resolved URI string,
or NULL on error.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="base_uri_string" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string representing a base URI</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="uri_ref" transfer-ownership="none">
          <doc xml:space="preserve">a string representing a relative or absolute URI</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags describing how to parse @uri_ref</doc>
          <type name="UriFlags" c:type="GUriFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_split" c:identifier="g_uri_split" moved-to="Uri.split" version="2.66" throws="1">
      <doc xml:space="preserve">Parses @uri_ref (which can be an
[absolute or relative URI](#relative-and-absolute-uris)) according to @flags, and
returns the pieces. Any component that doesn't appear in @uri_ref will be
returned as %NULL (but note that all URIs always have a path component,
though it may be the empty string).

If @flags contains %G_URI_FLAGS_ENCODED, then `%`-encoded characters in
@uri_ref will remain encoded in the output strings. (If not,
then all such characters will be decoded.) Note that decoding will
only work if the URI components are ASCII or UTF-8, so you will
need to use %G_URI_FLAGS_ENCODED if they are not.

Note that the %G_URI_FLAGS_HAS_PASSWORD and
%G_URI_FLAGS_HAS_AUTH_PARAMS @flags are ignored by g_uri_split(),
since it always returns only the full userinfo; use
g_uri_split_with_user() if you want it split up.</doc>
      <return-value transfer-ownership="none" skip="1">
        <doc xml:space="preserve">%TRUE if @uri_ref parsed successfully, %FALSE
  on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="uri_ref" transfer-ownership="none">
          <doc xml:space="preserve">a string containing a relative or absolute URI</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for parsing @uri_ref</doc>
          <type name="UriFlags" c:type="GUriFlags"/>
        </parameter>
        <parameter name="scheme" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains
   the scheme (converted to lowercase), or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="userinfo" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains
   the userinfo, or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="host" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains the
   host, or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="port" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains the
   port, or `-1`</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains the
   path</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="query" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains the
   query, or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="fragment" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains
   the fragment, or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_split_network" c:identifier="g_uri_split_network" moved-to="Uri.split_network" version="2.66" throws="1">
      <doc xml:space="preserve">Parses @uri_string (which must be an [absolute URI](#relative-and-absolute-uris))
according to @flags, and returns the pieces relevant to connecting to a host.
See the documentation for g_uri_split() for more details; this is
mostly a wrapper around that function with simpler arguments.
However, it will return an error if @uri_string is a relative URI,
or does not contain a hostname component.</doc>
      <return-value transfer-ownership="none" skip="1">
        <doc xml:space="preserve">%TRUE if @uri_string parsed successfully,
  %FALSE on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="uri_string" transfer-ownership="none">
          <doc xml:space="preserve">a string containing an absolute URI</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for parsing @uri_string</doc>
          <type name="UriFlags" c:type="GUriFlags"/>
        </parameter>
        <parameter name="scheme" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains
   the scheme (converted to lowercase), or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="host" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains the
   host, or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="port" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains the
   port, or `-1`</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_split_with_user" c:identifier="g_uri_split_with_user" moved-to="Uri.split_with_user" version="2.66" throws="1">
      <doc xml:space="preserve">Parses @uri_ref (which can be an
[absolute or relative URI](#relative-and-absolute-uris)) according to @flags, and
returns the pieces. Any component that doesn't appear in @uri_ref will be
returned as %NULL (but note that all URIs always have a path component,
though it may be the empty string).

See g_uri_split(), and the definition of #GUriFlags, for more
information on the effect of @flags. Note that @password will only
be parsed out if @flags contains %G_URI_FLAGS_HAS_PASSWORD, and
@auth_params will only be parsed out if @flags contains
%G_URI_FLAGS_HAS_AUTH_PARAMS.</doc>
      <return-value transfer-ownership="none" skip="1">
        <doc xml:space="preserve">%TRUE if @uri_ref parsed successfully, %FALSE
  on error.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="uri_ref" transfer-ownership="none">
          <doc xml:space="preserve">a string containing a relative or absolute URI</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for parsing @uri_ref</doc>
          <type name="UriFlags" c:type="GUriFlags"/>
        </parameter>
        <parameter name="scheme" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains
   the scheme (converted to lowercase), or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="user" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains
   the user, or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="password" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains
   the password, or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="auth_params" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains
   the auth_params, or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="host" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains the
   host, or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="port" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains the
   port, or `-1`</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains the
   path</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="query" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains the
   query, or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="fragment" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1">
          <doc xml:space="preserve">on return, contains
   the fragment, or %NULL</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_unescape_bytes" c:identifier="g_uri_unescape_bytes" moved-to="Uri.unescape_bytes" version="2.66" throws="1">
      <doc xml:space="preserve">Unescapes a segment of an escaped string as binary data.

Note that in contrast to g_uri_unescape_string(), this does allow
nul bytes to appear in the output.

If any of the characters in @illegal_characters appears as an escaped
character in @escaped_string, then that is an error and %NULL will be
returned. This is useful if you want to avoid for instance having a slash
being expanded in an escaped path element, which might confuse pathname
handling.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">an unescaped version of @escaped_string
    or %NULL on error (if decoding failed, using %G_URI_ERROR_FAILED error
    code). The returned #GBytes should be unreffed when no longer needed.</doc>
        <type name="Bytes" c:type="GBytes*"/>
      </return-value>
      <parameters>
        <parameter name="escaped_string" transfer-ownership="none">
          <doc xml:space="preserve">A URI-escaped string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length (in bytes) of @escaped_string to escape, or `-1` if it
  is nul-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="illegal_characters" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string of illegal characters
  not to be allowed, or %NULL.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_unescape_segment" c:identifier="g_uri_unescape_segment" moved-to="Uri.unescape_segment" version="2.16">
      <doc xml:space="preserve">Unescapes a segment of an escaped string.

If any of the characters in @illegal_characters or the NUL
character appears as an escaped character in @escaped_string, then
that is an error and %NULL will be returned. This is useful if you
want to avoid for instance having a slash being expanded in an
escaped path element, which might confuse pathname handling.

Note: `NUL` byte is not accepted in the output, in contrast to
g_uri_unescape_bytes().</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">an unescaped version of @escaped_string,
or %NULL on error. The returned string should be freed when no longer
needed.  As a special case if %NULL is given for @escaped_string, this
function will return %NULL.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="escaped_string" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">A string, may be %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="escaped_string_end" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Pointer to end of @escaped_string,
  may be %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="illegal_characters" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">An optional string of illegal
  characters not to be allowed, may be %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_unescape_string" c:identifier="g_uri_unescape_string" moved-to="Uri.unescape_string" version="2.16">
      <doc xml:space="preserve">Unescapes a whole escaped string.

If any of the characters in @illegal_characters or the NUL
character appears as an escaped character in @escaped_string, then
that is an error and %NULL will be returned. This is useful if you
want to avoid for instance having a slash being expanded in an
escaped path element, which might confuse pathname handling.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">an unescaped version of @escaped_string.
The returned string should be freed when no longer needed.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="escaped_string" transfer-ownership="none">
          <doc xml:space="preserve">an escaped string to be unescaped.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="illegal_characters" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a string of illegal characters
  not to be allowed, or %NULL.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="usleep" c:identifier="g_usleep">
      <doc xml:space="preserve">Pauses the current thread for the given number of microseconds.

There are 1 million microseconds per second (represented by the
%G_USEC_PER_SEC macro). g_usleep() may have limited precision,
depending on hardware and operating system; don't rely on the exact
length of the sleep.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="microseconds" transfer-ownership="none">
          <doc xml:space="preserve">number of microseconds to pause</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf16_to_ucs4" c:identifier="g_utf16_to_ucs4" throws="1">
      <doc xml:space="preserve">Convert a string from UTF-16 to UCS-4.

The result will be nul-terminated.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to a newly allocated UCS-4 string.
  This value must be freed with [func@GLib.free].</doc>
        <type name="gunichar" c:type="gunichar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-16 encoded string</doc>
          <array length="1" zero-terminated="0" c:type="const gunichar2*">
            <type name="guint16"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length (number of #gunichar2) of @str to use.
  If @len is negative, then the string is nul-terminated.</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="items_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number of words read, or
  `NULL`. If `NULL`, then [error@GLib.ConvertError.PARTIAL_INPUT] will be
  returned in case @str contains a trailing partial character. If
  an error occurs then the index of the invalid input is stored here.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
        <parameter name="items_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number
  of characters written, or `NULL`. The value stored here does not include
  the trailing nul character.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf16_to_utf8" c:identifier="g_utf16_to_utf8" throws="1">
      <doc xml:space="preserve">Convert a string from UTF-16 to UTF-8.

The result will be terminated with a nul byte.

Note that the input is expected to be already in native endianness,
an initial byte-order-mark character is not handled specially.
[func@GLib.convert] can be used to convert a byte buffer of UTF-16 data of
ambiguous endianness.

Further note that this function does not validate the result
string; it may (for example) include embedded nul characters. The only
validation done by this function is to ensure that the input can
be correctly interpreted as UTF-16, i.e. it doesn&#x2019;t contain
unpaired surrogates or partial character sequences.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to a newly allocated UTF-8 string.
  This value must be freed with [func@GLib.free].</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-16 encoded string</doc>
          <array length="1" zero-terminated="0" c:type="const gunichar2*">
            <type name="guint16"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length (number of #gunichar2) of @str to use.
  If @len is negative, then the string is nul-terminated.</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="items_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number of words read, or
  `NULL`. If `NULL`, then [error@GLib.ConvertError.PARTIAL_INPUT] will
  be returned in case @str contains a trailing partial character. If
  an error occurs then the index of the invalid input is stored here.
  It&#x2019;s guaranteed to be non-negative.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
        <parameter name="items_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number
  of bytes written, or `NULL`. The value stored here does not include the
  trailing nul byte. It&#x2019;s guaranteed to be non-negative.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_casefold" c:identifier="g_utf8_casefold">
      <doc xml:space="preserve">Converts a string into a form that is independent of case. The
result will not correspond to any particular case, but can be
compared for equality or ordered with the results of calling
g_utf8_casefold() on other strings.

Note that calling g_utf8_casefold() followed by g_utf8_collate() is
only an approximation to the correct linguistic case insensitive
ordering, though it is a fairly good one. Getting this exactly
right would require a more sophisticated collation function that
takes case sensitivity into account. GLib does not currently
provide such a function.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string, that is a
  case independent form of @str.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_collate" c:identifier="g_utf8_collate">
      <doc xml:space="preserve">Compares two strings for ordering using the linguistically
correct rules for the [current locale](running.html#locale).
When sorting a large number of strings, it will be significantly
faster to obtain collation keys with g_utf8_collate_key() and
compare the keys with strcmp() when sorting instead of sorting
the original strings.

If the two strings are not comparable due to being in different collation
sequences, the result is undefined. This can happen if the strings are in
different language scripts, for example.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">&lt; 0 if @str1 compares before @str2,
  0 if they compare equal, &gt; 0 if @str1 compares after @str2.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="str1" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="str2" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_collate_key" c:identifier="g_utf8_collate_key">
      <doc xml:space="preserve">Converts a string into a collation key that can be compared
with other collation keys produced by the same function using
strcmp().

The results of comparing the collation keys of two strings
with strcmp() will always be the same as comparing the two
original keys with g_utf8_collate().

Note that this function depends on the [current locale](running.html#locale).

Note that the returned string is not guaranteed to be in any
encoding, especially UTF-8. The returned value is meant to be
used only for comparisons.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string.
  The contents of the string are only meant to be used when sorting.
  This string should be freed with g_free() when you are done with it.</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_collate_key_for_filename" c:identifier="g_utf8_collate_key_for_filename" version="2.8">
      <doc xml:space="preserve">Converts a string into a collation key that can be compared
with other collation keys produced by the same function using strcmp().

In order to sort filenames correctly, this function treats the dot '.'
as a special case. Most dictionary orderings seem to consider it
insignificant, thus producing the ordering "event.c" "eventgenerator.c"
"event.h" instead of "event.c" "event.h" "eventgenerator.c". Also, we
would like to treat numbers intelligently so that "file1" "file10" "file5"
is sorted as "file1" "file5" "file10".

Note that this function depends on the [current locale](running.html#locale).

Note that the returned string is not guaranteed to be in any
encoding, especially UTF-8. The returned value is meant to be
used only for comparisons.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string.
  The contents of the string are only meant to be used when sorting.
  This string should be freed with g_free() when you are done with it.</doc>
        <type name="filename" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_find_next_char" c:identifier="g_utf8_find_next_char">
      <doc xml:space="preserve">Finds the start of the next UTF-8 character in the string after @p.

@p does not have to be at the beginning of a UTF-8 character. No check
is made to see if the character found is actually valid other than
it starts with an appropriate byte.

If @end is `NULL`, the return value will never be `NULL`: if the end of the
string is reached, a pointer to the terminating nul byte is returned. If
@end is non-`NULL`, the return value will be `NULL` if the end of the string
is reached.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the found character or `NULL` if @end is
   set and is reached</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="p" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a position within a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to the byte following the end of the string,
    or `NULL` to indicate that the string is nul-terminated</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_find_prev_char" c:identifier="g_utf8_find_prev_char">
      <doc xml:space="preserve">Given a position @p with a UTF-8 encoded string @str, find the start
of the previous UTF-8 character starting before @p. Returns `NULL` if no
UTF-8 characters are present in @str before @p.

@p does not have to be at the beginning of a UTF-8 character. No check
is made to see if the character found is actually valid other than
it starts with an appropriate byte.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the found character</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">pointer to the beginning of a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="p" transfer-ownership="none">
          <doc xml:space="preserve">pointer to some position within @str</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_get_char" c:identifier="g_utf8_get_char">
      <doc xml:space="preserve">Converts a sequence of bytes encoded as UTF-8 to a Unicode character.

If @p does not point to a valid UTF-8 encoded character, results
are undefined. If you are not sure that the bytes are complete
valid Unicode characters, you should use [func@GLib.utf8_get_char_validated]
instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the resulting character</doc>
        <type name="gunichar" c:type="gunichar"/>
      </return-value>
      <parameters>
        <parameter name="p" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to Unicode character encoded as UTF-8</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_get_char_validated" c:identifier="g_utf8_get_char_validated">
      <doc xml:space="preserve">Convert a sequence of bytes encoded as UTF-8 to a Unicode character.

This function checks for incomplete characters, for invalid characters
such as characters that are out of the range of Unicode, and for
overlong encodings of valid characters.

Note that [func@GLib.utf8_get_char_validated] returns `(gunichar)-2` if
@max_len is positive and any of the bytes in the first UTF-8 character
sequence are nul.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the resulting character. If @p points to a partial
  sequence at the end of a string that could begin a valid
  character (or if @max_len is zero), returns `(gunichar)-2`;
  otherwise, if @p does not point to a valid UTF-8 encoded
  Unicode character, returns `(gunichar)-1`.</doc>
        <type name="gunichar" c:type="gunichar"/>
      </return-value>
      <parameters>
        <parameter name="p" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to Unicode character encoded as UTF-8</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="max_len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of bytes to read, or `-1` if @p is nul-terminated</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_make_valid" c:identifier="g_utf8_make_valid" version="2.52">
      <doc xml:space="preserve">If the provided string is valid UTF-8, return a copy of it. If not,
return a copy in which bytes that could not be interpreted as valid Unicode
are replaced with the Unicode replacement character (U+FFFD).

For example, this is an appropriate function to use if you have received
a string that was incorrectly declared to be UTF-8, and you need a valid
UTF-8 version of it that can be logged or displayed to the user, with the
assumption that it is close enough to ASCII or UTF-8 to be mostly
readable as-is.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a valid UTF-8 string whose content resembles @str</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">string to coerce into UTF-8</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length of @str to use, in bytes. If @len is negative,
  then the string is nul-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="utf8_next_char" c:identifier="g_utf8_next_char" introspectable="0">
      <doc xml:space="preserve">Skips to the next character in a UTF-8 string.

The string must be valid; this macro is as fast as possible, and has
no error-checking.

You would use this macro to iterate over a string character by character.

The macro returns the start of the next UTF-8 character.

Before using this macro, use g_utf8_validate() to validate strings
that may contain invalid UTF-8.</doc>
      <parameters>
        <parameter name="p">
          <doc xml:space="preserve">Pointer to the start of a valid UTF-8 character</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="utf8_normalize" c:identifier="g_utf8_normalize">
      <doc xml:space="preserve">Converts a string into canonical form, standardizing
such issues as whether a character with an accent
is represented as a base character and combining
accent or as a single precomposed character. The
string has to be valid UTF-8, otherwise %NULL is
returned. You should generally call g_utf8_normalize()
before comparing two Unicode strings.

The normalization mode %G_NORMALIZE_DEFAULT only
standardizes differences that do not affect the
text content, such as the above-mentioned accent
representation. %G_NORMALIZE_ALL also standardizes
the "compatibility" characters in Unicode, such
as SUPERSCRIPT THREE to the standard forms
(in this case DIGIT THREE). Formatting information
may be lost but for most text operations such
characters should be considered the same.

%G_NORMALIZE_DEFAULT_COMPOSE and %G_NORMALIZE_ALL_COMPOSE
are like %G_NORMALIZE_DEFAULT and %G_NORMALIZE_ALL,
but returned a result with composed forms rather
than a maximally decomposed form. This is often
useful if you intend to convert the string to
a legacy encoding or pass it to a system with
less capable Unicode handling.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a newly allocated string, that
  is the normalized form of @str, or %NULL if @str
  is not valid UTF-8.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">the type of normalization to perform.</doc>
          <type name="NormalizeMode" c:type="GNormalizeMode"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_offset_to_pointer" c:identifier="g_utf8_offset_to_pointer">
      <doc xml:space="preserve">Converts from an integer character offset to a pointer to a position
within the string.

Since 2.10, this function allows to pass a negative @offset to
step backwards. It is usually worth stepping backwards from the end
instead of forwards if @offset is in the last fourth of the string,
since moving forward is about 3 times faster than moving backward.

Note that this function doesn&#x2019;t abort when reaching the end of @str.
Therefore you should be sure that @offset is within string boundaries
before calling that function. Call [func@GLib.utf8_strlen] when unsure.
This limitation exists as this function is called frequently during
text rendering and therefore has to be as fast as possible.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the resulting pointer</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">a character offset within @str</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_pointer_to_offset" c:identifier="g_utf8_pointer_to_offset">
      <doc xml:space="preserve">Converts from a pointer to position within a string to an integer
character offset.

Since 2.10, this function allows @pos to be before @str, and returns
a negative offset in this case.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the resulting character offset</doc>
        <type name="glong" c:type="glong"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a position within @str</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_prev_char" c:identifier="g_utf8_prev_char">
      <doc xml:space="preserve">Finds the previous UTF-8 character in the string before @p.

@p does not have to be at the beginning of a UTF-8 character. No check
is made to see if the character found is actually valid other than
it starts with an appropriate byte. If @p might be the first
character of the string, you must use [func@GLib.utf8_find_prev_char]
instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a pointer to the found character</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="p" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a position within a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_strchr" c:identifier="g_utf8_strchr">
      <doc xml:space="preserve">Finds the leftmost occurrence of the given Unicode character
in a UTF-8 encoded string, while limiting the search to @len bytes.

If @len is `-1`, allow unbounded search.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">`NULL` if the string does not contain
  the character, otherwise, a pointer to the start of the leftmost occurrence
  of the character in the string.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="p" transfer-ownership="none">
          <doc xml:space="preserve">a nul-terminated UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length of @p</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_strdown" c:identifier="g_utf8_strdown">
      <doc xml:space="preserve">Converts all Unicode characters in the string that have a case
to lowercase. The exact manner that this is done depends
on the current locale, and may result in the number of
characters in the string changing.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string, with all characters
   converted to lowercase.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_strlen" c:identifier="g_utf8_strlen">
      <doc xml:space="preserve">Computes the length of the string in characters, not including
the terminating nul character. If the @max&#x2019;th byte falls in the
middle of a character, the last (partial) character is not counted.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the length of the string in characters</doc>
        <type name="glong" c:type="glong"/>
      </return-value>
      <parameters>
        <parameter name="p" transfer-ownership="none">
          <doc xml:space="preserve">pointer to the start of a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="max" transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of bytes to examine. If @max
  is less than 0, then the string is assumed to be
  nul-terminated. If @max is 0, @p will not be examined and
  may be `NULL`. If @max is greater than 0, up to @max
  bytes are examined</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_strncpy" c:identifier="g_utf8_strncpy">
      <doc xml:space="preserve">Like the standard C [`strncpy()`](man:strncpy) function, but copies a given
number of characters instead of a given number of bytes.

The @src string must be valid UTF-8 encoded text. (Use
[func@GLib.utf8_validate] on all text before trying to use UTF-8 utility
functions with it.)

Note you must ensure @dest is at least 4 * @n + 1 to fit the
largest possible UTF-8 characters</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">@dest</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">buffer to fill with characters from @src</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">character count</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_strrchr" c:identifier="g_utf8_strrchr">
      <doc xml:space="preserve">Find the rightmost occurrence of the given Unicode character
in a UTF-8 encoded string, while limiting the search to @len bytes.

If @len is `-1`, allow unbounded search.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">`NULL` if the string does not contain
  the character, otherwise, a pointer to the start of the rightmost
  occurrence of the character in the string.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="p" transfer-ownership="none">
          <doc xml:space="preserve">a nul-terminated UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length of @p</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_strreverse" c:identifier="g_utf8_strreverse" version="2.2">
      <doc xml:space="preserve">Reverses a UTF-8 string.

@str must be valid UTF-8 encoded text. (Use [func@GLib.utf8_validate] on all
text before trying to use UTF-8 utility functions with it.)

This function is intended for programmatic uses of reversed strings.
It pays no attention to decomposed characters, combining marks, byte
order marks, directional indicators (LRM, LRO, etc) and similar
characters which might need special handling when reversing a string
for display purposes.

Note that unlike [func@GLib.strreverse], this function returns
newly-allocated memory, which should be freed with [func@GLib.free] when
no longer needed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated string which is the reverse of @str</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length of @str to use, in bytes. If @len is negative,
  then the string is nul-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_strup" c:identifier="g_utf8_strup">
      <doc xml:space="preserve">Converts all Unicode characters in the string that have a case
to uppercase. The exact manner that this is done depends
on the current locale, and may result in the number of
characters in the string increasing. (For instance, the
German ess-zet will be changed to SS.)</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string, with all characters
   converted to uppercase.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_substring" c:identifier="g_utf8_substring" version="2.30">
      <doc xml:space="preserve">Copies a substring out of a UTF-8 encoded string.
The substring will contain @end_pos - @start_pos characters.

Since GLib 2.72, `-1` can be passed to @end_pos to indicate the
end of the string.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated copy of the requested
  substring. Free with [func@GLib.free] when no longer needed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="start_pos" transfer-ownership="none">
          <doc xml:space="preserve">a character offset within @str</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="end_pos" transfer-ownership="none">
          <doc xml:space="preserve">another character offset within @str,
  or `-1` to indicate the end of the string</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_to_ucs4" c:identifier="g_utf8_to_ucs4" throws="1">
      <doc xml:space="preserve">Convert a string from UTF-8 to a 32-bit fixed width representation as UCS-4.

A trailing nul character (U+0000) will be added to the string after the
converted text.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to a newly allocated UCS-4 string.
  This value must be freed with [func@GLib.free].</doc>
        <type name="gunichar" c:type="gunichar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length of @str to use, in bytes. If @len is negative,
  then the string is nul-terminated.</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="items_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number of
 bytes read, or `NULL`.
  If `NULL`, then %G_CONVERT_ERROR_PARTIAL_INPUT will be
  returned in case @str contains a trailing partial
  character. If an error occurs then the index of the
  invalid input is stored here.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
        <parameter name="items_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number
  of characters written or `NULL`. The value here stored does not include
  the trailing nul character.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_to_ucs4_fast" c:identifier="g_utf8_to_ucs4_fast">
      <doc xml:space="preserve">Convert a string from UTF-8 to a 32-bit fixed width
representation as UCS-4, assuming valid UTF-8 input.

This function is roughly twice as fast as [func@GLib.utf8_to_ucs4]
but does no error checking on the input. A trailing nul character (U+0000)
will be added to the string after the converted text.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to a newly allocated UCS-4 string.
  This value must be freed with [func@GLib.free].</doc>
        <type name="gunichar" c:type="gunichar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length of @str to use, in bytes. If @len is negative,
  then the string is nul-terminated.</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="items_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store the
  number of characters in the result, or `NULL`.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_to_utf16" c:identifier="g_utf8_to_utf16" throws="1">
      <doc xml:space="preserve">Convert a string from UTF-8 to UTF-16.

A nul character (U+0000) will be added to the result after the converted text.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a pointer to a newly allocated UTF-16 string.
  This value must be freed with [func@GLib.free].</doc>
        <type name="guint16" c:type="gunichar2*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the maximum length (number of bytes) of @str to use.
  If @len is negative, then the string is nul-terminated.</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="items_read" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number of bytes read, or
  `NULL`. If `NULL`, then [error@GLib.ConvertError.PARTIAL_INPUT] will
  be returned in case @str contains a trailing partial character. If
  an error occurs then the index of the invalid input is stored here.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
        <parameter name="items_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store number
  of `gunichar2` written, or `NULL`. The value stored here does not include
  the trailing nul.</doc>
          <type name="glong" c:type="glong*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_truncate_middle" c:identifier="g_utf8_truncate_middle" version="2.78">
      <doc xml:space="preserve">Cuts off the middle of the string, preserving half of @truncate_length
characters at the beginning and half at the end.

If @string is already short enough, this returns a copy of @string.
If @truncate_length is `0`, an empty string is returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated copy of @string ellipsized in the middle</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a nul-terminated UTF-8 encoded string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="truncate_length" transfer-ownership="none">
          <doc xml:space="preserve">the new size of @string, in characters, including the ellipsis character</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_validate" c:identifier="g_utf8_validate">
      <doc xml:space="preserve">Validates UTF-8 encoded text.

@str is the text to validate; if @str is nul-terminated, then @max_len can be
`-1`, otherwise @max_len should be the number of bytes to validate.

If @end is non-`NULL`, then the end of the valid range will be stored there.
This is the first byte of the first invalid character if some bytes were
invalid, or the end of the text being validated otherwise &#x2014; either the
trailing nul byte, or the first byte beyond @max_len (if it&#x2019;s positive).

Note that `g_utf8_validate()` returns `FALSE` if @max_len is  positive and
any of the @max_len bytes are nul.

Returns `TRUE` if all of @str was valid. Many GLib and GTK
routines require valid UTF-8 as input; so data read from a file
or the network should be checked with `g_utf8_validate()` before
doing anything else with it.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if the text was valid UTF-8</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to character data</doc>
          <array length="1" zero-terminated="0" c:type="const gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="max_len" transfer-ownership="none">
          <doc xml:space="preserve">max bytes to validate, or `-1` to go until nul</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="end" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for end of valid data</doc>
          <array c:type="const gchar**">
            <type name="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_validate_len" c:identifier="g_utf8_validate_len" version="2.60">
      <doc xml:space="preserve">Validates UTF-8 encoded text.

As with [func@GLib.utf8_validate], but @max_len must be set, and hence this
function will always return `FALSE` if any of the bytes of @str are nul.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if the text was valid UTF-8</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to character data</doc>
          <array length="1" zero-terminated="0" c:type="const gchar*">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="max_len" transfer-ownership="none">
          <doc xml:space="preserve">max bytes to validate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="end" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for end of valid data</doc>
          <array c:type="const gchar**">
            <type name="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="utime" c:identifier="g_utime" version="2.18">
      <doc xml:space="preserve">A wrapper for the POSIX utime() function. The utime() function
sets the access and modification timestamps of a file.

See your C library manual for more details about how utime() works
on your system.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 if the operation was successful, -1 if an error occurred</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname in the GLib file name encoding
    (UTF-8 on Windows)</doc>
          <type name="filename" c:type="const gchar*"/>
        </parameter>
        <parameter name="utb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to a struct utimbuf.</doc>
          <type name="gpointer" c:type="utimbuf*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uuid_string_is_valid" c:identifier="g_uuid_string_is_valid" version="2.52">
      <doc xml:space="preserve">Parses the string @str and verify if it is a UUID.

The function accepts the following syntax:

- simple forms (e.g. `f81d4fae-7dec-11d0-a765-00a0c91e6bf6`)

Note that hyphens are required within the UUID string itself,
as per the aforementioned RFC.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @str is a valid UUID, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string representing a UUID</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uuid_string_random" c:identifier="g_uuid_string_random" version="2.52">
      <doc xml:space="preserve">Generates a random UUID (RFC 4122 version 4) as a string. It has the same
randomness guarantees as #GRand, so must not be used for cryptographic
purposes such as key generation, nonces, salts or one-time pads.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A string that should be freed with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
    </function>
    <function name="variant_get_gtype" c:identifier="g_variant_get_gtype">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="variant_is_object_path" c:identifier="g_variant_is_object_path" moved-to="Variant.is_object_path" version="2.24">
      <doc xml:space="preserve">Determines if a given string is a valid D-Bus object path.  You
should ensure that a string is a valid D-Bus object path before
passing it to g_variant_new_object_path().

A valid object path starts with `/` followed by zero or more
sequences of characters separated by `/` characters.  Each sequence
must contain only the characters `[A-Z][a-z][0-9]_`.  No sequence
(including the one following the final `/` character) may be empty.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @string is a D-Bus object path</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a normal C nul-terminated string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="variant_is_signature" c:identifier="g_variant_is_signature" moved-to="Variant.is_signature" version="2.24">
      <doc xml:space="preserve">Determines if a given string is a valid D-Bus type signature.  You
should ensure that a string is a valid D-Bus type signature before
passing it to g_variant_new_signature().

D-Bus type signatures consist of zero or more definite #GVariantType
strings in sequence.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @string is a D-Bus type signature</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a normal C nul-terminated string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="variant_parse" c:identifier="g_variant_parse" moved-to="Variant.parse" throws="1">
      <doc xml:space="preserve">Parses a #GVariant from a text representation.

A single #GVariant is parsed from the content of @text.

The format is described [here](gvariant-text-format.html).

The memory at @limit will never be accessed and the parser behaves as
if the character at @limit is the nul terminator.  This has the
effect of bounding @text.

If @endptr is non-%NULL then @text is permitted to contain data
following the value that this function parses and @endptr will be
updated to point to the first character past the end of the text
parsed by this function.  If @endptr is %NULL and there is extra data
then an error is returned.

If @type is non-%NULL then the value will be parsed to have that
type.  This may result in additional parse errors (in the case that
the parsed value doesn't fit the type) but may also result in fewer
errors (in the case that the type would have been ambiguous, such as
with empty arrays).

In the event that the parsing is successful, the resulting #GVariant
is returned. It is never floating, and must be freed with
[method@GLib.Variant.unref].

In case of any error, %NULL will be returned.  If @error is non-%NULL
then it will be set to reflect the error that occurred.

Officially, the language understood by the parser is &#x201C;any string
produced by [method@GLib.Variant.print]&#x201D;. This explicitly includes
`g_variant_print()`&#x2019;s annotated types like `int64 -1000`.

There may be implementation specific restrictions on deeply nested values,
which would result in a %G_VARIANT_PARSE_ERROR_RECURSION error. #GVariant is
guaranteed to handle nesting up to at least 64 levels.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a non-floating reference to a #GVariant, or %NULL</doc>
        <type name="Variant" c:type="GVariant*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GVariantType, or %NULL</doc>
          <type name="VariantType" c:type="const GVariantType*"/>
        </parameter>
        <parameter name="text" transfer-ownership="none">
          <doc xml:space="preserve">a string containing a GVariant in text form</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="limit" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a pointer to the end of @text, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="endptr" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a location to store the end pointer, or %NULL</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="variant_parse_error_print_context" c:identifier="g_variant_parse_error_print_context" moved-to="Variant.parse_error_print_context" version="2.40">
      <doc xml:space="preserve">Pretty-prints a message showing the context of a #GVariant parse
error within the string for which parsing was attempted.

The resulting string is suitable for output to the console or other
monospace media where newlines are treated in the usual way.

The message will typically look something like one of the following:

|[
unterminated string constant:
  (1, 2, 3, 'abc
            ^^^^
]|

or

|[
unable to find a common type:
  [1, 2, 3, 'str']
   ^        ^^^^^
]|

The format of the message may change in a future version.

@error must have come from a failed attempt to g_variant_parse() and
@source_str must be exactly the same string that caused the error.
If @source_str was not nul-terminated when you passed it to
g_variant_parse() then you must add nul termination before using this
function.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the printed message</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">a #GError from the #GVariantParseError domain</doc>
          <type name="Error" c:type="GError*"/>
        </parameter>
        <parameter name="source_str" transfer-ownership="none">
          <doc xml:space="preserve">the string that was given to the parser</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="variant_parse_error_quark" c:identifier="g_variant_parse_error_quark" moved-to="Variant.parse_error_quark">
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="variant_parser_get_error_quark" c:identifier="g_variant_parser_get_error_quark" moved-to="Variant.parser_get_error_quark" deprecated="1">
      <doc xml:space="preserve">Same as g_variant_error_quark().</doc>
      <doc-deprecated xml:space="preserve">Use g_variant_parse_error_quark() instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="variant_type_checked_" c:identifier="g_variant_type_checked_" moved-to="VariantType.checked_">
      <return-value transfer-ownership="none">
        <type name="VariantType" c:type="const GVariantType*"/>
      </return-value>
      <parameters>
        <parameter name="type_string" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="variant_type_string_get_depth_" c:identifier="g_variant_type_string_get_depth_" moved-to="VariantType.string_get_depth_">
      <return-value transfer-ownership="none">
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="type_string" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="variant_type_string_is_valid" c:identifier="g_variant_type_string_is_valid" moved-to="VariantType.string_is_valid">
      <doc xml:space="preserve">Checks if @type_string is a valid
[GVariant type string](./struct.VariantType.html#gvariant-type-strings).

This call is equivalent to calling [func@GLib.VariantType.string_scan] and
confirming that the following character is a nul terminator.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if @type_string is exactly one valid type string
Since 2.24</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type_string" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to any string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="variant_type_string_scan" c:identifier="g_variant_type_string_scan" moved-to="VariantType.string_scan" version="2.24">
      <doc xml:space="preserve">Scan for a single complete and valid GVariant type string in @string.

The memory pointed to by @limit (or bytes beyond it) is never
accessed.

If a valid type string is found, @endptr is updated to point to the
first character past the end of the string that was found and %TRUE
is returned.

If there is no valid type string starting at @string, or if the type
string does not end before @limit then %FALSE is returned.

For the simple case of checking if a string is a valid type string,
see [func@GLib.VariantType.string_is_valid].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">true if a valid type string was found</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to any string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="limit" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the end of @string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="endptr" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store the end pointer</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="vasprintf" c:identifier="g_vasprintf" version="2.4" introspectable="0">
      <doc xml:space="preserve">An implementation of the GNU `vasprintf()` function which supports
positional parameters, as specified in the Single Unix Specification.
This function is similar to [func@GLib.vsprintf], except that it allocates a
string to hold the output, instead of putting the output in a buffer
you allocate in advance.

The returned value in @string is guaranteed to be non-`NULL`, unless
@format contains `%lc` or `%ls` conversions, which can fail if no
multibyte representation is available for the given character.

`glib/gprintf.h` must be explicitly included in order to use this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes printed, or -1 on failure</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="string" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the return location for the
  newly-allocated string, which will be `NULL` if (and only if)
  this function fails</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a standard `printf()` format string, but notice
  [string precision pitfalls](string-utils.html#string-precision-pitfalls)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">the list of arguments to insert in the output</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="vfprintf" c:identifier="g_vfprintf" version="2.2" introspectable="0">
      <doc xml:space="preserve">An implementation of the standard `fprintf()` function which supports
positional parameters, as specified in the Single Unix Specification.

`glib/gprintf.h` must be explicitly included in order to use this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes printed</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="file" transfer-ownership="none">
          <doc xml:space="preserve">the stream to write to</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a standard `printf()` format string, but notice
  [string precision pitfalls](string-utils.html#string-precision-pitfalls)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">the list of arguments to insert in the output</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="vprintf" c:identifier="g_vprintf" version="2.2" introspectable="0">
      <doc xml:space="preserve">An implementation of the standard `vprintf()` function which supports
positional parameters, as specified in the Single Unix Specification.

`glib/gprintf.h` must be explicitly included in order to use this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes printed</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a standard `printf()` format string, but notice
  [string precision pitfalls](string-utils.html#string-precision-pitfalls)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">the list of arguments to insert in the output</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="vsnprintf" c:identifier="g_vsnprintf" introspectable="0">
      <doc xml:space="preserve">A safer form of the standard `vsprintf()` function. The output is guaranteed
to not exceed @n characters (including the terminating nul character), so
it is easy to ensure that a buffer overflow cannot occur.

See also [func@GLib.strdup_vprintf].

In versions of GLib prior to 1.2.3, this function may return -1 if the
output was truncated, and the truncated string may not be nul-terminated.
In versions prior to 1.3.12, this function returns the length of the output
string.

The return value of `g_vsnprintf()` conforms to the `vsnprintf()` function
as standardized in ISO C99. Note that this is different from traditional
`vsnprintf()`, which returns the length of the output string.

The format string may contain positional parameters, as specified in
the Single Unix Specification.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes which would be produced if the buffer
 was large enough</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the buffer to hold the output</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of bytes to produce (including the
  terminating nul character)</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a standard `printf()` format string, but notice
  [string precision pitfalls](string-utils.html#string-precision-pitfalls)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">the list of arguments to insert in the output</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="vsprintf" c:identifier="g_vsprintf" version="2.2" introspectable="0">
      <doc xml:space="preserve">An implementation of the standard `vsprintf()` function which supports
positional parameters, as specified in the Single Unix Specification.

`glib/gprintf.h` must be explicitly included in order to use this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes printed</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the buffer to hold the output</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a standard `printf()` format string, but notice
  [string precision pitfalls](string-utils.html#string-precision-pitfalls)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">the list of arguments to insert in the output</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="warn_if_fail" c:identifier="g_warn_if_fail" version="2.16" introspectable="0">
      <doc xml:space="preserve">Logs a warning if the expression is not true.

Unlike g_return_if_fail(), the expression is always evaluated, even if
checks and assertions are disabled.</doc>
      <parameters>
        <parameter name="expr">
          <doc xml:space="preserve">the expression to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="warn_if_reached" c:identifier="g_warn_if_reached" version="2.16" introspectable="0">
      <doc xml:space="preserve">Logs a warning.</doc>
    </function-macro>
    <function name="warn_message" c:identifier="g_warn_message" introspectable="0">
      <doc xml:space="preserve">Internal function used to print messages from the public [func@GLib.warn_if_reached]
and [func@GLib.warn_if_fail] macros.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">log domain</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <doc xml:space="preserve">file containing the warning</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <doc xml:space="preserve">line number of the warning</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:space="preserve">function containing the warning</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="warnexpr" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">expression which failed</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="warning" c:identifier="g_warning" introspectable="0">
      <doc xml:space="preserve">A convenience function/macro to log a warning message.

The message should typically *not* be translated to the user&#x2019;s language.

This is not intended for end user error reporting. Use of [type@GLib.Error] is
preferred for that instead, as it allows calling functions to perform actions
conditional on the type of error.

Warning messages are intended to be used in the event of unexpected
external conditions (system misconfiguration, missing files,
other trusted programs violating protocol, invalid contents in
trusted files, etc.)

If attempting to deal with programmer errors (for example, incorrect function
parameters) then you should use [flags@GLib.LogLevelFlags.LEVEL_CRITICAL] instead.

[func@GLib.warn_if_reached] and func@GLib.warn_if_fail] log at [flags@GLib.LogLevelFlags.LEVEL_WARNING].

You can make warnings fatal at runtime by setting the `G_DEBUG`
environment variable (see
[Running GLib Applications](running.html)):

```
G_DEBUG=fatal-warnings gdb ./my-program
```

Any unrelated failures can be skipped over in
[gdb](https://www.gnu.org/software/gdb/) using the `continue` command.

If [func@GLib.log_default_handler] is used as the log handler function,
a newline character will automatically be appended to @..., and
need not be entered manually.

If structured logging is enabled, this will use [func@GLib.log_structured];
otherwise it will use [func@GLib.log]. See
[Using Structured Logging](logging.html#using-structured-logging).</doc>
      <parameters>
        <parameter name="...">
          <doc xml:space="preserve">format string, followed by parameters to insert into the format string
  (as with `printf()`)</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="warning_once" c:identifier="g_warning_once" version="2.64" introspectable="0">
      <doc xml:space="preserve">Logs a warning only once.

g_warning_once() calls g_warning() with the passed message the first time
the statement is executed; subsequent times it is a no-op.

Note! On platforms where the compiler doesn't support variadic macros, the
warning is printed each time instead of only once.</doc>
      <parameters>
        <parameter name="...">
          <doc xml:space="preserve">format string, followed by parameters to insert
    into the format string (as with printf())</doc>
        </parameter>
      </parameters>
    </function-macro>
  </namespace>
</repository>
