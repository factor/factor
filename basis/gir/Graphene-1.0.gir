<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="GObject" version="2.0"/>
  <package name="graphene-gobject-1.0"/>
  <c:include name="graphene-gobject.h"/>
  <namespace name="Graphene" version="1.0" shared-library="libgraphene-1.0.so.0" c:identifier-prefixes="Graphene" c:symbol-prefixes="graphene">
    <function-macro name="ALIGNED_DECL" c:identifier="GRAPHENE_ALIGNED_DECL" introspectable="0">
      <parameters>
        <parameter name="x">
        </parameter>
        <parameter name="val">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Box" c:type="graphene_box_t" version="1.2" glib:type-name="GrapheneBox" glib:get-type="graphene_box_get_type" c:symbol-prefix="box">
      <doc xml:space="preserve">A 3D box, described as the volume between a minimum and
a maximum vertices.</doc>
      <field name="min" readable="0" private="1">
        <type name="Vec3" c:type="graphene_vec3_t"/>
      </field>
      <field name="max" readable="0" private="1">
        <type name="Vec3" c:type="graphene_vec3_t"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_box_alloc" version="1.2">
        <doc xml:space="preserve">Allocates a new #graphene_box_t.

The contents of the returned structure are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_box_t structure.
  Use graphene_box_free() to free the resources allocated by this function</doc>
          <type name="Box" c:type="graphene_box_t*"/>
        </return-value>
      </constructor>
      <method name="contains_box" c:identifier="graphene_box_contains_box" version="1.2">
        <doc xml:space="preserve">Checks whether the #graphene_box_t @a contains the given
#graphene_box_t @b.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the box is contained in the given box</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains_point" c:identifier="graphene_box_contains_point" version="1.2">
        <doc xml:space="preserve">Checks whether @box contains the given @point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the point is contained in the given box</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates to check</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_box_equal" version="1.2">
        <doc xml:space="preserve">Checks whether the two given boxes are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the boxes are equal</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="expand" c:identifier="graphene_box_expand" version="1.2">
        <doc xml:space="preserve">Expands the dimensions of @box to include the coordinates at @point.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates of the point to include</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the expanded box</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="expand_scalar" c:identifier="graphene_box_expand_scalar" version="1.2">
        <doc xml:space="preserve">Expands the dimensions of @box by the given @scalar value.

If @scalar is positive, the #graphene_box_t will grow; if @scalar is
negative, the #graphene_box_t will shrink.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="scalar" transfer-ownership="none">
            <doc xml:space="preserve">a scalar value</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the expanded box</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="expand_vec3" c:identifier="graphene_box_expand_vec3" version="1.2">
        <doc xml:space="preserve">Expands the dimensions of @box to include the coordinates of the
given vector.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="vec" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates of the point to include, as a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the expanded box</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_box_free" version="1.2">
        <doc xml:space="preserve">Frees the resources allocated by graphene_box_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bounding_sphere" c:identifier="graphene_box_get_bounding_sphere" version="1.2">
        <doc xml:space="preserve">Computes the bounding #graphene_sphere_t capable of containing the given
#graphene_box_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="sphere" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the bounding sphere</doc>
            <type name="Sphere" c:type="graphene_sphere_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_center" c:identifier="graphene_box_get_center" version="1.2">
        <doc xml:space="preserve">Retrieves the coordinates of the center of a #graphene_box_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="center" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the coordinates of
  the center</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_depth" c:identifier="graphene_box_get_depth" version="1.2">
        <doc xml:space="preserve">Retrieves the size of the @box on the Z axis.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the depth of the box</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="graphene_box_get_height" version="1.2">
        <doc xml:space="preserve">Retrieves the size of the @box on the Y axis.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the height of the box</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max" c:identifier="graphene_box_get_max" version="1.2">
        <doc xml:space="preserve">Retrieves the coordinates of the maximum point of the given
#graphene_box_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="max" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the maximum point</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_min" c:identifier="graphene_box_get_min" version="1.2">
        <doc xml:space="preserve">Retrieves the coordinates of the minimum point of the given
#graphene_box_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="min" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the minimum point</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="graphene_box_get_size" version="1.2">
        <doc xml:space="preserve">Retrieves the size of the box on all three axes, and stores
it into the given @size vector.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="size" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the size</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_vertices" c:identifier="graphene_box_get_vertices" version="1.2">
        <doc xml:space="preserve">Computes the vertices of the given #graphene_box_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="vertices" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for an array
  of 8 #graphene_vec3_t</doc>
            <array zero-terminated="0" c:type="graphene_vec3_t*" fixed-size="8">
              <type name="Vec3" c:type="graphene_vec3_t"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="graphene_box_get_width" version="1.2">
        <doc xml:space="preserve">Retrieves the size of the @box on the X axis.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the width of the box</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_box_init" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_box_t with two vertices.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_box_t</doc>
          <type name="Box" c:type="graphene_box_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_box_t to initialize</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </instance-parameter>
          <parameter name="min" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the coordinates of the minimum vertex</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="max" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the coordinates of the maximum vertex</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_box" c:identifier="graphene_box_init_from_box" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_box_t with the vertices of
another #graphene_box_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_box_t</doc>
          <type name="Box" c:type="graphene_box_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_box_t to initialize</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_points" c:identifier="graphene_box_init_from_points" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_box_t with the given array
of vertices.

If @n_points is 0, the returned box is initialized with
graphene_box_empty().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_box_t</doc>
          <type name="Box" c:type="graphene_box_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_box_t to initialize</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </instance-parameter>
          <parameter name="n_points" transfer-ownership="none">
            <doc xml:space="preserve">the number #graphene_point3d_t in the @points array</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="points" transfer-ownership="none">
            <doc xml:space="preserve">an array of #graphene_point3d_t</doc>
            <array length="0" zero-terminated="0" c:type="const graphene_point3d_t*">
              <type name="Point3D" c:type="graphene_point3d_t"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec3" c:identifier="graphene_box_init_from_vec3" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_box_t with two vertices
stored inside #graphene_vec3_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_box_t</doc>
          <type name="Box" c:type="graphene_box_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_box_t to initialize</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </instance-parameter>
          <parameter name="min" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the coordinates of the minimum vertex</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="max" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the coordinates of the maximum vertex</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vectors" c:identifier="graphene_box_init_from_vectors" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_box_t with the given array
of vertices.

If @n_vectors is 0, the returned box is initialized with
graphene_box_empty().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_box_t</doc>
          <type name="Box" c:type="graphene_box_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_box_t to initialize</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </instance-parameter>
          <parameter name="n_vectors" transfer-ownership="none">
            <doc xml:space="preserve">the number #graphene_point3d_t in the @vectors array</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="vectors" transfer-ownership="none">
            <doc xml:space="preserve">an array of #graphene_vec3_t</doc>
            <array length="0" zero-terminated="0" c:type="const graphene_vec3_t*">
              <type name="Vec3" c:type="graphene_vec3_t"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="intersection" c:identifier="graphene_box_intersection" version="1.2">
        <doc xml:space="preserve">Intersects the two given #graphene_box_t.

If the two boxes do not intersect, @res will contain a degenerate box
initialized with graphene_box_empty().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">true if the two boxes intersect</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the result</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="union" c:identifier="graphene_box_union" version="1.2">
        <doc xml:space="preserve">Unions the two given #graphene_box_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">the box to union to @a</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <function name="empty" c:identifier="graphene_box_empty" version="1.2">
        <doc xml:space="preserve">A degenerate #graphene_box_t that can only be expanded.

The returned value is owned by Graphene and should not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #graphene_box_t</doc>
          <type name="Box" c:type="const graphene_box_t*"/>
        </return-value>
      </function>
      <function name="infinite" c:identifier="graphene_box_infinite" version="1.2">
        <doc xml:space="preserve">A degenerate #graphene_box_t that cannot be expanded.

The returned value is owned by Graphene and should not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #graphene_box_t</doc>
          <type name="Box" c:type="const graphene_box_t*"/>
        </return-value>
      </function>
      <function name="minus_one" c:identifier="graphene_box_minus_one" version="1.2">
        <doc xml:space="preserve">A #graphene_box_t with the minimum vertex set at (-1, -1, -1) and the
maximum vertex set at (0, 0, 0).

The returned value is owned by Graphene and should not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #graphene_box_t</doc>
          <type name="Box" c:type="const graphene_box_t*"/>
        </return-value>
      </function>
      <function name="one" c:identifier="graphene_box_one" version="1.2">
        <doc xml:space="preserve">A #graphene_box_t with the minimum vertex set at (0, 0, 0) and the
maximum vertex set at (1, 1, 1).

The returned value is owned by Graphene and should not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #graphene_box_t</doc>
          <type name="Box" c:type="const graphene_box_t*"/>
        </return-value>
      </function>
      <function name="one_minus_one" c:identifier="graphene_box_one_minus_one" version="1.2">
        <doc xml:space="preserve">A #graphene_box_t with the minimum vertex set at (-1, -1, -1) and the
maximum vertex set at (1, 1, 1).

The returned value is owned by Graphene and should not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #graphene_box_t</doc>
          <type name="Box" c:type="const graphene_box_t*"/>
        </return-value>
      </function>
      <function name="zero" c:identifier="graphene_box_zero" version="1.2">
        <doc xml:space="preserve">A #graphene_box_t with both the minimum and maximum vertices set at (0, 0, 0).

The returned value is owned by Graphene and should not be modified or freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #graphene_box_t</doc>
          <type name="Box" c:type="const graphene_box_t*"/>
        </return-value>
      </function>
    </record>
    <function-macro name="CHECK_VERSION" c:identifier="GRAPHENE_CHECK_VERSION" introspectable="0">
      <parameters>
        <parameter name="major">
        </parameter>
        <parameter name="minor">
        </parameter>
        <parameter name="micro">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_FOR" c:identifier="GRAPHENE_DEPRECATED_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_0_FOR" c:identifier="GRAPHENE_DEPRECATED_IN_1_0_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_10_FOR" c:identifier="GRAPHENE_DEPRECATED_IN_1_10_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_2_FOR" c:identifier="GRAPHENE_DEPRECATED_IN_1_2_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_4_FOR" c:identifier="GRAPHENE_DEPRECATED_IN_1_4_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_6_FOR" c:identifier="GRAPHENE_DEPRECATED_IN_1_6_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_8_FOR" c:identifier="GRAPHENE_DEPRECATED_IN_1_8_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ENCODE_VERSION" c:identifier="GRAPHENE_ENCODE_VERSION" version="1.0" introspectable="0">
      <doc xml:space="preserve">Encodes the given components into a value that can be used for
version checks.</doc>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve">a major version</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve">a minor version</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve">a micro version</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="Euler" c:type="graphene_euler_t" version="1.2" glib:type-name="GrapheneEuler" glib:get-type="graphene_euler_get_type" c:symbol-prefix="euler">
      <doc xml:space="preserve">Describe a rotation using Euler angles.

The contents of the #graphene_euler_t structure are private
and should never be accessed directly.</doc>
      <field name="angles" readable="0" private="1">
        <type name="Vec3" c:type="graphene_vec3_t"/>
      </field>
      <field name="order" readable="0" private="1">
        <type name="EulerOrder" c:type="graphene_euler_order_t"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_euler_alloc" version="1.2">
        <doc xml:space="preserve">Allocates a new #graphene_euler_t.

The contents of the returned structure are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_euler_t</doc>
          <type name="Euler" c:type="graphene_euler_t*"/>
        </return-value>
      </constructor>
      <method name="equal" c:identifier="graphene_euler_equal" version="1.2">
        <doc xml:space="preserve">Checks if two #graphene_euler_t are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the two #graphene_euler_t are equal</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_euler_free" version="1.2">
        <doc xml:space="preserve">Frees the resources allocated by graphene_euler_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="graphene_euler_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha" c:identifier="graphene_euler_get_alpha" version="1.10">
        <doc xml:space="preserve">Retrieves the first component of the Euler angle vector,
depending on the order of rotation.

See also: graphene_euler_get_x()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the first component of the Euler angle vector, in radians</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_beta" c:identifier="graphene_euler_get_beta" version="1.10">
        <doc xml:space="preserve">Retrieves the second component of the Euler angle vector,
depending on the order of rotation.

See also: graphene_euler_get_y()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the second component of the Euler angle vector, in radians</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gamma" c:identifier="graphene_euler_get_gamma" version="1.10">
        <doc xml:space="preserve">Retrieves the third component of the Euler angle vector,
depending on the order of rotation.

See also: graphene_euler_get_z()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the third component of the Euler angle vector, in radians</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_order" c:identifier="graphene_euler_get_order" version="1.2">
        <doc xml:space="preserve">Retrieves the order used to apply the rotations described in the
#graphene_euler_t structure, when converting to and from other
structures, like #graphene_quaternion_t and #graphene_matrix_t.

This function does not return the %GRAPHENE_EULER_ORDER_DEFAULT
enumeration value; it will return the effective order of rotation
instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the order used to apply the rotations</doc>
          <type name="EulerOrder" c:type="graphene_euler_order_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_x" c:identifier="graphene_euler_get_x" version="1.2">
        <doc xml:space="preserve">Retrieves the rotation angle on the X axis, in degrees.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the rotation angle</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_y" c:identifier="graphene_euler_get_y" version="1.2">
        <doc xml:space="preserve">Retrieves the rotation angle on the Y axis, in degrees.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the rotation angle</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_z" c:identifier="graphene_euler_get_z" version="1.2">
        <doc xml:space="preserve">Retrieves the rotation angle on the Z axis, in degrees.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the rotation angle</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_euler_init" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_euler_t using the given angles.

The order of the rotations is %GRAPHENE_EULER_ORDER_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_euler_t</doc>
          <type name="Euler" c:type="graphene_euler_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_euler_t to initialize</doc>
            <type name="Euler" c:type="graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the X axis, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the Y axis, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the Z axis, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_euler" c:identifier="graphene_euler_init_from_euler" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_euler_t using the angles and order of
another #graphene_euler_t.

If the #graphene_euler_t @src is %NULL, this function is equivalent
to calling graphene_euler_init() with all angles set to 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_euler_t</doc>
          <type name="Euler" c:type="graphene_euler_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_euler_t to initialize</doc>
            <type name="Euler" c:type="graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_matrix" c:identifier="graphene_euler_init_from_matrix" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_euler_t using the given rotation matrix.

If the #graphene_matrix_t @m is %NULL, the #graphene_euler_t will
be initialized with all angles set to 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_euler_t</doc>
          <type name="Euler" c:type="graphene_euler_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_euler_t to initialize</doc>
            <type name="Euler" c:type="graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="m" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a rotation matrix</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
          <parameter name="order" transfer-ownership="none">
            <doc xml:space="preserve">the order used to apply the rotations</doc>
            <type name="EulerOrder" c:type="graphene_euler_order_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_quaternion" c:identifier="graphene_euler_init_from_quaternion" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_euler_t using the given normalized quaternion.

If the #graphene_quaternion_t @q is %NULL, the #graphene_euler_t will
be initialized with all angles set to 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_euler_t</doc>
          <type name="Euler" c:type="graphene_euler_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="q" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a normalized #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </parameter>
          <parameter name="order" transfer-ownership="none">
            <doc xml:space="preserve">the order used to apply the rotations</doc>
            <type name="EulerOrder" c:type="graphene_euler_order_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_radians" c:identifier="graphene_euler_init_from_radians" version="1.10">
        <doc xml:space="preserve">Initializes a #graphene_euler_t using the given angles
and order of rotation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_euler_t</doc>
          <type name="Euler" c:type="graphene_euler_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_euler_t to initialize</doc>
            <type name="Euler" c:type="graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the X axis, in radians</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the Y axis, in radians</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the Z axis, in radians</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="order" transfer-ownership="none">
            <doc xml:space="preserve">order of rotations</doc>
            <type name="EulerOrder" c:type="graphene_euler_order_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec3" c:identifier="graphene_euler_init_from_vec3" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_euler_t using the angles contained in a
#graphene_vec3_t.

If the #graphene_vec3_t @v is %NULL, the #graphene_euler_t will be
initialized with all angles set to 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_euler_t</doc>
          <type name="Euler" c:type="graphene_euler_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_euler_t to initialize</doc>
            <type name="Euler" c:type="graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="v" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_vec3_t containing the rotation
  angles in degrees</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="order" transfer-ownership="none">
            <doc xml:space="preserve">the order used to apply the rotations</doc>
            <type name="EulerOrder" c:type="graphene_euler_order_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_with_order" c:identifier="graphene_euler_init_with_order" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_euler_t with the given angles and @order.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_euler_t</doc>
          <type name="Euler" c:type="graphene_euler_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_euler_t to initialize</doc>
            <type name="Euler" c:type="graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the X axis, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the Y axis, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the Z axis, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="order" transfer-ownership="none">
            <doc xml:space="preserve">the order used to apply the rotations</doc>
            <type name="EulerOrder" c:type="graphene_euler_order_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="reorder" c:identifier="graphene_euler_reorder" version="1.2">
        <doc xml:space="preserve">Reorders a #graphene_euler_t using @order.

This function is equivalent to creating a #graphene_quaternion_t from the
given #graphene_euler_t, and then converting the quaternion into another
#graphene_euler_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="order" transfer-ownership="none">
            <doc xml:space="preserve">the new order</doc>
            <type name="EulerOrder" c:type="graphene_euler_order_t"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the reordered
  #graphene_euler_t</doc>
            <type name="Euler" c:type="graphene_euler_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_matrix" c:identifier="graphene_euler_to_matrix" version="1.2">
        <doc xml:space="preserve">Converts a #graphene_euler_t into a transformation matrix expressing
the extrinsic composition of rotations described by the Euler angles.

The rotations are applied over the reference frame axes in the order
associated with the #graphene_euler_t; for instance, if the order
used to initialize @e is %GRAPHENE_EULER_ORDER_XYZ:

 * the first rotation moves the body around the X axis with
   an angle &#x3C6;
 * the second rotation moves the body around the Y axis with
   an angle of &#x3D1;
 * the third rotation moves the body around the Z axis with
   an angle of &#x3C8;

The rotation sign convention is right-handed, to preserve compatibility
between Euler-based, quaternion-based, and angle-axis-based rotations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_quaternion" c:identifier="graphene_euler_to_quaternion" version="1.10">
        <doc xml:space="preserve">Converts a #graphene_euler_t into a #graphene_quaternion_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_vec3" c:identifier="graphene_euler_to_vec3" version="1.2">
        <doc xml:space="preserve">Retrieves the angles of a #graphene_euler_t and initializes a
#graphene_vec3_t with them.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="EulerOrder" version="1.2" c:type="graphene_euler_order_t">
      <doc xml:space="preserve">Specify the order of the rotations on each axis.

The %GRAPHENE_EULER_ORDER_DEFAULT value is special, and is used
as an alias for one of the other orders.</doc>
      <member name="default" value="-1" c:identifier="GRAPHENE_EULER_ORDER_DEFAULT">
        <doc xml:space="preserve">Rotate in the default order; the
  default order is one of the following enumeration values</doc>
      </member>
      <member name="xyz" value="0" c:identifier="GRAPHENE_EULER_ORDER_XYZ">
        <doc xml:space="preserve">Rotate in the X, Y, and Z order. Deprecated in
  Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SXYZ</doc>
      </member>
      <member name="yzx" value="1" c:identifier="GRAPHENE_EULER_ORDER_YZX">
        <doc xml:space="preserve">Rotate in the Y, Z, and X order. Deprecated in
  Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SYZX</doc>
      </member>
      <member name="zxy" value="2" c:identifier="GRAPHENE_EULER_ORDER_ZXY">
        <doc xml:space="preserve">Rotate in the Z, X, and Y order. Deprecated in
  Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SZXY</doc>
      </member>
      <member name="xzy" value="3" c:identifier="GRAPHENE_EULER_ORDER_XZY">
        <doc xml:space="preserve">Rotate in the X, Z, and Y order. Deprecated in
  Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SXZY</doc>
      </member>
      <member name="yxz" value="4" c:identifier="GRAPHENE_EULER_ORDER_YXZ">
        <doc xml:space="preserve">Rotate in the Y, X, and Z order. Deprecated in
  Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SYXZ</doc>
      </member>
      <member name="zyx" value="5" c:identifier="GRAPHENE_EULER_ORDER_ZYX">
        <doc xml:space="preserve">Rotate in the Z, Y, and X order. Deprecated in
  Graphene 1.10, it's an alias for %GRAPHENE_EULER_ORDER_SZYX</doc>
      </member>
      <member name="sxyz" value="6" c:identifier="GRAPHENE_EULER_ORDER_SXYZ">
        <doc xml:space="preserve">Defines a static rotation along the X, Y, and Z axes (Since: 1.10)</doc>
      </member>
      <member name="sxyx" value="7" c:identifier="GRAPHENE_EULER_ORDER_SXYX">
        <doc xml:space="preserve">Defines a static rotation along the X, Y, and X axes (Since: 1.10)</doc>
      </member>
      <member name="sxzy" value="8" c:identifier="GRAPHENE_EULER_ORDER_SXZY">
        <doc xml:space="preserve">Defines a static rotation along the X, Z, and Y axes (Since: 1.10)</doc>
      </member>
      <member name="sxzx" value="9" c:identifier="GRAPHENE_EULER_ORDER_SXZX">
        <doc xml:space="preserve">Defines a static rotation along the X, Z, and X axes (Since: 1.10)</doc>
      </member>
      <member name="syzx" value="10" c:identifier="GRAPHENE_EULER_ORDER_SYZX">
        <doc xml:space="preserve">Defines a static rotation along the Y, Z, and X axes (Since: 1.10)</doc>
      </member>
      <member name="syzy" value="11" c:identifier="GRAPHENE_EULER_ORDER_SYZY">
        <doc xml:space="preserve">Defines a static rotation along the Y, Z, and Y axes (Since: 1.10)</doc>
      </member>
      <member name="syxz" value="12" c:identifier="GRAPHENE_EULER_ORDER_SYXZ">
        <doc xml:space="preserve">Defines a static rotation along the Y, X, and Z axes (Since: 1.10)</doc>
      </member>
      <member name="syxy" value="13" c:identifier="GRAPHENE_EULER_ORDER_SYXY">
        <doc xml:space="preserve">Defines a static rotation along the Y, X, and Y axes (Since: 1.10)</doc>
      </member>
      <member name="szxy" value="14" c:identifier="GRAPHENE_EULER_ORDER_SZXY">
        <doc xml:space="preserve">Defines a static rotation along the Z, X, and Y axes (Since: 1.10)</doc>
      </member>
      <member name="szxz" value="15" c:identifier="GRAPHENE_EULER_ORDER_SZXZ">
        <doc xml:space="preserve">Defines a static rotation along the Z, X, and Z axes (Since: 1.10)</doc>
      </member>
      <member name="szyx" value="16" c:identifier="GRAPHENE_EULER_ORDER_SZYX">
        <doc xml:space="preserve">Defines a static rotation along the Z, Y, and X axes (Since: 1.10)</doc>
      </member>
      <member name="szyz" value="17" c:identifier="GRAPHENE_EULER_ORDER_SZYZ">
        <doc xml:space="preserve">Defines a static rotation along the Z, Y, and Z axes (Since: 1.10)</doc>
      </member>
      <member name="rzyx" value="18" c:identifier="GRAPHENE_EULER_ORDER_RZYX">
        <doc xml:space="preserve">Defines a relative rotation along the Z, Y, and X axes (Since: 1.10)</doc>
      </member>
      <member name="rxyx" value="19" c:identifier="GRAPHENE_EULER_ORDER_RXYX">
        <doc xml:space="preserve">Defines a relative rotation along the X, Y, and X axes (Since: 1.10)</doc>
      </member>
      <member name="ryzx" value="20" c:identifier="GRAPHENE_EULER_ORDER_RYZX">
        <doc xml:space="preserve">Defines a relative rotation along the Y, Z, and X axes (Since: 1.10)</doc>
      </member>
      <member name="rxzx" value="21" c:identifier="GRAPHENE_EULER_ORDER_RXZX">
        <doc xml:space="preserve">Defines a relative rotation along the X, Z, and X axes (Since: 1.10)</doc>
      </member>
      <member name="rxzy" value="22" c:identifier="GRAPHENE_EULER_ORDER_RXZY">
        <doc xml:space="preserve">Defines a relative rotation along the X, Z, and Y axes (Since: 1.10)</doc>
      </member>
      <member name="ryzy" value="23" c:identifier="GRAPHENE_EULER_ORDER_RYZY">
        <doc xml:space="preserve">Defines a relative rotation along the Y, Z, and Y axes (Since: 1.10)</doc>
      </member>
      <member name="rzxy" value="24" c:identifier="GRAPHENE_EULER_ORDER_RZXY">
        <doc xml:space="preserve">Defines a relative rotation along the Z, X, and Y axes (Since: 1.10)</doc>
      </member>
      <member name="ryxy" value="25" c:identifier="GRAPHENE_EULER_ORDER_RYXY">
        <doc xml:space="preserve">Defines a relative rotation along the Y, X, and Y axes (Since: 1.10)</doc>
      </member>
      <member name="ryxz" value="26" c:identifier="GRAPHENE_EULER_ORDER_RYXZ">
        <doc xml:space="preserve">Defines a relative rotation along the Y, X, and Z axes (Since: 1.10)</doc>
      </member>
      <member name="rzxz" value="27" c:identifier="GRAPHENE_EULER_ORDER_RZXZ">
        <doc xml:space="preserve">Defines a relative rotation along the Z, X, and Z axes (Since: 1.10)</doc>
      </member>
      <member name="rxyz" value="28" c:identifier="GRAPHENE_EULER_ORDER_RXYZ">
        <doc xml:space="preserve">Defines a relative rotation along the X, Y, and Z axes (Since: 1.10)</doc>
      </member>
      <member name="rzyz" value="29" c:identifier="GRAPHENE_EULER_ORDER_RZYZ">
        <doc xml:space="preserve">Defines a relative rotation along the Z, Y, and Z axes (Since: 1.10)</doc>
      </member>
    </enumeration>
    <record name="Frustum" c:type="graphene_frustum_t" version="1.2" glib:type-name="GrapheneFrustum" glib:get-type="graphene_frustum_get_type" c:symbol-prefix="frustum">
      <doc xml:space="preserve">A 3D volume delimited by 2D clip planes.

The contents of the `graphene_frustum_t` are private, and should not be
modified directly.</doc>
      <field name="planes" readable="0" private="1">
        <array zero-terminated="0" fixed-size="6">
          <type name="Plane" c:type="graphene_plane_t"/>
        </array>
      </field>
      <constructor name="alloc" c:identifier="graphene_frustum_alloc" version="1.2">
        <doc xml:space="preserve">Allocates a new #graphene_frustum_t structure.

The contents of the returned structure are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_frustum_t
  structure. Use graphene_frustum_free() to free the resources
  allocated by this function.</doc>
          <type name="Frustum" c:type="graphene_frustum_t*"/>
        </return-value>
      </constructor>
      <method name="contains_point" c:identifier="graphene_frustum_contains_point" version="1.2">
        <doc xml:space="preserve">Checks whether a point is inside the volume defined by the given
#graphene_frustum_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the point is inside the frustum</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="f" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_frustum_t</doc>
            <type name="Frustum" c:type="const graphene_frustum_t*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_frustum_equal" version="1.6">
        <doc xml:space="preserve">Checks whether the two given #graphene_frustum_t are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the given frustums are equal</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_frustum_t</doc>
            <type name="Frustum" c:type="const graphene_frustum_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_frustum_t</doc>
            <type name="Frustum" c:type="const graphene_frustum_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_frustum_free" version="1.2">
        <doc xml:space="preserve">Frees the resources allocated by graphene_frustum_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="f" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_frustum_t</doc>
            <type name="Frustum" c:type="graphene_frustum_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_planes" c:identifier="graphene_frustum_get_planes" version="1.2">
        <doc xml:space="preserve">Retrieves the planes that define the given #graphene_frustum_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="f" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_frustum_t</doc>
            <type name="Frustum" c:type="const graphene_frustum_t*"/>
          </instance-parameter>
          <parameter name="planes" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for an array
  of 6 #graphene_plane_t</doc>
            <array zero-terminated="0" c:type="graphene_plane_t*" fixed-size="6">
              <type name="Plane" c:type="graphene_plane_t"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_frustum_init" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_frustum_t using the provided
clipping planes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized frustum</doc>
          <type name="Frustum" c:type="graphene_frustum_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="f" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_frustum_t to initialize</doc>
            <type name="Frustum" c:type="graphene_frustum_t*"/>
          </instance-parameter>
          <parameter name="p0" transfer-ownership="none">
            <doc xml:space="preserve">a clipping plane</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:space="preserve">a clipping plane</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <doc xml:space="preserve">a clipping plane</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </parameter>
          <parameter name="p3" transfer-ownership="none">
            <doc xml:space="preserve">a clipping plane</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </parameter>
          <parameter name="p4" transfer-ownership="none">
            <doc xml:space="preserve">a clipping plane</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </parameter>
          <parameter name="p5" transfer-ownership="none">
            <doc xml:space="preserve">a clipping plane</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_frustum" c:identifier="graphene_frustum_init_from_frustum" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_frustum_t using the clipping
planes of another #graphene_frustum_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized frustum</doc>
          <type name="Frustum" c:type="graphene_frustum_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="f" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_frustum_t to initialize</doc>
            <type name="Frustum" c:type="graphene_frustum_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_frustum_t</doc>
            <type name="Frustum" c:type="const graphene_frustum_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_matrix" c:identifier="graphene_frustum_init_from_matrix" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_frustum_t using the given @matrix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized frustum</doc>
          <type name="Frustum" c:type="graphene_frustum_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="f" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_frustum_t</doc>
            <type name="Frustum" c:type="graphene_frustum_t*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersects_box" c:identifier="graphene_frustum_intersects_box" version="1.2">
        <doc xml:space="preserve">Checks whether the given @box intersects a plane of
a #graphene_frustum_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the box intersects the frustum</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="f" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_frustum_t</doc>
            <type name="Frustum" c:type="const graphene_frustum_t*"/>
          </instance-parameter>
          <parameter name="box" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersects_sphere" c:identifier="graphene_frustum_intersects_sphere" version="1.2">
        <doc xml:space="preserve">Checks whether the given @sphere intersects a plane of
a #graphene_frustum_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the sphere intersects the frustum</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="f" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_frustum_t</doc>
            <type name="Frustum" c:type="const graphene_frustum_t*"/>
          </instance-parameter>
          <parameter name="sphere" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="Matrix" c:type="graphene_matrix_t" glib:type-name="GrapheneMatrix" glib:get-type="graphene_matrix_get_type" c:symbol-prefix="matrix">
      <doc xml:space="preserve">A structure capable of holding a 4x4 matrix.

The contents of the #graphene_matrix_t structure are private and
should never be accessed directly.</doc>
      <field name="value" readable="0" private="1">
        <type name="Simd4X4F" c:type="graphene_simd4x4f_t"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_matrix_alloc" version="1.0">
        <doc xml:space="preserve">Allocates a new #graphene_matrix_t.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
      </constructor>
      <method name="decompose" c:identifier="graphene_matrix_decompose">
        <doc xml:space="preserve">Decomposes a transformation matrix into its component transformations.

The algorithm for decomposing a matrix is taken from the
[CSS3 Transforms specification](http://dev.w3.org/csswg/css-transforms/);
specifically, the decomposition code is based on the equivalent code
published in "Graphics Gems II", edited by Jim Arvo, and
[available online](http://web.archive.org/web/20150512160205/http://tog.acm.org/resources/GraphicsGems/gemsii/unmatrix.c).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the matrix could be decomposed</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="translate" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the translation vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
          <parameter name="scale" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the scale vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
          <parameter name="rotate" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the rotation quaternion</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </parameter>
          <parameter name="shear" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the shear vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
          <parameter name="perspective" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the perspective vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="determinant" c:identifier="graphene_matrix_determinant" version="1.0">
        <doc xml:space="preserve">Computes the determinant of the given matrix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the determinant</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_matrix_equal" version="1.10">
        <doc xml:space="preserve">Checks whether the two given #graphene_matrix_t matrices are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the two matrices are equal, and `false` otherwise</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal_fast" c:identifier="graphene_matrix_equal_fast" version="1.10">
        <doc xml:space="preserve">Checks whether the two given #graphene_matrix_t matrices are
byte-by-byte equal.

While this function is faster than graphene_matrix_equal(), it
can also return false negatives, so it should be used in
conjuction with either graphene_matrix_equal() or
graphene_matrix_near(). For instance:

|[&lt;!-- language="C" --&gt;
  if (graphene_matrix_equal_fast (a, b))
    {
      // matrices are definitely the same
    }
  else
    {
      if (graphene_matrix_equal (a, b))
        // matrices contain the same values within an epsilon of FLT_EPSILON
      else if (graphene_matrix_near (a, b, 0.0001))
        // matrices contain the same values within an epsilon of 0.0001
      else
        // matrices are not equal
    }
]|</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the matrices are equal. and `false` otherwise</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_matrix_free" version="1.0">
        <doc xml:space="preserve">Frees the resources allocated by graphene_matrix_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_row" c:identifier="graphene_matrix_get_row" version="1.0">
        <doc xml:space="preserve">Retrieves the given row vector at @index_ inside a matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the row vector, between 0 and 3</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the #graphene_vec4_t
  that is used to store the row vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="graphene_matrix_get_value" version="1.0">
        <doc xml:space="preserve">Retrieves the value at the given @row and @col index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value at the given indices</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="row" transfer-ownership="none">
            <doc xml:space="preserve">the row index</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="col" transfer-ownership="none">
            <doc xml:space="preserve">the column index</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_x_scale" c:identifier="graphene_matrix_get_x_scale" version="1.0">
        <doc xml:space="preserve">Retrieves the scaling factor on the X axis in @m.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the scaling factor</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_x_translation" c:identifier="graphene_matrix_get_x_translation" version="1.10">
        <doc xml:space="preserve">Retrieves the translation component on the X axis from @m.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the translation component</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_y_scale" c:identifier="graphene_matrix_get_y_scale" version="1.0">
        <doc xml:space="preserve">Retrieves the scaling factor on the Y axis in @m.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the scaling factor</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_y_translation" c:identifier="graphene_matrix_get_y_translation" version="1.10">
        <doc xml:space="preserve">Retrieves the translation component on the Y axis from @m.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the translation component</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_z_scale" c:identifier="graphene_matrix_get_z_scale" version="1.0">
        <doc xml:space="preserve">Retrieves the scaling factor on the Z axis in @m.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the scaling factor</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_z_translation" c:identifier="graphene_matrix_get_z_translation" version="1.10">
        <doc xml:space="preserve">Retrieves the translation component on the Z axis from @m.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the translation component</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_from_2d" c:identifier="graphene_matrix_init_from_2d" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t from the values of an affine
transformation matrix.

The arguments map to the following matrix layout:

|[&lt;!-- language="plain" --&gt;
  &#x239B; xx  yx &#x239E;   &#x239B;  a   b  0 &#x239E;
  &#x239C; xy  yy &#x239F; = &#x239C;  c   d  0 &#x239F;
  &#x239D; x0  y0 &#x23A0;   &#x239D; tx  ty  1 &#x23A0;
]|

This function can be used to convert between an affine matrix type
from other libraries and a #graphene_matrix_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="xx" transfer-ownership="none">
            <doc xml:space="preserve">the xx member</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="yx" transfer-ownership="none">
            <doc xml:space="preserve">the yx member</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="xy" transfer-ownership="none">
            <doc xml:space="preserve">the xy member</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="yy" transfer-ownership="none">
            <doc xml:space="preserve">the yy member</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="x_0" transfer-ownership="none">
            <doc xml:space="preserve">the x0 member</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y_0" transfer-ownership="none">
            <doc xml:space="preserve">the y0 member</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_float" c:identifier="graphene_matrix_init_from_float" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t with the given array of floating
point values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">an array of at least 16 floating
  point values</doc>
            <array zero-terminated="0" c:type="const float*" fixed-size="16">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_matrix" c:identifier="graphene_matrix_init_from_matrix" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t using the values of the
given matrix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec4" c:identifier="graphene_matrix_init_from_vec4" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t with the given four row
vectors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="v0" transfer-ownership="none">
            <doc xml:space="preserve">the first row vector</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">the second row vector</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">the third row vector</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="v3" transfer-ownership="none">
            <doc xml:space="preserve">the fourth row vector</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_frustum" c:identifier="graphene_matrix_init_frustum" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t compatible with #graphene_frustum_t.

See also: graphene_frustum_init_from_matrix()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">distance of the left clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">distance of the right clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">distance of the bottom clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">distance of the top clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve">distance of the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve">distance of the far clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_identity" c:identifier="graphene_matrix_init_identity" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t with the identity matrix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_look_at" c:identifier="graphene_matrix_init_look_at" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t so that it positions the "camera"
at the given @eye coordinates towards an object at the @center
coordinates. The top of the camera is aligned to the direction
of the @up vector.

Before the transform, the camera is assumed to be placed at the
origin, looking towards the negative Z axis, with the top side of
the camera facing in the direction of the Y axis and the right
side in the direction of the X axis.

In theory, one could use @m to transform a model of such a camera
into world-space. However, it is more common to use the inverse of
@m to transform another object from world coordinates to the view
coordinates of the camera. Typically you would then apply the
camera projection transform to get from view to screen
coordinates.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="eye" transfer-ownership="none">
            <doc xml:space="preserve">the vector describing the position to look from</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="center" transfer-ownership="none">
            <doc xml:space="preserve">the vector describing the position to look at</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="up" transfer-ownership="none">
            <doc xml:space="preserve">the vector describing the world's upward direction; usually,
  this is the graphene_vec3_y_axis() vector</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_ortho" c:identifier="graphene_matrix_init_ortho" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t with an orthographic projection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">the left edge of the clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">the right edge of the clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">the top edge of the clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">the bottom edge of the clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve">the distance of the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve">the distance of the far clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_perspective" c:identifier="graphene_matrix_init_perspective" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t with a perspective projection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="fovy" transfer-ownership="none">
            <doc xml:space="preserve">the field of view angle, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:space="preserve">the aspect value</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve">the near Z plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve">the far Z plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_rotate" c:identifier="graphene_matrix_init_rotate" version="1.0">
        <doc xml:space="preserve">Initializes @m to represent a rotation of @angle degrees on
the axis represented by the @axis vector.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation angle, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="axis" transfer-ownership="none">
            <doc xml:space="preserve">the axis vector as a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_scale" c:identifier="graphene_matrix_init_scale" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t with the given scaling factors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the scale factor on the X axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the scale factor on the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">the scale factor on the Z axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_skew" c:identifier="graphene_matrix_init_skew" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t with a skew transformation
with the given factors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="x_skew" transfer-ownership="none">
            <doc xml:space="preserve">skew factor, in radians, on the X axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_skew" transfer-ownership="none">
            <doc xml:space="preserve">skew factor, in radians, on the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_translate" c:identifier="graphene_matrix_init_translate" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_matrix_t with a translation to the
given coordinates.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized matrix</doc>
          <type name="Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">the translation coordinates</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="interpolate" c:identifier="graphene_matrix_interpolate" version="1.0">
        <doc xml:space="preserve">Linearly interpolates the two given #graphene_matrix_t by
interpolating the decomposed transformations separately.

If either matrix cannot be reduced to their transformations
then the interpolation cannot be performed, and this function
will return an identity matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the linear interpolation factor</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  interpolated matrix</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="inverse" c:identifier="graphene_matrix_inverse" version="1.0">
        <doc xml:space="preserve">Inverts the given matrix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the matrix is invertible</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  inverse matrix</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_2d" c:identifier="graphene_matrix_is_2d" version="1.0">
        <doc xml:space="preserve">Checks whether the given #graphene_matrix_t is compatible with an
a 2D affine transformation matrix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the matrix is compatible with an affine
  transformation matrix</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_backface_visible" c:identifier="graphene_matrix_is_backface_visible" version="1.0">
        <doc xml:space="preserve">Checks whether a #graphene_matrix_t has a visible back face.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the back face of the matrix is visible</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_identity" c:identifier="graphene_matrix_is_identity" version="1.0">
        <doc xml:space="preserve">Checks whether the given #graphene_matrix_t is the identity matrix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the matrix is the identity matrix</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_singular" c:identifier="graphene_matrix_is_singular" version="1.0">
        <doc xml:space="preserve">Checks whether a matrix is singular.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the matrix is singular</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="graphene_matrix_multiply" version="1.0">
        <doc xml:space="preserve">Multiplies two #graphene_matrix_t.

Matrix multiplication is not commutative in general; the order of the factors matters.
The product of this multiplication is (@a &#xD7; @b)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the matrix
  result</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="near" c:identifier="graphene_matrix_near" version="1.10">
        <doc xml:space="preserve">Compares the two given #graphene_matrix_t matrices and checks
whether their values are within the given @epsilon of each
other.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the two matrices are near each other, and
  `false` otherwise</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
          <parameter name="epsilon" transfer-ownership="none">
            <doc xml:space="preserve">the threshold between the two matrices</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="graphene_matrix_normalize" version="1.0">
        <doc xml:space="preserve">Normalizes the given #graphene_matrix_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the normalized matrix</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective" c:identifier="graphene_matrix_perspective" version="1.0">
        <doc xml:space="preserve">Applies a perspective of @depth to the matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="depth" transfer-ownership="none">
            <doc xml:space="preserve">the depth of the perspective</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  perspective matrix</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="print" c:identifier="graphene_matrix_print" version="1.0">
        <doc xml:space="preserve">Prints the contents of a matrix to the standard error stream.

This function is only useful for debugging; there are no guarantees
made on the format of the output.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">The matrix to print</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="project_point" c:identifier="graphene_matrix_project_point" version="1.0">
        <doc xml:space="preserve">Projects a #graphene_point_t using the matrix @m.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the projected
  point</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="project_rect" c:identifier="graphene_matrix_project_rect" version="1.2">
        <doc xml:space="preserve">Projects all corners of a #graphene_rect_t using the given matrix.

See also: graphene_matrix_project_point()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the projected
  rectangle</doc>
            <type name="Quad" c:type="graphene_quad_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="project_rect_bounds" c:identifier="graphene_matrix_project_rect_bounds" version="1.0">
        <doc xml:space="preserve">Projects a #graphene_rect_t using the given matrix.

The resulting rectangle is the axis aligned bounding rectangle capable
of fully containing the projected rectangle.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the projected
  rectangle</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="graphene_matrix_rotate" version="1.0">
        <doc xml:space="preserve">Adds a rotation transformation to @m, using the given @angle
and @axis vector.

This is the equivalent of calling graphene_matrix_init_rotate() and
then multiplying the matrix @m with the rotation matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation angle, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="axis" transfer-ownership="none">
            <doc xml:space="preserve">the rotation axis, as a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_euler" c:identifier="graphene_matrix_rotate_euler" version="1.2">
        <doc xml:space="preserve">Adds a rotation transformation to @m, using the given
#graphene_euler_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a rotation described by a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_quaternion" c:identifier="graphene_matrix_rotate_quaternion" version="1.2">
        <doc xml:space="preserve">Adds a rotation transformation to @m, using the given
#graphene_quaternion_t.

This is the equivalent of calling graphene_quaternion_to_matrix() and
then multiplying @m with the rotation matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a rotation described by a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_x" c:identifier="graphene_matrix_rotate_x" version="1.0">
        <doc xml:space="preserve">Adds a rotation transformation around the X axis to @m, using
the given @angle.

See also: graphene_matrix_rotate()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation angle, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_y" c:identifier="graphene_matrix_rotate_y" version="1.0">
        <doc xml:space="preserve">Adds a rotation transformation around the Y axis to @m, using
the given @angle.

See also: graphene_matrix_rotate()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation angle, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_z" c:identifier="graphene_matrix_rotate_z" version="1.0">
        <doc xml:space="preserve">Adds a rotation transformation around the Z axis to @m, using
the given @angle.

See also: graphene_matrix_rotate()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation angle, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="graphene_matrix_scale" version="1.0">
        <doc xml:space="preserve">Adds a scaling transformation to @m, using the three
given factors.

This is the equivalent of calling graphene_matrix_init_scale() and then
multiplying the matrix @m with the scale matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="factor_x" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the X axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="factor_y" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="factor_z" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the Z axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="skew_xy" c:identifier="graphene_matrix_skew_xy" version="1.0">
        <doc xml:space="preserve">Adds a skew of @factor on the X and Y axis to the given matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">skew factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="skew_xz" c:identifier="graphene_matrix_skew_xz" version="1.0">
        <doc xml:space="preserve">Adds a skew of @factor on the X and Z axis to the given matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">skew factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="skew_yz" c:identifier="graphene_matrix_skew_yz" version="1.0">
        <doc xml:space="preserve">Adds a skew of @factor on the Y and Z axis to the given matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">skew factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_2d" c:identifier="graphene_matrix_to_2d" version="1.0">
        <doc xml:space="preserve">Converts a #graphene_matrix_t to an affine transformation
matrix, if the given matrix is compatible.

The returned values have the following layout:

|[&lt;!-- language="plain" --&gt;
  &#x239B; xx  yx &#x239E;   &#x239B;  a   b  0 &#x239E;
  &#x239C; xy  yy &#x239F; = &#x239C;  c   d  0 &#x239F;
  &#x239D; x0  y0 &#x23A0;   &#x239D; tx  ty  1 &#x23A0;
]|

This function can be used to convert between a #graphene_matrix_t
and an affine matrix type from other libraries.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the matrix is compatible with an affine
  transformation matrix</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="xx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the xx member</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="yx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the yx member</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="xy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the xy member</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="yy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the yy member</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="x_0" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the x0 member</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
          <parameter name="y_0" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the y0 member</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_float" c:identifier="graphene_matrix_to_float" version="1.0">
        <doc xml:space="preserve">Converts a #graphene_matrix_t to an array of floating point
values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="v" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location
  for an array of floating point values. The array must be capable
  of holding at least 16 values.</doc>
            <array zero-terminated="0" c:type="float*" fixed-size="16">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="transform_bounds" c:identifier="graphene_matrix_transform_bounds" version="1.0">
        <doc xml:space="preserve">Transforms each corner of a #graphene_rect_t using the given matrix @m.

The result is the axis aligned bounding rectangle containing the coplanar
quadrilateral.

See also: graphene_matrix_transform_point()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the bounds
  of the transformed rectangle</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_box" c:identifier="graphene_matrix_transform_box" version="1.2">
        <doc xml:space="preserve">Transforms the vertices of a #graphene_box_t using the given matrix @m.

The result is the axis aligned bounding box containing the transformed
vertices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the bounds
  of the transformed box</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_point" c:identifier="graphene_matrix_transform_point" version="1.0">
        <doc xml:space="preserve">Transforms the given #graphene_point_t using the matrix @m.

Unlike graphene_matrix_transform_vec3(), this function will take into
account the fourth row vector of the #graphene_matrix_t when computing
the dot product of each row vector of the matrix.

See also: graphene_simd4x4f_point3_mul()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  transformed #graphene_point_t</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_point3d" c:identifier="graphene_matrix_transform_point3d" version="1.2">
        <doc xml:space="preserve">Transforms the given #graphene_point3d_t using the matrix @m.

Unlike graphene_matrix_transform_vec3(), this function will take into
account the fourth row vector of the #graphene_matrix_t when computing
the dot product of each row vector of the matrix.

See also: graphene_simd4x4f_point3_mul()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_ray" c:identifier="graphene_matrix_transform_ray" version="1.4">
        <doc xml:space="preserve">Transform a #graphene_ray_t using the given matrix @m.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  transformed ray</doc>
            <type name="Ray" c:type="graphene_ray_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_rect" c:identifier="graphene_matrix_transform_rect" version="1.0">
        <doc xml:space="preserve">Transforms each corner of a #graphene_rect_t using the given matrix @m.

The result is a coplanar quadrilateral.

See also: graphene_matrix_transform_point()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  transformed quad</doc>
            <type name="Quad" c:type="graphene_quad_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_sphere" c:identifier="graphene_matrix_transform_sphere" version="1.2">
        <doc xml:space="preserve">Transforms a #graphene_sphere_t using the given matrix @m. The
result is the bounding sphere containing the transformed sphere.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the bounds
  of the transformed sphere</doc>
            <type name="Sphere" c:type="graphene_sphere_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_vec3" c:identifier="graphene_matrix_transform_vec3" version="1.0">
        <doc xml:space="preserve">Transforms the given #graphene_vec3_t using the matrix @m.

This function will multiply the X, Y, and Z row vectors of the matrix @m
with the corresponding components of the vector @v. The W row vector will
be ignored.

See also: graphene_simd4x4f_vec3_mul()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_vec4" c:identifier="graphene_matrix_transform_vec4" version="1.0">
        <doc xml:space="preserve">Transforms the given #graphene_vec4_t using the matrix @m.

See also: graphene_simd4x4f_vec4_mul()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="graphene_matrix_translate" version="1.0">
        <doc xml:space="preserve">Adds a translation transformation to @m using the coordinates
of the given #graphene_point3d_t.

This is the equivalent of calling graphene_matrix_init_translate() and
then multiplying @m with the translation matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transpose" c:identifier="graphene_matrix_transpose" version="1.0">
        <doc xml:space="preserve">Transposes the given matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  transposed matrix</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unproject_point3d" c:identifier="graphene_matrix_unproject_point3d" version="1.2">
        <doc xml:space="preserve">Unprojects the given @point using the @projection matrix and
a @modelview matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="projection" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t for the projection matrix</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="modelview" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t for the modelview matrix; this is
  the inverse of the modelview used when projecting the point</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t with the coordinates of the point</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the unprojected
  point</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="untransform_bounds" c:identifier="graphene_matrix_untransform_bounds" version="1.0">
        <doc xml:space="preserve">Undoes the transformation on the corners of a #graphene_rect_t using the
given matrix, within the given axis aligned rectangular @bounds.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the bounds of the transformation</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  untransformed rectangle</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="untransform_point" c:identifier="graphene_matrix_untransform_point" version="1.0">
        <doc xml:space="preserve">Undoes the transformation of a #graphene_point_t using the
given matrix, within the given axis aligned rectangular @bounds.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the point was successfully untransformed</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the bounds of the transformation</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  untransformed point</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <constant name="PI" value="3.141593" c:type="GRAPHENE_PI">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <constant name="PI_2" value="1.570796" c:type="GRAPHENE_PI_2">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <function-macro name="POINT3D_INIT" c:identifier="GRAPHENE_POINT3D_INIT" version="1.0" introspectable="0">
      <doc xml:space="preserve">Initializes a #graphene_point3d_t to the given coordinates when declaring it.</doc>
      <parameters>
        <parameter name="_x">
          <doc xml:space="preserve">the X coordinate</doc>
        </parameter>
        <parameter name="_y">
          <doc xml:space="preserve">the Y coordinate</doc>
        </parameter>
        <parameter name="_z">
          <doc xml:space="preserve">the Z coordinate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="POINT_INIT" c:identifier="GRAPHENE_POINT_INIT" version="1.0" introspectable="0">
      <doc xml:space="preserve">Initializes a #graphene_point_t with the given coordinates
when declaring it, e.g:

|[&lt;!-- language="C" --&gt;
  graphene_point_t p = GRAPHENE_POINT_INIT (10.f, 10.f);
]|</doc>
      <parameters>
        <parameter name="_x">
          <doc xml:space="preserve">the X coordinate</doc>
        </parameter>
        <parameter name="_y">
          <doc xml:space="preserve">the Y coordinate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PRIVATE_FIELD" c:identifier="GRAPHENE_PRIVATE_FIELD" introspectable="0">
      <parameters>
        <parameter name="type">
        </parameter>
        <parameter name="name">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Plane" c:type="graphene_plane_t" version="1.2" glib:type-name="GraphenePlane" glib:get-type="graphene_plane_get_type" c:symbol-prefix="plane">
      <doc xml:space="preserve">A 2D plane that extends infinitely in a 3D volume.

The contents of the `graphene_plane_t` are private, and should not be
modified directly.</doc>
      <field name="normal" readable="0" private="1">
        <type name="Vec3" c:type="graphene_vec3_t"/>
      </field>
      <field name="constant" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_plane_alloc" version="1.2">
        <doc xml:space="preserve">Allocates a new #graphene_plane_t structure.

The contents of the returned structure are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_plane_t.
  Use graphene_plane_free() to free the resources allocated by
  this function</doc>
          <type name="Plane" c:type="graphene_plane_t*"/>
        </return-value>
      </constructor>
      <method name="distance" c:identifier="graphene_plane_distance" version="1.2">
        <doc xml:space="preserve">Computes the distance of @point from a #graphene_plane_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the distance of the given #graphene_point3d_t from the plane</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_plane_t</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_plane_equal" version="1.2">
        <doc xml:space="preserve">Checks whether the two given #graphene_plane_t are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the given planes are equal</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_plane_t</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_plane_t</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_plane_free" version="1.2">
        <doc xml:space="preserve">Frees the resources allocated by graphene_plane_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_plane_t</doc>
            <type name="Plane" c:type="graphene_plane_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_constant" c:identifier="graphene_plane_get_constant" version="1.2">
        <doc xml:space="preserve">Retrieves the distance along the normal vector of the
given #graphene_plane_t from the origin.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the constant value of the plane</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_plane_t</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_normal" c:identifier="graphene_plane_get_normal" version="1.2">
        <doc xml:space="preserve">Retrieves the normal vector pointing towards the origin of the
given #graphene_plane_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_plane_t</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </instance-parameter>
          <parameter name="normal" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the normal vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_plane_init" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_plane_t using the given @normal vector
and @constant values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized plane</doc>
          <type name="Plane" c:type="graphene_plane_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_plane_t to initialize</doc>
            <type name="Plane" c:type="graphene_plane_t*"/>
          </instance-parameter>
          <parameter name="normal" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a unit length normal vector defining the plane
  pointing towards the origin; if unset, we use the X axis by default</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="constant" transfer-ownership="none">
            <doc xml:space="preserve">the distance from the origin to the plane along the
  normal vector; the sign determines the half-space occupied by the
  plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_plane" c:identifier="graphene_plane_init_from_plane" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_plane_t using the normal
vector and constant of another #graphene_plane_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized plane</doc>
          <type name="Plane" c:type="graphene_plane_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_plane_t to initialize</doc>
            <type name="Plane" c:type="graphene_plane_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_plane_t</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_point" c:identifier="graphene_plane_init_from_point" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_plane_t using the given normal vector
and an arbitrary co-planar point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized plane</doc>
          <type name="Plane" c:type="graphene_plane_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_plane_t to initialize</doc>
            <type name="Plane" c:type="graphene_plane_t*"/>
          </instance-parameter>
          <parameter name="normal" transfer-ownership="none">
            <doc xml:space="preserve">a normal vector defining the plane pointing towards the origin</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_points" c:identifier="graphene_plane_init_from_points" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_plane_t using the 3 provided co-planar
points.

The winding order is counter-clockwise, and determines which direction
the normal vector will point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized plane</doc>
          <type name="Plane" c:type="graphene_plane_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_plane_t to initialize</doc>
            <type name="Plane" c:type="graphene_plane_t*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec4" c:identifier="graphene_plane_init_from_vec4" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_plane_t using the components of
the given #graphene_vec4_t vector.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized plane</doc>
          <type name="Plane" c:type="graphene_plane_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_plane_t to initialize</doc>
            <type name="Plane" c:type="graphene_plane_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t containing the normal vector in its first
  three components, and the distance in its fourth component</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="negate" c:identifier="graphene_plane_negate" version="1.2">
        <doc xml:space="preserve">Negates the normal vector and constant of a #graphene_plane_t, effectively
mirroring the plane across the origin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_plane_t</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the negated plane</doc>
            <type name="Plane" c:type="graphene_plane_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="graphene_plane_normalize" version="1.2">
        <doc xml:space="preserve">Normalizes the vector of the given #graphene_plane_t,
and adjusts the constant accordingly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_plane_t</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the normalized plane</doc>
            <type name="Plane" c:type="graphene_plane_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform" c:identifier="graphene_plane_transform" version="1.10">
        <doc xml:space="preserve">Transforms a #graphene_plane_t @p using the given @matrix
and @normal_matrix.

If @normal_matrix is %NULL, a transformation matrix for the plane
normal will be computed from @matrix. If you are transforming
multiple planes using the same @matrix it's recommended to compute
the normal matrix beforehand to avoid incurring in the cost of
recomputing it every time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_plane_t</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
          <parameter name="normal_matrix" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the transformed plane</doc>
            <type name="Plane" c:type="graphene_plane_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="Point" c:type="graphene_point_t" version="1.0" glib:type-name="GraphenePoint" glib:get-type="graphene_point_get_type" c:symbol-prefix="point">
      <doc xml:space="preserve">A point with two coordinates.</doc>
      <field name="x" writable="1">
        <doc xml:space="preserve">the X coordinate of the point</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve">the Y coordinate of the point</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_point_alloc" version="1.0">
        <doc xml:space="preserve">Allocates a new #graphene_point_t structure.

The coordinates of the returned point are (0, 0).

It's possible to chain this function with graphene_point_init()
or graphene_point_init_from_point(), e.g.:

|[&lt;!-- language="C" --&gt;
  graphene_point_t *
  point_new (float x, float y)
  {
    return graphene_point_init (graphene_point_alloc (), x, y);
  }

  graphene_point_t *
  point_copy (const graphene_point_t *p)
  {
    return graphene_point_init_from_point (graphene_point_alloc (), p);
  }
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_point_t.
  Use graphene_point_free() to free the resources allocated by
  this function.</doc>
          <type name="Point" c:type="graphene_point_t*"/>
        </return-value>
      </constructor>
      <method name="distance" c:identifier="graphene_point_distance" version="1.0">
        <doc xml:space="preserve">Computes the distance between @a and @b.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the distance between the two points</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="d_x" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">distance component on the X axis</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="d_y" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">distance component on the Y axis</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_point_equal" version="1.0">
        <doc xml:space="preserve">Checks if the two points @a and @b point to the same
coordinates.

This function accounts for floating point fluctuations; if
you want to control the fuzziness of the match, you can use
graphene_point_near() instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the points have the same coordinates</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_point_free" version="1.0">
        <doc xml:space="preserve">Frees the resources allocated by graphene_point_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_point_init" version="1.0">
        <doc xml:space="preserve">Initializes @p to the given @x and @y coordinates.

It's safe to call this function multiple times.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized point</doc>
          <type name="Point" c:type="graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the X coordinate</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the Y coordinate</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_point" c:identifier="graphene_point_init_from_point" version="1.0">
        <doc xml:space="preserve">Initializes @p with the same coordinates of @src.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized point</doc>
          <type name="Point" c:type="graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_point_t to use</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec2" c:identifier="graphene_point_init_from_vec2" version="1.4">
        <doc xml:space="preserve">Initializes @p with the coordinates inside the given #graphene_vec2_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized point</doc>
          <type name="Point" c:type="graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_point_t to initialize</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="interpolate" c:identifier="graphene_point_interpolate" version="1.0">
        <doc xml:space="preserve">Linearly interpolates the coordinates of @a and @b using the
given @factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the linear interpolation factor</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the interpolated
  point</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="near" c:identifier="graphene_point_near" version="1.0">
        <doc xml:space="preserve">Checks whether the two points @a and @b are within
the threshold of @epsilon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the distance is within @epsilon</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="epsilon" transfer-ownership="none">
            <doc xml:space="preserve">threshold between the two points</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_vec2" c:identifier="graphene_point_to_vec2" version="1.4">
        <doc xml:space="preserve">Stores the coordinates of the given #graphene_point_t into a
#graphene_vec2_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </instance-parameter>
          <parameter name="v" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the vertex</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <function name="zero" c:identifier="graphene_point_zero" version="1.0">
        <doc xml:space="preserve">Returns a point fixed at (0, 0).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a fixed point</doc>
          <type name="Point" c:type="const graphene_point_t*"/>
        </return-value>
      </function>
    </record>
    <record name="Point3D" c:type="graphene_point3d_t" version="1.0" glib:type-name="GraphenePoint3D" glib:get-type="graphene_point3d_get_type" c:symbol-prefix="point3d">
      <doc xml:space="preserve">A point with three components: X, Y, and Z.</doc>
      <field name="x" writable="1">
        <doc xml:space="preserve">the X coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve">the Y coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve">the Z coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_point3d_alloc" version="1.0">
        <doc xml:space="preserve">Allocates a #graphene_point3d_t structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated structure.
  Use graphene_point3d_free() to free the resources
  allocated by this function.</doc>
          <type name="Point3D" c:type="graphene_point3d_t*"/>
        </return-value>
      </constructor>
      <method name="cross" c:identifier="graphene_point3d_cross" version="1.0">
        <doc xml:space="preserve">Computes the cross product of the two given #graphene_point3d_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the cross
  product</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="distance" c:identifier="graphene_point3d_distance" version="1.4">
        <doc xml:space="preserve">Computes the distance between the two given #graphene_point3d_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the distance between two points</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="delta" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the distance
  components on the X, Y, and Z axis</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dot" c:identifier="graphene_point3d_dot" version="1.0">
        <doc xml:space="preserve">Computes the dot product of the two given #graphene_point3d_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the dot product</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_point3d_equal" version="1.0">
        <doc xml:space="preserve">Checks whether two given points are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the points are equal</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_point3d_free" version="1.0">
        <doc xml:space="preserve">Frees the resources allocated via graphene_point3d_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_point3d_init" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_point3d_t with the given coordinates.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_point3d_t</doc>
          <type name="Point3D" c:type="graphene_point3d_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_point3d_t to initialize</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the X coordinate of the point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the Y coordinate of the point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">the Z coordinate of the point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_point" c:identifier="graphene_point3d_init_from_point" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_point3d_t using the coordinates of
another #graphene_point3d_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized point</doc>
          <type name="Point3D" c:type="graphene_point3d_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec3" c:identifier="graphene_point3d_init_from_vec3" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_point3d_t using the components
of a #graphene_vec3_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_point3d_t</doc>
          <type name="Point3D" c:type="graphene_point3d_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="interpolate" c:identifier="graphene_point3d_interpolate" version="1.0">
        <doc xml:space="preserve">Linearly interpolates each component of @a and @b using the
provided @factor, and places the result in @res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the interpolation factor</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the return location for the
  interpolated #graphene_point3d_t</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="length" c:identifier="graphene_point3d_length" version="1.0">
        <doc xml:space="preserve">Computes the length of the vector represented by the
coordinates of the given #graphene_point3d_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the vector represented by the point</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="near" c:identifier="graphene_point3d_near" version="1.0">
        <doc xml:space="preserve">Checks whether the two points are near each other, within
an @epsilon factor.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the points are near each other</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="epsilon" transfer-ownership="none">
            <doc xml:space="preserve">fuzzyness factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="graphene_point3d_normalize" version="1.0">
        <doc xml:space="preserve">Computes the normalization of the vector represented by the
coordinates of the given #graphene_point3d_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the normalized
  #graphene_point3d_t</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize_viewport" c:identifier="graphene_point3d_normalize_viewport" version="1.4">
        <doc xml:space="preserve">Normalizes the coordinates of a #graphene_point3d_t using the
given viewport and clipping planes.

The coordinates of the resulting #graphene_point3d_t will be
in the [ -1, 1 ] range.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="viewport" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t representing a viewport</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve">the coordinate of the near clipping plane, or 0 for
  the default near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve">the coordinate of the far clipping plane, or 1 for the
  default far clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the return location for the
  normalized #graphene_point3d_t</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="graphene_point3d_scale" version="1.0">
        <doc xml:space="preserve">Scales the coordinates of the given #graphene_point3d_t by
the given @factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the scaling factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the scaled point</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_vec3" c:identifier="graphene_point3d_to_vec3" version="1.0">
        <doc xml:space="preserve">Stores the coordinates of a #graphene_point3d_t into a
#graphene_vec3_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </instance-parameter>
          <parameter name="v" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <function name="zero" c:identifier="graphene_point3d_zero" version="1.0">
        <doc xml:space="preserve">Retrieves a constant point with all three coordinates set to 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a zero point</doc>
          <type name="Point3D" c:type="const graphene_point3d_t*"/>
        </return-value>
      </function>
    </record>
    <record name="Quad" c:type="graphene_quad_t" version="1.0" glib:type-name="GrapheneQuad" glib:get-type="graphene_quad_get_type" c:symbol-prefix="quad">
      <doc xml:space="preserve">A 4 vertex quadrilateral, as represented by four #graphene_point_t.

The contents of a #graphene_quad_t are private and should never be
accessed directly.</doc>
      <field name="points" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="Point" c:type="graphene_point_t"/>
        </array>
      </field>
      <constructor name="alloc" c:identifier="graphene_quad_alloc" version="1.0">
        <doc xml:space="preserve">Allocates a new #graphene_quad_t instance.

The contents of the returned instance are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created #graphene_quad_t instance</doc>
          <type name="Quad" c:type="graphene_quad_t*"/>
        </return-value>
      </constructor>
      <method name="bounds" c:identifier="graphene_quad_bounds" version="1.0">
        <doc xml:space="preserve">Computes the bounding rectangle of @q and places it into @r.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quad_t</doc>
            <type name="Quad" c:type="const graphene_quad_t*"/>
          </instance-parameter>
          <parameter name="r" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_rect_t</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains" c:identifier="graphene_quad_contains" version="1.0">
        <doc xml:space="preserve">Checks if the given #graphene_quad_t contains the given #graphene_point_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the point is inside the #graphene_quad_t</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quad_t</doc>
            <type name="Quad" c:type="const graphene_quad_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_quad_free" version="1.0">
        <doc xml:space="preserve">Frees the resources allocated by graphene_quad_alloc()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quad_t</doc>
            <type name="Quad" c:type="graphene_quad_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_point" c:identifier="graphene_quad_get_point" version="1.0">
        <doc xml:space="preserve">Retrieves the point of a #graphene_quad_t at the given index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #graphene_point_t</doc>
          <type name="Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quad_t</doc>
            <type name="Quad" c:type="const graphene_quad_t*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">the index of the point to retrieve</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_quad_init" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_quad_t with the given points.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_quad_t</doc>
          <type name="Quad" c:type="graphene_quad_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_quad_t to initialize</doc>
            <type name="Quad" c:type="graphene_quad_t*"/>
          </instance-parameter>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:space="preserve">the first point of the quadrilateral</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <doc xml:space="preserve">the second point of the quadrilateral</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="p3" transfer-ownership="none">
            <doc xml:space="preserve">the third point of the quadrilateral</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="p4" transfer-ownership="none">
            <doc xml:space="preserve">the fourth point of the quadrilateral</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_points" c:identifier="graphene_quad_init_from_points" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_quad_t using an array of points.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_quad_t</doc>
          <type name="Quad" c:type="graphene_quad_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_quad_t to initialize</doc>
            <type name="Quad" c:type="graphene_quad_t*"/>
          </instance-parameter>
          <parameter name="points" transfer-ownership="none">
            <doc xml:space="preserve">an array of 4 #graphene_point_t</doc>
            <array zero-terminated="0" c:type="const graphene_point_t*" fixed-size="4">
              <type name="Point" c:type="graphene_point_t"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_rect" c:identifier="graphene_quad_init_from_rect" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_quad_t using the four corners of the
given #graphene_rect_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_quad_t</doc>
          <type name="Quad" c:type="graphene_quad_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_quad_t to initialize</doc>
            <type name="Quad" c:type="graphene_quad_t*"/>
          </instance-parameter>
          <parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="Quaternion" c:type="graphene_quaternion_t" version="1.0" glib:type-name="GrapheneQuaternion" glib:get-type="graphene_quaternion_get_type" c:symbol-prefix="quaternion">
      <doc xml:space="preserve">A quaternion.

The contents of the #graphene_quaternion_t structure are private
and should never be accessed directly.</doc>
      <field name="x" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="w" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_quaternion_alloc" version="1.0">
        <doc xml:space="preserve">Allocates a new #graphene_quaternion_t.

The contents of the returned value are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_quaternion_t</doc>
          <type name="Quaternion" c:type="graphene_quaternion_t*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="graphene_quaternion_add" version="1.10">
        <doc xml:space="preserve">Adds two #graphene_quaternion_t @a and @b.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the result of the operation</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dot" c:identifier="graphene_quaternion_dot" version="1.0">
        <doc xml:space="preserve">Computes the dot product of two #graphene_quaternion_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the dot products</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_quaternion_equal" version="1.0">
        <doc xml:space="preserve">Checks whether the given quaternions are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the quaternions are equal</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_quaternion_free" version="1.0">
        <doc xml:space="preserve">Releases the resources allocated by graphene_quaternion_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_quaternion_init" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_quaternion_t using the given four values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized quaternion</doc>
          <type name="Quaternion" c:type="graphene_quaternion_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the first component of the quaternion</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the second component of the quaternion</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">the third component of the quaternion</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="w" transfer-ownership="none">
            <doc xml:space="preserve">the fourth component of the quaternion</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_angle_vec3" c:identifier="graphene_quaternion_init_from_angle_vec3" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_quaternion_t using an @angle on a
specific @axis.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized quaternion</doc>
          <type name="Quaternion" c:type="graphene_quaternion_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation on a given axis, in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="axis" transfer-ownership="none">
            <doc xml:space="preserve">the axis of rotation, expressed as a vector</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_angles" c:identifier="graphene_quaternion_init_from_angles" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_quaternion_t using the values of
the [Euler angles](http://en.wikipedia.org/wiki/Euler_angles)
on each axis.

See also: graphene_quaternion_init_from_euler()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized quaternion</doc>
          <type name="Quaternion" c:type="graphene_quaternion_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="deg_x" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the X axis (yaw), in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="deg_y" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the Y axis (pitch), in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="deg_z" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the Z axis (roll), in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_euler" c:identifier="graphene_quaternion_init_from_euler" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_quaternion_t using the given #graphene_euler_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_quaternion_t</doc>
          <type name="Quaternion" c:type="graphene_quaternion_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_quaternion_t to initialize</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="e" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_euler_t</doc>
            <type name="Euler" c:type="const graphene_euler_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_matrix" c:identifier="graphene_quaternion_init_from_matrix" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_quaternion_t using the rotation components
of a transformation matrix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized quaternion</doc>
          <type name="Quaternion" c:type="graphene_quaternion_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_quaternion" c:identifier="graphene_quaternion_init_from_quaternion" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_quaternion_t with the values from @src.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized quaternion</doc>
          <type name="Quaternion" c:type="graphene_quaternion_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_radians" c:identifier="graphene_quaternion_init_from_radians" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_quaternion_t using the values of
the [Euler angles](http://en.wikipedia.org/wiki/Euler_angles)
on each axis.

See also: graphene_quaternion_init_from_euler()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized quaternion</doc>
          <type name="Quaternion" c:type="graphene_quaternion_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="rad_x" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the X axis (yaw), in radians</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="rad_y" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the Y axis (pitch), in radians</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="rad_z" transfer-ownership="none">
            <doc xml:space="preserve">rotation angle on the Z axis (roll), in radians</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec4" c:identifier="graphene_quaternion_init_from_vec4" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_quaternion_t with the values from @src.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized quaternion</doc>
          <type name="Quaternion" c:type="graphene_quaternion_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_identity" c:identifier="graphene_quaternion_init_identity" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_quaternion_t using the identity
transformation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized quaternion</doc>
          <type name="Quaternion" c:type="graphene_quaternion_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invert" c:identifier="graphene_quaternion_invert" version="1.0">
        <doc xml:space="preserve">Inverts a #graphene_quaternion_t, and returns the conjugate
quaternion of @q.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the inverted
  quaternion</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="graphene_quaternion_multiply" version="1.10">
        <doc xml:space="preserve">Multiplies two #graphene_quaternion_t @a and @b.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the result of the operation</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="graphene_quaternion_normalize" version="1.0">
        <doc xml:space="preserve">Normalizes a #graphene_quaternion_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the normalized
  quaternion</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="graphene_quaternion_scale" version="1.10">
        <doc xml:space="preserve">Scales all the elements of a #graphene_quaternion_t @q using
the given scalar factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">a scaling factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the result of the operation</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="slerp" c:identifier="graphene_quaternion_slerp" version="1.0">
        <doc xml:space="preserve">Interpolates between the two given quaternions using a spherical
linear interpolation, or [SLERP](http://en.wikipedia.org/wiki/Slerp),
using the given interpolation @factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the linear interpolation factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the interpolated
  quaternion</doc>
            <type name="Quaternion" c:type="graphene_quaternion_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_angle_vec3" c:identifier="graphene_quaternion_to_angle_vec3" version="1.0">
        <doc xml:space="preserve">Converts a quaternion into an @angle, @axis pair.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="angle" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the angle, in degrees</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="axis" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the rotation axis</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_angles" c:identifier="graphene_quaternion_to_angles" version="1.2">
        <doc xml:space="preserve">Converts a #graphene_quaternion_t to its corresponding rotations
on the [Euler angles](http://en.wikipedia.org/wiki/Euler_angles)
on each axis.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="deg_x" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the rotation angle on
  the X axis (yaw), in degrees</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="deg_y" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the rotation angle on
  the Y axis (pitch), in degrees</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="deg_z" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the rotation angle on
  the Z axis (roll), in degrees</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_matrix" c:identifier="graphene_quaternion_to_matrix" version="1.0">
        <doc xml:space="preserve">Converts a quaternion into a transformation matrix expressing
the rotation defined by the #graphene_quaternion_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="m" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_matrix_t</doc>
            <type name="Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_radians" c:identifier="graphene_quaternion_to_radians" version="1.2">
        <doc xml:space="preserve">Converts a #graphene_quaternion_t to its corresponding rotations
on the [Euler angles](http://en.wikipedia.org/wiki/Euler_angles)
on each axis.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="rad_x" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the rotation angle on
  the X axis (yaw), in radians</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="rad_y" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the rotation angle on
  the Y axis (pitch), in radians</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="rad_z" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the rotation angle on
  the Z axis (roll), in radians</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_vec4" c:identifier="graphene_quaternion_to_vec4" version="1.0">
        <doc xml:space="preserve">Copies the components of a #graphene_quaternion_t into a
#graphene_vec4_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="q" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_quaternion_t</doc>
            <type name="Quaternion" c:type="const graphene_quaternion_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a
  #graphene_vec4_t</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <function-macro name="RECT_INIT" c:identifier="GRAPHENE_RECT_INIT" version="1.0" introspectable="0">
      <doc xml:space="preserve">Initializes a #graphene_rect_t when declaring it.</doc>
      <parameters>
        <parameter name="_x">
          <doc xml:space="preserve">the X coordinate of the origin</doc>
        </parameter>
        <parameter name="_y">
          <doc xml:space="preserve">the Y coordinate of the origin</doc>
        </parameter>
        <parameter name="_w">
          <doc xml:space="preserve">the width</doc>
        </parameter>
        <parameter name="_h">
          <doc xml:space="preserve">the height</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="Ray" c:type="graphene_ray_t" version="1.4" glib:type-name="GrapheneRay" glib:get-type="graphene_ray_get_type" c:symbol-prefix="ray">
      <doc xml:space="preserve">A ray emitted from an origin in a given direction.

The contents of the `graphene_ray_t` structure are private, and should not
be modified directly.</doc>
      <field name="origin" readable="0" private="1">
        <type name="Vec3" c:type="graphene_vec3_t"/>
      </field>
      <field name="direction" readable="0" private="1">
        <type name="Vec3" c:type="graphene_vec3_t"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_ray_alloc" version="1.4">
        <doc xml:space="preserve">Allocates a new #graphene_ray_t structure.

The contents of the returned structure are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_ray_t.
  Use graphene_ray_free() to free the resources allocated by
  this function</doc>
          <type name="Ray" c:type="graphene_ray_t*"/>
        </return-value>
      </constructor>
      <method name="equal" c:identifier="graphene_ray_equal" version="1.4">
        <doc xml:space="preserve">Checks whether the two given #graphene_ray_t are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the given rays are equal</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_ray_free" version="1.4">
        <doc xml:space="preserve">Frees the resources allocated by graphene_ray_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="graphene_ray_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_closest_point_to_point" c:identifier="graphene_ray_get_closest_point_to_point" version="1.4">
        <doc xml:space="preserve">Computes the point on the given #graphene_ray_t that is closest to the
given point @p.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the closest point3d</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_direction" c:identifier="graphene_ray_get_direction" version="1.4">
        <doc xml:space="preserve">Retrieves the direction of the given #graphene_ray_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="direction" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the direction</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_distance_to_plane" c:identifier="graphene_ray_get_distance_to_plane" version="1.4">
        <doc xml:space="preserve">Computes the distance of the origin of the given #graphene_ray_t from the
given plane.

If the ray does not intersect the plane, this function returns `INFINITY`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the distance of the origin of the ray from the plane</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_plane_t</doc>
            <type name="Plane" c:type="const graphene_plane_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_distance_to_point" c:identifier="graphene_ray_get_distance_to_point" version="1.4">
        <doc xml:space="preserve">Computes the distance of the closest approach between the
given #graphene_ray_t @r and the point @p.

The closest approach to a ray from a point is the distance
between the point and the projection of the point on the
ray itself.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the distance of the point</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_origin" c:identifier="graphene_ray_get_origin" version="1.4">
        <doc xml:space="preserve">Retrieves the origin of the given #graphene_ray_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="origin" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the origin</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_position_at" c:identifier="graphene_ray_get_position_at" version="1.4">
        <doc xml:space="preserve">Retrieves the coordinates of a point at the distance @t along the
given #graphene_ray_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">the distance along the ray</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="position" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the position</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_ray_init" version="1.4">
        <doc xml:space="preserve">Initializes the given #graphene_ray_t using the given @origin
and @direction values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized ray</doc>
          <type name="Ray" c:type="graphene_ray_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_ray_t to initialize</doc>
            <type name="Ray" c:type="graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="origin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the origin of the ray</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the direction vector</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_ray" c:identifier="graphene_ray_init_from_ray" version="1.4">
        <doc xml:space="preserve">Initializes the given #graphene_ray_t using the origin and direction
values of another #graphene_ray_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized ray</doc>
          <type name="Ray" c:type="graphene_ray_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_ray_t to initialize</doc>
            <type name="Ray" c:type="graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec3" c:identifier="graphene_ray_init_from_vec3" version="1.4">
        <doc xml:space="preserve">Initializes the given #graphene_ray_t using the given vectors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized ray</doc>
          <type name="Ray" c:type="graphene_ray_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_ray_t to initialize</doc>
            <type name="Ray" c:type="graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="origin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect_box" c:identifier="graphene_ray_intersect_box" version="1.10">
        <doc xml:space="preserve">Intersects the given #graphene_ray_t @r with the given
#graphene_box_t @b.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of intersection</doc>
          <type name="RayIntersectionKind" c:type="graphene_ray_intersection_kind_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </parameter>
          <parameter name="t_out" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the distance of the point on the ray that intersects the box</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect_sphere" c:identifier="graphene_ray_intersect_sphere" version="1.10">
        <doc xml:space="preserve">Intersects the given #graphene_ray_t @r with the given
#graphene_sphere_t @s.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of intersection</doc>
          <type name="RayIntersectionKind" c:type="graphene_ray_intersection_kind_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </parameter>
          <parameter name="t_out" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the distance of the point on the ray that intersects the sphere</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect_triangle" c:identifier="graphene_ray_intersect_triangle" version="1.10">
        <doc xml:space="preserve">Intersects the given #graphene_ray_t @r with the given
#graphene_triangle_t @t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of intersection</doc>
          <type name="RayIntersectionKind" c:type="graphene_ray_intersection_kind_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </parameter>
          <parameter name="t_out" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the distance of the point on the ray that intersects the triangle</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersects_box" c:identifier="graphene_ray_intersects_box" version="1.10">
        <doc xml:space="preserve">Checks whether the given #graphene_ray_t @r intersects the
given #graphene_box_t @b.

See also: graphene_ray_intersect_box()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the ray intersects the box</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_box_t</doc>
            <type name="Box" c:type="const graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersects_sphere" c:identifier="graphene_ray_intersects_sphere" version="1.10">
        <doc xml:space="preserve">Checks if the given #graphene_ray_t @r intersects the
given #graphene_sphere_t @s.

See also: graphene_ray_intersect_sphere()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the ray intersects the sphere</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersects_triangle" c:identifier="graphene_ray_intersects_triangle" version="1.10">
        <doc xml:space="preserve">Checks whether the given #graphene_ray_t @r intersects the
given #graphene_triangle_t @b.

See also: graphene_ray_intersect_triangle()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the ray intersects the triangle</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_ray_t</doc>
            <type name="Ray" c:type="const graphene_ray_t*"/>
          </instance-parameter>
          <parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="RayIntersectionKind" version="1.10" c:type="graphene_ray_intersection_kind_t">
      <doc xml:space="preserve">The type of intersection.</doc>
      <member name="none" value="0" c:identifier="GRAPHENE_RAY_INTERSECTION_KIND_NONE">
        <doc xml:space="preserve">No intersection</doc>
      </member>
      <member name="enter" value="1" c:identifier="GRAPHENE_RAY_INTERSECTION_KIND_ENTER">
        <doc xml:space="preserve">The ray is entering the intersected
  object</doc>
      </member>
      <member name="leave" value="2" c:identifier="GRAPHENE_RAY_INTERSECTION_KIND_LEAVE">
        <doc xml:space="preserve">The ray is leaving the intersected
  object</doc>
      </member>
    </enumeration>
    <record name="Rect" c:type="graphene_rect_t" version="1.0" glib:type-name="GrapheneRect" glib:get-type="graphene_rect_get_type" c:symbol-prefix="rect">
      <doc xml:space="preserve">The location and size of a rectangle region.

The width and height of a #graphene_rect_t can be negative; for instance,
a #graphene_rect_t with an origin of [ 0, 0 ] and a size of [ 10, 10 ] is
equivalent to a #graphene_rect_t with an origin of [ 10, 10 ] and a size
of [ -10, -10 ].

Application code can normalize rectangles using graphene_rect_normalize();
this function will ensure that the width and height of a rectangle are
positive values. All functions taking a #graphene_rect_t as an argument
will internally operate on a normalized copy; all functions returning a
#graphene_rect_t will always return a normalized rectangle.</doc>
      <field name="origin" writable="1">
        <doc xml:space="preserve">the coordinates of the origin of the rectangle</doc>
        <type name="Point" c:type="graphene_point_t"/>
      </field>
      <field name="size" writable="1">
        <doc xml:space="preserve">the size of the rectangle</doc>
        <type name="Size" c:type="graphene_size_t"/>
      </field>
      <method name="contains_point" c:identifier="graphene_rect_contains_point" version="1.0">
        <doc xml:space="preserve">Checks whether a #graphene_rect_t contains the given coordinates.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the rectangle contains the point</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains_rect" c:identifier="graphene_rect_contains_rect" version="1.0">
        <doc xml:space="preserve">Checks whether a #graphene_rect_t fully contains the given
rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the rectangle @a fully contains @b</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_rect_equal" version="1.0">
        <doc xml:space="preserve">Checks whether the two given rectangle are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the rectangles are equal</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="expand" c:identifier="graphene_rect_expand" version="1.4">
        <doc xml:space="preserve">Expands a #graphene_rect_t to contain the given #graphene_point_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point_t</doc>
            <type name="Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the expanded rectangle</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_rect_free" version="1.0">
        <doc xml:space="preserve">Frees the resources allocated by graphene_rect_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_area" c:identifier="graphene_rect_get_area" version="1.10">
        <doc xml:space="preserve">Compute the area of given normalized rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the area of the normalized rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bottom_left" c:identifier="graphene_rect_get_bottom_left" version="1.0">
        <doc xml:space="preserve">Retrieves the coordinates of the bottom-left corner of the given rectangle.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="p" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_point_t</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bottom_right" c:identifier="graphene_rect_get_bottom_right" version="1.0">
        <doc xml:space="preserve">Retrieves the coordinates of the bottom-right corner of the given rectangle.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="p" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_point_t</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_center" c:identifier="graphene_rect_get_center" version="1.0">
        <doc xml:space="preserve">Retrieves the coordinates of the center of the given rectangle.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="p" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_point_t</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="graphene_rect_get_height" version="1.0">
        <doc xml:space="preserve">Retrieves the normalized height of the given rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the normalized height of the rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_top_left" c:identifier="graphene_rect_get_top_left" version="1.0">
        <doc xml:space="preserve">Retrieves the coordinates of the top-left corner of the given rectangle.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="p" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_point_t</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_top_right" c:identifier="graphene_rect_get_top_right" version="1.0">
        <doc xml:space="preserve">Retrieves the coordinates of the top-right corner of the given rectangle.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="p" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_point_t</doc>
            <type name="Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_vertices" c:identifier="graphene_rect_get_vertices" version="1.4">
        <doc xml:space="preserve">Computes the four vertices of a #graphene_rect_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="vertices" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for an array
 of 4 #graphene_vec2_t</doc>
            <array zero-terminated="0" c:type="graphene_vec2_t*" fixed-size="4">
              <type name="Vec2" c:type="graphene_vec2_t"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="graphene_rect_get_width" version="1.0">
        <doc xml:space="preserve">Retrieves the normalized width of the given rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the normalized width of the rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_x" c:identifier="graphene_rect_get_x" version="1.0">
        <doc xml:space="preserve">Retrieves the normalized X coordinate of the origin of the given
rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the normalized X coordinate of the rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_y" c:identifier="graphene_rect_get_y" version="1.0">
        <doc xml:space="preserve">Retrieves the normalized Y coordinate of the origin of the given
rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the normalized Y coordinate of the rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_rect_init" version="1.0">
        <doc xml:space="preserve">Initializes the given #graphene_rect_t with the given values.

This function will implicitly normalize the #graphene_rect_t
before returning.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="Rect" c:type="graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the X coordinate of the @graphene_rect_t.origin</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the Y coordinate of the @graphene_rect_t.origin</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">the width of the @graphene_rect_t.size</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">the height of the @graphene_rect_t.size</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_rect" c:identifier="graphene_rect_init_from_rect" version="1.0">
        <doc xml:space="preserve">Initializes @r using the given @src rectangle.

This function will implicitly normalize the #graphene_rect_t
before returning.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="Rect" c:type="graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="inset" c:identifier="graphene_rect_inset" version="1.0">
        <doc xml:space="preserve">Changes the given rectangle to be smaller, or larger depending on the
given inset parameters.

To create an inset rectangle, use positive @d_x or @d_y values; to
create a larger, encompassing rectangle, use negative @d_x or @d_y
values.

The origin of the rectangle is offset by @d_x and @d_y, while the size
is adjusted by `(2 * @d_x, 2 * @d_y)`. If @d_x and @d_y are positive
values, the size of the rectangle is decreased; if @d_x and @d_y are
negative values, the size of the rectangle is increased.

If the size of the resulting inset rectangle has a negative width or
height then the size will be set to zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the inset rectangle</doc>
          <type name="Rect" c:type="graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="d_x" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal inset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="d_y" transfer-ownership="none">
            <doc xml:space="preserve">the vertical inset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="inset_r" c:identifier="graphene_rect_inset_r" version="1.4">
        <doc xml:space="preserve">Changes the given rectangle to be smaller, or larger depending on the
given inset parameters.

To create an inset rectangle, use positive @d_x or @d_y values; to
create a larger, encompassing rectangle, use negative @d_x or @d_y
values.

The origin of the rectangle is offset by @d_x and @d_y, while the size
is adjusted by `(2 * @d_x, 2 * @d_y)`. If @d_x and @d_y are positive
values, the size of the rectangle is decreased; if @d_x and @d_y are
negative values, the size of the rectangle is increased.

If the size of the resulting inset rectangle has a negative width or
height then the size will be set to zero.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="d_x" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal inset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="d_y" transfer-ownership="none">
            <doc xml:space="preserve">the vertical inset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the inset rectangle</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="interpolate" c:identifier="graphene_rect_interpolate" version="1.0">
        <doc xml:space="preserve">Linearly interpolates the origin and size of the two given
rectangles.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the linear interpolation factor</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  interpolated rectangle</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersection" c:identifier="graphene_rect_intersection" version="1.0">
        <doc xml:space="preserve">Computes the intersection of the two given rectangles.

![](rectangle-intersection.png)

The intersection in the image above is the blue outline.

If the two rectangles do not intersect, @res will contain
a degenerate rectangle with origin in (0, 0) and a size of 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the two rectangles intersect</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for
  a #graphene_rect_t</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="graphene_rect_normalize" version="1.0">
        <doc xml:space="preserve">Normalizes the passed rectangle.

This function ensures that the size of the rectangle is made of
positive values, and that the origin is the top-left corner of
the rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the normalized rectangle</doc>
          <type name="Rect" c:type="graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="normalize_r" c:identifier="graphene_rect_normalize_r" version="1.4">
        <doc xml:space="preserve">Normalizes the passed rectangle.

This function ensures that the size of the rectangle is made of
positive values, and that the origin is in the top-left corner
of the rectangle.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the return location for the
  normalized rectangle</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="offset" c:identifier="graphene_rect_offset" version="1.0">
        <doc xml:space="preserve">Offsets the origin by @d_x and @d_y.

The size of the rectangle is unchanged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset rectangle</doc>
          <type name="Rect" c:type="graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="d_x" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="d_y" transfer-ownership="none">
            <doc xml:space="preserve">the vertical offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="offset_r" c:identifier="graphene_rect_offset_r" version="1.4">
        <doc xml:space="preserve">Offsets the origin of the given rectangle by @d_x and @d_y.

The size of the rectangle is left unchanged.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="d_x" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="d_y" transfer-ownership="none">
            <doc xml:space="preserve">the vertical offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the offset
  rectangle</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="round" c:identifier="graphene_rect_round" version="1.4" deprecated="1" deprecated-version="1.10">
        <doc xml:space="preserve">Rounds the origin and size of the given rectangle to
their nearest integer values; the rounding is guaranteed
to be large enough to have an area bigger or equal to the
original rectangle, but might not fully contain its extents.
Use graphene_rect_round_extents() in case you need to round
to a rectangle that covers fully the original one.

This function is the equivalent of calling `floor` on
the coordinates of the origin, and `ceil` on the size.</doc>
        <doc-deprecated xml:space="preserve">Use graphene_rect_round_extents() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  rounded rectangle</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="round_extents" c:identifier="graphene_rect_round_extents" version="1.10">
        <doc xml:space="preserve">Rounds the origin of the given rectangle to its nearest
integer value and and recompute the size so that the
rectangle is large enough to contain all the conrners
of the original rectangle.

This function is the equivalent of calling `floor` on
the coordinates of the origin, and recomputing the size
calling `ceil` on the bottom-right coordinates.

If you want to be sure that the rounded rectangle
completely covers the area that was covered by the
original rectangle &#x2014; i.e. you want to cover the area
including all its corners &#x2014; this function will make sure
that the size is recomputed taking into account the ceiling
of the coordinates of the bottom-right corner.
If the difference between the original coordinates and the
coordinates of the rounded rectangle is greater than the
difference between the original size and and the rounded
size, then the move of the origin would not be compensated
by a move in the anti-origin, leaving the corners of the
original rectangle outside the rounded one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  rectangle with rounded extents</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="round_to_pixel" c:identifier="graphene_rect_round_to_pixel" version="1.0" deprecated="1" deprecated-version="1.4">
        <doc xml:space="preserve">Rounds the origin and the size of the given rectangle to
their nearest integer values; the rounding is guaranteed
to be large enough to contain the original rectangle.</doc>
        <doc-deprecated xml:space="preserve">Use graphene_rect_round() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the pixel-aligned rectangle.</doc>
          <type name="Rect" c:type="graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="graphene_rect_scale" version="1.10">
        <doc xml:space="preserve">Scales the size and origin of a rectangle horizontaly by @s_h,
and vertically by @s_v. The result @res is normalized.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="r" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="s_h" transfer-ownership="none">
            <doc xml:space="preserve">horizontal scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="s_v" transfer-ownership="none">
            <doc xml:space="preserve">vertical scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  scaled rectangle</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="union" c:identifier="graphene_rect_union" version="1.0">
        <doc xml:space="preserve">Computes the union of the two given rectangles.

![](rectangle-union.png)

The union in the image above is the blue outline.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_rect_t</doc>
            <type name="Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <function name="alloc" c:identifier="graphene_rect_alloc" version="1.0">
        <doc xml:space="preserve">Allocates a new #graphene_rect_t.

The contents of the returned rectangle are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated rectangle</doc>
          <type name="Rect" c:type="graphene_rect_t*"/>
        </return-value>
      </function>
      <function name="zero" c:identifier="graphene_rect_zero" version="1.4">
        <doc xml:space="preserve">Returns a degenerate rectangle with origin fixed at (0, 0) and
a size of 0, 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a fixed rectangle</doc>
          <type name="Rect" c:type="const graphene_rect_t*"/>
        </return-value>
      </function>
    </record>
    <function-macro name="SIZE_INIT" c:identifier="GRAPHENE_SIZE_INIT" version="1.0" introspectable="0">
      <doc xml:space="preserve">Initializes a #graphene_size_t with the given sizes when
declaring it, e.g.:

|[&lt;!-- language="C" --&gt;
  graphene_size_t size = GRAPHENE_SIZE_INIT (100.f, 100.f);
]|</doc>
      <parameters>
        <parameter name="_w">
          <doc xml:space="preserve">the width</doc>
        </parameter>
        <parameter name="_h">
          <doc xml:space="preserve">the height</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="Simd4F" c:type="graphene_simd4f_t">
      <field name="x" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="w" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="Simd4X4F" c:type="graphene_simd4x4f_t">
      <field name="x" readable="0" private="1">
        <type name="Simd4F" c:type="graphene_simd4f_t"/>
      </field>
      <field name="y" readable="0" private="1">
        <type name="Simd4F" c:type="graphene_simd4f_t"/>
      </field>
      <field name="z" readable="0" private="1">
        <type name="Simd4F" c:type="graphene_simd4f_t"/>
      </field>
      <field name="w" readable="0" private="1">
        <type name="Simd4F" c:type="graphene_simd4f_t"/>
      </field>
    </record>
    <record name="Size" c:type="graphene_size_t" version="1.0" glib:type-name="GrapheneSize" glib:get-type="graphene_size_get_type" c:symbol-prefix="size">
      <doc xml:space="preserve">A size.</doc>
      <field name="width" writable="1">
        <doc xml:space="preserve">the width</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="height" writable="1">
        <doc xml:space="preserve">the height</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_size_alloc" version="1.0">
        <doc xml:space="preserve">Allocates a new #graphene_size_t.

The contents of the returned value are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_size_t</doc>
          <type name="Size" c:type="graphene_size_t*"/>
        </return-value>
      </constructor>
      <method name="equal" c:identifier="graphene_size_equal" version="1.0">
        <doc xml:space="preserve">Checks whether the two give #graphene_size_t are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the sizes are equal</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_size_t</doc>
            <type name="Size" c:type="const graphene_size_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_size_t</doc>
            <type name="Size" c:type="const graphene_size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_size_free" version="1.0">
        <doc xml:space="preserve">Frees the resources allocated by graphene_size_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_size_t</doc>
            <type name="Size" c:type="graphene_size_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_size_init" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_size_t using the given @width and @height.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_size_t</doc>
          <type name="Size" c:type="graphene_size_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_size_t</doc>
            <type name="Size" c:type="graphene_size_t*"/>
          </instance-parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">the width</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">the height</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_size" c:identifier="graphene_size_init_from_size" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_size_t using the width and height of
the given @src.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_size_t</doc>
          <type name="Size" c:type="graphene_size_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_size_t</doc>
            <type name="Size" c:type="graphene_size_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_size_t</doc>
            <type name="Size" c:type="const graphene_size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="interpolate" c:identifier="graphene_size_interpolate" version="1.0">
        <doc xml:space="preserve">Linearly interpolates the two given #graphene_size_t using the given
interpolation @factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_size_t</doc>
            <type name="Size" c:type="const graphene_size_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_size_t</doc>
            <type name="Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the linear interpolation factor</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the interpolated size</doc>
            <type name="Size" c:type="graphene_size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="graphene_size_scale" version="1.0">
        <doc xml:space="preserve">Scales the components of a #graphene_size_t using the given @factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_size_t</doc>
            <type name="Size" c:type="const graphene_size_t*"/>
          </instance-parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the scaling factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the scaled size</doc>
            <type name="Size" c:type="graphene_size_t*"/>
          </parameter>
        </parameters>
      </method>
      <function name="zero" c:identifier="graphene_size_zero" version="1.0">
        <doc xml:space="preserve">A constant pointer to a zero #graphene_size_t, useful for
equality checks and interpolations.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant size</doc>
          <type name="Size" c:type="const graphene_size_t*"/>
        </return-value>
      </function>
    </record>
    <record name="Sphere" c:type="graphene_sphere_t" version="1.2" glib:type-name="GrapheneSphere" glib:get-type="graphene_sphere_get_type" c:symbol-prefix="sphere">
      <doc xml:space="preserve">A sphere, represented by its center and radius.</doc>
      <field name="center" readable="0" private="1">
        <type name="Vec3" c:type="graphene_vec3_t"/>
      </field>
      <field name="radius" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_sphere_alloc" version="1.2">
        <doc xml:space="preserve">Allocates a new #graphene_sphere_t.

The contents of the newly allocated structure are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_sphere_t. Use
  graphene_sphere_free() to free the resources allocated by this function</doc>
          <type name="Sphere" c:type="graphene_sphere_t*"/>
        </return-value>
      </constructor>
      <method name="contains_point" c:identifier="graphene_sphere_contains_point" version="1.2">
        <doc xml:space="preserve">Checks whether the given @point is contained in the volume
of a #graphene_sphere_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the sphere contains the point</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="distance" c:identifier="graphene_sphere_distance" version="1.2">
        <doc xml:space="preserve">Computes the distance of the given @point from the surface of
a #graphene_sphere_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the distance of the point</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_sphere_equal" version="1.2">
        <doc xml:space="preserve">Checks whether two #graphene_sphere_t are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the spheres are equal</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_sphere_free" version="1.2">
        <doc xml:space="preserve">Frees the resources allocated by graphene_sphere_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="graphene_sphere_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bounding_box" c:identifier="graphene_sphere_get_bounding_box" version="1.2">
        <doc xml:space="preserve">Computes the bounding box capable of containing the
given #graphene_sphere_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </instance-parameter>
          <parameter name="box" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the bounding box</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_center" c:identifier="graphene_sphere_get_center" version="1.2">
        <doc xml:space="preserve">Retrieves the coordinates of the center of a #graphene_sphere_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </instance-parameter>
          <parameter name="center" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the coordinates of
  the center</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_radius" c:identifier="graphene_sphere_get_radius" version="1.2">
        <doc xml:space="preserve">Retrieves the radius of a #graphene_sphere_t.</doc>
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_sphere_init" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_sphere_t with the given @center and @radius.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_sphere_t</doc>
          <type name="Sphere" c:type="graphene_sphere_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_sphere_t to initialize</doc>
            <type name="Sphere" c:type="graphene_sphere_t*"/>
          </instance-parameter>
          <parameter name="center" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the coordinates of the center of the sphere, or %NULL
  for a center in (0, 0, 0)</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">the radius of the sphere</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_points" c:identifier="graphene_sphere_init_from_points" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_sphere_t using the given array
of 3D coordinates so that the sphere includes them.

The center of the sphere can either be specified, or will be center
of the 3D volume that encompasses all @points.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_sphere_t</doc>
          <type name="Sphere" c:type="graphene_sphere_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_sphere_t to initialize</doc>
            <type name="Sphere" c:type="graphene_sphere_t*"/>
          </instance-parameter>
          <parameter name="n_points" transfer-ownership="none">
            <doc xml:space="preserve">the number of #graphene_point3d_t in the @points array</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="points" transfer-ownership="none">
            <doc xml:space="preserve">an array of #graphene_point3d_t</doc>
            <array length="0" zero-terminated="0" c:type="const graphene_point3d_t*">
              <type name="Point3D" c:type="graphene_point3d_t"/>
            </array>
          </parameter>
          <parameter name="center" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the center of the sphere</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vectors" c:identifier="graphene_sphere_init_from_vectors" version="1.2">
        <doc xml:space="preserve">Initializes the given #graphene_sphere_t using the given array
of 3D coordinates so that the sphere includes them.

The center of the sphere can either be specified, or will be center
of the 3D volume that encompasses all @vectors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_sphere_t</doc>
          <type name="Sphere" c:type="graphene_sphere_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_sphere_t to initialize</doc>
            <type name="Sphere" c:type="graphene_sphere_t*"/>
          </instance-parameter>
          <parameter name="n_vectors" transfer-ownership="none">
            <doc xml:space="preserve">the number of #graphene_vec3_t in the @vectors array</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="vectors" transfer-ownership="none">
            <doc xml:space="preserve">an array of #graphene_vec3_t</doc>
            <array length="0" zero-terminated="0" c:type="const graphene_vec3_t*">
              <type name="Vec3" c:type="graphene_vec3_t"/>
            </array>
          </parameter>
          <parameter name="center" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the center of the sphere</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="graphene_sphere_is_empty" version="1.2">
        <doc xml:space="preserve">Checks whether the sphere has a zero radius.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the sphere is empty</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="graphene_sphere_translate" version="1.2">
        <doc xml:space="preserve">Translates the center of the given #graphene_sphere_t using the @point
coordinates as the delta of the translation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="s" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_sphere_t</doc>
            <type name="Sphere" c:type="const graphene_sphere_t*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates of the translation</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the translated sphere</doc>
            <type name="Sphere" c:type="graphene_sphere_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="Triangle" c:type="graphene_triangle_t" version="1.2" glib:type-name="GrapheneTriangle" glib:get-type="graphene_triangle_get_type" c:symbol-prefix="triangle">
      <doc xml:space="preserve">A triangle.</doc>
      <field name="a" readable="0" private="1">
        <type name="Vec3" c:type="graphene_vec3_t"/>
      </field>
      <field name="b" readable="0" private="1">
        <type name="Vec3" c:type="graphene_vec3_t"/>
      </field>
      <field name="c" readable="0" private="1">
        <type name="Vec3" c:type="graphene_vec3_t"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_triangle_alloc" version="1.2">
        <doc xml:space="preserve">Allocates a new #graphene_triangle_t.

The contents of the returned structure are undefined.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_triangle_t
  structure. Use graphene_triangle_free() to free the resources
  allocated by this function</doc>
          <type name="Triangle" c:type="graphene_triangle_t*"/>
        </return-value>
      </constructor>
      <method name="contains_point" c:identifier="graphene_triangle_contains_point" version="1.2">
        <doc xml:space="preserve">Checks whether the given triangle @t contains the point @p.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the point is inside the triangle</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_triangle_equal" version="1.2">
        <doc xml:space="preserve">Checks whether the two given #graphene_triangle_t are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the triangles are equal</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_triangle_free" version="1.2">
        <doc xml:space="preserve">Frees the resources allocated by graphene_triangle_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="graphene_triangle_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_area" c:identifier="graphene_triangle_get_area" version="1.2">
        <doc xml:space="preserve">Computes the area of the given #graphene_triangle_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the area of the triangle</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_barycoords" c:identifier="graphene_triangle_get_barycoords" version="1.2">
        <doc xml:space="preserve">Computes the [barycentric coordinates](http://en.wikipedia.org/wiki/Barycentric_coordinate_system)
of the given point @p.

The point @p must lie on the same plane as the triangle @t; if the
point is not coplanar, the result of this function is undefined.

If we place the origin in the coordinates of the triangle's A point,
the barycentric coordinates are `u`, which is on the AC vector; and `v`
which is on the AB vector:

![](triangle-barycentric.png)

The returned #graphene_vec2_t contains the following values, in order:

 - `res.x = u`
 - `res.y = v`</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the barycentric coordinates are valid</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the vector
  with the barycentric coordinates</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bounding_box" c:identifier="graphene_triangle_get_bounding_box" version="1.2">
        <doc xml:space="preserve">Computes the bounding box of the given #graphene_triangle_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the box</doc>
            <type name="Box" c:type="graphene_box_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_midpoint" c:identifier="graphene_triangle_get_midpoint" version="1.2">
        <doc xml:space="preserve">Computes the coordinates of the midpoint of the given #graphene_triangle_t.

The midpoint G is the [centroid](https://en.wikipedia.org/wiki/Centroid#Triangle_centroid)
of the triangle, i.e. the intersection of its medians.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the coordinates of
  the midpoint</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_normal" c:identifier="graphene_triangle_get_normal" version="1.2">
        <doc xml:space="preserve">Computes the normal vector of the given #graphene_triangle_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the normal vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_plane" c:identifier="graphene_triangle_get_plane" version="1.2">
        <doc xml:space="preserve">Computes the plane based on the vertices of the given #graphene_triangle_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the plane</doc>
            <type name="Plane" c:type="graphene_plane_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_points" c:identifier="graphene_triangle_get_points" version="1.2">
        <doc xml:space="preserve">Retrieves the three vertices of the given #graphene_triangle_t and returns
their coordinates as #graphene_point3d_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="a" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the coordinates
  of the first vertex</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
          <parameter name="b" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the coordinates
  of the second vertex</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
          <parameter name="c" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the coordinates
  of the third vertex</doc>
            <type name="Point3D" c:type="graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uv" c:identifier="graphene_triangle_get_uv" version="1.10">
        <doc xml:space="preserve">Computes the UV coordinates of the given point @p.

The point @p must lie on the same plane as the triangle @t; if the point
is not coplanar, the result of this function is undefined. If @p is %NULL,
the point will be set in (0, 0, 0).

The UV coordinates will be placed in the @res vector:

 - `res.x = u`
 - `res.y = v`

See also: graphene_triangle_get_barycoords()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the coordinates are valid</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="p" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="uv_a" transfer-ownership="none">
            <doc xml:space="preserve">the UV coordinates of the first point</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="uv_b" transfer-ownership="none">
            <doc xml:space="preserve">the UV coordinates of the second point</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="uv_c" transfer-ownership="none">
            <doc xml:space="preserve">the UV coordinates of the third point</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">a vector containing the UV coordinates
  of the given point @p</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_vertices" c:identifier="graphene_triangle_get_vertices" version="1.2">
        <doc xml:space="preserve">Retrieves the three vertices of the given #graphene_triangle_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_triangle_t</doc>
            <type name="Triangle" c:type="const graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="a" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the first vertex</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
          <parameter name="b" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the second vertex</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
          <parameter name="c" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the third vertex</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_float" c:identifier="graphene_triangle_init_from_float" version="1.10">
        <doc xml:space="preserve">Initializes a #graphene_triangle_t using the three given arrays
of floating point values, each representing the coordinates of
a point in 3D space.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_triangle_t</doc>
          <type name="Triangle" c:type="graphene_triangle_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_triangle_t to initialize</doc>
            <type name="Triangle" c:type="graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">an array of 3 floating point values</doc>
            <array zero-terminated="0" c:type="const float*" fixed-size="3">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">an array of 3 floating point values</doc>
            <array zero-terminated="0" c:type="const float*" fixed-size="3">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <doc xml:space="preserve">an array of 3 floating point values</doc>
            <array zero-terminated="0" c:type="const float*" fixed-size="3">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_point3d" c:identifier="graphene_triangle_init_from_point3d" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_triangle_t using the three given 3D points.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_triangle_t</doc>
          <type name="Triangle" c:type="graphene_triangle_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_triangle_t to initialize</doc>
            <type name="Triangle" c:type="graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
          <parameter name="c" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_point3d_t</doc>
            <type name="Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec3" c:identifier="graphene_triangle_init_from_vec3" version="1.2">
        <doc xml:space="preserve">Initializes a #graphene_triangle_t using the three given vectors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized #graphene_triangle_t</doc>
          <type name="Triangle" c:type="graphene_triangle_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">the #graphene_triangle_t to initialize</doc>
            <type name="Triangle" c:type="graphene_triangle_t*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="c" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <function-macro name="UNAVAILABLE" c:identifier="GRAPHENE_UNAVAILABLE" introspectable="0">
      <parameters>
        <parameter name="maj">
        </parameter>
        <parameter name="min">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="VEC2_LEN" value="2" c:type="GRAPHENE_VEC2_LEN" version="1.0">
      <doc xml:space="preserve">Evaluates to the number of components of a #graphene_vec2_t.

This symbol is useful when declaring a C array of floating
point values to be used with graphene_vec2_init_from_float() and
graphene_vec2_to_float(), e.g.

|[
  float v[GRAPHENE_VEC2_LEN];

  // vec is defined elsewhere
  graphene_vec2_to_float (&amp;vec, v);

  for (int i = 0; i &lt; GRAPHENE_VEC2_LEN; i++)
    fprintf (stdout, "component %d: %g\n", i, v[i]);
]|</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VEC3_LEN" value="3" c:type="GRAPHENE_VEC3_LEN" version="1.0">
      <doc xml:space="preserve">Evaluates to the number of components of a #graphene_vec3_t.

This symbol is useful when declaring a C array of floating
point values to be used with graphene_vec3_init_from_float() and
graphene_vec3_to_float(), e.g.

|[
  float v[GRAPHENE_VEC3_LEN];

  // vec is defined elsewhere
  graphene_vec3_to_float (&amp;vec, v);

  for (int i = 0; i &lt; GRAPHENE_VEC2_LEN; i++)
    fprintf (stdout, "component %d: %g\n", i, v[i]);
]|</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VEC4_LEN" value="4" c:type="GRAPHENE_VEC4_LEN" version="1.0">
      <doc xml:space="preserve">Evaluates to the number of components of a #graphene_vec4_t.

This symbol is useful when declaring a C array of floating
point values to be used with graphene_vec4_init_from_float() and
graphene_vec4_to_float(), e.g.

|[
  float v[GRAPHENE_VEC4_LEN];

  // vec is defined elsewhere
  graphene_vec4_to_float (&amp;vec, v);

  for (int i = 0; i &lt; GRAPHENE_VEC4_LEN; i++)
    fprintf (stdout, "component %d: %g\n", i, v[i]);
]|</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Vec2" c:type="graphene_vec2_t" glib:type-name="GrapheneVec2" glib:get-type="graphene_vec2_get_type" c:symbol-prefix="vec2">
      <doc xml:space="preserve">A structure capable of holding a vector with two dimensions, x and y.

The contents of the #graphene_vec2_t structure are private and should
never be accessed directly.</doc>
      <field name="value" readable="0" private="1">
        <type name="Simd4F" c:type="graphene_simd4f_t"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_vec2_alloc" version="1.0">
        <doc xml:space="preserve">Allocates a new #graphene_vec2_t structure.

The contents of the returned structure are undefined.

Use graphene_vec2_init() to initialize the vector.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_vec2_t
  structure. Use graphene_vec2_free() to free the resources allocated
  by this function.</doc>
          <type name="Vec2" c:type="graphene_vec2_t*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="graphene_vec2_add" version="1.0">
        <doc xml:space="preserve">Adds each component of the two passed vectors and places
each result into the components of @res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="divide" c:identifier="graphene_vec2_divide" version="1.0">
        <doc xml:space="preserve">Divides each component of the first operand @a by the corresponding
component of the second operand @b, and places the results into the
vector @res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dot" c:identifier="graphene_vec2_dot" version="1.0">
        <doc xml:space="preserve">Computes the dot product of the two given vectors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the dot product of the vectors</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_vec2_equal" version="1.2">
        <doc xml:space="preserve">Checks whether the two given #graphene_vec2_t are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the two vectors are equal, and false otherwise</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_vec2_free" version="1.0">
        <doc xml:space="preserve">Frees the resources allocated by @v</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_x" c:identifier="graphene_vec2_get_x" version="1.0">
        <doc xml:space="preserve">Retrieves the X component of the #graphene_vec2_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the X component</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_y" c:identifier="graphene_vec2_get_y" version="1.0">
        <doc xml:space="preserve">Retrieves the Y component of the #graphene_vec2_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the Y component</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_vec2_init" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_vec2_t using the given values.

This function can be called multiple times.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized vector</doc>
          <type name="Vec2" c:type="graphene_vec2_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the X field of the vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the Y field of the vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_float" c:identifier="graphene_vec2_init_from_float" version="1.0">
        <doc xml:space="preserve">Initializes @v with the contents of the given array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized vector</doc>
          <type name="Vec2" c:type="graphene_vec2_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">an array of floating point values
  with at least two elements</doc>
            <array zero-terminated="0" c:type="const float*" fixed-size="2">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec2" c:identifier="graphene_vec2_init_from_vec2" version="1.0">
        <doc xml:space="preserve">Copies the contents of @src into @v.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized vector</doc>
          <type name="Vec2" c:type="graphene_vec2_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="interpolate" c:identifier="graphene_vec2_interpolate" version="1.10">
        <doc xml:space="preserve">Linearly interpolates @v1 and @v2 using the given @factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the interpolation factor</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the interpolated vector</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="length" c:identifier="graphene_vec2_length" version="1.0">
        <doc xml:space="preserve">Computes the length of the given vector.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the vector</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="max" c:identifier="graphene_vec2_max" version="1.0">
        <doc xml:space="preserve">Compares the two given vectors and places the maximum
values of each component into @res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the resulting vector</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="min" c:identifier="graphene_vec2_min" version="1.0">
        <doc xml:space="preserve">Compares the two given vectors and places the minimum
values of each component into @res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the resulting vector</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="graphene_vec2_multiply" version="1.0">
        <doc xml:space="preserve">Multiplies each component of the two passed vectors and places
each result into the components of @res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="near" c:identifier="graphene_vec2_near" version="1.2">
        <doc xml:space="preserve">Compares the two given #graphene_vec2_t vectors and checks
whether their values are within the given @epsilon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the two vectors are near each other</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="epsilon" transfer-ownership="none">
            <doc xml:space="preserve">the threshold between the two vectors</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="negate" c:identifier="graphene_vec2_negate" version="1.2">
        <doc xml:space="preserve">Negates the given #graphene_vec2_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result vector</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="graphene_vec2_normalize" version="1.0">
        <doc xml:space="preserve">Computes the normalized vector for the given vector @v.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the
  normalized vector</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="graphene_vec2_scale" version="1.2">
        <doc xml:space="preserve">Multiplies all components of the given vector with the given scalar @factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the scalar factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result vector</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract" c:identifier="graphene_vec2_subtract" version="1.0">
        <doc xml:space="preserve">Subtracts from each component of the first operand @a the
corresponding component of the second operand @b and places
each result into the components of @res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_float" c:identifier="graphene_vec2_to_float" version="1.0">
        <doc xml:space="preserve">Stores the components of @v into an array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </instance-parameter>
          <parameter name="dest" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location
  for an array of floating point values with at least 2 elements</doc>
            <array zero-terminated="0" c:type="float*" fixed-size="2">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <function name="one" c:identifier="graphene_vec2_one" version="1.0">
        <doc xml:space="preserve">Retrieves a constant vector with (1, 1) components.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the one vector</doc>
          <type name="Vec2" c:type="const graphene_vec2_t*"/>
        </return-value>
      </function>
      <function name="x_axis" c:identifier="graphene_vec2_x_axis" version="1.0">
        <doc xml:space="preserve">Retrieves a constant vector with (1, 0) components.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the X axis vector</doc>
          <type name="Vec2" c:type="const graphene_vec2_t*"/>
        </return-value>
      </function>
      <function name="y_axis" c:identifier="graphene_vec2_y_axis" version="1.0">
        <doc xml:space="preserve">Retrieves a constant vector with (0, 1) components.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Y axis vector</doc>
          <type name="Vec2" c:type="const graphene_vec2_t*"/>
        </return-value>
      </function>
      <function name="zero" c:identifier="graphene_vec2_zero" version="1.0">
        <doc xml:space="preserve">Retrieves a constant vector with (0, 0) components.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the zero vector</doc>
          <type name="Vec2" c:type="const graphene_vec2_t*"/>
        </return-value>
      </function>
    </record>
    <record name="Vec3" c:type="graphene_vec3_t" glib:type-name="GrapheneVec3" glib:get-type="graphene_vec3_get_type" c:symbol-prefix="vec3">
      <doc xml:space="preserve">A structure capable of holding a vector with three dimensions: x, y, and z.

The contents of the #graphene_vec3_t structure are private and should
never be accessed directly.</doc>
      <field name="value" readable="0" private="1">
        <type name="Simd4F" c:type="graphene_simd4f_t"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_vec3_alloc" version="1.0">
        <doc xml:space="preserve">Allocates a new #graphene_vec3_t structure.

The contents of the returned structure are undefined.

Use graphene_vec3_init() to initialize the vector.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_vec3_t
  structure. Use graphene_vec3_free() to free the resources allocated
  by this function.</doc>
          <type name="Vec3" c:type="graphene_vec3_t*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="graphene_vec3_add" version="1.0">
        <doc xml:space="preserve">Adds each component of the two given vectors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the resulting vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="cross" c:identifier="graphene_vec3_cross" version="1.0">
        <doc xml:space="preserve">Computes the cross product of the two given vectors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the resulting vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="divide" c:identifier="graphene_vec3_divide" version="1.0">
        <doc xml:space="preserve">Divides each component of the first operand @a by the corresponding
component of the second operand @b, and places the results into the
vector @res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the resulting vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dot" c:identifier="graphene_vec3_dot" version="1.0">
        <doc xml:space="preserve">Computes the dot product of the two given vectors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the dot product</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_vec3_equal" version="1.2">
        <doc xml:space="preserve">Checks whether the two given #graphene_vec3_t are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the two vectors are equal, and false otherwise</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_vec3_free" version="1.0">
        <doc xml:space="preserve">Frees the resources allocated by @v</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_x" c:identifier="graphene_vec3_get_x" version="1.0">
        <doc xml:space="preserve">Retrieves the first component of the given vector @v.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the first component of the vector</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_xy" c:identifier="graphene_vec3_get_xy" version="1.0">
        <doc xml:space="preserve">Creates a #graphene_vec2_t that contains the first and second
components of the given #graphene_vec3_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_xy0" c:identifier="graphene_vec3_get_xy0" version="1.0">
        <doc xml:space="preserve">Creates a #graphene_vec3_t that contains the first two components of
the given #graphene_vec3_t, and the third component set to 0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_xyz0" c:identifier="graphene_vec3_get_xyz0" version="1.0">
        <doc xml:space="preserve">Converts a #graphene_vec3_t in a #graphene_vec4_t using 0.0
as the value for the fourth component of the resulting vector.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_xyz1" c:identifier="graphene_vec3_get_xyz1" version="1.0">
        <doc xml:space="preserve">Converts a #graphene_vec3_t in a #graphene_vec4_t using 1.0
as the value for the fourth component of the resulting vector.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_xyzw" c:identifier="graphene_vec3_get_xyzw" version="1.0">
        <doc xml:space="preserve">Converts a #graphene_vec3_t in a #graphene_vec4_t using @w as
the value of the fourth component of the resulting vector.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="w" transfer-ownership="none">
            <doc xml:space="preserve">the value of the W component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_y" c:identifier="graphene_vec3_get_y" version="1.0">
        <doc xml:space="preserve">Retrieves the second component of the given vector @v.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the second component of the vector</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_z" c:identifier="graphene_vec3_get_z" version="1.0">
        <doc xml:space="preserve">Retrieves the third component of the given vector @v.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the third component of the vector</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_vec3_init" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_vec3_t using the given values.

This function can be called multiple times.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the initialized
  vector</doc>
          <type name="Vec3" c:type="graphene_vec3_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the X field of the vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the Y field of the vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">the Z field of the vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_float" c:identifier="graphene_vec3_init_from_float" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_vec3_t with the values from an array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized vector</doc>
          <type name="Vec3" c:type="graphene_vec3_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">an array of 3 floating point values</doc>
            <array zero-terminated="0" c:type="const float*" fixed-size="3">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec3" c:identifier="graphene_vec3_init_from_vec3" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_vec3_t with the values of another
#graphene_vec3_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized vector</doc>
          <type name="Vec3" c:type="graphene_vec3_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="interpolate" c:identifier="graphene_vec3_interpolate" version="1.10">
        <doc xml:space="preserve">Linearly interpolates @v1 and @v2 using the given @factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the interpolation factor</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the interpolated vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="length" c:identifier="graphene_vec3_length" version="1.0">
        <doc xml:space="preserve">Retrieves the length of the given vector @v.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the length of the vector</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="max" c:identifier="graphene_vec3_max" version="1.0">
        <doc xml:space="preserve">Compares each component of the two given vectors and creates a
vector that contains the maximum values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="min" c:identifier="graphene_vec3_min" version="1.0">
        <doc xml:space="preserve">Compares each component of the two given vectors and creates a
vector that contains the minimum values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="graphene_vec3_multiply" version="1.0">
        <doc xml:space="preserve">Multiplies each component of the two given vectors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the resulting vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="near" c:identifier="graphene_vec3_near" version="1.2">
        <doc xml:space="preserve">Compares the two given #graphene_vec3_t vectors and checks
whether their values are within the given @epsilon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the two vectors are near each other</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="epsilon" transfer-ownership="none">
            <doc xml:space="preserve">the threshold between the two vectors</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="negate" c:identifier="graphene_vec3_negate" version="1.2">
        <doc xml:space="preserve">Negates the given #graphene_vec3_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="graphene_vec3_normalize" version="1.0">
        <doc xml:space="preserve">Normalizes the given #graphene_vec3_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the normalized vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="graphene_vec3_scale" version="1.2">
        <doc xml:space="preserve">Multiplies all components of the given vector with the given scalar @factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the scalar factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract" c:identifier="graphene_vec3_subtract" version="1.0">
        <doc xml:space="preserve">Subtracts from each component of the first operand @a the
corresponding component of the second operand @b and places
each result into the components of @res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the resulting vector</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_float" c:identifier="graphene_vec3_to_float" version="1.0">
        <doc xml:space="preserve">Copies the components of a #graphene_vec3_t into the given array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </instance-parameter>
          <parameter name="dest" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for
  an array of floating point values</doc>
            <array zero-terminated="0" c:type="float*" fixed-size="3">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <function name="one" c:identifier="graphene_vec3_one" version="1.0">
        <doc xml:space="preserve">Provides a constant pointer to a vector with three components,
all sets to 1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant vector</doc>
          <type name="Vec3" c:type="const graphene_vec3_t*"/>
        </return-value>
      </function>
      <function name="x_axis" c:identifier="graphene_vec3_x_axis" version="1.0">
        <doc xml:space="preserve">Provides a constant pointer to a vector with three components
with values set to (1, 0, 0).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant vector</doc>
          <type name="Vec3" c:type="const graphene_vec3_t*"/>
        </return-value>
      </function>
      <function name="y_axis" c:identifier="graphene_vec3_y_axis" version="1.0">
        <doc xml:space="preserve">Provides a constant pointer to a vector with three components
with values set to (0, 1, 0).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant vector</doc>
          <type name="Vec3" c:type="const graphene_vec3_t*"/>
        </return-value>
      </function>
      <function name="z_axis" c:identifier="graphene_vec3_z_axis" version="1.0">
        <doc xml:space="preserve">Provides a constant pointer to a vector with three components
with values set to (0, 0, 1).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant vector</doc>
          <type name="Vec3" c:type="const graphene_vec3_t*"/>
        </return-value>
      </function>
      <function name="zero" c:identifier="graphene_vec3_zero" version="1.0">
        <doc xml:space="preserve">Provides a constant pointer to a vector with three components,
all sets to 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant vector</doc>
          <type name="Vec3" c:type="const graphene_vec3_t*"/>
        </return-value>
      </function>
    </record>
    <record name="Vec4" c:type="graphene_vec4_t" glib:type-name="GrapheneVec4" glib:get-type="graphene_vec4_get_type" c:symbol-prefix="vec4">
      <doc xml:space="preserve">A structure capable of holding a vector with four dimensions: x, y, z, and w.

The contents of the #graphene_vec4_t structure are private and should
never be accessed directly.</doc>
      <field name="value" readable="0" private="1">
        <type name="Simd4F" c:type="graphene_simd4f_t"/>
      </field>
      <constructor name="alloc" c:identifier="graphene_vec4_alloc" version="1.0">
        <doc xml:space="preserve">Allocates a new #graphene_vec4_t structure.

The contents of the returned structure are undefined.

Use graphene_vec4_init() to initialize the vector.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated #graphene_vec4_t
  structure. Use graphene_vec4_free() to free the resources allocated
  by this function.</doc>
          <type name="Vec4" c:type="graphene_vec4_t*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="graphene_vec4_add" version="1.0">
        <doc xml:space="preserve">Adds each component of the two given vectors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the resulting vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="divide" c:identifier="graphene_vec4_divide" version="1.0">
        <doc xml:space="preserve">Divides each component of the first operand @a by the corresponding
component of the second operand @b, and places the results into the
vector @res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the resulting vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dot" c:identifier="graphene_vec4_dot" version="1.0">
        <doc xml:space="preserve">Computes the dot product of the two given vectors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the dot product</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="graphene_vec4_equal" version="1.2">
        <doc xml:space="preserve">Checks whether the two given #graphene_vec4_t are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the two vectors are equal, and false otherwise</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="graphene_vec4_free" version="1.0">
        <doc xml:space="preserve">Frees the resources allocated by @v</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_w" c:identifier="graphene_vec4_get_w" version="1.0">
        <doc xml:space="preserve">Retrieves the value of the fourth component of the given #graphene_vec4_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the fourth component</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_x" c:identifier="graphene_vec4_get_x" version="1.0">
        <doc xml:space="preserve">Retrieves the value of the first component of the given #graphene_vec4_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the first component</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_xy" c:identifier="graphene_vec4_get_xy" version="1.0">
        <doc xml:space="preserve">Creates a #graphene_vec2_t that contains the first two components
of the given #graphene_vec4_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_xyz" c:identifier="graphene_vec4_get_xyz" version="1.0">
        <doc xml:space="preserve">Creates a #graphene_vec3_t that contains the first three components
of the given #graphene_vec4_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for a graphene_vec3_t</doc>
            <type name="Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_y" c:identifier="graphene_vec4_get_y" version="1.0">
        <doc xml:space="preserve">Retrieves the value of the second component of the given #graphene_vec4_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the second component</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_z" c:identifier="graphene_vec4_get_z" version="1.0">
        <doc xml:space="preserve">Retrieves the value of the third component of the given #graphene_vec4_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the third component</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="graphene_vec4_init" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_vec4_t using the given values.

This function can be called multiple times.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the initialized
  vector</doc>
          <type name="Vec4" c:type="graphene_vec4_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the X field of the vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the Y field of the vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">the Z field of the vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="w" transfer-ownership="none">
            <doc xml:space="preserve">the W field of the vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_float" c:identifier="graphene_vec4_init_from_float" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_vec4_t with the values inside the given array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized vector</doc>
          <type name="Vec4" c:type="graphene_vec4_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">an array of four floating point values</doc>
            <array zero-terminated="0" c:type="const float*" fixed-size="4">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec2" c:identifier="graphene_vec4_init_from_vec2" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_vec4_t using the components of a
#graphene_vec2_t and the values of @z and @w.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized vector</doc>
          <type name="Vec4" c:type="graphene_vec4_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec2_t</doc>
            <type name="Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">the value for the third component of @v</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="w" transfer-ownership="none">
            <doc xml:space="preserve">the value for the fourth component of @v</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec3" c:identifier="graphene_vec4_init_from_vec3" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_vec4_t using the components of a
#graphene_vec3_t and the value of @w.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized vector</doc>
          <type name="Vec4" c:type="graphene_vec4_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec3_t</doc>
            <type name="Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
          <parameter name="w" transfer-ownership="none">
            <doc xml:space="preserve">the value for the fourth component of @v</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_vec4" c:identifier="graphene_vec4_init_from_vec4" version="1.0">
        <doc xml:space="preserve">Initializes a #graphene_vec4_t using the components of
another #graphene_vec4_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized vector</doc>
          <type name="Vec4" c:type="graphene_vec4_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="interpolate" c:identifier="graphene_vec4_interpolate" version="1.10">
        <doc xml:space="preserve">Linearly interpolates @v1 and @v2 using the given @factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the interpolation factor</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the interpolated vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="length" c:identifier="graphene_vec4_length" version="1.0">
        <doc xml:space="preserve">Computes the length of the given #graphene_vec4_t.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the vector</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="max" c:identifier="graphene_vec4_max" version="1.0">
        <doc xml:space="preserve">Compares each component of the two given vectors and creates a
vector that contains the maximum values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="min" c:identifier="graphene_vec4_min" version="1.0">
        <doc xml:space="preserve">Compares each component of the two given vectors and creates a
vector that contains the minimum values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="graphene_vec4_multiply" version="1.0">
        <doc xml:space="preserve">Multiplies each component of the two given vectors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the resulting vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="near" c:identifier="graphene_vec4_near" version="1.2">
        <doc xml:space="preserve">Compares the two given #graphene_vec4_t vectors and checks
whether their values are within the given @epsilon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`true` if the two vectors are near each other</doc>
          <type name="gboolean" c:type="_Bool"/>
        </return-value>
        <parameters>
          <instance-parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="epsilon" transfer-ownership="none">
            <doc xml:space="preserve">the threshold between the two vectors</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="negate" c:identifier="graphene_vec4_negate" version="1.2">
        <doc xml:space="preserve">Negates the given #graphene_vec4_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="graphene_vec4_normalize" version="1.0">
        <doc xml:space="preserve">Normalizes the given #graphene_vec4_t.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the normalized
  vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="graphene_vec4_scale" version="1.2">
        <doc xml:space="preserve">Multiplies all components of the given vector with the given scalar @factor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="factor" transfer-ownership="none">
            <doc xml:space="preserve">the scalar factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract" c:identifier="graphene_vec4_subtract" version="1.0">
        <doc xml:space="preserve">Subtracts from each component of the first operand @a the
corresponding component of the second operand @b and places
each result into the components of @res.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
          <parameter name="res" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the resulting vector</doc>
            <type name="Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_float" c:identifier="graphene_vec4_to_float" version="1.0">
        <doc xml:space="preserve">Stores the components of the given #graphene_vec4_t into an array
of floating point values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_vec4_t</doc>
            <type name="Vec4" c:type="const graphene_vec4_t*"/>
          </instance-parameter>
          <parameter name="dest" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for
  an array of floating point values</doc>
            <array zero-terminated="0" c:type="float*" fixed-size="4">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <function name="one" c:identifier="graphene_vec4_one" version="1.0">
        <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with all its
components set to 1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant vector</doc>
          <type name="Vec4" c:type="const graphene_vec4_t*"/>
        </return-value>
      </function>
      <function name="w_axis" c:identifier="graphene_vec4_w_axis" version="1.0">
        <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with its
components set to (0, 0, 0, 1).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant vector</doc>
          <type name="Vec4" c:type="const graphene_vec4_t*"/>
        </return-value>
      </function>
      <function name="x_axis" c:identifier="graphene_vec4_x_axis" version="1.0">
        <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with its
components set to (1, 0, 0, 0).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant vector</doc>
          <type name="Vec4" c:type="const graphene_vec4_t*"/>
        </return-value>
      </function>
      <function name="y_axis" c:identifier="graphene_vec4_y_axis" version="1.0">
        <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with its
components set to (0, 1, 0, 0).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant vector</doc>
          <type name="Vec4" c:type="const graphene_vec4_t*"/>
        </return-value>
      </function>
      <function name="z_axis" c:identifier="graphene_vec4_z_axis" version="1.0">
        <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with its
components set to (0, 0, 1, 0).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant vector</doc>
          <type name="Vec4" c:type="const graphene_vec4_t*"/>
        </return-value>
      </function>
      <function name="zero" c:identifier="graphene_vec4_zero" version="1.0">
        <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with all its
components set to 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant vector</doc>
          <type name="Vec4" c:type="const graphene_vec4_t*"/>
        </return-value>
      </function>
    </record>
    <function name="box_empty" c:identifier="graphene_box_empty" moved-to="Box.empty" version="1.2">
      <doc xml:space="preserve">A degenerate #graphene_box_t that can only be expanded.

The returned value is owned by Graphene and should not be modified or freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #graphene_box_t</doc>
        <type name="Box" c:type="const graphene_box_t*"/>
      </return-value>
    </function>
    <function name="box_infinite" c:identifier="graphene_box_infinite" moved-to="Box.infinite" version="1.2">
      <doc xml:space="preserve">A degenerate #graphene_box_t that cannot be expanded.

The returned value is owned by Graphene and should not be modified or freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #graphene_box_t</doc>
        <type name="Box" c:type="const graphene_box_t*"/>
      </return-value>
    </function>
    <function name="box_minus_one" c:identifier="graphene_box_minus_one" moved-to="Box.minus_one" version="1.2">
      <doc xml:space="preserve">A #graphene_box_t with the minimum vertex set at (-1, -1, -1) and the
maximum vertex set at (0, 0, 0).

The returned value is owned by Graphene and should not be modified or freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #graphene_box_t</doc>
        <type name="Box" c:type="const graphene_box_t*"/>
      </return-value>
    </function>
    <function name="box_one" c:identifier="graphene_box_one" moved-to="Box.one" version="1.2">
      <doc xml:space="preserve">A #graphene_box_t with the minimum vertex set at (0, 0, 0) and the
maximum vertex set at (1, 1, 1).

The returned value is owned by Graphene and should not be modified or freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #graphene_box_t</doc>
        <type name="Box" c:type="const graphene_box_t*"/>
      </return-value>
    </function>
    <function name="box_one_minus_one" c:identifier="graphene_box_one_minus_one" moved-to="Box.one_minus_one" version="1.2">
      <doc xml:space="preserve">A #graphene_box_t with the minimum vertex set at (-1, -1, -1) and the
maximum vertex set at (1, 1, 1).

The returned value is owned by Graphene and should not be modified or freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #graphene_box_t</doc>
        <type name="Box" c:type="const graphene_box_t*"/>
      </return-value>
    </function>
    <function name="box_zero" c:identifier="graphene_box_zero" moved-to="Box.zero" version="1.2">
      <doc xml:space="preserve">A #graphene_box_t with both the minimum and maximum vertices set at (0, 0, 0).

The returned value is owned by Graphene and should not be modified or freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #graphene_box_t</doc>
        <type name="Box" c:type="const graphene_box_t*"/>
      </return-value>
    </function>
    <docsection name="graphene-box">
      <doc xml:space="preserve">#graphene_box_t provides a representation of an axis aligned minimum
bounding box using the coordinates of its minimum and maximum vertices.</doc>
    </docsection>
    <docsection name="graphene-euler">
      <doc xml:space="preserve">The #graphene_euler_t structure defines a rotation along three axes using
three angles. It also optionally can describe the order of the rotations.

[Euler's rotation theorem](https://en.wikipedia.org/wiki/Euler%27s_rotation_theorem)
states that, in three-dimensional space, any displacement of a rigid body
such that a point on the rigid body remains fixed, is equivalent to a single
rotation about some axis that runs through the fixed point. The angles on
each axis can be placed in a vector of three components&#x2014;&#x3B1;, &#x3B2;, and &#x3B3;&#x2014;called
the *Euler angle vector*. Each rotation described by these components results
in a rotation matrix:

|[
  rot(&#x3B1;) = A
  rot(&#x3B2;) = B
  rot(&#x3B3;) = G
]|

The resulting rotation matrix expressed by the Euler angle vector is
given by the product of each rotation matrix:

|[
  G &#xD7; B &#xD7; A = R
]|

In order to specify the meaning of an Euler angle vector, we need to
assign each axis of rotation to the corresponding &#x3B1;, &#x3B2;, and &#x3B3; components,
for instance X, Y, and Z.

Additionally, we need to specify whether the rotations move the axes
as they are applied, also known as intrinsic, or relative rotations;
or if the axes stay fixed and the vectors move within the axis frame,
also known as extrinsic, or static rotations. For instance, a static
rotation alongside the ZYX axes will be interpreted as relative to
extrinsic coordinate axes, and be performed, in order, about the Z,
Y, and finally X axis. A relative rotation alongside the ZXZ axes will
be interpreted as relative to intrinsic coordinate axes, and be
performed, in order, about the Z axis, about the rotated X axis, and
finally about the rotated Z axis.

Finally, we need to define the direction of the rotation, or the handedness
of the coordinate system. In the case of Graphene, the direction is given
by the right-hand rule, which means all rotations are counterclockwise.

Rotations described Euler angles are typically immediately understandable,
compared to rotations expressed using quaternions, but they are susceptible
of ["Gimbal lock"](http://en.wikipedia.org/wiki/Gimbal_lock) &#x2014; the loss of
one degree of freedom caused by two axis on the same plane. You typically
should use #graphene_euler_t to expose rotation angles in your API, or to
store them, but use #graphene_quaternion_t to apply rotations to modelview
matrices, or interpolate between initial and final rotation transformations.

For more information, see:

  - http://en.wikipedia.org/wiki/Rotation_matrix
  - http://en.wikipedia.org/wiki/Euler_angles
  - http://mathworld.wolfram.com/EulerAngles.html
  - "Representing Attitude with Euler Angles and Quaternions: A
    Reference" by James Diebel, 2006
  - "Graphics Gems IV", edited by Paul Heckbert, Academic Press, 1994.

See also: #graphene_quaternion_t.</doc>
    </docsection>
    <docsection name="graphene-frustum">
      <doc xml:space="preserve">A #graphene_frustum_t represents a volume of space delimited by planes. It
is usually employed to represent the field of view of a camera, and can be
used to determine whether an object falls within that view, to efficiently
remove invisible objects from the render process.</doc>
    </docsection>
    <docsection name="graphene-gobject">
      <doc xml:space="preserve">Graphene optionally provides information for using its own types with
GObject properties and signals.

## Using Graphene with GObject

In order to discover at compile time if Graphene exposes type information
for the GType type system, you need to check if the `graphene-gobject-1.0`
pkg-config file exists.

If you're using Meson to build your project, you can use a typical
`dependency()` object, for instance:

|[&lt;!-- language="plain" --&gt;
  graphene_dep = dependency('graphene-gobject-1.0')
]|

If you're using Autotools to build your project, you can use the
`PKG_CHECK_EXISTS` m4 macro, for instance:

|[&lt;!-- language="plain" --&gt;
  PKG_CHECK_EXISTS([graphene-gobject-1.0],
                   [action-if-found],
                   [action-if-not-found]
]|

All the types provided by Graphene are boxed types, which means you
will have to use the #GBoxed API when dealing with #GValue, #GParamSpec,
and signal marshallers. For instance, to install a property in a #GObject
class that uses #graphene_rect_t, you can use:

|[&lt;!-- language="C" --&gt;
  g_object_class_install_property (object_class, PROP_BOUNDS,
    g_param_spec_boxed ("bounds", "Bounds", "Bounds of an object",
                        GRAPHENE_TYPE_RECT,
                        G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
]|

You'll then need to use g_value_set_boxed() and g_value_get_boxed()
in order to access the #graphene_rect_t pointer from the #GValue data
structure.

Whereas for creating a new signal that has a #graphene_point_t parameter
you can use:

|[&lt;!-- language="C" --&gt;
  signals[HIT_TEST] =
    g_signal_new ("hit-test",
                  G_TYPE_FROM_CLASS (object_class),
                  G_SIGNAL_RUN_LAST,
                  0,
                  g_signal_accumulator_true_handled, NULL,
                  marshal_BOOLEAN__BOXED,
                  G_TYPE_BOOLEAN, 1,
                  GRAPHENE_TYPE_POINT);
]|

## Using Graphene via GObject introspection

When using Graphene with another language than C, the GObject Introspection
bindings change the type names to the CamelCase version of the C name, minus
the `_t` suffix; for instance:

 * #graphene_point_t becomes `GraphenePoint`
 * #graphene_point3d_t becomes `GraphenePoint3D`
 * #graphene_rect_t becomes `GrapheneRect`
 * #graphene_matrix_t becomes `GrapheneMatrix`

There is no direct access for the low level #graphene_simd4f_t and
#graphene_simd4x4f_t SIMD types.</doc>
    </docsection>
    <docsection name="graphene-matrix">
      <doc xml:space="preserve">#graphene_matrix_t is a type that provides a 4x4 square matrix, useful for
representing 3D transformations.

The matrix is treated as row-major, i.e. it has four vectors (x, y, z, and
w) representing rows, and elements of each vector are a column:

|[&lt;!-- language="plain" --&gt;
  &#x23A1; m.x &#x23A4;    &#x239B; x.x  x.y  x.z  x.w &#x239E;
  &#x239C; m.y &#x239F; -\ &#x239C; y.x  y.y  y.z  y.w &#x239F;
  &#x239C; m.z &#x239F; -/ &#x239C; z.x  z.y  z.z  z.w &#x239F;
  &#x23A3; m.w &#x23A6;    &#x239D; w.x  w.y  w.z  w.w &#x23A0;
]|

It is possible to easily convert a #graphene_matrix_t to and from an array
of floating point values that can be used with other libraries.

The contents of a #graphene_matrix_t are private, and direct access is not
possible. You can modify and read the contents of a #graphene_matrix_t
only through the provided API.

# Conventions # {#conventions}

Graphene uses left-multiplication for all its operations on vectors and
matrices; in other words, given a matrix `A` and a vector `b`, the result
of a multiplication is going to be:

|[
  res = b &#xD7; A
]|

Multiplying two matrices, on the other hand, will use right-multiplication;
given two matrices `A` and `B`, the result of the multiplication is going
to be

|[
  res = A &#xD7; B
]|

as the implementation will multiply each row vector of matrix `A` with the
matrix `B` to obtain the new row vectors of the result matrix:

|[
  res = &#x23A1; A.x &#xD7; B &#x23A4;
        &#x239C; A.y &#xD7; B &#x239F;
        &#x239C; A.z &#xD7; B &#x239F;
        &#x23A3; A.w &#xD7; B &#x23A6;
]|

For more information, see the documentation for #graphene_simd4x4f_t,
especially the following functions:

  - graphene_simd4x4f_vec4_mul()
  - graphene_simd4x4f_vec3_mul()
  - graphene_simd4x4f_point3_mul()
  - graphene_simd4x4f_matrix_mul()</doc>
    </docsection>
    <docsection name="graphene-plane">
      <doc xml:space="preserve">#graphene_plane_t is a structure representing a plane that extends
infinitely in 3D space, described using the [Hessian normal
form](http://mathworld.wolfram.com/HessianNormalForm.html)
of a unit length normal vector pointing towards the origin, and a
constant distance from the origin along the normal vector.</doc>
    </docsection>
    <docsection name="graphene-point">
      <doc xml:space="preserve">#graphene_point_t is a data structure capable of describing a point with
two coordinates:

 * @graphene_point_t.x
 * @graphene_point_t.y</doc>
    </docsection>
    <docsection name="graphene-point3d">
      <doc xml:space="preserve">#graphene_point3d_t is a data structure capable of describing a point with
three coordinates:

 * @graphene_point3d_t.x
 * @graphene_point3d_t.y
 * @graphene_point3d_t.z</doc>
    </docsection>
    <docsection name="graphene-quad">
      <doc xml:space="preserve">A #graphene_quad_t represents a coplanar, four vertex quadrilateral shape.</doc>
    </docsection>
    <docsection name="graphene-quaternion">
      <doc xml:space="preserve">Quaternions are a mathematical entity that can be used to represent
rotation transformations in 3D space; unlike the usual Euler representation
with roll, pitch, and yaw, quaternions do not suffer from the so-called
["Gimbal Lock"](http://en.wikipedia.org/wiki/Gimbal_lock) problem.

See also: #graphene_euler_t</doc>
    </docsection>
    <docsection name="graphene-ray">
      <doc xml:space="preserve">#graphene_ray_t is a structure representing a ray emitted by an origin,
identified by a point in 3D space, in a given direction, identified
by a vector with 3 components.

A common use of #graphene_ray_t is ray-casting to find which objects in
a 3D scene are under the coordinates of the pointer.</doc>
    </docsection>
    <docsection name="graphene-rect">
      <doc xml:space="preserve">#graphene_rect_t is a type representing a rectangle through an origin
#graphene_point_t point and a #graphene_size_t size.

![](rectangle.png)

Operations on a #graphene_rect_t will normalize the rectangle, to
ensure that the origin is always the top-left corner of the rectangle
and that the size is always positive.</doc>
    </docsection>
    <docsection name="graphene-size">
      <doc xml:space="preserve">#graphene_size_t represents a size composed of a @graphene_size_t.width
by a @graphene_size_t.height.</doc>
    </docsection>
    <docsection name="graphene-sphere">
      <doc xml:space="preserve">#graphene_sphere_t provides a representation of a sphere using its center
and radius.</doc>
    </docsection>
    <docsection name="graphene-triangle">
      <doc xml:space="preserve">#graphene_triangle_t represents a triangle in 3D space.</doc>
    </docsection>
    <docsection name="graphene-vectors">
      <doc xml:space="preserve">Graphene has three vector types, distinguished by their length:

 1. #graphene_vec2_t, which holds 2 components x and y
 2. #graphene_vec3_t, which holds 3 components x, y, and z
 3. #graphene_vec4_t, which holds 4 components x, y, z, and w

Each vector type should be treated as an opaque data type.</doc>
    </docsection>
    <function name="point3d_zero" c:identifier="graphene_point3d_zero" moved-to="Point3D.zero" version="1.0">
      <doc xml:space="preserve">Retrieves a constant point with all three coordinates set to 0.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a zero point</doc>
        <type name="Point3D" c:type="const graphene_point3d_t*"/>
      </return-value>
    </function>
    <function name="point_zero" c:identifier="graphene_point_zero" moved-to="Point.zero" version="1.0">
      <doc xml:space="preserve">Returns a point fixed at (0, 0).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a fixed point</doc>
        <type name="Point" c:type="const graphene_point_t*"/>
      </return-value>
    </function>
    <function name="rect_alloc" c:identifier="graphene_rect_alloc" moved-to="Rect.alloc" version="1.0">
      <doc xml:space="preserve">Allocates a new #graphene_rect_t.

The contents of the returned rectangle are undefined.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly allocated rectangle</doc>
        <type name="Rect" c:type="graphene_rect_t*"/>
      </return-value>
    </function>
    <function name="rect_zero" c:identifier="graphene_rect_zero" moved-to="Rect.zero" version="1.4">
      <doc xml:space="preserve">Returns a degenerate rectangle with origin fixed at (0, 0) and
a size of 0, 0.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a fixed rectangle</doc>
        <type name="Rect" c:type="const graphene_rect_t*"/>
      </return-value>
    </function>
    <function name="size_zero" c:identifier="graphene_size_zero" moved-to="Size.zero" version="1.0">
      <doc xml:space="preserve">A constant pointer to a zero #graphene_size_t, useful for
equality checks and interpolations.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant size</doc>
        <type name="Size" c:type="const graphene_size_t*"/>
      </return-value>
    </function>
    <function name="vec2_one" c:identifier="graphene_vec2_one" moved-to="Vec2.one" version="1.0">
      <doc xml:space="preserve">Retrieves a constant vector with (1, 1) components.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the one vector</doc>
        <type name="Vec2" c:type="const graphene_vec2_t*"/>
      </return-value>
    </function>
    <function name="vec2_x_axis" c:identifier="graphene_vec2_x_axis" moved-to="Vec2.x_axis" version="1.0">
      <doc xml:space="preserve">Retrieves a constant vector with (1, 0) components.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the X axis vector</doc>
        <type name="Vec2" c:type="const graphene_vec2_t*"/>
      </return-value>
    </function>
    <function name="vec2_y_axis" c:identifier="graphene_vec2_y_axis" moved-to="Vec2.y_axis" version="1.0">
      <doc xml:space="preserve">Retrieves a constant vector with (0, 1) components.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the Y axis vector</doc>
        <type name="Vec2" c:type="const graphene_vec2_t*"/>
      </return-value>
    </function>
    <function name="vec2_zero" c:identifier="graphene_vec2_zero" moved-to="Vec2.zero" version="1.0">
      <doc xml:space="preserve">Retrieves a constant vector with (0, 0) components.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the zero vector</doc>
        <type name="Vec2" c:type="const graphene_vec2_t*"/>
      </return-value>
    </function>
    <function name="vec3_one" c:identifier="graphene_vec3_one" moved-to="Vec3.one" version="1.0">
      <doc xml:space="preserve">Provides a constant pointer to a vector with three components,
all sets to 1.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant vector</doc>
        <type name="Vec3" c:type="const graphene_vec3_t*"/>
      </return-value>
    </function>
    <function name="vec3_x_axis" c:identifier="graphene_vec3_x_axis" moved-to="Vec3.x_axis" version="1.0">
      <doc xml:space="preserve">Provides a constant pointer to a vector with three components
with values set to (1, 0, 0).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant vector</doc>
        <type name="Vec3" c:type="const graphene_vec3_t*"/>
      </return-value>
    </function>
    <function name="vec3_y_axis" c:identifier="graphene_vec3_y_axis" moved-to="Vec3.y_axis" version="1.0">
      <doc xml:space="preserve">Provides a constant pointer to a vector with three components
with values set to (0, 1, 0).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant vector</doc>
        <type name="Vec3" c:type="const graphene_vec3_t*"/>
      </return-value>
    </function>
    <function name="vec3_z_axis" c:identifier="graphene_vec3_z_axis" moved-to="Vec3.z_axis" version="1.0">
      <doc xml:space="preserve">Provides a constant pointer to a vector with three components
with values set to (0, 0, 1).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant vector</doc>
        <type name="Vec3" c:type="const graphene_vec3_t*"/>
      </return-value>
    </function>
    <function name="vec3_zero" c:identifier="graphene_vec3_zero" moved-to="Vec3.zero" version="1.0">
      <doc xml:space="preserve">Provides a constant pointer to a vector with three components,
all sets to 0.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant vector</doc>
        <type name="Vec3" c:type="const graphene_vec3_t*"/>
      </return-value>
    </function>
    <function name="vec4_one" c:identifier="graphene_vec4_one" moved-to="Vec4.one" version="1.0">
      <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with all its
components set to 1.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant vector</doc>
        <type name="Vec4" c:type="const graphene_vec4_t*"/>
      </return-value>
    </function>
    <function name="vec4_w_axis" c:identifier="graphene_vec4_w_axis" moved-to="Vec4.w_axis" version="1.0">
      <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with its
components set to (0, 0, 0, 1).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant vector</doc>
        <type name="Vec4" c:type="const graphene_vec4_t*"/>
      </return-value>
    </function>
    <function name="vec4_x_axis" c:identifier="graphene_vec4_x_axis" moved-to="Vec4.x_axis" version="1.0">
      <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with its
components set to (1, 0, 0, 0).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant vector</doc>
        <type name="Vec4" c:type="const graphene_vec4_t*"/>
      </return-value>
    </function>
    <function name="vec4_y_axis" c:identifier="graphene_vec4_y_axis" moved-to="Vec4.y_axis" version="1.0">
      <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with its
components set to (0, 1, 0, 0).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant vector</doc>
        <type name="Vec4" c:type="const graphene_vec4_t*"/>
      </return-value>
    </function>
    <function name="vec4_z_axis" c:identifier="graphene_vec4_z_axis" moved-to="Vec4.z_axis" version="1.0">
      <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with its
components set to (0, 0, 1, 0).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant vector</doc>
        <type name="Vec4" c:type="const graphene_vec4_t*"/>
      </return-value>
    </function>
    <function name="vec4_zero" c:identifier="graphene_vec4_zero" moved-to="Vec4.zero" version="1.0">
      <doc xml:space="preserve">Retrieves a pointer to a #graphene_vec4_t with all its
components set to 0.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a constant vector</doc>
        <type name="Vec4" c:type="const graphene_vec4_t*"/>
      </return-value>
    </function>
  </namespace>
</repository>
