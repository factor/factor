<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="Gdk" version="4.0"/>
  <include name="Graphene" version="1.0"/>
  <package name="gtk4"/>
  <c:include name="gsk/gsk.h"/>
  <namespace name="Gsk" version="4.0" shared-library="libgtk-4.so.1" c:identifier-prefixes="Gsk" c:symbol-prefixes="gsk">
    <function-macro name="BROADWAY_RENDERER" c:identifier="GSK_BROADWAY_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BROADWAY_RENDERER_CLASS" c:identifier="GSK_BROADWAY_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BROADWAY_RENDERER_GET_CLASS" c:identifier="GSK_BROADWAY_RENDERER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="BlendMode" glib:type-name="GskBlendMode" glib:get-type="gsk_blend_mode_get_type" c:type="GskBlendMode">
      <doc xml:space="preserve">The blend modes available for render nodes.

The implementation of each blend mode is deferred to the
rendering pipeline.

See &lt;https://www.w3.org/TR/compositing-1/#blending&gt; for more information
on blending and blend modes.</doc>
      <member name="default" value="0" c:identifier="GSK_BLEND_MODE_DEFAULT" glib:nick="default" glib:name="GSK_BLEND_MODE_DEFAULT">
        <doc xml:space="preserve">The default blend mode, which specifies no blending</doc>
      </member>
      <member name="multiply" value="1" c:identifier="GSK_BLEND_MODE_MULTIPLY" glib:nick="multiply" glib:name="GSK_BLEND_MODE_MULTIPLY">
        <doc xml:space="preserve">The source color is multiplied by the destination
  and replaces the destination</doc>
      </member>
      <member name="screen" value="2" c:identifier="GSK_BLEND_MODE_SCREEN" glib:nick="screen" glib:name="GSK_BLEND_MODE_SCREEN">
        <doc xml:space="preserve">Multiplies the complements of the destination and source
  color values, then complements the result.</doc>
      </member>
      <member name="overlay" value="3" c:identifier="GSK_BLEND_MODE_OVERLAY" glib:nick="overlay" glib:name="GSK_BLEND_MODE_OVERLAY">
        <doc xml:space="preserve">Multiplies or screens the colors, depending on the
  destination color value. This is the inverse of hard-list</doc>
      </member>
      <member name="darken" value="4" c:identifier="GSK_BLEND_MODE_DARKEN" glib:nick="darken" glib:name="GSK_BLEND_MODE_DARKEN">
        <doc xml:space="preserve">Selects the darker of the destination and source colors</doc>
      </member>
      <member name="lighten" value="5" c:identifier="GSK_BLEND_MODE_LIGHTEN" glib:nick="lighten" glib:name="GSK_BLEND_MODE_LIGHTEN">
        <doc xml:space="preserve">Selects the lighter of the destination and source colors</doc>
      </member>
      <member name="color_dodge" value="6" c:identifier="GSK_BLEND_MODE_COLOR_DODGE" glib:nick="color-dodge" glib:name="GSK_BLEND_MODE_COLOR_DODGE">
        <doc xml:space="preserve">Brightens the destination color to reflect the source color</doc>
      </member>
      <member name="color_burn" value="7" c:identifier="GSK_BLEND_MODE_COLOR_BURN" glib:nick="color-burn" glib:name="GSK_BLEND_MODE_COLOR_BURN">
        <doc xml:space="preserve">Darkens the destination color to reflect the source color</doc>
      </member>
      <member name="hard_light" value="8" c:identifier="GSK_BLEND_MODE_HARD_LIGHT" glib:nick="hard-light" glib:name="GSK_BLEND_MODE_HARD_LIGHT">
        <doc xml:space="preserve">Multiplies or screens the colors, depending on the source color value</doc>
      </member>
      <member name="soft_light" value="9" c:identifier="GSK_BLEND_MODE_SOFT_LIGHT" glib:nick="soft-light" glib:name="GSK_BLEND_MODE_SOFT_LIGHT">
        <doc xml:space="preserve">Darkens or lightens the colors, depending on the source color value</doc>
      </member>
      <member name="difference" value="10" c:identifier="GSK_BLEND_MODE_DIFFERENCE" glib:nick="difference" glib:name="GSK_BLEND_MODE_DIFFERENCE">
        <doc xml:space="preserve">Subtracts the darker of the two constituent colors from the lighter color</doc>
      </member>
      <member name="exclusion" value="11" c:identifier="GSK_BLEND_MODE_EXCLUSION" glib:nick="exclusion" glib:name="GSK_BLEND_MODE_EXCLUSION">
        <doc xml:space="preserve">Produces an effect similar to that of the difference mode but lower in contrast</doc>
      </member>
      <member name="color" value="12" c:identifier="GSK_BLEND_MODE_COLOR" glib:nick="color" glib:name="GSK_BLEND_MODE_COLOR">
        <doc xml:space="preserve">Creates a color with the hue and saturation of the source color and the luminosity of the destination color</doc>
      </member>
      <member name="hue" value="13" c:identifier="GSK_BLEND_MODE_HUE" glib:nick="hue" glib:name="GSK_BLEND_MODE_HUE">
        <doc xml:space="preserve">Creates a color with the hue of the source color and the saturation and luminosity of the destination color</doc>
      </member>
      <member name="saturation" value="14" c:identifier="GSK_BLEND_MODE_SATURATION" glib:nick="saturation" glib:name="GSK_BLEND_MODE_SATURATION">
        <doc xml:space="preserve">Creates a color with the saturation of the source color and the hue and luminosity of the destination color</doc>
      </member>
      <member name="luminosity" value="15" c:identifier="GSK_BLEND_MODE_LUMINOSITY" glib:nick="luminosity" glib:name="GSK_BLEND_MODE_LUMINOSITY">
        <doc xml:space="preserve">Creates a color with the luminosity of the source color and the hue and saturation of the destination color</doc>
      </member>
    </enumeration>
    <class name="BlendNode" c:symbol-prefix="blend_node" c:type="GskBlendNode" parent="RenderNode" glib:type-name="GskBlendNode" glib:get-type="gsk_blend_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node applying a blending function between its two child nodes.</doc>
      <constructor name="new" c:identifier="gsk_blend_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will use @blend_mode to blend the @top
node onto the @bottom node.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="BlendNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">The bottom node to be drawn</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">The node to be blended onto the @bottom node</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="blend_mode" transfer-ownership="none">
            <doc xml:space="preserve">The blend mode to use</doc>
            <type name="BlendMode" c:type="GskBlendMode"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_blend_mode" c:identifier="gsk_blend_node_get_blend_mode">
        <doc xml:space="preserve">Retrieves the blend mode used by @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blend mode</doc>
          <type name="BlendMode" c:type="GskBlendMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blending `GskRenderNode`</doc>
            <type name="BlendNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bottom_child" c:identifier="gsk_blend_node_get_bottom_child">
        <doc xml:space="preserve">Retrieves the bottom `GskRenderNode` child of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the bottom child node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blending `GskRenderNode`</doc>
            <type name="BlendNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_top_child" c:identifier="gsk_blend_node_get_top_child">
        <doc xml:space="preserve">Retrieves the top `GskRenderNode` child of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the top child node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blending `GskRenderNode`</doc>
            <type name="BlendNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="BlurNode" c:symbol-prefix="blur_node" c:type="GskBlurNode" parent="RenderNode" glib:type-name="GskBlurNode" glib:get-type="gsk_blur_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node applying a blur effect to its single child.</doc>
      <constructor name="new" c:identifier="gsk_blur_node_new">
        <doc xml:space="preserve">Creates a render node that blurs the child.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new `GskRenderNode`</doc>
          <type name="BlurNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">the child node to blur</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">the blur radius. Must be positive</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_blur_node_get_child">
        <doc xml:space="preserve">Retrieves the child `GskRenderNode` of the blur @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blurred child node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blur `GskRenderNode`</doc>
            <type name="BlurNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_radius" c:identifier="gsk_blur_node_get_radius">
        <doc xml:space="preserve">Retrieves the blur radius of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blur radius</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blur `GskRenderNode`</doc>
            <type name="BlurNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="BorderNode" c:symbol-prefix="border_node" c:type="GskBorderNode" parent="RenderNode" glib:type-name="GskBorderNode" glib:get-type="gsk_border_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a border.</doc>
      <constructor name="new" c:identifier="gsk_border_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will stroke a border rectangle inside the
given @outline.

The 4 sides of the border can have different widths and colors.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="BorderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="outline" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRoundedRect` describing the outline of the border</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
          <parameter name="border_width" transfer-ownership="none">
            <doc xml:space="preserve">the stroke width of the border on
    the top, right, bottom and left side respectively.</doc>
            <array zero-terminated="0" c:type="const float*" fixed-size="4">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="border_color" transfer-ownership="none">
            <doc xml:space="preserve">the color used on the top, right,
    bottom and left side.</doc>
            <array zero-terminated="0" c:type="const GdkRGBA*" fixed-size="4">
              <type name="Gdk.RGBA" c:type="GdkRGBA"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_colors" c:identifier="gsk_border_node_get_colors">
        <doc xml:space="preserve">Retrieves the colors of the border.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an array of 4 `GdkRGBA` structs
    for the top, right, bottom and left color of the border</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a border</doc>
            <type name="BorderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_outline" c:identifier="gsk_border_node_get_outline">
        <doc xml:space="preserve">Retrieves the outline of the border.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the outline of the border</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a border</doc>
            <type name="BorderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_widths" c:identifier="gsk_border_node_get_widths">
        <doc xml:space="preserve">Retrieves the stroke widths of the border.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an array of 4 floats
  for the top, right, bottom and left stroke width of the border,
  respectively</doc>
          <array zero-terminated="0" c:type="const float*" fixed-size="4">
            <type name="gfloat" c:type="float"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a border</doc>
            <type name="BorderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="BroadwayRenderer" c:symbol-prefix="broadway_renderer" c:type="GskBroadwayRenderer" parent="Renderer" glib:type-name="GskBroadwayRenderer" glib:get-type="gsk_broadway_renderer_get_type" glib:type-struct="BroadwayRendererClass">
      <doc xml:space="preserve">A Broadway based renderer.

See [class@Gsk.Renderer].</doc>
      <constructor name="new" c:identifier="gsk_broadway_renderer_new">
        <doc xml:space="preserve">Creates a new Broadway renderer.

The Broadway renderer is the default renderer for the broadway backend.
It will only work with broadway surfaces, otherwise it will fail the
call to gsk_renderer_realize().

This function is only available when GTK was compiled with Broadway
support.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new Broadway renderer.</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="BroadwayRendererClass" c:type="GskBroadwayRendererClass" disguised="1" opaque="1" glib:is-gtype-struct-for="BroadwayRenderer"/>
    <function-macro name="CAIRO_RENDERER" c:identifier="GSK_CAIRO_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CAIRO_RENDERER_CLASS" c:identifier="GSK_CAIRO_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CAIRO_RENDERER_GET_CLASS" c:identifier="GSK_CAIRO_RENDERER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="CairoNode" c:symbol-prefix="cairo_node" c:type="GskCairoNode" parent="RenderNode" glib:type-name="GskCairoNode" glib:get-type="gsk_cairo_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a Cairo surface.</doc>
      <constructor name="new" c:identifier="gsk_cairo_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will render a cairo surface
into the area given by @bounds.

You can draw to the cairo surface using [method@Gsk.CairoNode.get_draw_context].</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="CairoNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render to</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_draw_context" c:identifier="gsk_cairo_node_get_draw_context">
        <doc xml:space="preserve">Creates a Cairo context for drawing using the surface associated
to the render node.

If no surface exists yet, a surface will be created optimized for
rendering to @renderer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a Cairo context used for drawing; use
  cairo_destroy() when done drawing</doc>
          <type name="cairo.Context" c:type="cairo_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a Cairo surface</doc>
            <type name="CairoNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_surface" c:identifier="gsk_cairo_node_get_surface">
        <doc xml:space="preserve">Retrieves the Cairo surface used by the render node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a Cairo surface</doc>
          <type name="cairo.Surface" c:type="cairo_surface_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a Cairo surface</doc>
            <type name="CairoNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="CairoRenderer" c:symbol-prefix="cairo_renderer" c:type="GskCairoRenderer" parent="Renderer" glib:type-name="GskCairoRenderer" glib:get-type="gsk_cairo_renderer_get_type" glib:type-struct="CairoRendererClass">
      <doc xml:space="preserve">A GSK renderer that is using cairo.

Since it is using cairo, this renderer cannot support
3D transformations.</doc>
      <constructor name="new" c:identifier="gsk_cairo_renderer_new">
        <doc xml:space="preserve">Creates a new Cairo renderer.

The Cairo renderer is the fallback renderer drawing in ways similar
to how GTK 3 drew its content. Its primary use is as comparison tool.

The Cairo renderer is incomplete. It cannot render 3D transformed
content and will instead render an error marker. Its usage should be
avoided.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new Cairo renderer.</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="CairoRendererClass" c:type="GskCairoRendererClass" disguised="1" opaque="1" glib:is-gtype-struct-for="CairoRenderer"/>
    <class name="ClipNode" c:symbol-prefix="clip_node" c:type="GskClipNode" parent="RenderNode" glib:type-name="GskClipNode" glib:get-type="gsk_clip_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node applying a rectangular clip to its single child node.</doc>
      <constructor name="new" c:identifier="gsk_clip_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will clip the @child to the area
given by @clip.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="ClipNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="clip" transfer-ownership="none">
            <doc xml:space="preserve">The clip to apply</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_clip_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting clipped by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting clipped</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a clip @GskRenderNode</doc>
            <type name="ClipNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_clip" c:identifier="gsk_clip_node_get_clip">
        <doc xml:space="preserve">Retrieves the clip rectangle for @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a clip rectangle</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskClipNode`</doc>
            <type name="ClipNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="ColorMatrixNode" c:symbol-prefix="color_matrix_node" c:type="GskColorMatrixNode" parent="RenderNode" glib:type-name="GskColorMatrixNode" glib:get-type="gsk_color_matrix_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node controlling the color matrix of its single child node.</doc>
      <constructor name="new" c:identifier="gsk_color_matrix_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will drawn the @child with
@color_matrix.

In particular, the node will transform colors by applying

    pixel = transpose(color_matrix) * pixel + color_offset

for every pixel. The transformation operates on unpremultiplied
colors, with color components ordered R, G, B, A.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="ColorMatrixNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="color_matrix" transfer-ownership="none">
            <doc xml:space="preserve">The matrix to apply</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
          <parameter name="color_offset" transfer-ownership="none">
            <doc xml:space="preserve">Values to add to the color</doc>
            <type name="Graphene.Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_color_matrix_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting its colors modified by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting its colors modified</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a color matrix `GskRenderNode`</doc>
            <type name="ColorMatrixNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_matrix" c:identifier="gsk_color_matrix_node_get_color_matrix">
        <doc xml:space="preserve">Retrieves the color matrix used by the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a 4x4 color matrix</doc>
          <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a color matrix `GskRenderNode`</doc>
            <type name="ColorMatrixNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_offset" c:identifier="gsk_color_matrix_node_get_color_offset">
        <doc xml:space="preserve">Retrieves the color offset used by the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a color vector</doc>
          <type name="Graphene.Vec4" c:type="const graphene_vec4_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a color matrix `GskRenderNode`</doc>
            <type name="ColorMatrixNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="ColorNode" c:symbol-prefix="color_node" c:type="GskColorNode" parent="RenderNode" glib:type-name="GskColorNode" glib:get-type="gsk_color_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a solid color.</doc>
      <constructor name="new" c:identifier="gsk_color_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will render the color specified by @rgba into
the area given by @bounds.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="ColorNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="rgba" transfer-ownership="none">
            <doc xml:space="preserve">a `GdkRGBA` specifying a color</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the color into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_color" c:identifier="gsk_color_node_get_color">
        <doc xml:space="preserve">Retrieves the color of the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color of the node</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode`</doc>
            <type name="ColorNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="ColorStop" c:type="GskColorStop">
      <doc xml:space="preserve">A color stop in a gradient node.</doc>
      <field name="offset" writable="1">
        <doc xml:space="preserve">the offset of the color stop</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="color" writable="1">
        <doc xml:space="preserve">the color at the given offset</doc>
        <type name="Gdk.RGBA" c:type="GdkRGBA"/>
      </field>
    </record>
    <class name="ConicGradientNode" c:symbol-prefix="conic_gradient_node" c:type="GskConicGradientNode" parent="RenderNode" glib:type-name="GskConicGradientNode" glib:get-type="gsk_conic_gradient_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a conic gradient.</doc>
      <constructor name="new" c:identifier="gsk_conic_gradient_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that draws a conic gradient.

The conic gradient
starts around @center in the direction of @rotation. A rotation of 0 means
that the gradient points up. Color stops are then added clockwise.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="ConicGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the bounds of the node</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="center" transfer-ownership="none">
            <doc xml:space="preserve">the center of the gradient</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="rotation" transfer-ownership="none">
            <doc xml:space="preserve">the rotation of the gradient in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of
  `GskColorStop` defining the gradient. The offsets of all color stops
  must be increasing. The first stop's offset must be &gt;= 0 and the last
  stop's offset must be &lt;= 1.</doc>
            <array length="4" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_angle" c:identifier="gsk_conic_gradient_node_get_angle" version="4.2">
        <doc xml:space="preserve">Retrieves the angle for the gradient in radians, normalized in [0, 2 * PI].

The angle is starting at the top and going clockwise, as expressed
in the css specification:

    angle = 90 - gsk_conic_gradient_node_get_rotation()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the angle for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a conic gradient</doc>
            <type name="ConicGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_center" c:identifier="gsk_conic_gradient_node_get_center">
        <doc xml:space="preserve">Retrieves the center pointer for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the center point for the gradient</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a conic gradient</doc>
            <type name="ConicGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_stops" c:identifier="gsk_conic_gradient_node_get_color_stops">
        <doc xml:space="preserve">Retrieves the color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color stops in the gradient</doc>
          <array length="0" zero-terminated="0" c:type="const GskColorStop*">
            <type name="ColorStop" c:type="GskColorStop"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a conic gradient</doc>
            <type name="ConicGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="n_stops" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of color stops in the returned array</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_color_stops" c:identifier="gsk_conic_gradient_node_get_n_color_stops">
        <doc xml:space="preserve">Retrieves the number of color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of color stops</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a conic gradient</doc>
            <type name="ConicGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rotation" c:identifier="gsk_conic_gradient_node_get_rotation">
        <doc xml:space="preserve">Retrieves the rotation for the gradient in degrees.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the rotation for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a conic gradient</doc>
            <type name="ConicGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="ContainerNode" c:symbol-prefix="container_node" c:type="GskContainerNode" parent="RenderNode" glib:type-name="GskContainerNode" glib:get-type="gsk_container_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node that can contain other render nodes.</doc>
      <constructor name="new" c:identifier="gsk_container_node_new">
        <doc xml:space="preserve">Creates a new `GskRenderNode` instance for holding the given @children.

The new node will acquire a reference to each of the children.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new `GskRenderNode`</doc>
          <type name="ContainerNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="children" transfer-ownership="none">
            <doc xml:space="preserve">The children of the node</doc>
            <array length="1" zero-terminated="0" c:type="GskRenderNode**">
              <type name="RenderNode" c:type="GskRenderNode*"/>
            </array>
          </parameter>
          <parameter name="n_children" transfer-ownership="none">
            <doc xml:space="preserve">Number of children in the @children array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_container_node_get_child">
        <doc xml:space="preserve">Gets one of the children of @container.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @idx'th child of @container</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a container `GskRenderNode`</doc>
            <type name="ContainerNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the position of the child to get</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_children" c:identifier="gsk_container_node_get_n_children">
        <doc xml:space="preserve">Retrieves the number of direct children of @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of children of the `GskRenderNode`</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a container `GskRenderNode`</doc>
            <type name="ContainerNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="Corner" glib:type-name="GskCorner" glib:get-type="gsk_corner_get_type" c:type="GskCorner">
      <doc xml:space="preserve">The corner indices used by `GskRoundedRect`.</doc>
      <member name="top_left" value="0" c:identifier="GSK_CORNER_TOP_LEFT" glib:nick="top-left" glib:name="GSK_CORNER_TOP_LEFT">
        <doc xml:space="preserve">The top left corner</doc>
      </member>
      <member name="top_right" value="1" c:identifier="GSK_CORNER_TOP_RIGHT" glib:nick="top-right" glib:name="GSK_CORNER_TOP_RIGHT">
        <doc xml:space="preserve">The top right corner</doc>
      </member>
      <member name="bottom_right" value="2" c:identifier="GSK_CORNER_BOTTOM_RIGHT" glib:nick="bottom-right" glib:name="GSK_CORNER_BOTTOM_RIGHT">
        <doc xml:space="preserve">The bottom right corner</doc>
      </member>
      <member name="bottom_left" value="3" c:identifier="GSK_CORNER_BOTTOM_LEFT" glib:nick="bottom-left" glib:name="GSK_CORNER_BOTTOM_LEFT">
        <doc xml:space="preserve">The bottom left corner</doc>
      </member>
    </enumeration>
    <class name="CrossFadeNode" c:symbol-prefix="cross_fade_node" c:type="GskCrossFadeNode" parent="RenderNode" glib:type-name="GskCrossFadeNode" glib:get-type="gsk_cross_fade_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node cross fading between two child nodes.</doc>
      <constructor name="new" c:identifier="gsk_cross_fade_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will do a cross-fade between @start and @end.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="CrossFadeNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">The start node to be drawn</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">The node to be cross_fadeed onto the @start node</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve">How far the fade has progressed from start to end. The value will
    be clamped to the range [0 ... 1]</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_end_child" c:identifier="gsk_cross_fade_node_get_end_child">
        <doc xml:space="preserve">Retrieves the child `GskRenderNode` at the end of the cross-fade.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a `GskRenderNode`</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a cross-fading `GskRenderNode`</doc>
            <type name="CrossFadeNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_progress" c:identifier="gsk_cross_fade_node_get_progress">
        <doc xml:space="preserve">Retrieves the progress value of the cross fade.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the progress value, between 0 and 1</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a cross-fading `GskRenderNode`</doc>
            <type name="CrossFadeNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_start_child" c:identifier="gsk_cross_fade_node_get_start_child">
        <doc xml:space="preserve">Retrieves the child `GskRenderNode` at the beginning of the cross-fade.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a `GskRenderNode`</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a cross-fading `GskRenderNode`</doc>
            <type name="CrossFadeNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="DebugNode" c:symbol-prefix="debug_node" c:type="GskDebugNode" parent="RenderNode" glib:type-name="GskDebugNode" glib:get-type="gsk_debug_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node that emits a debugging message when drawing its
child node.</doc>
      <constructor name="new" c:identifier="gsk_debug_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will add debug information about
the given @child.

Adding this node has no visual effect.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="DebugNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The child to add debug info for</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="message" transfer-ownership="full">
            <doc xml:space="preserve">The debug message</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_debug_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting drawn by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the child `GskRenderNode`</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a debug `GskRenderNode`</doc>
            <type name="DebugNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message" c:identifier="gsk_debug_node_get_message">
        <doc xml:space="preserve">Gets the debug message that was set on this node</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The debug message</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a debug `GskRenderNode`</doc>
            <type name="DebugNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="FillNode" c:symbol-prefix="fill_node" c:type="GskFillNode" version="4.14" parent="RenderNode" glib:type-name="GskFillNode" glib:get-type="gsk_fill_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node filling the area given by [struct@Gsk.Path]
and [enum@Gsk.FillRule] with the child node.</doc>
      <constructor name="new" c:identifier="gsk_fill_node_new" version="4.14">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will fill the @child in the area
given by @path and @fill_rule.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="FillNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to fill the area with</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">The path describing the area to fill</doc>
            <type name="Path" c:type="GskPath*"/>
          </parameter>
          <parameter name="fill_rule" transfer-ownership="none">
            <doc xml:space="preserve">The fill rule to use</doc>
            <type name="FillRule" c:type="GskFillRule"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_fill_node_get_child" version="4.14">
        <doc xml:space="preserve">Gets the child node that is getting drawn by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting drawn</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a fill `GskRenderNode`</doc>
            <type name="FillNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fill_rule" c:identifier="gsk_fill_node_get_fill_rule" version="4.14">
        <doc xml:space="preserve">Retrieves the fill rule used to determine how the path is filled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a `GskFillRule`</doc>
          <type name="FillRule" c:type="GskFillRule"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a fill `GskRenderNode`</doc>
            <type name="FillNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="gsk_fill_node_get_path" version="4.14">
        <doc xml:space="preserve">Retrieves the path used to describe the area filled with the contents of
the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a `GskPath`</doc>
          <type name="Path" c:type="GskPath*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a fill `GskRenderNode`</doc>
            <type name="FillNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="FillRule" version="4.14" glib:type-name="GskFillRule" glib:get-type="gsk_fill_rule_get_type" c:type="GskFillRule">
      <doc xml:space="preserve">`GskFillRule` is used to select how paths are filled.

Whether or not a point is included in the fill is determined by taking
a ray from that point to infinity and looking at intersections with the
path. The ray can be in any direction, as long as it doesn't pass through
the end point of a segment or have a tricky intersection such as
intersecting tangent to the path.

(Note that filling is not actually implemented in this way. This
is just a description of the rule that is applied.)

New entries may be added in future versions.</doc>
      <member name="winding" value="0" c:identifier="GSK_FILL_RULE_WINDING" glib:nick="winding" glib:name="GSK_FILL_RULE_WINDING">
        <doc xml:space="preserve">If the path crosses the ray from
  left-to-right, counts +1. If the path crosses the ray
  from right to left, counts -1. (Left and right are determined
  from the perspective of looking along the ray from the starting
  point.) If the total count is non-zero, the point will be filled.</doc>
      </member>
      <member name="even_odd" value="1" c:identifier="GSK_FILL_RULE_EVEN_ODD" glib:nick="even-odd" glib:name="GSK_FILL_RULE_EVEN_ODD">
        <doc xml:space="preserve">Counts the total number of
  intersections, without regard to the orientation of the contour. If
  the total number of intersections is odd, the point will be
  filled.</doc>
      </member>
    </enumeration>
    <class name="GLRenderer" c:symbol-prefix="gl_renderer" c:type="GskGLRenderer" version="4.2" parent="Renderer" glib:type-name="GskGLRenderer" glib:get-type="gsk_gl_renderer_get_type" glib:type-struct="GLRendererClass">
      <doc xml:space="preserve">A GL based renderer.

See [class@Gsk.Renderer].</doc>
      <constructor name="new" c:identifier="gsk_gl_renderer_new" version="4.2">
        <doc xml:space="preserve">Creates a new `GskRenderer` using the new OpenGL renderer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new GL renderer</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="GLRendererClass" c:type="GskGLRendererClass" disguised="1" opaque="1" glib:is-gtype-struct-for="GLRenderer"/>
    <class name="GLShader" c:symbol-prefix="gl_shader" c:type="GskGLShader" parent="GObject.Object" glib:type-name="GskGLShader" glib:get-type="gsk_gl_shader_get_type" glib:type-struct="GLShaderClass">
      <doc xml:space="preserve">A `GskGLShader` is a snippet of GLSL that is meant to run in the
fragment shader of the rendering pipeline.

A fragment shader gets the coordinates being rendered as input and
produces the pixel values for that particular pixel. Additionally,
the shader can declare a set of other input arguments, called
uniforms (as they are uniform over all the calls to your shader in
each instance of use). A shader can also receive up to 4
textures that it can use as input when producing the pixel data.

`GskGLShader` is usually used with gtk_snapshot_push_gl_shader()
to produce a [class@Gsk.GLShaderNode] in the rendering hierarchy,
and then its input textures are constructed by rendering the child
nodes to textures before rendering the shader node itself. (You can
pass texture nodes as children if you want to directly use a texture
as input).

The actual shader code is GLSL code that gets combined with
some other code into the fragment shader. Since the exact
capabilities of the GPU driver differs between different OpenGL
drivers and hardware, GTK adds some defines that you can use
to ensure your GLSL code runs on as many drivers as it can.

If the OpenGL driver is GLES, then the shader language version
is set to 100, and GSK_GLES will be defined in the shader.

Otherwise, if the OpenGL driver does not support the 3.2 core profile,
then the shader will run with language version 110 for GL2 and 130 for GL3,
and GSK_LEGACY will be defined in the shader.

If the OpenGL driver supports the 3.2 code profile, it will be used,
the shader language version is set to 150, and GSK_GL3 will be defined
in the shader.

The main function the shader must implement is:

```glsl
 void mainImage(out vec4 fragColor,
                in vec2 fragCoord,
                in vec2 resolution,
                in vec2 uv)
```

Where the input @fragCoord is the coordinate of the pixel we're
currently rendering, relative to the boundary rectangle that was
specified in the `GskGLShaderNode`, and @resolution is the width and
height of that rectangle. This is in the typical GTK coordinate
system with the origin in the top left. @uv contains the u and v
coordinates that can be used to index a texture at the
corresponding point. These coordinates are in the [0..1]x[0..1]
region, with 0, 0 being in the lower left corder (which is typical
for OpenGL).

The output @fragColor should be a RGBA color (with
premultiplied alpha) that will be used as the output for the
specified pixel location. Note that this output will be
automatically clipped to the clip region of the glshader node.

In addition to the function arguments the shader can define
up to 4 uniforms for textures which must be called u_textureN
(i.e. u_texture1 to u_texture4) as well as any custom uniforms
you want of types int, uint, bool, float, vec2, vec3 or vec4.

All textures sources contain premultiplied alpha colors, but if some
there are outer sources of colors there is a gsk_premultiply() helper
to compute premultiplication when needed.

Note that GTK parses the uniform declarations, so each uniform has to
be on a line by itself with no other code, like so:

```glsl
uniform float u_time;
uniform vec3 u_color;
uniform sampler2D u_texture1;
uniform sampler2D u_texture2;
```

GTK uses the "gsk" namespace in the symbols it uses in the
shader, so your code should not use any symbols with the prefix gsk
or GSK. There are some helper functions declared that you can use:

```glsl
vec4 GskTexture(sampler2D sampler, vec2 texCoords);
```

This samples a texture (e.g. u_texture1) at the specified
coordinates, and contains some helper ifdefs to ensure that
it works on all OpenGL versions.

You can compile the shader yourself using [method@Gsk.GLShader.compile],
otherwise the GSK renderer will do it when it handling the glshader
node. If errors occurs, the returned @error will include the glsl
sources, so you can see what GSK was passing to the compiler. You
can also set GSK_DEBUG=shaders in the environment to see the sources
and other relevant information about all shaders that GSK is handling.

# An example shader

```glsl
uniform float position;
uniform sampler2D u_texture1;
uniform sampler2D u_texture2;

void mainImage(out vec4 fragColor,
               in vec2 fragCoord,
               in vec2 resolution,
               in vec2 uv) {
  vec4 source1 = GskTexture(u_texture1, uv);
  vec4 source2 = GskTexture(u_texture2, uv);

  fragColor = position * source1 + (1.0 - position) * source2;
}
```

# Deprecation

This feature was deprecated in GTK 4.16 after the new rendering infrastructure
introduced in 4.14 did not support it.
The lack of Vulkan inegration would have made it a very hard feature to support.

If you want to use OpenGL directly, you should look at [GtkGLArea](../gtk4/class.GLArea.html)
which uses a different approach and is still well supported.</doc>
      <constructor name="new_from_bytes" c:identifier="gsk_gl_shader_new_from_bytes" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Creates a `GskGLShader` that will render pixels using the specified code.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskGLShader`</doc>
          <type name="GLShader" c:type="GskGLShader*"/>
        </return-value>
        <parameters>
          <parameter name="sourcecode" transfer-ownership="none">
            <doc xml:space="preserve">GLSL sourcecode for the shader, as a `GBytes`</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_resource" c:identifier="gsk_gl_shader_new_from_resource" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Creates a `GskGLShader` that will render pixels using the specified code.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskGLShader`</doc>
          <type name="GLShader" c:type="GskGLShader*"/>
        </return-value>
        <parameters>
          <parameter name="resource_path" transfer-ownership="none">
            <doc xml:space="preserve">path to a resource that contains the GLSL sourcecode for
    the shader</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="compile" c:identifier="gsk_gl_shader_compile" deprecated="1" deprecated-version="4.16" throws="1">
        <doc xml:space="preserve">Tries to compile the @shader for the given @renderer.

If there is a problem, this function returns %FALSE and reports
an error. You should use this function before relying on the shader
for rendering and use a fallback with a simpler shader or without
shaders if it fails.

Note that this will modify the rendering state (for example
change the current GL context) and requires the renderer to be
set up. This means that the widget has to be realized. Commonly you
want to call this from the realize signal of a widget, or during
widget snapshot.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if an error occurred</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderer`</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_uniform_by_name" c:identifier="gsk_gl_shader_find_uniform_by_name" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Looks for a uniform by the name @name, and returns the index
of the uniform, or -1 if it was not found.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The index of the uniform, or -1</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">uniform name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="format_args" c:identifier="gsk_gl_shader_format_args" introspectable="0" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Formats the uniform data as needed for feeding the named uniforms
values into the shader.

The argument list is a list of pairs of names, and values for the types
that match the declared uniforms (i.e. double/int/guint/gboolean for
primitive values and `graphene_vecN_t *` for vecN uniforms).

Any uniforms of the shader that are not included in the argument list
are zero-initialized.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated block of data which can be
    passed to [ctor@Gsk.GLShaderNode.new].</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">name-Value pairs for the uniforms of @shader, ending with
    a %NULL name</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="format_args_va" c:identifier="gsk_gl_shader_format_args_va" introspectable="0" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Formats the uniform data as needed for feeding the named uniforms
values into the shader.

The argument list is a list of pairs of names, and values for the
types that match the declared uniforms (i.e. double/int/guint/gboolean
for primitive values and `graphene_vecN_t *` for vecN uniforms).

It is an error to pass a uniform name that is not declared by the shader.

Any uniforms of the shader that are not included in the argument list
are zero-initialized.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated block of data which can be
    passed to [ctor@Gsk.GLShaderNode.new].</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="uniforms" transfer-ownership="none">
            <doc xml:space="preserve">name-Value pairs for the uniforms of @shader, ending
    with a %NULL name</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_bool" c:identifier="gsk_gl_shader_get_arg_bool" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.

The uniform must be of bool type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_float" c:identifier="gsk_gl_shader_get_arg_float" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.

The uniform must be of float type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_int" c:identifier="gsk_gl_shader_get_arg_int" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.

The uniform must be of int type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_uint" c:identifier="gsk_gl_shader_get_arg_uint" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.

The uniform must be of uint type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_vec2" c:identifier="gsk_gl_shader_get_arg_vec2" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.

The uniform must be of vec2 type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="out_value" transfer-ownership="none">
            <doc xml:space="preserve">location to store the uniform value in</doc>
            <type name="Graphene.Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_vec3" c:identifier="gsk_gl_shader_get_arg_vec3" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.

The uniform must be of vec3 type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="out_value" transfer-ownership="none">
            <doc xml:space="preserve">location to store the uniform value in</doc>
            <type name="Graphene.Vec3" c:type="graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_arg_vec4" c:identifier="gsk_gl_shader_get_arg_vec4" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Gets the value of the uniform @idx in the @args block.

The uniform must be of vec4 type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">uniform arguments</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="out_value" transfer-ownership="none">
            <doc xml:space="preserve">location to store set the uniform value in</doc>
            <type name="Graphene.Vec4" c:type="graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_args_size" c:identifier="gsk_gl_shader_get_args_size" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Get the size of the data block used to specify arguments for this shader.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The size of the data block</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_textures" c:identifier="gsk_gl_shader_get_n_textures" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Returns the number of textures that the shader requires.

This can be used to check that the a passed shader works
in your usecase. It is determined by looking at the highest
u_textureN value that the shader defines.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of texture inputs required by @shader</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_uniforms" c:identifier="gsk_gl_shader_get_n_uniforms" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Get the number of declared uniforms for this shader.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of declared uniforms</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_resource" c:identifier="gsk_gl_shader_get_resource" glib:get-property="resource" deprecated="1" deprecated-version="4.16">
        <attribute name="org.gtk.Method.get_property" value="resource"/>
        <doc xml:space="preserve">Gets the resource path for the GLSL sourcecode being used
to render this shader.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The resource path for the shader</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source" c:identifier="gsk_gl_shader_get_source" glib:get-property="source" deprecated="1" deprecated-version="4.16">
        <attribute name="org.gtk.Method.get_property" value="source"/>
        <doc xml:space="preserve">Gets the GLSL sourcecode being used to render this shader.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The source code for the shader</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uniform_name" c:identifier="gsk_gl_shader_get_uniform_name" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Get the name of the declared uniform for this shader at index @idx.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The name of the declared uniform</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uniform_offset" c:identifier="gsk_gl_shader_get_uniform_offset" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Get the offset into the data block where data for this uniforms is stored.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The data offset</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uniform_type" c:identifier="gsk_gl_shader_get_uniform_type" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Get the type of the declared uniform for this shader at index @idx.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The type of the declared uniform</doc>
          <type name="GLUniformType" c:type="GskGLUniformType"/>
        </return-value>
        <parameters>
          <instance-parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <property name="resource" writable="1" construct-only="1" transfer-ownership="none" getter="get_resource" default-value="NULL">
        <attribute name="org.gtk.Property.get" value="gsk_gl_shader_get_resource"/>
        <doc xml:space="preserve">Resource containing the source code for the shader.

If the shader source is not coming from a resource, this
will be %NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="source" writable="1" construct-only="1" transfer-ownership="none" getter="get_source">
        <attribute name="org.gtk.Property.get" value="gsk_gl_shader_get_source"/>
        <doc xml:space="preserve">The source code for the shader, as a `GBytes`.</doc>
        <type name="GLib.Bytes"/>
      </property>
    </class>
    <record name="GLShaderClass" c:type="GskGLShaderClass" glib:is-gtype-struct-for="GLShader">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="GLShaderNode" c:symbol-prefix="gl_shader_node" c:type="GskGLShaderNode" parent="RenderNode" glib:type-name="GskGLShaderNode" glib:get-type="gsk_gl_shader_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node using a GL shader when drawing its children nodes.</doc>
      <constructor name="new" c:identifier="gsk_gl_shader_node_new" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will render the given @shader into the
area given by @bounds.

The @args is a block of data to use for uniform input, as per types and
offsets defined by the @shader. Normally this is generated by
[method@Gsk.GLShader.format_args] or [struct@Gsk.ShaderArgsBuilder].

See [class@Gsk.GLShader] for details about how the shader should be written.

All the children will be rendered into textures (if they aren't already
`GskTextureNodes`, which will be used directly). These textures will be
sent as input to the shader.

If the renderer doesn't support GL shaders, or if there is any problem
when compiling the shader, then the node will draw pink. You should use
[method@Gsk.GLShader.compile] to ensure the @shader will work for the
renderer before using it.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="GLShaderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">the `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the shader into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">Arguments for the uniforms</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="children" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">array of child nodes,
  these will be rendered to textures and used as input.</doc>
            <array length="4" zero-terminated="0" c:type="GskRenderNode**">
              <type name="RenderNode" c:type="GskRenderNode*"/>
            </array>
          </parameter>
          <parameter name="n_children" transfer-ownership="none">
            <doc xml:space="preserve">Length of @children (currently the GL backend supports
  up to 4 children)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_args" c:identifier="gsk_gl_shader_node_get_args" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Gets args for the node.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A `GBytes` with the uniform arguments</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a gl shader</doc>
            <type name="GLShaderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_child" c:identifier="gsk_gl_shader_node_get_child" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Gets one of the children.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @idx'th child of @node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a gl shader</doc>
            <type name="GLShaderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the position of the child to get</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_children" c:identifier="gsk_gl_shader_node_get_n_children" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Returns the number of children</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of children</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a gl shader</doc>
            <type name="GLShaderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_shader" c:identifier="gsk_gl_shader_node_get_shader">
        <doc xml:space="preserve">Gets shader code for the node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the `GskGLShader` shader</doc>
          <type name="GLShader" c:type="GskGLShader*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a gl shader</doc>
            <type name="GLShaderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="GLUniformType" glib:type-name="GskGLUniformType" glib:get-type="gsk_gl_uniform_type_get_type" c:type="GskGLUniformType">
      <doc xml:space="preserve">This defines the types of the uniforms that `GskGLShaders`
declare.

It defines both what the type is called in the GLSL shader
code, and what the corresponding C type is on the Gtk side.</doc>
      <member name="none" value="0" c:identifier="GSK_GL_UNIFORM_TYPE_NONE" glib:nick="none" glib:name="GSK_GL_UNIFORM_TYPE_NONE">
        <doc xml:space="preserve">No type, used for uninitialized or unspecified values.</doc>
      </member>
      <member name="float" value="1" c:identifier="GSK_GL_UNIFORM_TYPE_FLOAT" glib:nick="float" glib:name="GSK_GL_UNIFORM_TYPE_FLOAT">
        <doc xml:space="preserve">A float uniform</doc>
      </member>
      <member name="int" value="2" c:identifier="GSK_GL_UNIFORM_TYPE_INT" glib:nick="int" glib:name="GSK_GL_UNIFORM_TYPE_INT">
        <doc xml:space="preserve">A GLSL int / gint32 uniform</doc>
      </member>
      <member name="uint" value="3" c:identifier="GSK_GL_UNIFORM_TYPE_UINT" glib:nick="uint" glib:name="GSK_GL_UNIFORM_TYPE_UINT">
        <doc xml:space="preserve">A GLSL uint / guint32 uniform</doc>
      </member>
      <member name="bool" value="4" c:identifier="GSK_GL_UNIFORM_TYPE_BOOL" glib:nick="bool" glib:name="GSK_GL_UNIFORM_TYPE_BOOL">
        <doc xml:space="preserve">A GLSL bool / gboolean uniform</doc>
      </member>
      <member name="vec2" value="5" c:identifier="GSK_GL_UNIFORM_TYPE_VEC2" glib:nick="vec2" glib:name="GSK_GL_UNIFORM_TYPE_VEC2">
        <doc xml:space="preserve">A GLSL vec2 / graphene_vec2_t uniform</doc>
      </member>
      <member name="vec3" value="6" c:identifier="GSK_GL_UNIFORM_TYPE_VEC3" glib:nick="vec3" glib:name="GSK_GL_UNIFORM_TYPE_VEC3">
        <doc xml:space="preserve">A GLSL vec3 / graphene_vec3_t uniform</doc>
      </member>
      <member name="vec4" value="7" c:identifier="GSK_GL_UNIFORM_TYPE_VEC4" glib:nick="vec4" glib:name="GSK_GL_UNIFORM_TYPE_VEC4">
        <doc xml:space="preserve">A GLSL vec4 / graphene_vec4_t uniform</doc>
      </member>
    </enumeration>
    <function-macro name="GL_RENDERER" c:identifier="GSK_GL_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_RENDERER_CLASS" c:identifier="GSK_GL_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GL_RENDERER_GET_CLASS" c:identifier="GSK_GL_RENDERER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="INCLUDE_WARNING" c:identifier="GSK_INCLUDE_WARNING" introspectable="0">
      <parameters>
        <parameter name="x">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BROADWAY_RENDERER" c:identifier="GSK_IS_BROADWAY_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BROADWAY_RENDERER_CLASS" c:identifier="GSK_IS_BROADWAY_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_CAIRO_RENDERER" c:identifier="GSK_IS_CAIRO_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_CAIRO_RENDERER_CLASS" c:identifier="GSK_IS_CAIRO_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_RENDERER" c:identifier="GSK_IS_GL_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_GL_RENDERER_CLASS" c:identifier="GSK_IS_GL_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_RENDERER" c:identifier="GSK_IS_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_RENDER_NODE" c:identifier="GSK_IS_RENDER_NODE" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_VULKAN_RENDERER" c:identifier="GSK_IS_VULKAN_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_VULKAN_RENDERER_CLASS" c:identifier="GSK_IS_VULKAN_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <class name="InsetShadowNode" c:symbol-prefix="inset_shadow_node" c:type="GskInsetShadowNode" parent="RenderNode" glib:type-name="GskInsetShadowNode" glib:get-type="gsk_inset_shadow_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for an inset shadow.</doc>
      <constructor name="new" c:identifier="gsk_inset_shadow_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will render an inset shadow
into the box given by @outline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="InsetShadowNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="outline" transfer-ownership="none">
            <doc xml:space="preserve">outline of the region containing the shadow</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">color of the shadow</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve">horizontal offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve">vertical offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="spread" transfer-ownership="none">
            <doc xml:space="preserve">how far the shadow spreads towards the inside</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blur_radius" transfer-ownership="none">
            <doc xml:space="preserve">how much blur to apply to the shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_blur_radius" c:identifier="gsk_inset_shadow_node_get_blur_radius">
        <doc xml:space="preserve">Retrieves the blur radius to apply to the shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blur radius, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color" c:identifier="gsk_inset_shadow_node_get_color">
        <doc xml:space="preserve">Retrieves the color of the inset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color of the shadow</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dx" c:identifier="gsk_inset_shadow_node_get_dx">
        <doc xml:space="preserve">Retrieves the horizontal offset of the inset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dy" c:identifier="gsk_inset_shadow_node_get_dy">
        <doc xml:space="preserve">Retrieves the vertical offset of the inset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_outline" c:identifier="gsk_inset_shadow_node_get_outline">
        <doc xml:space="preserve">Retrieves the outline rectangle of the inset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a rounded rectangle</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_spread" c:identifier="gsk_inset_shadow_node_get_spread">
        <doc xml:space="preserve">Retrieves how much the shadow spreads inwards.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the shadow, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an inset shadow</doc>
            <type name="InsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="LineCap" version="4.14" glib:type-name="GskLineCap" glib:get-type="gsk_line_cap_get_type" c:type="GskLineCap">
      <doc xml:space="preserve">Specifies how to render the start and end points of contours or
dashes when stroking.

The default line cap style is `GSK_LINE_CAP_BUTT`.

New entries may be added in future versions.

&lt;figure&gt;
  &lt;picture&gt;
    &lt;source srcset="caps-dark.png" media="(prefers-color-scheme: dark)"&gt;
    &lt;img alt="Line Cap Styles" src="caps-light.png"&gt;
  &lt;/picture&gt;
  &lt;figcaption&gt;GSK_LINE_CAP_BUTT, GSK_LINE_CAP_ROUND, GSK_LINE_CAP_SQUARE&lt;/figcaption&gt;
&lt;/figure&gt;</doc>
      <member name="butt" value="0" c:identifier="GSK_LINE_CAP_BUTT" glib:nick="butt" glib:name="GSK_LINE_CAP_BUTT">
        <doc xml:space="preserve">Start and stop the line exactly at the start
  and end point</doc>
      </member>
      <member name="round" value="1" c:identifier="GSK_LINE_CAP_ROUND" glib:nick="round" glib:name="GSK_LINE_CAP_ROUND">
        <doc xml:space="preserve">Use a round ending, the center of the circle
  is the start or end point</doc>
      </member>
      <member name="square" value="2" c:identifier="GSK_LINE_CAP_SQUARE" glib:nick="square" glib:name="GSK_LINE_CAP_SQUARE">
        <doc xml:space="preserve">use squared ending, the center of the square
  is the start or end point</doc>
      </member>
    </enumeration>
    <enumeration name="LineJoin" version="4.14" glib:type-name="GskLineJoin" glib:get-type="gsk_line_join_get_type" c:type="GskLineJoin">
      <doc xml:space="preserve">Specifies how to render the junction of two lines when stroking.

The default line join style is `GSK_LINE_JOIN_MITER`.

New entries may be added in future versions.

&lt;figure&gt;
  &lt;picture&gt;
    &lt;source srcset="join-dark.png" media="(prefers-color-scheme: dark)"&gt;
    &lt;img alt="Line Join Styles" src="join-light.png"&gt;
  &lt;/picture&gt;
  &lt;figcaption&gt;GSK_LINE_JOINT_MITER, GSK_LINE_JOINT_ROUND, GSK_LINE_JOIN_BEVEL&lt;/figcaption&gt;
&lt;/figure&gt;</doc>
      <member name="miter" value="0" c:identifier="GSK_LINE_JOIN_MITER" glib:nick="miter" glib:name="GSK_LINE_JOIN_MITER">
        <doc xml:space="preserve">Use a sharp angled corner</doc>
      </member>
      <member name="round" value="1" c:identifier="GSK_LINE_JOIN_ROUND" glib:nick="round" glib:name="GSK_LINE_JOIN_ROUND">
        <doc xml:space="preserve">Use a round join, the center of the circle is
  the join point</doc>
      </member>
      <member name="bevel" value="2" c:identifier="GSK_LINE_JOIN_BEVEL" glib:nick="bevel" glib:name="GSK_LINE_JOIN_BEVEL">
        <doc xml:space="preserve">use a cut-off join, the join is cut off at half
  the line width from the joint point</doc>
      </member>
    </enumeration>
    <class name="LinearGradientNode" c:symbol-prefix="linear_gradient_node" c:type="GskLinearGradientNode" parent="RenderNode" glib:type-name="GskLinearGradientNode" glib:get-type="gsk_linear_gradient_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a linear gradient.</doc>
      <constructor name="new" c:identifier="gsk_linear_gradient_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will create a linear gradient from the given
points and color stops, and render that into the area given by @bounds.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="LinearGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the linear gradient into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will begin</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will finish</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of
  `GskColorStop` defining the gradient. The offsets of all color stops
  must be increasing. The first stop's offset must be &gt;= 0 and the last
  stop's offset must be &lt;= 1.</doc>
            <array length="4" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_color_stops" c:identifier="gsk_linear_gradient_node_get_color_stops">
        <doc xml:space="preserve">Retrieves the color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color stops in the gradient</doc>
          <array length="0" zero-terminated="0" c:type="const GskColorStop*">
            <type name="ColorStop" c:type="GskColorStop"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="n_stops" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of color stops in the returned array</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_end" c:identifier="gsk_linear_gradient_node_get_end">
        <doc xml:space="preserve">Retrieves the final point of the linear gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the final point</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_color_stops" c:identifier="gsk_linear_gradient_node_get_n_color_stops">
        <doc xml:space="preserve">Retrieves the number of color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of color stops</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_start" c:identifier="gsk_linear_gradient_node_get_start">
        <doc xml:space="preserve">Retrieves the initial point of the linear gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initial point</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a linear gradient</doc>
            <type name="LinearGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="MaskMode" version="4.10" glib:type-name="GskMaskMode" glib:get-type="gsk_mask_mode_get_type" c:type="GskMaskMode">
      <doc xml:space="preserve">The mask modes available for mask nodes.</doc>
      <member name="alpha" value="0" c:identifier="GSK_MASK_MODE_ALPHA" glib:nick="alpha" glib:name="GSK_MASK_MODE_ALPHA">
        <doc xml:space="preserve">Use the alpha channel of the mask</doc>
      </member>
      <member name="inverted_alpha" value="1" c:identifier="GSK_MASK_MODE_INVERTED_ALPHA" glib:nick="inverted-alpha" glib:name="GSK_MASK_MODE_INVERTED_ALPHA">
        <doc xml:space="preserve">Use the inverted alpha channel of the mask</doc>
      </member>
      <member name="luminance" value="2" c:identifier="GSK_MASK_MODE_LUMINANCE" glib:nick="luminance" glib:name="GSK_MASK_MODE_LUMINANCE">
        <doc xml:space="preserve">Use the luminance of the mask,
    multiplied by mask alpha</doc>
      </member>
      <member name="inverted_luminance" value="3" c:identifier="GSK_MASK_MODE_INVERTED_LUMINANCE" glib:nick="inverted-luminance" glib:name="GSK_MASK_MODE_INVERTED_LUMINANCE">
        <doc xml:space="preserve">Use the inverted luminance of the mask,
    multiplied by mask alpha</doc>
      </member>
    </enumeration>
    <class name="MaskNode" c:symbol-prefix="mask_node" c:type="GskMaskNode" version="4.10" parent="RenderNode" glib:type-name="GskMaskNode" glib:get-type="gsk_mask_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node masking one child node with another.</doc>
      <constructor name="new" c:identifier="gsk_mask_node_new" version="4.10">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will mask a given node by another.

The @mask_mode determines how the 'mask values' are derived from
the colors of the @mask. Applying the mask consists of multiplying
the 'mask value' with the alpha of the source.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="MaskNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">The source node to be drawn</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">The node to be used as mask</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="mask_mode" transfer-ownership="none">
            <doc xml:space="preserve">The mask mode to use</doc>
            <type name="MaskMode" c:type="GskMaskMode"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_mask" c:identifier="gsk_mask_node_get_mask" version="4.10">
        <doc xml:space="preserve">Retrieves the mask `GskRenderNode` child of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the mask child node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a mask `GskRenderNode`</doc>
            <type name="MaskNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mask_mode" c:identifier="gsk_mask_node_get_mask_mode" version="4.10">
        <doc xml:space="preserve">Retrieves the mask mode used by @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the mask mode</doc>
          <type name="MaskMode" c:type="GskMaskMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a blending `GskRenderNode`</doc>
            <type name="MaskNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source" c:identifier="gsk_mask_node_get_source" version="4.10">
        <doc xml:space="preserve">Retrieves the source `GskRenderNode` child of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the source child node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a mask `GskRenderNode`</doc>
            <type name="MaskNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="NglRenderer" c:symbol-prefix="ngl_renderer" version="4.2" parent="Renderer" glib:type-name="GskNglRenderer" glib:get-type="gsk_ngl_renderer_get_type">
      <doc xml:space="preserve">A GL based renderer.

See [class@Gsk.Renderer].</doc>
      <constructor name="new" c:identifier="gsk_ngl_renderer_new">
        <doc xml:space="preserve">Creates an instance of the new experimental GL renderer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new GL renderer</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <class name="OpacityNode" c:symbol-prefix="opacity_node" c:type="GskOpacityNode" parent="RenderNode" glib:type-name="GskOpacityNode" glib:get-type="gsk_opacity_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node controlling the opacity of its single child node.</doc>
      <constructor name="new" c:identifier="gsk_opacity_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will drawn the @child with reduced
@opacity.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="OpacityNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="opacity" transfer-ownership="none">
            <doc xml:space="preserve">The opacity to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_opacity_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting opacityed by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting opacityed</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an opacity</doc>
            <type name="OpacityNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_opacity" c:identifier="gsk_opacity_node_get_opacity">
        <doc xml:space="preserve">Gets the transparency factor for an opacity node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the opacity factor</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an opacity</doc>
            <type name="OpacityNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="OutsetShadowNode" c:symbol-prefix="outset_shadow_node" c:type="GskOutsetShadowNode" parent="RenderNode" glib:type-name="GskOutsetShadowNode" glib:get-type="gsk_outset_shadow_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for an outset shadow.</doc>
      <constructor name="new" c:identifier="gsk_outset_shadow_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will render an outset shadow
around the box given by @outline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="OutsetShadowNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="outline" transfer-ownership="none">
            <doc xml:space="preserve">outline of the region surrounded by shadow</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">color of the shadow</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve">horizontal offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve">vertical offset of shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="spread" transfer-ownership="none">
            <doc xml:space="preserve">how far the shadow spreads towards the inside</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blur_radius" transfer-ownership="none">
            <doc xml:space="preserve">how much blur to apply to the shadow</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_blur_radius" c:identifier="gsk_outset_shadow_node_get_blur_radius">
        <doc xml:space="preserve">Retrieves the blur radius of the shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blur radius, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color" c:identifier="gsk_outset_shadow_node_get_color">
        <doc xml:space="preserve">Retrieves the color of the outset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a color</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dx" c:identifier="gsk_outset_shadow_node_get_dx">
        <doc xml:space="preserve">Retrieves the horizontal offset of the outset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dy" c:identifier="gsk_outset_shadow_node_get_dy">
        <doc xml:space="preserve">Retrieves the vertical offset of the outset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an offset, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_outline" c:identifier="gsk_outset_shadow_node_get_outline">
        <doc xml:space="preserve">Retrieves the outline rectangle of the outset shadow.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a rounded rectangle</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_spread" c:identifier="gsk_outset_shadow_node_get_spread">
        <doc xml:space="preserve">Retrieves how much the shadow spreads outwards.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the shadow, in pixels</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for an outset shadow</doc>
            <type name="OutsetShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <callback name="ParseErrorFunc" c:type="GskParseErrorFunc">
      <doc xml:space="preserve">Type of callback that is called when an error occurs
during node deserialization.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve">start of the error location</doc>
          <type name="ParseLocation" c:type="const GskParseLocation*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">end of the error location</doc>
          <type name="ParseLocation" c:type="const GskParseLocation*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">the error</doc>
          <type name="GLib.Error" c:type="const GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ParseLocation" c:type="GskParseLocation">
      <doc xml:space="preserve">A location in a parse buffer.</doc>
      <field name="bytes" writable="1">
        <doc xml:space="preserve">the offset of the location in the parse buffer, as bytes</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="chars" writable="1">
        <doc xml:space="preserve">the offset of the location in the parse buffer, as characters</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="lines" writable="1">
        <doc xml:space="preserve">the line of the location in the parse buffer</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="line_bytes" writable="1">
        <doc xml:space="preserve">the position in the line, as bytes</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="line_chars" writable="1">
        <doc xml:space="preserve">the position in the line, as characters</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
    </record>
    <record name="Path" c:type="GskPath" opaque="1" version="4.14" glib:type-name="GskPath" glib:get-type="gsk_path_get_type" c:symbol-prefix="path">
      <doc xml:space="preserve">A `GskPath` describes lines and curves that are more complex
than simple rectangles.

Paths can used for rendering (filling or stroking) and for animations
(e.g. as trajectories).

`GskPath` is an immutable, opaque, reference-counted struct.
After creation, you cannot change the types it represents. Instead,
new `GskPath` objects have to be created. The [struct@Gsk.PathBuilder]
structure is meant to help in this endeavor.

Conceptually, a path consists of zero or more contours (continuous, connected
curves), each of which may or may not be closed. Contours are typically
constructed from B&#xE9;zier segments.

&lt;picture&gt;
  &lt;source srcset="path-dark.png" media="(prefers-color-scheme: dark)"&gt;
  &lt;img alt="A Path" src="path-light.png"&gt;
&lt;/picture&gt;</doc>
      <method name="foreach" c:identifier="gsk_path_foreach" version="4.14">
        <doc xml:space="preserve">Calls @func for every operation of the path.

Note that this may only approximate @self, because paths can contain
optimizations for various specialized contours, and depending on the
@flags, the path may be decomposed into simpler curves than the ones
that it contained originally.

This function serves two purposes:

- When the @flags allow everything, it provides access to the raw,
  unmodified data of the path.
- When the @flags disallow certain operations, it provides
  an approximation of the path using just the allowed operations.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`FALSE` if @func returned FALSE`, `TRUE` otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags to pass to the foreach function. See [flags@Gsk.PathForeachFlags]
  for details about flags</doc>
            <type name="PathForeachFlags" c:type="GskPathForeachFlags"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="2">
            <doc xml:space="preserve">the function to call for operations</doc>
            <type name="PathForeachFunc" c:type="GskPathForeachFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bounds" c:identifier="gsk_path_get_bounds" version="4.14">
        <doc xml:space="preserve">Computes the bounds of the given path.

The returned bounds may be larger than necessary, because this
function aims to be fast, not accurate. The bounds are guaranteed
to contain the path.

It is possible that the returned rectangle has 0 width and/or height.
This can happen when the path only describes a point or an
axis-aligned line.

If the path is empty, `FALSE` is returned and @bounds are set to
graphene_rect_zero(). This is different from the case where the path
is a single point at the origin, where the @bounds will also be set to
the zero rectangle but `TRUE` will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the path has bounds, `FALSE` if the path is known
  to be empty and have no bounds.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
          <parameter name="bounds" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the bounds of the given path</doc>
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_closest_point" c:identifier="gsk_path_get_closest_point" version="4.14">
        <doc xml:space="preserve">Computes the closest point on the path to the given point
and sets the @result to it.

If there is no point closer than the given threshold,
`FALSE` is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if @point was set to the closest point
  on @self, `FALSE` if no point is closer than @threshold</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="threshold" transfer-ownership="none">
            <doc xml:space="preserve">maximum allowed distance</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="result" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the closest point</doc>
            <type name="PathPoint" c:type="GskPathPoint*"/>
          </parameter>
          <parameter name="distance" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return location for the distance</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_end_point" c:identifier="gsk_path_get_end_point" version="4.14">
        <doc xml:space="preserve">Gets the end point of the path.

An empty path has no points, so `FALSE`
is returned in this case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if @result was filled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
          <parameter name="result" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for point</doc>
            <type name="PathPoint" c:type="GskPathPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_start_point" c:identifier="gsk_path_get_start_point" version="4.14">
        <doc xml:space="preserve">Gets the start point of the path.

An empty path has no points, so `FALSE`
is returned in this case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if @result was filled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
          <parameter name="result" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for point</doc>
            <type name="PathPoint" c:type="GskPathPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_stroke_bounds" c:identifier="gsk_path_get_stroke_bounds" version="4.14">
        <doc xml:space="preserve">Computes the bounds for stroking the given path with the
parameters in @stroke.

The returned bounds may be larger than necessary, because this
function aims to be fast, not accurate. The bounds are guaranteed
to contain the area affected by the stroke, including protrusions
like miters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the path has bounds, `FALSE` if the path is known
  to be empty and have no bounds.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GtkPath</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
          <parameter name="stroke" transfer-ownership="none">
            <doc xml:space="preserve">stroke parameters</doc>
            <type name="Stroke" c:type="const GskStroke*"/>
          </parameter>
          <parameter name="bounds" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">the bounds to fill in</doc>
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="in_fill" c:identifier="gsk_path_in_fill" version="4.14">
        <doc xml:space="preserve">Returns whether the given point is inside the area
that would be affected if the path was filled according
to @fill_rule.

Note that this function assumes that filling a contour
implicitly closes it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if @point is inside</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to test</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="fill_rule" transfer-ownership="none">
            <doc xml:space="preserve">the fill rule to follow</doc>
            <type name="FillRule" c:type="GskFillRule"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_closed" c:identifier="gsk_path_is_closed" version="4.14">
        <doc xml:space="preserve">Returns if the path represents a single closed
contour.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the path is closed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="gsk_path_is_empty" version="4.14">
        <doc xml:space="preserve">Checks if the path is empty, i.e. contains no lines or curves.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the path is empty</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="print" c:identifier="gsk_path_print" version="4.14">
        <doc xml:space="preserve">Converts @self into a human-readable string representation suitable
for printing.

The string is compatible with (a superset of)
[SVG path syntax](https://www.w3.org/TR/SVG11/paths.html#PathData),
see [func@Gsk.Path.parse] for a summary of the syntax.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">The string to print into</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_path_ref" version="4.14">
        <doc xml:space="preserve">Increases the reference count of a `GskPath` by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in `GskPath`.</doc>
          <type name="Path" c:type="GskPath*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_cairo" c:identifier="gsk_path_to_cairo" version="4.14">
        <doc xml:space="preserve">Appends the given @path to the given cairo context for drawing
with Cairo.

This may cause some suboptimal conversions to be performed as
Cairo does not support all features of `GskPath`.

This function does not clear the existing Cairo path. Call
cairo_new_path() if you want this.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">a cairo context</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gsk_path_to_string" version="4.14">
        <doc xml:space="preserve">Converts the path into a string that is suitable for printing.

You can use this function in a debugger to get a quick overview
of the path.

This is a wrapper around [method@Gsk.Path.print], see that function
for details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new string for @self</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_path_unref" version="4.14">
        <doc xml:space="preserve">Decreases the reference count of a `GskPath` by one.

If the resulting reference count is zero, frees the path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPath`</doc>
            <type name="Path" c:type="GskPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="parse" c:identifier="gsk_path_parse" version="4.14">
        <doc xml:space="preserve">This is a convenience function that constructs a `GskPath`
from a serialized form.

The string is expected to be in (a superset of)
[SVG path syntax](https://www.w3.org/TR/SVG11/paths.html#PathData),
as e.g. produced by [method@Gsk.Path.to_string].

A high-level summary of the syntax:

- `M x y` Move to `(x, y)`
- `L x y` Add a line from the current point to `(x, y)`
- `Q x1 y1 x2 y2` Add a quadratic B&#xE9;zier from the current point to `(x2, y2)`, with control point `(x1, y1)`
- `C x1 y1 x2 y2 x3 y3` Add a cubic B&#xE9;zier from the current point to `(x3, y3)`, with control points `(x1, y1)` and `(x2, y2)`
- `Z` Close the contour by drawing a line back to the start point
- `H x` Add a horizontal line from the current point to the given x value
- `V y` Add a vertical line from the current point to the given y value
- `T x2 y2` Add a quadratic B&#xE9;zier, using the reflection of the previous segments' control point as control point
- `S x2 y2 x3 y3` Add a cubic B&#xE9;zier, using the reflection of the previous segments' second control point as first control point
- `A rx ry r l s x y` Add an elliptical arc from the current point to `(x, y)` with radii rx and ry. See the SVG documentation for how the other parameters influence the arc.
- `O x1 y1 x2 y2 w` Add a rational quadratic B&#xE9;zier from the current point to `(x2, y2)` with control point `(x1, y1)` and weight `w`.

All the commands have lowercase variants that interpret coordinates
relative to the current point.

The `O` command is an extension that is not supported in SVG.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new `GskPath`, or `NULL` if @string could not be parsed</doc>
          <type name="Path" c:type="GskPath*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PathBuilder" c:type="GskPathBuilder" opaque="1" version="4.14" glib:type-name="GskPathBuilder" glib:get-type="gsk_path_builder_get_type" c:symbol-prefix="path_builder">
      <doc xml:space="preserve">`GskPathBuilder` is an auxiliary object for constructing
`GskPath` objects.

A path is constructed like this:

|[&lt;!-- language="C" --&gt;
GskPath *
construct_path (void)
{
  GskPathBuilder *builder;

  builder = gsk_path_builder_new ();

  // add contours to the path here

  return gsk_path_builder_free_to_path (builder);
]|

Adding contours to the path can be done in two ways.
The easiest option is to use the `gsk_path_builder_add_*` group
of functions that add predefined contours to the current path,
either common shapes like [method@Gsk.PathBuilder.add_circle]
or by adding from other paths like [method@Gsk.PathBuilder.add_path].

The `gsk_path_builder_add_*` methods always add complete contours,
and do not use or modify the current point.

The other option is to define each line and curve manually with
the `gsk_path_builder_*_to` group of functions. You start with
a call to [method@Gsk.PathBuilder.move_to] to set the starting point
and then use multiple calls to any of the drawing functions to
move the pen along the plane. Once you are done, you can call
[method@Gsk.PathBuilder.close] to close the path by connecting it
back with a line to the starting point.

This is similar to how paths are drawn in Cairo.

Note that `GskPathBuilder` will reduce the degree of added B&#xE9;zier
curves as much as possible, to simplify rendering.</doc>
      <constructor name="new" c:identifier="gsk_path_builder_new" version="4.14">
        <doc xml:space="preserve">Create a new `GskPathBuilder` object.

The resulting builder would create an empty `GskPath`.
Use addition functions to add types to it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new `GskPathBuilder`</doc>
          <type name="PathBuilder" c:type="GskPathBuilder*"/>
        </return-value>
      </constructor>
      <method name="add_cairo_path" c:identifier="gsk_path_builder_add_cairo_path" version="4.14">
        <doc xml:space="preserve">Adds a Cairo path to the builder.

You can use cairo_copy_path() to access the path
from a Cairo context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a path</doc>
            <type name="cairo.Path" c:type="const cairo_path_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_circle" c:identifier="gsk_path_builder_add_circle" version="4.14">
        <doc xml:space="preserve">Adds a circle with the @center and @radius.

The path is going around the circle in clockwise direction.

If @radius is zero, the contour will be a closed point.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="center" transfer-ownership="none">
            <doc xml:space="preserve">the center of the circle</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">the radius of the circle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_layout" c:identifier="gsk_path_builder_add_layout" version="4.14">
        <doc xml:space="preserve">Adds the outlines for the glyphs in @layout to the builder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskPathBuilder</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="layout" transfer-ownership="none">
            <doc xml:space="preserve">the pango layout to add</doc>
            <type name="Pango.Layout" c:type="PangoLayout*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_path" c:identifier="gsk_path_builder_add_path" version="4.14">
        <doc xml:space="preserve">Appends all of @path to the builder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to append</doc>
            <type name="Path" c:type="GskPath*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_rect" c:identifier="gsk_path_builder_add_rect" version="4.14">
        <doc xml:space="preserve">Adds @rect as a new contour to the path built by the builder.

The path is going around the rectangle in clockwise direction.

If the the width or height are 0, the path will be a closed
horizontal or vertical line. If both are 0, it'll be a closed dot.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">The rectangle to create a path for</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_reverse_path" c:identifier="gsk_path_builder_add_reverse_path" version="4.14">
        <doc xml:space="preserve">Appends all of @path to the builder, in reverse order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to append</doc>
            <type name="Path" c:type="GskPath*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_rounded_rect" c:identifier="gsk_path_builder_add_rounded_rect" version="4.14">
        <doc xml:space="preserve">Adds @rect as a new contour to the path built in @self.

The path is going around the rectangle in clockwise direction.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskPathBuilder</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rounded rect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_segment" c:identifier="gsk_path_builder_add_segment" version="4.14">
        <doc xml:space="preserve">Adds to @self the segment of @path from @start to @end.

If @start is equal to or after @end, the path will first add the
segment from @start to the end of the path, and then add the segment
from the beginning to @end. If the path is closed, these segments
will be connected.

Note that this method always adds a path with the given start point
and end point. To add a closed path, use [method@Gsk.PathBuilder.add_path].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the `GskPath` to take the segment to</doc>
            <type name="Path" c:type="GskPath*"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the point on @path to start at</doc>
            <type name="PathPoint" c:type="const GskPathPoint*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the point on @path to end at</doc>
            <type name="PathPoint" c:type="const GskPathPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="arc_to" c:identifier="gsk_path_builder_arc_to" version="4.14">
        <doc xml:space="preserve">Adds an elliptical arc from the current point to @x2, @y2
with @x1, @y1 determining the tangent directions.

After this, @x2, @y2 will be the new current point.

Note: Two points and their tangents do not determine
a unique ellipse, so GSK just picks one. If you need more
precise control, use [method@Gsk.PathBuilder.conic_to]
or [method@Gsk.PathBuilder.svg_arc_to].

&lt;picture&gt;
  &lt;source srcset="arc-dark.png" media="(prefers-color-scheme: dark)"&gt;
  &lt;img alt="Arc To" src="arc-light.png"&gt;
&lt;/picture&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="close" c:identifier="gsk_path_builder_close" version="4.14">
        <doc xml:space="preserve">Ends the current contour with a line back to the start point.

Note that this is different from calling [method@Gsk.PathBuilder.line_to]
with the start point in that the contour will be closed. A closed
contour behaves differently from an open one. When stroking, its
start and end point are considered connected, so they will be
joined via the line join, and not ended with line caps.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="conic_to" c:identifier="gsk_path_builder_conic_to" version="4.14">
        <doc xml:space="preserve">Adds a [conic curve](https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline)
from the current point to @x2, @y2 with the given @weight and @x1, @y1 as the
control point.

The weight determines how strongly the curve is pulled towards the control point.
A conic with weight 1 is identical to a quadratic B&#xE9;zier curve with the same points.

Conic curves can be used to draw ellipses and circles. They are also known as
rational quadratic B&#xE9;zier curves.

After this, @x2, @y2 will be the new current point.

&lt;picture&gt;
  &lt;source srcset="conic-dark.png" media="(prefers-color-scheme: dark)"&gt;
  &lt;img alt="Conic To" src="conic-light.png"&gt;
&lt;/picture&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="weight" transfer-ownership="none">
            <doc xml:space="preserve">weight of the control point, must be greater than zero</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="cubic_to" c:identifier="gsk_path_builder_cubic_to" version="4.14">
        <doc xml:space="preserve">Adds a [cubic B&#xE9;zier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)
from the current point to @x3, @y3 with @x1, @y1 and @x2, @y2 as the control
points.

After this, @x3, @y3 will be the new current point.

&lt;picture&gt;
  &lt;source srcset="cubic-dark.png" media="(prefers-color-scheme: dark)"&gt;
  &lt;img alt="Cubic To" src="cubic-light.png"&gt;
&lt;/picture&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x3" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y3" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="free_to_path" c:identifier="gsk_path_builder_free_to_path" version="4.14" introspectable="0">
        <doc xml:space="preserve">Creates a new `GskPath` from the current state of the
given builder, and unrefs the @builder instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created `GskPath`
  with all the contours added to the builder</doc>
          <type name="Path" c:type="GskPath*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_current_point" c:identifier="gsk_path_builder_get_current_point" version="4.14">
        <doc xml:space="preserve">Gets the current point.

The current point is used for relative drawing commands and
updated after every operation.

When the builder is created, the default current point is set
to `0, 0`. Note that this is different from cairo, which starts
out without a current point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current point</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="html_arc_to" c:identifier="gsk_path_builder_html_arc_to" version="4.14">
        <doc xml:space="preserve">Implements arc-to according to the HTML Canvas spec.

A convenience function that implements the
[HTML arc_to](https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-arcto-dev)
functionality.

After this, the current point will be the point where
the circle with the given radius touches the line from
@x1, @y1 to @x2, @y2.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">X coordinate of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">Y coordinate of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">X coordinate of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">Y coordinate of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">Radius of the circle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="line_to" c:identifier="gsk_path_builder_line_to" version="4.14">
        <doc xml:space="preserve">Draws a line from the current point to @x, @y and makes it
the new current point.

&lt;picture&gt;
  &lt;source srcset="line-dark.png" media="(prefers-color-scheme: dark)"&gt;
  &lt;img alt="Line To" src="line-light.png"&gt;
&lt;/picture&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="move_to" c:identifier="gsk_path_builder_move_to" version="4.14">
        <doc xml:space="preserve">Starts a new contour by placing the pen at @x, @y.

If this function is called twice in succession, the first
call will result in a contour made up of a single point.
The second call will start a new contour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="quad_to" c:identifier="gsk_path_builder_quad_to" version="4.14">
        <doc xml:space="preserve">Adds a [quadratic B&#xE9;zier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)
from the current point to @x2, @y2 with @x1, @y1 as the control point.

After this, @x2, @y2 will be the new current point.

&lt;picture&gt;
  &lt;source srcset="quad-dark.png" media="(prefers-color-scheme: dark)"&gt;
  &lt;img alt="Quad To" src="quad-light.png"&gt;
&lt;/picture&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskPathBuilder</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_path_builder_ref" version="4.14">
        <doc xml:space="preserve">Acquires a reference on the given builder.

This function is intended primarily for language bindings.
`GskPathBuilder` objects should not be kept around.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the given `GskPathBuilder` with
  its reference count increased</doc>
          <type name="PathBuilder" c:type="GskPathBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rel_arc_to" c:identifier="gsk_path_builder_rel_arc_to" version="4.14">
        <doc xml:space="preserve">Adds an elliptical arc from the current point to @x2, @y2
with @x1, @y1 determining the tangent directions.

All coordinates are given relative to the current point.

This is the relative version of [method@Gsk.PathBuilder.arc_to].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rel_conic_to" c:identifier="gsk_path_builder_rel_conic_to" version="4.14">
        <doc xml:space="preserve">Adds a [conic curve](https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline)
from the current point to @x2, @y2 with the given @weight and @x1, @y1 as the
control point.

All coordinates are given relative to the current point.

This is the relative version of [method@Gsk.PathBuilder.conic_to].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">x offset of control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">y offset of control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">x offset of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">y offset of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="weight" transfer-ownership="none">
            <doc xml:space="preserve">weight of the curve, must be greater than zero</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rel_cubic_to" c:identifier="gsk_path_builder_rel_cubic_to" version="4.14">
        <doc xml:space="preserve">Adds a [cubic B&#xE9;zier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)
from the current point to @x3, @y3 with @x1, @y1 and @x2, @y2 as the control
points.

All coordinates are given relative to the current point.

This is the relative version of [method@Gsk.PathBuilder.cubic_to].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">x offset of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">y offset of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">x offset of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">y offset of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x3" transfer-ownership="none">
            <doc xml:space="preserve">x offset of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y3" transfer-ownership="none">
            <doc xml:space="preserve">y offset of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rel_html_arc_to" c:identifier="gsk_path_builder_rel_html_arc_to" version="4.14">
        <doc xml:space="preserve">Implements arc-to according to the HTML Canvas spec.

All coordinates are given relative to the current point.

This is the relative version of [method@Gsk.PathBuilder.html_arc_to].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">X coordinate of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">Y coordinate of first control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">X coordinate of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">Y coordinate of second control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">Radius of the circle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rel_line_to" c:identifier="gsk_path_builder_rel_line_to" version="4.14">
        <doc xml:space="preserve">Draws a line from the current point to a point offset from it
by @x, @y and makes it the new current point.

This is the relative version of [method@Gsk.PathBuilder.line_to].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rel_move_to" c:identifier="gsk_path_builder_rel_move_to" version="4.14">
        <doc xml:space="preserve">Starts a new contour by placing the pen at @x, @y
relative to the current point.

This is the relative version of [method@Gsk.PathBuilder.move_to].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rel_quad_to" c:identifier="gsk_path_builder_rel_quad_to" version="4.14">
        <doc xml:space="preserve">Adds a [quadratic B&#xE9;zier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve)
from the current point to @x2, @y2 with @x1, @y1 the control point.

All coordinates are given relative to the current point.

This is the relative version of [method@Gsk.PathBuilder.quad_to].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="x1" transfer-ownership="none">
            <doc xml:space="preserve">x offset of control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y1" transfer-ownership="none">
            <doc xml:space="preserve">y offset of control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x2" transfer-ownership="none">
            <doc xml:space="preserve">x offset of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y2" transfer-ownership="none">
            <doc xml:space="preserve">y offset of the end of the curve</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rel_svg_arc_to" c:identifier="gsk_path_builder_rel_svg_arc_to" version="4.14">
        <doc xml:space="preserve">Implements arc-to according to the SVG spec.

All coordinates are given relative to the current point.

This is the relative version of [method@Gsk.PathBuilder.svg_arc_to].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="rx" transfer-ownership="none">
            <doc xml:space="preserve">X radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="ry" transfer-ownership="none">
            <doc xml:space="preserve">Y radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_axis_rotation" transfer-ownership="none">
            <doc xml:space="preserve">the rotation of the ellipsis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="large_arc" transfer-ownership="none">
            <doc xml:space="preserve">whether to add the large arc</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="positive_sweep" transfer-ownership="none">
            <doc xml:space="preserve">whether to sweep in the positive direction</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the X coordinate of the endpoint</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the Y coordinate of the endpoint</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="svg_arc_to" c:identifier="gsk_path_builder_svg_arc_to" version="4.14">
        <doc xml:space="preserve">Implements arc-to according to the SVG spec.

A convenience function that implements the
[SVG arc_to](https://www.w3.org/TR/SVG11/paths.html#PathDataEllipticalArcCommands)
functionality.

After this, @x, @y will be the new current point.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
          <parameter name="rx" transfer-ownership="none">
            <doc xml:space="preserve">X radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="ry" transfer-ownership="none">
            <doc xml:space="preserve">Y radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_axis_rotation" transfer-ownership="none">
            <doc xml:space="preserve">the rotation of the ellipsis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="large_arc" transfer-ownership="none">
            <doc xml:space="preserve">whether to add the large arc</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="positive_sweep" transfer-ownership="none">
            <doc xml:space="preserve">whether to sweep in the positive direction</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">the X coordinate of the endpoint</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">the Y coordinate of the endpoint</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_path" c:identifier="gsk_path_builder_to_path" version="4.14">
        <doc xml:space="preserve">Creates a new `GskPath` from the given builder.

The given `GskPathBuilder` is reset once this function returns;
you cannot call this function multiple times on the same builder
instance.

This function is intended primarily for language bindings.
C code should use [method@Gsk.PathBuilder.free_to_path].</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly created `GskPath`
  with all the contours added to the builder</doc>
          <type name="Path" c:type="GskPath*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_path_builder_unref" version="4.14">
        <doc xml:space="preserve">Releases a reference on the given builder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathBuilder`</doc>
            <type name="PathBuilder" c:type="GskPathBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="PathDirection" version="4.14" glib:type-name="GskPathDirection" glib:get-type="gsk_path_direction_get_type" c:type="GskPathDirection">
      <doc xml:space="preserve">The values of the `GskPathDirection` enum are used to pick one
of the four tangents at a given point on the path.

Note that the directions for @GSK_PATH_FROM_START/@GSK_PATH_TO_END and
@GSK_PATH_TO_START/@GSK_PATH_FROM_END will coincide for smooth points.
Only sharp turns will exhibit four different directions.

&lt;picture&gt;
  &lt;source srcset="directions-dark.png" media="(prefers-color-scheme: dark)"&gt;
  &lt;img alt="Path Tangents" src="directions-light.png"&gt;
&lt;/picture&gt;</doc>
      <member name="from_start" value="0" c:identifier="GSK_PATH_FROM_START" glib:nick="from-start" glib:name="GSK_PATH_FROM_START">
        <doc xml:space="preserve">The tangent in path direction of the incoming side
  of the path</doc>
      </member>
      <member name="to_start" value="1" c:identifier="GSK_PATH_TO_START" glib:nick="to-start" glib:name="GSK_PATH_TO_START">
        <doc xml:space="preserve">The tangent against path direction of the incoming side
  of the path</doc>
      </member>
      <member name="to_end" value="2" c:identifier="GSK_PATH_TO_END" glib:nick="to-end" glib:name="GSK_PATH_TO_END">
        <doc xml:space="preserve">The tangent in path direction of the outgoing side
  of the path</doc>
      </member>
      <member name="from_end" value="3" c:identifier="GSK_PATH_FROM_END" glib:nick="from-end" glib:name="GSK_PATH_FROM_END">
        <doc xml:space="preserve">The tangent against path direction of the outgoing
  side of the path</doc>
      </member>
    </enumeration>
    <bitfield name="PathForeachFlags" version="4.14" glib:type-name="GskPathForeachFlags" glib:get-type="gsk_path_foreach_flags_get_type" c:type="GskPathForeachFlags">
      <doc xml:space="preserve">Flags that can be passed to gsk_path_foreach() to influence what
kinds of operations the path is decomposed into.

By default, [method@Gsk.Path.foreach] will only emit a path with all
operations flattened to straight lines to allow for maximum compatibility.
The only operations emitted will be `GSK_PATH_MOVE`, `GSK_PATH_LINE` and
`GSK_PATH_CLOSE`.</doc>
      <member name="only_lines" value="0" c:identifier="GSK_PATH_FOREACH_ALLOW_ONLY_LINES" glib:nick="only-lines" glib:name="GSK_PATH_FOREACH_ALLOW_ONLY_LINES">
        <doc xml:space="preserve">The default behavior, only allow lines.</doc>
      </member>
      <member name="quad" value="1" c:identifier="GSK_PATH_FOREACH_ALLOW_QUAD" glib:nick="quad" glib:name="GSK_PATH_FOREACH_ALLOW_QUAD">
        <doc xml:space="preserve">Allow emission of `GSK_PATH_QUAD` operations</doc>
      </member>
      <member name="cubic" value="2" c:identifier="GSK_PATH_FOREACH_ALLOW_CUBIC" glib:nick="cubic" glib:name="GSK_PATH_FOREACH_ALLOW_CUBIC">
        <doc xml:space="preserve">Allow emission of `GSK_PATH_CUBIC` operations.</doc>
      </member>
      <member name="conic" value="4" c:identifier="GSK_PATH_FOREACH_ALLOW_CONIC" glib:nick="conic" glib:name="GSK_PATH_FOREACH_ALLOW_CONIC">
        <doc xml:space="preserve">Allow emission of `GSK_PATH_CONIC` operations.</doc>
      </member>
    </bitfield>
    <callback name="PathForeachFunc" c:type="GskPathForeachFunc">
      <doc xml:space="preserve">Prototype of the callback to iterate through the operations of
a path.

For each operation, the callback is given the @op itself, the points
that the operation is applied to in @pts, and a @weight for conic
curves. The @n_pts argument is somewhat redundant, since the number
of points can be inferred from the operation.

Each contour of the path starts with a @GSK_PATH_MOVE operation.
Closed contours end with a @GSK_PATH_CLOSE operation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE to continue iterating the path, %FALSE to
  immediately abort and not call the function again.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="op" transfer-ownership="none">
          <doc xml:space="preserve">The operation</doc>
          <type name="PathOperation" c:type="GskPathOperation"/>
        </parameter>
        <parameter name="pts" transfer-ownership="none">
          <doc xml:space="preserve">The points of the operation</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </parameter>
        <parameter name="n_pts" transfer-ownership="none">
          <doc xml:space="preserve">The number of points</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="weight" transfer-ownership="none">
          <doc xml:space="preserve">The weight for conic curves, or unused if not a conic curve</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
          <doc xml:space="preserve">The user data provided with the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PathMeasure" c:type="GskPathMeasure" opaque="1" version="4.14" glib:type-name="GskPathMeasure" glib:get-type="gsk_path_measure_get_type" c:symbol-prefix="path_measure">
      <doc xml:space="preserve">`GskPathMeasure` is an object that allows measurements
on `GskPath`s such as determining the length of the path.

Many measuring operations require sampling the path length
at intermediate points. Therefore, a `GskPathMeasure` has
a tolerance that determines what precision is required
for such approximations.

A `GskPathMeasure` struct is a reference counted struct
and should be treated as opaque.</doc>
      <constructor name="new" c:identifier="gsk_path_measure_new" version="4.14">
        <doc xml:space="preserve">Creates a measure object for the given @path with the
default tolerance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new `GskPathMeasure` representing @path</doc>
          <type name="PathMeasure" c:type="GskPathMeasure*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to measure</doc>
            <type name="Path" c:type="GskPath*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_tolerance" c:identifier="gsk_path_measure_new_with_tolerance" version="4.14">
        <doc xml:space="preserve">Creates a measure object for the given @path and @tolerance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new `GskPathMeasure` representing @path</doc>
          <type name="PathMeasure" c:type="GskPathMeasure*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to measure</doc>
            <type name="Path" c:type="GskPath*"/>
          </parameter>
          <parameter name="tolerance" transfer-ownership="none">
            <doc xml:space="preserve">the tolerance for measuring operations</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_length" c:identifier="gsk_path_measure_get_length" version="4.14">
        <doc xml:space="preserve">Gets the length of the path being measured.

The length is cached, so this function does not do any work.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The length of the path measured by @self</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathMeasure`</doc>
            <type name="PathMeasure" c:type="GskPathMeasure*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="gsk_path_measure_get_path" version="4.14">
        <doc xml:space="preserve">Returns the path that the measure was created for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the path of @self</doc>
          <type name="Path" c:type="GskPath*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathMeasure`</doc>
            <type name="PathMeasure" c:type="GskPathMeasure*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_point" c:identifier="gsk_path_measure_get_point" version="4.14">
        <doc xml:space="preserve">Sets @result to the point at the given distance into the path.

An empty path has no points, so `FALSE` is returned in that case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if @result was set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathMeasure`</doc>
            <type name="PathMeasure" c:type="GskPathMeasure*"/>
          </instance-parameter>
          <parameter name="distance" transfer-ownership="none">
            <doc xml:space="preserve">the distance</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="result" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result</doc>
            <type name="PathPoint" c:type="GskPathPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_tolerance" c:identifier="gsk_path_measure_get_tolerance" version="4.14">
        <doc xml:space="preserve">Returns the tolerance that the measure was created with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the tolerance of @self</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathMeasure`</doc>
            <type name="PathMeasure" c:type="GskPathMeasure*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_path_measure_ref" version="4.14">
        <doc xml:space="preserve">Increases the reference count of a `GskPathMeasure` by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in `GskPathMeasure`.</doc>
          <type name="PathMeasure" c:type="GskPathMeasure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathMeasure`</doc>
            <type name="PathMeasure" c:type="GskPathMeasure*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_path_measure_unref" version="4.14">
        <doc xml:space="preserve">Decreases the reference count of a `GskPathMeasure` by one.

If the resulting reference count is zero, frees the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathMeasure`</doc>
            <type name="PathMeasure" c:type="GskPathMeasure*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="PathOperation" version="4.14" glib:type-name="GskPathOperation" glib:get-type="gsk_path_operation_get_type" c:type="GskPathOperation">
      <doc xml:space="preserve">Path operations are used to describe the segments of a `GskPath`.

More values may be added in the future.</doc>
      <member name="move" value="0" c:identifier="GSK_PATH_MOVE" glib:nick="move" glib:name="GSK_PATH_MOVE">
        <doc xml:space="preserve">A move-to operation, with 1 point describing the target point.</doc>
      </member>
      <member name="close" value="1" c:identifier="GSK_PATH_CLOSE" glib:nick="close" glib:name="GSK_PATH_CLOSE">
        <doc xml:space="preserve">A close operation ending the current contour with a line back
  to the starting point. Two points describe the start and end of the line.</doc>
      </member>
      <member name="line" value="2" c:identifier="GSK_PATH_LINE" glib:nick="line" glib:name="GSK_PATH_LINE">
        <doc xml:space="preserve">A line-to operation, with 2 points describing the start and
  end point of a straight line.</doc>
      </member>
      <member name="quad" value="3" c:identifier="GSK_PATH_QUAD" glib:nick="quad" glib:name="GSK_PATH_QUAD">
        <doc xml:space="preserve">A curve-to operation describing a quadratic B&#xE9;zier curve
  with 3 points describing the start point, the control point and the end
  point of the curve.</doc>
      </member>
      <member name="cubic" value="4" c:identifier="GSK_PATH_CUBIC" glib:nick="cubic" glib:name="GSK_PATH_CUBIC">
        <doc xml:space="preserve">A curve-to operation describing a cubic B&#xE9;zier curve with 4
  points describing the start point, the two control points and the end point
  of the curve.</doc>
      </member>
      <member name="conic" value="5" c:identifier="GSK_PATH_CONIC" glib:nick="conic" glib:name="GSK_PATH_CONIC">
        <doc xml:space="preserve">A rational quadratic B&#xE9;zier curve with 3 points describing
  the start point, control point and end point of the curve. A weight for the
  curve will be passed, too.</doc>
      </member>
    </enumeration>
    <record name="PathPoint" c:type="GskPathPoint" version="4.14" glib:type-name="GskPathPoint" glib:get-type="gsk_path_point_get_type" c:symbol-prefix="path_point">
      <doc xml:space="preserve">`GskPathPoint` is an opaque type representing a point on a path.

It can be queried for properties of the path at that point, such as
its tangent or its curvature.

To obtain a `GskPathPoint`, use [method@Gsk.Path.get_closest_point],
[method@Gsk.Path.get_start_point], [method@Gsk.Path.get_end_point]
or [method@Gsk.PathMeasure.get_point].

Note that `GskPathPoint` structs are meant to be stack-allocated,
and don't hold a reference to the path object they are obtained from.
It is the callers responsibility to keep a reference to the path
as long as the `GskPathPoint` is used.</doc>
      <union>
        <record>
          <field name="contour" writable="1">
            <type name="gsize" c:type="gsize"/>
          </field>
          <field name="idx" writable="1">
            <type name="gsize" c:type="gsize"/>
          </field>
          <field name="t" writable="1">
            <type name="gfloat" c:type="float"/>
          </field>
        </record>
        <field name="padding" writable="1">
          <array zero-terminated="0" fixed-size="8">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
        <field name="alignment" writable="1">
          <type name="Graphene.Vec4" c:type="graphene_vec4_t"/>
        </field>
      </union>
      <method name="compare" c:identifier="gsk_path_point_compare" version="4.14">
        <doc xml:space="preserve">Returns whether @point1 is before or after @point2.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 if @point1 is before @point2,
  1 if @point1 is after @point2,
  0 if they are equal</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="point1" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathPoint`</doc>
            <type name="PathPoint" c:type="const GskPathPoint*"/>
          </instance-parameter>
          <parameter name="point2" transfer-ownership="none">
            <doc xml:space="preserve">another `GskPathPoint`</doc>
            <type name="PathPoint" c:type="const GskPathPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gsk_path_point_copy" version="4.14">
        <doc xml:space="preserve">Copies a path point.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the copied point</doc>
          <type name="PathPoint" c:type="GskPathPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a path point</doc>
            <type name="PathPoint" c:type="GskPathPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="gsk_path_point_equal" version="4.14">
        <doc xml:space="preserve">Returns whether the two path points refer to the same
location on all paths.

Note that the start- and endpoint of a closed contour
will compare nonequal according to this definition.
Use [method@Gsk.Path.is_closed] to find out if the
start- and endpoint of a concrete path refer to the
same location.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if @point1 and @point2 are equal</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="point1" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathPoint`</doc>
            <type name="PathPoint" c:type="const GskPathPoint*"/>
          </instance-parameter>
          <parameter name="point2" transfer-ownership="none">
            <doc xml:space="preserve">another `GskPathPoint`</doc>
            <type name="PathPoint" c:type="const GskPathPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gsk_path_point_free" version="4.14">
        <doc xml:space="preserve">Frees a path point copied by [method@Gsk.PathPoint.copy].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a path point</doc>
            <type name="PathPoint" c:type="GskPathPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_curvature" c:identifier="gsk_path_point_get_curvature" version="4.14">
        <doc xml:space="preserve">Calculates the curvature of the path at the point.

Optionally, returns the center of the osculating circle as well.
The curvature is the inverse of the radius of the osculating circle.

Lines have a curvature of zero (indicating an osculating circle of
infinite radius. In this case, the @center is not modified.

Circles with a radius of zero have `INFINITY` as curvature

Note that certain points on a path may not have a single curvature,
such as sharp turns. At such points, there are two curvatures --
the (limit of) the curvature of the path going into the point,
and the (limit of) the curvature of the path coming out of it.
The @direction argument lets you choose which one to get.

&lt;picture&gt;
  &lt;source srcset="curvature-dark.png" media="(prefers-color-scheme: dark)"&gt;
  &lt;img alt="Osculating circle" src="curvature-light.png"&gt;
&lt;/picture&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The curvature of the path at the given point</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathPoint`</doc>
            <type name="PathPoint" c:type="const GskPathPoint*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path that @point is on</doc>
            <type name="Path" c:type="GskPath*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">the direction for which to return the curvature</doc>
            <type name="PathDirection" c:type="GskPathDirection"/>
          </parameter>
          <parameter name="center" direction="out" caller-allocates="1" transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">Return location for
  the center of the osculating circle</doc>
            <type name="Graphene.Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_distance" c:identifier="gsk_path_point_get_distance" version="4.14">
        <doc xml:space="preserve">Returns the distance from the beginning of the path
to @point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the distance of @point</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathPoint on the path</doc>
            <type name="PathPoint" c:type="const GskPathPoint*"/>
          </instance-parameter>
          <parameter name="measure" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathMeasure` for the path</doc>
            <type name="PathMeasure" c:type="GskPathMeasure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_position" c:identifier="gsk_path_point_get_position" version="4.14">
        <doc xml:space="preserve">Gets the position of the point.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathPoint`</doc>
            <type name="PathPoint" c:type="const GskPathPoint*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path that @point is on</doc>
            <type name="Path" c:type="GskPath*"/>
          </parameter>
          <parameter name="position" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">Return location for
  the coordinates of the point</doc>
            <type name="Graphene.Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_rotation" c:identifier="gsk_path_point_get_rotation" version="4.14">
        <doc xml:space="preserve">Gets the direction of the tangent at a given point.

This is a convenience variant of [method@Gsk.PathPoint.get_tangent]
that returns the angle between the tangent and the X axis. The angle
can e.g. be used in
[gtk_snapshot_rotate()](../gtk4/method.Snapshot.rotate.html).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the angle between the tangent and the X axis, in degrees</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathPoint`</doc>
            <type name="PathPoint" c:type="const GskPathPoint*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path that @point is on</doc>
            <type name="Path" c:type="GskPath*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">the direction for which to return the rotation</doc>
            <type name="PathDirection" c:type="GskPathDirection"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_tangent" c:identifier="gsk_path_point_get_tangent" version="4.14">
        <doc xml:space="preserve">Gets the tangent of the path at the point.

Note that certain points on a path may not have a single
tangent, such as sharp turns. At such points, there are
two tangents -- the direction of the path going into the
point, and the direction coming out of it. The @direction
argument lets you choose which one to get.

If the path is just a single point (e.g. a circle with
radius zero), then @tangent is set to `0, 0`.

If you want to orient something in the direction of the
path, [method@Gsk.PathPoint.get_rotation] may be more
convenient to use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a `GskPathPoint`</doc>
            <type name="PathPoint" c:type="const GskPathPoint*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path that @point is on</doc>
            <type name="Path" c:type="GskPath*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">the direction for which to return the tangent</doc>
            <type name="PathDirection" c:type="GskPathDirection"/>
          </parameter>
          <parameter name="tangent" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">Return location for
  the tangent at the point</doc>
            <type name="Graphene.Vec2" c:type="graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <function-macro name="RENDERER" c:identifier="GSK_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ROUNDED_RECT_INIT" c:identifier="GSK_ROUNDED_RECT_INIT" introspectable="0">
      <doc xml:space="preserve">Initializes a `GskRoundedRect` when declaring it.
All corner sizes will be initialized to 0.</doc>
      <parameters>
        <parameter name="_x">
          <doc xml:space="preserve">the X coordinate of the origin</doc>
        </parameter>
        <parameter name="_y">
          <doc xml:space="preserve">the Y coordinate of the origin</doc>
        </parameter>
        <parameter name="_w">
          <doc xml:space="preserve">the width</doc>
        </parameter>
        <parameter name="_h">
          <doc xml:space="preserve">the height</doc>
        </parameter>
      </parameters>
    </function-macro>
    <class name="RadialGradientNode" c:symbol-prefix="radial_gradient_node" c:type="GskRadialGradientNode" parent="RenderNode" glib:type-name="GskRadialGradientNode" glib:get-type="gsk_radial_gradient_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a radial gradient.</doc>
      <constructor name="new" c:identifier="gsk_radial_gradient_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that draws a radial gradient.

The radial gradient
starts around @center. The size of the gradient is dictated by @hradius
in horizontal orientation and by @vradius in vertical orientation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="RadialGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the bounds of the node</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="center" transfer-ownership="none">
            <doc xml:space="preserve">the center of the gradient</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="hradius" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="vradius" transfer-ownership="none">
            <doc xml:space="preserve">the vertical radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">a percentage &gt;= 0 that defines the start of the gradient around @center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">a percentage &gt;= 0 that defines the end of the gradient around @center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of
  `GskColorStop` defining the gradient. The offsets of all color stops
  must be increasing. The first stop's offset must be &gt;= 0 and the last
  stop's offset must be &lt;= 1.</doc>
            <array length="7" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_center" c:identifier="gsk_radial_gradient_node_get_center">
        <doc xml:space="preserve">Retrieves the center pointer for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the center point for the gradient</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_stops" c:identifier="gsk_radial_gradient_node_get_color_stops">
        <doc xml:space="preserve">Retrieves the color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the color stops in the gradient</doc>
          <array length="0" zero-terminated="0" c:type="const GskColorStop*">
            <type name="ColorStop" c:type="GskColorStop"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="n_stops" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of color stops in the returned array</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_end" c:identifier="gsk_radial_gradient_node_get_end">
        <doc xml:space="preserve">Retrieves the end value for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the end value for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hradius" c:identifier="gsk_radial_gradient_node_get_hradius">
        <doc xml:space="preserve">Retrieves the horizontal radius for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the horizontal radius for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_color_stops" c:identifier="gsk_radial_gradient_node_get_n_color_stops">
        <doc xml:space="preserve">Retrieves the number of color stops in the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of color stops</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_start" c:identifier="gsk_radial_gradient_node_get_start">
        <doc xml:space="preserve">Retrieves the start value for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the start value for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vradius" c:identifier="gsk_radial_gradient_node_get_vradius">
        <doc xml:space="preserve">Retrieves the vertical radius for the gradient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the vertical radius for the gradient</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a radial gradient</doc>
            <type name="RadialGradientNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="RenderNode" c:symbol-prefix="render_node" c:type="GskRenderNode" abstract="1" glib:type-name="GskRenderNode" glib:get-type="gsk_render_node_get_type" glib:fundamental="1" glib:ref-func="gsk_render_node_ref" glib:unref-func="gsk_render_node_unref" glib:set-value-func="gsk_value_set_render_node" glib:get-value-func="gsk_value_get_render_node">
      <doc xml:space="preserve">`GskRenderNode` is the basic block in a scene graph to be
rendered using [class@Gsk.Renderer].

Each node has a parent, except the top-level node; each node may have
children nodes.

Each node has an associated drawing surface, which has the size of
the rectangle set when creating it.

Render nodes are meant to be transient; once they have been associated
to a [class@Gsk.Renderer] it's safe to release any reference you have on
them. All [class@Gsk.RenderNode]s are immutable, you can only specify their
properties during construction.</doc>
      <function name="deserialize" c:identifier="gsk_render_node_deserialize">
        <doc xml:space="preserve">Loads data previously created via [method@Gsk.RenderNode.serialize].

For a discussion of the supported format, see that function.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new `GskRenderNode`</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">the bytes containing the data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="error_func" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="2">
            <doc xml:space="preserve">Callback on parsing errors</doc>
            <type name="ParseErrorFunc" c:type="GskParseErrorFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user_data for @error_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="draw" c:identifier="gsk_render_node_draw">
        <doc xml:space="preserve">Draw the contents of @node to the given cairo context.

Typically, you'll use this function to implement fallback rendering
of `GskRenderNode`s on an intermediate Cairo context, instead of using
the drawing context associated to a [class@Gdk.Surface]'s rendering buffer.

For advanced nodes that cannot be supported using Cairo, in particular
for nodes doing 3D operations, this function may fail.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode`</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">cairo context to draw to</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bounds" c:identifier="gsk_render_node_get_bounds">
        <doc xml:space="preserve">Retrieves the boundaries of the @node.

The node will not draw outside of its boundaries.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode`</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="bounds" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the boundaries</doc>
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_node_type" c:identifier="gsk_render_node_get_node_type">
        <doc xml:space="preserve">Returns the type of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the `GskRenderNode`</doc>
          <type name="RenderNodeType" c:type="GskRenderNodeType"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode`</doc>
            <type name="RenderNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_render_node_ref">
        <doc xml:space="preserve">Acquires a reference on the given `GskRenderNode`.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the `GskRenderNode` with an additional reference</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode`</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="serialize" c:identifier="gsk_render_node_serialize">
        <doc xml:space="preserve">Serializes the @node for later deserialization via
gsk_render_node_deserialize(). No guarantees are made about the format
used other than that the same version of GTK will be able to deserialize
the result of a call to gsk_render_node_serialize() and
gsk_render_node_deserialize() will correctly reject files it cannot open
that were created with previous versions of GTK.

The intended use of this functions is testing, benchmarking and debugging.
The format is not meant as a permanent storage format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a `GBytes` representing the node.</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode`</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_render_node_unref">
        <doc xml:space="preserve">Releases a reference on the given `GskRenderNode`.

If the reference was the last, the resources associated to the @node are
freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="full">
            <doc xml:space="preserve">a `GskRenderNode`</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write_to_file" c:identifier="gsk_render_node_write_to_file" throws="1">
        <doc xml:space="preserve">This function is equivalent to calling [method@Gsk.RenderNode.serialize]
followed by [func@GLib.file_set_contents].

See those two functions for details on the arguments.

It is mostly intended for use inside a debugger to quickly dump a render
node to a file for later inspection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if saving was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode`</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the file to save it to.</doc>
            <type name="filename" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="RenderNodeType" glib:type-name="GskRenderNodeType" glib:get-type="gsk_render_node_type_get_type" c:type="GskRenderNodeType">
      <doc xml:space="preserve">The type of a node determines what the node is rendering.</doc>
      <member name="not_a_render_node" value="0" c:identifier="GSK_NOT_A_RENDER_NODE" glib:nick="not-a-render-node" glib:name="GSK_NOT_A_RENDER_NODE">
        <doc xml:space="preserve">Error type. No node will ever have this type.</doc>
      </member>
      <member name="container_node" value="1" c:identifier="GSK_CONTAINER_NODE" glib:nick="container-node" glib:name="GSK_CONTAINER_NODE">
        <doc xml:space="preserve">A node containing a stack of children</doc>
      </member>
      <member name="cairo_node" value="2" c:identifier="GSK_CAIRO_NODE" glib:nick="cairo-node" glib:name="GSK_CAIRO_NODE">
        <doc xml:space="preserve">A node drawing a `cairo_surface_t`</doc>
      </member>
      <member name="color_node" value="3" c:identifier="GSK_COLOR_NODE" glib:nick="color-node" glib:name="GSK_COLOR_NODE">
        <doc xml:space="preserve">A node drawing a single color rectangle</doc>
      </member>
      <member name="linear_gradient_node" value="4" c:identifier="GSK_LINEAR_GRADIENT_NODE" glib:nick="linear-gradient-node" glib:name="GSK_LINEAR_GRADIENT_NODE">
        <doc xml:space="preserve">A node drawing a linear gradient</doc>
      </member>
      <member name="repeating_linear_gradient_node" value="5" c:identifier="GSK_REPEATING_LINEAR_GRADIENT_NODE" glib:nick="repeating-linear-gradient-node" glib:name="GSK_REPEATING_LINEAR_GRADIENT_NODE">
        <doc xml:space="preserve">A node drawing a repeating linear gradient</doc>
      </member>
      <member name="radial_gradient_node" value="6" c:identifier="GSK_RADIAL_GRADIENT_NODE" glib:nick="radial-gradient-node" glib:name="GSK_RADIAL_GRADIENT_NODE">
        <doc xml:space="preserve">A node drawing a radial gradient</doc>
      </member>
      <member name="repeating_radial_gradient_node" value="7" c:identifier="GSK_REPEATING_RADIAL_GRADIENT_NODE" glib:nick="repeating-radial-gradient-node" glib:name="GSK_REPEATING_RADIAL_GRADIENT_NODE">
        <doc xml:space="preserve">A node drawing a repeating radial gradient</doc>
      </member>
      <member name="conic_gradient_node" value="8" c:identifier="GSK_CONIC_GRADIENT_NODE" glib:nick="conic-gradient-node" glib:name="GSK_CONIC_GRADIENT_NODE">
        <doc xml:space="preserve">A node drawing a conic gradient</doc>
      </member>
      <member name="border_node" value="9" c:identifier="GSK_BORDER_NODE" glib:nick="border-node" glib:name="GSK_BORDER_NODE">
        <doc xml:space="preserve">A node stroking a border around an area</doc>
      </member>
      <member name="texture_node" value="10" c:identifier="GSK_TEXTURE_NODE" glib:nick="texture-node" glib:name="GSK_TEXTURE_NODE">
        <doc xml:space="preserve">A node drawing a `GdkTexture`</doc>
      </member>
      <member name="inset_shadow_node" value="11" c:identifier="GSK_INSET_SHADOW_NODE" glib:nick="inset-shadow-node" glib:name="GSK_INSET_SHADOW_NODE">
        <doc xml:space="preserve">A node drawing an inset shadow</doc>
      </member>
      <member name="outset_shadow_node" value="12" c:identifier="GSK_OUTSET_SHADOW_NODE" glib:nick="outset-shadow-node" glib:name="GSK_OUTSET_SHADOW_NODE">
        <doc xml:space="preserve">A node drawing an outset shadow</doc>
      </member>
      <member name="transform_node" value="13" c:identifier="GSK_TRANSFORM_NODE" glib:nick="transform-node" glib:name="GSK_TRANSFORM_NODE">
        <doc xml:space="preserve">A node that renders its child after applying a matrix transform</doc>
      </member>
      <member name="opacity_node" value="14" c:identifier="GSK_OPACITY_NODE" glib:nick="opacity-node" glib:name="GSK_OPACITY_NODE">
        <doc xml:space="preserve">A node that changes the opacity of its child</doc>
      </member>
      <member name="color_matrix_node" value="15" c:identifier="GSK_COLOR_MATRIX_NODE" glib:nick="color-matrix-node" glib:name="GSK_COLOR_MATRIX_NODE">
        <doc xml:space="preserve">A node that applies a color matrix to every pixel</doc>
      </member>
      <member name="repeat_node" value="16" c:identifier="GSK_REPEAT_NODE" glib:nick="repeat-node" glib:name="GSK_REPEAT_NODE">
        <doc xml:space="preserve">A node that repeats the child's contents</doc>
      </member>
      <member name="clip_node" value="17" c:identifier="GSK_CLIP_NODE" glib:nick="clip-node" glib:name="GSK_CLIP_NODE">
        <doc xml:space="preserve">A node that clips its child to a rectangular area</doc>
      </member>
      <member name="rounded_clip_node" value="18" c:identifier="GSK_ROUNDED_CLIP_NODE" glib:nick="rounded-clip-node" glib:name="GSK_ROUNDED_CLIP_NODE">
        <doc xml:space="preserve">A node that clips its child to a rounded rectangle</doc>
      </member>
      <member name="shadow_node" value="19" c:identifier="GSK_SHADOW_NODE" glib:nick="shadow-node" glib:name="GSK_SHADOW_NODE">
        <doc xml:space="preserve">A node that draws a shadow below its child</doc>
      </member>
      <member name="blend_node" value="20" c:identifier="GSK_BLEND_NODE" glib:nick="blend-node" glib:name="GSK_BLEND_NODE">
        <doc xml:space="preserve">A node that blends two children together</doc>
      </member>
      <member name="cross_fade_node" value="21" c:identifier="GSK_CROSS_FADE_NODE" glib:nick="cross-fade-node" glib:name="GSK_CROSS_FADE_NODE">
        <doc xml:space="preserve">A node that cross-fades between two children</doc>
      </member>
      <member name="text_node" value="22" c:identifier="GSK_TEXT_NODE" glib:nick="text-node" glib:name="GSK_TEXT_NODE">
        <doc xml:space="preserve">A node containing a glyph string</doc>
      </member>
      <member name="blur_node" value="23" c:identifier="GSK_BLUR_NODE" glib:nick="blur-node" glib:name="GSK_BLUR_NODE">
        <doc xml:space="preserve">A node that applies a blur</doc>
      </member>
      <member name="debug_node" value="24" c:identifier="GSK_DEBUG_NODE" glib:nick="debug-node" glib:name="GSK_DEBUG_NODE">
        <doc xml:space="preserve">Debug information that does not affect the rendering</doc>
      </member>
      <member name="gl_shader_node" value="25" c:identifier="GSK_GL_SHADER_NODE" glib:nick="gl-shader-node" glib:name="GSK_GL_SHADER_NODE">
        <doc xml:space="preserve">A node that uses OpenGL fragment shaders to render</doc>
      </member>
      <member name="texture_scale_node" value="26" c:identifier="GSK_TEXTURE_SCALE_NODE" version="4.10" glib:nick="texture-scale-node" glib:name="GSK_TEXTURE_SCALE_NODE">
        <doc xml:space="preserve">A node drawing a `GdkTexture` scaled and filtered.</doc>
      </member>
      <member name="mask_node" value="27" c:identifier="GSK_MASK_NODE" version="4.10" glib:nick="mask-node" glib:name="GSK_MASK_NODE">
        <doc xml:space="preserve">A node that masks one child with another.</doc>
      </member>
      <member name="fill_node" value="28" c:identifier="GSK_FILL_NODE" version="4.14" glib:nick="fill-node" glib:name="GSK_FILL_NODE">
        <doc xml:space="preserve">A node that fills a path.</doc>
      </member>
      <member name="stroke_node" value="29" c:identifier="GSK_STROKE_NODE" version="4.14" glib:nick="stroke-node" glib:name="GSK_STROKE_NODE">
        <doc xml:space="preserve">A node that strokes a path.</doc>
      </member>
      <member name="subsurface_node" value="30" c:identifier="GSK_SUBSURFACE_NODE" version="4.14" glib:nick="subsurface-node" glib:name="GSK_SUBSURFACE_NODE">
        <doc xml:space="preserve">A node that possibly redirects part of the scene graph to a subsurface.</doc>
      </member>
    </enumeration>
    <class name="Renderer" c:symbol-prefix="renderer" c:type="GskRenderer" parent="GObject.Object" abstract="1" glib:type-name="GskRenderer" glib:get-type="gsk_renderer_get_type" glib:type-struct="RendererClass">
      <doc xml:space="preserve">`GskRenderer` is a class that renders a scene graph defined via a
tree of [class@Gsk.RenderNode] instances.

Typically you will use a `GskRenderer` instance to repeatedly call
[method@Gsk.Renderer.render] to update the contents of its associated
[class@Gdk.Surface].

It is necessary to realize a `GskRenderer` instance using
[method@Gsk.Renderer.realize] before calling [method@Gsk.Renderer.render],
in order to create the appropriate windowing system resources needed
to render the scene.</doc>
      <constructor name="new_for_surface" c:identifier="gsk_renderer_new_for_surface">
        <doc xml:space="preserve">Creates an appropriate `GskRenderer` instance for the given @surface.

If the `GSK_RENDERER` environment variable is set, GSK will
try that renderer first, before trying the backend-specific
default. The ultimate fallback is the cairo renderer.

The renderer will be realized before it is returned.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a `GskRenderer`</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
        <parameters>
          <parameter name="surface" transfer-ownership="none">
            <doc xml:space="preserve">a `GdkSurface`</doc>
            <type name="Gdk.Surface" c:type="GdkSurface*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_surface" c:identifier="gsk_renderer_get_surface" glib:get-property="surface">
        <attribute name="org.gtk.Method.get_property" value="surface"/>
        <doc xml:space="preserve">Retrieves the `GdkSurface` set using gsk_enderer_realize().

If the renderer has not been realized yet, %NULL will be returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a `GdkSurface`</doc>
          <type name="Gdk.Surface" c:type="GdkSurface*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderer`</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_realized" c:identifier="gsk_renderer_is_realized" glib:get-property="realized">
        <attribute name="org.gtk.Method.get_property" value="realized"/>
        <doc xml:space="preserve">Checks whether the @renderer is realized or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the `GskRenderer` was realized, and %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderer`</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="realize" c:identifier="gsk_renderer_realize" throws="1">
        <doc xml:space="preserve">Creates the resources needed by the @renderer to render the scene
graph.

Since GTK 4.6, the surface may be `NULL`, which allows using
renderers without having to create a surface.
Since GTK 4.14, it is recommended to use [method@Gsk.Renderer.realize_for_display]
instead.

Note that it is mandatory to call [method@Gsk.Renderer.unrealize] before
destroying the renderer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the renderer was successfully realized</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderer`</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="surface" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the `GdkSurface` renderer will be used on</doc>
            <type name="Gdk.Surface" c:type="GdkSurface*"/>
          </parameter>
        </parameters>
      </method>
      <method name="realize_for_display" c:identifier="gsk_renderer_realize_for_display" version="4.14" throws="1">
        <doc xml:space="preserve">Creates the resources needed by the @renderer to render the scene
graph.

Note that it is mandatory to call [method@Gsk.Renderer.unrealize] before
destroying the renderer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the renderer was successfully realized</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderer`</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve">the `GdkDisplay` renderer will be used on</doc>
            <type name="Gdk.Display" c:type="GdkDisplay*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render" c:identifier="gsk_renderer_render">
        <doc xml:space="preserve">Renders the scene graph, described by a tree of `GskRenderNode` instances
to the renderer's surface,  ensuring that the given @region gets redrawn.

If the renderer has no associated surface, this function does nothing.

Renderers must ensure that changes of the contents given by the @root
node as well as the area given by @region are redrawn. They are however
free to not redraw any pixel outside of @region if they can guarantee that
it didn't change.

The @renderer will acquire a reference on the `GskRenderNode` tree while
the rendering is in progress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a realized `GskRenderer`</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode`</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="region" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the `cairo_region_t` that must be redrawn or %NULL
  for the whole window</doc>
            <type name="cairo.Region" c:type="const cairo_region_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render_texture" c:identifier="gsk_renderer_render_texture">
        <doc xml:space="preserve">Renders the scene graph, described by a tree of `GskRenderNode` instances,
to a `GdkTexture`.

The @renderer will acquire a reference on the `GskRenderNode` tree while
the rendering is in progress.

If you want to apply any transformations to @root, you should put it into a
transform node and pass that node instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a `GdkTexture` with the rendered contents of @root.</doc>
          <type name="Gdk.Texture" c:type="GdkTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a realized `GskRenderer`</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode`</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="viewport" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the section to draw or %NULL to use @root's bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unrealize" c:identifier="gsk_renderer_unrealize">
        <doc xml:space="preserve">Releases all the resources created by gsk_renderer_realize().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderer`</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="realized" transfer-ownership="none" getter="is_realized" default-value="FALSE">
        <attribute name="org.gtk.Property.get" value="gsk_renderer_is_realized"/>
        <doc xml:space="preserve">Whether the renderer has been associated with a surface or draw context.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="surface" transfer-ownership="none" getter="get_surface">
        <attribute name="org.gtk.Property.get" value="gsk_renderer_get_surface"/>
        <doc xml:space="preserve">The surface associated with renderer.</doc>
        <type name="Gdk.Surface"/>
      </property>
    </class>
    <record name="RendererClass" c:type="GskRendererClass" disguised="1" opaque="1" glib:is-gtype-struct-for="Renderer"/>
    <class name="RepeatNode" c:symbol-prefix="repeat_node" c:type="GskRepeatNode" parent="RenderNode" glib:type-name="GskRepeatNode" glib:get-type="gsk_repeat_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node repeating its single child node.</doc>
      <constructor name="new" c:identifier="gsk_repeat_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will repeat the drawing of @child across
the given @bounds.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="RepeatNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">The bounds of the area to be painted</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The child to repeat</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="child_bounds" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The area of the child to repeat or %NULL to
    use the child's bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_repeat_node_get_child">
        <doc xml:space="preserve">Retrieves the child of @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a `GskRenderNode`</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a repeat `GskRenderNode`</doc>
            <type name="RepeatNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_child_bounds" c:identifier="gsk_repeat_node_get_child_bounds">
        <doc xml:space="preserve">Retrieves the bounding rectangle of the child of @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a bounding rectangle</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a repeat `GskRenderNode`</doc>
            <type name="RepeatNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="RepeatingLinearGradientNode" c:symbol-prefix="repeating_linear_gradient_node" c:type="GskRepeatingLinearGradientNode" parent="RenderNode" glib:type-name="GskRepeatingLinearGradientNode" glib:get-type="gsk_repeating_linear_gradient_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a repeating linear gradient.</doc>
      <constructor name="new" c:identifier="gsk_repeating_linear_gradient_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will create a repeating linear gradient
from the given points and color stops, and render that into the area
given by @bounds.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="RepeatingLinearGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the linear gradient into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will begin</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the point at which the linear gradient will finish</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of
`GskColorStop` defining the gradient. The offsets of all color stops
  must be increasing. The first stop's offset must be &gt;= 0 and the last
  stop's offset must be &lt;= 1.</doc>
            <array length="4" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <class name="RepeatingRadialGradientNode" c:symbol-prefix="repeating_radial_gradient_node" c:type="GskRepeatingRadialGradientNode" parent="RenderNode" glib:type-name="GskRepeatingRadialGradientNode" glib:get-type="gsk_repeating_radial_gradient_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a repeating radial gradient.</doc>
      <constructor name="new" c:identifier="gsk_repeating_radial_gradient_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that draws a repeating radial gradient.

The radial gradient starts around @center. The size of the gradient
is dictated by @hradius in horizontal orientation and by @vradius
in vertical orientation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="RepeatingRadialGradientNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the bounds of the node</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="center" transfer-ownership="none">
            <doc xml:space="preserve">the center of the gradient</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="hradius" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="vradius" transfer-ownership="none">
            <doc xml:space="preserve">the vertical radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">a percentage &gt;= 0 that defines the start of the gradient around @center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">a percentage &gt;= 0 that defines the end of the gradient around @center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="color_stops" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of
  `GskColorStop` defining the gradient. The offsets of all color stops
  must be increasing. The first stop's offset must be &gt;= 0 and the last
  stop's offset must be &lt;= 1.</doc>
            <array length="7" zero-terminated="0" c:type="const GskColorStop*">
              <type name="ColorStop" c:type="GskColorStop"/>
            </array>
          </parameter>
          <parameter name="n_color_stops" transfer-ownership="none">
            <doc xml:space="preserve">the number of elements in @color_stops</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <class name="RoundedClipNode" c:symbol-prefix="rounded_clip_node" c:type="GskRoundedClipNode" parent="RenderNode" glib:type-name="GskRoundedClipNode" glib:get-type="gsk_rounded_clip_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node applying a rounded rectangle clip to its single child.</doc>
      <constructor name="new" c:identifier="gsk_rounded_clip_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will clip the @child to the area
given by @clip.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="RoundedClipNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="clip" transfer-ownership="none">
            <doc xml:space="preserve">The clip to apply</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_rounded_clip_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting clipped by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting clipped</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a rounded clip `GskRenderNode`</doc>
            <type name="RoundedClipNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_clip" c:identifier="gsk_rounded_clip_node_get_clip">
        <doc xml:space="preserve">Retrieves the rounded rectangle used to clip the contents of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a rounded rectangle</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a rounded clip `GskRenderNode`</doc>
            <type name="RoundedClipNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="RoundedRect" c:type="GskRoundedRect">
      <doc xml:space="preserve">A rectangular region with rounded corners.

Application code should normalize rectangles using
[method@Gsk.RoundedRect.normalize]; this function will ensure that
the bounds of the rectangle are normalized and ensure that the corner
values are positive and the corners do not overlap.

All functions taking a `GskRoundedRect` as an argument will internally
operate on a normalized copy; all functions returning a `GskRoundedRect`
will always return a normalized one.

The algorithm used for normalizing corner sizes is described in
[the CSS specification](https://drafts.csswg.org/css-backgrounds-3/#border-radius).</doc>
      <field name="bounds" writable="1">
        <doc xml:space="preserve">the bounds of the rectangle</doc>
        <type name="Graphene.Rect" c:type="graphene_rect_t"/>
      </field>
      <field name="corner" writable="1">
        <doc xml:space="preserve">the size of the 4 rounded corners</doc>
        <array zero-terminated="0" fixed-size="4">
          <type name="Graphene.Size" c:type="graphene_size_t"/>
        </array>
      </field>
      <method name="contains_point" c:identifier="gsk_rounded_rect_contains_point">
        <doc xml:space="preserve">Checks if the given @point is inside the rounded rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @point is inside the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRoundedRect`</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to check</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains_rect" c:identifier="gsk_rounded_rect_contains_rect">
        <doc xml:space="preserve">Checks if the given @rect is contained inside the rounded rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @rect is fully contained inside the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRoundedRect`</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to check</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gsk_rounded_rect_init">
        <doc xml:space="preserve">Initializes the given `GskRoundedRect` with the given values.

This function will implicitly normalize the `GskRoundedRect`
before returning.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The `GskRoundedRect` to initialize</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">a `graphene_rect_t` describing the bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="top_left" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the top left corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="top_right" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the top right corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="bottom_right" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the bottom right corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="bottom_left" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the bottom left corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_copy" c:identifier="gsk_rounded_rect_init_copy">
        <doc xml:space="preserve">Initializes @self using the given @src rectangle.

This function will not normalize the `GskRoundedRect`,
so make sure the source is normalized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRoundedRect`</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRoundedRect`</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_rect" c:identifier="gsk_rounded_rect_init_from_rect">
        <doc xml:space="preserve">Initializes @self to the given @bounds and sets the radius
of all four corners to @radius.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRoundedRect`</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">a `graphene_rect_t`</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">the border radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersects_rect" c:identifier="gsk_rounded_rect_intersects_rect">
        <doc xml:space="preserve">Checks if part of the given @rect is contained inside the rounded rectangle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @rect intersects with the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRoundedRect`</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to check</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_rectilinear" c:identifier="gsk_rounded_rect_is_rectilinear">
        <doc xml:space="preserve">Checks if all corners of @self are right angles and the
rectangle covers all of its bounds.

This information can be used to decide if [ctor@Gsk.ClipNode.new]
or [ctor@Gsk.RoundedClipNode.new] should be called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the rectangle is rectilinear</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the `GskRoundedRect` to check</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="gsk_rounded_rect_normalize">
        <doc xml:space="preserve">Normalizes the passed rectangle.

This function will ensure that the bounds of the rectangle
are normalized and ensure that the corner values are positive
and the corners do not overlap.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the normalized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRoundedRect`</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="offset" c:identifier="gsk_rounded_rect_offset">
        <doc xml:space="preserve">Offsets the bound's origin by @dx and @dy.

The size and corners of the rectangle are unchanged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRoundedRect`</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve">the vertical offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="shrink" c:identifier="gsk_rounded_rect_shrink">
        <doc xml:space="preserve">Shrinks (or grows) the given rectangle by moving the 4 sides
according to the offsets given.

The corner radii will be changed in a way that tries to keep
the center of the corner circle intact. This emulates CSS behavior.

This function also works for growing rectangles if you pass
negative values for the @top, @right, @bottom or @left.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the resized `GskRoundedRect`</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The `GskRoundedRect` to shrink or grow</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the top side downwards</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the right side to the left</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the bottom side upwards</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the left side to the right</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="ScalingFilter" glib:type-name="GskScalingFilter" glib:get-type="gsk_scaling_filter_get_type" c:type="GskScalingFilter">
      <doc xml:space="preserve">The filters used when scaling texture data.

The actual implementation of each filter is deferred to the
rendering pipeline.</doc>
      <member name="linear" value="0" c:identifier="GSK_SCALING_FILTER_LINEAR" glib:nick="linear" glib:name="GSK_SCALING_FILTER_LINEAR">
        <doc xml:space="preserve">linear interpolation filter</doc>
      </member>
      <member name="nearest" value="1" c:identifier="GSK_SCALING_FILTER_NEAREST" glib:nick="nearest" glib:name="GSK_SCALING_FILTER_NEAREST">
        <doc xml:space="preserve">nearest neighbor interpolation filter</doc>
      </member>
      <member name="trilinear" value="2" c:identifier="GSK_SCALING_FILTER_TRILINEAR" glib:nick="trilinear" glib:name="GSK_SCALING_FILTER_TRILINEAR">
        <doc xml:space="preserve">linear interpolation along each axis,
  plus mipmap generation, with linear interpolation along the mipmap
  levels</doc>
      </member>
    </enumeration>
    <enumeration name="SerializationError" glib:type-name="GskSerializationError" glib:get-type="gsk_serialization_error_get_type" c:type="GskSerializationError" glib:error-domain="gsk-serialization-error-quark">
      <doc xml:space="preserve">Errors that can happen during (de)serialization.</doc>
      <member name="unsupported_format" value="0" c:identifier="GSK_SERIALIZATION_UNSUPPORTED_FORMAT" glib:nick="unsupported-format" glib:name="GSK_SERIALIZATION_UNSUPPORTED_FORMAT">
        <doc xml:space="preserve">The format can not be identified</doc>
      </member>
      <member name="unsupported_version" value="1" c:identifier="GSK_SERIALIZATION_UNSUPPORTED_VERSION" glib:nick="unsupported-version" glib:name="GSK_SERIALIZATION_UNSUPPORTED_VERSION">
        <doc xml:space="preserve">The version of the data is not
  understood</doc>
      </member>
      <member name="invalid_data" value="2" c:identifier="GSK_SERIALIZATION_INVALID_DATA" glib:nick="invalid-data" glib:name="GSK_SERIALIZATION_INVALID_DATA">
        <doc xml:space="preserve">The given data may not exist in
  a proper serialization</doc>
      </member>
      <function name="quark" c:identifier="gsk_serialization_error_quark">
        <doc xml:space="preserve">Registers an error quark for [class@Gsk.RenderNode] errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder" opaque="1" glib:type-name="GskShaderArgsBuilder" glib:get-type="gsk_shader_args_builder_get_type" c:symbol-prefix="shader_args_builder">
      <doc xml:space="preserve">An object to build the uniforms data for a `GskGLShader`.</doc>
      <constructor name="new" c:identifier="gsk_shader_args_builder_new" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Allocates a builder that can be used to construct a new uniform data
chunk.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The newly allocated builder, free with
    [method@Gsk.ShaderArgsBuilder.unref]</doc>
          <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
        </return-value>
        <parameters>
          <parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve">a `GskGLShader`</doc>
            <type name="GLShader" c:type="GskGLShader*"/>
          </parameter>
          <parameter name="initial_values" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional `GBytes` with initial values</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="free_to_args" c:identifier="gsk_shader_args_builder_free_to_args" introspectable="0" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Creates a new `GBytes` args from the current state of the
given @builder, and frees the @builder instance.

Any uniforms of the shader that have not been explicitly set
on the @builder are zero-initialized.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated buffer with
  all the args added to @builder</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a `GskShaderArgsBuilder`</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_shader_args_builder_ref" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Increases the reference count of a `GskShaderArgsBuilder` by one.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in `GskShaderArgsBuilder`</doc>
          <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a `GskShaderArgsBuilder`</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_bool" c:identifier="gsk_shader_args_builder_set_bool" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Sets the value of the uniform @idx.

The uniform must be of bool type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a `GskShaderArgsBuilder`</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform to</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_float" c:identifier="gsk_shader_args_builder_set_float">
        <doc xml:space="preserve">Sets the value of the uniform @idx.

The uniform must be of float type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a `GskShaderArgsBuilder`</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform to</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="gsk_shader_args_builder_set_int" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Sets the value of the uniform @idx.

The uniform must be of int type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a `GskShaderArgsBuilder`</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform to</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint" c:identifier="gsk_shader_args_builder_set_uint" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Sets the value of the uniform @idx.

The uniform must be of uint type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a `GskShaderArgsBuilder`</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_vec2" c:identifier="gsk_shader_args_builder_set_vec2" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Sets the value of the uniform @idx.

The uniform must be of vec2 type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">A `GskShaderArgsBuilder`</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform too</doc>
            <type name="Graphene.Vec2" c:type="const graphene_vec2_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_vec3" c:identifier="gsk_shader_args_builder_set_vec3" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Sets the value of the uniform @idx.

The uniform must be of vec3 type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a `GskShaderArgsBuilder`</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform too</doc>
            <type name="Graphene.Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_vec4" c:identifier="gsk_shader_args_builder_set_vec4" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Sets the value of the uniform @idx.

The uniform must be of vec4 type.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a `GskShaderArgsBuilder`</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value to set the uniform too</doc>
            <type name="Graphene.Vec4" c:type="const graphene_vec4_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_args" c:identifier="gsk_shader_args_builder_to_args" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Creates a new `GBytes` args from the current state of the
given @builder.

Any uniforms of the shader that have not been explicitly set on
the @builder are zero-initialized.

The given `GskShaderArgsBuilder` is reset once this function returns;
you cannot call this function multiple times on the same @builder instance.

This function is intended primarily for bindings. C code should use
[method@Gsk.ShaderArgsBuilder.free_to_args].</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly allocated buffer with
  all the args added to @builder</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a `GskShaderArgsBuilder`</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_shader_args_builder_unref" deprecated="1" deprecated-version="4.16">
        <doc xml:space="preserve">Decreases the reference count of a `GskShaderArgBuilder` by one.

If the resulting reference count is zero, frees the builder.</doc>
        <doc-deprecated xml:space="preserve">GTK's new Vulkan-focused rendering
  does not support this feature. Use [GtkGLArea](../gtk4/class.GLArea.html)
  for OpenGL rendering.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a `GskShaderArgsBuilder`</doc>
            <type name="ShaderArgsBuilder" c:type="GskShaderArgsBuilder*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Shadow" c:type="GskShadow">
      <doc xml:space="preserve">The shadow parameters in a shadow node.</doc>
      <field name="color" writable="1">
        <doc xml:space="preserve">the color of the shadow</doc>
        <type name="Gdk.RGBA" c:type="GdkRGBA"/>
      </field>
      <field name="dx" writable="1">
        <doc xml:space="preserve">the horizontal offset of the shadow</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="dy" writable="1">
        <doc xml:space="preserve">the vertical offset of the shadow</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="radius" writable="1">
        <doc xml:space="preserve">the radius of the shadow</doc>
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <class name="ShadowNode" c:symbol-prefix="shadow_node" c:type="GskShadowNode" parent="RenderNode" glib:type-name="GskShadowNode" glib:get-type="gsk_shadow_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node drawing one or more shadows behind its single child node.</doc>
      <constructor name="new" c:identifier="gsk_shadow_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will draw a @child with the given
@shadows below it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="ShadowNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="shadows" transfer-ownership="none">
            <doc xml:space="preserve">The shadows to apply</doc>
            <array length="2" zero-terminated="0" c:type="const GskShadow*">
              <type name="Shadow" c:type="GskShadow"/>
            </array>
          </parameter>
          <parameter name="n_shadows" transfer-ownership="none">
            <doc xml:space="preserve">number of entries in the @shadows array</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_shadow_node_get_child">
        <doc xml:space="preserve">Retrieves the child `GskRenderNode` of the shadow @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the child render node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a shadow `GskRenderNode`</doc>
            <type name="ShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_shadows" c:identifier="gsk_shadow_node_get_n_shadows">
        <doc xml:space="preserve">Retrieves the number of shadows in the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of shadows.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a shadow `GskRenderNode`</doc>
            <type name="ShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_shadow" c:identifier="gsk_shadow_node_get_shadow">
        <doc xml:space="preserve">Retrieves the shadow data at the given index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the shadow data</doc>
          <type name="Shadow" c:type="const GskShadow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a shadow `GskRenderNode`</doc>
            <type name="ShadowNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the given index</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="Stroke" c:type="GskStroke" opaque="1" version="4.14" glib:type-name="GskStroke" glib:get-type="gsk_stroke_get_type" c:symbol-prefix="stroke">
      <doc xml:space="preserve">A `GskStroke` struct collects the parameters that influence
the operation of stroking a path.</doc>
      <constructor name="new" c:identifier="gsk_stroke_new" version="4.14">
        <doc xml:space="preserve">Creates a new `GskStroke` with the given @line_width.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new `GskStroke`</doc>
          <type name="Stroke" c:type="GskStroke*"/>
        </return-value>
        <parameters>
          <parameter name="line_width" transfer-ownership="none">
            <doc xml:space="preserve">line width of the stroke. Must be &gt; 0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="gsk_stroke_copy" version="4.14">
        <doc xml:space="preserve">Creates a copy of the given @other stroke.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new `GskStroke`. Use [method@Gsk.Stroke.free] to free it</doc>
          <type name="Stroke" c:type="GskStroke*"/>
        </return-value>
        <parameters>
          <instance-parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">`GskStroke` to copy</doc>
            <type name="Stroke" c:type="const GskStroke*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gsk_stroke_free" version="4.14">
        <doc xml:space="preserve">Frees a `GskStroke`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="GskStroke*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dash" c:identifier="gsk_stroke_get_dash" version="4.14">
        <doc xml:space="preserve">Gets the dash array in use or `NULL` if dashing is disabled.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">
  The dash array or `NULL` if the dash array is empty.</doc>
          <array length="0" zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="const GskStroke*"/>
          </instance-parameter>
          <parameter name="n_dash" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">number of elements in the array returned</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dash_offset" c:identifier="gsk_stroke_get_dash_offset" version="4.14">
        <doc xml:space="preserve">Returns the dash_offset of a `GskStroke`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the dash_offset</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="const GskStroke*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_line_cap" c:identifier="gsk_stroke_get_line_cap" version="4.14">
        <doc xml:space="preserve">Gets the line cap used.

See [enum@Gsk.LineCap] for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The line cap</doc>
          <type name="LineCap" c:type="GskLineCap"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="const GskStroke*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_line_join" c:identifier="gsk_stroke_get_line_join" version="4.14">
        <doc xml:space="preserve">Gets the line join used.

See [enum@Gsk.LineJoin] for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The line join</doc>
          <type name="LineJoin" c:type="GskLineJoin"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="const GskStroke*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_line_width" c:identifier="gsk_stroke_get_line_width" version="4.14">
        <doc xml:space="preserve">Gets the line width used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The line width</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="const GskStroke*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_miter_limit" c:identifier="gsk_stroke_get_miter_limit" version="4.14">
        <doc xml:space="preserve">Returns the miter limit of a `GskStroke`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the miter limit</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="const GskStroke*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_dash" c:identifier="gsk_stroke_set_dash" version="4.14">
        <doc xml:space="preserve">Sets the dash pattern to use by this stroke.

A dash pattern is specified by an array of alternating non-negative
values. Each value provides the length of alternate "on" and "off"
portions of the stroke.

Each "on" segment will have caps applied as if the segment were a
separate contour. In particular, it is valid to use an "on" length
of 0 with `GSK_LINE_CAP_ROUND` or `GSK_LINE_CAP_SQUARE` to draw dots
or squares along a path.

If @n_dash is 0, if all elements in @dash are 0, or if there are
negative values in @dash, then dashing is disabled.

If @n_dash is 1, an alternating "on" and "off" pattern with the
single dash length provided is assumed.

If @n_dash is uneven, the dash array will be used with the first
element in @dash defining an "on" or "off" in alternating passes
through the array.

You can specify a starting offset into the dash with
[method@Gsk.Stroke.set_dash_offset].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="GskStroke*"/>
          </instance-parameter>
          <parameter name="dash" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">
  the array of dashes</doc>
            <array length="1" zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="n_dash" transfer-ownership="none">
            <doc xml:space="preserve">number of elements in @dash</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dash_offset" c:identifier="gsk_stroke_set_dash_offset" version="4.14">
        <doc xml:space="preserve">Sets the offset into the dash pattern where dashing should begin.

This is an offset into the length of the path, not an index into
the array values of the dash array.

See [method@Gsk.Stroke.set_dash] for more details on dashing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="GskStroke*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">offset into the dash pattern</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_line_cap" c:identifier="gsk_stroke_set_line_cap" version="4.14">
        <doc xml:space="preserve">Sets the line cap to be used when stroking.

See [enum@Gsk.LineCap] for details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a`GskStroke`</doc>
            <type name="Stroke" c:type="GskStroke*"/>
          </instance-parameter>
          <parameter name="line_cap" transfer-ownership="none">
            <doc xml:space="preserve">the `GskLineCap`</doc>
            <type name="LineCap" c:type="GskLineCap"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_line_join" c:identifier="gsk_stroke_set_line_join" version="4.14">
        <doc xml:space="preserve">Sets the line join to be used when stroking.

See [enum@Gsk.LineJoin] for details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="GskStroke*"/>
          </instance-parameter>
          <parameter name="line_join" transfer-ownership="none">
            <doc xml:space="preserve">The line join to use</doc>
            <type name="LineJoin" c:type="GskLineJoin"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_line_width" c:identifier="gsk_stroke_set_line_width" version="4.14">
        <doc xml:space="preserve">Sets the line width to be used when stroking.

The line width must be &gt; 0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="GskStroke*"/>
          </instance-parameter>
          <parameter name="line_width" transfer-ownership="none">
            <doc xml:space="preserve">width of the line in pixels</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_miter_limit" c:identifier="gsk_stroke_set_miter_limit" version="4.14">
        <doc xml:space="preserve">Sets the limit for the distance from the corner where sharp
turns of joins get cut off.

The miter limit is in units of line width and must be non-negative.

For joins of type `GSK_LINE_JOIN_MITER` that exceed the miter
limit, the join gets rendered as if it was of type
`GSK_LINE_JOIN_BEVEL`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="GskStroke*"/>
          </instance-parameter>
          <parameter name="limit" transfer-ownership="none">
            <doc xml:space="preserve">the miter limit</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_cairo" c:identifier="gsk_stroke_to_cairo" version="4.14">
        <doc xml:space="preserve">A helper function that sets the stroke parameters
of @cr from the values found in @self.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskStroke`</doc>
            <type name="Stroke" c:type="const GskStroke*"/>
          </instance-parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">the cairo context to configure</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <function name="equal" c:identifier="gsk_stroke_equal" version="4.14">
        <doc xml:space="preserve">Checks if 2 strokes are identical.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">`TRUE` if the 2 strokes are equal, `FALSE` otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="stroke1" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the first `GskStroke`</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="stroke2" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the second `GskStroke`</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="StrokeNode" c:symbol-prefix="stroke_node" c:type="GskStrokeNode" version="4.14" parent="RenderNode" glib:type-name="GskStrokeNode" glib:get-type="gsk_stroke_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node that will fill the area determined by stroking the the given
[struct@Gsk.Path] using the [struct@Gsk.Stroke] attributes.</doc>
      <constructor name="new" c:identifier="gsk_stroke_node_new" version="4.14">
        <doc xml:space="preserve">Creates a #GskRenderNode that will fill the outline generated by stroking
the given @path using the attributes defined in @stroke.

The area is filled with @child.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="StrokeNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to stroke the area with</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">The path describing the area to stroke</doc>
            <type name="Path" c:type="GskPath*"/>
          </parameter>
          <parameter name="stroke" transfer-ownership="none">
            <doc xml:space="preserve">The stroke attributes to use</doc>
            <type name="Stroke" c:type="const GskStroke*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_stroke_node_get_child" version="4.14">
        <doc xml:space="preserve">Gets the child node that is getting drawn by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting drawn</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a stroke #GskRenderNode</doc>
            <type name="StrokeNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="gsk_stroke_node_get_path" version="4.14">
        <doc xml:space="preserve">Retrieves the path that will be stroked with the contents of
the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GskPath</doc>
          <type name="Path" c:type="GskPath*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a stroke #GskRenderNode</doc>
            <type name="StrokeNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stroke" c:identifier="gsk_stroke_node_get_stroke" version="4.14">
        <doc xml:space="preserve">Retrieves the stroke attributes used in this @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GskStroke</doc>
          <type name="Stroke" c:type="const GskStroke*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a stroke #GskRenderNode</doc>
            <type name="StrokeNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="SubsurfaceNode" c:symbol-prefix="subsurface_node" c:type="GskSubsurfaceNode" version="4.14" parent="RenderNode" glib:type-name="GskSubsurfaceNode" glib:get-type="gsk_subsurface_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node that potentially diverts a part of the scene graph to a subsurface.</doc>
      <constructor name="new" c:identifier="gsk_subsurface_node_new" version="4.14" introspectable="0">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will possibly divert the child
node to a subsurface.

Note: Since subsurfaces are currently private, these nodes cannot
currently be created outside of GTK. See
[GtkGraphicsOffload](../gtk4/class.GraphicsOffload.html).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="SubsurfaceNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The child to divert to a subsurface</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="subsurface" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the subsurface to use</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_subsurface" c:identifier="gsk_subsurface_node_get_subsurface" version="4.14" introspectable="0">
        <doc xml:space="preserve">Gets the subsurface that was set on this node</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the subsurface</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a debug `GskRenderNode`</doc>
            <type name="DebugNode" c:type="const GskRenderNode*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_child" c:identifier="gsk_subsurface_node_get_child" version="4.14">
        <doc xml:space="preserve">Gets the child node that is getting drawn by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the child `GskRenderNode`</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a debug `GskRenderNode`</doc>
            <type name="SubsurfaceNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="TextNode" c:symbol-prefix="text_node" c:type="GskTextNode" parent="RenderNode" glib:type-name="GskTextNode" glib:get-type="gsk_text_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node drawing a set of glyphs.</doc>
      <constructor name="new" c:identifier="gsk_text_node_new">
        <doc xml:space="preserve">Creates a render node that renders the given glyphs.

Note that @color may not be used if the font contains
color glyphs.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new `GskRenderNode`</doc>
          <type name="TextNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="font" transfer-ownership="none">
            <doc xml:space="preserve">the `PangoFont` containing the glyphs</doc>
            <type name="Pango.Font" c:type="PangoFont*"/>
          </parameter>
          <parameter name="glyphs" transfer-ownership="none">
            <doc xml:space="preserve">the `PangoGlyphString` to render</doc>
            <type name="Pango.GlyphString" c:type="PangoGlyphString*"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">the foreground color to render with</doc>
            <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">offset of the baseline</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_color" c:identifier="gsk_text_node_get_color">
        <doc xml:space="preserve">Retrieves the color used by the text @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the text color</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text `GskRenderNode`</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_font" c:identifier="gsk_text_node_get_font">
        <doc xml:space="preserve">Returns the font used by the text @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the font</doc>
          <type name="Pango.Font" c:type="PangoFont*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">The `GskRenderNode`</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_glyphs" c:identifier="gsk_text_node_get_glyphs">
        <doc xml:space="preserve">Retrieves the glyph information in the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the glyph information</doc>
          <array length="0" zero-terminated="0" c:type="const PangoGlyphInfo*">
            <type name="Pango.GlyphInfo" c:type="PangoGlyphInfo"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text `GskRenderNode`</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
          <parameter name="n_glyphs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">the number of glyphs returned</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_num_glyphs" c:identifier="gsk_text_node_get_num_glyphs">
        <doc xml:space="preserve">Retrieves the number of glyphs in the text node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of glyphs</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text `GskRenderNode`</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset" c:identifier="gsk_text_node_get_offset">
        <doc xml:space="preserve">Retrieves the offset applied to the text.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a point with the horizontal and vertical offsets</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text `GskRenderNode`</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_color_glyphs" c:identifier="gsk_text_node_has_color_glyphs" version="4.2">
        <doc xml:space="preserve">Checks whether the text @node has color glyphs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the text node has color glyphs</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a text `GskRenderNode`</doc>
            <type name="TextNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="TextureNode" c:symbol-prefix="texture_node" c:type="GskTextureNode" parent="RenderNode" glib:type-name="GskTextureNode" glib:get-type="gsk_texture_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a `GdkTexture`.</doc>
      <constructor name="new" c:identifier="gsk_texture_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will render the given
@texture into the area given by @bounds.

Note that GSK applies linear filtering when textures are
scaled and transformed. See [class@Gsk.TextureScaleNode]
for a way to influence filtering.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="TextureNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">the `GdkTexture`</doc>
            <type name="Gdk.Texture" c:type="GdkTexture*"/>
          </parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the texture into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_texture" c:identifier="gsk_texture_node_get_texture">
        <doc xml:space="preserve">Retrieves the `GdkTexture` used when creating this `GskRenderNode`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the `GdkTexture`</doc>
          <type name="Gdk.Texture" c:type="GdkTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` of type %GSK_TEXTURE_NODE</doc>
            <type name="TextureNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="TextureScaleNode" c:symbol-prefix="texture_scale_node" c:type="GskTextureScaleNode" version="4.10" parent="RenderNode" glib:type-name="GskTextureScaleNode" glib:get-type="gsk_texture_scale_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node for a `GdkTexture`.</doc>
      <constructor name="new" c:identifier="gsk_texture_scale_node_new" version="4.10">
        <doc xml:space="preserve">Creates a node that scales the texture to the size given by the
bounds using the filter and then places it at the bounds' position.

Note that further scaling and other transformations which are
applied to the node will apply linear filtering to the resulting
texture, as usual.

This node is intended for tight control over scaling applied
to a texture, such as in image editors and requires the
application to be aware of the whole render tree as further
transforms may be applied that conflict with the desired effect
of this node.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="TextureScaleNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">the texture to scale</doc>
            <type name="Gdk.Texture" c:type="GdkTexture*"/>
          </parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the size of the texture to scale to</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">how to scale the texture</doc>
            <type name="ScalingFilter" c:type="GskScalingFilter"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_filter" c:identifier="gsk_texture_scale_node_get_filter" version="4.10">
        <doc xml:space="preserve">Retrieves the `GskScalingFilter` used when creating this `GskRenderNode`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the `GskScalingFilter`</doc>
          <type name="ScalingFilter" c:type="GskScalingFilter"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` of type %GSK_TEXTURE_SCALE_NODE</doc>
            <type name="TextureScaleNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_texture" c:identifier="gsk_texture_scale_node_get_texture" version="4.10">
        <doc xml:space="preserve">Retrieves the `GdkTexture` used when creating this `GskRenderNode`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the `GdkTexture`</doc>
          <type name="Gdk.Texture" c:type="GdkTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` of type %GSK_TEXTURE_SCALE_NODE</doc>
            <type name="TextureScaleNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="Transform" c:type="GskTransform" opaque="1" glib:type-name="GskTransform" glib:get-type="gsk_transform_get_type" c:symbol-prefix="transform">
      <doc xml:space="preserve">`GskTransform` is an object to describe transform matrices.

Unlike `graphene_matrix_t`, `GskTransform` retains the steps in how
a transform was constructed, and allows inspecting them. It is modeled
after the way CSS describes transforms.

`GskTransform` objects are immutable and cannot be changed after creation.
This means code can safely expose them as properties of objects without
having to worry about others changing them.</doc>
      <constructor name="new" c:identifier="gsk_transform_new">
        <doc xml:space="preserve">Creates a new identity transform.

This function is meant to be used by language
bindings. For C code, this is equivalent to using %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new identity transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
      </constructor>
      <method name="equal" c:identifier="gsk_transform_equal">
        <doc xml:space="preserve">Checks two transforms for equality.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the two transforms perform the same operation</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="first" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the first transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="second" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the second transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_category" c:identifier="gsk_transform_get_category">
        <doc xml:space="preserve">Returns the category this transform belongs to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The category of the transform</doc>
          <type name="TransformCategory" c:type="GskTransformCategory"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">A `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invert" c:identifier="gsk_transform_invert">
        <doc xml:space="preserve">Inverts the given transform.

If @self is not invertible, %NULL is returned.
Note that inverting %NULL also returns %NULL, which is
the correct inverse of %NULL. If you need to differentiate
between those cases, you should check @self is not %NULL
before calling this function.

This function consumes @self. Use [method@Gsk.Transform.ref] first
if you want to keep it around.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The inverted transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">Transform to invert</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="matrix" c:identifier="gsk_transform_matrix">
        <doc xml:space="preserve">Multiplies @next with the given @matrix.

This function consumes @next. Use [method@Gsk.Transform.ref] first
if you want to keep it around.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">the matrix to multiply @next with</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective" c:identifier="gsk_transform_perspective">
        <doc xml:space="preserve">Applies a perspective projection transform.

This transform scales points in X and Y based on their Z value,
scaling points with positive Z values away from the origin, and
those with negative Z values towards the origin. Points
on the z=0 plane are unchanged.

This function consumes @next. Use [method@Gsk.Transform.ref] first
if you want to keep it around.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="depth" transfer-ownership="none">
            <doc xml:space="preserve">distance of the z=0 plane. Lower values give a more
  flattened pyramid and therefore a more pronounced
  perspective effect.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="print" c:identifier="gsk_transform_print">
        <doc xml:space="preserve">Converts @self into a human-readable string representation suitable
for printing.

The result of this function can later be parsed with
[func@Gsk.Transform.parse].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">The string to print into</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_transform_ref">
        <doc xml:space="preserve">Acquires a reference on the given `GskTransform`.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the `GskTransform` with an additional reference</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="gsk_transform_rotate">
        <doc xml:space="preserve">Rotates @next @angle degrees in 2D - or in 3D-speak, around the Z axis.
The rotation happens around the origin point of (0, 0).

This function consumes @next. Use [method@Gsk.Transform.ref] first
if you want to keep it around.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation angle, in degrees (clockwise)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_3d" c:identifier="gsk_transform_rotate_3d">
        <doc xml:space="preserve">Rotates @next @angle degrees around @axis.

For a rotation in 2D space, use [method@Gsk.Transform.rotate]

This function consumes @next. Use [method@Gsk.Transform.ref] first
if you want to keep it around.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">the rotation angle, in degrees (clockwise)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="axis" transfer-ownership="none">
            <doc xml:space="preserve">The rotation axis</doc>
            <type name="Graphene.Vec3" c:type="const graphene_vec3_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="gsk_transform_scale">
        <doc xml:space="preserve">Scales @next in 2-dimensional space by the given factors.

Use [method@Gsk.Transform.scale_3d] to scale in all 3 dimensions.

This function consumes @next. Use [method@Gsk.Transform.ref] first
if you want to keep it around.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="factor_x" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the X axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="factor_y" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale_3d" c:identifier="gsk_transform_scale_3d">
        <doc xml:space="preserve">Scales @next by the given factors.

This function consumes @next. Use [method@Gsk.Transform.ref] first
if you want to keep it around.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="factor_x" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the X axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="factor_y" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="factor_z" transfer-ownership="none">
            <doc xml:space="preserve">scaling factor on the Z axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="skew" c:identifier="gsk_transform_skew" version="4.6">
        <doc xml:space="preserve">Applies a skew transform.

This function consumes @next. Use [method@Gsk.Transform.ref] first
if you want to keep it around.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="skew_x" transfer-ownership="none">
            <doc xml:space="preserve">skew factor, in degrees, on the X axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="skew_y" transfer-ownership="none">
            <doc xml:space="preserve">skew factor, in degrees, on the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_2d" c:identifier="gsk_transform_to_2d">
        <doc xml:space="preserve">Converts a `GskTransform` to a 2D transformation matrix.

@self must be a 2D transformation. If you are not
sure, use gsk_transform_get_category() &gt;=
%GSK_TRANSFORM_CATEGORY_2D to check.

The returned values have the following layout:

```
  | xx yx |   |  a  b  0 |
  | xy yy | = |  c  d  0 |
  | dx dy |   | tx ty  1 |
```

This function can be used to convert between a `GskTransform`
and a matrix type from other 2D drawing libraries, in particular
Cairo.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a 2D `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_xx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the xx member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_yx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the yx member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_xy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the xy member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_yy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the yy member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the x0 member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the y0 member</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_2d_components" c:identifier="gsk_transform_to_2d_components" version="4.6">
        <doc xml:space="preserve">Converts a `GskTransform` to 2D transformation factors.

To recreate an equivalent transform from the factors returned
by this function, use

    gsk_transform_skew (
        gsk_transform_scale (
            gsk_transform_rotate (
                gsk_transform_translate (NULL, &amp;GRAPHENE_POINT_T (dx, dy)),
                angle),
            scale_x, scale_y),
        skew_x, skew_y)

@self must be a 2D transformation. If you are not sure, use

    gsk_transform_get_category() &gt;= %GSK_TRANSFORM_CATEGORY_2D

to check.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_skew_x" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the skew factor
  in the  x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_skew_y" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the skew factor
  in the  y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_scale_x" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the scale
  factor in the x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_scale_y" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the scale
  factor in the y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_angle" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the rotation angle</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
  in the x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
  in the y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_affine" c:identifier="gsk_transform_to_affine">
        <doc xml:space="preserve">Converts a `GskTransform` to 2D affine transformation factors.

To recreate an equivalent transform from the factors returned
by this function, use

    gsk_transform_scale (gsk_transform_translate (NULL,
                                                  &amp;GRAPHENE_POINT_T (dx, dy)),
                         sx, sy)

@self must be a 2D affine transformation. If you are not
sure, use

    gsk_transform_get_category() &gt;= %GSK_TRANSFORM_CATEGORY_2D_AFFINE

to check.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_scale_x" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the scale
  factor in the x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_scale_y" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the scale
  factor in the y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
  in the x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
  in the y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_matrix" c:identifier="gsk_transform_to_matrix">
        <doc xml:space="preserve">Computes the actual value of @self and stores it in @out_matrix.

The previous value of @out_matrix will be ignored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_matrix" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">The matrix to set</doc>
            <type name="Graphene.Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gsk_transform_to_string">
        <doc xml:space="preserve">Converts a matrix into a string that is suitable for printing.

The resulting string can be parsed with [func@Gsk.Transform.parse].

This is a wrapper around [method@Gsk.Transform.print].</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new string for @self</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_translate" c:identifier="gsk_transform_to_translate">
        <doc xml:space="preserve">Converts a `GskTransform` to a translation operation.

@self must be a 2D transformation. If you are not
sure, use

    gsk_transform_get_category() &gt;= %GSK_TRANSFORM_CATEGORY_2D_TRANSLATE

to check.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="out_dx" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
  in the x direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="out_dy" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the translation
  in the y direction</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform" c:identifier="gsk_transform_transform">
        <doc xml:space="preserve">Applies all the operations from @other to @next.

This function consumes @next. Use [method@Gsk.Transform.ref] first
if you want to keep it around.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">Transform to apply @other to</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Transform to apply</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_bounds" c:identifier="gsk_transform_transform_bounds">
        <doc xml:space="preserve">Transforms a `graphene_rect_t` using the given transform @self.

The result is the bounding box containing the coplanar quad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">a `graphene_rect_t`</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="out_rect" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for the bounds
  of the transformed rectangle</doc>
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_point" c:identifier="gsk_transform_transform_point">
        <doc xml:space="preserve">Transforms a `graphene_point_t` using the given transform @self.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">a `graphene_point_t`</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
          <parameter name="out_point" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">return location for
  the transformed point</doc>
            <type name="Graphene.Point" c:type="graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="gsk_transform_translate">
        <doc xml:space="preserve">Translates @next in 2-dimensional space by @point.

This function consumes @next. Use [method@Gsk.Transform.ref] first
if you want to keep it around.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to translate the transform by</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate_3d" c:identifier="gsk_transform_translate_3d">
        <doc xml:space="preserve">Translates @next by @point.

This function consumes @next. Use [method@Gsk.Transform.ref] first
if you want to keep it around.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The new transform</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="next" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">the next transform</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to translate the transform by</doc>
            <type name="Graphene.Point3D" c:type="const graphene_point3d_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_transform_unref">
        <doc xml:space="preserve">Releases a reference on the given `GskTransform`.

If the reference was the last, the resources associated to the @self are
freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a `GskTransform`</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="parse" c:identifier="gsk_transform_parse">
        <doc xml:space="preserve">Parses the given @string into a transform and puts it in
@out_transform.

Strings printed via [method@Gsk.Transform.to_string]
can be read in again successfully using this function.

If @string does not describe a valid transform, %FALSE is
returned and %NULL is put in @out_transform.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @string described a valid transform.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">the string to parse</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out_transform" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The location to put the transform in</doc>
            <type name="Transform" c:type="GskTransform**"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="TransformCategory" glib:type-name="GskTransformCategory" glib:get-type="gsk_transform_category_get_type" c:type="GskTransformCategory">
      <doc xml:space="preserve">The categories of matrices relevant for GSK and GTK.

Note that any category includes matrices of all later categories.
So if you want to for example check if a matrix is a 2D matrix,
`category &gt;= GSK_TRANSFORM_CATEGORY_2D` is the way to do this.

Also keep in mind that rounding errors may cause matrices to not
conform to their categories. Otherwise, matrix operations done via
multiplication will not worsen categories. So for the matrix
multiplication `C = A * B`, `category(C) = MIN (category(A), category(B))`.</doc>
      <member name="unknown" value="0" c:identifier="GSK_TRANSFORM_CATEGORY_UNKNOWN" glib:nick="unknown" glib:name="GSK_TRANSFORM_CATEGORY_UNKNOWN">
        <doc xml:space="preserve">The category of the matrix has not been
  determined.</doc>
      </member>
      <member name="any" value="1" c:identifier="GSK_TRANSFORM_CATEGORY_ANY" glib:nick="any" glib:name="GSK_TRANSFORM_CATEGORY_ANY">
        <doc xml:space="preserve">Analyzing the matrix concluded that it does
  not fit in any other category.</doc>
      </member>
      <member name="3d" value="2" c:identifier="GSK_TRANSFORM_CATEGORY_3D" glib:nick="3d" glib:name="GSK_TRANSFORM_CATEGORY_3D">
        <doc xml:space="preserve">The matrix is a 3D matrix. This means that
  the w column (the last column) has the values (0, 0, 0, 1).</doc>
      </member>
      <member name="2d" value="3" c:identifier="GSK_TRANSFORM_CATEGORY_2D" glib:nick="2d" glib:name="GSK_TRANSFORM_CATEGORY_2D">
        <doc xml:space="preserve">The matrix is a 2D matrix. This is equivalent
  to graphene_matrix_is_2d() returning %TRUE. In particular, this
  means that Cairo can deal with the matrix.</doc>
      </member>
      <member name="2d_affine" value="4" c:identifier="GSK_TRANSFORM_CATEGORY_2D_AFFINE" glib:nick="2d-affine" glib:name="GSK_TRANSFORM_CATEGORY_2D_AFFINE">
        <doc xml:space="preserve">The matrix is a combination of 2D scale
  and 2D translation operations. In particular, this means that any
  rectangle can be transformed exactly using this matrix.</doc>
      </member>
      <member name="2d_translate" value="5" c:identifier="GSK_TRANSFORM_CATEGORY_2D_TRANSLATE" glib:nick="2d-translate" glib:name="GSK_TRANSFORM_CATEGORY_2D_TRANSLATE">
        <doc xml:space="preserve">The matrix is a 2D translation.</doc>
      </member>
      <member name="identity" value="6" c:identifier="GSK_TRANSFORM_CATEGORY_IDENTITY" glib:nick="identity" glib:name="GSK_TRANSFORM_CATEGORY_IDENTITY">
        <doc xml:space="preserve">The matrix is the identity matrix.</doc>
      </member>
    </enumeration>
    <class name="TransformNode" c:symbol-prefix="transform_node" c:type="GskTransformNode" parent="RenderNode" glib:type-name="GskTransformNode" glib:get-type="gsk_transform_node_get_type" glib:fundamental="1">
      <doc xml:space="preserve">A render node applying a `GskTransform` to its single child node.</doc>
      <constructor name="new" c:identifier="gsk_transform_node_new">
        <doc xml:space="preserve">Creates a `GskRenderNode` that will transform the given @child
with the given @transform.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new `GskRenderNode`</doc>
          <type name="TransformNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to transform</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="transform" transfer-ownership="none">
            <doc xml:space="preserve">The transform to apply</doc>
            <type name="Transform" c:type="GskTransform*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_child" c:identifier="gsk_transform_node_get_child">
        <doc xml:space="preserve">Gets the child node that is getting transformed by the given @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The child that is getting transformed</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a transform</doc>
            <type name="TransformNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_transform" c:identifier="gsk_transform_node_get_transform">
        <doc xml:space="preserve">Retrieves the `GskTransform` used by the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a `GskTransform`</doc>
          <type name="Transform" c:type="GskTransform*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a `GskRenderNode` for a transform</doc>
            <type name="TransformNode" c:type="const GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <function-macro name="VALUE_HOLDS_RENDER_NODE" c:identifier="GSK_VALUE_HOLDS_RENDER_NODE" introspectable="0">
      <doc xml:space="preserve">Evaluates to %TRUE if @value was initialized with %GSK_TYPE_RENDER_NODE.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a `GValue`</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VULKAN_RENDERER" c:identifier="GSK_VULKAN_RENDERER" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VULKAN_RENDERER_CLASS" c:identifier="GSK_VULKAN_RENDERER_CLASS" introspectable="0">
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VULKAN_RENDERER_GET_CLASS" c:identifier="GSK_VULKAN_RENDERER_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="VulkanRenderer" c:symbol-prefix="vulkan_renderer" c:type="GskVulkanRenderer" parent="Renderer" glib:type-name="GskVulkanRenderer" glib:get-type="gsk_vulkan_renderer_get_type" glib:type-struct="VulkanRendererClass">
      <doc xml:space="preserve">A GSK renderer that is using Vulkan.

This renderer will fail to realize if Vulkan is not supported.</doc>
      <constructor name="new" c:identifier="gsk_vulkan_renderer_new">
        <doc xml:space="preserve">Creates a new Vulkan renderer.

The Vulkan renderer is a renderer that uses the Vulkan library for
rendering.

This renderer will fail to realize when GTK was not compiled with
Vulkan support.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new Vulkan renderer</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
      </constructor>
    </class>
    <record name="VulkanRendererClass" c:type="GskVulkanRendererClass" disguised="1" opaque="1" glib:is-gtype-struct-for="VulkanRenderer"/>
    <function name="path_parse" c:identifier="gsk_path_parse" moved-to="Path.parse" version="4.14">
      <doc xml:space="preserve">This is a convenience function that constructs a `GskPath`
from a serialized form.

The string is expected to be in (a superset of)
[SVG path syntax](https://www.w3.org/TR/SVG11/paths.html#PathData),
as e.g. produced by [method@Gsk.Path.to_string].

A high-level summary of the syntax:

- `M x y` Move to `(x, y)`
- `L x y` Add a line from the current point to `(x, y)`
- `Q x1 y1 x2 y2` Add a quadratic B&#xE9;zier from the current point to `(x2, y2)`, with control point `(x1, y1)`
- `C x1 y1 x2 y2 x3 y3` Add a cubic B&#xE9;zier from the current point to `(x3, y3)`, with control points `(x1, y1)` and `(x2, y2)`
- `Z` Close the contour by drawing a line back to the start point
- `H x` Add a horizontal line from the current point to the given x value
- `V y` Add a vertical line from the current point to the given y value
- `T x2 y2` Add a quadratic B&#xE9;zier, using the reflection of the previous segments' control point as control point
- `S x2 y2 x3 y3` Add a cubic B&#xE9;zier, using the reflection of the previous segments' second control point as first control point
- `A rx ry r l s x y` Add an elliptical arc from the current point to `(x, y)` with radii rx and ry. See the SVG documentation for how the other parameters influence the arc.
- `O x1 y1 x2 y2 w` Add a rational quadratic B&#xE9;zier from the current point to `(x2, y2)` with control point `(x1, y1)` and weight `w`.

All the commands have lowercase variants that interpret coordinates
relative to the current point.

The `O` command is an extension that is not supported in SVG.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a new `GskPath`, or `NULL` if @string could not be parsed</doc>
        <type name="Path" c:type="GskPath*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="serialization_error_quark" c:identifier="gsk_serialization_error_quark" moved-to="SerializationError.quark">
      <doc xml:space="preserve">Registers an error quark for [class@Gsk.RenderNode] errors.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="stroke_equal" c:identifier="gsk_stroke_equal" moved-to="Stroke.equal" version="4.14">
      <doc xml:space="preserve">Checks if 2 strokes are identical.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">`TRUE` if the 2 strokes are equal, `FALSE` otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="stroke1" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the first `GskStroke`</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="stroke2" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the second `GskStroke`</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="transform_parse" c:identifier="gsk_transform_parse" moved-to="Transform.parse">
      <doc xml:space="preserve">Parses the given @string into a transform and puts it in
@out_transform.

Strings printed via [method@Gsk.Transform.to_string]
can be read in again successfully using this function.

If @string does not describe a valid transform, %FALSE is
returned and %NULL is put in @out_transform.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @string described a valid transform.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">the string to parse</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out_transform" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">The location to put the transform in</doc>
          <type name="Transform" c:type="GskTransform**"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_dup_render_node" c:identifier="gsk_value_dup_render_node" version="4.6">
      <doc xml:space="preserve">Retrieves the `GskRenderNode` stored inside the given `value`, and acquires
a reference to it.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a `GskRenderNode`</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a [struct@GObject.Value] initialized with type `GSK_TYPE_RENDER_NODE`</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_render_node" c:identifier="gsk_value_get_render_node" version="4.6">
      <doc xml:space="preserve">Retrieves the `GskRenderNode` stored inside the given `value`.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a `GskRenderNode`</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a `GValue` initialized with type `GSK_TYPE_RENDER_NODE`</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_render_node" c:identifier="gsk_value_set_render_node" version="4.6">
      <doc xml:space="preserve">Stores the given `GskRenderNode` inside `value`.

The [struct@GObject.Value] will acquire a reference to the `node`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a [struct@GObject.Value] initialized with type `GSK_TYPE_RENDER_NODE`</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a `GskRenderNode`</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_take_render_node" c:identifier="gsk_value_take_render_node" version="4.6">
      <doc xml:space="preserve">Stores the given `GskRenderNode` inside `value`.

This function transfers the ownership of the `node` to the `GValue`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a [struct@GObject.Value] initialized with type `GSK_TYPE_RENDER_NODE`</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="node" transfer-ownership="full" nullable="1" allow-none="1">
          <doc xml:space="preserve">a `GskRenderNode`</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
