<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="GLib" version="2.0"/>
  <package name="gobject-2.0"/>
  <c:include name="glib-object.h"/>
  <namespace name="GObject" version="2.0" shared-library="libgobject-2.0.so.0" c:identifier-prefixes="G" c:symbol-prefixes="gobject,g">
    <alias name="SignalCMarshaller" c:type="GSignalCMarshaller">
      <doc xml:space="preserve">This is the signature of marshaller functions, required to marshall
arrays of parameter values to signal emissions into C language callback
invocations.

It is merely an alias to #GClosureMarshal since the #GClosure mechanism
takes over responsibility of actual function invocation for the signal
system.</doc>
      <type name="ClosureMarshal" c:type="GClosureMarshal"/>
    </alias>
    <alias name="SignalCVaMarshaller" c:type="GSignalCVaMarshaller">
      <doc xml:space="preserve">This is the signature of va_list marshaller functions, an optional
marshaller that can be used in some situations to avoid
marshalling the signal argument into GValues.</doc>
      <type name="VaClosureMarshal" c:type="GVaClosureMarshal"/>
    </alias>
    <alias name="Type" c:type="GType">
      <doc xml:space="preserve">A numerical value which represents the unique identifier of a registered
type.</doc>
      <type name="gsize" c:type="gsize"/>
    </alias>
    <function-macro name="ADD_PRIVATE" c:identifier="G_ADD_PRIVATE" version="2.38" introspectable="0">
      <doc xml:space="preserve">A convenience macro to ease adding private data to instances of a new type
in the @_C_ section of G_DEFINE_TYPE_WITH_CODE() or
G_DEFINE_ABSTRACT_TYPE_WITH_CODE().

For instance:

|[&lt;!-- language="C" --&gt;
  typedef struct _MyObject MyObject;
  typedef struct _MyObjectClass MyObjectClass;

  typedef struct {
    gint foo;
    gint bar;
  } MyObjectPrivate;

  G_DEFINE_TYPE_WITH_CODE (MyObject, my_object, G_TYPE_OBJECT,
                           G_ADD_PRIVATE (MyObject))
]|

Will add `MyObjectPrivate` as the private data to any instance of the
`MyObject` type.

`G_DEFINE_TYPE_*` macros will automatically create a private function
based on the arguments to this macro, which can be used to safely
retrieve the private data from an instance of the type; for instance:

|[&lt;!-- language="C" --&gt;
  gint
  my_object_get_foo (MyObject *obj)
  {
    MyObjectPrivate *priv = my_object_get_instance_private (obj);

    g_return_val_if_fail (MY_IS_OBJECT (obj), 0);

    return priv-&gt;foo;
  }

  void
  my_object_set_bar (MyObject *obj,
                     gint      bar)
  {
    MyObjectPrivate *priv = my_object_get_instance_private (obj);

    g_return_if_fail (MY_IS_OBJECT (obj));

    if (priv-&gt;bar != bar)
      priv-&gt;bar = bar;
  }
]|

Since GLib 2.72, the returned `MyObjectPrivate` pointer is guaranteed to be
aligned to at least the alignment of the largest basic GLib type (typically
this is #guint64 or #gdouble). If you need larger alignment for an element in
the struct, you should allocate it on the heap (aligned), or arrange for your
`MyObjectPrivate` struct to be appropriately padded.

Note that this macro can only be used together with the `G_DEFINE_TYPE_*`
macros, since it depends on variable names from those macros.

Also note that private structs added with these macros must have a struct
name of the form `TypeNamePrivate`.

It is safe to call the `_get_instance_private` function on %NULL or invalid
objects since it's only adding an offset to the instance pointer. In that
case the returned pointer must not be dereferenced.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">the name of the type in CamelCase</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ADD_PRIVATE_DYNAMIC" c:identifier="G_ADD_PRIVATE_DYNAMIC" version="2.38" introspectable="0">
      <doc xml:space="preserve">A convenience macro to ease adding private data to instances of a new dynamic
type in the @_C_ section of G_DEFINE_DYNAMIC_TYPE_EXTENDED().

See G_ADD_PRIVATE() for details, it is similar but for static types.

Note that this macro can only be used together with the
G_DEFINE_DYNAMIC_TYPE_EXTENDED macros, since it depends on variable
names from that macro.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">the name of the type in CamelCase</doc>
        </parameter>
      </parameters>
    </function-macro>
    <glib:boxed glib:name="Array" c:symbol-prefix="array" glib:type-name="GArray" glib:get-type="g_array_get_type">
    </glib:boxed>
    <function-macro name="BINDING" c:identifier="G_BINDING" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BINDING_GROUP" c:identifier="G_BINDING_GROUP" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <callback name="BaseFinalizeFunc" c:type="GBaseFinalizeFunc">
      <doc xml:space="preserve">A callback function used by the type system to finalize those portions
of a derived types class structure that were setup from the corresponding
GBaseInitFunc() function.

Class finalization basically works the inverse way in which class
initialization is performed.

See GClassInitFunc() for a discussion of the class initialization process.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:space="preserve">The #GTypeClass structure to finalize</doc>
          <type name="TypeClass" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseInitFunc" c:type="GBaseInitFunc">
      <doc xml:space="preserve">A callback function used by the type system to do base initialization
of the class structures of derived types.

This function is called as part of the initialization process of all derived
classes and should reallocate or reset all dynamic class members copied over
from the parent class.

For example, class members (such as strings) that are not sufficiently
handled by a plain memory copy of the parent class into the derived class
have to be altered. See GClassInitFunc() for a discussion of the class
initialization process.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:space="preserve">The #GTypeClass structure to initialize</doc>
          <type name="TypeClass" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Binding" c:symbol-prefix="binding" c:type="GBinding" version="2.26" parent="Object" glib:type-name="GBinding" glib:get-type="g_binding_get_type">
      <doc xml:space="preserve">`GObject` instance (or source) and another property on another `GObject`
instance (or target).

Whenever the source property changes, the same value is applied to the
target property; for instance, the following binding:

```c
  g_object_bind_property (object1, "property-a",
                          object2, "property-b",
                          G_BINDING_DEFAULT);
```

will cause the property named "property-b" of @object2 to be updated
every time [method@GObject.set] or the specific accessor changes the value of
the property "property-a" of @object1.

It is possible to create a bidirectional binding between two properties
of two `GObject` instances, so that if either property changes, the
other is updated as well, for instance:

```c
  g_object_bind_property (object1, "property-a",
                          object2, "property-b",
                          G_BINDING_BIDIRECTIONAL);
```

will keep the two properties in sync.

It is also possible to set a custom transformation function (in both
directions, in case of a bidirectional binding) to apply a custom
transformation from the source value to the target value before
applying it; for instance, the following binding:

```c
  g_object_bind_property_full (adjustment1, "value",
                               adjustment2, "value",
                               G_BINDING_BIDIRECTIONAL,
                               celsius_to_fahrenheit,
                               fahrenheit_to_celsius,
                               NULL, NULL);
```

will keep the "value" property of the two adjustments in sync; the
@celsius_to_fahrenheit function will be called whenever the "value"
property of @adjustment1 changes and will transform the current value
of the property before applying it to the "value" property of @adjustment2.

Vice versa, the @fahrenheit_to_celsius function will be called whenever
the "value" property of @adjustment2 changes, and will transform the
current value of the property before applying it to the "value" property
of @adjustment1.

Note that #GBinding does not resolve cycles by itself; a cycle like

```
  object1:propertyA -&gt; object2:propertyB
  object2:propertyB -&gt; object3:propertyC
  object3:propertyC -&gt; object1:propertyA
```

might lead to an infinite loop. The loop, in this particular case,
can be avoided if the objects emit the `GObject::notify` signal only
if the value has effectively been changed. A binding is implemented
using the `GObject::notify` signal, so it is susceptible to all the
various ways of blocking a signal emission, like [func@GObject.signal_stop_emission]
or [func@GObject.signal_handler_block].

A binding will be severed, and the resources it allocates freed, whenever
either one of the `GObject` instances it refers to are finalized, or when
the #GBinding instance loses its last reference.

Bindings for languages with garbage collection can use
[method@GObject.Binding.unbind] to explicitly release a binding between the source
and target properties, instead of relying on the last reference on the
binding, source, and target instances to drop.</doc>
      <method name="dup_source" c:identifier="g_binding_dup_source" version="2.68">
        <doc xml:space="preserve">Retrieves the #GObject instance used as the source of the binding.

A #GBinding can outlive the source #GObject as the binding does not hold a
strong reference to the source. If the source is destroyed before the
binding then this function will return %NULL.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the source #GObject, or %NULL if the
    source does not exist any more.</doc>
          <type name="Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none">
            <doc xml:space="preserve">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_target" c:identifier="g_binding_dup_target" version="2.68">
        <doc xml:space="preserve">Retrieves the #GObject instance used as the target of the binding.

A #GBinding can outlive the target #GObject as the binding does not hold a
strong reference to the target. If the target is destroyed before the
binding then this function will return %NULL.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the target #GObject, or %NULL if the
    target does not exist any more.</doc>
          <type name="Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none">
            <doc xml:space="preserve">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_binding_get_flags" glib:get-property="flags" version="2.26">
        <doc xml:space="preserve">Retrieves the flags passed when constructing the #GBinding.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GBindingFlags used by the #GBinding</doc>
          <type name="BindingFlags" c:type="GBindingFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none">
            <doc xml:space="preserve">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source" c:identifier="g_binding_get_source" glib:get-property="source" version="2.26" deprecated="1" deprecated-version="2.68">
        <doc xml:space="preserve">Retrieves the #GObject instance used as the source of the binding.

A #GBinding can outlive the source #GObject as the binding does not hold a
strong reference to the source. If the source is destroyed before the
binding then this function will return %NULL.

Use g_binding_dup_source() if the source or binding are used from different
threads as otherwise the pointer returned from this function might become
invalid if the source is finalized from another thread in the meantime.</doc>
        <doc-deprecated xml:space="preserve">Use g_binding_dup_source() for a safer version of this
function.</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the source #GObject, or %NULL if the
    source does not exist any more.</doc>
          <type name="Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none">
            <doc xml:space="preserve">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source_property" c:identifier="g_binding_get_source_property" glib:get-property="source-property" version="2.26">
        <doc xml:space="preserve">Retrieves the name of the property of #GBinding:source used as the source
of the binding.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the source property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none">
            <doc xml:space="preserve">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_target" c:identifier="g_binding_get_target" glib:get-property="target" version="2.26" deprecated="1" deprecated-version="2.68">
        <doc xml:space="preserve">Retrieves the #GObject instance used as the target of the binding.

A #GBinding can outlive the target #GObject as the binding does not hold a
strong reference to the target. If the target is destroyed before the
binding then this function will return %NULL.

Use g_binding_dup_target() if the target or binding are used from different
threads as otherwise the pointer returned from this function might become
invalid if the target is finalized from another thread in the meantime.</doc>
        <doc-deprecated xml:space="preserve">Use g_binding_dup_target() for a safer version of this
function.</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the target #GObject, or %NULL if the
    target does not exist any more.</doc>
          <type name="Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none">
            <doc xml:space="preserve">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_target_property" c:identifier="g_binding_get_target_property" glib:get-property="target-property" version="2.26">
        <doc xml:space="preserve">Retrieves the name of the property of #GBinding:target used as the target
of the binding.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the target property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none">
            <doc xml:space="preserve">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unbind" c:identifier="g_binding_unbind" version="2.38">
        <doc xml:space="preserve">Explicitly releases the binding between the source and the target
property expressed by @binding.

This function will release the reference that is being held on
the @binding instance if the binding is still bound; if you want to hold on
to the #GBinding instance after calling g_binding_unbind(), you will need
to hold a reference to it.

Note however that this function does not take ownership of @binding, it
only unrefs the reference that was initially created by
g_object_bind_property() and is owned by the binding.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none">
            <doc xml:space="preserve">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="flags" version="2.26" writable="1" construct-only="1" transfer-ownership="none" getter="get_flags" default-value="G_BINDING_DEFAULT">
        <doc xml:space="preserve">Flags to be used to control the #GBinding</doc>
        <type name="BindingFlags"/>
      </property>
      <property name="source" version="2.26" writable="1" construct-only="1" transfer-ownership="none" getter="get_source">
        <doc xml:space="preserve">The #GObject that should be used as the source of the binding</doc>
        <type name="Object"/>
      </property>
      <property name="source-property" version="2.26" writable="1" construct-only="1" transfer-ownership="none" getter="get_source_property" default-value="NULL">
        <doc xml:space="preserve">The name of the property of #GBinding:source that should be used
as the source of the binding.

This should be in [canonical form][canonical-parameter-names] to get the
best performance.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="target" version="2.26" writable="1" construct-only="1" transfer-ownership="none" getter="get_target">
        <doc xml:space="preserve">The #GObject that should be used as the target of the binding</doc>
        <type name="Object"/>
      </property>
      <property name="target-property" version="2.26" writable="1" construct-only="1" transfer-ownership="none" getter="get_target_property" default-value="NULL">
        <doc xml:space="preserve">The name of the property of #GBinding:target that should be used
as the target of the binding.

This should be in [canonical form][canonical-parameter-names] to get the
best performance.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
    </class>
    <bitfield name="BindingFlags" version="2.26" glib:type-name="GBindingFlags" glib:get-type="g_binding_flags_get_type" c:type="GBindingFlags">
      <doc xml:space="preserve">Flags to be passed to g_object_bind_property() or
g_object_bind_property_full().

This enumeration can be extended at later date.</doc>
      <member name="default" value="0" c:identifier="G_BINDING_DEFAULT" glib:nick="default" glib:name="G_BINDING_DEFAULT">
        <doc xml:space="preserve">The default binding; if the source property
  changes, the target property is updated with its value.</doc>
      </member>
      <member name="bidirectional" value="1" c:identifier="G_BINDING_BIDIRECTIONAL" glib:nick="bidirectional" glib:name="G_BINDING_BIDIRECTIONAL">
        <doc xml:space="preserve">Bidirectional binding; if either the
  property of the source or the property of the target changes,
  the other is updated.</doc>
      </member>
      <member name="sync_create" value="2" c:identifier="G_BINDING_SYNC_CREATE" glib:nick="sync-create" glib:name="G_BINDING_SYNC_CREATE">
        <doc xml:space="preserve">Synchronize the values of the source and
  target properties when creating the binding; the direction of
  the synchronization is always from the source to the target.</doc>
      </member>
      <member name="invert_boolean" value="4" c:identifier="G_BINDING_INVERT_BOOLEAN" glib:nick="invert-boolean" glib:name="G_BINDING_INVERT_BOOLEAN">
        <doc xml:space="preserve">If the two properties being bound are
  booleans, setting one to %TRUE will result in the other being
  set to %FALSE and vice versa. This flag will only work for
  boolean properties, and cannot be used when passing custom
  transformation functions to g_object_bind_property_full().</doc>
      </member>
    </bitfield>
    <class name="BindingGroup" c:symbol-prefix="binding_group" c:type="GBindingGroup" version="2.72" parent="Object" glib:type-name="GBindingGroup" glib:get-type="g_binding_group_get_type">
      <doc xml:space="preserve">`GBindingGroup` can be used to bind multiple properties
from an object collectively.

Use the various methods to bind properties from a single source
object to multiple destination objects. Properties can be bound
bidirectionally and are connected when the source object is set
with [method@GObject.BindingGroup.set_source].</doc>
      <constructor name="new" c:identifier="g_binding_group_new" version="2.72">
        <doc xml:space="preserve">Creates a new #GBindingGroup.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GBindingGroup</doc>
          <type name="BindingGroup" c:type="GBindingGroup*"/>
        </return-value>
      </constructor>
      <method name="bind" c:identifier="g_binding_group_bind" version="2.72">
        <doc xml:space="preserve">Creates a binding between @source_property on the source object
and @target_property on @target. Whenever the @source_property
is changed the @target_property is updated using the same value.
The binding flag %G_BINDING_SYNC_CREATE is automatically specified.

See g_object_bind_property() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GBindingGroup</doc>
            <type name="BindingGroup" c:type="GBindingGroup*"/>
          </instance-parameter>
          <parameter name="source_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on the source to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the target #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the flags used to create the #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_full" c:identifier="g_binding_group_bind_full" shadowed-by="bind_with_closures" version="2.72">
        <doc xml:space="preserve">Creates a binding between @source_property on the source object and
@target_property on @target, allowing you to set the transformation
functions to be used by the binding. The binding flag
%G_BINDING_SYNC_CREATE is automatically specified.

See g_object_bind_property_full() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GBindingGroup</doc>
            <type name="BindingGroup" c:type="GBindingGroup*"/>
          </instance-parameter>
          <parameter name="source_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on the source to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the target #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the flags used to create the #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags"/>
          </parameter>
          <parameter name="transform_to" transfer-ownership="none" nullable="1" allow-none="1" scope="notified">
            <doc xml:space="preserve">the transformation function
    from the source object to the @target, or %NULL to use the default</doc>
            <type name="BindingTransformFunc" c:type="GBindingTransformFunc"/>
          </parameter>
          <parameter name="transform_from" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="6" destroy="7">
            <doc xml:space="preserve">the transformation function
    from the @target to the source object, or %NULL to use the default</doc>
            <type name="BindingTransformFunc" c:type="GBindingTransformFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">custom data to be passed to the transformation
            functions, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="user_data_destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">function to be called when disposing the binding,
    to free the resources used by the transformation functions</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_with_closures" c:identifier="g_binding_group_bind_with_closures" shadows="bind_full" version="2.72">
        <doc xml:space="preserve">Creates a binding between @source_property on the source object and
@target_property on @target, allowing you to set the transformation
functions to be used by the binding. The binding flag
%G_BINDING_SYNC_CREATE is automatically specified.

This function is the language bindings friendly version of
g_binding_group_bind_property_full(), using #GClosures
instead of function pointers.

See g_object_bind_property_with_closures() for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GBindingGroup</doc>
            <type name="BindingGroup" c:type="GBindingGroup*"/>
          </instance-parameter>
          <parameter name="source_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on the source to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the target #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the flags used to create the #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags"/>
          </parameter>
          <parameter name="transform_to" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GClosure wrapping the
    transformation function from the source object to the @target,
    or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="transform_from" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GClosure wrapping the
    transformation function from the @target to the source object,
    or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_source" c:identifier="g_binding_group_dup_source" version="2.72">
        <doc xml:space="preserve">Gets the source object used for binding properties.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GObject or %NULL.</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GBindingGroup</doc>
            <type name="BindingGroup" c:type="GBindingGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_source" c:identifier="g_binding_group_set_source" glib:set-property="source" version="2.72">
        <doc xml:space="preserve">Sets @source as the source object used for creating property
bindings. If there is already a source object all bindings from it
will be removed.

Note that all properties that have been bound must exist on @source.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GBindingGroup</doc>
            <type name="BindingGroup" c:type="GBindingGroup*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the source #GObject,
  or %NULL to clear it</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="source" version="2.72" writable="1" transfer-ownership="none" setter="set_source">
        <doc xml:space="preserve">The source object used for binding properties.</doc>
        <type name="Object"/>
      </property>
    </class>
    <callback name="BindingTransformFunc" c:type="GBindingTransformFunc" version="2.26">
      <doc xml:space="preserve">A function to be called to transform @from_value to @to_value.

If this is the @transform_to function of a binding, then @from_value
is the @source_property on the @source object, and @to_value is the
@target_property on the @target object. If this is the
@transform_from function of a %G_BINDING_BIDIRECTIONAL binding,
then those roles are reversed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the transformation was successful, and %FALSE
  otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="binding" transfer-ownership="none">
          <doc xml:space="preserve">a #GBinding</doc>
          <type name="Binding" c:type="GBinding*"/>
        </parameter>
        <parameter name="from_value" transfer-ownership="none">
          <doc xml:space="preserve">the #GValue containing the value to transform</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="to_value" transfer-ownership="none">
          <doc xml:space="preserve">the #GValue in which to store the transformed value</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">data passed to the transform function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="BookmarkFile" c:symbol-prefix="bookmark_file" glib:type-name="GBookmarkFile" glib:get-type="g_bookmark_file_get_type">
    </glib:boxed>
    <callback name="BoxedCopyFunc" c:type="GBoxedCopyFunc">
      <doc xml:space="preserve">This function is provided by the user and should produce a copy
of the passed in boxed structure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The newly created copy of the boxed structure.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="boxed" transfer-ownership="none">
          <doc xml:space="preserve">The boxed structure to be copied.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BoxedFreeFunc" c:type="GBoxedFreeFunc">
      <doc xml:space="preserve">This function is provided by the user and should free the boxed
structure passed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="boxed" transfer-ownership="none">
          <doc xml:space="preserve">The boxed structure to be freed.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="ByteArray" c:symbol-prefix="byte_array" glib:type-name="GByteArray" glib:get-type="g_byte_array_get_type">
    </glib:boxed>
    <glib:boxed glib:name="Bytes" c:symbol-prefix="bytes" glib:type-name="GBytes" glib:get-type="g_bytes_get_type">
    </glib:boxed>
    <function-macro name="CALLBACK" c:identifier="G_CALLBACK" introspectable="0">
      <doc xml:space="preserve">Cast a function pointer to a #GCallback.</doc>
      <parameters>
        <parameter name="f">
          <doc xml:space="preserve">a function pointer.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CCLOSURE_SWAP_DATA" c:identifier="G_CCLOSURE_SWAP_DATA" introspectable="0">
      <doc xml:space="preserve">Checks whether the user data of the #GCClosure should be passed as the
first parameter to the callback. See g_cclosure_new_swap().</doc>
      <parameters>
        <parameter name="cclosure">
          <doc xml:space="preserve">a #GCClosure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="CClosure" c:type="GCClosure">
      <doc xml:space="preserve">A #GCClosure is a specialization of #GClosure for C function callbacks.</doc>
      <field name="closure" writable="1">
        <doc xml:space="preserve">the #GClosure</doc>
        <type name="Closure" c:type="GClosure"/>
      </field>
      <field name="callback" writable="1">
        <doc xml:space="preserve">the callback function</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <function name="marshal_BOOLEAN__BOXED_BOXED" c:identifier="g_cclosure_marshal_BOOLEAN__BOXED_BOXED">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with handlers that
take two boxed pointers as arguments and return a boolean.  If you
have such a signal, you will probably also need to use an
accumulator, such as g_signal_accumulator_true_handled().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_BOOLEAN__BOXED_BOXEDv" c:identifier="g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__BOXED_BOXED().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_BOOLEAN__FLAGS" c:identifier="g_cclosure_marshal_BOOLEAN__FLAGS">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with handlers that
take a flags type as an argument and return a boolean.  If you have
such a signal, you will probably also need to use an accumulator,
such as g_signal_accumulator_true_handled().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_BOOLEAN__FLAGSv" c:identifier="g_cclosure_marshal_BOOLEAN__FLAGSv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__FLAGS().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_STRING__OBJECT_POINTER" c:identifier="g_cclosure_marshal_STRING__OBJECT_POINTER">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with handlers that
take a #GObject and a pointer and produce a string.  It is highly
unlikely that your signal handler fits this description.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_STRING__OBJECT_POINTERv" c:identifier="g_cclosure_marshal_STRING__OBJECT_POINTERv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_STRING__OBJECT_POINTER().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__BOOLEAN" c:identifier="g_cclosure_marshal_VOID__BOOLEAN">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
boolean argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__BOOLEANv" c:identifier="g_cclosure_marshal_VOID__BOOLEANv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOOLEAN().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__BOXED" c:identifier="g_cclosure_marshal_VOID__BOXED">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
argument which is any boxed pointer type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__BOXEDv" c:identifier="g_cclosure_marshal_VOID__BOXEDv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOXED().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__CHAR" c:identifier="g_cclosure_marshal_VOID__CHAR">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
character argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__CHARv" c:identifier="g_cclosure_marshal_VOID__CHARv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__CHAR().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__DOUBLE" c:identifier="g_cclosure_marshal_VOID__DOUBLE">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with one
double-precision floating point argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__DOUBLEv" c:identifier="g_cclosure_marshal_VOID__DOUBLEv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__DOUBLE().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__ENUM" c:identifier="g_cclosure_marshal_VOID__ENUM">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
argument with an enumerated type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__ENUMv" c:identifier="g_cclosure_marshal_VOID__ENUMv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ENUM().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__FLAGS" c:identifier="g_cclosure_marshal_VOID__FLAGS">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
argument with a flags types.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__FLAGSv" c:identifier="g_cclosure_marshal_VOID__FLAGSv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLAGS().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__FLOAT" c:identifier="g_cclosure_marshal_VOID__FLOAT">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with one
single-precision floating point argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__FLOATv" c:identifier="g_cclosure_marshal_VOID__FLOATv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLOAT().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__INT" c:identifier="g_cclosure_marshal_VOID__INT">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
integer argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__INTv" c:identifier="g_cclosure_marshal_VOID__INTv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__INT().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__LONG" c:identifier="g_cclosure_marshal_VOID__LONG">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with with a single
long integer argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__LONGv" c:identifier="g_cclosure_marshal_VOID__LONGv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__LONG().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__OBJECT" c:identifier="g_cclosure_marshal_VOID__OBJECT">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
#GObject argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__OBJECTv" c:identifier="g_cclosure_marshal_VOID__OBJECTv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__OBJECT().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__PARAM" c:identifier="g_cclosure_marshal_VOID__PARAM">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
argument of type #GParamSpec.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__PARAMv" c:identifier="g_cclosure_marshal_VOID__PARAMv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__PARAM().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__POINTER" c:identifier="g_cclosure_marshal_VOID__POINTER">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single raw
pointer argument type.

If it is possible, it is better to use one of the more specific
functions such as g_cclosure_marshal_VOID__OBJECT() or
g_cclosure_marshal_VOID__OBJECT().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__POINTERv" c:identifier="g_cclosure_marshal_VOID__POINTERv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__POINTER().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__STRING" c:identifier="g_cclosure_marshal_VOID__STRING">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single string
argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__STRINGv" c:identifier="g_cclosure_marshal_VOID__STRINGv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__STRING().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__UCHAR" c:identifier="g_cclosure_marshal_VOID__UCHAR">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
unsigned character argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__UCHARv" c:identifier="g_cclosure_marshal_VOID__UCHARv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UCHAR().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__UINT" c:identifier="g_cclosure_marshal_VOID__UINT">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with with a single
unsigned integer argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__UINT_POINTER" c:identifier="g_cclosure_marshal_VOID__UINT_POINTER">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with an unsigned int
and a pointer as arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__UINT_POINTERv" c:identifier="g_cclosure_marshal_VOID__UINT_POINTERv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT_POINTER().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__UINTv" c:identifier="g_cclosure_marshal_VOID__UINTv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__ULONG" c:identifier="g_cclosure_marshal_VOID__ULONG">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
unsigned long integer argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__ULONGv" c:identifier="g_cclosure_marshal_VOID__ULONGv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ULONG().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__VARIANT" c:identifier="g_cclosure_marshal_VOID__VARIANT">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
#GVariant argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__VARIANTv" c:identifier="g_cclosure_marshal_VOID__VARIANTv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VARIANT().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__VOID" c:identifier="g_cclosure_marshal_VOID__VOID">
        <doc xml:space="preserve">A #GClosureMarshal function for use with signals with no arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_VOID__VOIDv" c:identifier="g_cclosure_marshal_VOID__VOIDv" introspectable="0">
        <doc xml:space="preserve">The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VOID().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_generic" c:identifier="g_cclosure_marshal_generic" version="2.30">
        <doc xml:space="preserve">A generic marshaller function implemented via
[libffi](http://sourceware.org/libffi/).

Normally this function is not passed explicitly to g_signal_new(),
but used automatically by GLib when specifying a %NULL marshaller.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">A #GClosure.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_gvalue" transfer-ownership="none">
            <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">The length of the @param_values array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="marshal_generic_va" c:identifier="g_cclosure_marshal_generic_va" version="2.30" introspectable="0">
        <doc xml:space="preserve">A generic #GVaClosureMarshal function implemented via
[libffi](http://sourceware.org/libffi/).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance on which the closure is
 invoked.</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
          <parameter name="args_list" transfer-ownership="none">
            <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_params" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_types array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="param_types" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of each argument from
 @args_list.</doc>
            <array length="5" zero-terminated="0" c:type="GType*">
              <type name="GType" c:type="GType"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="g_cclosure_new" introspectable="0">
        <doc xml:space="preserve">Creates a new closure which invokes @callback_func with @user_data as
the last parameter.

@destroy_data will be called as a finalize notifier on the #GClosure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new #GCClosure</doc>
          <type name="Closure" c:type="GClosure*"/>
        </return-value>
        <parameters>
          <parameter name="callback_func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">the function to invoke</doc>
            <type name="Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @callback_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_data" transfer-ownership="none">
            <doc xml:space="preserve">destroy notify to be called when @user_data is no longer used</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_object" c:identifier="g_cclosure_new_object" introspectable="0">
        <doc xml:space="preserve">A variant of g_cclosure_new() which uses @object as @user_data and
calls g_object_watch_closure() on @object and the created
closure. This function is useful when you have a callback closely
associated with a #GObject, and want the callback to no longer run
after the object is is freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #GCClosure</doc>
          <type name="Closure" c:type="GClosure*"/>
        </return-value>
        <parameters>
          <parameter name="callback_func" transfer-ownership="none">
            <doc xml:space="preserve">the function to invoke</doc>
            <type name="Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject pointer to pass to @callback_func</doc>
            <type name="Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_object_swap" c:identifier="g_cclosure_new_object_swap" introspectable="0">
        <doc xml:space="preserve">A variant of g_cclosure_new_swap() which uses @object as @user_data
and calls g_object_watch_closure() on @object and the created
closure. This function is useful when you have a callback closely
associated with a #GObject, and want the callback to no longer run
after the object is is freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #GCClosure</doc>
          <type name="Closure" c:type="GClosure*"/>
        </return-value>
        <parameters>
          <parameter name="callback_func" transfer-ownership="none">
            <doc xml:space="preserve">the function to invoke</doc>
            <type name="Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject pointer to pass to @callback_func</doc>
            <type name="Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_swap" c:identifier="g_cclosure_new_swap" introspectable="0">
        <doc xml:space="preserve">Creates a new closure which invokes @callback_func with @user_data as
the first parameter.

@destroy_data will be called as a finalize notifier on the #GClosure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new #GCClosure</doc>
          <type name="Closure" c:type="GClosure*"/>
        </return-value>
        <parameters>
          <parameter name="callback_func" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">the function to invoke</doc>
            <type name="Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">user data to pass to @callback_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_data" transfer-ownership="none">
            <doc xml:space="preserve">destroy notify to be called when @user_data is no longer used</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <function-macro name="CLOSURE_NEEDS_MARSHAL" c:identifier="G_CLOSURE_NEEDS_MARSHAL" introspectable="0">
      <doc xml:space="preserve">Check if the closure still needs a marshaller. See g_closure_set_marshal().</doc>
      <parameters>
        <parameter name="closure">
          <doc xml:space="preserve">a #GClosure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CLOSURE_N_NOTIFIERS" c:identifier="G_CLOSURE_N_NOTIFIERS" introspectable="0">
      <doc xml:space="preserve">Get the total number of notifiers connected with the closure @cl.

The count includes the meta marshaller, the finalize and invalidate notifiers
and the marshal guards. Note that each guard counts as two notifiers.
See g_closure_set_meta_marshal(), g_closure_add_finalize_notifier(),
g_closure_add_invalidate_notifier() and g_closure_add_marshal_guards().</doc>
      <parameters>
        <parameter name="cl">
          <doc xml:space="preserve">a #GClosure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <callback name="Callback" c:type="GCallback">
      <doc xml:space="preserve">The type used for callback functions in structure definitions and function
signatures.

This doesn't mean that all callback functions must take no  parameters and
return void. The required signature of a callback function is determined by
the context in which is used (e.g. the signal to which it is connected).

Use G_CALLBACK() to cast the callback function to a #GCallback.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </callback>
    <glib:boxed glib:name="Checksum" c:symbol-prefix="checksum" glib:type-name="GChecksum" glib:get-type="g_checksum_get_type">
    </glib:boxed>
    <callback name="ClassFinalizeFunc" c:type="GClassFinalizeFunc">
      <doc xml:space="preserve">A callback function used by the type system to finalize a class.

This function is rarely needed, as dynamically allocated class resources
should be handled by GBaseInitFunc() and GBaseFinalizeFunc().

Also, specification of a GClassFinalizeFunc() in the #GTypeInfo
structure of a static type is invalid, because classes of static types
will never be finalized (they are artificially kept alive when their
reference count drops to zero).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:space="preserve">The #GTypeClass structure to finalize</doc>
          <type name="TypeClass" c:type="gpointer"/>
        </parameter>
        <parameter name="class_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The @class_data member supplied via the #GTypeInfo structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ClassInitFunc" c:type="GClassInitFunc">
      <doc xml:space="preserve">A callback function used by the type system to initialize the class
of a specific type.

This function should initialize all static class members.

The initialization process of a class involves:

- Copying common members from the parent class over to the
  derived class structure.
- Zero initialization of the remaining members not copied
  over from the parent class.
- Invocation of the GBaseInitFunc() initializers of all parent
  types and the class' type.
- Invocation of the class' GClassInitFunc() initializer.

Since derived classes are partially initialized through a memory copy
of the parent class, the general rule is that GBaseInitFunc() and
GBaseFinalizeFunc() should take care of necessary reinitialization
and release of those class members that were introduced by the type
that specified these GBaseInitFunc()/GBaseFinalizeFunc().
GClassInitFunc() should only care about initializing static
class members, while dynamic class members (such as allocated strings
or reference counted resources) are better handled by a GBaseInitFunc()
for this type, so proper initialization of the dynamic class members
is performed for class initialization of derived types as well.

An example may help to correspond the intend of the different class
initializers:

|[&lt;!-- language="C" --&gt;
typedef struct {
  GObjectClass parent_class;
  gint         static_integer;
  gchar       *dynamic_string;
} TypeAClass;
static void
type_a_base_class_init (TypeAClass *class)
{
  class-&gt;dynamic_string = g_strdup ("some string");
}
static void
type_a_base_class_finalize (TypeAClass *class)
{
  g_free (class-&gt;dynamic_string);
}
static void
type_a_class_init (TypeAClass *class)
{
  class-&gt;static_integer = 42;
}

typedef struct {
  TypeAClass   parent_class;
  gfloat       static_float;
  GString     *dynamic_gstring;
} TypeBClass;
static void
type_b_base_class_init (TypeBClass *class)
{
  class-&gt;dynamic_gstring = g_string_new ("some other string");
}
static void
type_b_base_class_finalize (TypeBClass *class)
{
  g_string_free (class-&gt;dynamic_gstring);
}
static void
type_b_class_init (TypeBClass *class)
{
  class-&gt;static_float = 3.14159265358979323846;
}
]|

Initialization of TypeBClass will first cause initialization of
TypeAClass (derived classes reference their parent classes, see
g_type_class_ref() on this).

Initialization of TypeAClass roughly involves zero-initializing its fields,
then calling its GBaseInitFunc() type_a_base_class_init() to allocate
its dynamic members (dynamic_string), and finally calling its GClassInitFunc()
type_a_class_init() to initialize its static members (static_integer).
The first step in the initialization process of TypeBClass is then
a plain memory copy of the contents of TypeAClass into TypeBClass and
zero-initialization of the remaining fields in TypeBClass.
The dynamic members of TypeAClass within TypeBClass now need
reinitialization which is performed by calling type_a_base_class_init()
with an argument of TypeBClass.

After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()
is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),
is called to complete the initialization process with the static members
(static_float).

Corresponding finalization counter parts to the GBaseInitFunc() functions
have to be provided to release allocated resources at class finalization
time.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:space="preserve">The #GTypeClass structure to initialize.</doc>
          <type name="TypeClass" c:type="gpointer"/>
        </parameter>
        <parameter name="class_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The @class_data member supplied via the #GTypeInfo structure.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Closure" c:type="GClosure" glib:type-name="GClosure" glib:get-type="g_closure_get_type" c:symbol-prefix="closure">
      <doc xml:space="preserve">A `GClosure` represents a callback supplied by the programmer.

It will generally comprise a function of some kind and a marshaller
used to call it. It is the responsibility of the marshaller to
convert the arguments for the invocation from #GValues into
a suitable form, perform the callback on the converted arguments,
and transform the return value back into a #GValue.

In the case of C programs, a closure usually just holds a pointer
to a function and maybe a data argument, and the marshaller
converts between #GValue and native C types. The GObject
library provides the #GCClosure type for this purpose. Bindings for
other languages need marshallers which convert between #GValues
and suitable representations in the runtime of the language in
order to use functions written in that language as callbacks. Use
g_closure_set_marshal() to set the marshaller on such a custom
closure implementation.

Within GObject, closures play an important role in the
implementation of signals. When a signal is registered, the
@c_marshaller argument to g_signal_new() specifies the default C
marshaller for any closure which is connected to this
signal. GObject provides a number of C marshallers for this
purpose, see the g_cclosure_marshal_*() functions. Additional C
marshallers can be generated with the [glib-genmarshal][glib-genmarshal]
utility.  Closures can be explicitly connected to signals with
g_signal_connect_closure(), but it usually more convenient to let
GObject create a closure automatically by using one of the
g_signal_connect_*() functions which take a callback function/user
data pair.

Using closures has a number of important advantages over a simple
callback function/data pointer combination:

- Closures allow the callee to get the types of the callback parameters,
  which means that language bindings don't have to write individual glue
  for each callback type.

- The reference counting of #GClosure makes it easy to handle reentrancy
  right; if a callback is removed while it is being invoked, the closure
  and its parameters won't be freed until the invocation finishes.

- g_closure_invalidate() and invalidation notifiers allow callbacks to be
  automatically removed when the objects they point to go away.</doc>
      <field name="ref_count" readable="0" bits="15" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="meta_marshal_nouse" readable="0" bits="1" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="n_guards" readable="0" bits="1" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="n_fnotifiers" readable="0" bits="2" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="n_inotifiers" readable="0" bits="8" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="in_inotify" readable="0" bits="1" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="floating" readable="0" bits="1" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="derivative_flag" readable="0" bits="1" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="in_marshal" writable="1" bits="1">
        <doc xml:space="preserve">Indicates whether the closure is currently being invoked with
  g_closure_invoke()</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="is_invalid" writable="1" bits="1">
        <doc xml:space="preserve">Indicates whether the closure has been invalidated by
  g_closure_invalidate()</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="marshal">
        <callback name="marshal">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="closure" transfer-ownership="none">
              <type name="Closure" c:type="GClosure*"/>
            </parameter>
            <parameter name="return_value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="n_param_values" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="param_values" transfer-ownership="none">
              <type name="Value" c:type="const GValue*"/>
            </parameter>
            <parameter name="invocation_hint" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="marshal_data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="notifiers" readable="0" private="1">
        <type name="ClosureNotifyData" c:type="GClosureNotifyData*"/>
      </field>
      <constructor name="new_object" c:identifier="g_closure_new_object">
        <doc xml:space="preserve">A variant of g_closure_new_simple() which stores @object in the
@data field of the closure and calls g_object_watch_closure() on
@object and the created closure. This function is mainly useful
when implementing new types of closures.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a newly allocated #GClosure</doc>
          <type name="Closure" c:type="GClosure*"/>
        </return-value>
        <parameters>
          <parameter name="sizeof_closure" transfer-ownership="none">
            <doc xml:space="preserve">the size of the structure to allocate, must be at least
 `sizeof (GClosure)`</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject pointer to store in the @data field of the newly
 allocated #GClosure</doc>
            <type name="Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_simple" c:identifier="g_closure_new_simple">
        <doc xml:space="preserve">Allocates a struct of the given size and initializes the initial
part as a #GClosure.

This function is mainly useful when implementing new types of closures:

|[&lt;!-- language="C" --&gt;
typedef struct _MyClosure MyClosure;
struct _MyClosure
{
  GClosure closure;
  // extra data goes here
};

static void
my_closure_finalize (gpointer  notify_data,
                     GClosure *closure)
{
  MyClosure *my_closure = (MyClosure *)closure;

  // free extra data here
}

MyClosure *my_closure_new (gpointer data)
{
  GClosure *closure;
  MyClosure *my_closure;

  closure = g_closure_new_simple (sizeof (MyClosure), data);
  my_closure = (MyClosure *) closure;

  // initialize extra data here

  g_closure_add_finalize_notifier (closure, notify_data,
                                   my_closure_finalize);
  return my_closure;
}
]|</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a floating reference to a new #GClosure</doc>
          <type name="Closure" c:type="GClosure*"/>
        </return-value>
        <parameters>
          <parameter name="sizeof_closure" transfer-ownership="none">
            <doc xml:space="preserve">the size of the structure to allocate, must be at least
                 `sizeof (GClosure)`</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to store in the @data field of the newly allocated #GClosure</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_finalize_notifier" c:identifier="g_closure_add_finalize_notifier" introspectable="0">
        <doc xml:space="preserve">Registers a finalization notifier which will be called when the
reference count of @closure goes down to 0.

Multiple finalization notifiers on a single closure are invoked in
unspecified order. If a single call to g_closure_unref() results in
the closure being both invalidated and finalized, then the invalidate
notifiers will be run before the finalize notifiers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @notify_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify_func" transfer-ownership="none">
            <doc xml:space="preserve">the callback function to register</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_invalidate_notifier" c:identifier="g_closure_add_invalidate_notifier" introspectable="0">
        <doc xml:space="preserve">Registers an invalidation notifier which will be called when the
@closure is invalidated with g_closure_invalidate().

Invalidation notifiers are invoked before finalization notifiers,
in an unspecified order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @notify_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify_func" transfer-ownership="none">
            <doc xml:space="preserve">the callback function to register</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_marshal_guards" c:identifier="g_closure_add_marshal_guards" introspectable="0">
        <doc xml:space="preserve">Adds a pair of notifiers which get invoked before and after the
closure callback, respectively.

This is typically used to protect the extra arguments for the
duration of the callback. See g_object_watch_closure() for an
example of marshal guards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
          <parameter name="pre_marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass
 to @pre_marshal_notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="pre_marshal_notify" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">a function to call before the closure callback</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
          <parameter name="post_marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass
 to @post_marshal_notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="post_marshal_notify" transfer-ownership="none">
            <doc xml:space="preserve">a function to call after the closure callback</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="invalidate" c:identifier="g_closure_invalidate">
        <doc xml:space="preserve">Sets a flag on the closure to indicate that its calling
environment has become invalid, and thus causes any future
invocations of g_closure_invoke() on this @closure to be
ignored.

Also, invalidation notifiers installed on the closure will
be called at this point. Note that unless you are holding a
reference to the closure yourself, the invalidation notifiers may
unref the closure and cause it to be destroyed, so if you need to
access the closure after calling g_closure_invalidate(), make sure
that you've previously called g_closure_ref().

Note that g_closure_invalidate() will also be called when the
reference count of a closure drops to zero (unless it has already
been invalidated before).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">#GClosure to invalidate</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invoke" c:identifier="g_closure_invoke">
        <doc xml:space="preserve">Invokes the closure, i.e. executes the callback represented by the @closure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
          <parameter name="return_value" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1">
            <doc xml:space="preserve">a #GValue to store the return
               value. May be %NULL if the callback of @closure
               doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @param_values array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:space="preserve">an array of
               #GValues holding the arguments on which to
               invoke the callback of @closure</doc>
            <array length="1" zero-terminated="0" c:type="const GValue*">
              <type name="Value" c:type="GValue"/>
            </array>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a context-dependent invocation hint</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_closure_ref">
        <doc xml:space="preserve">Increments the reference count on a closure to force it staying
alive while the caller holds a pointer to it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The @closure passed in, for convenience</doc>
          <type name="Closure" c:type="GClosure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">#GClosure to increment the reference count on</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_finalize_notifier" c:identifier="g_closure_remove_finalize_notifier" introspectable="0">
        <doc xml:space="preserve">Removes a finalization notifier.

Notice that notifiers are automatically removed after they are run.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data which was passed to g_closure_add_finalize_notifier()
 when registering @notify_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify_func" transfer-ownership="none">
            <doc xml:space="preserve">the callback function to remove</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_invalidate_notifier" c:identifier="g_closure_remove_invalidate_notifier" introspectable="0">
        <doc xml:space="preserve">Removes an invalidation notifier.

Notice that notifiers are automatically removed after they are run.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data which was passed to g_closure_add_invalidate_notifier()
              when registering @notify_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify_func" transfer-ownership="none">
            <doc xml:space="preserve">the callback function to remove</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_marshal" c:identifier="g_closure_set_marshal" introspectable="0">
        <doc xml:space="preserve">Sets the marshaller of @closure.

The `marshal_data` of @marshal provides a way for a meta marshaller to
provide additional information to the marshaller.

For GObject's C predefined marshallers (the `g_cclosure_marshal_*()`
functions), what it provides is a callback function to use instead of
@closure-&gt;callback.

See also: g_closure_set_meta_marshal()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
          <parameter name="marshal" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosureMarshal function</doc>
            <type name="ClosureMarshal" c:type="GClosureMarshal"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_meta_marshal" c:identifier="g_closure_set_meta_marshal" introspectable="0">
        <doc xml:space="preserve">Sets the meta marshaller of @closure.

A meta marshaller wraps the @closure's marshal and modifies the way
it is called in some fashion. The most common use of this facility
is for C callbacks.

The same marshallers (generated by [glib-genmarshal][glib-genmarshal]),
are used everywhere, but the way that we get the callback function
differs. In most cases we want to use the @closure's callback, but in
other cases we want to use some different technique to retrieve the
callback function.

For example, class closures for signals (see
g_signal_type_cclosure_new()) retrieve the callback function from a
fixed offset in the class structure.  The meta marshaller retrieves
the right callback and passes it to the marshaller as the
@marshal_data argument.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">context-dependent data to pass
 to @meta_marshal</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="meta_marshal" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosureMarshal function</doc>
            <type name="ClosureMarshal" c:type="GClosureMarshal"/>
          </parameter>
        </parameters>
      </method>
      <method name="sink" c:identifier="g_closure_sink">
        <doc xml:space="preserve">Takes over the initial ownership of a closure.

Each closure is initially created in a "floating" state, which means
that the initial reference count is not owned by any caller.

This function checks to see if the object is still floating, and if so,
unsets the floating state and decreases the reference count. If the
closure is not floating, g_closure_sink() does nothing.

The reason for the existence of the floating state is to prevent
cumbersome code sequences like:

|[&lt;!-- language="C" --&gt;
closure = g_cclosure_new (cb_func, cb_data);
g_source_set_closure (source, closure);
g_closure_unref (closure); // GObject doesn't really need this
]|

Because g_source_set_closure() (and similar functions) take ownership of the
initial reference count, if it is unowned, we instead can write:

|[&lt;!-- language="C" --&gt;
g_source_set_closure (source, g_cclosure_new (cb_func, cb_data));
]|

Generally, this function is used together with g_closure_ref(). An example
of storing a closure for later notification looks like:

|[&lt;!-- language="C" --&gt;
static GClosure *notify_closure = NULL;
void
foo_notify_set_closure (GClosure *closure)
{
  if (notify_closure)
    g_closure_unref (notify_closure);
  notify_closure = closure;
  if (notify_closure)
    {
      g_closure_ref (notify_closure);
      g_closure_sink (notify_closure);
    }
}
]|

Because g_closure_sink() may decrement the reference count of a closure
(if it hasn't been called on @closure yet) just like g_closure_unref(),
g_closure_ref() should be called prior to this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">#GClosure to decrement the initial reference count on, if it's
          still being held</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_closure_unref">
        <doc xml:space="preserve">Decrements the reference count of a closure after it was previously
incremented by the same caller.

If no other callers are using the closure, then the closure will be
destroyed and freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">#GClosure to decrement the reference count on</doc>
            <type name="Closure" c:type="GClosure*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="ClosureMarshal" c:type="GClosureMarshal">
      <doc xml:space="preserve">The type used for marshaller functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">the length of the @param_values array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">an array of
 #GValues holding the arguments on which to invoke the
 callback of @closure</doc>
          <array length="2" zero-terminated="0" c:type="const GValue*">
            <type name="Value" c:type="GValue"/>
          </array>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the invocation hint given as the
 last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ClosureNotify" c:type="GClosureNotify">
      <doc xml:space="preserve">The type used for the various notification callbacks which can be registered
on closures.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data specified when registering the notification callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">the #GClosure on which the notification is emitted</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ClosureNotifyData" c:type="GClosureNotifyData">
      <field name="data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="notify" writable="1">
        <type name="ClosureNotify" c:type="GClosureNotify"/>
      </field>
    </record>
    <bitfield name="ConnectFlags" c:type="GConnectFlags">
      <doc xml:space="preserve">The connection flags are used to specify the behaviour of a signal's
connection.</doc>
      <member name="default" value="0" c:identifier="G_CONNECT_DEFAULT">
        <doc xml:space="preserve">Default behaviour (no special flags). Since: 2.74</doc>
      </member>
      <member name="after" value="1" c:identifier="G_CONNECT_AFTER">
        <doc xml:space="preserve">If set, the handler should be called after the
 default handler of the signal. Normally, the handler is called before
 the default handler.</doc>
      </member>
      <member name="swapped" value="2" c:identifier="G_CONNECT_SWAPPED">
        <doc xml:space="preserve">If set, the instance and data should be swapped when
 calling the handler; see g_signal_connect_swapped() for an example.</doc>
      </member>
    </bitfield>
    <function-macro name="DECLARE_DERIVABLE_TYPE" c:identifier="G_DECLARE_DERIVABLE_TYPE" version="2.44" introspectable="0">
      <doc xml:space="preserve">A convenience macro for emitting the usual declarations in the
header file for a type which is intended to be subclassed.

You might use it in a header as follows:

|[&lt;!-- language="C" --&gt;
#ifndef _gtk_frobber_h_
#define _gtk_frobber_h_

#define GTK_TYPE_FROBBER gtk_frobber_get_type ()
GDK_AVAILABLE_IN_3_12
G_DECLARE_DERIVABLE_TYPE (GtkFrobber, gtk_frobber, GTK, FROBBER, GtkWidget)

struct _GtkFrobberClass
{
  GtkWidgetClass parent_class;

  void (* handle_frob)  (GtkFrobber *frobber,
                         guint       n_frobs);

  gpointer padding[12];
};

GtkWidget *    gtk_frobber_new   (void);

...

#endif
]|

Since the instance structure is public it is often needed to declare a
private struct as follow in your C file:

|[&lt;!-- language="C" --&gt;
typedef struct _GtkFrobberPrivate GtkFrobberPrivate;
struct _GtkFrobberPrivate
{
  ...
};
G_DEFINE_TYPE_WITH_PRIVATE (GtkFrobber, gtk_frobber, GTK_TYPE_WIDGET)
]|

This results in the following things happening:

- the usual `gtk_frobber_get_type()` function is declared with a return type of #GType

- the `GtkFrobber` struct is created with `GtkWidget` as the first and only item.  You are expected to use
  a private structure from your .c file to store your instance variables.

- the `GtkFrobberClass` type is defined as a typedef to `struct _GtkFrobberClass`, which is left undefined.
  You should do this from the header file directly after you use the macro.

- the `GTK_FROBBER()` and `GTK_FROBBER_CLASS()` casts are emitted as `static inline` functions along with
  the `GTK_IS_FROBBER()` and `GTK_IS_FROBBER_CLASS()` type checking functions and `GTK_FROBBER_GET_CLASS()`
  function.

- g_autoptr() support being added for your type, based on the type of your parent class

You can only use this function if your parent type also supports g_autoptr().

Because the type macro (`GTK_TYPE_FROBBER` in the above example) is not a callable, you must continue to
manually define this as a macro for yourself.

The declaration of the `_get_type()` function is the first thing emitted by the macro.  This allows this macro
to be used in the usual way with export control and API versioning macros.

If you are writing a library, it is important to note that it is possible to convert a type from using
G_DECLARE_FINAL_TYPE() to G_DECLARE_DERIVABLE_TYPE() without breaking API or ABI.  As a precaution, you
should therefore use G_DECLARE_FINAL_TYPE() until you are sure that it makes sense for your class to be
subclassed.  Once a class structure has been exposed it is not possible to change its size or remove or
reorder items without breaking the API and/or ABI.  If you want to declare your own class structure, use
G_DECLARE_DERIVABLE_TYPE().  If you want to declare a class without exposing the class or instance
structures, use G_DECLARE_FINAL_TYPE().

If you must use G_DECLARE_DERIVABLE_TYPE() you should be sure to include some padding at the bottom of your
class structure to leave space for the addition of future virtual functions.</doc>
      <parameters>
        <parameter name="ModuleObjName">
          <doc xml:space="preserve">The name of the new type, in camel case (like `GtkWidget`)</doc>
        </parameter>
        <parameter name="module_obj_name">
          <doc xml:space="preserve">The name of the new type in lowercase, with words
 separated by `_` (like `gtk_widget`)</doc>
        </parameter>
        <parameter name="MODULE">
          <doc xml:space="preserve">The name of the module, in all caps (like `GTK`)</doc>
        </parameter>
        <parameter name="OBJ_NAME">
          <doc xml:space="preserve">The bare name of the type, in all caps (like `WIDGET`)</doc>
        </parameter>
        <parameter name="ParentName">
          <doc xml:space="preserve">the name of the parent type, in camel case (like `GtkWidget`)</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DECLARE_FINAL_TYPE" c:identifier="G_DECLARE_FINAL_TYPE" version="2.44" introspectable="0">
      <doc xml:space="preserve">A convenience macro for emitting the usual declarations in the header file
for a type which is not (at the present time) intended to be subclassed.

You might use it in a header as follows:

|[&lt;!-- language="C" --&gt;
#ifndef _myapp_window_h_
#define _myapp_window_h_

#include &lt;gtk/gtk.h&gt;

#define MY_APP_TYPE_WINDOW my_app_window_get_type ()
G_DECLARE_FINAL_TYPE (MyAppWindow, my_app_window, MY_APP, WINDOW, GtkWindow)

MyAppWindow *    my_app_window_new    (void);

...

#endif
]|

And use it as follow in your C file:

|[&lt;!-- language="C" --&gt;
struct _MyAppWindow
{
 GtkWindow parent;
 ...
};
G_DEFINE_TYPE (MyAppWindow, my_app_window, GTK_TYPE_WINDOW)
]|

This results in the following things happening:

- the usual `my_app_window_get_type()` function is declared with a return type of #GType

- the `MyAppWindow` type is defined as a `typedef` of `struct _MyAppWindow`.  The struct itself is not
  defined and should be defined from the .c file before G_DEFINE_TYPE() is used.

- the `MY_APP_WINDOW()` cast is emitted as `static inline` function along with the `MY_APP_IS_WINDOW()` type
  checking function

- the `MyAppWindowClass` type is defined as a struct containing `GtkWindowClass`.  This is done for the
  convenience of the person defining the type and should not be considered to be part of the ABI.  In
  particular, without a firm declaration of the instance structure, it is not possible to subclass the type
  and therefore the fact that the size of the class structure is exposed is not a concern and it can be
  freely changed at any point in the future.

- g_autoptr() support being added for your type, based on the type of your parent class

You can only use this function if your parent type also supports g_autoptr().

Because the type macro (`MY_APP_TYPE_WINDOW` in the above example) is not a callable, you must continue to
manually define this as a macro for yourself.

The declaration of the `_get_type()` function is the first thing emitted by the macro.  This allows this macro
to be used in the usual way with export control and API versioning macros.

If you want to declare your own class structure, use G_DECLARE_DERIVABLE_TYPE().

If you are writing a library, it is important to note that it is possible to convert a type from using
G_DECLARE_FINAL_TYPE() to G_DECLARE_DERIVABLE_TYPE() without breaking API or ABI.  As a precaution, you
should therefore use G_DECLARE_FINAL_TYPE() until you are sure that it makes sense for your class to be
subclassed.  Once a class structure has been exposed it is not possible to change its size or remove or
reorder items without breaking the API and/or ABI.</doc>
      <parameters>
        <parameter name="ModuleObjName">
          <doc xml:space="preserve">The name of the new type, in camel case (like `GtkWidget`)</doc>
        </parameter>
        <parameter name="module_obj_name">
          <doc xml:space="preserve">The name of the new type in lowercase, with words
 separated by `_` (like `gtk_widget`)</doc>
        </parameter>
        <parameter name="MODULE">
          <doc xml:space="preserve">The name of the module, in all caps (like `GTK`)</doc>
        </parameter>
        <parameter name="OBJ_NAME">
          <doc xml:space="preserve">The bare name of the type, in all caps (like `WIDGET`)</doc>
        </parameter>
        <parameter name="ParentName">
          <doc xml:space="preserve">the name of the parent type, in camel case (like `GtkWidget`)</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DECLARE_INTERFACE" c:identifier="G_DECLARE_INTERFACE" version="2.44" introspectable="0">
      <doc xml:space="preserve">A convenience macro for emitting the usual declarations in the header file for a #GInterface type.

You might use it in a header as follows:

|[&lt;!-- language="C" --&gt;
#ifndef _my_model_h_
#define _my_model_h_

#define MY_TYPE_MODEL my_model_get_type ()
GDK_AVAILABLE_IN_3_12
G_DECLARE_INTERFACE (MyModel, my_model, MY, MODEL, GObject)

struct _MyModelInterface
{
  GTypeInterface g_iface;

  gpointer (* get_item)  (MyModel *model);
};

gpointer my_model_get_item (MyModel *model);

...

#endif
]|

And use it as follow in your C file:

|[&lt;!-- language="C" --&gt;
G_DEFINE_INTERFACE (MyModel, my_model, G_TYPE_OBJECT);

static void
my_model_default_init (MyModelInterface *iface)
{
  ...
}
]|

This results in the following things happening:

- the usual `my_model_get_type()` function is declared with a return type of #GType

- the `MyModelInterface` type is defined as a typedef to `struct _MyModelInterface`,
  which is left undefined. You should do this from the header file directly after
  you use the macro.

- the `MY_MODEL()` cast is emitted as `static inline` functions along with
  the `MY_IS_MODEL()` type checking function and `MY_MODEL_GET_IFACE()` function.

- g_autoptr() support being added for your type, based on your prerequisite type.

You can only use this function if your prerequisite type also supports g_autoptr().

Because the type macro (`MY_TYPE_MODEL` in the above example) is not a callable, you must continue to
manually define this as a macro for yourself.

The declaration of the `_get_type()` function is the first thing emitted by the macro.  This allows this macro
to be used in the usual way with export control and API versioning macros.</doc>
      <parameters>
        <parameter name="ModuleObjName">
          <doc xml:space="preserve">The name of the new type, in camel case (like `GtkWidget`)</doc>
        </parameter>
        <parameter name="module_obj_name">
          <doc xml:space="preserve">The name of the new type in lowercase, with words
 separated by `_` (like `gtk_widget`)</doc>
        </parameter>
        <parameter name="MODULE">
          <doc xml:space="preserve">The name of the module, in all caps (like `GTK`)</doc>
        </parameter>
        <parameter name="OBJ_NAME">
          <doc xml:space="preserve">The bare name of the type, in all caps (like `WIDGET`)</doc>
        </parameter>
        <parameter name="PrerequisiteName">
          <doc xml:space="preserve">the name of the prerequisite type, in camel case (like `GtkWidget`)</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_ABSTRACT_TYPE" c:identifier="G_DEFINE_ABSTRACT_TYPE" version="2.4" introspectable="0">
      <doc xml:space="preserve">A convenience macro for type implementations.

Similar to G_DEFINE_TYPE(), but defines an abstract type.
See G_DEFINE_TYPE_EXTENDED() for an example.</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">The name of the new type, in Camel case.</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
 separated by `_`.</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">The #GType of the parent type.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_ABSTRACT_TYPE_WITH_CODE" c:identifier="G_DEFINE_ABSTRACT_TYPE_WITH_CODE" version="2.4" introspectable="0">
      <doc xml:space="preserve">A convenience macro for type implementations.

Similar to G_DEFINE_TYPE_WITH_CODE(), but defines an abstract type and
allows you to insert custom code into the `*_get_type()` function, e.g.
interface implementations via G_IMPLEMENT_INTERFACE().

See G_DEFINE_TYPE_EXTENDED() for an example.</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">The name of the new type, in Camel case.</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
 separated by `_`.</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">The #GType of the parent type.</doc>
        </parameter>
        <parameter name="_C_">
          <doc xml:space="preserve">Custom code that gets inserted in the `type_name_get_type()` function.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_ABSTRACT_TYPE_WITH_PRIVATE" c:identifier="G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE" version="2.38" introspectable="0">
      <doc xml:space="preserve">Similar to G_DEFINE_TYPE_WITH_PRIVATE(), but defines an abstract type.

See G_DEFINE_TYPE_EXTENDED() for an example.</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">The name of the new type, in Camel case.</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
 separated by `_`.</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">The #GType of the parent type.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_BOXED_TYPE" c:identifier="G_DEFINE_BOXED_TYPE" version="2.26" introspectable="0">
      <doc xml:space="preserve">A convenience macro for defining a new custom boxed type.

Using this macro is the recommended way of defining new custom boxed
types, over calling g_boxed_type_register_static() directly. It defines
a `type_name_get_type()` function which will return the newly defined
#GType, enabling lazy instantiation.

You might start by putting declarations in a header as follows:

|[&lt;!-- language="C" --&gt;
#define MY_TYPE_STRUCT my_struct_get_type ()
GType my_struct_get_type (void) G_GNUC_CONST;

MyStruct *    my_struct_new (void);
void          my_struct_free (MyStruct *self);
MyStruct *    my_struct_copy (MyStruct *self);
]|

And then use this macro and define your implementation in the source file as
follows:

|[&lt;!-- language="C" --&gt;
MyStruct *
my_struct_new (void)
{
  // ... your code to allocate a new MyStruct ...
}

void
my_struct_free (MyStruct *self)
{
  // ... your code to free a MyStruct ...
}

MyStruct *
my_struct_copy (MyStruct *self)
{
  // ... your code return a newly allocated copy of a MyStruct ...
}

G_DEFINE_BOXED_TYPE (MyStruct, my_struct, my_struct_copy, my_struct_free)

void
foo ()
{
  MyStruct *ms;

  ms = my_struct_new ();
  // ... your code ...
  my_struct_free (ms);
}
]|</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">The name of the new type, in Camel case</doc>
        </parameter>
        <parameter name="type_name">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
 separated by `_`</doc>
        </parameter>
        <parameter name="copy_func">
          <doc xml:space="preserve">the #GBoxedCopyFunc for the new type</doc>
        </parameter>
        <parameter name="free_func">
          <doc xml:space="preserve">the #GBoxedFreeFunc for the new type</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_BOXED_TYPE_WITH_CODE" c:identifier="G_DEFINE_BOXED_TYPE_WITH_CODE" version="2.26" introspectable="0">
      <doc xml:space="preserve">A convenience macro for boxed type implementations.

Similar to G_DEFINE_BOXED_TYPE(), but allows to insert custom code into the
`type_name_get_type()` function, e.g. to register value transformations with
g_value_register_transform_func(), for instance:

|[&lt;!-- language="C" --&gt;
G_DEFINE_BOXED_TYPE_WITH_CODE (GdkRectangle, gdk_rectangle,
                               gdk_rectangle_copy,
                               gdk_rectangle_free,
                               register_rectangle_transform_funcs (g_define_type_id))
]|

Similarly to the `G_DEFINE_TYPE_*` family of macros, the #GType of the newly
defined boxed type is exposed in the `g_define_type_id` variable.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">The name of the new type, in Camel case</doc>
        </parameter>
        <parameter name="type_name">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
 separated by `_`</doc>
        </parameter>
        <parameter name="copy_func">
          <doc xml:space="preserve">the #GBoxedCopyFunc for the new type</doc>
        </parameter>
        <parameter name="free_func">
          <doc xml:space="preserve">the #GBoxedFreeFunc for the new type</doc>
        </parameter>
        <parameter name="_C_">
          <doc xml:space="preserve">Custom code that gets inserted in the `*_get_type()` function</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_DYNAMIC_TYPE" c:identifier="G_DEFINE_DYNAMIC_TYPE" version="2.14" introspectable="0">
      <doc xml:space="preserve">A convenience macro for dynamic type implementations, which declares a
class initialization function, an instance initialization function (see
#GTypeInfo for information about these) and a static variable named
`t_n`_parent_class pointing to the parent class.

Furthermore, it defines a `*_get_type()` and a static `*_register_type()`
functions for use in your `module_init()`.

See G_DEFINE_DYNAMIC_TYPE_EXTENDED() for an example.</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">The name of the new type, in Camel case.</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
 separated by '_'.</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">The #GType of the parent type.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_DYNAMIC_TYPE_EXTENDED" c:identifier="G_DEFINE_DYNAMIC_TYPE_EXTENDED" version="2.14" introspectable="0">
      <doc xml:space="preserve">A more general version of G_DEFINE_DYNAMIC_TYPE() which
allows to specify #GTypeFlags and custom code.

|[&lt;!-- language="C" --&gt;
G_DEFINE_DYNAMIC_TYPE_EXTENDED (GtkGadget,
                                gtk_gadget,
                                GTK_TYPE_THING,
                                0,
                                G_IMPLEMENT_INTERFACE_DYNAMIC (TYPE_GIZMO,
                                                               gtk_gadget_gizmo_init));
]|

expands to

|[&lt;!-- language="C" --&gt;
static void     gtk_gadget_init              (GtkGadget      *self);
static void     gtk_gadget_class_init        (GtkGadgetClass *klass);
static void     gtk_gadget_class_finalize    (GtkGadgetClass *klass);

static gpointer gtk_gadget_parent_class = NULL;
static GType    gtk_gadget_type_id = 0;

static void     gtk_gadget_class_intern_init (gpointer klass)
{
  gtk_gadget_parent_class = g_type_class_peek_parent (klass);
  gtk_gadget_class_init ((GtkGadgetClass*) klass);
}

GType
gtk_gadget_get_type (void)
{
  return gtk_gadget_type_id;
}

static void
gtk_gadget_register_type (GTypeModule *type_module)
{
  const GTypeInfo g_define_type_info = {
    sizeof (GtkGadgetClass),
    (GBaseInitFunc) NULL,
    (GBaseFinalizeFunc) NULL,
    (GClassInitFunc) gtk_gadget_class_intern_init,
    (GClassFinalizeFunc) gtk_gadget_class_finalize,
    NULL,   // class_data
    sizeof (GtkGadget),
    0,      // n_preallocs
    (GInstanceInitFunc) gtk_gadget_init,
    NULL    // value_table
  };
  gtk_gadget_type_id = g_type_module_register_type (type_module,
                                                    GTK_TYPE_THING,
                                                    "GtkGadget",
                                                    &amp;g_define_type_info,
                                                    (GTypeFlags) flags);
  {
    const GInterfaceInfo g_implement_interface_info = {
      (GInterfaceInitFunc) gtk_gadget_gizmo_init
    };
    g_type_module_add_interface (type_module, g_define_type_id, TYPE_GIZMO, &amp;g_implement_interface_info);
  }
}
]|</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">The name of the new type, in Camel case.</doc>
        </parameter>
        <parameter name="type_name">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
 separated by '_'.</doc>
        </parameter>
        <parameter name="TYPE_PARENT">
          <doc xml:space="preserve">The #GType of the parent type.</doc>
        </parameter>
        <parameter name="flags">
          <doc xml:space="preserve">#GTypeFlags to pass to g_type_module_register_type()</doc>
        </parameter>
        <parameter name="CODE">
          <doc xml:space="preserve">Custom code that gets inserted in the *_get_type() function.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_ENUM_TYPE" c:identifier="G_DEFINE_ENUM_TYPE" version="2.74" introspectable="0">
      <doc xml:space="preserve">A convenience macro for defining enumeration types.

This macro will generate a `*_get_type()` function for the
given @TypeName, using @type_name as the function prefix.

|[&lt;!-- language="C" --&gt;
G_DEFINE_ENUM_TYPE (GtkOrientation, gtk_orientation,
  G_DEFINE_ENUM_VALUE (GTK_ORIENTATION_HORIZONTAL, "horizontal"),
  G_DEFINE_ENUM_VALUE (GTK_ORIENTATION_VERTICAL, "vertical"))
]|

For projects that have multiple enumeration types, or enumeration
types with many values, you should consider using glib-mkenums to
generate the type function.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">the enumeration type, in `CamelCase`</doc>
        </parameter>
        <parameter name="type_name">
          <doc xml:space="preserve">the enumeration type prefixed, in `snake_case`</doc>
        </parameter>
        <parameter name="...">
          <doc xml:space="preserve">a list of enumeration values, defined using G_DEFINE_ENUM_VALUE()</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_ENUM_VALUE" c:identifier="G_DEFINE_ENUM_VALUE" version="2.74" introspectable="0">
      <doc xml:space="preserve">Defines an enumeration value, and maps it to a "nickname".

This macro can only be used with G_DEFINE_ENUM_TYPE() and
G_DEFINE_FLAGS_TYPE().</doc>
      <parameters>
        <parameter name="EnumValue">
          <doc xml:space="preserve">an enumeration value</doc>
        </parameter>
        <parameter name="EnumNick">
          <doc xml:space="preserve">a short string representing the enumeration value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_FINAL_TYPE" c:identifier="G_DEFINE_FINAL_TYPE" version="2.70" introspectable="0">
      <doc xml:space="preserve">A convenience macro for type implementations.

Similar to G_DEFINE_TYPE(), but defines a final type.

See G_DEFINE_TYPE_EXTENDED() for an example.</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">the name of the new type, in Camel case</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">the name of the new type, in lower case, with words
  separated by `_` (snake case)</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">the #GType of the parent type</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_FINAL_TYPE_WITH_CODE" c:identifier="G_DEFINE_FINAL_TYPE_WITH_CODE" version="2.70" introspectable="0">
      <doc xml:space="preserve">A convenience macro for type implementations.

Similar to G_DEFINE_TYPE_WITH_CODE(), but defines a final type and
allows you to insert custom code into the `*_get_type()` function, e.g.
interface implementations via G_IMPLEMENT_INTERFACE().

See G_DEFINE_TYPE_EXTENDED() for an example.</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">the name of the new type, in Camel case</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">the name of the new type, in lower case, with words
  separated by `_` (snake case)</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">the #GType of the parent type</doc>
        </parameter>
        <parameter name="_C_">
          <doc xml:space="preserve">Custom code that gets inserted in the `type_name_get_type()` function.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_FINAL_TYPE_WITH_PRIVATE" c:identifier="G_DEFINE_FINAL_TYPE_WITH_PRIVATE" version="2.70" introspectable="0">
      <doc xml:space="preserve">A convenience macro for type implementations.

Similar to G_DEFINE_TYPE_WITH_PRIVATE(), but defines a final type.

See G_DEFINE_TYPE_EXTENDED() for an example.</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">the name of the new type, in Camel case</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">the name of the new type, in lower case, with words
  separated by `_` (snake case)</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">the #GType of the parent type</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_FLAGS_TYPE" c:identifier="G_DEFINE_FLAGS_TYPE" version="2.74" introspectable="0">
      <doc xml:space="preserve">A convenience macro for defining flag types.

This macro will generate a `*_get_type()` function for the
given @TypeName, using @type_name as the function prefix.

|[&lt;!-- language="C" --&gt;
G_DEFINE_FLAGS_TYPE (GSettingsBindFlags, g_settings_bind_flags,
  G_DEFINE_ENUM_VALUE (G_SETTINGS_BIND_DEFAULT, "default"),
  G_DEFINE_ENUM_VALUE (G_SETTINGS_BIND_GET, "get"),
  G_DEFINE_ENUM_VALUE (G_SETTINGS_BIND_SET, "set"),
  G_DEFINE_ENUM_VALUE (G_SETTINGS_BIND_NO_SENSITIVITY, "no-sensitivity"),
  G_DEFINE_ENUM_VALUE (G_SETTINGS_BIND_GET_NO_CHANGES, "get-no-changes"),
  G_DEFINE_ENUM_VALUE (G_SETTINGS_BIND_INVERT_BOOLEAN, "invert-boolean"))
]|

For projects that have multiple enumeration types, or enumeration
types with many values, you should consider using glib-mkenums to
generate the type function.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">the enumeration type, in `CamelCase`</doc>
        </parameter>
        <parameter name="type_name">
          <doc xml:space="preserve">the enumeration type prefixed, in `snake_case`</doc>
        </parameter>
        <parameter name="...">
          <doc xml:space="preserve">a list of enumeration values, defined using G_DEFINE_ENUM_VALUE()</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_INTERFACE" c:identifier="G_DEFINE_INTERFACE" version="2.24" introspectable="0">
      <doc xml:space="preserve">A convenience macro for #GTypeInterface definitions, which declares
a default vtable initialization function and defines a `*_get_type()`
function.

The macro expects the interface initialization function to have the
name `t_n ## _default_init`, and the interface structure to have the
name `TN ## Interface`.

The initialization function has signature
`static void t_n ## _default_init (TypeName##Interface *klass);`, rather than
the full #GInterfaceInitFunc signature, for brevity and convenience. If you
need to use an initialization function with an `iface_data` argument, you
must write the #GTypeInterface definitions manually.</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">The name of the new type, in Camel case.</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words separated by `_`.</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">The #GType of the prerequisite type for the interface, or %G_TYPE_INVALID
for no prerequisite type.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_INTERFACE_WITH_CODE" c:identifier="G_DEFINE_INTERFACE_WITH_CODE" version="2.24" introspectable="0">
      <doc xml:space="preserve">A convenience macro for #GTypeInterface definitions.

Similar to G_DEFINE_INTERFACE(), but allows you to insert custom code
into the `*_get_type()` function, e.g. additional interface implementations
via G_IMPLEMENT_INTERFACE(), or additional prerequisite types.

See G_DEFINE_TYPE_EXTENDED() for a similar example using
G_DEFINE_TYPE_WITH_CODE().</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">The name of the new type, in Camel case.</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words separated by `_`.</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">The #GType of the prerequisite type for the interface, or %G_TYPE_INVALID
for no prerequisite type.</doc>
        </parameter>
        <parameter name="_C_">
          <doc xml:space="preserve">Custom code that gets inserted in the `*_get_type()` function.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_POINTER_TYPE" c:identifier="G_DEFINE_POINTER_TYPE" version="2.26" introspectable="0">
      <doc xml:space="preserve">A convenience macro for pointer type implementations, which defines a
`type_name_get_type()` function registering the pointer type.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">The name of the new type, in Camel case</doc>
        </parameter>
        <parameter name="type_name">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
 separated by `_`</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_POINTER_TYPE_WITH_CODE" c:identifier="G_DEFINE_POINTER_TYPE_WITH_CODE" version="2.26" introspectable="0">
      <doc xml:space="preserve">A convenience macro for pointer type implementations.
Similar to G_DEFINE_POINTER_TYPE(), but allows to insert
custom code into the `type_name_get_type()` function.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">The name of the new type, in Camel case</doc>
        </parameter>
        <parameter name="type_name">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
 separated by `_`</doc>
        </parameter>
        <parameter name="_C_">
          <doc xml:space="preserve">Custom code that gets inserted in the `*_get_type()` function</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_TYPE" c:identifier="G_DEFINE_TYPE" version="2.4" introspectable="0">
      <doc xml:space="preserve">A convenience macro for type implementations, which declares a class
initialization function, an instance initialization function (see #GTypeInfo
for information about these) and a static variable named `t_n_parent_class`
pointing to the parent class. Furthermore, it defines a `*_get_type()` function.
See G_DEFINE_TYPE_EXTENDED() for an example.</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">The name of the new type, in Camel case.</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
 separated by `_`.</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">The #GType of the parent type.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_TYPE_EXTENDED" c:identifier="G_DEFINE_TYPE_EXTENDED" version="2.4" introspectable="0">
      <doc xml:space="preserve">The most general convenience macro for type implementations, on which
G_DEFINE_TYPE(), etc are based.

|[&lt;!-- language="C" --&gt;
G_DEFINE_TYPE_EXTENDED (GtkGadget,
                        gtk_gadget,
                        GTK_TYPE_WIDGET,
                        0,
                        G_ADD_PRIVATE (GtkGadget)
                        G_IMPLEMENT_INTERFACE (TYPE_GIZMO,
                                               gtk_gadget_gizmo_init));
]|

expands to

|[&lt;!-- language="C" --&gt;
static void     gtk_gadget_init       (GtkGadget      *self);
static void     gtk_gadget_class_init (GtkGadgetClass *klass);
static gpointer gtk_gadget_parent_class = NULL;
static gint     GtkGadget_private_offset;
static void     gtk_gadget_class_intern_init (gpointer klass)
{
  gtk_gadget_parent_class = g_type_class_peek_parent (klass);
  if (GtkGadget_private_offset != 0)
    g_type_class_adjust_private_offset (klass, &amp;GtkGadget_private_offset);
  gtk_gadget_class_init ((GtkGadgetClass*) klass);
}
static inline gpointer gtk_gadget_get_instance_private (GtkGadget *self)
{
  return (G_STRUCT_MEMBER_P (self, GtkGadget_private_offset));
}

GType
gtk_gadget_get_type (void)
{
  static GType static_g_define_type_id = 0;
  if (g_once_init_enter_pointer (&amp;static_g_define_type_id))
    {
      GType g_define_type_id =
        g_type_register_static_simple (GTK_TYPE_WIDGET,
                                       g_intern_static_string ("GtkGadget"),
                                       sizeof (GtkGadgetClass),
                                       (GClassInitFunc) gtk_gadget_class_intern_init,
                                       sizeof (GtkGadget),
                                       (GInstanceInitFunc) gtk_gadget_init,
                                       0);
      {
        GtkGadget_private_offset =
          g_type_add_instance_private (g_define_type_id, sizeof (GtkGadgetPrivate));
      }
      {
        const GInterfaceInfo g_implement_interface_info = {
          (GInterfaceInitFunc) gtk_gadget_gizmo_init
        };
        g_type_add_interface_static (g_define_type_id, TYPE_GIZMO, &amp;g_implement_interface_info);
      }
      g_once_init_leave_pointer (&amp;static_g_define_type_id, g_define_type_id);
    }
  return static_g_define_type_id;
}
]|

The only pieces which have to be manually provided are the definitions of
the instance and class structure and the definitions of the instance and
class init functions.</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">The name of the new type, in Camel case.</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
   separated by `_`.</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">The #GType of the parent type.</doc>
        </parameter>
        <parameter name="_f_">
          <doc xml:space="preserve">#GTypeFlags to pass to g_type_register_static()</doc>
        </parameter>
        <parameter name="_C_">
          <doc xml:space="preserve">Custom code that gets inserted in the `*_get_type()` function.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_TYPE_WITH_CODE" c:identifier="G_DEFINE_TYPE_WITH_CODE" version="2.4" introspectable="0">
      <doc xml:space="preserve">A convenience macro for type implementations.

Similar to G_DEFINE_TYPE(), but allows you to insert custom code into the
`*_get_type()` function, e.g. interface implementations via G_IMPLEMENT_INTERFACE().
See G_DEFINE_TYPE_EXTENDED() for an example.</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">The name of the new type, in Camel case.</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">The name of the new type in lowercase, with words separated by `_`.</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">The #GType of the parent type.</doc>
        </parameter>
        <parameter name="_C_">
          <doc xml:space="preserve">Custom code that gets inserted in the `*_get_type()` function.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEFINE_TYPE_WITH_PRIVATE" c:identifier="G_DEFINE_TYPE_WITH_PRIVATE" version="2.38" introspectable="0">
      <doc xml:space="preserve">A convenience macro for type implementations, which declares a class
initialization function, an instance initialization function (see #GTypeInfo
for information about these), a static variable named `t_n_parent_class`
pointing to the parent class, and adds private instance data to the type.

Furthermore, it defines a `*_get_type()` function. See G_DEFINE_TYPE_EXTENDED()
for an example.

Note that private structs added with this macros must have a struct
name of the form `TN ## Private`.

The private instance data can be retrieved using the automatically generated
getter function `t_n_get_instance_private()`.

See also: G_ADD_PRIVATE()</doc>
      <parameters>
        <parameter name="TN">
          <doc xml:space="preserve">The name of the new type, in Camel case.</doc>
        </parameter>
        <parameter name="t_n">
          <doc xml:space="preserve">The name of the new type, in lowercase, with words
 separated by `_`.</doc>
        </parameter>
        <parameter name="T_P">
          <doc xml:space="preserve">The #GType of the parent type.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_26_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_26_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_28_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_28_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_30_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_30_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_32_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_32_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_34_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_34_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_36_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_36_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_38_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_38_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_40_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_40_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_42_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_42_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_44_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_44_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_46_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_46_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_48_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_48_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_50_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_50_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_52_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_52_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_54_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_54_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_56_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_56_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_58_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_58_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_60_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_60_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_62_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_62_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_64_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_64_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_66_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_66_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_68_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_68_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_70_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_70_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_72_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_72_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_74_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_74_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_76_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_76_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_78_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_78_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_80_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_80_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_ENUMERATOR_IN_2_82_FOR" c:identifier="GOBJECT_DEPRECATED_ENUMERATOR_IN_2_82_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_FOR" c:identifier="GOBJECT_DEPRECATED_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_26_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_26_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_28_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_28_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_30_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_30_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_32_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_32_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_34_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_34_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_36_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_36_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_38_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_38_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_40_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_40_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_42_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_42_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_44_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_44_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_46_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_46_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_48_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_48_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_50_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_50_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_52_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_52_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_54_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_54_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_56_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_56_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_58_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_58_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_60_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_60_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_62_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_62_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_64_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_64_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_66_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_66_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_68_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_68_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_70_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_70_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_72_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_72_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_74_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_74_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_76_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_76_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_78_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_78_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_80_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_80_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_2_82_FOR" c:identifier="GOBJECT_DEPRECATED_IN_2_82_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_26_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_26_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_28_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_28_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_30_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_30_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_32_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_32_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_34_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_34_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_36_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_36_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_38_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_38_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_40_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_40_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_42_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_42_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_44_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_44_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_46_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_46_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_48_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_48_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_50_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_50_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_52_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_52_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_54_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_54_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_56_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_56_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_58_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_58_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_60_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_60_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_62_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_62_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_64_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_64_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_66_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_66_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_68_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_68_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_70_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_70_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_72_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_72_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_74_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_74_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_76_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_76_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_78_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_78_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_80_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_80_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_MACRO_IN_2_82_FOR" c:identifier="GOBJECT_DEPRECATED_MACRO_IN_2_82_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_26_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_26_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_28_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_28_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_30_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_30_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_32_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_32_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_34_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_34_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_36_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_36_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_38_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_38_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_40_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_40_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_42_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_42_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_44_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_44_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_46_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_46_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_48_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_48_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_50_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_50_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_52_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_52_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_54_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_54_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_56_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_56_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_58_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_58_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_60_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_60_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_62_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_62_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_64_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_64_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_66_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_66_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_68_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_68_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_70_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_70_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_72_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_72_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_74_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_74_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_76_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_76_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_78_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_78_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_80_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_80_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_TYPE_IN_2_82_FOR" c:identifier="GOBJECT_DEPRECATED_TYPE_IN_2_82_FOR" introspectable="0">
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <glib:boxed glib:name="Date" c:symbol-prefix="date" glib:type-name="GDate" glib:get-type="g_date_get_type">
    </glib:boxed>
    <glib:boxed glib:name="DateTime" c:symbol-prefix="date_time" glib:type-name="GDateTime" glib:get-type="g_date_time_get_type">
    </glib:boxed>
    <glib:boxed glib:name="Dir" c:symbol-prefix="dir" glib:type-name="GDir" glib:get-type="g_dir_get_type">
    </glib:boxed>
    <function-macro name="ENUM_CLASS" c:identifier="G_ENUM_CLASS" introspectable="0">
      <doc xml:space="preserve">Casts a derived #GEnumClass structure into a #GEnumClass structure.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a valid #GEnumClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ENUM_CLASS_TYPE" c:identifier="G_ENUM_CLASS_TYPE" introspectable="0">
      <doc xml:space="preserve">Get the type identifier from a given #GEnumClass structure.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a #GEnumClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ENUM_CLASS_TYPE_NAME" c:identifier="G_ENUM_CLASS_TYPE_NAME" introspectable="0">
      <doc xml:space="preserve">Get the static type name from a given #GEnumClass structure.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a #GEnumClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="EnumClass" c:type="GEnumClass">
      <doc xml:space="preserve">The class of an enumeration type holds information about its
possible values.</doc>
      <field name="g_type_class" writable="1">
        <doc xml:space="preserve">the parent class</doc>
        <type name="TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="minimum" writable="1">
        <doc xml:space="preserve">the smallest possible value.</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="maximum" writable="1">
        <doc xml:space="preserve">the largest possible value.</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="n_values" writable="1">
        <doc xml:space="preserve">the number of possible values.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="values" writable="1">
        <doc xml:space="preserve">an array of #GEnumValue structs describing the
 individual values.</doc>
        <type name="EnumValue" c:type="GEnumValue*"/>
      </field>
    </record>
    <record name="EnumValue" c:type="GEnumValue">
      <doc xml:space="preserve">A structure which contains a single enum value, its name, and its
nickname.</doc>
      <field name="value" writable="1">
        <doc xml:space="preserve">the enum value</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="value_name" writable="1">
        <doc xml:space="preserve">the name of the value</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="value_nick" writable="1">
        <doc xml:space="preserve">the nickname of the value</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
    </record>
    <glib:boxed glib:name="Error" c:symbol-prefix="error" glib:type-name="GError" glib:get-type="g_error_get_type">
    </glib:boxed>
    <function-macro name="FLAGS_CLASS" c:identifier="G_FLAGS_CLASS" introspectable="0">
      <doc xml:space="preserve">Casts a derived #GFlagsClass structure into a #GFlagsClass structure.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a valid #GFlagsClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FLAGS_CLASS_TYPE" c:identifier="G_FLAGS_CLASS_TYPE" introspectable="0">
      <doc xml:space="preserve">Get the type identifier from a given #GFlagsClass structure.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a #GFlagsClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FLAGS_CLASS_TYPE_NAME" c:identifier="G_FLAGS_CLASS_TYPE_NAME" introspectable="0">
      <doc xml:space="preserve">Get the static type name from a given #GFlagsClass structure.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a #GFlagsClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="FlagsClass" c:type="GFlagsClass">
      <doc xml:space="preserve">The class of a flags type holds information about its
possible values.</doc>
      <field name="g_type_class" writable="1">
        <doc xml:space="preserve">the parent class</doc>
        <type name="TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="mask" writable="1">
        <doc xml:space="preserve">a mask covering all possible values.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="n_values" writable="1">
        <doc xml:space="preserve">the number of possible values.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="values" writable="1">
        <doc xml:space="preserve">an array of #GFlagsValue structs describing the
 individual values.</doc>
        <type name="FlagsValue" c:type="GFlagsValue*"/>
      </field>
    </record>
    <record name="FlagsValue" c:type="GFlagsValue">
      <doc xml:space="preserve">A structure which contains a single flags value, its name, and its
nickname.</doc>
      <field name="value" writable="1">
        <doc xml:space="preserve">the flags value</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="value_name" writable="1">
        <doc xml:space="preserve">the name of the value</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="value_nick" writable="1">
        <doc xml:space="preserve">the nickname of the value</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
    </record>
    <glib:boxed glib:name="HashTable" c:symbol-prefix="hash_table" glib:type-name="GHashTable" glib:get-type="g_hash_table_get_type">
    </glib:boxed>
    <glib:boxed glib:name="Hmac" c:symbol-prefix="hmac" glib:type-name="GHmac" glib:get-type="g_hmac_get_type">
    </glib:boxed>
    <function-macro name="IMPLEMENT_INTERFACE" c:identifier="G_IMPLEMENT_INTERFACE" version="2.4" introspectable="0">
      <doc xml:space="preserve">A convenience macro to ease interface addition in the `_C_` section
of G_DEFINE_TYPE_WITH_CODE() or G_DEFINE_ABSTRACT_TYPE_WITH_CODE().
See G_DEFINE_TYPE_EXTENDED() for an example.

Note that this macro can only be used together with the `G_DEFINE_TYPE_*`
macros, since it depends on variable names from those macros.</doc>
      <parameters>
        <parameter name="TYPE_IFACE">
          <doc xml:space="preserve">The #GType of the interface to add</doc>
        </parameter>
        <parameter name="iface_init">
          <doc xml:space="preserve">The interface init function, of type #GInterfaceInitFunc</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IMPLEMENT_INTERFACE_DYNAMIC" c:identifier="G_IMPLEMENT_INTERFACE_DYNAMIC" version="2.24" introspectable="0">
      <doc xml:space="preserve">A convenience macro to ease interface addition in the @_C_ section
of G_DEFINE_DYNAMIC_TYPE_EXTENDED().

See G_DEFINE_DYNAMIC_TYPE_EXTENDED() for an example.

Note that this macro can only be used together with the
G_DEFINE_DYNAMIC_TYPE_EXTENDED macros, since it depends on variable
names from that macro.</doc>
      <parameters>
        <parameter name="TYPE_IFACE">
          <doc xml:space="preserve">The #GType of the interface to add</doc>
        </parameter>
        <parameter name="iface_init">
          <doc xml:space="preserve">The interface init function</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="INITIALLY_UNOWNED" c:identifier="G_INITIALLY_UNOWNED" introspectable="0">
      <doc xml:space="preserve">Casts a #GInitiallyUnowned or derived pointer into a (GInitiallyUnowned*)
pointer.

Depending on the current debugging level, this function may invoke
certain runtime checks to identify invalid casts.</doc>
      <parameters>
        <parameter name="object">
          <doc xml:space="preserve">Object which is subject to casting.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="INITIALLY_UNOWNED_CLASS" c:identifier="G_INITIALLY_UNOWNED_CLASS" introspectable="0">
      <doc xml:space="preserve">Casts a derived #GInitiallyUnownedClass structure into a
#GInitiallyUnownedClass structure.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a valid #GInitiallyUnownedClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="INITIALLY_UNOWNED_GET_CLASS" c:identifier="G_INITIALLY_UNOWNED_GET_CLASS" introspectable="0">
      <doc xml:space="preserve">Get the class structure associated to a #GInitiallyUnowned instance.</doc>
      <parameters>
        <parameter name="object">
          <doc xml:space="preserve">a #GInitiallyUnowned instance.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <glib:boxed glib:name="IOChannel" c:symbol-prefix="io_channel" glib:type-name="GIOChannel" glib:get-type="g_io_channel_get_type">
    </glib:boxed>
    <bitfield name="IOCondition" glib:type-name="GIOCondition" glib:get-type="g_io_condition_get_type" c:type="GIOCondition">
      <member name="in" value="1" c:identifier="G_IO_IN" glib:nick="in" glib:name="G_IO_IN">
      </member>
      <member name="out" value="4" c:identifier="G_IO_OUT" glib:nick="out" glib:name="G_IO_OUT">
      </member>
      <member name="pri" value="2" c:identifier="G_IO_PRI" glib:nick="pri" glib:name="G_IO_PRI">
      </member>
      <member name="err" value="8" c:identifier="G_IO_ERR" glib:nick="err" glib:name="G_IO_ERR">
      </member>
      <member name="hup" value="16" c:identifier="G_IO_HUP" glib:nick="hup" glib:name="G_IO_HUP">
      </member>
      <member name="nval" value="32" c:identifier="G_IO_NVAL" glib:nick="nval" glib:name="G_IO_NVAL">
      </member>
    </bitfield>
    <function-macro name="IS_BINDING" c:identifier="G_IS_BINDING" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BINDING_GROUP" c:identifier="G_IS_BINDING_GROUP" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_ENUM_CLASS" c:identifier="G_IS_ENUM_CLASS" introspectable="0">
      <doc xml:space="preserve">Checks whether @class "is a" valid #GEnumClass structure of type %G_TYPE_ENUM
or derived.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a #GEnumClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_FLAGS_CLASS" c:identifier="G_IS_FLAGS_CLASS" introspectable="0">
      <doc xml:space="preserve">Checks whether @class "is a" valid #GFlagsClass structure of type %G_TYPE_FLAGS
or derived.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a #GFlagsClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_INITIALLY_UNOWNED" c:identifier="G_IS_INITIALLY_UNOWNED" introspectable="0">
      <doc xml:space="preserve">Checks whether a valid #GTypeInstance pointer is of type %G_TYPE_INITIALLY_UNOWNED.</doc>
      <parameters>
        <parameter name="object">
          <doc xml:space="preserve">Instance to check for being a %G_TYPE_INITIALLY_UNOWNED.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_INITIALLY_UNOWNED_CLASS" c:identifier="G_IS_INITIALLY_UNOWNED_CLASS" introspectable="0">
      <doc xml:space="preserve">Checks whether @class "is a" valid #GInitiallyUnownedClass structure of type
%G_TYPE_INITIALLY_UNOWNED or derived.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a #GInitiallyUnownedClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_OBJECT" c:identifier="G_IS_OBJECT" introspectable="0">
      <doc xml:space="preserve">Checks whether a valid #GTypeInstance pointer is of type %G_TYPE_OBJECT.</doc>
      <parameters>
        <parameter name="object">
          <doc xml:space="preserve">Instance to check for being a %G_TYPE_OBJECT.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_OBJECT_CLASS" c:identifier="G_IS_OBJECT_CLASS" introspectable="0">
      <doc xml:space="preserve">Checks whether @class "is a" valid #GObjectClass structure of type
%G_TYPE_OBJECT or derived.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a #GObjectClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC" c:identifier="G_IS_PARAM_SPEC" introspectable="0">
      <doc xml:space="preserve">Checks whether @pspec "is a" valid #GParamSpec structure of type %G_TYPE_PARAM
or derived.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_BOOLEAN" c:identifier="G_IS_PARAM_SPEC_BOOLEAN" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_BOOLEAN.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_BOXED" c:identifier="G_IS_PARAM_SPEC_BOXED" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_BOXED.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_CHAR" c:identifier="G_IS_PARAM_SPEC_CHAR" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_CHAR.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_CLASS" c:identifier="G_IS_PARAM_SPEC_CLASS" introspectable="0">
      <doc xml:space="preserve">Checks whether @pclass "is a" valid #GParamSpecClass structure of type
%G_TYPE_PARAM or derived.</doc>
      <parameters>
        <parameter name="pclass">
          <doc xml:space="preserve">a #GParamSpecClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_DOUBLE" c:identifier="G_IS_PARAM_SPEC_DOUBLE" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_DOUBLE.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_ENUM" c:identifier="G_IS_PARAM_SPEC_ENUM" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_ENUM.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_FLAGS" c:identifier="G_IS_PARAM_SPEC_FLAGS" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_FLAGS.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_FLOAT" c:identifier="G_IS_PARAM_SPEC_FLOAT" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_FLOAT.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_GTYPE" c:identifier="G_IS_PARAM_SPEC_GTYPE" version="2.10" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_GTYPE.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_INT" c:identifier="G_IS_PARAM_SPEC_INT" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_INT.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_INT64" c:identifier="G_IS_PARAM_SPEC_INT64" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_INT64.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_LONG" c:identifier="G_IS_PARAM_SPEC_LONG" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_LONG.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_OBJECT" c:identifier="G_IS_PARAM_SPEC_OBJECT" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_OBJECT.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_OVERRIDE" c:identifier="G_IS_PARAM_SPEC_OVERRIDE" version="2.4" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_OVERRIDE.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_PARAM" c:identifier="G_IS_PARAM_SPEC_PARAM" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_PARAM.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_POINTER" c:identifier="G_IS_PARAM_SPEC_POINTER" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_POINTER.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_STRING" c:identifier="G_IS_PARAM_SPEC_STRING" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_STRING.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_UCHAR" c:identifier="G_IS_PARAM_SPEC_UCHAR" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_UCHAR.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_UINT" c:identifier="G_IS_PARAM_SPEC_UINT" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_UINT.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_UINT64" c:identifier="G_IS_PARAM_SPEC_UINT64" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_UINT64.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_ULONG" c:identifier="G_IS_PARAM_SPEC_ULONG" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_ULONG.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_UNICHAR" c:identifier="G_IS_PARAM_SPEC_UNICHAR" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_UNICHAR.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_VALUE_ARRAY" c:identifier="G_IS_PARAM_SPEC_VALUE_ARRAY" introspectable="0" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_VALUE_ARRAY.</doc>
      <doc-deprecated xml:space="preserve">Use #GArray instead of #GValueArray</doc-deprecated>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_VARIANT" c:identifier="G_IS_PARAM_SPEC_VARIANT" version="2.26" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GParamSpec is of type %G_TYPE_PARAM_VARIANT.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SIGNAL_GROUP" c:identifier="G_IS_SIGNAL_GROUP" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TYPE_MODULE" c:identifier="G_IS_TYPE_MODULE" introspectable="0">
      <parameters>
        <parameter name="module">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TYPE_MODULE_CLASS" c:identifier="G_IS_TYPE_MODULE_CLASS" introspectable="0">
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TYPE_PLUGIN" c:identifier="G_IS_TYPE_PLUGIN" introspectable="0">
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TYPE_PLUGIN_CLASS" c:identifier="G_IS_TYPE_PLUGIN_CLASS" introspectable="0">
      <parameters>
        <parameter name="vtable">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_VALUE" c:identifier="G_IS_VALUE" introspectable="0">
      <doc xml:space="preserve">Checks if @value is a valid and initialized #GValue structure.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">A #GValue structure.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <class name="InitiallyUnowned" c:symbol-prefix="initially_unowned" c:type="GInitiallyUnowned" parent="Object" glib:type-name="GInitiallyUnowned" glib:get-type="g_initially_unowned_get_type" glib:type-struct="InitiallyUnownedClass">
      <doc xml:space="preserve">A type for objects that have an initially floating reference.

All the fields in the `GInitiallyUnowned` structure are private to the
implementation and should never be accessed directly.</doc>
      <field name="g_type_instance">
        <type name="TypeInstance" c:type="GTypeInstance"/>
      </field>
      <field name="ref_count" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="qdata" readable="0" private="1">
        <type name="GLib.Data" c:type="GData*"/>
      </field>
    </class>
    <record name="InitiallyUnownedClass" c:type="GInitiallyUnownedClass" glib:is-gtype-struct-for="InitiallyUnowned">
      <doc xml:space="preserve">The class structure for the GInitiallyUnowned type.</doc>
      <field name="g_type_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="construct_properties" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="constructor" introspectable="0">
        <doc xml:space="preserve">the @constructor function is called by g_object_new () to
 complete the object initialization after all the construction properties are
 set. The first thing a @constructor implementation must do is chain up to the
 @constructor of the parent class. Overriding @constructor should be rarely
 needed, e.g. to handle construct properties, or to implement singletons.</doc>
        <callback name="constructor" introspectable="0">
          <return-value>
            <type name="Object" c:type="GObject*"/>
          </return-value>
          <parameters>
            <parameter name="type" transfer-ownership="none">
              <type name="GType" c:type="GType"/>
            </parameter>
            <parameter name="n_construct_properties" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="construct_properties" transfer-ownership="none">
              <type name="ObjectConstructParam" c:type="GObjectConstructParam*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_property">
        <doc xml:space="preserve">the generic setter for all properties of this type. Should be
 overridden for every type with properties. If implementations of
 @set_property don't emit property change notification explicitly, this will
 be done implicitly by the type system. However, if the notify signal is
 emitted explicitly, the type system will not emit it a second time.</doc>
        <callback name="set_property">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="property_id" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="const GValue*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_property">
        <doc xml:space="preserve">the generic getter for all properties of this type. Should be
 overridden for every type with properties.</doc>
        <callback name="get_property">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="property_id" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dispose">
        <doc xml:space="preserve">the @dispose function is supposed to drop all references to other
 objects, but keep the instance otherwise intact, so that client method
 invocations still work. It may be run multiple times (due to reference
 loops). Before returning, @dispose should chain up to the @dispose method
 of the parent class.</doc>
        <callback name="dispose">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finalize">
        <doc xml:space="preserve">instance finalization function, should finish the finalization of
 the instance begun in @dispose and chain up to the @finalize method of the
 parent class.</doc>
        <callback name="finalize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dispatch_properties_changed">
        <doc xml:space="preserve">emits property change notification for a bunch
 of properties. Overriding @dispatch_properties_changed should be rarely
 needed.</doc>
        <callback name="dispatch_properties_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="n_pspecs" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="pspecs" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="notify">
        <doc xml:space="preserve">the class closure for the notify signal</doc>
        <callback name="notify">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">a #GObject</doc>
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="constructed">
        <doc xml:space="preserve">the @constructed function is called by g_object_new() as the
 final step of the object creation process.  At the point of the call, all
 construction properties have been set on the object.  The purpose of this
 call is to allow for object initialisation steps that can only be performed
 after construction properties have been set.  @constructed implementors
 should chain up to the @constructed call of their parent class to allow it
 to complete its initialisation.</doc>
        <callback name="constructed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flags" readable="0" private="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="n_construct_properties" readable="0" private="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="pspecs" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="n_pspecs" readable="0" private="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="pdummy" readable="0" private="1">
        <array zero-terminated="0" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="InstanceInitFunc" c:type="GInstanceInitFunc">
      <doc xml:space="preserve">A callback function used by the type system to initialize a new
instance of a type.

This function initializes all instance members and allocates any resources
required by it.

Initialization of a derived instance involves calling all its parent
types instance initializers, so the class member of the instance
is altered during its initialization to always point to the class that
belongs to the type the current initializer was introduced for.

The extended members of @instance are guaranteed to have been filled with
zeros before this function is called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">The instance to initialize</doc>
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:space="preserve">The class of the type the instance is
   created for</doc>
          <type name="TypeClass" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="InterfaceFinalizeFunc" c:type="GInterfaceFinalizeFunc">
      <doc xml:space="preserve">A callback function used by the type system to finalize an interface.

This function should destroy any internal data and release any resources
allocated by the corresponding GInterfaceInitFunc() function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:space="preserve">The interface structure to finalize</doc>
          <type name="TypeInterface" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The @interface_data supplied via the #GInterfaceInfo structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="InterfaceInfo" c:type="GInterfaceInfo">
      <doc xml:space="preserve">A structure that provides information to the type system which is
used specifically for managing interface types.</doc>
      <field name="interface_init" writable="1">
        <doc xml:space="preserve">location of the interface initialization function</doc>
        <type name="InterfaceInitFunc" c:type="GInterfaceInitFunc"/>
      </field>
      <field name="interface_finalize" writable="1">
        <doc xml:space="preserve">location of the interface finalization function</doc>
        <type name="InterfaceFinalizeFunc" c:type="GInterfaceFinalizeFunc"/>
      </field>
      <field name="interface_data" writable="1">
        <doc xml:space="preserve">user-supplied data passed to the interface init/finalize functions</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <callback name="InterfaceInitFunc" c:type="GInterfaceInitFunc">
      <doc xml:space="preserve">A callback function used by the type system to initialize a new
interface.

This function should initialize all internal data and* allocate any
resources required by the interface.

The members of @iface_data are guaranteed to have been filled with
zeros before this function is called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:space="preserve">The interface structure to initialize</doc>
          <type name="TypeInterface" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The @interface_data supplied via the #GInterfaceInfo structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="KeyFile" c:symbol-prefix="key_file" glib:type-name="GKeyFile" glib:get-type="g_key_file_get_type">
    </glib:boxed>
    <glib:boxed glib:name="MainContext" c:symbol-prefix="main_context" glib:type-name="GMainContext" glib:get-type="g_main_context_get_type">
    </glib:boxed>
    <glib:boxed glib:name="MainLoop" c:symbol-prefix="main_loop" glib:type-name="GMainLoop" glib:get-type="g_main_loop_get_type">
    </glib:boxed>
    <glib:boxed glib:name="MappedFile" c:symbol-prefix="mapped_file" glib:type-name="GMappedFile" glib:get-type="g_mapped_file_get_type">
    </glib:boxed>
    <glib:boxed glib:name="MarkupParseContext" c:symbol-prefix="markup_parse_context" glib:type-name="GMarkupParseContext" glib:get-type="g_markup_parse_context_get_type">
    </glib:boxed>
    <glib:boxed glib:name="MatchInfo" c:symbol-prefix="match_info" glib:type-name="GMatchInfo" glib:get-type="g_match_info_get_type">
    </glib:boxed>
    <function-macro name="OBJECT" c:identifier="G_OBJECT" introspectable="0">
      <doc xml:space="preserve">Casts a #GObject or derived pointer into a (GObject*) pointer.

Depending on the current debugging level, this function may invoke
certain runtime checks to identify invalid casts.</doc>
      <parameters>
        <parameter name="object">
          <doc xml:space="preserve">Object which is subject to casting.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_CLASS" c:identifier="G_OBJECT_CLASS" introspectable="0">
      <doc xml:space="preserve">Casts a derived #GObjectClass structure into a #GObjectClass structure.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a valid #GObjectClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_CLASS_NAME" c:identifier="G_OBJECT_CLASS_NAME" introspectable="0">
      <doc xml:space="preserve">Return the name of a class structure's type.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a valid #GObjectClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_CLASS_TYPE" c:identifier="G_OBJECT_CLASS_TYPE" introspectable="0">
      <doc xml:space="preserve">Get the type id of a class structure.</doc>
      <parameters>
        <parameter name="class">
          <doc xml:space="preserve">a valid #GObjectClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_GET_CLASS" c:identifier="G_OBJECT_GET_CLASS" introspectable="0">
      <doc xml:space="preserve">Get the class structure associated to a #GObject instance.</doc>
      <parameters>
        <parameter name="object">
          <doc xml:space="preserve">a #GObject instance.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_TYPE" c:identifier="G_OBJECT_TYPE" introspectable="0">
      <doc xml:space="preserve">Get the type id of an object.</doc>
      <parameters>
        <parameter name="object">
          <doc xml:space="preserve">Object to return the type id for.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_TYPE_NAME" c:identifier="G_OBJECT_TYPE_NAME" introspectable="0">
      <doc xml:space="preserve">Get the name of an object's type.</doc>
      <parameters>
        <parameter name="object">
          <doc xml:space="preserve">Object to return the type name for.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_WARN_INVALID_PROPERTY_ID" c:identifier="G_OBJECT_WARN_INVALID_PROPERTY_ID" introspectable="0">
      <doc xml:space="preserve">This macro should be used to emit a standard warning about unexpected
properties in set_property() and get_property() implementations.</doc>
      <parameters>
        <parameter name="object">
          <doc xml:space="preserve">the #GObject on which set_property() or get_property() was called</doc>
        </parameter>
        <parameter name="property_id">
          <doc xml:space="preserve">the numeric id of the property</doc>
        </parameter>
        <parameter name="pspec">
          <doc xml:space="preserve">the #GParamSpec of the property</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT_WARN_INVALID_PSPEC" c:identifier="G_OBJECT_WARN_INVALID_PSPEC" introspectable="0">
      <parameters>
        <parameter name="object">
        </parameter>
        <parameter name="pname">
        </parameter>
        <parameter name="property_id">
        </parameter>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Object" c:symbol-prefix="object" c:type="GObject" glib:type-name="GObject" glib:get-type="g_object_get_type" glib:type-struct="ObjectClass">
      <doc xml:space="preserve">The base object type.

`GObject` is the fundamental type providing the common attributes and
methods for all object types in GTK, Pango and other libraries
based on GObject. The `GObject` class provides methods for object
construction and destruction, property access methods, and signal
support. Signals are described in detail [here][gobject-Signals].

For a tutorial on implementing a new `GObject` class, see [How to define and
implement a new GObject](tutorial.html#how-to-define-and-implement-a-new-gobject).
For a list of naming conventions for GObjects and their methods, see the
[GType conventions](concepts.html#conventions). For the high-level concepts
behind GObject, read
[Instantiatable classed types: Objects](concepts.html#instantiatable-classed-types-objects).

Since GLib 2.72, all `GObject`s are guaranteed to be aligned to at least the
alignment of the largest basic GLib type (typically this is `guint64` or
`gdouble`). If you need larger alignment for an element in a `GObject`, you
should allocate it on the heap (aligned), or arrange for your `GObject` to be
appropriately padded. This guarantee applies to the `GObject` (or derived)
struct, the `GObjectClass` (or derived) struct, and any private data allocated
by `G_ADD_PRIVATE()`.</doc>
      <constructor name="new" c:identifier="g_object_new" introspectable="0">
        <doc xml:space="preserve">Creates a new instance of a #GObject subtype and sets its properties.

Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
which are not explicitly specified are set to their default values. Any
private data for the object is guaranteed to be initialized with zeros, as
per g_type_create_instance().

Note that in C, small integer types in variable argument lists are promoted
up to `gint` or `guint` as appropriate, and read back accordingly. `gint` is
32 bits on every platform on which GLib is currently supported. This means that
you can use C expressions of type `gint` with g_object_new() and properties of
type `gint` or `guint` or smaller. Specifically, you can use integer literals
with these property types.

When using property types of `gint64` or `guint64`, you must ensure that the
value that you provide is 64 bit. This means that you should use a cast or
make use of the %G_GINT64_CONSTANT or %G_GUINT64_CONSTANT macros.

Similarly, `gfloat` is promoted to `gdouble`, so you must ensure that the value
you provide is a `gdouble`, even for a property of type `gfloat`.

Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the
alignment of the largest basic GLib type (typically this is `guint64` or
`gdouble`). If you need larger alignment for an element in a #GObject, you
should allocate it on the heap (aligned), or arrange for your #GObject to be
appropriately padded.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new instance of
  @object_type</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">the type id of the #GObject subtype to instantiate</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the first property</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the value of the first property, followed optionally by more
  name/value pairs, followed by %NULL</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_valist" c:identifier="g_object_new_valist" introspectable="0">
        <doc xml:space="preserve">Creates a new instance of a #GObject subtype and sets its properties.

Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
which are not explicitly specified are set to their default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new instance of @object_type</doc>
          <type name="Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">the type id of the #GObject subtype to instantiate</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the first property</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">the value of the first property, followed optionally by more
 name/value pairs, followed by %NULL</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_properties" c:identifier="g_object_new_with_properties" version="2.54" introspectable="0">
        <doc xml:space="preserve">Creates a new instance of a #GObject subtype and sets its properties using
the provided arrays. Both arrays must have exactly @n_properties elements,
and the names and values correspond by index.

Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
which are not explicitly specified are set to their default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new instance of
@object_type</doc>
          <type name="Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">the object type to instantiate</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_properties" transfer-ownership="none">
            <doc xml:space="preserve">the number of properties</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="names" transfer-ownership="none">
            <doc xml:space="preserve">the names of each property to be set</doc>
            <array length="1" zero-terminated="0" c:type="const char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:space="preserve">the values of each property to be set</doc>
            <array length="1" zero-terminated="0" c:type="const GValue*">
              <type name="Value" c:type="GValue"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="newv" c:identifier="g_object_newv" deprecated="1" deprecated-version="2.54">
        <doc xml:space="preserve">Creates a new instance of a #GObject subtype and sets its properties.

Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
which are not explicitly specified are set to their default values.</doc>
        <doc-deprecated xml:space="preserve">Use g_object_new_with_properties() instead.
deprecated. See #GParameter for more information.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new instance of
@object_type</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:space="preserve">the type id of the #GObject subtype to instantiate</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @parameters array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GParameter</doc>
            <array length="1" zero-terminated="0" c:type="GParameter*">
              <type name="Parameter" c:type="GParameter"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <function name="compat_control" c:identifier="g_object_compat_control">
        <return-value transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="what" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="interface_find_property" c:identifier="g_object_interface_find_property" version="2.4">
        <doc xml:space="preserve">Find the #GParamSpec with the given name for an
interface. Generally, the interface vtable passed in as @g_iface
will be the default vtable from g_type_default_interface_ref(), or,
if you know the interface has already been loaded,
g_type_default_interface_peek().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GParamSpec for the property of the
         interface with the name @property_name, or %NULL if no
         such property exists.</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:space="preserve">any interface vtable for the
 interface, or the default vtable for the interface</doc>
            <type name="TypeInterface" c:type="gpointer"/>
          </parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">name of a property to look up.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="interface_install_property" c:identifier="g_object_interface_install_property" version="2.4">
        <doc xml:space="preserve">Add a property to an interface; this is only useful for interfaces
that are added to GObject-derived types. Adding a property to an
interface forces all objects classes with that interface to have a
compatible property. The compatible property could be a newly
created #GParamSpec, but normally
g_object_class_override_property() will be used so that the object
class only needs to provide an implementation and inherits the
property description, default value, bounds, and so forth from the
interface property.

This function is meant to be called from the interface's default
vtable initialization function (the @class_init member of
#GTypeInfo.) It must not be called after after @class_init has
been called for any object types implementing this interface.

If @pspec is a floating reference, it will be consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:space="preserve">any interface vtable for the
   interface, or the default
 vtable for the interface.</doc>
            <type name="TypeInterface" c:type="gpointer"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="interface_list_properties" c:identifier="g_object_interface_list_properties" version="2.4">
        <doc xml:space="preserve">Lists the properties of an interface.Generally, the interface
vtable passed in as @g_iface will be the default vtable from
g_type_default_interface_ref(), or, if you know the interface has
already been loaded, g_type_default_interface_peek().</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a
  pointer to an array of pointers to #GParamSpec
  structures. The paramspecs are owned by GLib, but the
  array should be freed with g_free() when you are done with
  it.</doc>
          <array length="1" zero-terminated="0" c:type="GParamSpec**">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:space="preserve">any interface vtable for the
 interface, or the default vtable for the interface</doc>
            <type name="TypeInterface" c:type="gpointer"/>
          </parameter>
          <parameter name="n_properties_p" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store number of properties returned.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="constructed">
        <doc xml:space="preserve">the @constructed function is called by g_object_new() as the
 final step of the object creation process.  At the point of the call, all
 construction properties have been set on the object.  The purpose of this
 call is to allow for object initialisation steps that can only be performed
 after construction properties have been set.  @constructed implementors
 should chain up to the @constructed call of their parent class to allow it
 to complete its initialisation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dispatch_properties_changed">
        <doc xml:space="preserve">emits property change notification for a bunch
 of properties. Overriding @dispatch_properties_changed should be rarely
 needed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="n_pspecs" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="pspecs" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dispose">
        <doc xml:space="preserve">the @dispose function is supposed to drop all references to other
 objects, but keep the instance otherwise intact, so that client method
 invocations still work. It may be run multiple times (due to reference
 loops). Before returning, @dispose should chain up to the @dispose method
 of the parent class.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="finalize">
        <doc xml:space="preserve">instance finalization function, should finish the finalization of
 the instance begun in @dispose and chain up to the @finalize method of the
 parent class.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_property">
        <doc xml:space="preserve">the generic getter for all properties of this type. Should be
 overridden for every type with properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="notify" invoker="notify">
        <doc xml:space="preserve">Emits a "notify" signal for the property @property_name on @object.

When possible, eg. when signaling a property change from within the class
that registered the property, you should use g_object_notify_by_pspec()
instead.

Note that emission of the notify signal may be blocked with
g_object_freeze_notify(). In this case, the signal emissions are queued
and will be emitted (in reverse order) when g_object_thaw_notify() is
called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_property">
        <doc xml:space="preserve">the generic setter for all properties of this type. Should be
 overridden for every type with properties. If implementations of
 @set_property don't emit property change notification explicitly, this will
 be done implicitly by the type system. However, if the notify signal is
 emitted explicitly, the type system will not emit it a second time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_toggle_ref" c:identifier="g_object_add_toggle_ref" version="2.8" introspectable="0">
        <doc xml:space="preserve">Increases the reference count of the object by one and sets a
callback to be called when all other references to the object are
dropped, or when this is already the last reference to the object
and another reference is established.

This functionality is intended for binding @object to a proxy
object managed by another memory manager. This is done with two
paired references: the strong reference added by
g_object_add_toggle_ref() and a reverse reference to the proxy
object which is either a strong reference or weak reference.

The setup is that when there are no other references to @object,
only a weak reference is held in the reverse direction from @object
to the proxy object, but when there are other references held to
@object, a strong reference is held. The @notify callback is called
when the reference from @object to the proxy object should be
"toggled" from strong to weak (@is_last_ref true) or weak to strong
(@is_last_ref false).

Since a (normal) reference must be held to the object before
calling g_object_add_toggle_ref(), the initial state of the reverse
link is always strong.

Multiple toggle references may be added to the same gobject,
however if there are multiple toggle references to an object, none
of them will ever be notified until all but one are removed.  For
this reason, you should only ever use a toggle reference if there
is important state in the proxy object.

Note that if you unref the object on another thread, then @notify might
still be invoked after g_object_remove_toggle_ref(), and the object argument
might be a dangling pointer. If the object is destroyed on other threads,
you must take care of that yourself.

A g_object_add_toggle_ref() must be released with g_object_remove_toggle_ref().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="notify" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">a function to call when this reference is the
 last reference to the object, or is no longer
 the last reference.</doc>
            <type name="ToggleNotify" c:type="GToggleNotify"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_weak_pointer" c:identifier="g_object_add_weak_pointer" introspectable="0">
        <doc xml:space="preserve">Adds a weak reference from weak_pointer to @object to indicate that
the pointer located at @weak_pointer_location is only valid during
the lifetime of @object. When the @object is finalized,
@weak_pointer will be set to %NULL.

Note that as with g_object_weak_ref(), the weak references created by
this method are not thread-safe: they cannot safely be used in one
thread if the object's last g_object_unref() might happen in another
thread. Use #GWeakRef if thread-safety is required.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The object that should be weak referenced.</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="weak_pointer_location" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The memory address
   of a pointer.</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_property" c:identifier="g_object_bind_property" version="2.26">
        <doc xml:space="preserve">Creates a binding between @source_property on @source and @target_property
on @target.

Whenever the @source_property is changed the @target_property is
updated using the same value. For instance:

|[&lt;!-- language="C" --&gt;
  g_object_bind_property (action, "active", widget, "sensitive", 0);
]|

Will result in the "sensitive" property of the widget #GObject instance to be
updated with the same value of the "active" property of the action #GObject
instance.

If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
if @target_property on @target changes then the @source_property on @source
will be updated as well.

The binding will automatically be removed when either the @source or the
@target instances are finalized. To remove the binding without affecting the
@source and the @target you can just call g_object_unref() on the returned
#GBinding instance.

Removing the binding by calling g_object_unref() on it must only be done if
the binding, @source and @target are only used from a single thread and it
is clear that both @source and @target outlive the binding. Especially it
is not safe to rely on this if the binding, @source or @target can be
finalized from different threads. Keep another reference to the binding and
use g_binding_unbind() instead to be on the safe side.

A #GObject can have multiple bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GBinding instance representing the
    binding between the two #GObject instances. The binding is released
    whenever the #GBinding reference count reaches zero.</doc>
          <type name="Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the source #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
          <parameter name="source_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the target #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_property_full" c:identifier="g_object_bind_property_full" shadowed-by="bind_property_with_closures" version="2.26">
        <doc xml:space="preserve">Complete version of g_object_bind_property().

Creates a binding between @source_property on @source and @target_property
on @target, allowing you to set the transformation functions to be used by
the binding.

If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
if @target_property on @target changes then the @source_property on @source
will be updated as well. The @transform_from function is only used in case
of bidirectional bindings, otherwise it will be ignored

The binding will automatically be removed when either the @source or the
@target instances are finalized. This will release the reference that is
being held on the #GBinding instance; if you want to hold on to the
#GBinding instance, you will need to hold a reference to it.

To remove the binding, call g_binding_unbind().

A #GObject can have multiple bindings.

The same @user_data parameter will be used for both @transform_to
and @transform_from transformation functions; the @notify function will
be called once, when the binding is removed. If you need different data
for each transformation function, please use
g_object_bind_property_with_closures() instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GBinding instance representing the
    binding between the two #GObject instances. The binding is released
    whenever the #GBinding reference count reaches zero.</doc>
          <type name="Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the source #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
          <parameter name="source_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the target #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags"/>
          </parameter>
          <parameter name="transform_to" transfer-ownership="none" nullable="1" allow-none="1" scope="notified">
            <doc xml:space="preserve">the transformation function
    from the @source to the @target, or %NULL to use the default</doc>
            <type name="BindingTransformFunc" c:type="GBindingTransformFunc"/>
          </parameter>
          <parameter name="transform_from" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="6" destroy="7">
            <doc xml:space="preserve">the transformation function
    from the @target to the @source, or %NULL to use the default</doc>
            <type name="BindingTransformFunc" c:type="GBindingTransformFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">custom data to be passed to the transformation functions,
    or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a function to call when disposing the binding, to free
    resources used by the transformation functions, or %NULL if not required</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_property_with_closures" c:identifier="g_object_bind_property_with_closures" shadows="bind_property_full" version="2.26">
        <doc xml:space="preserve">Creates a binding between @source_property on @source and @target_property
on @target, allowing you to set the transformation functions to be used by
the binding.

This function is the language bindings friendly version of
g_object_bind_property_full(), using #GClosures instead of
function pointers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GBinding instance representing the
    binding between the two #GObject instances. The binding is released
    whenever the #GBinding reference count reaches zero.</doc>
          <type name="Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the source #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
          <parameter name="source_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:space="preserve">the target #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:space="preserve">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags"/>
          </parameter>
          <parameter name="transform_to" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosure wrapping the transformation function
    from the @source to the @target, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="transform_from" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosure wrapping the transformation function
    from the @target to the @source, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect" c:identifier="g_object_connect" introspectable="0">
        <doc xml:space="preserve">A convenience function to connect multiple signals at once.

The signal specs expected by this function have the form
`modifier::signal_name`, where `modifier` can be one of the
following:

- `signal`: equivalent to `g_signal_connect_data (..., NULL, G_CONNECT_DEFAULT)`
- `object-signal`, `object_signal`: equivalent to `g_signal_connect_object (..., G_CONNECT_DEFAULT)`
- `swapped-signal`, `swapped_signal`: equivalent to `g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED)`
- `swapped_object_signal`, `swapped-object-signal`: equivalent to `g_signal_connect_object (..., G_CONNECT_SWAPPED)`
- `signal_after`, `signal-after`: equivalent to `g_signal_connect_data (..., NULL, G_CONNECT_AFTER)`
- `object_signal_after`, `object-signal-after`: equivalent to `g_signal_connect_object (..., G_CONNECT_AFTER)`
- `swapped_signal_after`, `swapped-signal-after`: equivalent to `g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED | G_CONNECT_AFTER)`
- `swapped_object_signal_after`, `swapped-object-signal-after`: equivalent to `g_signal_connect_object (..., G_CONNECT_SWAPPED | G_CONNECT_AFTER)`

```c
menu-&gt;toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,
                                                 "type", GTK_WINDOW_POPUP,
                                                 "child", menu,
                                                 NULL),
                                   "signal::event", gtk_menu_window_event, menu,
                                   "signal::size_request", gtk_menu_window_size_request, menu,
                                   "signal::destroy", gtk_widget_destroyed, &amp;menu-&gt;toplevel,
                                   NULL);
```</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the object</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
          <parameter name="signal_spec" transfer-ownership="none">
            <doc xml:space="preserve">the spec for the first signal</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">[type@GObject.Callback] for the first signal, followed by data for the
  first signal, followed optionally by more signal
  spec/callback/data triples, followed by `NULL`</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" c:identifier="g_object_disconnect" introspectable="0">
        <doc xml:space="preserve">A convenience function to disconnect multiple signals at once.

The signal specs expected by this function have the form
"any_signal", which means to disconnect any signal with matching
callback and data, or "any_signal::signal_name", which only
disconnects the signal named "signal_name".</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
          <parameter name="signal_spec" transfer-ownership="none">
            <doc xml:space="preserve">the spec for the first signal</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">#GCallback for the first signal, followed by data for the first signal,
 followed optionally by more signal spec/callback/data triples,
 followed by %NULL</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_data" c:identifier="g_object_dup_data" version="2.34" introspectable="0">
        <doc xml:space="preserve">This is a variant of g_object_get_data() which returns
a 'duplicate' of the value. @dup_func defines the
meaning of 'duplicate' in this context, it could e.g.
take a reference on a ref-counted object.

If the @key is not set on the object then @dup_func
will be called with a %NULL argument.

Note that @dup_func is called while user data of @object
is locked.

This function can be useful to avoid races when multiple
threads are using object data on the same key on the same
object.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the result of calling @dup_func on the value
    associated with @key on @object, or %NULL if not set.
    If @dup_func is %NULL, the value is returned
    unmodified.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the #GObject to store user data on</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a string, naming the user data pointer</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dup_func" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
            <doc xml:space="preserve">function to dup the value</doc>
            <type name="GLib.DuplicateFunc" c:type="GDuplicateFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">passed as user_data to @dup_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_qdata" c:identifier="g_object_dup_qdata" version="2.34" introspectable="0">
        <doc xml:space="preserve">This is a variant of g_object_get_qdata() which returns
a 'duplicate' of the value. @dup_func defines the
meaning of 'duplicate' in this context, it could e.g.
take a reference on a ref-counted object.

If the @quark is not set on the object then @dup_func
will be called with a %NULL argument.

Note that @dup_func is called while user data of @object
is locked.

This function can be useful to avoid races when multiple
threads are using object data on the same key on the same
object.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the result of calling @dup_func on the value
    associated with @quark on @object, or %NULL if not set.
    If @dup_func is %NULL, the value is returned
    unmodified.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the #GObject to store user data on</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:space="preserve">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="dup_func" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
            <doc xml:space="preserve">function to dup the value</doc>
            <type name="GLib.DuplicateFunc" c:type="GDuplicateFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">passed as user_data to @dup_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="force_floating" c:identifier="g_object_force_floating" version="2.10">
        <doc xml:space="preserve">This function is intended for #GObject implementations to re-enforce
a [floating][floating-ref] object reference. Doing this is seldom
required: all #GInitiallyUnowneds are created with a floating reference
which usually just needs to be sunken by calling g_object_ref_sink().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="freeze_notify" c:identifier="g_object_freeze_notify">
        <doc xml:space="preserve">Increases the freeze count on @object. If the freeze count is
non-zero, the emission of "notify" signals on @object is
stopped. The signals are queued until the freeze count is decreased
to zero. Duplicate notifications are squashed so that at most one
#GObject::notify signal is emitted for each property modified while the
object is frozen.

This is necessary for accessors that modify multiple properties to prevent
premature notification while the object is still being modified.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="g_object_get" introspectable="0">
        <doc xml:space="preserve">Gets properties of an object.

In general, a copy is made of the property contents and the caller
is responsible for freeing the memory in the appropriate manner for
the type, for instance by calling g_free() or g_object_unref().

Here is an example of using g_object_get() to get the contents
of three properties: an integer, a string and an object:
|[&lt;!-- language="C" --&gt;
 gint intval;
 guint64 uint64val;
 gchar *strval;
 GObject *objval;

 g_object_get (my_object,
               "int-property", &amp;intval,
               "uint64-property", &amp;uint64val,
               "str-property", &amp;strval,
               "obj-property", &amp;objval,
               NULL);

 // Do something with intval, uint64val, strval, objval

 g_free (strval);
 g_object_unref (objval);
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the first property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">return location for the first property, followed optionally by more
 name/return location pairs, followed by %NULL</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="g_object_get_data">
        <doc xml:space="preserve">Gets a named field from the objects table of associations (see g_object_set_data()).</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the data if found,
         or %NULL if no such data exists.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">#GObject containing the associations</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">name of the key for that association</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_property" c:identifier="g_object_get_property">
        <doc xml:space="preserve">Gets a property of an object.

The @value can be:

 - an empty #GValue initialized by %G_VALUE_INIT, which will be
   automatically initialized with the expected type of the property
   (since GLib 2.60)
 - a #GValue initialized with the expected type of the property
 - a #GValue initialized with a type to which the expected type
   of the property can be transformed

In general, a copy is made of the property contents and the caller is
responsible for freeing the memory by calling g_value_unset().

Note that g_object_get_property() is really intended for language
bindings, g_object_get() is much more convenient for C programming.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">return location for the property value</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_qdata" c:identifier="g_object_get_qdata">
        <doc xml:space="preserve">This function gets back user data pointers stored via
g_object_set_qdata().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The GObject to get a stored user data pointer from</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:space="preserve">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valist" c:identifier="g_object_get_valist" introspectable="0">
        <doc xml:space="preserve">Gets properties of an object.

In general, a copy is made of the property contents and the caller
is responsible for freeing the memory in the appropriate manner for
the type, for instance by calling g_free() or g_object_unref().

See g_object_get().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the first property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">return location for the first property, followed optionally by more
 name/return location pairs, followed by %NULL</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="getv" c:identifier="g_object_getv" version="2.54">
        <doc xml:space="preserve">Gets @n_properties properties for an @object.
Obtained properties will be set to @values. All properties must be valid.
Warnings will be emitted and undefined behaviour may result if invalid
properties are passed in.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="n_properties" transfer-ownership="none">
            <doc xml:space="preserve">the number of properties</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="names" transfer-ownership="none">
            <doc xml:space="preserve">the names of each property to get</doc>
            <array length="0" zero-terminated="0" c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:space="preserve">the values of each property to get</doc>
            <array length="0" zero-terminated="0" c:type="GValue*">
              <type name="Value" c:type="GValue"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="is_floating" c:identifier="g_object_is_floating" version="2.10">
        <doc xml:space="preserve">Checks whether @object has a [floating][floating-ref] reference.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @object has a floating reference</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="notify" c:identifier="g_object_notify">
        <doc xml:space="preserve">Emits a "notify" signal for the property @property_name on @object.

When possible, eg. when signaling a property change from within the class
that registered the property, you should use g_object_notify_by_pspec()
instead.

Note that emission of the notify signal may be blocked with
g_object_freeze_notify(). In this case, the signal emissions are queued
and will be emitted (in reverse order) when g_object_thaw_notify() is
called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a property installed on the class of @object.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="notify_by_pspec" c:identifier="g_object_notify_by_pspec" version="2.26">
        <doc xml:space="preserve">Emits a "notify" signal for the property specified by @pspec on @object.

This function omits the property name lookup, hence it is faster than
g_object_notify().

One way to avoid using g_object_notify() from within the
class that registered the properties, and using g_object_notify_by_pspec()
instead, is to store the GParamSpec used with
g_object_class_install_property() inside a static array, e.g.:

|[&lt;!-- language="C" --&gt;
  typedef enum
  {
    PROP_FOO = 1,
    PROP_LAST
  } MyObjectProperty;

  static GParamSpec *properties[PROP_LAST];

  static void
  my_object_class_init (MyObjectClass *klass)
  {
    properties[PROP_FOO] = g_param_spec_int ("foo", NULL, NULL,
                                             0, 100,
                                             50,
                                             G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
    g_object_class_install_property (gobject_class,
                                     PROP_FOO,
                                     properties[PROP_FOO]);
  }
]|

and then notify a change on the "foo" property with:

|[&lt;!-- language="C" --&gt;
  g_object_notify_by_pspec (self, properties[PROP_FOO]);
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">the #GParamSpec of a property installed on the class of @object.</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_object_ref">
        <doc xml:space="preserve">Increases the reference count of @object.

Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
of @object will be propagated to the return type (using the GCC typeof()
extension), so any casting the caller needs to do on the return type must be
explicit.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the same @object</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref_sink" c:identifier="g_object_ref_sink" version="2.10">
        <doc xml:space="preserve">Increase the reference count of @object, and possibly remove the
[floating][floating-ref] reference, if @object has a floating reference.

In other words, if the object is floating, then this call "assumes
ownership" of the floating reference, converting it to a normal
reference by clearing the floating flag while leaving the reference
count unchanged.  If the object is not floating, then this call
adds a new normal reference increasing the reference count by one.

Since GLib 2.56, the type of @object will be propagated to the return type
under the same conditions as for g_object_ref().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@object</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_toggle_ref" c:identifier="g_object_remove_toggle_ref" version="2.8" introspectable="0">
        <doc xml:space="preserve">Removes a reference added with g_object_add_toggle_ref(). The
reference count of the object is decreased by one.

Note that if you unref the object on another thread, then @notify might
still be invoked after g_object_remove_toggle_ref(), and the object argument
might be a dangling pointer. If the object is destroyed on other threads,
you must take care of that yourself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="notify" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">a function to call when this reference is the
 last reference to the object, or is no longer
 the last reference.</doc>
            <type name="ToggleNotify" c:type="GToggleNotify"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @notify, or %NULL to
 match any toggle refs with the @notify argument.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_weak_pointer" c:identifier="g_object_remove_weak_pointer" introspectable="0">
        <doc xml:space="preserve">Removes a weak reference from @object that was previously added
using g_object_add_weak_pointer(). The @weak_pointer_location has
to match the one used with g_object_add_weak_pointer().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The object that is weak referenced.</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="weak_pointer_location" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The memory address
   of a pointer.</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_data" c:identifier="g_object_replace_data" version="2.34" introspectable="0">
        <doc xml:space="preserve">Compares the user data for the key @key on @object with
@oldval, and if they are the same, replaces @oldval with
@newval.

This is like a typical atomic compare-and-exchange
operation, for user data on an object.

If the previous value was replaced then ownership of the
old value (@oldval) is passed to the caller, including
the registered destroy notify for it (passed out in @old_destroy).
It&#x2019;s up to the caller to free this as needed, which may
or may not include using @old_destroy as sometimes replacement
should not destroy the object in the normal way.

See g_object_set_data() for guidance on using a small, bounded set of values
for @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the existing value for @key was replaced
 by @newval, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the #GObject to store user data on</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a string, naming the user data pointer</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="oldval" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the old value to compare against</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="newval" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the new value</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a destroy notify for the new value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="old_destroy" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1" scope="async">
            <doc xml:space="preserve">destroy notify for the existing value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_qdata" c:identifier="g_object_replace_qdata" version="2.34" introspectable="0">
        <doc xml:space="preserve">Compares the user data for the key @quark on @object with
@oldval, and if they are the same, replaces @oldval with
@newval.

This is like a typical atomic compare-and-exchange
operation, for user data on an object.

If the previous value was replaced then ownership of the
old value (@oldval) is passed to the caller, including
the registered destroy notify for it (passed out in @old_destroy).
It&#x2019;s up to the caller to free this as needed, which may
or may not include using @old_destroy as sometimes replacement
should not destroy the object in the normal way.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the existing value for @quark was replaced
 by @newval, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the #GObject to store user data on</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:space="preserve">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="oldval" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the old value to compare against</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="newval" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the new value</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">a destroy notify for the new value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="old_destroy" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1" scope="async">
            <doc xml:space="preserve">destroy notify for the existing value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run_dispose" c:identifier="g_object_run_dispose">
        <doc xml:space="preserve">Releases all references to other objects. This can be used to break
reference cycles.

This function should only be called from object system implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="g_object_set" introspectable="0">
        <doc xml:space="preserve">Sets properties on an object.

The same caveats about passing integer literals as varargs apply as with
g_object_new(). In particular, any integer literals set as the values for
properties of type #gint64 or #guint64 must be 64 bits wide, using the
%G_GINT64_CONSTANT or %G_GUINT64_CONSTANT macros.

Note that the "notify" signals are queued and only emitted (in
reverse order) after all properties have been set. See
g_object_freeze_notify().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the first property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">value for the first property, followed optionally by more
 name/value pairs, followed by %NULL</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data" c:identifier="g_object_set_data">
        <doc xml:space="preserve">Each object carries around a table of associations from
strings to pointers.  This function lets you set an association.

If the object already had an association with that name,
the old association will be destroyed.

Internally, the @key is converted to a #GQuark using g_quark_from_string().
This means a copy of @key is kept permanently (even after @object has been
finalized) &#x2014; so it is recommended to only use a small, bounded set of values
for @key in your program, to avoid the #GQuark storage growing unbounded.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">#GObject containing the associations.</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">name of the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to associate with that key</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data_full" c:identifier="g_object_set_data_full" introspectable="0">
        <doc xml:space="preserve">Like g_object_set_data() except it adds notification
for when the association is destroyed, either by setting it
to a different value or when the object is destroyed.

Note that the @destroy callback is not called if @data is %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">#GObject containing the associations</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">name of the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to associate with that key</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">function to call when the association is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_property" c:identifier="g_object_set_property">
        <doc xml:space="preserve">Sets a property on an object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qdata" c:identifier="g_object_set_qdata" introspectable="0">
        <doc xml:space="preserve">This sets an opaque, named pointer on an object.
The name is specified through a #GQuark (retrieved e.g. via
g_quark_from_static_string()), and the pointer
can be gotten back from the @object with g_object_get_qdata()
until the @object is finalized.
Setting a previously set user data pointer, overrides (frees)
the old pointer set, using #NULL as pointer essentially
removes the data stored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The GObject to set store a user data pointer</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:space="preserve">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">An opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qdata_full" c:identifier="g_object_set_qdata_full" introspectable="0">
        <doc xml:space="preserve">This function works like g_object_set_qdata(), but in addition,
a void (*destroy) (gpointer) function may be specified which is
called with @data as argument when the @object is finalized, or
the data is being overwritten by a call to g_object_set_qdata()
with the same @quark.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The GObject to set store a user data pointer</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:space="preserve">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">An opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">Function to invoke with @data as argument, when @data
          needs to be freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_valist" c:identifier="g_object_set_valist" introspectable="0">
        <doc xml:space="preserve">Sets properties on an object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the first property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">value for the first property, followed optionally by more
 name/value pairs, followed by %NULL</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="setv" c:identifier="g_object_setv" version="2.54" introspectable="0">
        <doc xml:space="preserve">Sets @n_properties properties for an @object.
Properties to be set will be taken from @values. All properties must be
valid. Warnings will be emitted and undefined behaviour may result if invalid
properties are passed in.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="n_properties" transfer-ownership="none">
            <doc xml:space="preserve">the number of properties</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="names" transfer-ownership="none">
            <doc xml:space="preserve">the names of each property to be set</doc>
            <array length="0" zero-terminated="0" c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:space="preserve">the values of each property to be set</doc>
            <array length="0" zero-terminated="0" c:type="const GValue*">
              <type name="Value" c:type="GValue"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="steal_data" c:identifier="g_object_steal_data">
        <doc xml:space="preserve">Remove a specified datum from the object's data associations,
without invoking the association's destroy handler.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the data if found, or %NULL
         if no such data exists.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">#GObject containing the associations</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">name of the key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_qdata" c:identifier="g_object_steal_qdata">
        <doc xml:space="preserve">This function gets back user data pointers stored via
g_object_set_qdata() and removes the @data from object
without invoking its destroy() function (if any was
set).
Usually, calling this function is only required to update
user data pointers with a destroy notifier, for example:
|[&lt;!-- language="C" --&gt;
void
object_add_to_user_list (GObject     *object,
                         const gchar *new_string)
{
  // the quark, naming the object data
  GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
  // retrieve the old string list
  GList *list = g_object_steal_qdata (object, quark_string_list);

  // prepend new string
  list = g_list_prepend (list, g_strdup (new_string));
  // this changed 'list', so we need to set it again
  g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
}
static void
free_string_list (gpointer data)
{
  GList *node, *list = data;

  for (node = list; node; node = node-&gt;next)
    g_free (node-&gt;data);
  g_list_free (list);
}
]|
Using g_object_get_qdata() in the above example, instead of
g_object_steal_qdata() would have left the destroy function set,
and thus the partial string list would have been freed upon
g_object_set_qdata_full().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The GObject to get a stored user data pointer from</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:space="preserve">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_ref" c:identifier="g_object_take_ref" version="2.70" introspectable="0">
        <doc xml:space="preserve">If @object is floating, sink it.  Otherwise, do nothing.

In other words, this function will convert a floating reference (if
present) into a full reference.

Typically you want to use g_object_ref_sink() in order to
automatically do the correct thing with respect to floating or
non-floating references, but there is one specific scenario where
this function is helpful.

The situation where this function is helpful is when creating an API
that allows the user to provide a callback function that returns a
GObject. We certainly want to allow the user the flexibility to
return a non-floating reference from this callback (for the case
where the object that is being returned already exists).

At the same time, the API style of some popular GObject-based
libraries (such as Gtk) make it likely that for newly-created GObject
instances, the user can be saved some typing if they are allowed to
return a floating reference.

Using this function on the return value of the user's callback allows
the user to do whichever is more convenient for them. The caller will
always receives exactly one full reference to the value: either the
one that was returned in the first place, or a floating reference
that has been converted to a full reference.

This function has an odd interaction when combined with
g_object_ref_sink() running at the same time in another thread on
the same #GObject instance. If g_object_ref_sink() runs first then
the result will be that the floating reference is converted to a hard
reference. If g_object_take_ref() runs first then the result will be
that the floating reference is converted to a hard reference and an
additional reference on top of that one is added. It is best to avoid
this situation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">@object</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="thaw_notify" c:identifier="g_object_thaw_notify">
        <doc xml:space="preserve">Reverts the effect of a previous call to
g_object_freeze_notify(). The freeze count is decreased on @object
and when it reaches zero, queued "notify" signals are emitted.

Duplicate notifications for each property are squashed so that at most one
#GObject::notify signal is emitted for each property, in the reverse order
in which they have been queued.

It is an error to call this function when the freeze count is zero.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_object_unref">
        <doc xml:space="preserve">Decreases the reference count of @object. When its reference count
drops to 0, the object is finalized (i.e. its memory is freed).

If the pointer to the #GObject may be reused in future (for example, if it is
an instance variable of another object), it is recommended to clear the
pointer to %NULL rather than retain a dangling pointer to a potentially
invalid #GObject instance. Use g_clear_object() for this.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="Object" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="watch_closure" c:identifier="g_object_watch_closure">
        <doc xml:space="preserve">This function essentially limits the life time of the @closure to
the life time of the object. That is, when the object is finalized,
the @closure is invalidated by calling g_closure_invalidate() on
it, in order to prevent invocations of the closure with a finalized
(nonexisting) object. Also, g_object_ref() and g_object_unref() are
added as marshal guards to the @closure, to ensure that an extra
reference count is held on @object during invocation of the
@closure.  Usually, this function will be called on closures that
use this @object as closure data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">#GObject restricting lifetime of @closure</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">#GClosure to watch</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="weak_ref" c:identifier="g_object_weak_ref" introspectable="0">
        <doc xml:space="preserve">Adds a weak reference callback to an object. Weak references are
used for notification when an object is disposed. They are called
"weak references" because they allow you to safely hold a pointer
to an object without calling g_object_ref() (g_object_ref() adds a
strong reference, that is, forces the object to stay alive).

Note that the weak references created by this method are not
thread-safe: they cannot safely be used in one thread if the
object's last g_object_unref() might happen in another thread.
Use #GWeakRef if thread-safety is required.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">#GObject to reference weakly</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="notify" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">callback to invoke before the object is freed</doc>
            <type name="WeakNotify" c:type="GWeakNotify"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">extra data to pass to notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="weak_unref" c:identifier="g_object_weak_unref" introspectable="0">
        <doc xml:space="preserve">Removes a weak reference callback to an object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">#GObject to remove a weak reference from</doc>
            <type name="Object" c:type="GObject*"/>
          </instance-parameter>
          <parameter name="notify" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">callback to search for</doc>
            <type name="WeakNotify" c:type="GWeakNotify"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to search for</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="g_type_instance">
        <type name="TypeInstance" c:type="GTypeInstance"/>
      </field>
      <field name="ref_count" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="qdata" readable="0" private="1">
        <type name="GLib.Data" c:type="GData*"/>
      </field>
      <glib:signal name="notify" when="first" no-recurse="1" detailed="1" action="1" no-hooks="1">
        <doc xml:space="preserve">The notify signal is emitted on an object when one of its properties has
its value set through g_object_set_property(), g_object_set(), et al.

Note that getting this signal doesn&#x2019;t itself guarantee that the value of
the property has actually changed. When it is emitted is determined by the
derived GObject class. If the implementor did not create the property with
%G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
in ::notify being emitted, even if the new value is the same as the old.
If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
and common practice is to do that only when the value has actually changed.

This signal is typically used to obtain change notification for a
single property, by specifying the property name as a detail in the
g_signal_connect() call, like this:

|[&lt;!-- language="C" --&gt;
g_signal_connect (text_view-&gt;buffer, "notify::paste-target-list",
                  G_CALLBACK (gtk_text_view_target_list_notify),
                  text_view)
]|

It is important to note that you must use
[canonical parameter names][class@GObject.ParamSpec#parameter-names] as
detail strings for the notify signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">the #GParamSpec of the property which changed.</doc>
            <type name="ParamSpec"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ObjectClass" c:type="GObjectClass" glib:is-gtype-struct-for="Object">
      <doc xml:space="preserve">The class structure for the GObject type.

|[&lt;!-- language="C" --&gt;
// Example of implementing a singleton using a constructor.
static MySingleton *the_singleton = NULL;

static GObject*
my_singleton_constructor (GType                  type,
                          guint                  n_construct_params,
                          GObjectConstructParam *construct_params)
{
  GObject *object;
  
  if (!the_singleton)
    {
      object = G_OBJECT_CLASS (parent_class)-&gt;constructor (type,
                                                           n_construct_params,
                                                           construct_params);
      the_singleton = MY_SINGLETON (object);
    }
  else
    object = g_object_ref (G_OBJECT (the_singleton));

  return object;
}
]|</doc>
      <field name="g_type_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="construct_properties" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="constructor" introspectable="0">
        <doc xml:space="preserve">the @constructor function is called by g_object_new () to
 complete the object initialization after all the construction properties are
 set. The first thing a @constructor implementation must do is chain up to the
 @constructor of the parent class. Overriding @constructor should be rarely
 needed, e.g. to handle construct properties, or to implement singletons.</doc>
        <callback name="constructor" introspectable="0">
          <return-value>
            <type name="Object" c:type="GObject*"/>
          </return-value>
          <parameters>
            <parameter name="type" transfer-ownership="none">
              <type name="GType" c:type="GType"/>
            </parameter>
            <parameter name="n_construct_properties" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="construct_properties" transfer-ownership="none">
              <type name="ObjectConstructParam" c:type="GObjectConstructParam*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_property">
        <doc xml:space="preserve">the generic setter for all properties of this type. Should be
 overridden for every type with properties. If implementations of
 @set_property don't emit property change notification explicitly, this will
 be done implicitly by the type system. However, if the notify signal is
 emitted explicitly, the type system will not emit it a second time.</doc>
        <callback name="set_property">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="property_id" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="const GValue*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_property">
        <doc xml:space="preserve">the generic getter for all properties of this type. Should be
 overridden for every type with properties.</doc>
        <callback name="get_property">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="property_id" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dispose">
        <doc xml:space="preserve">the @dispose function is supposed to drop all references to other
 objects, but keep the instance otherwise intact, so that client method
 invocations still work. It may be run multiple times (due to reference
 loops). Before returning, @dispose should chain up to the @dispose method
 of the parent class.</doc>
        <callback name="dispose">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finalize">
        <doc xml:space="preserve">instance finalization function, should finish the finalization of
 the instance begun in @dispose and chain up to the @finalize method of the
 parent class.</doc>
        <callback name="finalize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dispatch_properties_changed">
        <doc xml:space="preserve">emits property change notification for a bunch
 of properties. Overriding @dispatch_properties_changed should be rarely
 needed.</doc>
        <callback name="dispatch_properties_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="n_pspecs" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="pspecs" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="notify">
        <doc xml:space="preserve">the class closure for the notify signal</doc>
        <callback name="notify">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">a #GObject</doc>
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="constructed">
        <doc xml:space="preserve">the @constructed function is called by g_object_new() as the
 final step of the object creation process.  At the point of the call, all
 construction properties have been set on the object.  The purpose of this
 call is to allow for object initialisation steps that can only be performed
 after construction properties have been set.  @constructed implementors
 should chain up to the @constructed call of their parent class to allow it
 to complete its initialisation.</doc>
        <callback name="constructed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flags" readable="0" private="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="n_construct_properties" readable="0" private="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="pspecs" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="n_pspecs" readable="0" private="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="pdummy" readable="0" private="1">
        <array zero-terminated="0" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="find_property" c:identifier="g_object_class_find_property">
        <doc xml:space="preserve">Looks up the #GParamSpec for a property of a class.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GParamSpec for the property, or
         %NULL if the class doesn't have a property of that name</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none">
            <doc xml:space="preserve">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to look up</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="install_properties" c:identifier="g_object_class_install_properties" version="2.26">
        <doc xml:space="preserve">Installs new properties from an array of #GParamSpecs.

All properties should be installed during the class initializer.  It
is possible to install properties after that, but doing so is not
recommend, and specifically, is not guaranteed to be thread-safe vs.
use of properties on the same type on other threads.

The property id of each property is the index of each #GParamSpec in
the @pspecs array.

The property id of 0 is treated specially by #GObject and it should not
be used to store a #GParamSpec.

This function should be used if you plan to use a static array of
#GParamSpecs and g_object_notify_by_pspec(). For instance, this
class initialization:

|[&lt;!-- language="C" --&gt;
typedef enum {
  PROP_FOO = 1,
  PROP_BAR,
  N_PROPERTIES
} MyObjectProperty;

static GParamSpec *obj_properties[N_PROPERTIES] = { NULL, };

static void
my_object_class_init (MyObjectClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  obj_properties[PROP_FOO] =
    g_param_spec_int ("foo", NULL, NULL,
                      -1, G_MAXINT,
                      0,
                      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);

  obj_properties[PROP_BAR] =
    g_param_spec_string ("bar", NULL, NULL,
                         NULL,
                         G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);

  gobject_class-&gt;set_property = my_object_set_property;
  gobject_class-&gt;get_property = my_object_get_property;
  g_object_class_install_properties (gobject_class,
                                     G_N_ELEMENTS (obj_properties),
                                     obj_properties);
}
]|

allows calling g_object_notify_by_pspec() to notify of property changes:

|[&lt;!-- language="C" --&gt;
void
my_object_set_foo (MyObject *self, gint foo)
{
  if (self-&gt;foo != foo)
    {
      self-&gt;foo = foo;
      g_object_notify_by_pspec (G_OBJECT (self), obj_properties[PROP_FOO]);
    }
 }
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none">
            <doc xml:space="preserve">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*"/>
          </instance-parameter>
          <parameter name="n_pspecs" transfer-ownership="none">
            <doc xml:space="preserve">the length of the #GParamSpecs array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="pspecs" transfer-ownership="none">
            <doc xml:space="preserve">the #GParamSpecs array
  defining the new properties</doc>
            <array length="0" zero-terminated="0" c:type="GParamSpec**">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="install_property" c:identifier="g_object_class_install_property">
        <doc xml:space="preserve">Installs a new property.

All properties should be installed during the class initializer.  It
is possible to install properties after that, but doing so is not
recommend, and specifically, is not guaranteed to be thread-safe vs.
use of properties on the same type on other threads.

Note that it is possible to redefine a property in a derived class,
by installing a property with the same name. This can be useful at times,
e.g. to change the range of allowed values or the default value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none">
            <doc xml:space="preserve">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*"/>
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none">
            <doc xml:space="preserve">the id for the new property</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_properties" c:identifier="g_object_class_list_properties">
        <doc xml:space="preserve">Get an array of #GParamSpec* for all properties of a class.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">an array of
         #GParamSpec* which should be freed after use</doc>
          <array length="0" zero-terminated="0" c:type="GParamSpec**">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none">
            <doc xml:space="preserve">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*"/>
          </instance-parameter>
          <parameter name="n_properties" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the length of the returned array</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="override_property" c:identifier="g_object_class_override_property" version="2.4">
        <doc xml:space="preserve">Registers @property_id as referring to a property with the name
@name in a parent class or in an interface implemented by @oclass.
This allows this class to "override" a property implementation in
a parent class or to provide the implementation of a property from
an interface.

Internally, overriding is implemented by creating a property of type
#GParamSpecOverride; generally operations that query the properties of
the object class, such as g_object_class_find_property() or
g_object_class_list_properties() will return the overridden
property. However, in one case, the @construct_properties argument of
the @constructor virtual function, the #GParamSpecOverride is passed
instead, so that the @param_id field of the #GParamSpec will be
correct.  For virtually all uses, this makes no difference. If you
need to get the overridden property, you can call
g_param_spec_get_redirect_target().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none">
            <doc xml:space="preserve">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*"/>
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none">
            <doc xml:space="preserve">the new property ID</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a property registered in a parent class or
 in an interface of this class.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ObjectConstructParam" c:type="GObjectConstructParam">
      <doc xml:space="preserve">The GObjectConstructParam struct is an auxiliary structure used to hand
#GParamSpec/#GValue pairs to the @constructor of a #GObjectClass.</doc>
      <field name="pspec" writable="1">
        <doc xml:space="preserve">the #GParamSpec of the construct parameter</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </field>
      <field name="value" writable="1">
        <doc xml:space="preserve">the value to set the parameter to</doc>
        <type name="Value" c:type="GValue*"/>
      </field>
    </record>
    <callback name="ObjectFinalizeFunc" c:type="GObjectFinalizeFunc">
      <doc xml:space="preserve">The type of the @finalize function of #GObjectClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">the #GObject being finalized</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ObjectGetPropertyFunc" c:type="GObjectGetPropertyFunc">
      <doc xml:space="preserve">The type of the @get_property function of #GObjectClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">a #GObject</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
        <parameter name="property_id" transfer-ownership="none">
          <doc xml:space="preserve">the numeric id under which the property was registered with
 g_object_class_install_property().</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue to return the property value in</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:space="preserve">the #GParamSpec describing the property</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ObjectSetPropertyFunc" c:type="GObjectSetPropertyFunc">
      <doc xml:space="preserve">The type of the @set_property function of #GObjectClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">a #GObject</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
        <parameter name="property_id" transfer-ownership="none">
          <doc xml:space="preserve">the numeric id under which the property was registered with
 g_object_class_install_property().</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the new value for the property</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:space="preserve">the #GParamSpec describing the property</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="OptionGroup" c:symbol-prefix="option_group" glib:type-name="GOptionGroup" glib:get-type="g_option_group_get_type">
    </glib:boxed>
    <constant name="PARAM_MASK" value="255" c:type="G_PARAM_MASK">
      <doc xml:space="preserve">Mask containing the bits of #GParamSpec.flags which are reserved for GLib.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="PARAM_SPEC" c:identifier="G_PARAM_SPEC" introspectable="0">
      <doc xml:space="preserve">Casts a derived #GParamSpec object (e.g. of type #GParamSpecInt) into
a #GParamSpec object.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_BOOLEAN" c:identifier="G_PARAM_SPEC_BOOLEAN" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecBoolean.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_BOXED" c:identifier="G_PARAM_SPEC_BOXED" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecBoxed.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_CHAR" c:identifier="G_PARAM_SPEC_CHAR" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecChar.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_CLASS" c:identifier="G_PARAM_SPEC_CLASS" introspectable="0">
      <doc xml:space="preserve">Casts a derived #GParamSpecClass structure into a #GParamSpecClass structure.</doc>
      <parameters>
        <parameter name="pclass">
          <doc xml:space="preserve">a valid #GParamSpecClass</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_DOUBLE" c:identifier="G_PARAM_SPEC_DOUBLE" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecDouble.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_ENUM" c:identifier="G_PARAM_SPEC_ENUM" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecEnum.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_FLAGS" c:identifier="G_PARAM_SPEC_FLAGS" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecFlags.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_FLOAT" c:identifier="G_PARAM_SPEC_FLOAT" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecFloat.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_GET_CLASS" c:identifier="G_PARAM_SPEC_GET_CLASS" introspectable="0">
      <doc xml:space="preserve">Retrieves the #GParamSpecClass of a #GParamSpec.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_GTYPE" c:identifier="G_PARAM_SPEC_GTYPE" version="2.10" introspectable="0">
      <doc xml:space="preserve">Casts a #GParamSpec into a #GParamSpecGType.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_INT" c:identifier="G_PARAM_SPEC_INT" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecInt.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_INT64" c:identifier="G_PARAM_SPEC_INT64" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecInt64.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_LONG" c:identifier="G_PARAM_SPEC_LONG" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecLong.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_OBJECT" c:identifier="G_PARAM_SPEC_OBJECT" introspectable="0">
      <doc xml:space="preserve">Casts a #GParamSpec instance into a #GParamSpecObject.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_OVERRIDE" c:identifier="G_PARAM_SPEC_OVERRIDE" version="2.4" introspectable="0">
      <doc xml:space="preserve">Casts a #GParamSpec into a #GParamSpecOverride.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_PARAM" c:identifier="G_PARAM_SPEC_PARAM" introspectable="0">
      <doc xml:space="preserve">Casts a #GParamSpec instance into a #GParamSpecParam.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_POINTER" c:identifier="G_PARAM_SPEC_POINTER" introspectable="0">
      <doc xml:space="preserve">Casts a #GParamSpec instance into a #GParamSpecPointer.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_STRING" c:identifier="G_PARAM_SPEC_STRING" introspectable="0">
      <doc xml:space="preserve">Casts a #GParamSpec instance into a #GParamSpecString.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_TYPE" c:identifier="G_PARAM_SPEC_TYPE" introspectable="0">
      <doc xml:space="preserve">Retrieves the #GType of this @pspec.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_TYPE_NAME" c:identifier="G_PARAM_SPEC_TYPE_NAME" introspectable="0">
      <doc xml:space="preserve">Retrieves the #GType name of this @pspec.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_UCHAR" c:identifier="G_PARAM_SPEC_UCHAR" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecUChar.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_UINT" c:identifier="G_PARAM_SPEC_UINT" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecUInt.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_UINT64" c:identifier="G_PARAM_SPEC_UINT64" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecUInt64.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_ULONG" c:identifier="G_PARAM_SPEC_ULONG" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecULong.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_UNICHAR" c:identifier="G_PARAM_SPEC_UNICHAR" introspectable="0">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecUnichar.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_VALUE_ARRAY" c:identifier="G_PARAM_SPEC_VALUE_ARRAY" introspectable="0" deprecated="1" deprecated-version="2.32">
      <doc xml:space="preserve">Cast a #GParamSpec instance into a #GParamSpecValueArray.</doc>
      <doc-deprecated xml:space="preserve">Use #GArray instead of #GValueArray</doc-deprecated>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_VALUE_TYPE" c:identifier="G_PARAM_SPEC_VALUE_TYPE" introspectable="0">
      <doc xml:space="preserve">Retrieves the #GType to initialize a #GValue for this parameter.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a valid #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_VARIANT" c:identifier="G_PARAM_SPEC_VARIANT" version="2.26" introspectable="0">
      <doc xml:space="preserve">Casts a #GParamSpec into a #GParamSpecVariant.</doc>
      <parameters>
        <parameter name="pspec">
          <doc xml:space="preserve">a #GParamSpec</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="PARAM_STATIC_STRINGS" value="224" c:type="G_PARAM_STATIC_STRINGS">
      <doc xml:space="preserve">#GParamFlags value alias for %G_PARAM_STATIC_NAME | %G_PARAM_STATIC_NICK | %G_PARAM_STATIC_BLURB.

It is recommended to use this for all properties by default, as it allows for
internal performance improvements in GObject.

It is very rare that a property would have a dynamically constructed name,
nickname or blurb.

Since 2.13.0</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_USER_SHIFT" value="8" c:type="G_PARAM_USER_SHIFT">
      <doc xml:space="preserve">Minimum shift count to be used for user defined flags, to be stored in
#GParamSpec.flags. The maximum allowed is 10.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="PRIVATE_FIELD" c:identifier="G_PRIVATE_FIELD" version="2.38" introspectable="0">
      <doc xml:space="preserve">Evaluates to the @field_name inside the @inst private data
structure for @TypeName.

Note that this macro can only be used together with the `G_DEFINE_TYPE_*`
and G_ADD_PRIVATE() macros, since it depends on variable names from
those macros.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">the name of the type in CamelCase</doc>
        </parameter>
        <parameter name="inst">
          <doc xml:space="preserve">the instance of @TypeName you wish to access</doc>
        </parameter>
        <parameter name="field_type">
          <doc xml:space="preserve">the type of the field in the private data structure</doc>
        </parameter>
        <parameter name="field_name">
          <doc xml:space="preserve">the name of the field in the private data structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PRIVATE_FIELD_P" c:identifier="G_PRIVATE_FIELD_P" version="2.38" introspectable="0">
      <doc xml:space="preserve">Evaluates to a pointer to the @field_name inside the @inst private data
structure for @TypeName.

Note that this macro can only be used together with the `G_DEFINE_TYPE_*`
and G_ADD_PRIVATE() macros, since it depends on variable names from
those macros.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">the name of the type in CamelCase</doc>
        </parameter>
        <parameter name="inst">
          <doc xml:space="preserve">the instance of @TypeName you wish to access</doc>
        </parameter>
        <parameter name="field_name">
          <doc xml:space="preserve">the name of the field in the private data structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PRIVATE_OFFSET" c:identifier="G_PRIVATE_OFFSET" version="2.38" introspectable="0">
      <doc xml:space="preserve">Evaluates to the offset of the @field inside the instance private data
structure for @TypeName.

Note that this macro can only be used together with the `G_DEFINE_TYPE_*`
and G_ADD_PRIVATE() macros, since it depends on variable names from
those macros.</doc>
      <parameters>
        <parameter name="TypeName">
          <doc xml:space="preserve">the name of the type in CamelCase</doc>
        </parameter>
        <parameter name="field">
          <doc xml:space="preserve">the name of the field in the private data structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <bitfield name="ParamFlags" c:type="GParamFlags">
      <doc xml:space="preserve">Through the #GParamFlags flag values, certain aspects of parameters
can be configured.

See also: %G_PARAM_STATIC_STRINGS</doc>
      <member name="readable" value="1" c:identifier="G_PARAM_READABLE">
        <doc xml:space="preserve">the parameter is readable</doc>
      </member>
      <member name="writable" value="2" c:identifier="G_PARAM_WRITABLE">
        <doc xml:space="preserve">the parameter is writable</doc>
      </member>
      <member name="readwrite" value="3" c:identifier="G_PARAM_READWRITE">
        <doc xml:space="preserve">alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE</doc>
      </member>
      <member name="construct" value="4" c:identifier="G_PARAM_CONSTRUCT">
        <doc xml:space="preserve">the parameter will be set upon object construction</doc>
      </member>
      <member name="construct_only" value="8" c:identifier="G_PARAM_CONSTRUCT_ONLY">
        <doc xml:space="preserve">the parameter can only be set upon object construction</doc>
      </member>
      <member name="lax_validation" value="16" c:identifier="G_PARAM_LAX_VALIDATION">
        <doc xml:space="preserve">upon parameter conversion (see g_param_value_convert())
 strict validation is not required</doc>
      </member>
      <member name="static_name" value="32" c:identifier="G_PARAM_STATIC_NAME">
        <doc xml:space="preserve">the string used as name when constructing the
 parameter is guaranteed to remain valid and
 unmodified for the lifetime of the parameter.
 Since 2.8</doc>
      </member>
      <member name="private" value="32" c:identifier="G_PARAM_PRIVATE">
        <doc xml:space="preserve">internal</doc>
      </member>
      <member name="static_nick" value="64" c:identifier="G_PARAM_STATIC_NICK">
        <doc xml:space="preserve">the string used as nick when constructing the
 parameter is guaranteed to remain valid and
 unmmodified for the lifetime of the parameter.
 Since 2.8</doc>
      </member>
      <member name="static_blurb" value="128" c:identifier="G_PARAM_STATIC_BLURB">
        <doc xml:space="preserve">the string used as blurb when constructing the
 parameter is guaranteed to remain valid and
 unmodified for the lifetime of the parameter.
 Since 2.8</doc>
      </member>
      <member name="explicit_notify" value="1073741824" c:identifier="G_PARAM_EXPLICIT_NOTIFY">
        <doc xml:space="preserve">calls to g_object_set_property() for this
  property will not automatically result in a "notify" signal being
  emitted: the implementation must call g_object_notify() themselves
  in case the property actually changes.  Since: 2.42.</doc>
      </member>
      <member name="deprecated" value="2147483648" c:identifier="G_PARAM_DEPRECATED">
        <doc xml:space="preserve">the parameter is deprecated and will be removed
 in a future version. A warning will be generated if it is used
 while running with G_ENABLE_DIAGNOSTIC=1.
 Since 2.26</doc>
      </member>
    </bitfield>
    <class name="ParamSpec" c:symbol-prefix="param_spec" c:type="GParamSpec" abstract="1" glib:type-name="GParam" glib:get-type="intern" glib:type-struct="ParamSpecClass" glib:fundamental="1" glib:ref-func="g_param_spec_ref_sink" glib:unref-func="g_param_spec_unref" glib:set-value-func="g_value_set_param" glib:get-value-func="g_value_get_param">
      <doc xml:space="preserve">`GParamSpec` encapsulates the metadata required to specify parameters, such as `GObject` properties.

## Parameter names

A property name consists of one or more segments consisting of ASCII letters
and digits, separated by either the `-` or `_` character. The first
character of a property name must be a letter. These are the same rules as
for signal naming (see [func@GObject.signal_new]).

When creating and looking up a `GParamSpec`, either separator can be
used, but they cannot be mixed. Using `-` is considerably more
efficient, and is the &#x2018;canonical form&#x2019;. Using `_` is discouraged.</doc>
      <function name="internal" c:identifier="g_param_spec_internal" introspectable="0">
        <doc xml:space="preserve">Creates a new #GParamSpec instance.

See [canonical parameter names][class@GObject.ParamSpec#parameter-names]
for details of the rules for @name. Names which violate these rules lead
to undefined behaviour.

Beyond the name, #GParamSpecs have two more descriptive strings, the
@nick and @blurb, which may be used as a localized label and description.
For GTK and related libraries these are considered deprecated and may be
omitted, while for other libraries such as GStreamer and its plugins they
are essential. When in doubt, follow the conventions used in the
surrounding code and supporting libraries.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">(transfer floating): a newly allocated
    #GParamSpec instance, which is initially floating</doc>
          <type name="ParamSpec" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="param_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType for the property; must be derived from %G_TYPE_PARAM</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the canonical name of the property</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the nickname of the property</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a short description of the property</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a combination of #GParamFlags</doc>
            <type name="ParamFlags" c:type="GParamFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_valid_name" c:identifier="g_param_spec_is_valid_name" version="2.66">
        <doc xml:space="preserve">Validate a property name for a #GParamSpec. This can be useful for
dynamically-generated properties which need to be validated at run-time
before actually trying to create them.

See [canonical parameter names][class@GObject.ParamSpec#parameter-names]
for details of the rules for valid names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @name is a valid property name, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the canonical name of the property</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="finalize">
        <doc xml:space="preserve">The instance finalization function (optional), should chain
 up to the finalize method of the parent class.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="value_is_valid">
        <doc xml:space="preserve">Checks if contents of @value comply with the specifications
  set out by this type, without modifying the value. This vfunc is optional.
  If it isn't set, GObject will use @value_validate. Since 2.74</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="value_set_default">
        <doc xml:space="preserve">Resets a @value to the default value for this type
 (recommended, the default is g_value_reset()), see
 g_param_value_set_default().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="value_validate">
        <doc xml:space="preserve">Ensures that the contents of @value comply with the
 specifications set out by this type (optional), see
 g_param_value_validate().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="values_cmp">
        <doc xml:space="preserve">Compares @value1 with @value2 according to this type
 (recommended, the default is memcmp()), see g_param_values_cmp().</doc>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
          <parameter name="value1" transfer-ownership="none">
            <type name="Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="value2" transfer-ownership="none">
            <type name="Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_blurb" c:identifier="g_param_spec_get_blurb">
        <doc xml:space="preserve">Get the short description of a #GParamSpec.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the short description of @pspec.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_default_value" c:identifier="g_param_spec_get_default_value" version="2.38">
        <doc xml:space="preserve">Gets the default value of @pspec as a pointer to a #GValue.

The #GValue will remain valid for the life of @pspec.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #GValue which must not be modified</doc>
          <type name="Value" c:type="const GValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_param_spec_get_name">
        <doc xml:space="preserve">Get the name of a #GParamSpec.

The name is always an "interned" string (as per g_intern_string()).
This allows for pointer-value comparisons.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of @pspec.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name_quark" c:identifier="g_param_spec_get_name_quark" version="2.46">
        <doc xml:space="preserve">Gets the GQuark for the name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the GQuark for @pspec-&gt;name.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nick" c:identifier="g_param_spec_get_nick">
        <doc xml:space="preserve">Get the nickname of a #GParamSpec.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the nickname of @pspec.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_qdata" c:identifier="g_param_spec_get_qdata">
        <doc xml:space="preserve">Gets back user data pointers stored via g_param_spec_set_qdata().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:space="preserve">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_redirect_target" c:identifier="g_param_spec_get_redirect_target" version="2.4">
        <doc xml:space="preserve">If the paramspec redirects operations to another paramspec,
returns that paramspec. Redirect is used typically for
providing a new implementation of a property in a derived
type while preserving all the properties from the parent
type. Redirection is established by creating a property
of type #GParamSpecOverride. See g_object_class_override_property()
for an example of the use of this capability.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">paramspec to which requests on this
         paramspec should be redirected, or %NULL if none.</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_param_spec_ref" introspectable="0">
        <doc xml:space="preserve">Increments the reference count of @pspec.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GParamSpec that was passed into this function</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref_sink" c:identifier="g_param_spec_ref_sink" version="2.10" introspectable="0">
        <doc xml:space="preserve">Convenience function to ref and sink a #GParamSpec.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GParamSpec that was passed into this function</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_qdata" c:identifier="g_param_spec_set_qdata">
        <doc xml:space="preserve">Sets an opaque, named pointer on a #GParamSpec. The name is
specified through a #GQuark (retrieved e.g. via
g_quark_from_static_string()), and the pointer can be gotten back
from the @pspec with g_param_spec_get_qdata().  Setting a
previously set user data pointer, overrides (frees) the old pointer
set, using %NULL as pointer essentially removes the data stored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">the #GParamSpec to set store a user data pointer</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:space="preserve">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qdata_full" c:identifier="g_param_spec_set_qdata_full" introspectable="0">
        <doc xml:space="preserve">This function works like g_param_spec_set_qdata(), but in addition,
a `void (*destroy) (gpointer)` function may be
specified which is called with @data as argument when the @pspec is
finalized, or the data is being overwritten by a call to
g_param_spec_set_qdata() with the same @quark.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">the #GParamSpec to set store a user data pointer</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:space="preserve">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async">
            <doc xml:space="preserve">function to invoke with @data as argument, when @data needs to
 be freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="sink" c:identifier="g_param_spec_sink">
        <doc xml:space="preserve">The initial reference count of a newly created #GParamSpec is 1,
even though no one has explicitly called g_param_spec_ref() on it
yet. So the initial reference count is flagged as "floating", until
someone calls `g_param_spec_ref (pspec); g_param_spec_sink
(pspec);` in sequence on it, taking over the initial
reference count (thus ending up with a @pspec that has a reference
count of 1 still, but is not flagged "floating" anymore).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="steal_qdata" c:identifier="g_param_spec_steal_qdata">
        <doc xml:space="preserve">Gets back user data pointers stored via g_param_spec_set_qdata()
and removes the @data from @pspec without invoking its destroy()
function (if any was set).  Usually, calling this function is only
required to update user data pointers with a destroy notifier.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">the #GParamSpec to get a stored user data pointer from</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:space="preserve">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_param_spec_unref" introspectable="0">
        <doc xml:space="preserve">Decrements the reference count of a @pspec.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="g_type_instance">
        <doc xml:space="preserve">private `GTypeInstance` portion</doc>
        <type name="TypeInstance" c:type="GTypeInstance"/>
      </field>
      <field name="name">
        <doc xml:space="preserve">name of this parameter: always an interned string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="flags">
        <doc xml:space="preserve">`GParamFlags` flags for this parameter</doc>
        <type name="ParamFlags" c:type="GParamFlags"/>
      </field>
      <field name="value_type">
        <doc xml:space="preserve">the `GValue` type for this parameter</doc>
        <type name="GType" c:type="GType"/>
      </field>
      <field name="owner_type">
        <doc xml:space="preserve">`GType` type that uses (introduces) this parameter</doc>
        <type name="GType" c:type="GType"/>
      </field>
      <field name="_nick" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="_blurb" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="qdata" readable="0" private="1">
        <type name="GLib.Data" c:type="GData*"/>
      </field>
      <field name="ref_count" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="param_id" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
    </class>
    <class name="ParamSpecBoolean" c:symbol-prefix="param_spec_boolean" c:type="GParamSpecBoolean" parent="ParamSpec" glib:type-name="GParamBoolean" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for boolean properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </class>
    <class name="ParamSpecBoxed" c:symbol-prefix="param_spec_boxed" c:type="GParamSpecBoxed" parent="ParamSpec" glib:type-name="GParamBoxed" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for boxed properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
    </class>
    <class name="ParamSpecChar" c:symbol-prefix="param_spec_char" c:type="GParamSpecChar" parent="ParamSpec" glib:type-name="GParamChar" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for character properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum">
        <doc xml:space="preserve">minimum value for the property specified</doc>
        <type name="gint8" c:type="gint8"/>
      </field>
      <field name="maximum">
        <doc xml:space="preserve">maximum value for the property specified</doc>
        <type name="gint8" c:type="gint8"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="gint8" c:type="gint8"/>
      </field>
    </class>
    <record name="ParamSpecClass" c:type="GParamSpecClass" glib:is-gtype-struct-for="ParamSpec">
      <doc xml:space="preserve">The class structure for the GParamSpec type.
Normally, GParamSpec classes are filled by
g_param_type_register_static().</doc>
      <field name="g_type_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="value_type">
        <doc xml:space="preserve">the #GValue type for this parameter</doc>
        <type name="GType" c:type="GType"/>
      </field>
      <field name="finalize">
        <doc xml:space="preserve">The instance finalization function (optional), should chain
 up to the finalize method of the parent class.</doc>
        <callback name="finalize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_set_default">
        <doc xml:space="preserve">Resets a @value to the default value for this type
 (recommended, the default is g_value_reset()), see
 g_param_value_set_default().</doc>
        <callback name="value_set_default">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_validate">
        <doc xml:space="preserve">Ensures that the contents of @value comply with the
 specifications set out by this type (optional), see
 g_param_value_validate().</doc>
        <callback name="value_validate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="values_cmp">
        <doc xml:space="preserve">Compares @value1 with @value2 according to this type
 (recommended, the default is memcmp()), see g_param_values_cmp().</doc>
        <callback name="values_cmp">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value1" transfer-ownership="none">
              <type name="Value" c:type="const GValue*"/>
            </parameter>
            <parameter name="value2" transfer-ownership="none">
              <type name="Value" c:type="const GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_is_valid">
        <doc xml:space="preserve">Checks if contents of @value comply with the specifications
  set out by this type, without modifying the value. This vfunc is optional.
  If it isn't set, GObject will use @value_validate. Since 2.74</doc>
        <callback name="value_is_valid">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="const GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dummy" readable="0" private="1">
        <array zero-terminated="0" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="ParamSpecDouble" c:symbol-prefix="param_spec_double" c:type="GParamSpecDouble" parent="ParamSpec" glib:type-name="GParamDouble" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for double properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum">
        <doc xml:space="preserve">minimum value for the property specified</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="maximum">
        <doc xml:space="preserve">maximum value for the property specified</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="epsilon">
        <doc xml:space="preserve">values closer than @epsilon will be considered identical
 by g_param_values_cmp(); the default value is 1e-90.</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
    </class>
    <class name="ParamSpecEnum" c:symbol-prefix="param_spec_enum" c:type="GParamSpecEnum" parent="ParamSpec" glib:type-name="GParamEnum" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for enum
properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="enum_class">
        <doc xml:space="preserve">the #GEnumClass for the enum</doc>
        <type name="EnumClass" c:type="GEnumClass*"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="gint" c:type="gint"/>
      </field>
    </class>
    <class name="ParamSpecFlags" c:symbol-prefix="param_spec_flags" c:type="GParamSpecFlags" parent="ParamSpec" glib:type-name="GParamFlags" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for flags
properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="flags_class">
        <doc xml:space="preserve">the #GFlagsClass for the flags</doc>
        <type name="FlagsClass" c:type="GFlagsClass*"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="guint" c:type="guint"/>
      </field>
    </class>
    <class name="ParamSpecFloat" c:symbol-prefix="param_spec_float" c:type="GParamSpecFloat" parent="ParamSpec" glib:type-name="GParamFloat" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for float properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum">
        <doc xml:space="preserve">minimum value for the property specified</doc>
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <field name="maximum">
        <doc xml:space="preserve">maximum value for the property specified</doc>
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <field name="epsilon">
        <doc xml:space="preserve">values closer than @epsilon will be considered identical
 by g_param_values_cmp(); the default value is 1e-30.</doc>
        <type name="gfloat" c:type="gfloat"/>
      </field>
    </class>
    <class name="ParamSpecGType" c:symbol-prefix="param_spec_gtype" c:type="GParamSpecGType" version="2.10" parent="ParamSpec" glib:type-name="GParamGType" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for #GType properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="is_a_type">
        <doc xml:space="preserve">a #GType whose subtypes can occur as values</doc>
        <type name="GType" c:type="GType"/>
      </field>
    </class>
    <class name="ParamSpecInt" c:symbol-prefix="param_spec_int" c:type="GParamSpecInt" parent="ParamSpec" glib:type-name="GParamInt" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for integer properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum">
        <doc xml:space="preserve">minimum value for the property specified</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="maximum">
        <doc xml:space="preserve">maximum value for the property specified</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="gint" c:type="gint"/>
      </field>
    </class>
    <class name="ParamSpecInt64" c:symbol-prefix="param_spec_int64" c:type="GParamSpecInt64" parent="ParamSpec" glib:type-name="GParamInt64" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for 64bit integer properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum">
        <doc xml:space="preserve">minimum value for the property specified</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="maximum">
        <doc xml:space="preserve">maximum value for the property specified</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
    </class>
    <class name="ParamSpecLong" c:symbol-prefix="param_spec_long" c:type="GParamSpecLong" parent="ParamSpec" glib:type-name="GParamLong" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for long integer properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum">
        <doc xml:space="preserve">minimum value for the property specified</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="maximum">
        <doc xml:space="preserve">maximum value for the property specified</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="glong" c:type="glong"/>
      </field>
    </class>
    <class name="ParamSpecObject" c:symbol-prefix="param_spec_object" c:type="GParamSpecObject" parent="ParamSpec" glib:type-name="GParamObject" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for object properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
    </class>
    <class name="ParamSpecOverride" c:symbol-prefix="param_spec_override" c:type="GParamSpecOverride" version="2.4" parent="ParamSpec" glib:type-name="GParamOverride" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that redirects operations to
other types of #GParamSpec.

All operations other than getting or setting the value are redirected,
including accessing the nick and blurb, validating a value, and so
forth.

See g_param_spec_get_redirect_target() for retrieving the overridden
property. #GParamSpecOverride is used in implementing
g_object_class_override_property(), and will not be directly useful
unless you are implementing a new base type similar to GObject.</doc>
      <field name="parent_instance" readable="0" private="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="overridden" readable="0" private="1">
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </field>
    </class>
    <class name="ParamSpecParam" c:symbol-prefix="param_spec_param" c:type="GParamSpecParam" parent="ParamSpec" glib:type-name="GParamParam" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM
properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
    </class>
    <class name="ParamSpecPointer" c:symbol-prefix="param_spec_pointer" c:type="GParamSpecPointer" parent="ParamSpec" glib:type-name="GParamPointer" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for pointer properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
    </class>
    <record name="ParamSpecPool" c:type="GParamSpecPool" disguised="1" opaque="1">
      <doc xml:space="preserve">A #GParamSpecPool maintains a collection of #GParamSpecs which can be
quickly accessed by owner and name.

The implementation of the #GObject property system uses such a pool to
store the #GParamSpecs of the properties all object types.</doc>
      <method name="free" c:identifier="g_param_spec_pool_free" version="2.80">
        <doc xml:space="preserve">Frees the resources allocated by a #GParamSpecPool.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="full">
            <doc xml:space="preserve">a #GParamSpecPool</doc>
            <type name="ParamSpecPool" c:type="GParamSpecPool*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_param_spec_pool_insert">
        <doc xml:space="preserve">Inserts a #GParamSpec in the pool.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GParamSpecPool.</doc>
            <type name="ParamSpecPool" c:type="GParamSpecPool*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">the #GParamSpec to insert</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="owner_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType identifying the owner of @pspec</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="list" c:identifier="g_param_spec_pool_list">
        <doc xml:space="preserve">Gets an array of all #GParamSpecs owned by @owner_type in
the pool.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a newly
         allocated array containing pointers to all #GParamSpecs
         owned by @owner_type in the pool</doc>
          <array length="1" zero-terminated="0" c:type="GParamSpec**">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GParamSpecPool</doc>
            <type name="ParamSpecPool" c:type="GParamSpecPool*"/>
          </instance-parameter>
          <parameter name="owner_type" transfer-ownership="none">
            <doc xml:space="preserve">the owner to look for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_pspecs_p" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the length of the returned array</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_owned" c:identifier="g_param_spec_pool_list_owned">
        <doc xml:space="preserve">Gets an #GList of all #GParamSpecs owned by @owner_type in
the pool.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a
         #GList of all #GParamSpecs owned by @owner_type in
         the pool#GParamSpecs.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ParamSpec"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GParamSpecPool</doc>
            <type name="ParamSpecPool" c:type="GParamSpecPool*"/>
          </instance-parameter>
          <parameter name="owner_type" transfer-ownership="none">
            <doc xml:space="preserve">the owner to look for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="g_param_spec_pool_lookup">
        <doc xml:space="preserve">Looks up a #GParamSpec in the pool.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The found #GParamSpec, or %NULL if no
matching #GParamSpec was found.</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GParamSpecPool</doc>
            <type name="ParamSpecPool" c:type="GParamSpecPool*"/>
          </instance-parameter>
          <parameter name="param_name" transfer-ownership="none">
            <doc xml:space="preserve">the name to look for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="owner_type" transfer-ownership="none">
            <doc xml:space="preserve">the owner to look for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="walk_ancestors" transfer-ownership="none">
            <doc xml:space="preserve">If %TRUE, also try to find a #GParamSpec with @param_name
 owned by an ancestor of @owner_type.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_param_spec_pool_remove">
        <doc xml:space="preserve">Removes a #GParamSpec from the pool.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none">
            <doc xml:space="preserve">a #GParamSpecPool</doc>
            <type name="ParamSpecPool" c:type="GParamSpecPool*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">the #GParamSpec to remove</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="g_param_spec_pool_new" introspectable="0">
        <doc xml:space="preserve">Creates a new #GParamSpecPool.

If @type_prefixing is %TRUE, lookups in the newly created pool will
allow to specify the owner as a colon-separated prefix of the
property name, like "GtkContainer:border-width". This feature is
deprecated, so you should always set @type_prefixing to %FALSE.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GParamSpecPool.</doc>
          <type name="ParamSpecPool" c:type="GParamSpecPool*"/>
        </return-value>
        <parameters>
          <parameter name="type_prefixing" transfer-ownership="none">
            <doc xml:space="preserve">Whether the pool will support type-prefixed property names.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="ParamSpecString" c:symbol-prefix="param_spec_string" c:type="GParamSpecString" parent="ParamSpec" glib:type-name="GParamString" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for string
properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="cset_first">
        <doc xml:space="preserve">a string containing the allowed values for the first byte</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="cset_nth">
        <doc xml:space="preserve">a string containing the allowed values for the subsequent bytes</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="substitutor">
        <doc xml:space="preserve">the replacement byte for bytes which don't match @cset_first or @cset_nth.</doc>
        <type name="gchar" c:type="gchar"/>
      </field>
      <field name="null_fold_if_empty" bits="1">
        <doc xml:space="preserve">replace empty string by %NULL</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="ensure_non_null" bits="1">
        <doc xml:space="preserve">replace %NULL strings by an empty string</doc>
        <type name="guint" c:type="guint"/>
      </field>
    </class>
    <record name="ParamSpecTypeInfo" c:type="GParamSpecTypeInfo">
      <doc xml:space="preserve">This structure is used to provide the type system with the information
required to initialize and destruct (finalize) a parameter's class and
instances thereof.

The initialized structure is passed to the g_param_type_register_static()
The type system will perform a deep copy of this structure, so its memory
does not need to be persistent across invocation of
g_param_type_register_static().</doc>
      <field name="instance_size" writable="1">
        <doc xml:space="preserve">Size of the instance (object) structure.</doc>
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="n_preallocs" writable="1">
        <doc xml:space="preserve">Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.</doc>
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="instance_init">
        <doc xml:space="preserve">Location of the instance initialization function (optional).</doc>
        <callback name="instance_init">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_type" writable="1">
        <doc xml:space="preserve">The #GType of values conforming to this #GParamSpec</doc>
        <type name="GType" c:type="GType"/>
      </field>
      <field name="finalize">
        <doc xml:space="preserve">The instance finalization function (optional).</doc>
        <callback name="finalize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_set_default">
        <doc xml:space="preserve">Resets a @value to the default value for @pspec
 (recommended, the default is g_value_reset()), see
 g_param_value_set_default().</doc>
        <callback name="value_set_default">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_validate">
        <doc xml:space="preserve">Ensures that the contents of @value comply with the
 specifications set out by @pspec (optional), see
 g_param_value_validate().</doc>
        <callback name="value_validate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="values_cmp">
        <doc xml:space="preserve">Compares @value1 with @value2 according to @pspec
 (recommended, the default is memcmp()), see g_param_values_cmp().</doc>
        <callback name="values_cmp">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value1" transfer-ownership="none">
              <type name="Value" c:type="const GValue*"/>
            </parameter>
            <parameter name="value2" transfer-ownership="none">
              <type name="Value" c:type="const GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="ParamSpecUChar" c:symbol-prefix="param_spec_uchar" c:type="GParamSpecUChar" parent="ParamSpec" glib:type-name="GParamUChar" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for unsigned character properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum">
        <doc xml:space="preserve">minimum value for the property specified</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="maximum">
        <doc xml:space="preserve">maximum value for the property specified</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
    </class>
    <class name="ParamSpecUInt" c:symbol-prefix="param_spec_uint" c:type="GParamSpecUInt" parent="ParamSpec" glib:type-name="GParamUInt" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for unsigned integer properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum">
        <doc xml:space="preserve">minimum value for the property specified</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="maximum">
        <doc xml:space="preserve">maximum value for the property specified</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="guint" c:type="guint"/>
      </field>
    </class>
    <class name="ParamSpecUInt64" c:symbol-prefix="param_spec_uint64" c:type="GParamSpecUInt64" parent="ParamSpec" glib:type-name="GParamUInt64" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum">
        <doc xml:space="preserve">minimum value for the property specified</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="maximum">
        <doc xml:space="preserve">maximum value for the property specified</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
    </class>
    <class name="ParamSpecULong" c:symbol-prefix="param_spec_ulong" c:type="GParamSpecULong" parent="ParamSpec" glib:type-name="GParamULong" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for unsigned long integer properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum">
        <doc xml:space="preserve">minimum value for the property specified</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="maximum">
        <doc xml:space="preserve">maximum value for the property specified</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
    </class>
    <class name="ParamSpecUnichar" c:symbol-prefix="param_spec_unichar" c:type="GParamSpecUnichar" parent="ParamSpec" glib:type-name="GParamUnichar" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">default value for the property specified</doc>
        <type name="gunichar" c:type="gunichar"/>
      </field>
    </class>
    <class name="ParamSpecValueArray" c:symbol-prefix="param_spec_value_array" c:type="GParamSpecValueArray" parent="ParamSpec" glib:type-name="GParamValueArray" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for #GValueArray properties.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="element_spec">
        <doc xml:space="preserve">a #GParamSpec describing the elements contained in arrays of this property, may be %NULL</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </field>
      <field name="fixed_n_elements">
        <doc xml:space="preserve">if greater than 0, arrays of this property will always have this many elements</doc>
        <type name="guint" c:type="guint"/>
      </field>
    </class>
    <class name="ParamSpecVariant" c:symbol-prefix="param_spec_variant" c:type="GParamSpecVariant" version="2.26" parent="ParamSpec" glib:type-name="GParamVariant" glib:get-type="intern" glib:fundamental="1">
      <doc xml:space="preserve">A #GParamSpec derived structure that contains the meta data for #GVariant properties.

When comparing values with g_param_values_cmp(), scalar values with the same
type will be compared with g_variant_compare(). Other non-%NULL variants will
be checked for equality with g_variant_equal(), and their sort order is
otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL
values compare equal.</doc>
      <field name="parent_instance">
        <doc xml:space="preserve">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="type">
        <doc xml:space="preserve">a #GVariantType, or %NULL</doc>
        <type name="GLib.VariantType" c:type="GVariantType*"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve">a #GVariant, or %NULL</doc>
        <type name="GLib.Variant" c:type="GVariant*"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="Parameter" c:type="GParameter" deprecated="1" deprecated-version="2.54">
      <doc xml:space="preserve">The GParameter struct is an auxiliary structure used
to hand parameter name/value pairs to g_object_newv().</doc>
      <doc-deprecated xml:space="preserve">This type is not introspectable.</doc-deprecated>
      <field name="name" writable="1">
        <doc xml:space="preserve">the parameter name</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="value" writable="1">
        <doc xml:space="preserve">the parameter value</doc>
        <type name="Value" c:type="GValue"/>
      </field>
    </record>
    <glib:boxed glib:name="PatternSpec" c:symbol-prefix="pattern_spec" glib:type-name="GPatternSpec" glib:get-type="g_pattern_spec_get_type">
    </glib:boxed>
    <glib:boxed glib:name="PollFD" c:symbol-prefix="pollfd" glib:type-name="GPollFD" glib:get-type="g_pollfd_get_type">
    </glib:boxed>
    <glib:boxed glib:name="PtrArray" c:symbol-prefix="ptr_array" glib:type-name="GPtrArray" glib:get-type="g_ptr_array_get_type">
    </glib:boxed>
    <glib:boxed glib:name="Rand" c:symbol-prefix="rand" glib:type-name="GRand" glib:get-type="g_rand_get_type">
    </glib:boxed>
    <glib:boxed glib:name="Regex" c:symbol-prefix="regex" glib:type-name="GRegex" glib:get-type="g_regex_get_type">
    </glib:boxed>
    <constant name="SIGNAL_FLAGS_MASK" value="511" c:type="G_SIGNAL_FLAGS_MASK">
      <doc xml:space="preserve">A mask for all #GSignalFlags bits.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="SIGNAL_GROUP" c:identifier="G_SIGNAL_GROUP" introspectable="0">
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="SIGNAL_MATCH_MASK" value="63" c:type="G_SIGNAL_MATCH_MASK">
      <doc xml:space="preserve">A mask for all #GSignalMatchType bits.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <callback name="SignalAccumulator" c:type="GSignalAccumulator">
      <doc xml:space="preserve">The signal accumulator is a special callback function that can be used
to collect return values of the various callbacks that are called
during a signal emission.

The signal accumulator is specified at signal creation time, if it is
left %NULL, no accumulation of callback return values is performed.
The return value of signal emissions is then the value returned by the
last callback.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The accumulator function returns whether the signal emission
 should be aborted. Returning %TRUE will continue with
 the signal emission. Returning %FALSE will abort the current emission.
 Since 2.62, returning %FALSE will skip to the CLEANUP stage. In this case,
 emission will occur as normal in the CLEANUP stage and the handler's
 return value will be accumulated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ihint" transfer-ownership="none">
          <doc xml:space="preserve">Signal invocation hint, see #GSignalInvocationHint.</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*"/>
        </parameter>
        <parameter name="return_accu" transfer-ownership="none">
          <doc xml:space="preserve">Accumulator to collect callback return values in, this
 is the return value of the current signal emission.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="handler_return" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue holding the return value of the signal handler.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Callback data that was specified when creating the signal.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SignalEmissionHook" c:type="GSignalEmissionHook">
      <doc xml:space="preserve">A simple function pointer to get invoked when the signal is emitted.

Emission hooks allow you to tie a hook to the signal type, so that it will
trap all emissions of that signal, from any object.

You may not attach these to signals created with the %G_SIGNAL_NO_HOOKS flag.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether it wants to stay connected. If it returns %FALSE, the signal
 hook is disconnected (and destroyed).</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ihint" transfer-ownership="none">
          <doc xml:space="preserve">Signal invocation hint, see #GSignalInvocationHint.</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">the number of parameters to the function, including
 the instance on which the signal was emitted.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">the instance on which
 the signal was emitted, followed by the parameters of the emission.</doc>
          <array length="1" zero-terminated="0" c:type="const GValue*">
            <type name="Value" c:type="GValue"/>
          </array>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data associated with the hook.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="SignalFlags" c:type="GSignalFlags">
      <doc xml:space="preserve">The signal flags are used to specify a signal's behaviour.</doc>
      <member name="run_first" value="1" c:identifier="G_SIGNAL_RUN_FIRST">
        <doc xml:space="preserve">Invoke the object method handler in the first emission stage.</doc>
      </member>
      <member name="run_last" value="2" c:identifier="G_SIGNAL_RUN_LAST">
        <doc xml:space="preserve">Invoke the object method handler in the third emission stage.</doc>
      </member>
      <member name="run_cleanup" value="4" c:identifier="G_SIGNAL_RUN_CLEANUP">
        <doc xml:space="preserve">Invoke the object method handler in the last emission stage.</doc>
      </member>
      <member name="no_recurse" value="8" c:identifier="G_SIGNAL_NO_RECURSE">
        <doc xml:space="preserve">Signals being emitted for an object while currently being in
 emission for this very object will not be emitted recursively,
 but instead cause the first emission to be restarted.</doc>
      </member>
      <member name="detailed" value="16" c:identifier="G_SIGNAL_DETAILED">
        <doc xml:space="preserve">This signal supports "::detail" appendices to the signal name
 upon handler connections and emissions.</doc>
      </member>
      <member name="action" value="32" c:identifier="G_SIGNAL_ACTION">
        <doc xml:space="preserve">Action signals are signals that may freely be emitted on alive
 objects from user code via g_signal_emit() and friends, without
 the need of being embedded into extra code that performs pre or
 post emission adjustments on the object. They can also be thought
 of as object methods which can be called generically by
 third-party code.</doc>
      </member>
      <member name="no_hooks" value="64" c:identifier="G_SIGNAL_NO_HOOKS">
        <doc xml:space="preserve">No emissions hooks are supported for this signal.</doc>
      </member>
      <member name="must_collect" value="128" c:identifier="G_SIGNAL_MUST_COLLECT">
        <doc xml:space="preserve">Varargs signal emission will always collect the
  arguments, even if there are no signal handlers connected.  Since 2.30.</doc>
      </member>
      <member name="deprecated" value="256" c:identifier="G_SIGNAL_DEPRECATED">
        <doc xml:space="preserve">The signal is deprecated and will be removed
  in a future version. A warning will be generated if it is connected while
  running with G_ENABLE_DIAGNOSTIC=1.  Since 2.32.</doc>
      </member>
      <member name="accumulator_first_run" value="131072" c:identifier="G_SIGNAL_ACCUMULATOR_FIRST_RUN">
        <doc xml:space="preserve">Only used in #GSignalAccumulator accumulator
  functions for the #GSignalInvocationHint::run_type field to mark the first
  call to the accumulator function for a signal emission.  Since 2.68.</doc>
      </member>
    </bitfield>
    <class name="SignalGroup" c:symbol-prefix="signal_group" c:type="GSignalGroup" version="2.72" parent="Object" glib:type-name="GSignalGroup" glib:get-type="g_signal_group_get_type">
      <doc xml:space="preserve">`GSignalGroup` manages a collection of signals on a `GObject`.

`GSignalGroup` simplifies the process of connecting  many signals to a `GObject`
as a group. As such there is no API to disconnect a signal from the group.

In particular, this allows you to:

 - Change the target instance, which automatically causes disconnection
   of the signals from the old instance and connecting to the new instance.
 - Block and unblock signals as a group
 - Ensuring that blocked state transfers across target instances.

One place you might want to use such a structure is with `GtkTextView` and
`GtkTextBuffer`. Often times, you'll need to connect to many signals on
`GtkTextBuffer` from a `GtkTextView` subclass. This allows you to create a
signal group during instance construction, simply bind the
`GtkTextView:buffer` property to `GSignalGroup:target` and connect
all the signals you need. When the `GtkTextView:buffer` property changes
all of the signals will be transitioned correctly.</doc>
      <constructor name="new" c:identifier="g_signal_group_new" version="2.72">
        <doc xml:space="preserve">Creates a new #GSignalGroup for target instances of @target_type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSignalGroup</doc>
          <type name="SignalGroup" c:type="GSignalGroup*"/>
        </return-value>
        <parameters>
          <parameter name="target_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the target instance.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="block" c:identifier="g_signal_group_block" version="2.72">
        <doc xml:space="preserve">Blocks all signal handlers managed by @self so they will not
be called during any signal emissions. Must be unblocked exactly
the same number of times it has been blocked to become active again.

This blocked state will be kept across changes of the target instance.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GSignalGroup</doc>
            <type name="SignalGroup" c:type="GSignalGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="connect" c:identifier="g_signal_group_connect" version="2.72" introspectable="0">
        <doc xml:space="preserve">Connects @c_handler to the signal @detailed_signal
on the target instance of @self.

You cannot connect a signal handler after #GSignalGroup:target has been set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSignalGroup</doc>
            <type name="SignalGroup" c:type="GSignalGroup*"/>
          </instance-parameter>
          <parameter name="detailed_signal" transfer-ownership="none">
            <doc xml:space="preserve">a string of the form "signal-name::detail"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="c_handler" transfer-ownership="none" scope="notified" closure="2">
            <doc xml:space="preserve">the #GCallback to connect</doc>
            <type name="Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @c_handler calls</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_after" c:identifier="g_signal_group_connect_after" version="2.72" introspectable="0">
        <doc xml:space="preserve">Connects @c_handler to the signal @detailed_signal
on the target instance of @self.

The @c_handler will be called after the default handler of the signal.

You cannot connect a signal handler after #GSignalGroup:target has been set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSignalGroup</doc>
            <type name="SignalGroup" c:type="GSignalGroup*"/>
          </instance-parameter>
          <parameter name="detailed_signal" transfer-ownership="none">
            <doc xml:space="preserve">a string of the form "signal-name::detail"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="c_handler" transfer-ownership="none" scope="notified" closure="2">
            <doc xml:space="preserve">the #GCallback to connect</doc>
            <type name="Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @c_handler calls</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_closure" c:identifier="g_signal_group_connect_closure" version="2.74">
        <doc xml:space="preserve">Connects @closure to the signal @detailed_signal on #GSignalGroup:target.

You cannot connect a signal handler after #GSignalGroup:target has been set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSignalGroup</doc>
            <type name="SignalGroup" c:type="GSignalGroup*"/>
          </instance-parameter>
          <parameter name="detailed_signal" transfer-ownership="none">
            <doc xml:space="preserve">a string of the form `signal-name` with optional `::signal-detail`</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">the closure to connect.</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="after" transfer-ownership="none">
            <doc xml:space="preserve">whether the handler should be called before or after the
 default handler of the signal.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_data" c:identifier="g_signal_group_connect_data" version="2.72">
        <doc xml:space="preserve">Connects @c_handler to the signal @detailed_signal
on the target instance of @self.

You cannot connect a signal handler after #GSignalGroup:target has been set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSignalGroup</doc>
            <type name="SignalGroup" c:type="GSignalGroup*"/>
          </instance-parameter>
          <parameter name="detailed_signal" transfer-ownership="none">
            <doc xml:space="preserve">a string of the form "signal-name::detail"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="c_handler" transfer-ownership="none" scope="notified" closure="2" destroy="3">
            <doc xml:space="preserve">the #GCallback to connect</doc>
            <type name="Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @c_handler calls</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="notified">
            <doc xml:space="preserve">function to be called when disposing of @self</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the flags used to create the signal connection</doc>
            <type name="ConnectFlags" c:type="GConnectFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_object" c:identifier="g_signal_group_connect_object" version="2.72" introspectable="0">
        <doc xml:space="preserve">Connects @c_handler to the signal @detailed_signal on #GSignalGroup:target.

Ensures that the @object stays alive during the call to @c_handler
by temporarily adding a reference count. When the @object is destroyed
the signal handler will automatically be removed.

You cannot connect a signal handler after #GSignalGroup:target has been set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSignalGroup</doc>
            <type name="SignalGroup" c:type="GSignalGroup*"/>
          </instance-parameter>
          <parameter name="detailed_signal" transfer-ownership="none">
            <doc xml:space="preserve">a string of the form `signal-name` with optional `::signal-detail`</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="c_handler" transfer-ownership="none" scope="notified">
            <doc xml:space="preserve">the #GCallback to connect</doc>
            <type name="Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">the #GObject to pass as data to @c_handler calls</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GConnectFlags for the signal connection</doc>
            <type name="ConnectFlags" c:type="GConnectFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_swapped" c:identifier="g_signal_group_connect_swapped" version="2.72">
        <doc xml:space="preserve">Connects @c_handler to the signal @detailed_signal
on the target instance of @self.

The instance on which the signal is emitted and @data
will be swapped when calling @c_handler.

You cannot connect a signal handler after #GSignalGroup:target has been set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GSignalGroup</doc>
            <type name="SignalGroup" c:type="GSignalGroup*"/>
          </instance-parameter>
          <parameter name="detailed_signal" transfer-ownership="none">
            <doc xml:space="preserve">a string of the form "signal-name::detail"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="c_handler" transfer-ownership="none" scope="async" closure="2">
            <doc xml:space="preserve">the #GCallback to connect</doc>
            <type name="Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the data to pass to @c_handler calls</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_target" c:identifier="g_signal_group_dup_target" version="2.72">
        <doc xml:space="preserve">Gets the target instance used when connecting signals.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">The target instance</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GSignalGroup</doc>
            <type name="SignalGroup" c:type="GSignalGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_target" c:identifier="g_signal_group_set_target" glib:set-property="target" version="2.72">
        <doc xml:space="preserve">Sets the target instance used when connecting signals. Any signal
that has been registered with g_signal_group_connect_object() or
similar functions will be connected to this object.

If the target instance was previously set, signals will be
disconnected from that object prior to connecting to @target.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GSignalGroup.</doc>
            <type name="SignalGroup" c:type="GSignalGroup*"/>
          </instance-parameter>
          <parameter name="target" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">The target instance used
    when connecting signals.</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock" c:identifier="g_signal_group_unblock" version="2.72">
        <doc xml:space="preserve">Unblocks all signal handlers managed by @self so they will be
called again during any signal emissions unless it is blocked
again. Must be unblocked exactly the same number of times it
has been blocked to become active again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GSignalGroup</doc>
            <type name="SignalGroup" c:type="GSignalGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="target" version="2.72" writable="1" transfer-ownership="none" setter="set_target">
        <doc xml:space="preserve">The target instance used when connecting signals.</doc>
        <type name="Object"/>
      </property>
      <property name="target-type" version="2.72" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GType of the target property.</doc>
        <type name="GType" c:type="GType"/>
      </property>
      <glib:signal name="bind" when="last" version="2.72">
        <doc xml:space="preserve">This signal is emitted when #GSignalGroup:target is set to a new value
other than %NULL. It is similar to #GObject::notify on `target` except it
will not emit when #GSignalGroup:target is %NULL and also allows for
receiving the #GObject without a data-race.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject containing the new value for #GSignalGroup:target</doc>
            <type name="Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="unbind" when="last" version="2.72">
        <doc xml:space="preserve">This signal is emitted when the target instance of @self is set to a
new #GObject.

This signal will only be emitted if the previous target of @self is
non-%NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="SignalInvocationHint" c:type="GSignalInvocationHint">
      <doc xml:space="preserve">The #GSignalInvocationHint structure is used to pass on additional information
to callbacks during a signal emission.</doc>
      <field name="signal_id" writable="1">
        <doc xml:space="preserve">The signal id of the signal invoking the callback</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="detail" writable="1">
        <doc xml:space="preserve">The detail passed on for this emission</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="run_type" writable="1">
        <doc xml:space="preserve">The stage the signal emission is currently in, this
 field will contain one of %G_SIGNAL_RUN_FIRST,
 %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP and %G_SIGNAL_ACCUMULATOR_FIRST_RUN.
 %G_SIGNAL_ACCUMULATOR_FIRST_RUN is only set for the first run of the accumulator
 function for a signal emission.</doc>
        <type name="SignalFlags" c:type="GSignalFlags"/>
      </field>
    </record>
    <bitfield name="SignalMatchType" c:type="GSignalMatchType">
      <doc xml:space="preserve">The match types specify what g_signal_handlers_block_matched(),
g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
match signals by.</doc>
      <member name="id" value="1" c:identifier="G_SIGNAL_MATCH_ID">
        <doc xml:space="preserve">The signal id must be equal.</doc>
      </member>
      <member name="detail" value="2" c:identifier="G_SIGNAL_MATCH_DETAIL">
        <doc xml:space="preserve">The signal detail must be equal.</doc>
      </member>
      <member name="closure" value="4" c:identifier="G_SIGNAL_MATCH_CLOSURE">
        <doc xml:space="preserve">The closure must be the same.</doc>
      </member>
      <member name="func" value="8" c:identifier="G_SIGNAL_MATCH_FUNC">
        <doc xml:space="preserve">The C closure callback must be the same.</doc>
      </member>
      <member name="data" value="16" c:identifier="G_SIGNAL_MATCH_DATA">
        <doc xml:space="preserve">The closure data must be the same.</doc>
      </member>
      <member name="unblocked" value="32" c:identifier="G_SIGNAL_MATCH_UNBLOCKED">
        <doc xml:space="preserve">Only unblocked signals may be matched.</doc>
      </member>
    </bitfield>
    <record name="SignalQuery" c:type="GSignalQuery">
      <doc xml:space="preserve">A structure holding in-depth information for a specific signal.

See also: g_signal_query()</doc>
      <field name="signal_id" writable="1">
        <doc xml:space="preserve">The signal id of the signal being queried, or 0 if the
 signal to be queried was unknown.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="signal_name" writable="1">
        <doc xml:space="preserve">The signal name.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="itype" writable="1">
        <doc xml:space="preserve">The interface/instance type that this signal can be emitted for.</doc>
        <type name="GType" c:type="GType"/>
      </field>
      <field name="signal_flags" writable="1">
        <doc xml:space="preserve">The signal flags as passed in to g_signal_new().</doc>
        <type name="SignalFlags" c:type="GSignalFlags"/>
      </field>
      <field name="return_type" writable="1">
        <doc xml:space="preserve">The return type for user callbacks.</doc>
        <type name="GType" c:type="GType"/>
      </field>
      <field name="n_params" writable="1">
        <doc xml:space="preserve">The number of parameters that user callbacks take.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="param_types" writable="1">
        <doc xml:space="preserve">The individual parameter types for
 user callbacks, note that the effective callback signature is:
 |[&lt;!-- language="C" --&gt;
 @return_type callback (#gpointer     data1,
 [param_types param_names,]
 gpointer     data2);
 ]|</doc>
        <array length="5" zero-terminated="0" c:type="const GType*">
          <type name="GType" c:type="GType"/>
        </array>
      </field>
    </record>
    <glib:boxed glib:name="Source" c:symbol-prefix="source" glib:type-name="GSource" glib:get-type="g_source_get_type">
      <function name="set_closure" c:identifier="g_source_set_closure">
        <doc xml:space="preserve">Set the callback for a source as a #GClosure.

If the source is not one of the standard GLib types, the @closure_callback
and @closure_marshal fields of the #GSourceFuncs structure must have been
filled in with pointers to appropriate functions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the source</doc>
            <type name="GLib.Source" c:type="GSource*"/>
          </parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_dummy_callback" c:identifier="g_source_set_dummy_callback">
        <doc xml:space="preserve">Sets a dummy callback for @source. The callback will do nothing, and
if the source expects a #gboolean return value, it will return %TRUE.
(If the source expects any other type of return value, it will return
a 0/%NULL value; whatever g_value_init() initializes a #GValue to for
that type.)

If the source is not one of the standard GLib types, the
@closure_callback and @closure_marshal fields of the #GSourceFuncs
structure must have been filled in with pointers to appropriate
functions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the source</doc>
            <type name="GLib.Source" c:type="GSource*"/>
          </parameter>
        </parameters>
      </function>
    </glib:boxed>
    <glib:boxed glib:name="String" c:symbol-prefix="gstring" glib:type-name="GString" glib:get-type="g_gstring_get_type">
    </glib:boxed>
    <glib:boxed glib:name="Strv" c:symbol-prefix="strv" glib:type-name="GStrv" glib:get-type="g_strv_get_type">
    </glib:boxed>
    <glib:boxed glib:name="StrvBuilder" c:symbol-prefix="strv_builder" glib:type-name="GStrvBuilder" glib:get-type="g_strv_builder_get_type">
    </glib:boxed>
    <function-macro name="TYPE_CHECK_CLASS_CAST" c:identifier="G_TYPE_CHECK_CLASS_CAST" introspectable="0">
      <doc xml:space="preserve">Checks that @g_class is a class structure of the type identified by @g_type
and issues a warning if this is not the case. Returns @g_class casted
to a pointer to @c_type. %NULL is not a valid class structure.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="g_class">
          <doc xml:space="preserve">Location of a #GTypeClass structure</doc>
        </parameter>
        <parameter name="g_type">
          <doc xml:space="preserve">The type to be returned</doc>
        </parameter>
        <parameter name="c_type">
          <doc xml:space="preserve">The corresponding C type of class structure of @g_type</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_CHECK_CLASS_TYPE" c:identifier="G_TYPE_CHECK_CLASS_TYPE" introspectable="0">
      <doc xml:space="preserve">Checks if @g_class is a class structure of the type identified by
@g_type. If @g_class is %NULL, %FALSE will be returned.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="g_class">
          <doc xml:space="preserve">Location of a #GTypeClass structure</doc>
        </parameter>
        <parameter name="g_type">
          <doc xml:space="preserve">The type to be checked</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_CHECK_INSTANCE" c:identifier="G_TYPE_CHECK_INSTANCE" introspectable="0">
      <doc xml:space="preserve">Checks if @instance is a valid #GTypeInstance structure,
otherwise issues a warning and returns %FALSE. %NULL is not a valid
#GTypeInstance.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">Location of a #GTypeInstance structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_CHECK_INSTANCE_CAST" c:identifier="G_TYPE_CHECK_INSTANCE_CAST" introspectable="0">
      <doc xml:space="preserve">Checks that @instance is an instance of the type identified by @g_type
and issues a warning if this is not the case. Returns @instance casted
to a pointer to @c_type.

No warning will be issued if @instance is %NULL, and %NULL will be returned.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">Location of a #GTypeInstance structure</doc>
        </parameter>
        <parameter name="g_type">
          <doc xml:space="preserve">The type to be returned</doc>
        </parameter>
        <parameter name="c_type">
          <doc xml:space="preserve">The corresponding C type of @g_type</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE" c:identifier="G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE" introspectable="0">
      <doc xml:space="preserve">Checks if @instance is an instance of the fundamental type identified by @g_type.
If @instance is %NULL, %FALSE will be returned.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">Location of a #GTypeInstance structure.</doc>
        </parameter>
        <parameter name="g_type">
          <doc xml:space="preserve">The fundamental type to be checked</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_CHECK_INSTANCE_TYPE" c:identifier="G_TYPE_CHECK_INSTANCE_TYPE" introspectable="0">
      <doc xml:space="preserve">Checks if @instance is an instance of the type identified by @g_type. If
@instance is %NULL, %FALSE will be returned.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">Location of a #GTypeInstance structure.</doc>
        </parameter>
        <parameter name="g_type">
          <doc xml:space="preserve">The type to be checked</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_CHECK_VALUE" c:identifier="G_TYPE_CHECK_VALUE" introspectable="0">
      <doc xml:space="preserve">Checks if @value has been initialized to hold values
of a value type.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a #GValue</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_CHECK_VALUE_TYPE" c:identifier="G_TYPE_CHECK_VALUE_TYPE" introspectable="0">
      <doc xml:space="preserve">Checks if @value has been initialized to hold values
of type @g_type.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a #GValue</doc>
        </parameter>
        <parameter name="g_type">
          <doc xml:space="preserve">The type to be checked</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_CLASS_GET_PRIVATE" c:identifier="G_TYPE_CLASS_GET_PRIVATE" version="2.24" introspectable="0">
      <doc xml:space="preserve">Gets the private class structure for a particular type.

The private structure must have been registered in the
get_type() function with g_type_add_class_private().

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="klass">
          <doc xml:space="preserve">the class of a type deriving from @private_type</doc>
        </parameter>
        <parameter name="g_type">
          <doc xml:space="preserve">the type identifying which private data to retrieve</doc>
        </parameter>
        <parameter name="c_type">
          <doc xml:space="preserve">The C type for the private structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="TYPE_FLAG_RESERVED_ID_BIT" value="1" c:type="G_TYPE_FLAG_RESERVED_ID_BIT">
      <doc xml:space="preserve">A bit in the type number that's supposed to be left untouched.</doc>
      <type name="Type" c:type="GType"/>
    </constant>
    <function-macro name="TYPE_FROM_CLASS" c:identifier="G_TYPE_FROM_CLASS" introspectable="0">
      <doc xml:space="preserve">Get the type identifier from a given @class structure.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="g_class">
          <doc xml:space="preserve">Location of a valid #GTypeClass structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_FROM_INSTANCE" c:identifier="G_TYPE_FROM_INSTANCE" introspectable="0">
      <doc xml:space="preserve">Get the type identifier from a given @instance structure.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">Location of a valid #GTypeInstance structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_FROM_INTERFACE" c:identifier="G_TYPE_FROM_INTERFACE" introspectable="0">
      <doc xml:space="preserve">Get the type identifier from a given @interface structure.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="g_iface">
          <doc xml:space="preserve">Location of a valid #GTypeInterface structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_FUNDAMENTAL" c:identifier="G_TYPE_FUNDAMENTAL" introspectable="0">
      <doc xml:space="preserve">The fundamental type which is the ancestor of @type.

Fundamental types are types that serve as ultimate bases for the derived types,
thus they are the roots of distinct inheritance hierarchies.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="TYPE_FUNDAMENTAL_MAX" value="1020" c:type="G_TYPE_FUNDAMENTAL_MAX">
      <doc xml:space="preserve">An integer constant that represents the number of identifiers reserved
for types that are assigned at compile-time.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TYPE_FUNDAMENTAL_SHIFT" value="2" c:type="G_TYPE_FUNDAMENTAL_SHIFT">
      <doc xml:space="preserve">Shift value used in converting numbers to type IDs.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="TYPE_HAS_VALUE_TABLE" c:identifier="G_TYPE_HAS_VALUE_TABLE" introspectable="0">
      <doc xml:space="preserve">Checks if @type has a #GTypeValueTable.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_INSTANCE_GET_CLASS" c:identifier="G_TYPE_INSTANCE_GET_CLASS" introspectable="0">
      <doc xml:space="preserve">Get the class structure of a given @instance, casted
to a specified ancestor type @g_type of the instance.

Note that while calling a GInstanceInitFunc(), the class pointer
gets modified, so it might not always return the expected pointer.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">Location of the #GTypeInstance structure</doc>
        </parameter>
        <parameter name="g_type">
          <doc xml:space="preserve">The #GType of the class to be returned</doc>
        </parameter>
        <parameter name="c_type">
          <doc xml:space="preserve">The C type of the class structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_INSTANCE_GET_INTERFACE" c:identifier="G_TYPE_INSTANCE_GET_INTERFACE" introspectable="0">
      <doc xml:space="preserve">Get the interface structure for interface @g_type of a given @instance.

This macro should only be used in type implementations.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">Location of the #GTypeInstance structure</doc>
        </parameter>
        <parameter name="g_type">
          <doc xml:space="preserve">The #GType of the interface to be returned</doc>
        </parameter>
        <parameter name="c_type">
          <doc xml:space="preserve">The C type of the interface structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_INSTANCE_GET_PRIVATE" c:identifier="G_TYPE_INSTANCE_GET_PRIVATE" version="2.4" introspectable="0" deprecated="1" deprecated-version="2.58">
      <doc xml:space="preserve">Gets the private structure for a particular type.

The private structure must have been registered in the
class_init function with g_type_class_add_private().

This macro should only be used in type implementations.</doc>
      <doc-deprecated xml:space="preserve">Use G_ADD_PRIVATE() and the generated
  `your_type_get_instance_private()` function instead</doc-deprecated>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">the instance of a type deriving from @private_type</doc>
        </parameter>
        <parameter name="g_type">
          <doc xml:space="preserve">the type identifying which private data to retrieve</doc>
        </parameter>
        <parameter name="c_type">
          <doc xml:space="preserve">The C type for the private structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_ABSTRACT" c:identifier="G_TYPE_IS_ABSTRACT" introspectable="0">
      <doc xml:space="preserve">Checks if @type is an abstract type.  An abstract type cannot be
instantiated and is normally used as an abstract base class for
derived classes.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_BOXED" c:identifier="G_TYPE_IS_BOXED" introspectable="0">
      <parameters>
        <parameter name="type">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_CLASSED" c:identifier="G_TYPE_IS_CLASSED" introspectable="0">
      <doc xml:space="preserve">Checks if @type is a classed type.

A classed type has an associated #GTypeClass which can be derived to store
class-wide virtual function pointers and data for all instances of the type.
This allows for subclassing. All #GObjects are classed; none of the scalar
fundamental types built into GLib are classed.

Interfaces are not classed: while their #GTypeInterface struct could be
considered similar to #GTypeClass, and classes can derive interfaces,
#GTypeInterface doesn&#x2019;t allow for subclassing.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_DEEP_DERIVABLE" c:identifier="G_TYPE_IS_DEEP_DERIVABLE" introspectable="0">
      <doc xml:space="preserve">Checks if @type is a deep derivable type.  A deep derivable type
can be used as the base class of a deep (multi-level) class hierarchy.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_DEPRECATED" c:identifier="G_TYPE_IS_DEPRECATED" version="2.76" introspectable="0">
      <doc xml:space="preserve">Checks if @type is deprecated. Instantiating a deprecated type will
trigger a warning if running with `G_ENABLE_DIAGNOSTIC=1`.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">a #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_DERIVABLE" c:identifier="G_TYPE_IS_DERIVABLE" introspectable="0">
      <doc xml:space="preserve">Checks if @type is a derivable type.  A derivable type can
be used as the base class of a flat (single-level) class hierarchy.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_DERIVED" c:identifier="G_TYPE_IS_DERIVED" introspectable="0">
      <doc xml:space="preserve">Checks if @type is derived (or in object-oriented terminology:
inherited) from another type (this holds true for all non-fundamental
types).</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_ENUM" c:identifier="G_TYPE_IS_ENUM" introspectable="0">
      <doc xml:space="preserve">Checks whether @type "is a" %G_TYPE_ENUM.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">a #GType ID.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_FINAL" c:identifier="G_TYPE_IS_FINAL" version="2.70" introspectable="0">
      <doc xml:space="preserve">Checks if @type is a final type. A final type cannot be derived any
further.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">a #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_FLAGS" c:identifier="G_TYPE_IS_FLAGS" introspectable="0">
      <doc xml:space="preserve">Checks whether @type "is a" %G_TYPE_FLAGS.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">a #GType ID.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_FUNDAMENTAL" c:identifier="G_TYPE_IS_FUNDAMENTAL" introspectable="0">
      <doc xml:space="preserve">Checks if @type is a fundamental type.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_INSTANTIATABLE" c:identifier="G_TYPE_IS_INSTANTIATABLE" introspectable="0">
      <doc xml:space="preserve">Checks if @type can be instantiated.  Instantiation is the
process of creating an instance (object) of this type.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_INTERFACE" c:identifier="G_TYPE_IS_INTERFACE" introspectable="0">
      <doc xml:space="preserve">Checks if @type is an interface type.

An interface type provides a pure API, the implementation
of which is provided by another type (which is then said to conform
to the interface).  GLib interfaces are somewhat analogous to Java
interfaces and C++ classes containing only pure virtual functions,
with the difference that GType interfaces are not derivable (but see
g_type_interface_add_prerequisite() for an alternative).</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_OBJECT" c:identifier="G_TYPE_IS_OBJECT" introspectable="0">
      <doc xml:space="preserve">Check if the passed in type id is a %G_TYPE_OBJECT or derived from it.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">Type id to check</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_PARAM" c:identifier="G_TYPE_IS_PARAM" introspectable="0">
      <doc xml:space="preserve">Checks whether @type "is a" %G_TYPE_PARAM.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">a #GType ID</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_VALUE" c:identifier="G_TYPE_IS_VALUE" introspectable="0">
      <doc xml:space="preserve">Checks whether the passed in type ID can be used for g_value_init().

That is, this macro checks whether this type provides an implementation
of the #GTypeValueTable functions required for a type to create a #GValue of.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_VALUE_ABSTRACT" c:identifier="G_TYPE_IS_VALUE_ABSTRACT" introspectable="0">
      <doc xml:space="preserve">Checks if @type is an abstract value type.  An abstract value type introduces
a value table, but can't be used for g_value_init() and is normally used as
an abstract base type for derived value types.</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_IS_VALUE_TYPE" c:identifier="G_TYPE_IS_VALUE_TYPE" introspectable="0">
      <doc xml:space="preserve">Checks if @type is a value type and can be used with g_value_init().</doc>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_MAKE_FUNDAMENTAL" c:identifier="G_TYPE_MAKE_FUNDAMENTAL" introspectable="0">
      <doc xml:space="preserve">Get the type ID for the fundamental type number @x.

Use g_type_fundamental_next() instead of this macro to create new fundamental
types.</doc>
      <parameters>
        <parameter name="x">
          <doc xml:space="preserve">the fundamental type number.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_MODULE" c:identifier="G_TYPE_MODULE" introspectable="0">
      <parameters>
        <parameter name="module">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_MODULE_CLASS" c:identifier="G_TYPE_MODULE_CLASS" introspectable="0">
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_MODULE_GET_CLASS" c:identifier="G_TYPE_MODULE_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="module">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_PLUGIN" c:identifier="G_TYPE_PLUGIN" introspectable="0">
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_PLUGIN_CLASS" c:identifier="G_TYPE_PLUGIN_CLASS" introspectable="0">
      <parameters>
        <parameter name="vtable">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TYPE_PLUGIN_GET_CLASS" c:identifier="G_TYPE_PLUGIN_GET_CLASS" introspectable="0">
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="TYPE_RESERVED_BSE_FIRST" value="32" c:type="G_TYPE_RESERVED_BSE_FIRST">
      <doc xml:space="preserve">First fundamental type number to create a new fundamental type id with
G_TYPE_MAKE_FUNDAMENTAL() reserved for BSE.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TYPE_RESERVED_BSE_LAST" value="48" c:type="G_TYPE_RESERVED_BSE_LAST">
      <doc xml:space="preserve">Last fundamental type number reserved for BSE.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TYPE_RESERVED_GLIB_FIRST" value="22" c:type="G_TYPE_RESERVED_GLIB_FIRST">
      <doc xml:space="preserve">First fundamental type number to create a new fundamental type id with
G_TYPE_MAKE_FUNDAMENTAL() reserved for GLib.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TYPE_RESERVED_GLIB_LAST" value="31" c:type="G_TYPE_RESERVED_GLIB_LAST">
      <doc xml:space="preserve">Last fundamental type number reserved for GLib.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TYPE_RESERVED_USER_FIRST" value="49" c:type="G_TYPE_RESERVED_USER_FIRST">
      <doc xml:space="preserve">First available fundamental type number to create new fundamental
type id with G_TYPE_MAKE_FUNDAMENTAL().</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <glib:boxed glib:name="Thread" c:symbol-prefix="thread" glib:type-name="GThread" glib:get-type="g_thread_get_type">
    </glib:boxed>
    <glib:boxed glib:name="TimeZone" c:symbol-prefix="time_zone" glib:type-name="GTimeZone" glib:get-type="g_time_zone_get_type">
    </glib:boxed>
    <callback name="ToggleNotify" c:type="GToggleNotify">
      <doc xml:space="preserve">A callback function used for notification when the state
of a toggle reference changes.

See also: g_object_add_toggle_ref()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Callback data passed to g_object_add_toggle_ref()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">The object on which g_object_add_toggle_ref() was called.</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
        <parameter name="is_last_ref" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the toggle reference is now the
 last reference to the object. %FALSE if the toggle
 reference was the last reference and there are now other
 references.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="Tree" c:symbol-prefix="tree" glib:type-name="GTree" glib:get-type="g_tree_get_type">
    </glib:boxed>
    <union name="TypeCValue" c:type="GTypeCValue">
      <doc xml:space="preserve">A union holding one collected value.</doc>
      <field name="v_int" writable="1">
        <doc xml:space="preserve">the field for holding integer values</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="v_long" writable="1">
        <doc xml:space="preserve">the field for holding long integer values</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="v_int64" writable="1">
        <doc xml:space="preserve">the field for holding 64 bit integer values</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="v_double" writable="1">
        <doc xml:space="preserve">the field for holding floating point values</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="v_pointer" writable="1">
        <doc xml:space="preserve">the field for holding pointers</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </union>
    <record name="TypeClass" c:type="GTypeClass">
      <doc xml:space="preserve">An opaque structure used as the base of all classes.</doc>
      <field name="g_type" readable="0" private="1">
        <type name="GType" c:type="GType"/>
      </field>
      <method name="add_private" c:identifier="g_type_class_add_private" version="2.4" deprecated="1" deprecated-version="2.58">
        <doc xml:space="preserve">Registers a private structure for an instantiatable type.

When an object is allocated, the private structures for
the type and all of its parent types are allocated
sequentially in the same memory block as the public
structures, and are zero-filled.

Note that the accumulated size of the private structures of
a type and all its parent types cannot exceed 64 KiB.

This function should be called in the type's class_init() function.
The private structure can be retrieved using the
G_TYPE_INSTANCE_GET_PRIVATE() macro.

The following example shows attaching a private structure
MyObjectPrivate to an object MyObject defined in the standard
GObject fashion in the type's class_init() function.

Note the use of a structure member "priv" to avoid the overhead
of repeatedly calling MY_OBJECT_GET_PRIVATE().

|[&lt;!-- language="C" --&gt;
typedef struct _MyObject        MyObject;
typedef struct _MyObjectPrivate MyObjectPrivate;

struct _MyObject {
 GObject parent;

 MyObjectPrivate *priv;
};

struct _MyObjectPrivate {
  int some_field;
};

static void
my_object_class_init (MyObjectClass *klass)
{
  g_type_class_add_private (klass, sizeof (MyObjectPrivate));
}

static void
my_object_init (MyObject *my_object)
{
  my_object-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (my_object,
                                                 MY_TYPE_OBJECT,
                                                 MyObjectPrivate);
  // my_object-&gt;priv-&gt;some_field will be automatically initialised to 0
}

static int
my_object_get_some_field (MyObject *my_object)
{
  MyObjectPrivate *priv;

  g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);

  priv = my_object-&gt;priv;

  return priv-&gt;some_field;
}
]|</doc>
        <doc-deprecated xml:space="preserve">Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`
  family of macros to add instance private data to a type</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="g_class" transfer-ownership="none">
            <doc xml:space="preserve">class structure for an instantiatable
   type</doc>
            <type name="TypeClass" c:type="gpointer"/>
          </instance-parameter>
          <parameter name="private_size" transfer-ownership="none">
            <doc xml:space="preserve">size of private structure</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_instance_private_offset" c:identifier="g_type_class_get_instance_private_offset" version="2.38" introspectable="0">
        <doc xml:space="preserve">Gets the offset of the private data for instances of @g_class.

This is how many bytes you should add to the instance pointer of a
class in order to get the private data for the type represented by
@g_class.

You can only call this function after you have registered a private
data area for @g_class using g_type_class_add_private().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset, in bytes</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="g_class" transfer-ownership="none">
            <doc xml:space="preserve">a #GTypeClass</doc>
            <type name="TypeClass" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private" c:identifier="g_type_class_get_private">
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="klass" transfer-ownership="none">
            <type name="TypeClass" c:type="GTypeClass*"/>
          </instance-parameter>
          <parameter name="private_type" transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_parent" c:identifier="g_type_class_peek_parent">
        <doc xml:space="preserve">This is a convenience function often needed in class initializers.
It returns the class structure of the immediate parent type of the
class passed in.  Since derived classes hold a reference count on
their parent classes as long as they are instantiated, the returned
class will always exist.

This function is essentially equivalent to:
g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)))</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the parent class
    of @g_class</doc>
          <type name="TypeClass" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="g_class" transfer-ownership="none">
            <doc xml:space="preserve">the #GTypeClass structure to
    retrieve the parent class for</doc>
            <type name="TypeClass" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_type_class_unref">
        <doc xml:space="preserve">Decrements the reference count of the class structure being passed in.
Once the last reference count of a class has been released, classes
may be finalized by the type system, so further dereferencing of a
class pointer after g_type_class_unref() are invalid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="g_class" transfer-ownership="none">
            <doc xml:space="preserve">a #GTypeClass structure to unref</doc>
            <type name="TypeClass" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref_uncached" c:identifier="g_type_class_unref_uncached" introspectable="0">
        <doc xml:space="preserve">A variant of g_type_class_unref() for use in #GTypeClassCacheFunc
implementations. It unreferences a class without consulting the chain
of #GTypeClassCacheFuncs, avoiding the recursion which would occur
otherwise.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="g_class" transfer-ownership="none">
            <doc xml:space="preserve">a #GTypeClass structure to unref</doc>
            <type name="TypeClass" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="adjust_private_offset" c:identifier="g_type_class_adjust_private_offset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_class" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="private_size_or_offset" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="peek" c:identifier="g_type_class_peek">
        <doc xml:space="preserve">This function is essentially the same as g_type_class_ref(),
except that the classes reference count isn't incremented.
As a consequence, this function may return %NULL if the class
of the type passed in does not currently exist (hasn't been
referenced before).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GTypeClass
    structure for the given type ID or %NULL if the class does not
    currently exist</doc>
          <type name="TypeClass" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type ID of a classed type</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
      <function name="peek_static" c:identifier="g_type_class_peek_static" version="2.4">
        <doc xml:space="preserve">A more efficient version of g_type_class_peek() which works only for
static types.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GTypeClass
    structure for the given type ID or %NULL if the class does not
    currently exist or is dynamically loaded</doc>
          <type name="TypeClass" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type ID of a classed type</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
      <function name="ref" c:identifier="g_type_class_ref">
        <doc xml:space="preserve">Increments the reference count of the class structure belonging to
@type. This function will demand-create the class if it doesn't
exist already.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GTypeClass
    structure for the given type ID</doc>
          <type name="TypeClass" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type ID of a classed type</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="TypeClassCacheFunc" c:type="GTypeClassCacheFunc">
      <doc xml:space="preserve">A callback function which is called when the reference count of a class
drops to zero.

It may use g_type_class_ref() to prevent the class from being freed. You
should not call g_type_class_unref() from a #GTypeClassCacheFunc function
to prevent infinite recursion, use g_type_class_unref_uncached() instead.

The functions have to check the class id passed in to figure
whether they actually want to cache the class of this type, since all
classes are routed through the same #GTypeClassCacheFunc chain.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE to stop further #GTypeClassCacheFuncs from being
 called, %FALSE to continue</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="cache_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data that was given to the g_type_add_class_cache_func() call</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:space="preserve">The #GTypeClass structure which is
   unreferenced</doc>
          <type name="TypeClass" c:type="GTypeClass*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="TypeDebugFlags" deprecated="1" deprecated-version="2.36" c:type="GTypeDebugFlags">
      <doc xml:space="preserve">These flags used to be passed to g_type_init_with_debug_flags() which
is now deprecated.

If you need to enable debugging features, use the `GOBJECT_DEBUG`
environment variable.</doc>
      <doc-deprecated xml:space="preserve">g_type_init() is now done automatically</doc-deprecated>
      <member name="none" value="0" c:identifier="G_TYPE_DEBUG_NONE">
        <doc xml:space="preserve">Print no messages</doc>
      </member>
      <member name="objects" value="1" c:identifier="G_TYPE_DEBUG_OBJECTS">
        <doc xml:space="preserve">Print messages about object bookkeeping</doc>
      </member>
      <member name="signals" value="2" c:identifier="G_TYPE_DEBUG_SIGNALS">
        <doc xml:space="preserve">Print messages about signal emissions</doc>
      </member>
      <member name="instance_count" value="4" c:identifier="G_TYPE_DEBUG_INSTANCE_COUNT">
        <doc xml:space="preserve">Keep a count of instances of each type</doc>
      </member>
      <member name="mask" value="7" c:identifier="G_TYPE_DEBUG_MASK">
        <doc xml:space="preserve">Mask covering all debug flags</doc>
      </member>
    </bitfield>
    <bitfield name="TypeFlags" c:type="GTypeFlags">
      <doc xml:space="preserve">Bit masks used to check or determine characteristics of a type.</doc>
      <member name="none" value="0" c:identifier="G_TYPE_FLAG_NONE">
        <doc xml:space="preserve">No special flags. Since: 2.74</doc>
      </member>
      <member name="abstract" value="16" c:identifier="G_TYPE_FLAG_ABSTRACT">
        <doc xml:space="preserve">Indicates an abstract type. No instances can be
 created for an abstract type</doc>
      </member>
      <member name="value_abstract" value="32" c:identifier="G_TYPE_FLAG_VALUE_ABSTRACT">
        <doc xml:space="preserve">Indicates an abstract value type, i.e. a type
 that introduces a value table, but can't be used for
 g_value_init()</doc>
      </member>
      <member name="final" value="64" c:identifier="G_TYPE_FLAG_FINAL">
        <doc xml:space="preserve">Indicates a final type. A final type is a non-derivable
 leaf node in a deep derivable type hierarchy tree. Since: 2.70</doc>
      </member>
      <member name="deprecated" value="128" c:identifier="G_TYPE_FLAG_DEPRECATED">
        <doc xml:space="preserve">The type is deprecated and may be removed in a
 future version. A warning will be emitted if it is instantiated while
 running with `G_ENABLE_DIAGNOSTIC=1`. Since 2.76</doc>
      </member>
    </bitfield>
    <bitfield name="TypeFundamentalFlags" c:type="GTypeFundamentalFlags">
      <doc xml:space="preserve">Bit masks used to check or determine specific characteristics of a
fundamental type.</doc>
      <member name="classed" value="1" c:identifier="G_TYPE_FLAG_CLASSED">
        <doc xml:space="preserve">Indicates a classed type</doc>
      </member>
      <member name="instantiatable" value="2" c:identifier="G_TYPE_FLAG_INSTANTIATABLE">
        <doc xml:space="preserve">Indicates an instantiatable type (implies classed)</doc>
      </member>
      <member name="derivable" value="4" c:identifier="G_TYPE_FLAG_DERIVABLE">
        <doc xml:space="preserve">Indicates a flat derivable type</doc>
      </member>
      <member name="deep_derivable" value="8" c:identifier="G_TYPE_FLAG_DEEP_DERIVABLE">
        <doc xml:space="preserve">Indicates a deep derivable type (implies derivable)</doc>
      </member>
    </bitfield>
    <record name="TypeFundamentalInfo" c:type="GTypeFundamentalInfo">
      <doc xml:space="preserve">A structure that provides information to the type system which is
used specifically for managing fundamental types.</doc>
      <field name="type_flags" writable="1">
        <doc xml:space="preserve">#GTypeFundamentalFlags describing the characteristics of the fundamental type</doc>
        <type name="TypeFundamentalFlags" c:type="GTypeFundamentalFlags"/>
      </field>
    </record>
    <record name="TypeInfo" c:type="GTypeInfo">
      <doc xml:space="preserve">This structure is used to provide the type system with the information
required to initialize and destruct (finalize) a type's class and
its instances.

The initialized structure is passed to the g_type_register_static() function
(or is copied into the provided #GTypeInfo structure in the
g_type_plugin_complete_type_info()). The type system will perform a deep
copy of this structure, so its memory does not need to be persistent
across invocation of g_type_register_static().</doc>
      <field name="class_size" writable="1">
        <doc xml:space="preserve">Size of the class structure (required for interface, classed and instantiatable types)</doc>
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="base_init" writable="1">
        <doc xml:space="preserve">Location of the base initialization function (optional)</doc>
        <type name="BaseInitFunc" c:type="GBaseInitFunc"/>
      </field>
      <field name="base_finalize" writable="1">
        <doc xml:space="preserve">Location of the base finalization function (optional)</doc>
        <type name="BaseFinalizeFunc" c:type="GBaseFinalizeFunc"/>
      </field>
      <field name="class_init" writable="1">
        <doc xml:space="preserve">Location of the class initialization function for
 classed and instantiatable types. Location of the default vtable
 initialization function for interface types. (optional) This function
 is used both to fill in virtual functions in the class or default vtable,
 and to do type-specific setup such as registering signals and object
 properties.</doc>
        <type name="ClassInitFunc" c:type="GClassInitFunc"/>
      </field>
      <field name="class_finalize" writable="1">
        <doc xml:space="preserve">Location of the class finalization function for
 classed and instantiatable types. Location of the default vtable
 finalization function for interface types. (optional)</doc>
        <type name="ClassFinalizeFunc" c:type="GClassFinalizeFunc"/>
      </field>
      <field name="class_data" writable="1">
        <doc xml:space="preserve">User-supplied data passed to the class init/finalize functions</doc>
        <type name="gpointer" c:type="gconstpointer"/>
      </field>
      <field name="instance_size" writable="1">
        <doc xml:space="preserve">Size of the instance (object) structure (required for instantiatable types only)</doc>
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="n_preallocs" writable="1">
        <doc xml:space="preserve">Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored.</doc>
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="instance_init" writable="1">
        <doc xml:space="preserve">Location of the instance initialization function (optional, for instantiatable types only)</doc>
        <type name="InstanceInitFunc" c:type="GInstanceInitFunc"/>
      </field>
      <field name="value_table" writable="1">
        <doc xml:space="preserve">A #GTypeValueTable function table for generic handling of GValues
 of this type (usually only useful for fundamental types)</doc>
        <type name="TypeValueTable" c:type="const GTypeValueTable*"/>
      </field>
    </record>
    <record name="TypeInstance" c:type="GTypeInstance">
      <doc xml:space="preserve">An opaque structure used as the base of all type instances.</doc>
      <field name="g_class" readable="0" private="1">
        <type name="TypeClass" c:type="GTypeClass*"/>
      </field>
      <method name="get_private" c:identifier="g_type_instance_get_private">
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="instance" transfer-ownership="none">
            <type name="TypeInstance" c:type="GTypeInstance*"/>
          </instance-parameter>
          <parameter name="private_type" transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="TypeInterface" c:type="GTypeInterface">
      <doc xml:space="preserve">An opaque structure used as the base of all interface types.</doc>
      <field name="g_type" readable="0" private="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="g_instance_type" readable="0" private="1">
        <type name="GType" c:type="GType"/>
      </field>
      <method name="peek_parent" c:identifier="g_type_interface_peek_parent">
        <doc xml:space="preserve">Returns the corresponding #GTypeInterface structure of the parent type
of the instance type to which @g_iface belongs. This is useful when
deriving the implementation of an interface from the parent type and
then possibly overriding some methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the
    corresponding #GTypeInterface structure of the parent type of the
    instance type to which @g_iface belongs, or %NULL if the parent
    type doesn't conform to the interface</doc>
          <type name="TypeInterface" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="g_iface" transfer-ownership="none">
            <doc xml:space="preserve">a #GTypeInterface structure</doc>
            <type name="TypeInterface" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="add_prerequisite" c:identifier="g_type_interface_add_prerequisite">
        <doc xml:space="preserve">Adds @prerequisite_type to the list of prerequisites of @interface_type.
This means that any type implementing @interface_type must also implement
@prerequisite_type. Prerequisites can be thought of as an alternative to
interface derivation (which GType doesn't support). An interface can have
at most one instantiatable prerequisite type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="interface_type" transfer-ownership="none">
            <doc xml:space="preserve">#GType value of an interface type</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="prerequisite_type" transfer-ownership="none">
            <doc xml:space="preserve">#GType value of an interface or instantiatable type</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_plugin" c:identifier="g_type_interface_get_plugin">
        <doc xml:space="preserve">Returns the #GTypePlugin structure for the dynamic interface
@interface_type which has been added to @instance_type, or %NULL
if @interface_type has not been added to @instance_type or does
not have a #GTypePlugin structure. See g_type_add_interface_dynamic().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GTypePlugin for the dynamic
    interface @interface_type of @instance_type</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </return-value>
        <parameters>
          <parameter name="instance_type" transfer-ownership="none">
            <doc xml:space="preserve">#GType of an instantiatable type</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="interface_type" transfer-ownership="none">
            <doc xml:space="preserve">#GType of an interface type</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
      <function name="instantiatable_prerequisite" c:identifier="g_type_interface_instantiatable_prerequisite" version="2.68">
        <doc xml:space="preserve">Returns the most specific instantiatable prerequisite of an
interface type. If the interface type has no instantiatable
prerequisite, %G_TYPE_INVALID is returned.

See g_type_interface_add_prerequisite() for more information
about prerequisites.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the instantiatable prerequisite type or %G_TYPE_INVALID if none</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="interface_type" transfer-ownership="none">
            <doc xml:space="preserve">an interface type</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
      <function name="peek" c:identifier="g_type_interface_peek">
        <doc xml:space="preserve">Returns the #GTypeInterface structure of an interface to which the
passed in class conforms.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GTypeInterface
    structure of @iface_type if implemented by @instance_class, %NULL
    otherwise</doc>
          <type name="TypeInterface" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="instance_class" transfer-ownership="none">
            <doc xml:space="preserve">a #GTypeClass structure</doc>
            <type name="TypeClass" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_type" transfer-ownership="none">
            <doc xml:space="preserve">an interface ID which this class conforms to</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
      <function name="prerequisites" c:identifier="g_type_interface_prerequisites" version="2.2">
        <doc xml:space="preserve">Returns the prerequisites of an interfaces type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a
    newly-allocated zero-terminated array of #GType containing
    the prerequisites of @interface_type</doc>
          <array length="1" zero-terminated="0" c:type="GType*">
            <type name="GType" c:type="GType"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="interface_type" transfer-ownership="none">
            <doc xml:space="preserve">an interface type</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_prerequisites" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to return the number
    of prerequisites, or %NULL</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="TypeInterfaceCheckFunc" c:type="GTypeInterfaceCheckFunc" version="2.4">
      <doc xml:space="preserve">A callback called after an interface vtable is initialized.

See g_type_add_interface_check().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="check_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data passed to g_type_add_interface_check()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:space="preserve">the interface that has been
   initialized</doc>
          <type name="TypeInterface" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="TypeModule" c:symbol-prefix="type_module" c:type="GTypeModule" parent="Object" abstract="1" glib:type-name="GTypeModule" glib:get-type="g_type_module_get_type" glib:type-struct="TypeModuleClass">
      <doc xml:space="preserve">`GTypeModule` provides a simple implementation of the `GTypePlugin`
interface.

The model of `GTypeModule` is a dynamically loaded module which
implements some number of types and interface implementations.

When the module is loaded, it registers its types and interfaces
using [method@GObject.TypeModule.register_type] and
[method@GObject.TypeModule.add_interface].
As long as any instances of these types and interface implementations
are in use, the module is kept loaded. When the types and interfaces
are gone, the module may be unloaded. If the types and interfaces
become used again, the module will be reloaded. Note that the last
reference cannot be released from within the module code, since that
would lead to the caller's code being unloaded before `g_object_unref()`
returns to it.

Keeping track of whether the module should be loaded or not is done by
using a use count - it starts at zero, and whenever it is greater than
zero, the module is loaded. The use count is maintained internally by
the type system, but also can be explicitly controlled by
[method@GObject.TypeModule.use] and [method@GObject.TypeModule.unuse].
Typically, when loading a module for the first type, `g_type_module_use()`
will be used to load it so that it can initialize its types. At some later
point, when the module no longer needs to be loaded except for the type
implementations it contains, `g_type_module_unuse()` is called.

`GTypeModule` does not actually provide any implementation of module
loading and unloading. To create a particular module type you must
derive from `GTypeModule` and implement the load and unload functions
in `GTypeModuleClass`.</doc>
      <implements name="TypePlugin"/>
      <virtual-method name="load">
        <doc xml:space="preserve">loads the module and registers one or more types using
 g_type_module_register_type().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <type name="TypeModule" c:type="GTypeModule*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unload">
        <doc xml:space="preserve">unloads the module</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <type name="TypeModule" c:type="GTypeModule*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_interface" c:identifier="g_type_module_add_interface">
        <doc xml:space="preserve">Registers an additional interface for a type, whose interface lives
in the given type plugin. If the interface was already registered
for the type in this plugin, nothing will be done.

As long as any instances of the type exist, the type plugin will
not be unloaded.

Since 2.56 if @module is %NULL this will call g_type_add_interface_static()
instead. This can be used when making a static build of the module.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GTypeModule</doc>
            <type name="TypeModule" c:type="GTypeModule*"/>
          </instance-parameter>
          <parameter name="instance_type" transfer-ownership="none">
            <doc xml:space="preserve">type to which to add the interface.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="interface_type" transfer-ownership="none">
            <doc xml:space="preserve">interface type to add</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="interface_info" transfer-ownership="none">
            <doc xml:space="preserve">type information structure</doc>
            <type name="InterfaceInfo" c:type="const GInterfaceInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_enum" c:identifier="g_type_module_register_enum" version="2.6">
        <doc xml:space="preserve">Looks up or registers an enumeration that is implemented with a particular
type plugin. If a type with name @type_name was previously registered,
the #GType identifier for the type is returned, otherwise the type
is newly registered, and the resulting #GType identifier returned.

As long as any instances of the type exist, the type plugin will
not be unloaded.

Since 2.56 if @module is %NULL this will call g_type_register_static()
instead. This can be used when making a static build of the module.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the new or existing type ID</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GTypeModule</doc>
            <type name="TypeModule" c:type="GTypeModule*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name for the type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="const_static_values" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GEnumValue structs for the
                      possible enumeration values. The array is
                      terminated by a struct with all members being
                      0.</doc>
            <type name="EnumValue" c:type="const GEnumValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_flags" c:identifier="g_type_module_register_flags" version="2.6">
        <doc xml:space="preserve">Looks up or registers a flags type that is implemented with a particular
type plugin. If a type with name @type_name was previously registered,
the #GType identifier for the type is returned, otherwise the type
is newly registered, and the resulting #GType identifier returned.

As long as any instances of the type exist, the type plugin will
not be unloaded.

Since 2.56 if @module is %NULL this will call g_type_register_static()
instead. This can be used when making a static build of the module.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the new or existing type ID</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GTypeModule</doc>
            <type name="TypeModule" c:type="GTypeModule*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name for the type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="const_static_values" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GFlagsValue structs for the
                      possible flags values. The array is
                      terminated by a struct with all members being
                      0.</doc>
            <type name="FlagsValue" c:type="const GFlagsValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_type" c:identifier="g_type_module_register_type">
        <doc xml:space="preserve">Looks up or registers a type that is implemented with a particular
type plugin. If a type with name @type_name was previously registered,
the #GType identifier for the type is returned, otherwise the type
is newly registered, and the resulting #GType identifier returned.

When reregistering a type (typically because a module is unloaded
then reloaded, and reinitialized), @module and @parent_type must
be the same as they were previously.

As long as any instances of the type exist, the type plugin will
not be unloaded.

Since 2.56 if @module is %NULL this will call g_type_register_static()
instead. This can be used when making a static build of the module.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the new or existing type ID</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GTypeModule</doc>
            <type name="TypeModule" c:type="GTypeModule*"/>
          </instance-parameter>
          <parameter name="parent_type" transfer-ownership="none">
            <doc xml:space="preserve">the type for the parent class</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="type_name" transfer-ownership="none">
            <doc xml:space="preserve">name for the type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type_info" transfer-ownership="none">
            <doc xml:space="preserve">type information structure</doc>
            <type name="TypeInfo" c:type="const GTypeInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags field providing details about the type</doc>
            <type name="TypeFlags" c:type="GTypeFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="g_type_module_set_name">
        <doc xml:space="preserve">Sets the name for a #GTypeModule</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">a #GTypeModule.</doc>
            <type name="TypeModule" c:type="GTypeModule*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a human-readable name to use in error messages.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unuse" c:identifier="g_type_module_unuse">
        <doc xml:space="preserve">Decreases the use count of a #GTypeModule by one. If the
result is zero, the module will be unloaded. (However, the
#GTypeModule will not be freed, and types associated with the
#GTypeModule are not unregistered. Once a #GTypeModule is
initialized, it must exist forever.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">a #GTypeModule</doc>
            <type name="TypeModule" c:type="GTypeModule*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="use" c:identifier="g_type_module_use">
        <doc xml:space="preserve">Increases the use count of a #GTypeModule by one. If the
use count was zero before, the plugin will be loaded.
If loading the plugin fails, the use count is reset to
its prior value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the plugin needed to be loaded and
 loading the plugin failed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">a #GTypeModule</doc>
            <type name="TypeModule" c:type="GTypeModule*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="GObject"/>
      </field>
      <field name="use_count">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="type_infos">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="interface_infos">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="name">
        <doc xml:space="preserve">the name of the module</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
    </class>
    <record name="TypeModuleClass" c:type="GTypeModuleClass" glib:is-gtype-struct-for="TypeModule">
      <doc xml:space="preserve">In order to implement dynamic loading of types based on #GTypeModule,
the @load and @unload functions in #GTypeModuleClass must be implemented.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="load">
        <doc xml:space="preserve">loads the module and registers one or more types using
 g_type_module_register_type().</doc>
        <callback name="load">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="module" transfer-ownership="none">
              <type name="TypeModule" c:type="GTypeModule*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unload">
        <doc xml:space="preserve">unloads the module</doc>
        <callback name="unload">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="module" transfer-ownership="none">
              <type name="TypeModule" c:type="GTypeModule*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved1">
        <callback name="reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="reserved2">
        <callback name="reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="reserved3">
        <callback name="reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="reserved4">
        <callback name="reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <interface name="TypePlugin" c:symbol-prefix="type_plugin" c:type="GTypePlugin" glib:type-name="GTypePlugin" glib:get-type="g_type_plugin_get_type" glib:type-struct="TypePluginClass">
      <doc xml:space="preserve">An interface that handles the lifecycle of dynamically loaded types.

The GObject type system supports dynamic loading of types.
It goes as follows:

1. The type is initially introduced (usually upon loading the module
   the first time, or by your main application that knows what modules
   introduces what types), like this:
   ```c
   new_type_id = g_type_register_dynamic (parent_type_id,
                                          "TypeName",
                                          new_type_plugin,
                                          type_flags);
   ```
   where `new_type_plugin` is an implementation of the
   `GTypePlugin` interface.

2. The type's implementation is referenced, e.g. through
   [func@GObject.TypeClass.ref] or through [func@GObject.type_create_instance]
   (this is being called by [ctor@GObject.Object.new]) or through one of the above
   done on a type derived from `new_type_id`.

3. This causes the type system to load the type's implementation by calling
   [method@GObject.TypePlugin.use] and [method@GObject.TypePlugin.complete_type_info]
   on `new_type_plugin`.

4. At some point the type's implementation isn't required anymore, e.g. after
   [method@GObject.TypeClass.unref] or [func@GObject.type_free_instance]
   (called when the reference count of an instance drops to zero).

5. This causes the type system to throw away the information retrieved
   from [method@GObject.TypePlugin.complete_type_info] and then it calls
   [method@GObject.TypePlugin.unuse] on `new_type_plugin`.

6. Things may repeat from the second step.

So basically, you need to implement a `GTypePlugin` type that
carries a use_count, once use_count goes from zero to one, you need
to load the implementation to successfully handle the upcoming
[method@GObject.TypePlugin.complete_type_info] call. Later, maybe after
succeeding use/unuse calls, once use_count drops to zero, you can
unload the implementation again. The type system makes sure to call
[method@GObject.TypePlugin.use] and [method@GObject.TypePlugin.complete_type_info]
again when the type is needed again.

[class@GObject.TypeModule] is an implementation of `GTypePlugin` that
already implements most of this except for the actual module loading and
unloading. It even handles multiple registered types per module.</doc>
      <method name="complete_interface_info" c:identifier="g_type_plugin_complete_interface_info">
        <doc xml:space="preserve">Calls the @complete_interface_info function from the
#GTypePluginClass of @plugin. There should be no need to use this
function outside of the GObject type system itself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">the #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*"/>
          </instance-parameter>
          <parameter name="instance_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of an instantiatable type to which the interface
 is added</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="interface_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the interface whose info is completed</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">the #GInterfaceInfo to fill in</doc>
            <type name="InterfaceInfo" c:type="GInterfaceInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="complete_type_info" c:identifier="g_type_plugin_complete_type_info">
        <doc xml:space="preserve">Calls the @complete_type_info function from the #GTypePluginClass of @plugin.
There should be no need to use this function outside of the GObject
type system itself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*"/>
          </instance-parameter>
          <parameter name="g_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType whose info is completed</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">the #GTypeInfo struct to fill in</doc>
            <type name="TypeInfo" c:type="GTypeInfo*"/>
          </parameter>
          <parameter name="value_table" transfer-ownership="none">
            <doc xml:space="preserve">the #GTypeValueTable to fill in</doc>
            <type name="TypeValueTable" c:type="GTypeValueTable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unuse" c:identifier="g_type_plugin_unuse">
        <doc xml:space="preserve">Calls the @unuse_plugin function from the #GTypePluginClass of
@plugin.  There should be no need to use this function outside of
the GObject type system itself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="use" c:identifier="g_type_plugin_use">
        <doc xml:space="preserve">Calls the @use_plugin function from the #GTypePluginClass of
@plugin.  There should be no need to use this function outside of
the GObject type system itself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none">
            <doc xml:space="preserve">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <record name="TypePluginClass" c:type="GTypePluginClass" glib:is-gtype-struct-for="TypePlugin">
      <doc xml:space="preserve">The #GTypePlugin interface is used by the type system in order to handle
the lifecycle of dynamically loaded types.</doc>
      <field name="base_iface" readable="0" private="1">
        <type name="TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="use_plugin" writable="1">
        <doc xml:space="preserve">Increases the use count of the plugin.</doc>
        <type name="TypePluginUse" c:type="GTypePluginUse"/>
      </field>
      <field name="unuse_plugin" writable="1">
        <doc xml:space="preserve">Decreases the use count of the plugin.</doc>
        <type name="TypePluginUnuse" c:type="GTypePluginUnuse"/>
      </field>
      <field name="complete_type_info" writable="1">
        <doc xml:space="preserve">Fills in the #GTypeInfo and
 #GTypeValueTable structs for the type. The structs are initialized
 with `memset(s, 0, sizeof (s))` before calling this function.</doc>
        <type name="TypePluginCompleteTypeInfo" c:type="GTypePluginCompleteTypeInfo"/>
      </field>
      <field name="complete_interface_info" writable="1">
        <doc xml:space="preserve">Fills in missing parts of the #GInterfaceInfo
 for the interface. The structs is initialized with
 `memset(s, 0, sizeof (s))` before calling this function.</doc>
        <type name="TypePluginCompleteInterfaceInfo" c:type="GTypePluginCompleteInterfaceInfo"/>
      </field>
    </record>
    <callback name="TypePluginCompleteInterfaceInfo" c:type="GTypePluginCompleteInterfaceInfo">
      <doc xml:space="preserve">The type of the @complete_interface_info function of #GTypePluginClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:space="preserve">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:space="preserve">the #GType of an instantiatable type to which the interface
 is added</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:space="preserve">the #GType of the interface whose info is completed</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">the #GInterfaceInfo to fill in</doc>
          <type name="InterfaceInfo" c:type="GInterfaceInfo*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypePluginCompleteTypeInfo" c:type="GTypePluginCompleteTypeInfo">
      <doc xml:space="preserve">The type of the @complete_type_info function of #GTypePluginClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:space="preserve">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
        <parameter name="g_type" transfer-ownership="none">
          <doc xml:space="preserve">the #GType whose info is completed</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">the #GTypeInfo struct to fill in</doc>
          <type name="TypeInfo" c:type="GTypeInfo*"/>
        </parameter>
        <parameter name="value_table" transfer-ownership="none">
          <doc xml:space="preserve">the #GTypeValueTable to fill in</doc>
          <type name="TypeValueTable" c:type="GTypeValueTable*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypePluginUnuse" c:type="GTypePluginUnuse">
      <doc xml:space="preserve">The type of the @unuse_plugin function of #GTypePluginClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:space="preserve">the #GTypePlugin whose use count should be decreased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypePluginUse" c:type="GTypePluginUse">
      <doc xml:space="preserve">The type of the @use_plugin function of #GTypePluginClass, which gets called
to increase the use count of @plugin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:space="preserve">the #GTypePlugin whose use count should be increased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TypeQuery" c:type="GTypeQuery">
      <doc xml:space="preserve">A structure holding information for a specific type.

See also: g_type_query()</doc>
      <field name="type" writable="1">
        <doc xml:space="preserve">the #GType value of the type</doc>
        <type name="GType" c:type="GType"/>
      </field>
      <field name="type_name" writable="1">
        <doc xml:space="preserve">the name of the type</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="class_size" writable="1">
        <doc xml:space="preserve">the size of the class structure</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="instance_size" writable="1">
        <doc xml:space="preserve">the size of the instance structure</doc>
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <callback name="TypeValueCollectFunc" c:type="GTypeValueCollectFunc" version="2.78">
      <doc xml:space="preserve">This function is responsible for converting the values collected from
a variadic argument list into contents suitable for storage in a #GValue.

This function should setup @value similar to #GTypeValueInitFunc; e.g.
for a string value that does not allow `NULL` pointers, it needs to either
emit an error, or do an implicit conversion by storing an empty string.

The @value passed in to this function has a zero-filled data array, so
just like for #GTypeValueInitFunc it is guaranteed to not contain any old
contents that might need freeing.

The @n_collect_values argument is the string length of the `collect_format`
field of #GTypeValueTable, and `collect_values` is an array of #GTypeCValue
with length of @n_collect_values, containing the collected values according
to `collect_format`.

The @collect_flags argument provided as a hint by the caller. It may
contain the flag %G_VALUE_NOCOPY_CONTENTS indicating that the collected
value contents may be considered &#x2018;static&#x2019; for the duration of the @value
lifetime. Thus an extra copy of the contents stored in @collect_values is
not required for assignment to @value.

For our above string example, we continue with:

|[&lt;!-- language="C" --&gt;
if (!collect_values[0].v_pointer)
  value-&gt;data[0].v_pointer = g_strdup ("");
else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
  {
    value-&gt;data[0].v_pointer = collect_values[0].v_pointer;
    // keep a flag for the value_free() implementation to not free this string
    value-&gt;data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
  }
else
  value-&gt;data[0].v_pointer = g_strdup (collect_values[0].v_pointer);
return NULL;
]|

It should be noted, that it is generally a bad idea to follow the
%G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to
reentrancy requirements and reference count assertions performed
by the signal emission code, reference counts should always be
incremented for reference counted contents stored in the `value-&gt;data`
array. To deviate from our string example for a moment, and taking
a look at an exemplary implementation for `GTypeValueTable.collect_value()`
of `GObject`:

|[&lt;!-- language="C" --&gt;
GObject *object = G_OBJECT (collect_values[0].v_pointer);
g_return_val_if_fail (object != NULL,
   g_strdup_printf ("Object %p passed as invalid NULL pointer", object));
// never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types
value-&gt;data[0].v_pointer = g_object_ref (object);
return NULL;
]|

The reference count for valid objects is always incremented, regardless
of `collect_flags`. For invalid objects, the example returns a newly
allocated string without altering `value`.

Upon success, `collect_value()` needs to return `NULL`. If, however,
an error condition occurred, `collect_value()` should return a newly
allocated string containing an error diagnostic.

The calling code makes no assumptions about the `value` contents being
valid upon error returns, `value` is simply thrown away without further
freeing. As such, it is a good idea to not allocate `GValue` contents
prior to returning an error; however, `collect_values()` is not obliged
to return a correctly setup @value for error returns, simply because
any non-`NULL` return is considered a fatal programming error, and
further program behaviour is undefined.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">`NULL` on success, otherwise a
  newly allocated error string on failure</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value to initialize</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_collect_values" transfer-ownership="none">
          <doc xml:space="preserve">the number of collected values</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="collect_values" transfer-ownership="none">
          <doc xml:space="preserve">the collected values</doc>
          <array length="1" zero-terminated="0" c:type="GTypeCValue*">
            <type name="TypeCValue" c:type="GTypeCValue"/>
          </array>
        </parameter>
        <parameter name="collect_flags" transfer-ownership="none">
          <doc xml:space="preserve">optional flags</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypeValueCopyFunc" c:type="GTypeValueCopyFunc" version="2.78">
      <doc xml:space="preserve">Copies the content of a #GValue into another.

The @dest_value is a #GValue with zero-filled data section and @src_value
is a properly initialized #GValue of same type, or derived type.

The purpose of this function is to copy the contents of @src_value
into @dest_value in a way, that even after @src_value has been freed, the
contents of @dest_value remain valid. String type example:

|[&lt;!-- language="C" --&gt;
dest_value-&gt;data[0].v_pointer = g_strdup (src_value-&gt;data[0].v_pointer);
]|</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src_value" transfer-ownership="none">
          <doc xml:space="preserve">the value to copy</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="dest_value" direction="out" caller-allocates="1" transfer-ownership="none">
          <doc xml:space="preserve">the location of the copy</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypeValueFreeFunc" c:type="GTypeValueFreeFunc" version="2.78">
      <doc xml:space="preserve">Frees any old contents that might be left in the `value-&gt;data` array of
the given value.

No resources may remain allocated through the #GValue contents after this
function returns. E.g. for our above string type:

|[&lt;!-- language="C" --&gt;
// only free strings without a specific flag for static storage
if (!(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS))
  g_free (value-&gt;data[0].v_pointer);
]|</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value to free</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypeValueInitFunc" c:type="GTypeValueInitFunc" version="2.78">
      <doc xml:space="preserve">Initializes the value contents by setting the fields of the `value-&gt;data`
array.

The data array of the #GValue passed into this function was zero-filled
with `memset()`, so no care has to be taken to free any old contents.
For example, in the case of a string value that may never be %NULL, the
implementation might look like:

|[&lt;!-- language="C" --&gt;
value-&gt;data[0].v_pointer = g_strdup ("");
]|</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value to initialize</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypeValueLCopyFunc" c:type="GTypeValueLCopyFunc" version="2.78">
      <doc xml:space="preserve">This function is responsible for storing the `value`
contents into arguments passed through a variadic argument list which
got collected into `collect_values` according to `lcopy_format`.

The `n_collect_values` argument equals the string length of
`lcopy_format`, and `collect_flags` may contain %G_VALUE_NOCOPY_CONTENTS.

In contrast to #GTypeValueCollectFunc, this function is obliged to always
properly support %G_VALUE_NOCOPY_CONTENTS.

Similar to #GTypeValueCollectFunc the function may prematurely abort by
returning a newly allocated string describing an error condition. To
complete the string example:

|[&lt;!-- language="C" --&gt;
gchar **string_p = collect_values[0].v_pointer;
g_return_val_if_fail (string_p != NULL,
  g_strdup ("string location passed as NULL"));

if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
  *string_p = value-&gt;data[0].v_pointer;
else
  *string_p = g_strdup (value-&gt;data[0].v_pointer);
]|

And an illustrative version of this function for reference-counted
types:

|[&lt;!-- language="C" --&gt;
GObject **object_p = collect_values[0].v_pointer;
g_return_val_if_fail (object_p != NULL,
  g_strdup ("object location passed as NULL"));

if (value-&gt;data[0].v_pointer == NULL)
  *object_p = NULL;
else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS) // always honour
  *object_p = value-&gt;data[0].v_pointer;
else
  *object_p = g_object_ref (value-&gt;data[0].v_pointer);

return NULL;
]|</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">`NULL` on success, otherwise
  a newly allocated error string on failure</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value to lcopy</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="n_collect_values" transfer-ownership="none">
          <doc xml:space="preserve">the number of collected values</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="collect_values" transfer-ownership="none">
          <doc xml:space="preserve">the collected
  locations for storage</doc>
          <array length="1" zero-terminated="0" c:type="GTypeCValue*">
            <type name="TypeCValue" c:type="GTypeCValue"/>
          </array>
        </parameter>
        <parameter name="collect_flags" transfer-ownership="none">
          <doc xml:space="preserve">optional flags</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypeValuePeekPointerFunc" c:type="GTypeValuePeekPointerFunc" version="2.78">
      <doc xml:space="preserve">If the value contents fit into a pointer, such as objects or strings,
return this pointer, so the caller can peek at the current contents.

To extend on our above string example:

|[&lt;!-- language="C" --&gt;
return value-&gt;data[0].v_pointer;
]|</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">a pointer to the value contents</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value to peek</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TypeValueTable" c:type="GTypeValueTable">
      <doc xml:space="preserve">The #GTypeValueTable provides the functions required by the #GValue
implementation, to serve as a container for values of a type.</doc>
      <field name="value_init" writable="1">
        <doc xml:space="preserve">Function to initialize a GValue</doc>
        <type name="TypeValueInitFunc" c:type="GTypeValueInitFunc"/>
      </field>
      <field name="value_free" writable="1">
        <doc xml:space="preserve">Function to free a GValue</doc>
        <type name="TypeValueFreeFunc" c:type="GTypeValueFreeFunc"/>
      </field>
      <field name="value_copy" writable="1">
        <doc xml:space="preserve">Function to copy a GValue</doc>
        <type name="TypeValueCopyFunc" c:type="GTypeValueCopyFunc"/>
      </field>
      <field name="value_peek_pointer" writable="1">
        <doc xml:space="preserve">Function to peek the contents of a GValue if they fit
  into a pointer</doc>
        <type name="TypeValuePeekPointerFunc" c:type="GTypeValuePeekPointerFunc"/>
      </field>
      <field name="collect_format" writable="1">
        <doc xml:space="preserve">A string format describing how to collect the contents of
  this value bit-by-bit. Each character in the format represents
  an argument to be collected, and the characters themselves indicate
  the type of the argument. Currently supported arguments are:
   - `'i'`: Integers, passed as `collect_values[].v_int`
   - `'l'`: Longs, passed as `collect_values[].v_long`
   - `'d'`: Doubles, passed as `collect_values[].v_double`
   - `'p'`: Pointers, passed as `collect_values[].v_pointer`
  It should be noted that for variable argument list construction,
  ANSI C promotes every type smaller than an integer to an int, and
  floats to doubles. So for collection of short int or char, `'i'`
  needs to be used, and for collection of floats `'d'`.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="collect_value" writable="1">
        <doc xml:space="preserve">Function to initialize a GValue from the values
  collected from variadic arguments</doc>
        <type name="TypeValueCollectFunc" c:type="GTypeValueCollectFunc"/>
      </field>
      <field name="lcopy_format" writable="1">
        <doc xml:space="preserve">Format description of the arguments to collect for @lcopy_value,
  analogous to @collect_format. Usually, @lcopy_format string consists
  only of `'p'`s to provide lcopy_value() with pointers to storage locations.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="lcopy_value" writable="1">
        <doc xml:space="preserve">Function to store the contents of a value into the
  locations collected from variadic arguments</doc>
        <type name="TypeValueLCopyFunc" c:type="GTypeValueLCopyFunc"/>
      </field>
      <function name="peek" c:identifier="g_type_value_table_peek" introspectable="0">
        <doc xml:space="preserve">Returns the location of the #GTypeValueTable associated with @type.

Note that this function should only be used from source code
that implements or has internal knowledge of the implementation of
@type.</doc>
        <return-value>
          <doc xml:space="preserve">location of the #GTypeValueTable associated with @type or
    %NULL if there is no #GTypeValueTable associated with @type</doc>
          <type name="TypeValueTable" c:type="GTypeValueTable*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <function-macro name="UNAVAILABLE" c:identifier="GOBJECT_UNAVAILABLE" introspectable="0">
      <parameters>
        <parameter name="maj">
        </parameter>
        <parameter name="min">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="UNAVAILABLE_STATIC_INLINE" c:identifier="GOBJECT_UNAVAILABLE_STATIC_INLINE" introspectable="0">
      <parameters>
        <parameter name="maj">
        </parameter>
        <parameter name="min">
        </parameter>
      </parameters>
    </function-macro>
    <glib:boxed glib:name="Uri" c:symbol-prefix="uri" glib:type-name="GUri" glib:get-type="g_uri_get_type">
    </glib:boxed>
    <function-macro name="VALUE_COLLECT" c:identifier="G_VALUE_COLLECT" introspectable="0">
      <doc xml:space="preserve">Collects a variable argument value from a `va_list`.

We have to implement the varargs collection as a macro, because on some systems
`va_list` variables cannot be passed by reference.

Note: If you are creating the @value argument just before calling this macro,
you should use the G_VALUE_COLLECT_INIT() variant and pass the uninitialized
#GValue. That variant is faster than G_VALUE_COLLECT().</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a #GValue return location. @value is supposed to be initialized
 according to the value type to be collected</doc>
        </parameter>
        <parameter name="var_args">
          <doc xml:space="preserve">the va_list variable; it may be evaluated multiple times</doc>
        </parameter>
        <parameter name="flags">
          <doc xml:space="preserve">flags which are passed on to the collect_value() function of
 the #GTypeValueTable of @value.</doc>
        </parameter>
        <parameter name="__error">
          <doc xml:space="preserve">a #gchar** variable that will be modified to hold a g_new()
 allocated error messages if something fails</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="VALUE_COLLECT_FORMAT_MAX_LENGTH" value="8" c:type="G_VALUE_COLLECT_FORMAT_MAX_LENGTH">
      <doc xml:space="preserve">The maximal number of #GTypeCValues which can be collected for a
single #GValue.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="VALUE_COLLECT_INIT" c:identifier="G_VALUE_COLLECT_INIT" version="2.24" introspectable="0">
      <doc xml:space="preserve">Collects a variable argument value from a `va_list`.

We have to implement the varargs collection as a macro, because on some
systems `va_list` variables cannot be passed by reference.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a #GValue return location. @value must contain only 0 bytes.</doc>
        </parameter>
        <parameter name="_value_type">
          <doc xml:space="preserve">the #GType to use for @value.</doc>
        </parameter>
        <parameter name="var_args">
          <doc xml:space="preserve">the va_list variable; it may be evaluated multiple times</doc>
        </parameter>
        <parameter name="flags">
          <doc xml:space="preserve">flags which are passed on to the collect_value() function of
 the #GTypeValueTable of @value.</doc>
        </parameter>
        <parameter name="__error">
          <doc xml:space="preserve">a #gchar** variable that will be modified to hold a g_new()
 allocated error messages if something fails</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_COLLECT_INIT2" c:identifier="G_VALUE_COLLECT_INIT2" version="2.74" introspectable="0">
      <doc xml:space="preserve">A variant of G_VALUE_COLLECT_INIT() that provides the #GTypeValueTable
to the caller.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a #GValue return location. @value must contain only 0 bytes.</doc>
        </parameter>
        <parameter name="g_vci_vtab">
          <doc xml:space="preserve">a #GTypeValueTable pointer that will be set to the value table
  for @_value_type</doc>
        </parameter>
        <parameter name="_value_type">
          <doc xml:space="preserve">the #GType to use for @value.</doc>
        </parameter>
        <parameter name="var_args">
          <doc xml:space="preserve">the va_list variable; it may be evaluated multiple times</doc>
        </parameter>
        <parameter name="flags">
          <doc xml:space="preserve">flags which are passed on to the collect_value() function of
 the #GTypeValueTable of @value.</doc>
        </parameter>
        <parameter name="__error">
          <doc xml:space="preserve">a #gchar** variable that will be modified to hold a g_new()
 allocated error messages if something fails</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_COLLECT_SKIP" c:identifier="G_VALUE_COLLECT_SKIP" introspectable="0">
      <doc xml:space="preserve">Skip an argument of type @_value_type from @var_args.</doc>
      <parameters>
        <parameter name="_value_type">
          <doc xml:space="preserve">the #GType of the value to skip</doc>
        </parameter>
        <parameter name="var_args">
          <doc xml:space="preserve">the va_list variable; it may be evaluated multiple times</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS" c:identifier="G_VALUE_HOLDS" introspectable="0">
      <doc xml:space="preserve">Checks if @value holds (or contains) a value of @type.
This macro will also check for @value != %NULL and issue a
warning if the check fails.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">A #GValue structure.</doc>
        </parameter>
        <parameter name="type">
          <doc xml:space="preserve">A #GType value.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_BOOLEAN" c:identifier="G_VALUE_HOLDS_BOOLEAN" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_BOOLEAN.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_BOXED" c:identifier="G_VALUE_HOLDS_BOXED" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values derived
from type %G_TYPE_BOXED.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_CHAR" c:identifier="G_VALUE_HOLDS_CHAR" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_CHAR.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_DOUBLE" c:identifier="G_VALUE_HOLDS_DOUBLE" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_DOUBLE.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_ENUM" c:identifier="G_VALUE_HOLDS_ENUM" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values derived from type %G_TYPE_ENUM.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_FLAGS" c:identifier="G_VALUE_HOLDS_FLAGS" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values derived from type %G_TYPE_FLAGS.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_FLOAT" c:identifier="G_VALUE_HOLDS_FLOAT" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_FLOAT.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_GTYPE" c:identifier="G_VALUE_HOLDS_GTYPE" version="2.12" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_GTYPE.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_INT" c:identifier="G_VALUE_HOLDS_INT" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_INT.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_INT64" c:identifier="G_VALUE_HOLDS_INT64" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_INT64.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_LONG" c:identifier="G_VALUE_HOLDS_LONG" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_LONG.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_OBJECT" c:identifier="G_VALUE_HOLDS_OBJECT" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values derived from type %G_TYPE_OBJECT.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_PARAM" c:identifier="G_VALUE_HOLDS_PARAM" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values derived from type %G_TYPE_PARAM.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_POINTER" c:identifier="G_VALUE_HOLDS_POINTER" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_POINTER.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_STRING" c:identifier="G_VALUE_HOLDS_STRING" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_STRING.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_UCHAR" c:identifier="G_VALUE_HOLDS_UCHAR" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_UCHAR.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_UINT" c:identifier="G_VALUE_HOLDS_UINT" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_UINT.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_UINT64" c:identifier="G_VALUE_HOLDS_UINT64" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_UINT64.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_ULONG" c:identifier="G_VALUE_HOLDS_ULONG" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_ULONG.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_HOLDS_VARIANT" c:identifier="G_VALUE_HOLDS_VARIANT" version="2.26" introspectable="0">
      <doc xml:space="preserve">Checks whether the given #GValue can hold values of type %G_TYPE_VARIANT.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="VALUE_INTERNED_STRING" value="268435456" c:type="G_VALUE_INTERNED_STRING" version="2.66">
      <doc xml:space="preserve">For string values, indicates that the string contained is canonical and will
exist for the duration of the process. See g_value_set_interned_string().</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="VALUE_IS_INTERNED_STRING" c:identifier="G_VALUE_IS_INTERNED_STRING" version="2.66" introspectable="0">
      <doc xml:space="preserve">Checks whether @value contains a string which is canonical.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a valid #GValue structure</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_LCOPY" c:identifier="G_VALUE_LCOPY" introspectable="0">
      <doc xml:space="preserve">Stores a value&#x2019;s value into one or more argument locations from a `va_list`.

This is the inverse of G_VALUE_COLLECT().</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">a #GValue to store into the @var_args; this must be initialized
 and set</doc>
        </parameter>
        <parameter name="var_args">
          <doc xml:space="preserve">the va_list variable; it may be evaluated multiple times</doc>
        </parameter>
        <parameter name="flags">
          <doc xml:space="preserve">flags which are passed on to the lcopy_value() function of
 the #GTypeValueTable of @value.</doc>
        </parameter>
        <parameter name="__error">
          <doc xml:space="preserve">a #gchar** variable that will be modified to hold a g_new()
 allocated error message if something fails</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="VALUE_NOCOPY_CONTENTS" value="134217728" c:type="G_VALUE_NOCOPY_CONTENTS">
      <doc xml:space="preserve">If passed to G_VALUE_COLLECT(), allocated data won't be copied
but used verbatim. This does not affect ref-counted types like
objects. This does not affect usage of g_value_copy(), the data will
be copied if it is not ref-counted.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="VALUE_TYPE" c:identifier="G_VALUE_TYPE" introspectable="0">
      <doc xml:space="preserve">Get the type identifier of @value.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">A #GValue structure.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VALUE_TYPE_NAME" c:identifier="G_VALUE_TYPE_NAME" introspectable="0">
      <doc xml:space="preserve">Gets the type name of @value.</doc>
      <parameters>
        <parameter name="value">
          <doc xml:space="preserve">A #GValue structure.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <callback name="VaClosureMarshal" c:type="GVaClosureMarshal" introspectable="0">
      <doc xml:space="preserve">This is the signature of va_list marshaller functions, an optional
marshaller that can be used in some situations to avoid
marshalling the signal argument into GValues.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the instance on which the closure is
 invoked.</doc>
          <type name="TypeInstance" c:type="gpointer"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">va_list of arguments to be passed to the closure.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="n_params" transfer-ownership="none">
          <doc xml:space="preserve">the length of the @param_types array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="param_types" transfer-ownership="none">
          <doc xml:space="preserve">the #GType of each argument from
 @args.</doc>
          <array length="5" zero-terminated="0" c:type="GType*">
            <type name="GType" c:type="GType"/>
          </array>
        </parameter>
      </parameters>
    </callback>
    <record name="Value" c:type="GValue" glib:type-name="GValue" glib:get-type="g_value_get_type" c:symbol-prefix="value">
      <doc xml:space="preserve">An opaque structure used to hold different types of values.

The data within the structure has protected scope: it is accessible only
to functions within a #GTypeValueTable structure, or implementations of
the g_value_*() API. That is, code portions which implement new fundamental
types.

#GValue users cannot make any assumptions about how data is stored
within the 2 element @data union, and the @g_type member should
only be accessed through the G_VALUE_TYPE() macro.</doc>
      <field name="g_type" readable="0" private="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="data" writable="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="_Value__data__union"/>
        </array>
      </field>
      <method name="copy" c:identifier="g_value_copy">
        <doc xml:space="preserve">Copies the value of @src_value into @dest_value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src_value" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #GValue structure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
          <parameter name="dest_value" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #GValue structure of the same type as @src_value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_boxed" c:identifier="g_value_dup_boxed" introspectable="0">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_BOXED derived #GValue.  Upon getting,
the boxed value is duplicated and needs to be later freed with
g_boxed_free(), e.g. like: g_boxed_free (G_VALUE_TYPE (@value),
return_value);</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">boxed contents of @value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_object" c:identifier="g_value_dup_object">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_OBJECT derived #GValue, increasing
its reference count. If the contents of the #GValue are %NULL, then
%NULL will be returned.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">object content of @value,
         should be unreferenced when no longer needed.</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue whose type is derived from %G_TYPE_OBJECT</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_param" c:identifier="g_value_dup_param" introspectable="0">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_PARAM #GValue, increasing its
reference count.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GParamSpec content of @value, should be
    unreferenced when no longer needed.</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue whose type is derived from %G_TYPE_PARAM</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_string" c:identifier="g_value_dup_string">
        <doc xml:space="preserve">Get a copy the contents of a %G_TYPE_STRING #GValue.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated copy of the string content of @value</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_variant" c:identifier="g_value_dup_variant" version="2.26">
        <doc xml:space="preserve">Get the contents of a variant #GValue, increasing its refcount. The returned
#GVariant is never floating.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">variant contents of @value (may be %NULL);
   should be unreffed using g_variant_unref() when no longer needed</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="fits_pointer" c:identifier="g_value_fits_pointer">
        <doc xml:space="preserve">Determines if @value will fit inside the size of a pointer value.
This is an internal function introduced mainly for C marshallers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @value will fit inside a pointer value.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #GValue structure.</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_boolean" c:identifier="g_value_get_boolean">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_BOOLEAN #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">boolean contents of @value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_BOOLEAN</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_boxed" c:identifier="g_value_get_boxed">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_BOXED derived #GValue.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">boxed contents of @value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_char" c:identifier="g_value_get_char" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Do not use this function; it is broken on platforms where the %char
type is unsigned, such as ARM and PowerPC.  See g_value_get_schar().

Get the contents of a %G_TYPE_CHAR #GValue.</doc>
        <doc-deprecated xml:space="preserve">This function's return type is broken, see g_value_get_schar()</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">character contents of @value</doc>
          <type name="gchar" c:type="gchar"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="g_value_get_double">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_DOUBLE #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">double contents of @value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_DOUBLE</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_enum" c:identifier="g_value_get_enum">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_ENUM #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">enum contents of @value</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue whose type is derived from %G_TYPE_ENUM</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="g_value_get_flags">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_FLAGS #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">flags contents of @value</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue whose type is derived from %G_TYPE_FLAGS</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_float" c:identifier="g_value_get_float">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_FLOAT #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">float contents of @value</doc>
          <type name="gfloat" c:type="gfloat"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_FLOAT</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gtype" c:identifier="g_value_get_gtype" version="2.12">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_GTYPE #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType stored in @value</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_GTYPE</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_int" c:identifier="g_value_get_int">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_INT #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">integer contents of @value</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_INT</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_int64" c:identifier="g_value_get_int64">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_INT64 #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">64bit integer contents of @value</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_INT64</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_long" c:identifier="g_value_get_long">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_LONG #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">long integer contents of @value</doc>
          <type name="glong" c:type="glong"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_LONG</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_object" c:identifier="g_value_get_object">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_OBJECT derived #GValue.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">object contents of @value</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_OBJECT derived type</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_param" c:identifier="g_value_get_param">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_PARAM #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#GParamSpec content of @value</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue whose type is derived from %G_TYPE_PARAM</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pointer" c:identifier="g_value_get_pointer">
        <doc xml:space="preserve">Get the contents of a pointer #GValue.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">pointer contents of @value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_POINTER</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_schar" c:identifier="g_value_get_schar" version="2.32">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_CHAR #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">signed 8 bit integer contents of @value</doc>
          <type name="gint8" c:type="gint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="g_value_get_string">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_STRING #GValue.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">string content of @value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uchar" c:identifier="g_value_get_uchar">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_UCHAR #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">unsigned character contents of @value</doc>
          <type name="guint8" c:type="guchar"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_UCHAR</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uint" c:identifier="g_value_get_uint">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_UINT #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">unsigned integer contents of @value</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_UINT</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uint64" c:identifier="g_value_get_uint64">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_UINT64 #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">unsigned 64bit integer contents of @value</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_UINT64</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ulong" c:identifier="g_value_get_ulong">
        <doc xml:space="preserve">Get the contents of a %G_TYPE_ULONG #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">unsigned long integer contents of @value</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_ULONG</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_variant" c:identifier="g_value_get_variant" version="2.26">
        <doc xml:space="preserve">Get the contents of a variant #GValue.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">variant contents of @value (may be %NULL)</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_value_init">
        <doc xml:space="preserve">Initializes @value with the default value of @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GValue structure that has been passed in</doc>
          <type name="Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">A zero-filled (uninitialized) #GValue structure.</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="g_type" transfer-ownership="none">
            <doc xml:space="preserve">Type the #GValue should hold values of.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_instance" c:identifier="g_value_init_from_instance" version="2.42">
        <doc xml:space="preserve">Initializes and sets @value from an instantiatable type via the
value_table's collect_value() function.

Note: The @value will be initialised with the exact type of
@instance.  If you wish to set the @value's type to a different GType
(such as a parent class GType), you need to manually call
g_value_init() and g_value_set_instance().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">An uninitialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:space="preserve">the instance</doc>
            <type name="TypeInstance" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_pointer" c:identifier="g_value_peek_pointer">
        <doc xml:space="preserve">Returns the value contents as pointer. This function asserts that
g_value_fits_pointer() returned %TRUE for the passed in value.
This is an internal function introduced mainly for C marshallers.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the value contents as pointer</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #GValue structure</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="g_value_reset">
        <doc xml:space="preserve">Clears the current value in @value and resets it to the default value
(as if the value had just been initialized).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GValue structure that has been passed in</doc>
          <type name="Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_boolean" c:identifier="g_value_set_boolean">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_BOOLEAN #GValue to @v_boolean.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_BOOLEAN</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_boolean" transfer-ownership="none">
            <doc xml:space="preserve">boolean value to be set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boxed" c:identifier="g_value_set_boxed">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boxed_take_ownership" c:identifier="g_value_set_boxed_take_ownership" deprecated="1" deprecated-version="2.4">
        <doc xml:space="preserve">This is an internal function introduced mainly for C marshallers.</doc>
        <doc-deprecated xml:space="preserve">Use g_value_take_boxed() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_char" c:identifier="g_value_set_char" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_CHAR #GValue to @v_char.</doc>
        <doc-deprecated xml:space="preserve">This function's input type is broken, see g_value_set_schar()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_char" transfer-ownership="none">
            <doc xml:space="preserve">character value to be set</doc>
            <type name="gchar" c:type="gchar"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double" c:identifier="g_value_set_double">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_DOUBLE #GValue to @v_double.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_DOUBLE</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_double" transfer-ownership="none">
            <doc xml:space="preserve">double value to be set</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enum" c:identifier="g_value_set_enum">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_ENUM #GValue to @v_enum.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue whose type is derived from %G_TYPE_ENUM</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_enum" transfer-ownership="none">
            <doc xml:space="preserve">enum value to be set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="g_value_set_flags">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_FLAGS #GValue to @v_flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue whose type is derived from %G_TYPE_FLAGS</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_flags" transfer-ownership="none">
            <doc xml:space="preserve">flags value to be set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_float" c:identifier="g_value_set_float">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_FLOAT #GValue to @v_float.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_FLOAT</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_float" transfer-ownership="none">
            <doc xml:space="preserve">float value to be set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_gtype" c:identifier="g_value_set_gtype" version="2.12">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_GTYPE #GValue to @v_gtype.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_GTYPE</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_gtype" transfer-ownership="none">
            <doc xml:space="preserve">#GType to be set</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_instance" c:identifier="g_value_set_instance">
        <doc xml:space="preserve">Sets @value from an instantiatable type via the
value_table's collect_value() function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="instance" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the instance</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="g_value_set_int">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_INT #GValue to @v_int.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_INT</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_int" transfer-ownership="none">
            <doc xml:space="preserve">integer value to be set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int64" c:identifier="g_value_set_int64">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_INT64 #GValue to @v_int64.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_INT64</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_int64" transfer-ownership="none">
            <doc xml:space="preserve">64bit integer value to be set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_interned_string" c:identifier="g_value_set_interned_string" version="2.66">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_STRING #GValue to @v_string.  The string is
assumed to be static and interned (canonical, for example from
g_intern_string()), and is thus not duplicated when setting the #GValue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">static string to be set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_long" c:identifier="g_value_set_long">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_LONG #GValue to @v_long.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_LONG</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_long" transfer-ownership="none">
            <doc xml:space="preserve">long integer value to be set</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_object" c:identifier="g_value_set_object">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_OBJECT derived #GValue to @v_object.

g_value_set_object() increases the reference count of @v_object
(the #GValue holds a reference to @v_object).  If you do not wish
to increase the reference count of the object (i.e. you wish to
pass your current reference to the #GValue because you no longer
need it), use g_value_take_object() instead.

It is important that your #GValue holds a reference to @v_object (either its
own, or one it has taken) to ensure that the object won't be destroyed while
the #GValue still exists).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_OBJECT derived type</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">object value to be set</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_object_take_ownership" c:identifier="g_value_set_object_take_ownership" introspectable="0" deprecated="1" deprecated-version="2.4">
        <doc xml:space="preserve">This is an internal function introduced mainly for C marshallers.</doc>
        <doc-deprecated xml:space="preserve">Use g_value_take_object() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_OBJECT derived type</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">object value to be set</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_param" c:identifier="g_value_set_param">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_PARAM #GValue to @param.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_PARAM</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="param" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GParamSpec to be set</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_param_take_ownership" c:identifier="g_value_set_param_take_ownership" introspectable="0" deprecated="1" deprecated-version="2.4">
        <doc xml:space="preserve">This is an internal function introduced mainly for C marshallers.</doc>
        <doc-deprecated xml:space="preserve">Use g_value_take_param() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_PARAM</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="param" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GParamSpec to be set</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pointer" c:identifier="g_value_set_pointer">
        <doc xml:space="preserve">Set the contents of a pointer #GValue to @v_pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_POINTER</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_pointer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">pointer value to be set</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_schar" c:identifier="g_value_set_schar" version="2.32">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_CHAR #GValue to @v_char.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_char" transfer-ownership="none">
            <doc xml:space="preserve">signed 8 bit integer to be set</doc>
            <type name="gint8" c:type="gint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_static_boxed" c:identifier="g_value_set_static_boxed">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed.

The boxed value is assumed to be static, and is thus not duplicated
when setting the #GValue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">static boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_static_string" c:identifier="g_value_set_static_string">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_STRING #GValue to @v_string.
The string is assumed to be static, and is thus not duplicated
when setting the #GValue.

If the the string is a canonical string, using g_value_set_interned_string()
is more appropriate.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">static string to be set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="g_value_set_string">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_STRING #GValue to a copy of @v_string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">caller-owned string to be duplicated for the #GValue</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string_take_ownership" c:identifier="g_value_set_string_take_ownership" deprecated="1" deprecated-version="2.4">
        <doc xml:space="preserve">This is an internal function introduced mainly for C marshallers.</doc>
        <doc-deprecated xml:space="preserve">Use g_value_take_string() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">duplicated unowned string to be set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uchar" c:identifier="g_value_set_uchar">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_UCHAR #GValue to @v_uchar.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_UCHAR</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_uchar" transfer-ownership="none">
            <doc xml:space="preserve">unsigned character value to be set</doc>
            <type name="guint8" c:type="guchar"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint" c:identifier="g_value_set_uint">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_UINT #GValue to @v_uint.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_UINT</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_uint" transfer-ownership="none">
            <doc xml:space="preserve">unsigned integer value to be set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint64" c:identifier="g_value_set_uint64">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_UINT64 #GValue to @v_uint64.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_UINT64</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_uint64" transfer-ownership="none">
            <doc xml:space="preserve">unsigned 64bit integer value to be set</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ulong" c:identifier="g_value_set_ulong">
        <doc xml:space="preserve">Set the contents of a %G_TYPE_ULONG #GValue to @v_ulong.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_ULONG</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_ulong" transfer-ownership="none">
            <doc xml:space="preserve">unsigned long integer value to be set</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_variant" c:identifier="g_value_set_variant" version="2.26">
        <doc xml:space="preserve">Set the contents of a variant #GValue to @variant.
If the variant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="variant" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_string" c:identifier="g_value_steal_string" version="2.80">
        <doc xml:space="preserve">Steal ownership on contents of a %G_TYPE_STRING #GValue.
As a result of this operation the value's contents will be reset to %NULL.

The purpose of this call is to provide a way to avoid an extra copy
when some object have been serialized into string through #GValue API.

NOTE: for safety and compatibility purposes, if #GValue contains
static string, or an interned one, this function will return a copy
of the string. Otherwise the transfer notation would be ambiguous.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">string content of @value;
 Should be freed with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="take_boxed" c:identifier="g_value_take_boxed" version="2.4">
        <doc xml:space="preserve">Sets the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed
and takes over the ownership of the caller&#x2019;s reference to @v_boxed;
the caller doesn&#x2019;t have to unref it any more.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_object" c:identifier="g_value_take_object" version="2.4" introspectable="0">
        <doc xml:space="preserve">Sets the contents of a %G_TYPE_OBJECT derived #GValue to @v_object
and takes over the ownership of the caller&#x2019;s reference to @v_object;
the caller doesn&#x2019;t have to unref it any more (i.e. the reference
count of the object is not increased).

If you want the #GValue to hold its own reference to @v_object, use
g_value_set_object() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of %G_TYPE_OBJECT derived type</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">object value to be set</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_param" c:identifier="g_value_take_param" version="2.4" introspectable="0">
        <doc xml:space="preserve">Sets the contents of a %G_TYPE_PARAM #GValue to @param and takes
over the ownership of the caller&#x2019;s reference to @param; the caller
doesn&#x2019;t have to unref it any more.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_PARAM</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="param" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GParamSpec to be set</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_string" c:identifier="g_value_take_string" version="2.4">
        <doc xml:space="preserve">Sets the contents of a %G_TYPE_STRING #GValue to @v_string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">string to take ownership of</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_variant" c:identifier="g_value_take_variant" version="2.26">
        <doc xml:space="preserve">Set the contents of a variant #GValue to @variant, and takes over
the ownership of the caller's reference to @variant;
the caller doesn't have to unref it any more (i.e. the reference
count of the variant is not increased).

If @variant was floating then its floating reference is converted to
a hard reference.

If you want the #GValue to hold its own reference to @variant, use
g_value_set_variant() instead.

This is an internal function introduced mainly for C marshallers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
          <parameter name="variant" transfer-ownership="full" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform" c:identifier="g_value_transform">
        <doc xml:space="preserve">Tries to cast the contents of @src_value into a type appropriate
to store in @dest_value, e.g. to transform a %G_TYPE_INT value
into a %G_TYPE_FLOAT value. Performing transformations between
value types might incur precision lossage. Especially
transformations into strings might reveal seemingly arbitrary
results and shouldn't be relied upon for production code (such
as rcfile value or object property serialization).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether a transformation rule was found and could be applied.
 Upon failing transformations, @dest_value is left untouched.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src_value" transfer-ownership="none">
            <doc xml:space="preserve">Source value.</doc>
            <type name="Value" c:type="const GValue*"/>
          </instance-parameter>
          <parameter name="dest_value" transfer-ownership="none">
            <doc xml:space="preserve">Target value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unset" c:identifier="g_value_unset">
        <doc xml:space="preserve">Clears the current value in @value (if any) and "unsets" the type,
this releases all resources associated with this GValue. An unset
value is the same as an uninitialized (zero-filled) #GValue
structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">An initialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="register_transform_func" c:identifier="g_value_register_transform_func" introspectable="0">
        <doc xml:space="preserve">Registers a value transformation function for use in g_value_transform().
A previously registered transformation function for @src_type and @dest_type
will be replaced.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="src_type" transfer-ownership="none">
            <doc xml:space="preserve">Source type.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="dest_type" transfer-ownership="none">
            <doc xml:space="preserve">Target type.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="transform_func" transfer-ownership="none">
            <doc xml:space="preserve">a function which transforms values of type @src_type
 into value of type @dest_type</doc>
            <type name="ValueTransform" c:type="GValueTransform"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_compatible" c:identifier="g_value_type_compatible">
        <doc xml:space="preserve">Returns whether a #GValue of type @src_type can be copied into
a #GValue of type @dest_type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if g_value_copy() is possible with @src_type and @dest_type.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_type" transfer-ownership="none">
            <doc xml:space="preserve">source type to be copied.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="dest_type" transfer-ownership="none">
            <doc xml:space="preserve">destination type for copying.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_transformable" c:identifier="g_value_type_transformable">
        <doc xml:space="preserve">Check whether g_value_transform() is able to transform values
of type @src_type into values of type @dest_type. Note that for
the types to be transformable, they must be compatible or a
transformation function must be registered.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the transformation is possible, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_type" transfer-ownership="none">
            <doc xml:space="preserve">Source type.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="dest_type" transfer-ownership="none">
            <doc xml:space="preserve">Target type.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ValueArray" c:type="GValueArray" deprecated="1" deprecated-version="2.32" glib:type-name="GValueArray" glib:get-type="g_value_array_get_type" c:symbol-prefix="value_array">
      <doc xml:space="preserve">A `GValueArray` is a container structure to hold an array of generic values.

The prime purpose of a `GValueArray` is for it to be used as an
object property that holds an array of values. A `GValueArray` wraps
an array of `GValue` elements in order for it to be used as a boxed
type through `G_TYPE_VALUE_ARRAY`.

`GValueArray` is deprecated in favour of `GArray` since GLib 2.32.
It is possible to create a `GArray` that behaves like a `GValueArray`
by using the size of `GValue` as the element size, and by setting
[method@GObject.Value.unset] as the clear function using
[func@GLib.Array.set_clear_func], for instance, the following code:

```c
  GValueArray *array = g_value_array_new (10);
```

can be replaced by:

```c
  GArray *array = g_array_sized_new (FALSE, TRUE, sizeof (GValue), 10);
  g_array_set_clear_func (array, (GDestroyNotify) g_value_unset);
```</doc>
      <doc-deprecated xml:space="preserve">Use `GArray` instead, if possible for the given use case,
   as described above.</doc-deprecated>
      <field name="n_values" writable="1">
        <doc xml:space="preserve">number of values contained in the array</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="values" writable="1">
        <doc xml:space="preserve">array of values</doc>
        <type name="Value" c:type="GValue*"/>
      </field>
      <field name="n_prealloced" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <constructor name="new" c:identifier="g_value_array_new" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Allocate and initialize a new #GValueArray, optionally preserve space
for @n_prealloced elements. New arrays always contain 0 elements,
regardless of the value of @n_prealloced.</doc>
        <doc-deprecated xml:space="preserve">Use #GArray and g_array_sized_new() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GValueArray with 0 values</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <parameter name="n_prealloced" transfer-ownership="none">
            <doc xml:space="preserve">number of values to preallocate space for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="g_value_array_append" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Insert a copy of @value as last element of @value_array. If @value is
%NULL, an uninitialized value is appended.</doc>
        <doc-deprecated xml:space="preserve">Use #GArray and g_array_append_val() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value_array" transfer-ownership="none">
            <doc xml:space="preserve">#GValueArray to add an element to</doc>
            <type name="ValueArray" c:type="GValueArray*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">#GValue to copy into #GValueArray, or %NULL</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="g_value_array_copy" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Construct an exact copy of a #GValueArray by duplicating all its
contents.</doc>
        <doc-deprecated xml:space="preserve">Use #GArray and g_array_ref() instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">Newly allocated copy of #GValueArray</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value_array" transfer-ownership="none">
            <doc xml:space="preserve">#GValueArray to copy</doc>
            <type name="ValueArray" c:type="const GValueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="g_value_array_free" introspectable="0" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Free a #GValueArray including its contents.</doc>
        <doc-deprecated xml:space="preserve">Use #GArray and g_array_unref() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value_array" transfer-ownership="none">
            <doc xml:space="preserve">#GValueArray to free</doc>
            <type name="ValueArray" c:type="GValueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nth" c:identifier="g_value_array_get_nth" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Return a pointer to the value at @index_ contained in @value_array.</doc>
        <doc-deprecated xml:space="preserve">Use g_array_index() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">pointer to a value at @index_ in @value_array</doc>
          <type name="Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value_array" transfer-ownership="none">
            <doc xml:space="preserve">#GValueArray to get a value from</doc>
            <type name="ValueArray" c:type="GValueArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">index of the value of interest</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_value_array_insert" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Insert a copy of @value at specified position into @value_array. If @value
is %NULL, an uninitialized value is inserted.</doc>
        <doc-deprecated xml:space="preserve">Use #GArray and g_array_insert_val() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value_array" transfer-ownership="none">
            <doc xml:space="preserve">#GValueArray to add an element to</doc>
            <type name="ValueArray" c:type="GValueArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">insertion position, must be &lt;= value_array-&gt;;n_values</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">#GValue to copy into #GValueArray, or %NULL</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend" c:identifier="g_value_array_prepend" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Insert a copy of @value as first element of @value_array. If @value is
%NULL, an uninitialized value is prepended.</doc>
        <doc-deprecated xml:space="preserve">Use #GArray and g_array_prepend_val() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value_array" transfer-ownership="none">
            <doc xml:space="preserve">#GValueArray to add an element to</doc>
            <type name="ValueArray" c:type="GValueArray*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">#GValue to copy into #GValueArray, or %NULL</doc>
            <type name="Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_value_array_remove" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Remove the value at position @index_ from @value_array.</doc>
        <doc-deprecated xml:space="preserve">Use #GArray and g_array_remove_index() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value_array" transfer-ownership="none">
            <doc xml:space="preserve">#GValueArray to remove an element from</doc>
            <type name="ValueArray" c:type="GValueArray*"/>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:space="preserve">position of value to remove, which must be less than
    @value_array-&gt;n_values</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="sort" c:identifier="g_value_array_sort" shadowed-by="sort_with_data" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Sort @value_array using @compare_func to compare the elements according to
the semantics of #GCompareFunc.

The current implementation uses the same sorting algorithm as standard
C qsort() function.</doc>
        <doc-deprecated xml:space="preserve">Use #GArray and g_array_sort().</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value_array" transfer-ownership="none">
            <doc xml:space="preserve">#GValueArray to sort</doc>
            <type name="ValueArray" c:type="GValueArray*"/>
          </instance-parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">function to compare elements</doc>
            <type name="GLib.CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="sort_with_data" c:identifier="g_value_array_sort_with_data" shadows="sort" deprecated="1" deprecated-version="2.32">
        <doc xml:space="preserve">Sort @value_array using @compare_func to compare the elements according
to the semantics of #GCompareDataFunc.

The current implementation uses the same sorting algorithm as standard
C qsort() function.</doc>
        <doc-deprecated xml:space="preserve">Use #GArray and g_array_sort_with_data().</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value_array" transfer-ownership="none">
            <doc xml:space="preserve">#GValueArray to sort</doc>
            <type name="ValueArray" c:type="GValueArray*"/>
          </instance-parameter>
          <parameter name="compare_func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">function to compare elements</doc>
            <type name="GLib.CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">extra data argument provided for @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="ValueTransform" c:type="GValueTransform">
      <doc xml:space="preserve">The type of value transformation functions which can be registered with
g_value_register_transform_func().

@dest_value will be initialized to the correct destination type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src_value" transfer-ownership="none">
          <doc xml:space="preserve">Source value.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="dest_value" transfer-ownership="none">
          <doc xml:space="preserve">Target value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="VariantBuilder" c:symbol-prefix="variant_builder" glib:type-name="GVariantBuilder" glib:get-type="g_variant_builder_get_type">
    </glib:boxed>
    <glib:boxed glib:name="VariantDict" c:symbol-prefix="variant_dict" glib:type-name="GVariantDict" glib:get-type="g_variant_dict_get_type">
    </glib:boxed>
    <glib:boxed glib:name="VariantType" c:symbol-prefix="variant_type" glib:type-name="GVariantType" glib:get-type="g_variant_type_get_gtype">
    </glib:boxed>
    <callback name="WeakNotify" c:type="GWeakNotify">
      <doc xml:space="preserve">A #GWeakNotify function can be added to an object as a callback that gets
triggered when the object is finalized.

Since the object is already being disposed when the #GWeakNotify is called,
there's not much you could do with the object, apart from e.g. using its
address as hash-index or the like.

In particular, this means it&#x2019;s invalid to call g_object_ref(),
g_weak_ref_init(), g_weak_ref_set(), g_object_add_toggle_ref(),
g_object_weak_ref(), g_object_add_weak_pointer() or any function which calls
them on the object from this callback.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data that was provided when the weak reference was established</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="where_the_object_was" transfer-ownership="none">
          <doc xml:space="preserve">the object being disposed</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="WeakRef" c:type="GWeakRef">
      <doc xml:space="preserve">A structure containing a weak reference to a #GObject.

A `GWeakRef` can either be empty (i.e. point to %NULL), or point to an
object for as long as at least one "strong" reference to that object
exists. Before the object's #GObjectClass.dispose method is called,
every #GWeakRef associated with becomes empty (i.e. points to %NULL).

Like #GValue, #GWeakRef can be statically allocated, stack- or
heap-allocated, or embedded in larger structures.

Unlike g_object_weak_ref() and g_object_add_weak_pointer(), this weak
reference is thread-safe: converting a weak pointer to a reference is
atomic with respect to invalidation of weak pointers to destroyed
objects.

If the object's #GObjectClass.dispose method results in additional
references to the object being held (&#x2018;re-referencing&#x2019;), any #GWeakRefs taken
before it was disposed will continue to point to %NULL.  Any #GWeakRefs taken
during disposal and after re-referencing, or after disposal has returned due
to the re-referencing, will continue to point to the object until its refcount
goes back to zero, at which point they too will be invalidated.

It is invalid to take a #GWeakRef on an object during #GObjectClass.dispose
without first having or creating a strong reference to the object.</doc>
      <union name="priv" c:type="priv">
        <field name="p" writable="1">
          <type name="gpointer" c:type="gpointer"/>
        </field>
      </union>
      <method name="clear" c:identifier="g_weak_ref_clear" version="2.32" introspectable="0">
        <doc xml:space="preserve">Frees resources associated with a non-statically-allocated #GWeakRef.
After this call, the #GWeakRef is left in an undefined state.

You should only call this on a #GWeakRef that previously had
g_weak_ref_init() called on it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="weak_ref" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location of a weak reference, which
 may be empty</doc>
            <type name="WeakRef" c:type="GWeakRef*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="g_weak_ref_get" version="2.32" introspectable="0">
        <doc xml:space="preserve">If @weak_ref is not empty, atomically acquire a strong
reference to the object it points to, and return that reference.

This function is needed because of the potential race between taking
the pointer value and g_object_ref() on it, if the object was losing
its last reference at the same time in a different thread.

The caller should release the resulting reference in the usual way,
by using g_object_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the object pointed to
    by @weak_ref, or %NULL if it was empty</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="weak_ref" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location of a weak reference to a #GObject</doc>
            <type name="WeakRef" c:type="GWeakRef*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="g_weak_ref_init" version="2.32" introspectable="0">
        <doc xml:space="preserve">Initialise a non-statically-allocated #GWeakRef.

This function also calls g_weak_ref_set() with @object on the
freshly-initialised weak reference.

This function should always be matched with a call to
g_weak_ref_clear().  It is not necessary to use this function for a
#GWeakRef in static storage because it will already be
properly initialised.  Just use g_weak_ref_set() directly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="weak_ref" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">uninitialized or empty location for a weak
   reference</doc>
            <type name="WeakRef" c:type="GWeakRef*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GObject or %NULL</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="g_weak_ref_set" version="2.32" introspectable="0">
        <doc xml:space="preserve">Change the object to which @weak_ref points, or set it to
%NULL.

You must own a strong reference on @object while calling this
function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="weak_ref" transfer-ownership="none">
            <doc xml:space="preserve">location for a weak reference</doc>
            <type name="WeakRef" c:type="GWeakRef*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GObject or %NULL</doc>
            <type name="Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <union name="_Value__data__union">
      <field name="v_int" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="v_uint" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="v_long" writable="1">
        <type name="glong" c:type="glong"/>
      </field>
      <field name="v_ulong" writable="1">
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="v_int64" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="v_uint64" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="v_float" writable="1">
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <field name="v_double" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="v_pointer" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </union>
    <function-macro name="assert_finalize_object" c:identifier="g_assert_finalize_object" version="2.62" introspectable="0">
      <doc xml:space="preserve">Assert that @object is non-%NULL, then release one reference to it with
g_object_unref() and assert that it has been finalized (i.e. that there
are no more references).

If assertions are disabled via `G_DISABLE_ASSERT`,
this macro just calls g_object_unref() without any further checks.

This macro should only be used in regression tests.</doc>
      <parameters>
        <parameter name="object">
          <doc xml:space="preserve">an object</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="boxed_copy" c:identifier="g_boxed_copy">
      <doc xml:space="preserve">Provide a copy of a boxed structure @src_boxed which is of type @boxed_type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The newly created copy of the boxed
   structure.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="boxed_type" transfer-ownership="none">
          <doc xml:space="preserve">The type of @src_boxed.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="src_boxed" transfer-ownership="none">
          <doc xml:space="preserve">The boxed structure to be copied.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="boxed_free" c:identifier="g_boxed_free">
      <doc xml:space="preserve">Free the boxed structure @boxed which is of type @boxed_type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="boxed_type" transfer-ownership="none">
          <doc xml:space="preserve">The type of @boxed.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="boxed" transfer-ownership="none">
          <doc xml:space="preserve">The boxed structure to be freed.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="boxed_type_register_static" c:identifier="g_boxed_type_register_static">
      <doc xml:space="preserve">This function creates a new %G_TYPE_BOXED derived type id for a new
boxed type with name @name.

Boxed type handling functions have to be provided to copy and free
opaque boxed structures of this type.

For the general case, it is recommended to use G_DEFINE_BOXED_TYPE()
instead of calling g_boxed_type_register_static() directly. The macro
will create the appropriate `*_get_type()` function for the boxed type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">New %G_TYPE_BOXED derived type id for @name.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">Name of the new boxed type.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="boxed_copy" transfer-ownership="none" scope="forever">
          <doc xml:space="preserve">Boxed structure copy function.</doc>
          <type name="BoxedCopyFunc" c:type="GBoxedCopyFunc"/>
        </parameter>
        <parameter name="boxed_free" transfer-ownership="none" scope="forever">
          <doc xml:space="preserve">Boxed structure free function.</doc>
          <type name="BoxedFreeFunc" c:type="GBoxedFreeFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_BOOLEAN__BOXED_BOXED" c:identifier="g_cclosure_marshal_BOOLEAN__BOXED_BOXED" moved-to="CClosure.marshal_BOOLEAN__BOXED_BOXED">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with handlers that
take two boxed pointers as arguments and return a boolean.  If you
have such a signal, you will probably also need to use an
accumulator, such as g_signal_accumulator_true_handled().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_BOOLEAN__FLAGS" c:identifier="g_cclosure_marshal_BOOLEAN__FLAGS" moved-to="CClosure.marshal_BOOLEAN__FLAGS">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with handlers that
take a flags type as an argument and return a boolean.  If you have
such a signal, you will probably also need to use an accumulator,
such as g_signal_accumulator_true_handled().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_STRING__OBJECT_POINTER" c:identifier="g_cclosure_marshal_STRING__OBJECT_POINTER" moved-to="CClosure.marshal_STRING__OBJECT_POINTER">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with handlers that
take a #GObject and a pointer and produce a string.  It is highly
unlikely that your signal handler fits this description.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__BOOLEAN" c:identifier="g_cclosure_marshal_VOID__BOOLEAN" moved-to="CClosure.marshal_VOID__BOOLEAN">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
boolean argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__BOXED" c:identifier="g_cclosure_marshal_VOID__BOXED" moved-to="CClosure.marshal_VOID__BOXED">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
argument which is any boxed pointer type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__CHAR" c:identifier="g_cclosure_marshal_VOID__CHAR" moved-to="CClosure.marshal_VOID__CHAR">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
character argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__DOUBLE" c:identifier="g_cclosure_marshal_VOID__DOUBLE" moved-to="CClosure.marshal_VOID__DOUBLE">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with one
double-precision floating point argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__ENUM" c:identifier="g_cclosure_marshal_VOID__ENUM" moved-to="CClosure.marshal_VOID__ENUM">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
argument with an enumerated type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__FLAGS" c:identifier="g_cclosure_marshal_VOID__FLAGS" moved-to="CClosure.marshal_VOID__FLAGS">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
argument with a flags types.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__FLOAT" c:identifier="g_cclosure_marshal_VOID__FLOAT" moved-to="CClosure.marshal_VOID__FLOAT">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with one
single-precision floating point argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__INT" c:identifier="g_cclosure_marshal_VOID__INT" moved-to="CClosure.marshal_VOID__INT">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
integer argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__LONG" c:identifier="g_cclosure_marshal_VOID__LONG" moved-to="CClosure.marshal_VOID__LONG">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with with a single
long integer argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__OBJECT" c:identifier="g_cclosure_marshal_VOID__OBJECT" moved-to="CClosure.marshal_VOID__OBJECT">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
#GObject argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__PARAM" c:identifier="g_cclosure_marshal_VOID__PARAM" moved-to="CClosure.marshal_VOID__PARAM">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
argument of type #GParamSpec.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__POINTER" c:identifier="g_cclosure_marshal_VOID__POINTER" moved-to="CClosure.marshal_VOID__POINTER">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single raw
pointer argument type.

If it is possible, it is better to use one of the more specific
functions such as g_cclosure_marshal_VOID__OBJECT() or
g_cclosure_marshal_VOID__OBJECT().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__STRING" c:identifier="g_cclosure_marshal_VOID__STRING" moved-to="CClosure.marshal_VOID__STRING">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single string
argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__UCHAR" c:identifier="g_cclosure_marshal_VOID__UCHAR" moved-to="CClosure.marshal_VOID__UCHAR">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
unsigned character argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__UINT" c:identifier="g_cclosure_marshal_VOID__UINT" moved-to="CClosure.marshal_VOID__UINT">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with with a single
unsigned integer argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__UINT_POINTER" c:identifier="g_cclosure_marshal_VOID__UINT_POINTER" moved-to="CClosure.marshal_VOID__UINT_POINTER">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with an unsigned int
and a pointer as arguments.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__ULONG" c:identifier="g_cclosure_marshal_VOID__ULONG" moved-to="CClosure.marshal_VOID__ULONG">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
unsigned long integer argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__VARIANT" c:identifier="g_cclosure_marshal_VOID__VARIANT" moved-to="CClosure.marshal_VOID__VARIANT">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with a single
#GVariant argument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__VOID" c:identifier="g_cclosure_marshal_VOID__VOID" moved-to="CClosure.marshal_VOID__VOID">
      <doc xml:space="preserve">A #GClosureMarshal function for use with signals with no arguments.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_generic" c:identifier="g_cclosure_marshal_generic" moved-to="CClosure.marshal_generic" version="2.30">
      <doc xml:space="preserve">A generic marshaller function implemented via
[libffi](http://sourceware.org/libffi/).

Normally this function is not passed explicitly to g_signal_new(),
but used automatically by GLib when specifying a %NULL marshaller.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">A #GClosure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_gvalue" transfer-ownership="none">
          <doc xml:space="preserve">A #GValue to store the return value. May be %NULL
  if the callback of closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:space="preserve">The length of the @param_values array.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GValues holding the arguments
  on which to invoke the callback of closure.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The invocation hint given as the last argument to
  g_closure_invoke().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Additional data specified when registering the
  marshaller, see g_closure_set_marshal() and
  g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_new" c:identifier="g_cclosure_new" moved-to="CClosure.new" introspectable="0">
      <doc xml:space="preserve">Creates a new closure which invokes @callback_func with @user_data as
the last parameter.

@destroy_data will be called as a finalize notifier on the #GClosure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a floating reference to a new #GCClosure</doc>
        <type name="Closure" c:type="GClosure*"/>
      </return-value>
      <parameters>
        <parameter name="callback_func" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">the function to invoke</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to @callback_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy_data" transfer-ownership="none">
          <doc xml:space="preserve">destroy notify to be called when @user_data is no longer used</doc>
          <type name="ClosureNotify" c:type="GClosureNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_new_object" c:identifier="g_cclosure_new_object" moved-to="CClosure.new_object" introspectable="0">
      <doc xml:space="preserve">A variant of g_cclosure_new() which uses @object as @user_data and
calls g_object_watch_closure() on @object and the created
closure. This function is useful when you have a callback closely
associated with a #GObject, and want the callback to no longer run
after the object is is freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new #GCClosure</doc>
        <type name="Closure" c:type="GClosure*"/>
      </return-value>
      <parameters>
        <parameter name="callback_func" transfer-ownership="none">
          <doc xml:space="preserve">the function to invoke</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">a #GObject pointer to pass to @callback_func</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_new_object_swap" c:identifier="g_cclosure_new_object_swap" moved-to="CClosure.new_object_swap" introspectable="0">
      <doc xml:space="preserve">A variant of g_cclosure_new_swap() which uses @object as @user_data
and calls g_object_watch_closure() on @object and the created
closure. This function is useful when you have a callback closely
associated with a #GObject, and want the callback to no longer run
after the object is is freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new #GCClosure</doc>
        <type name="Closure" c:type="GClosure*"/>
      </return-value>
      <parameters>
        <parameter name="callback_func" transfer-ownership="none">
          <doc xml:space="preserve">the function to invoke</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">a #GObject pointer to pass to @callback_func</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_new_swap" c:identifier="g_cclosure_new_swap" moved-to="CClosure.new_swap" introspectable="0">
      <doc xml:space="preserve">Creates a new closure which invokes @callback_func with @user_data as
the first parameter.

@destroy_data will be called as a finalize notifier on the #GClosure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a floating reference to a new #GCClosure</doc>
        <type name="Closure" c:type="GClosure*"/>
      </return-value>
      <parameters>
        <parameter name="callback_func" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">the function to invoke</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data to pass to @callback_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy_data" transfer-ownership="none">
          <doc xml:space="preserve">destroy notify to be called when @user_data is no longer used</doc>
          <type name="ClosureNotify" c:type="GClosureNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="clear_object" c:identifier="g_clear_object" version="2.28" introspectable="0">
      <doc xml:space="preserve">Clears a reference to a #GObject.

@object_ptr must not be %NULL.

If the reference is %NULL then this function does nothing.
Otherwise, the reference count of the object is decreased and the
pointer is set to %NULL.

A macro is also included that allows this function to be used without
pointer casts.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object_ptr" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #GObject reference</doc>
          <type name="Object" c:type="GObject**"/>
        </parameter>
      </parameters>
    </function>
    <function name="clear_signal_handler" c:identifier="g_clear_signal_handler" version="2.62">
      <doc xml:space="preserve">Disconnects a handler from @instance so it will not be called during
any future or currently ongoing emissions of the signal it has been
connected to. The @handler_id_ptr is then set to zero, which is never a valid handler ID value (see g_signal_connect()).

If the handler ID is 0 then this function does nothing.

There is also a macro version of this function so that the code
will be inlined.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handler_id_ptr" transfer-ownership="none">
          <doc xml:space="preserve">A pointer to a handler ID (of type #gulong) of the handler to be disconnected.</doc>
          <type name="gulong" c:type="gulong*"/>
        </parameter>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">The instance to remove the signal handler from.
  This pointer may be %NULL or invalid, if the handler ID is zero.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="clear_weak_pointer" c:identifier="g_clear_weak_pointer" version="2.56" introspectable="0">
      <doc xml:space="preserve">Clears a weak reference to a #GObject.

@weak_pointer_location must not be %NULL.

If the weak reference is %NULL then this function does nothing.
Otherwise, the weak reference to the object is removed for that location
and the pointer is set to %NULL.

A macro is also included that allows this function to be used without
pointer casts. The function itself is static inline, so its address may vary
between compilation units.</doc>
      <parameters>
        <parameter name="weak_pointer_location">
          <doc xml:space="preserve">The memory address of a pointer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="enum_complete_type_info" c:identifier="g_enum_complete_type_info">
      <doc xml:space="preserve">This function is meant to be called from the `complete_type_info`
function of a #GTypePlugin implementation, as in the following
example:

|[&lt;!-- language="C" --&gt;
static void
my_enum_complete_type_info (GTypePlugin     *plugin,
                            GType            g_type,
                            GTypeInfo       *info,
                            GTypeValueTable *value_table)
{
  static const GEnumValue values[] = {
    { MY_ENUM_FOO, "MY_ENUM_FOO", "foo" },
    { MY_ENUM_BAR, "MY_ENUM_BAR", "bar" },
    { 0, NULL, NULL }
  };

  g_enum_complete_type_info (type, info, values);
}
]|</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_enum_type" transfer-ownership="none">
          <doc xml:space="preserve">the type identifier of the type being completed</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the #GTypeInfo struct to be filled in</doc>
          <type name="TypeInfo" c:type="GTypeInfo*"/>
        </parameter>
        <parameter name="const_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GEnumValue structs for the possible
 enumeration values. The array is terminated by a struct with all
 members being 0.</doc>
          <type name="EnumValue" c:type="const GEnumValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_get_value" c:identifier="g_enum_get_value">
      <doc xml:space="preserve">Returns the #GEnumValue for a value.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the #GEnumValue for @value, or %NULL
         if @value is not a member of the enumeration</doc>
        <type name="EnumValue" c:type="GEnumValue*"/>
      </return-value>
      <parameters>
        <parameter name="enum_class" transfer-ownership="none">
          <doc xml:space="preserve">a #GEnumClass</doc>
          <type name="EnumClass" c:type="GEnumClass*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value to look up</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_get_value_by_name" c:identifier="g_enum_get_value_by_name">
      <doc xml:space="preserve">Looks up a #GEnumValue by name.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the #GEnumValue with name @name,
         or %NULL if the enumeration doesn't have a member
         with that name</doc>
        <type name="EnumValue" c:type="GEnumValue*"/>
      </return-value>
      <parameters>
        <parameter name="enum_class" transfer-ownership="none">
          <doc xml:space="preserve">a #GEnumClass</doc>
          <type name="EnumClass" c:type="GEnumClass*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the name to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_get_value_by_nick" c:identifier="g_enum_get_value_by_nick">
      <doc xml:space="preserve">Looks up a #GEnumValue by nickname.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the #GEnumValue with nickname @nick,
         or %NULL if the enumeration doesn't have a member
         with that nickname</doc>
        <type name="EnumValue" c:type="GEnumValue*"/>
      </return-value>
      <parameters>
        <parameter name="enum_class" transfer-ownership="none">
          <doc xml:space="preserve">a #GEnumClass</doc>
          <type name="EnumClass" c:type="GEnumClass*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">the nickname to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_register_static" c:identifier="g_enum_register_static">
      <doc xml:space="preserve">Registers a new static enumeration type with the name @name.

It is normally more convenient to let [glib-mkenums][glib-mkenums],
generate a my_enum_get_type() function from a usual C enumeration
definition  than to write one yourself using g_enum_register_static().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The new type identifier.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">A nul-terminated string used as the name of the new type.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="const_static_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GEnumValue structs for the possible
 enumeration values. The array is terminated by a struct with all
 members being 0. GObject keeps a reference to the data, so it cannot
 be stack-allocated.</doc>
          <type name="EnumValue" c:type="const GEnumValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_to_string" c:identifier="g_enum_to_string" version="2.54">
      <doc xml:space="preserve">Pretty-prints @value in the form of the enum&#x2019;s name.

This is intended to be used for debugging purposes. The format of the output
may change in the future.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated text string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="g_enum_type" transfer-ownership="none">
          <doc xml:space="preserve">the type identifier of a #GEnumClass type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="flags_complete_type_info" c:identifier="g_flags_complete_type_info">
      <doc xml:space="preserve">This function is meant to be called from the complete_type_info()
function of a #GTypePlugin implementation, see the example for
g_enum_complete_type_info() above.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_flags_type" transfer-ownership="none">
          <doc xml:space="preserve">the type identifier of the type being completed</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the #GTypeInfo struct to be filled in</doc>
          <type name="TypeInfo" c:type="GTypeInfo*"/>
        </parameter>
        <parameter name="const_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GFlagsValue structs for the possible
 enumeration values. The array is terminated by a struct with all
 members being 0.</doc>
          <type name="FlagsValue" c:type="const GFlagsValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="flags_get_first_value" c:identifier="g_flags_get_first_value">
      <doc xml:space="preserve">Returns the first #GFlagsValue which is set in @value.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the first #GFlagsValue which is set in
         @value, or %NULL if none is set</doc>
        <type name="FlagsValue" c:type="GFlagsValue*"/>
      </return-value>
      <parameters>
        <parameter name="flags_class" transfer-ownership="none">
          <doc xml:space="preserve">a #GFlagsClass</doc>
          <type name="FlagsClass" c:type="GFlagsClass*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="flags_get_value_by_name" c:identifier="g_flags_get_value_by_name">
      <doc xml:space="preserve">Looks up a #GFlagsValue by name.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the #GFlagsValue with name @name,
         or %NULL if there is no flag with that name</doc>
        <type name="FlagsValue" c:type="GFlagsValue*"/>
      </return-value>
      <parameters>
        <parameter name="flags_class" transfer-ownership="none">
          <doc xml:space="preserve">a #GFlagsClass</doc>
          <type name="FlagsClass" c:type="GFlagsClass*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the name to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="flags_get_value_by_nick" c:identifier="g_flags_get_value_by_nick">
      <doc xml:space="preserve">Looks up a #GFlagsValue by nickname.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the #GFlagsValue with nickname @nick,
         or %NULL if there is no flag with that nickname</doc>
        <type name="FlagsValue" c:type="GFlagsValue*"/>
      </return-value>
      <parameters>
        <parameter name="flags_class" transfer-ownership="none">
          <doc xml:space="preserve">a #GFlagsClass</doc>
          <type name="FlagsClass" c:type="GFlagsClass*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">the nickname to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="flags_register_static" c:identifier="g_flags_register_static">
      <doc xml:space="preserve">Registers a new static flags type with the name @name.

It is normally more convenient to let [glib-mkenums][glib-mkenums]
generate a my_flags_get_type() function from a usual C enumeration
definition than to write one yourself using g_flags_register_static().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The new type identifier.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">A nul-terminated string used as the name of the new type.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="const_static_values" transfer-ownership="none">
          <doc xml:space="preserve">An array of #GFlagsValue structs for the possible
 flags values. The array is terminated by a struct with all members being 0.
 GObject keeps a reference to the data, so it cannot be stack-allocated.</doc>
          <type name="FlagsValue" c:type="const GFlagsValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="flags_to_string" c:identifier="g_flags_to_string" version="2.54">
      <doc xml:space="preserve">Pretty-prints @value in the form of the flag names separated by ` | ` and
sorted. Any extra bits will be shown at the end as a hexadecimal number.

This is intended to be used for debugging purposes. The format of the output
may change in the future.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated text string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="flags_type" transfer-ownership="none">
          <doc xml:space="preserve">the type identifier of a #GFlagsClass type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="gtype_get_type" c:identifier="g_gtype_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="param_spec_boolean" c:identifier="g_param_spec_boolean">
      <doc xml:space="preserve">Creates a new #GParamSpecBoolean instance specifying a %G_TYPE_BOOLEAN
property. In many cases, it may be more appropriate to use an enum with
g_param_spec_enum(), both to improve code clarity by using explicitly named
values, and to allow for more values to be added in future without breaking
API.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_boxed" c:identifier="g_param_spec_boxed">
      <doc xml:space="preserve">Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_BOXED
derived property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="boxed_type" transfer-ownership="none">
          <doc xml:space="preserve">%G_TYPE_BOXED derived type of this property</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_char" c:identifier="g_param_spec_char">
      <doc xml:space="preserve">Creates a new #GParamSpecChar instance specifying a %G_TYPE_CHAR property.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="gint8" c:type="gint8"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="gint8" c:type="gint8"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gint8" c:type="gint8"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_double" c:identifier="g_param_spec_double">
      <doc xml:space="preserve">Creates a new #GParamSpecDouble instance specifying a %G_TYPE_DOUBLE
property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_enum" c:identifier="g_param_spec_enum">
      <doc xml:space="preserve">Creates a new #GParamSpecEnum instance specifying a %G_TYPE_ENUM
property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="enum_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType derived from %G_TYPE_ENUM</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_flags" c:identifier="g_param_spec_flags">
      <doc xml:space="preserve">Creates a new #GParamSpecFlags instance specifying a %G_TYPE_FLAGS
property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType derived from %G_TYPE_FLAGS</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_float" c:identifier="g_param_spec_float">
      <doc xml:space="preserve">Creates a new #GParamSpecFloat instance specifying a %G_TYPE_FLOAT property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_gtype" c:identifier="g_param_spec_gtype" version="2.10">
      <doc xml:space="preserve">Creates a new #GParamSpecGType instance specifying a
%G_TYPE_GTYPE property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="is_a_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType whose subtypes are allowed as values
 of the property (use %G_TYPE_NONE for any type)</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_int" c:identifier="g_param_spec_int">
      <doc xml:space="preserve">Creates a new #GParamSpecInt instance specifying a %G_TYPE_INT property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_int64" c:identifier="g_param_spec_int64">
      <doc xml:space="preserve">Creates a new #GParamSpecInt64 instance specifying a %G_TYPE_INT64 property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_long" c:identifier="g_param_spec_long">
      <doc xml:space="preserve">Creates a new #GParamSpecLong instance specifying a %G_TYPE_LONG property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_object" c:identifier="g_param_spec_object">
      <doc xml:space="preserve">Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_OBJECT
derived property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="object_type" transfer-ownership="none">
          <doc xml:space="preserve">%G_TYPE_OBJECT derived type of this property</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_override" c:identifier="g_param_spec_override" version="2.4" introspectable="0">
      <doc xml:space="preserve">Creates a new property of type #GParamSpecOverride. This is used
to direct operations to another paramspec, and will not be directly
useful unless you are implementing a new base type similar to GObject.</doc>
      <return-value>
        <doc xml:space="preserve">the newly created #GParamSpec</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the property.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="overridden" transfer-ownership="none">
          <doc xml:space="preserve">The property that is being overridden</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_param" c:identifier="g_param_spec_param">
      <doc xml:space="preserve">Creates a new #GParamSpecParam instance specifying a %G_TYPE_PARAM
property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="param_type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType derived from %G_TYPE_PARAM</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_pointer" c:identifier="g_param_spec_pointer">
      <doc xml:space="preserve">Creates a new #GParamSpecPointer instance specifying a pointer property.
Where possible, it is better to use g_param_spec_object() or
g_param_spec_boxed() to expose memory management information.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_string" c:identifier="g_param_spec_string">
      <doc xml:space="preserve">Creates a new #GParamSpecString instance.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_uchar" c:identifier="g_param_spec_uchar">
      <doc xml:space="preserve">Creates a new #GParamSpecUChar instance specifying a %G_TYPE_UCHAR property.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_uint" c:identifier="g_param_spec_uint">
      <doc xml:space="preserve">Creates a new #GParamSpecUInt instance specifying a %G_TYPE_UINT property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_uint64" c:identifier="g_param_spec_uint64">
      <doc xml:space="preserve">Creates a new #GParamSpecUInt64 instance specifying a %G_TYPE_UINT64
property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_ulong" c:identifier="g_param_spec_ulong">
      <doc xml:space="preserve">Creates a new #GParamSpecULong instance specifying a %G_TYPE_ULONG
property.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_unichar" c:identifier="g_param_spec_unichar">
      <doc xml:space="preserve">Creates a new #GParamSpecUnichar instance specifying a %G_TYPE_UINT
property. #GValue structures for this property can be accessed with
g_value_set_uint() and g_value_get_uint().

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_value_array" c:identifier="g_param_spec_value_array" introspectable="0">
      <doc xml:space="preserve">Creates a new #GParamSpecValueArray instance specifying a
%G_TYPE_VALUE_ARRAY property. %G_TYPE_VALUE_ARRAY is a
%G_TYPE_BOXED type, as such, #GValue structures for this property
can be accessed with g_value_set_boxed() and g_value_get_boxed().

See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="element_spec" transfer-ownership="none">
          <doc xml:space="preserve">a #GParamSpec describing the elements contained in
 arrays of this property, may be %NULL</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_variant" c:identifier="g_param_spec_variant" version="2.26">
      <doc xml:space="preserve">Creates a new #GParamSpecVariant instance specifying a #GVariant
property.

If @default_value is floating, it is consumed.

See g_param_spec_internal() for details on property names.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly created #GParamSpec</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GVariantType</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="full" nullable="1" allow-none="1">
          <doc xml:space="preserve">a #GVariant of type @type to
                use as the default value, or %NULL</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_type_register_static" c:identifier="g_param_type_register_static">
      <doc xml:space="preserve">Registers @name as the name of a new static type derived
from %G_TYPE_PARAM.

The type system uses the information contained in the #GParamSpecTypeInfo
structure pointed to by @info to manage the #GParamSpec type and its
instances.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The new type identifier.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">0-terminated string used as the name of the new #GParamSpec type.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="pspec_info" transfer-ownership="none">
          <doc xml:space="preserve">The #GParamSpecTypeInfo for this #GParamSpec type.</doc>
          <type name="ParamSpecTypeInfo" c:type="const GParamSpecTypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_value_convert" c:identifier="g_param_value_convert">
      <doc xml:space="preserve">Transforms @src_value into @dest_value if possible, and then
validates @dest_value, in order for it to conform to @pspec.  If
@strict_validation is %TRUE this function will only succeed if the
transformed @dest_value complied to @pspec without modifications.

See also g_value_type_transformable(), g_value_transform() and
g_param_value_validate().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if transformation and validation were successful,
 %FALSE otherwise and @dest_value is left untouched.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:space="preserve">a valid #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="src_value" transfer-ownership="none">
          <doc xml:space="preserve">source #GValue</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="dest_value" transfer-ownership="none">
          <doc xml:space="preserve">destination #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="strict_validation" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE requires @dest_value to conform to @pspec
without modifications</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_value_defaults" c:identifier="g_param_value_defaults">
      <doc xml:space="preserve">Checks whether @value contains the default value as specified in @pspec.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether @value contains the canonical default for this @pspec</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:space="preserve">a valid #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_value_is_valid" c:identifier="g_param_value_is_valid" version="2.74">
      <doc xml:space="preserve">Return whether the contents of @value comply with the specifications
set out by @pspec.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the contents of @value comply with the specifications
  set out by @pspec.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:space="preserve">a valid #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_value_set_default" c:identifier="g_param_value_set_default">
      <doc xml:space="preserve">Sets @value to its default value as specified in @pspec.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:space="preserve">a valid #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue of correct type for @pspec; since 2.64, you
  can also pass an empty #GValue, initialized with %G_VALUE_INIT</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_value_validate" c:identifier="g_param_value_validate">
      <doc xml:space="preserve">Ensures that the contents of @value comply with the specifications
set out by @pspec. For example, a #GParamSpecInt might require
that integers stored in @value may not be smaller than -42 and not be
greater than +42. If @value contains an integer outside of this range,
it is modified accordingly, so the resulting value will fit into the
range -42 .. +42.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether modifying @value was necessary to ensure validity</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:space="preserve">a valid #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_values_cmp" c:identifier="g_param_values_cmp">
      <doc xml:space="preserve">Compares @value1 with @value2 according to @pspec, and return -1, 0 or +1,
if @value1 is found to be less than, equal to or greater than @value2,
respectively.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">-1, 0 or +1, for a less than, equal to or greater than result</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:space="preserve">a valid #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pointer_type_register_static" c:identifier="g_pointer_type_register_static">
      <doc xml:space="preserve">Creates a new %G_TYPE_POINTER derived type id for a new
pointer type with name @name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new %G_TYPE_POINTER derived type id for @name.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the new pointer type.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="set_object" c:identifier="g_set_object" version="2.44" introspectable="0">
      <doc xml:space="preserve">Updates a #GObject pointer to refer to @new_object.

It increments the reference count of @new_object (if non-%NULL), decrements
the reference count of the current value of @object_ptr (if non-%NULL), and
assigns @new_object to @object_ptr. The assignment is not atomic.

@object_ptr must not be %NULL, but can point to a %NULL value.

A macro is also included that allows this function to be used without
pointer casts. The function itself is static inline, so its address may vary
between compilation units.

One convenient usage of this function is in implementing property setters:
|[
  void
  foo_set_bar (Foo *foo,
               Bar *new_bar)
  {
    g_return_if_fail (IS_FOO (foo));
    g_return_if_fail (new_bar == NULL || IS_BAR (new_bar));

    if (g_set_object (&amp;foo-&gt;bar, new_bar))
      g_object_notify (foo, "bar");
  }
]|</doc>
      <parameters>
        <parameter name="object_ptr">
          <doc xml:space="preserve">a pointer to a #GObject reference</doc>
        </parameter>
        <parameter name="new_object">
          <doc xml:space="preserve">a pointer to the new #GObject to
  assign to @object_ptr, or %NULL to clear the pointer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="set_weak_pointer" c:identifier="g_set_weak_pointer" version="2.56" introspectable="0">
      <doc xml:space="preserve">Updates a pointer to weakly refer to @new_object.

It assigns @new_object to @weak_pointer_location and ensures
that @weak_pointer_location will automatically be set to %NULL
if @new_object gets destroyed. The assignment is not atomic.
The weak reference is not thread-safe, see g_object_add_weak_pointer()
for details.

The @weak_pointer_location argument must not be %NULL.

A macro is also included that allows this function to be used without
pointer casts. The function itself is static inline, so its address may vary
between compilation units.

One convenient usage of this function is in implementing property setters:
|[
  void
  foo_set_bar (Foo *foo,
               Bar *new_bar)
  {
    g_return_if_fail (IS_FOO (foo));
    g_return_if_fail (new_bar == NULL || IS_BAR (new_bar));

    if (g_set_weak_pointer (&amp;foo-&gt;bar, new_bar))
      g_object_notify (foo, "bar");
  }
]|</doc>
      <parameters>
        <parameter name="weak_pointer_location">
          <doc xml:space="preserve">the memory address of a pointer</doc>
        </parameter>
        <parameter name="new_object">
          <doc xml:space="preserve">a pointer to the new #GObject to
  assign to it, or %NULL to clear the pointer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="signal_accumulator_first_wins" c:identifier="g_signal_accumulator_first_wins" version="2.28">
      <doc xml:space="preserve">A predefined #GSignalAccumulator for signals intended to be used as a
hook for application code to provide a particular value.  Usually
only one such value is desired and multiple handlers for the same
signal don't make much sense (except for the case of the default
handler defined in the class structure, in which case you will
usually want the signal connection to override the class handler).

This accumulator will use the return value from the first signal
handler that is run as the return value for the signal and not run
any further handlers (ie: the first handler "wins").</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">standard #GSignalAccumulator result</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ihint" transfer-ownership="none">
          <doc xml:space="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*"/>
        </parameter>
        <parameter name="return_accu" transfer-ownership="none">
          <doc xml:space="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="handler_return" transfer-ownership="none">
          <doc xml:space="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="dummy" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_accumulator_true_handled" c:identifier="g_signal_accumulator_true_handled" version="2.4">
      <doc xml:space="preserve">A predefined #GSignalAccumulator for signals that return a
boolean values. The behavior that this accumulator gives is
that a return of %TRUE stops the signal emission: no further
callbacks will be invoked, while a return of %FALSE allows
the emission to continue. The idea here is that a %TRUE return
indicates that the callback handled the signal, and no further
handling is needed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">standard #GSignalAccumulator result</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ihint" transfer-ownership="none">
          <doc xml:space="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*"/>
        </parameter>
        <parameter name="return_accu" transfer-ownership="none">
          <doc xml:space="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="handler_return" transfer-ownership="none">
          <doc xml:space="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="dummy" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_add_emission_hook" c:identifier="g_signal_add_emission_hook">
      <doc xml:space="preserve">Adds an emission hook for a signal, which will get called for any emission
of that signal, independent of the instance. This is possible only
for signals which don't have %G_SIGNAL_NO_HOOKS flag set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the hook id, for later use with g_signal_remove_emission_hook().</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">the signal identifier, as returned by g_signal_lookup().</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:space="preserve">the detail on which to call the hook.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="hook_func" transfer-ownership="none" scope="notified" closure="3" destroy="4">
          <doc xml:space="preserve">a #GSignalEmissionHook function.</doc>
          <type name="SignalEmissionHook" c:type="GSignalEmissionHook"/>
        </parameter>
        <parameter name="hook_data" transfer-ownership="none" nullable="1" allow-none="1" scope="notified">
          <doc xml:space="preserve">user data for @hook_func.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data_destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" destroy="3">
          <doc xml:space="preserve">a #GDestroyNotify for @hook_data.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_chain_from_overridden" c:identifier="g_signal_chain_from_overridden">
      <doc xml:space="preserve">Calls the original class closure of a signal. This function should only
be called from an overridden class closure; see
g_signal_override_class_closure() and
g_signal_override_class_handler().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance_and_params" transfer-ownership="none">
          <doc xml:space="preserve">the argument list of the signal emission.
 The first element in the array is a #GValue for the instance the signal
 is being emitted on. The rest are any arguments to be passed to the signal.</doc>
          <array zero-terminated="0" c:type="const GValue*">
            <type name="Value" c:type="GValue"/>
          </array>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">Location for the return value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_chain_from_overridden_handler" c:identifier="g_signal_chain_from_overridden_handler" version="2.18" introspectable="0">
      <doc xml:space="preserve">Calls the original class closure of a signal. This function should
only be called from an overridden class closure; see
g_signal_override_class_closure() and
g_signal_override_class_handler().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the instance the signal is being
   emitted on.</doc>
          <type name="TypeInstance" c:type="gpointer"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">parameters to be passed to the parent class closure, followed by a
 location for the return value. If the return type of the signal
 is %G_TYPE_NONE, the return value location can be omitted.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="signal_connect" c:identifier="g_signal_connect" introspectable="0">
      <doc xml:space="preserve">Connects a [type@GObject.Callback] function to a signal for a particular object.

The handler will be called synchronously, before the default handler of the signal.
[func@GObject.signal_emit] will not return control until all handlers are called.

See [memory management of signal handlers](signals.html#Memory_management_of_signal_handlers) for
details on how to handle the return value and memory management of @data.

This function cannot fail. If the given signal doesn&#x2019;t exist, a critical
warning is emitted.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">the instance to connect to.</doc>
        </parameter>
        <parameter name="detailed_signal">
          <doc xml:space="preserve">a string of the form "signal-name::detail".</doc>
        </parameter>
        <parameter name="c_handler">
          <doc xml:space="preserve">the #GCallback to connect.</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">data to pass to @c_handler calls.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="signal_connect_after" c:identifier="g_signal_connect_after" introspectable="0">
      <doc xml:space="preserve">Connects a #GCallback function to a signal for a particular object.

The handler will be called synchronously, after the default handler of the signal.

This function cannot fail. If the given signal doesn&#x2019;t exist, a critical
warning is emitted.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">the instance to connect to.</doc>
        </parameter>
        <parameter name="detailed_signal">
          <doc xml:space="preserve">a string of the form "signal-name::detail".</doc>
        </parameter>
        <parameter name="c_handler">
          <doc xml:space="preserve">the #GCallback to connect.</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">data to pass to @c_handler calls.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="signal_connect_closure" c:identifier="g_signal_connect_closure">
      <doc xml:space="preserve">Connects a closure to a signal for a particular object.

If @closure is a floating reference (see g_closure_sink()), this function
takes ownership of @closure.

This function cannot fail. If the given signal doesn&#x2019;t exist, a critical
warning is emitted.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the handler ID (always greater than 0)</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the instance to connect to.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:space="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">the closure to connect.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="after" transfer-ownership="none">
          <doc xml:space="preserve">whether the handler should be called before or after the
 default handler of the signal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_connect_closure_by_id" c:identifier="g_signal_connect_closure_by_id">
      <doc xml:space="preserve">Connects a closure to a signal for a particular object.

If @closure is a floating reference (see g_closure_sink()), this function
takes ownership of @closure.

This function cannot fail. If the given signal doesn&#x2019;t exist, a critical
warning is emitted.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the handler ID (always greater than 0)</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the instance to connect to.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">the id of the signal.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:space="preserve">the detail.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">the closure to connect.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="after" transfer-ownership="none">
          <doc xml:space="preserve">whether the handler should be called before or after the
 default handler of the signal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_connect_data" c:identifier="g_signal_connect_data" introspectable="0">
      <doc xml:space="preserve">Connects a #GCallback function to a signal for a particular object. Similar
to g_signal_connect(), but allows to provide a #GClosureNotify for the data
which will be called when the signal handler is disconnected and no longer
used. Specify @connect_flags if you need `..._after()` or
`..._swapped()` variants of this function.

This function cannot fail. If the given signal doesn&#x2019;t exist, a critical
warning is emitted.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the handler ID (always greater than 0)</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the instance to connect to.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:space="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="c_handler" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">the #GCallback to connect.</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" scope="notified">
          <doc xml:space="preserve">data to pass to @c_handler calls.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy_data" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" destroy="3">
          <doc xml:space="preserve">a #GClosureNotify for @data.</doc>
          <type name="ClosureNotify" c:type="GClosureNotify"/>
        </parameter>
        <parameter name="connect_flags" transfer-ownership="none">
          <doc xml:space="preserve">a combination of #GConnectFlags.</doc>
          <type name="ConnectFlags" c:type="GConnectFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_connect_object" c:identifier="g_signal_connect_object" introspectable="0">
      <doc xml:space="preserve">This is similar to g_signal_connect_data(), but uses a closure which
ensures that the @gobject stays alive during the call to @c_handler
by temporarily adding a reference count to @gobject.

When the @gobject is destroyed the signal handler will be automatically
disconnected.  Note that this is not currently threadsafe (ie:
emitting a signal while @gobject is being destroyed in another thread
is not safe).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the handler id.</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the instance to connect to.</doc>
          <type name="TypeInstance" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:space="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="c_handler" transfer-ownership="none">
          <doc xml:space="preserve">the #GCallback to connect.</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="gobject" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the object to pass as data
   to @c_handler.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="connect_flags" transfer-ownership="none">
          <doc xml:space="preserve">a combination of #GConnectFlags.</doc>
          <type name="ConnectFlags" c:type="GConnectFlags"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="signal_connect_swapped" c:identifier="g_signal_connect_swapped" introspectable="0">
      <doc xml:space="preserve">Connects a #GCallback function to a signal for a particular object.

The instance on which the signal is emitted and @data will be swapped when
calling the handler. This is useful when calling pre-existing functions to
operate purely on the @data, rather than the @instance: swapping the
parameters avoids the need to write a wrapper function.

For example, this allows the shorter code:
|[&lt;!-- language="C" --&gt;
g_signal_connect_swapped (button, "clicked",
                          (GCallback) gtk_widget_hide, other_widget);
]|

Rather than the cumbersome:
|[&lt;!-- language="C" --&gt;
static void
button_clicked_cb (GtkButton *button, GtkWidget *other_widget)
{
    gtk_widget_hide (other_widget);
}

...

g_signal_connect (button, "clicked",
                  (GCallback) button_clicked_cb, other_widget);
]|

This function cannot fail. If the given signal doesn&#x2019;t exist, a critical
warning is emitted.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">the instance to connect to.</doc>
        </parameter>
        <parameter name="detailed_signal">
          <doc xml:space="preserve">a string of the form "signal-name::detail".</doc>
        </parameter>
        <parameter name="c_handler">
          <doc xml:space="preserve">the #GCallback to connect.</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">data to pass to @c_handler calls.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="signal_emit" c:identifier="g_signal_emit" introspectable="0">
      <doc xml:space="preserve">Emits a signal. Signal emission is done synchronously.
The method will only return control after all handlers are called or signal emission was stopped.

Note that g_signal_emit() resets the return value to the default
if no handlers are connected, in contrast to g_signal_emitv().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the instance the signal is being emitted on.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">the signal id</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:space="preserve">the detail</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">parameters to be passed to the signal, followed by a
 location for the return value. If the return type of the signal
 is %G_TYPE_NONE, the return value location can be omitted.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_emit_by_name" c:identifier="g_signal_emit_by_name" introspectable="0">
      <doc xml:space="preserve">Emits a signal. Signal emission is done synchronously.
The method will only return control after all handlers are called or signal emission was stopped.

Note that g_signal_emit_by_name() resets the return value to the default
if no handlers are connected, in contrast to g_signal_emitv().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the instance the signal is being emitted on.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:space="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">parameters to be passed to the signal, followed by a
 location for the return value. If the return type of the signal
 is %G_TYPE_NONE, the return value location can be omitted. The
 number of parameters to pass to this function is defined when creating the signal.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_emit_valist" c:identifier="g_signal_emit_valist" introspectable="0">
      <doc xml:space="preserve">Emits a signal. Signal emission is done synchronously.
The method will only return control after all handlers are called or signal emission was stopped.

Note that g_signal_emit_valist() resets the return value to the default
if no handlers are connected, in contrast to g_signal_emitv().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the instance the signal is being
   emitted on.</doc>
          <type name="TypeInstance" c:type="gpointer"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">the signal id</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:space="preserve">the detail</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:space="preserve">a list of parameters to be passed to the signal, followed by a
 location for the return value. If the return type of the signal
 is %G_TYPE_NONE, the return value location can be omitted.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_emitv" c:identifier="g_signal_emitv">
      <doc xml:space="preserve">Emits a signal. Signal emission is done synchronously.
The method will only return control after all handlers are called or signal emission was stopped.

Note that g_signal_emitv() doesn't change @return_value if no handlers are
connected, in contrast to g_signal_emit() and g_signal_emit_valist().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance_and_params" transfer-ownership="none">
          <doc xml:space="preserve">argument list for the signal emission.
 The first element in the array is a #GValue for the instance the signal
 is being emitted on. The rest are any arguments to be passed to the signal.</doc>
          <array zero-terminated="0" c:type="const GValue*">
            <type name="Value" c:type="GValue"/>
          </array>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">the signal id</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:space="preserve">the detail</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="return_value" direction="inout" caller-allocates="0" transfer-ownership="full" optional="1">
          <doc xml:space="preserve">Location to
store the return value of the signal emission. This must be provided if the
specified signal returns a value, but may be ignored otherwise.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_get_invocation_hint" c:identifier="g_signal_get_invocation_hint">
      <doc xml:space="preserve">Returns the invocation hint of the innermost signal emission of instance.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the invocation hint of the innermost
    signal emission, or %NULL if not found.</doc>
        <type name="SignalInvocationHint" c:type="GSignalInvocationHint*"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the instance to query</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handler_block" c:identifier="g_signal_handler_block">
      <doc xml:space="preserve">Blocks a handler of an instance so it will not be called during any
signal emissions unless it is unblocked again. Thus "blocking" a
signal handler means to temporarily deactivate it, a signal handler
has to be unblocked exactly the same amount of times it has been
blocked before to become active again.

The @handler_id has to be a valid signal handler id, connected to a
signal of @instance.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">The instance to block the signal handler of.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="handler_id" transfer-ownership="none">
          <doc xml:space="preserve">Handler id of the handler to be blocked.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handler_disconnect" c:identifier="g_signal_handler_disconnect">
      <doc xml:space="preserve">Disconnects a handler from an instance so it will not be called during
any future or currently ongoing emissions of the signal it has been
connected to. The @handler_id becomes invalid and may be reused.

The @handler_id has to be a valid signal handler id, connected to a
signal of @instance.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">The instance to remove the signal handler from.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="handler_id" transfer-ownership="none">
          <doc xml:space="preserve">Handler id of the handler to be disconnected.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handler_find" c:identifier="g_signal_handler_find">
      <doc xml:space="preserve">Finds the first signal handler that matches certain selection criteria.
The criteria mask is passed as an OR-ed combination of #GSignalMatchType
flags, and the criteria values are passed as arguments.
The match @mask has to be non-0 for successful matches.
If no handler was found, 0 is returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A valid non-0 signal handler id for a successful match.</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">The instance owning the signal handler to be found.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handler has to match.</doc>
          <type name="SignalMatchType" c:type="GSignalMatchType"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">Signal the handler has to be connected to.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:space="preserve">Signal detail the handler has to be connected to.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The closure the handler will invoke.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The C closure callback of the handler (useless for non-C closures).</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The closure data of the handler's closure.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handler_is_connected" c:identifier="g_signal_handler_is_connected">
      <doc xml:space="preserve">Returns whether @handler_id is the ID of a handler connected to @instance.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether @handler_id identifies a handler connected to @instance.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">The instance where a signal handler is sought.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="handler_id" transfer-ownership="none">
          <doc xml:space="preserve">the handler ID.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handler_unblock" c:identifier="g_signal_handler_unblock">
      <doc xml:space="preserve">Undoes the effect of a previous g_signal_handler_block() call.  A
blocked handler is skipped during signal emissions and will not be
invoked, unblocking it (for exactly the amount of times it has been
blocked before) reverts its "blocked" state, so the handler will be
recognized by the signal system and is called upon future or
currently ongoing signal emissions (since the order in which
handlers are called during signal emissions is deterministic,
whether the unblocked handler in question is called as part of a
currently ongoing emission depends on how far that emission has
proceeded yet).

The @handler_id has to be a valid id of a signal handler that is
connected to a signal of @instance and is currently blocked.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">The instance to unblock the signal handler of.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="handler_id" transfer-ownership="none">
          <doc xml:space="preserve">Handler id of the handler to be unblocked.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="signal_handlers_block_by_func" c:identifier="g_signal_handlers_block_by_func" introspectable="0">
      <doc xml:space="preserve">Blocks all handlers on an instance that match @func and @data.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">The instance to block handlers from.</doc>
        </parameter>
        <parameter name="func">
          <doc xml:space="preserve">The C closure callback of the handlers (useless for non-C closures).</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">The closure data of the handlers' closures.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="signal_handlers_block_matched" c:identifier="g_signal_handlers_block_matched">
      <doc xml:space="preserve">Blocks all handlers on an instance that match a certain selection criteria.

The criteria mask is passed as a combination of #GSignalMatchType flags, and
the criteria values are passed as arguments. A handler must match on all
flags set in @mask to be blocked (i.e. the match is conjunctive).

Passing at least one of the %G_SIGNAL_MATCH_ID, %G_SIGNAL_MATCH_CLOSURE,
%G_SIGNAL_MATCH_FUNC
or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
If no handlers were found, 0 is returned, the number of blocked handlers
otherwise.

Support for %G_SIGNAL_MATCH_ID was added in GLib 2.78.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The number of handlers that matched.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">The instance to block handlers from.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handlers have to match.</doc>
          <type name="SignalMatchType" c:type="GSignalMatchType"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">Signal the handlers have to be connected to.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:space="preserve">Signal detail the handlers have to be connected to.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The closure the handlers will invoke.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The C closure callback of the handlers (useless for non-C closures).</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The closure data of the handlers' closures.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handlers_destroy" c:identifier="g_signal_handlers_destroy">
      <doc xml:space="preserve">Destroy all signal handlers of a type instance. This function is
an implementation detail of the #GObject dispose implementation,
and should not be used outside of the type system.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">The instance whose signal handlers are destroyed</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="signal_handlers_disconnect_by_data" c:identifier="g_signal_handlers_disconnect_by_data" version="2.32" introspectable="0">
      <doc xml:space="preserve">Disconnects all handlers on an instance that match @data.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">The instance to remove handlers from</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">the closure data of the handlers' closures</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="signal_handlers_disconnect_by_func" c:identifier="g_signal_handlers_disconnect_by_func" introspectable="0">
      <doc xml:space="preserve">Disconnects all handlers on an instance that match @func and @data.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">The instance to remove handlers from.</doc>
        </parameter>
        <parameter name="func">
          <doc xml:space="preserve">The C closure callback of the handlers (useless for non-C closures).</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">The closure data of the handlers' closures.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="signal_handlers_disconnect_matched" c:identifier="g_signal_handlers_disconnect_matched">
      <doc xml:space="preserve">Disconnects all handlers on an instance that match a certain
selection criteria.

The criteria mask is passed as a combination of #GSignalMatchType flags, and
the criteria values are passed as arguments. A handler must match on all
flags set in @mask to be disconnected (i.e. the match is conjunctive).

Passing at least one of the %G_SIGNAL_MATCH_ID, %G_SIGNAL_MATCH_CLOSURE,
%G_SIGNAL_MATCH_FUNC or
%G_SIGNAL_MATCH_DATA match flags is required for successful
matches.  If no handlers were found, 0 is returned, the number of
disconnected handlers otherwise.

Support for %G_SIGNAL_MATCH_ID was added in GLib 2.78.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The number of handlers that matched.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">The instance to remove handlers from.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handlers have to match.</doc>
          <type name="SignalMatchType" c:type="GSignalMatchType"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">Signal the handlers have to be connected to.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:space="preserve">Signal detail the handlers have to be connected to.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The closure the handlers will invoke.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The C closure callback of the handlers (useless for non-C closures).</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The closure data of the handlers' closures.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="signal_handlers_unblock_by_func" c:identifier="g_signal_handlers_unblock_by_func" introspectable="0">
      <doc xml:space="preserve">Unblocks all handlers on an instance that match @func and @data.</doc>
      <parameters>
        <parameter name="instance">
          <doc xml:space="preserve">The instance to unblock handlers from.</doc>
        </parameter>
        <parameter name="func">
          <doc xml:space="preserve">The C closure callback of the handlers (useless for non-C closures).</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve">The closure data of the handlers' closures.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="signal_handlers_unblock_matched" c:identifier="g_signal_handlers_unblock_matched">
      <doc xml:space="preserve">Unblocks all handlers on an instance that match a certain selection
criteria.

The criteria mask is passed as a combination of #GSignalMatchType flags, and
the criteria values are passed as arguments. A handler must match on all
flags set in @mask to be unblocked (i.e. the match is conjunctive).

Passing at least one of the %G_SIGNAL_MATCH_ID, %G_SIGNAL_MATCH_CLOSURE,
%G_SIGNAL_MATCH_FUNC
or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
If no handlers were found, 0 is returned, the number of unblocked handlers
otherwise. The match criteria should not apply to any handlers that are
not currently blocked.

Support for %G_SIGNAL_MATCH_ID was added in GLib 2.78.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The number of handlers that matched.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">The instance to unblock handlers from.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:space="preserve">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handlers have to match.</doc>
          <type name="SignalMatchType" c:type="GSignalMatchType"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">Signal the handlers have to be connected to.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:space="preserve">Signal detail the handlers have to be connected to.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The closure the handlers will invoke.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The C closure callback of the handlers (useless for non-C closures).</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The closure data of the handlers' closures.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_has_handler_pending" c:identifier="g_signal_has_handler_pending">
      <doc xml:space="preserve">Returns whether there are any handlers connected to @instance for the
given signal id and detail.

If @detail is 0 then it will only match handlers that were connected
without detail.  If @detail is non-zero then it will match handlers
connected both without detail and with the given detail.  This is
consistent with how a signal emitted with @detail would be delivered
to those handlers.

Since 2.46 this also checks for a non-default class closure being
installed, as this is basically always what you want.

One example of when you might use this is when the arguments to the
signal are difficult to compute. A class implementor may opt to not
emit the signal if no one is attached anyway, thus saving the cost
of building the arguments.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if a handler is connected to the signal, %FALSE
         otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the object whose signal handlers are sought.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">the signal id.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:space="preserve">the detail.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="may_be_blocked" transfer-ownership="none">
          <doc xml:space="preserve">whether blocked handlers should count as match.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_is_valid_name" c:identifier="g_signal_is_valid_name" version="2.66">
      <doc xml:space="preserve">Validate a signal name. This can be useful for dynamically-generated signals
which need to be validated at run-time before actually trying to create them.

See [func@GObject.signal_new] for details of the rules for valid names.
The rules for signal names are the same as those for property names.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @name is a valid signal name, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the canonical name of the signal</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_list_ids" c:identifier="g_signal_list_ids">
      <doc xml:space="preserve">Lists the signals by id that a certain instance or interface type
created. Further information about the signals can be acquired through
g_signal_query().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Newly allocated array of signal IDs.</doc>
        <array length="1" zero-terminated="0" c:type="guint*">
          <type name="guint" c:type="guint"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:space="preserve">Instance or interface type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_ids" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">Location to store the number of signal ids for @itype.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_lookup" c:identifier="g_signal_lookup">
      <doc xml:space="preserve">Given the name of the signal and the type of object it connects to, gets
the signal's identifying integer. Emitting the signal by number is
somewhat faster than using the name each time.

Also tries the ancestors of the given type.

The type class passed as @itype must already have been instantiated (for
example, using g_type_class_ref()) for this function to work, as signals are
always installed during class initialization.

See g_signal_new() for details on allowed signal names.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the signal's identifying number, or 0 if no signal was found.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the signal's name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:space="preserve">the type that the signal operates on.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_name" c:identifier="g_signal_name">
      <doc xml:space="preserve">Given the signal's identifier, finds its name.

Two different signals may have the same name, if they have differing types.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the signal name, or %NULL if the signal number was invalid.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">the signal's identifying number.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_new" c:identifier="g_signal_new" introspectable="0">
      <doc xml:space="preserve">Creates a new signal. (This is usually done in the class initializer.)

A signal name consists of segments consisting of ASCII letters and
digits, separated by either the `-` or `_` character. The first
character of a signal name must be a letter. Names which violate these
rules lead to undefined behaviour. These are the same rules as for property
naming (see g_param_spec_internal()).

When registering a signal and looking up a signal, either separator can
be used, but they cannot be mixed. Using `-` is considerably more efficient.
Using `_` is discouraged.

If 0 is used for @class_offset subclasses cannot override the class handler
in their class_init method by doing super_class-&gt;signal_handler = my_signal_handler.
Instead they will have to use g_signal_override_class_handler().

If @c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
the marshaller for this signal. In some simple cases, g_signal_new()
will use a more optimized c_marshaller and va_marshaller for the signal
instead of g_cclosure_marshal_generic().

If @c_marshaller is non-%NULL, you need to also specify a va_marshaller
using g_signal_set_va_marshaller() or the generic va_marshaller will
be used.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the signal id</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:space="preserve">the name for the signal</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:space="preserve">the type this signal pertains to. It will also pertain to
 types which are derived from this type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="signal_flags" transfer-ownership="none">
          <doc xml:space="preserve">a combination of #GSignalFlags specifying detail of when
 the default handler is to be invoked. You should at least specify
 %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.</doc>
          <type name="SignalFlags" c:type="GSignalFlags"/>
        </parameter>
        <parameter name="class_offset" transfer-ownership="none">
          <doc xml:space="preserve">The offset of the function pointer in the class structure
 for this type. Used to invoke a class method generically. Pass 0 to
 not associate a class method slot with this signal.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="accumulator" transfer-ownership="none" nullable="1" allow-none="1" scope="forever" closure="5">
          <doc xml:space="preserve">the accumulator for this signal; may be %NULL.</doc>
          <type name="SignalAccumulator" c:type="GSignalAccumulator"/>
        </parameter>
        <parameter name="accu_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data for the @accumulator.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="c_marshaller" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the function to translate arrays of parameter
 values to signal emissions into C language callback invocations or %NULL.</doc>
          <type name="SignalCMarshaller" c:type="GSignalCMarshaller"/>
        </parameter>
        <parameter name="return_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of return value, or %G_TYPE_NONE for a signal
 without a return value.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_params" transfer-ownership="none">
          <doc xml:space="preserve">the number of parameter types to follow.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a list of types, one for each parameter.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_new_class_handler" c:identifier="g_signal_new_class_handler" version="2.18" introspectable="0">
      <doc xml:space="preserve">Creates a new signal. (This is usually done in the class initializer.)

This is a variant of g_signal_new() that takes a C callback instead
of a class offset for the signal's class handler. This function
doesn't need a function pointer exposed in the class structure of
an object definition, instead the function pointer is passed
directly and can be overridden by derived classes with
g_signal_override_class_closure() or
g_signal_override_class_handler() and chained to with
g_signal_chain_from_overridden() or
g_signal_chain_from_overridden_handler().

See g_signal_new() for information about signal names.

If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
the marshaller for this signal.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the signal id</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:space="preserve">the name for the signal</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:space="preserve">the type this signal pertains to. It will also pertain to
 types which are derived from this type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="signal_flags" transfer-ownership="none">
          <doc xml:space="preserve">a combination of #GSignalFlags specifying detail of when
 the default handler is to be invoked. You should at least specify
 %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.</doc>
          <type name="SignalFlags" c:type="GSignalFlags"/>
        </parameter>
        <parameter name="class_handler" transfer-ownership="none" nullable="1" allow-none="1" scope="forever">
          <doc xml:space="preserve">a #GCallback which acts as class implementation of
 this signal. Used to invoke a class method generically. Pass %NULL to
 not associate a class method with this signal.</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="accumulator" transfer-ownership="none" nullable="1" allow-none="1" scope="forever" closure="5">
          <doc xml:space="preserve">the accumulator for this signal; may be %NULL.</doc>
          <type name="SignalAccumulator" c:type="GSignalAccumulator"/>
        </parameter>
        <parameter name="accu_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data for the @accumulator.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="c_marshaller" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the function to translate arrays of parameter
 values to signal emissions into C language callback invocations or %NULL.</doc>
          <type name="SignalCMarshaller" c:type="GSignalCMarshaller"/>
        </parameter>
        <parameter name="return_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of return value, or %G_TYPE_NONE for a signal
 without a return value.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_params" transfer-ownership="none">
          <doc xml:space="preserve">the number of parameter types to follow.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">a list of types, one for each parameter.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_new_valist" c:identifier="g_signal_new_valist" introspectable="0">
      <doc xml:space="preserve">Creates a new signal. (This is usually done in the class initializer.)

See g_signal_new() for details on allowed signal names.

If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
the marshaller for this signal.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the signal id</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:space="preserve">the name for the signal</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:space="preserve">the type this signal pertains to. It will also pertain to
 types which are derived from this type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="signal_flags" transfer-ownership="none">
          <doc xml:space="preserve">a combination of #GSignalFlags specifying detail of when
 the default handler is to be invoked. You should at least specify
 %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.</doc>
          <type name="SignalFlags" c:type="GSignalFlags"/>
        </parameter>
        <parameter name="class_closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The closure to invoke on signal emission; may be %NULL.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="accumulator" transfer-ownership="none" nullable="1" allow-none="1" scope="forever" closure="5">
          <doc xml:space="preserve">the accumulator for this signal; may be %NULL.</doc>
          <type name="SignalAccumulator" c:type="GSignalAccumulator"/>
        </parameter>
        <parameter name="accu_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data for the @accumulator.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="c_marshaller" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the function to translate arrays of parameter
 values to signal emissions into C language callback invocations or %NULL.</doc>
          <type name="SignalCMarshaller" c:type="GSignalCMarshaller"/>
        </parameter>
        <parameter name="return_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of return value, or %G_TYPE_NONE for a signal
 without a return value.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_params" transfer-ownership="none">
          <doc xml:space="preserve">the number of parameter types in @args.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">va_list of #GType, one for each parameter.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_newv" c:identifier="g_signal_newv" introspectable="0">
      <doc xml:space="preserve">Creates a new signal. (This is usually done in the class initializer.)

See g_signal_new() for details on allowed signal names.

If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
the marshaller for this signal.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the signal id</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:space="preserve">the name for the signal</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:space="preserve">the type this signal pertains to. It will also pertain to
    types which are derived from this type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="signal_flags" transfer-ownership="none">
          <doc xml:space="preserve">a combination of #GSignalFlags specifying detail of when
    the default handler is to be invoked. You should at least specify
    %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST</doc>
          <type name="SignalFlags" c:type="GSignalFlags"/>
        </parameter>
        <parameter name="class_closure" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">The closure to invoke on signal emission;
    may be %NULL</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="accumulator" transfer-ownership="none" nullable="1" allow-none="1" scope="forever" closure="5">
          <doc xml:space="preserve">the accumulator for this signal; may be %NULL</doc>
          <type name="SignalAccumulator" c:type="GSignalAccumulator"/>
        </parameter>
        <parameter name="accu_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">user data for the @accumulator</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="c_marshaller" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the function to translate arrays of
    parameter values to signal emissions into C language callback
    invocations or %NULL</doc>
          <type name="SignalCMarshaller" c:type="GSignalCMarshaller"/>
        </parameter>
        <parameter name="return_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of return value, or %G_TYPE_NONE for a signal
    without a return value</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_params" transfer-ownership="none">
          <doc xml:space="preserve">the length of @param_types</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_types" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">an array of types, one for
    each parameter (may be %NULL if @n_params is zero)</doc>
          <array length="8" zero-terminated="0" c:type="GType*">
            <type name="GType" c:type="GType"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="signal_override_class_closure" c:identifier="g_signal_override_class_closure">
      <doc xml:space="preserve">Overrides the class closure (i.e. the default handler) for the given signal
for emissions on instances of @instance_type. @instance_type must be derived
from the type to which the signal belongs.

See g_signal_chain_from_overridden() and
g_signal_chain_from_overridden_handler() for how to chain up to the
parent class closure from inside the overridden one.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">the signal id</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:space="preserve">the instance type on which to override the class closure
 for the signal.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="class_closure" transfer-ownership="none">
          <doc xml:space="preserve">the closure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_override_class_handler" c:identifier="g_signal_override_class_handler" version="2.18">
      <doc xml:space="preserve">Overrides the class closure (i.e. the default handler) for the
given signal for emissions on instances of @instance_type with
callback @class_handler. @instance_type must be derived from the
type to which the signal belongs.

See g_signal_chain_from_overridden() and
g_signal_chain_from_overridden_handler() for how to chain up to the
parent class closure from inside the overridden one.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:space="preserve">the name for the signal</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:space="preserve">the instance type on which to override the class handler
 for the signal.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="class_handler" transfer-ownership="none" scope="forever">
          <doc xml:space="preserve">the handler.</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_parse_name" c:identifier="g_signal_parse_name">
      <doc xml:space="preserve">Internal function to parse a signal name into its @signal_id
and @detail quark.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether the signal name could successfully be parsed and @signal_id_p and @detail_p contain valid return values.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:space="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:space="preserve">The interface/instance type that introduced "signal-name".</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="signal_id_p" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">Location to store the signal id.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="detail_p" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">Location to store the detail quark.</doc>
          <type name="GLib.Quark" c:type="GQuark*"/>
        </parameter>
        <parameter name="force_detail_quark" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE forces creation of a #GQuark for the detail.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_query" c:identifier="g_signal_query">
      <doc xml:space="preserve">Queries the signal system for in-depth information about a
specific signal. This function will fill in a user-provided
structure to hold signal-specific information. If an invalid
signal id is passed in, the @signal_id member of the #GSignalQuery
is 0. All members filled into the #GSignalQuery structure should
be considered constant and have to be left untouched.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">The signal id of the signal to query information for.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="query" direction="out" caller-allocates="1" transfer-ownership="none">
          <doc xml:space="preserve">A user provided structure that is
 filled in with constant values upon success.</doc>
          <type name="SignalQuery" c:type="GSignalQuery*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_remove_emission_hook" c:identifier="g_signal_remove_emission_hook">
      <doc xml:space="preserve">Deletes an emission hook.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">the id of the signal</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="hook_id" transfer-ownership="none">
          <doc xml:space="preserve">the id of the emission hook, as returned by
 g_signal_add_emission_hook()</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_set_va_marshaller" c:identifier="g_signal_set_va_marshaller" version="2.32" introspectable="0">
      <doc xml:space="preserve">Change the #GSignalCVaMarshaller used for a given signal.  This is a
specialised form of the marshaller that can often be used for the
common case of a single connected signal handler and avoids the
overhead of #GValue.  Its use is optional.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">the signal id</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:space="preserve">the instance type on which to set the marshaller.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="va_marshaller" transfer-ownership="none">
          <doc xml:space="preserve">the marshaller to set.</doc>
          <type name="SignalCVaMarshaller" c:type="GSignalCVaMarshaller"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_stop_emission" c:identifier="g_signal_stop_emission">
      <doc xml:space="preserve">Stops a signal's current emission.

This will prevent the default method from running, if the signal was
%G_SIGNAL_RUN_LAST and you connected normally (i.e. without the "after"
flag).

Prints a warning if used on a signal which isn't being emitted.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the object whose signal handlers you wish to stop.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:space="preserve">the signal identifier, as returned by g_signal_lookup().</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:space="preserve">the detail which the signal was emitted with.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_stop_emission_by_name" c:identifier="g_signal_stop_emission_by_name">
      <doc xml:space="preserve">Stops a signal's current emission.

This is just like g_signal_stop_emission() except it will look up the
signal id for you.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">the object whose signal handlers you wish to stop.</doc>
          <type name="Object" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:space="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_type_cclosure_new" c:identifier="g_signal_type_cclosure_new">
      <doc xml:space="preserve">Creates a new closure which invokes the function found at the offset
@struct_offset in the class structure of the interface or classed type
identified by @itype.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a floating reference to a new #GCClosure</doc>
        <type name="Closure" c:type="GClosure*"/>
      </return-value>
      <parameters>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:space="preserve">the #GType identifier of an interface or classed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="struct_offset" transfer-ownership="none">
          <doc xml:space="preserve">the offset of the member function of @itype's class
 structure which is to be invoked by the new closure</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="source_set_closure" c:identifier="g_source_set_closure" moved-to="Source.set_closure">
      <doc xml:space="preserve">Set the callback for a source as a #GClosure.

If the source is not one of the standard GLib types, the @closure_callback
and @closure_marshal fields of the #GSourceFuncs structure must have been
filled in with pointers to appropriate functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">the source</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:space="preserve">a #GClosure</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="source_set_dummy_callback" c:identifier="g_source_set_dummy_callback" moved-to="Source.set_dummy_callback">
      <doc xml:space="preserve">Sets a dummy callback for @source. The callback will do nothing, and
if the source expects a #gboolean return value, it will return %TRUE.
(If the source expects any other type of return value, it will return
a 0/%NULL value; whatever g_value_init() initializes a #GValue to for
that type.)

If the source is not one of the standard GLib types, the
@closure_callback and @closure_marshal fields of the #GSourceFuncs
structure must have been filled in with pointers to appropriate
functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">the source</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strdup_value_contents" c:identifier="g_strdup_value_contents">
      <doc xml:space="preserve">Return a newly allocated string, which describes the contents of a
#GValue.  The main purpose of this function is to describe #GValue
contents for debugging output, the way in which the contents are
described may change between different GLib versions.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Newly allocated string.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">#GValue which contents are to be described.</doc>
          <type name="Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_add_class_cache_func" c:identifier="g_type_add_class_cache_func" introspectable="0">
      <doc xml:space="preserve">Adds a #GTypeClassCacheFunc to be called before the reference count of a
class goes from one to zero. This can be used to prevent premature class
destruction. All installed #GTypeClassCacheFunc functions will be chained
until one of them returns %TRUE. The functions have to check the class id
passed in to figure whether they actually want to cache the class of this
type, since all classes are routed through the same #GTypeClassCacheFunc
chain.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cache_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to be passed to @cache_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="cache_func" transfer-ownership="none">
          <doc xml:space="preserve">a #GTypeClassCacheFunc</doc>
          <type name="TypeClassCacheFunc" c:type="GTypeClassCacheFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_add_class_private" c:identifier="g_type_add_class_private" version="2.24">
      <doc xml:space="preserve">Registers a private class structure for a classed type;
when the class is allocated, the private structures for
the class and all of its parent types are allocated
sequentially in the same memory block as the public
structures, and are zero-filled.

This function should be called in the
type's get_type() function after the type is registered.
The private structure can be retrieved using the
G_TYPE_CLASS_GET_PRIVATE() macro.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="class_type" transfer-ownership="none">
          <doc xml:space="preserve">GType of a classed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="private_size" transfer-ownership="none">
          <doc xml:space="preserve">size of private structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_add_instance_private" c:identifier="g_type_add_instance_private">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="class_type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="private_size" transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_add_interface_check" c:identifier="g_type_add_interface_check" version="2.4" introspectable="0">
      <doc xml:space="preserve">Adds a function to be called after an interface vtable is
initialized for any class (i.e. after the @interface_init
member of #GInterfaceInfo has been called).

This function is useful when you want to check an invariant
that depends on the interfaces of a class. For instance, the
implementation of #GObject uses this facility to check that an
object implements all of the properties that are defined on its
interfaces.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="check_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @check_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="check_func" transfer-ownership="none">
          <doc xml:space="preserve">function to be called after each interface
    is initialized</doc>
          <type name="TypeInterfaceCheckFunc" c:type="GTypeInterfaceCheckFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_add_interface_dynamic" c:identifier="g_type_add_interface_dynamic">
      <doc xml:space="preserve">Adds @interface_type to the dynamic @instance_type. The information
contained in the #GTypePlugin structure pointed to by @plugin
is used to manage the relationship.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:space="preserve">#GType value of an instantiatable type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:space="preserve">#GType value of an interface type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:space="preserve">#GTypePlugin structure to retrieve the #GInterfaceInfo from</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_add_interface_static" c:identifier="g_type_add_interface_static">
      <doc xml:space="preserve">Adds @interface_type to the static @instance_type.
The information contained in the #GInterfaceInfo structure
pointed to by @info is used to manage the relationship.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:space="preserve">#GType value of an instantiatable type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:space="preserve">#GType value of an interface type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">#GInterfaceInfo structure for this
       (@instance_type, @interface_type) combination</doc>
          <type name="InterfaceInfo" c:type="const GInterfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_class_cast" c:identifier="g_type_check_class_cast" introspectable="0">
      <return-value>
        <type name="TypeClass" c:type="GTypeClass*"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <type name="TypeClass" c:type="GTypeClass*"/>
        </parameter>
        <parameter name="is_a_type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_class_is_a" c:identifier="g_type_check_class_is_a">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <type name="TypeClass" c:type="GTypeClass*"/>
        </parameter>
        <parameter name="is_a_type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_instance" c:identifier="g_type_check_instance">
      <doc xml:space="preserve">Private helper function to aid implementation of the
G_TYPE_CHECK_INSTANCE() macro.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @instance is valid, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">a valid #GTypeInstance structure</doc>
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_instance_cast" c:identifier="g_type_check_instance_cast" introspectable="0">
      <return-value>
        <type name="TypeInstance" c:type="GTypeInstance*"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
        <parameter name="iface_type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_instance_is_a" c:identifier="g_type_check_instance_is_a">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
        <parameter name="iface_type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_instance_is_fundamentally_a" c:identifier="g_type_check_instance_is_fundamentally_a">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
        <parameter name="fundamental_type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_is_value_type" c:identifier="g_type_check_is_value_type">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_value" c:identifier="g_type_check_value">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_value_holds" c:identifier="g_type_check_value_holds">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_children" c:identifier="g_type_children">
      <doc xml:space="preserve">Return a newly allocated and 0-terminated array of type IDs, listing
the child types of @type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Newly allocated
    and 0-terminated array of child types, free with g_free()</doc>
        <array length="1" zero-terminated="0" c:type="GType*">
          <type name="GType" c:type="GType"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the parent type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_children" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store the length of
    the returned array, or %NULL</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_class_adjust_private_offset" c:identifier="g_type_class_adjust_private_offset" moved-to="TypeClass.adjust_private_offset">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none" nullable="1" allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="private_size_or_offset" transfer-ownership="none">
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_class_peek" c:identifier="g_type_class_peek" moved-to="TypeClass.peek">
      <doc xml:space="preserve">This function is essentially the same as g_type_class_ref(),
except that the classes reference count isn't incremented.
As a consequence, this function may return %NULL if the class
of the type passed in does not currently exist (hasn't been
referenced before).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GTypeClass
    structure for the given type ID or %NULL if the class does not
    currently exist</doc>
        <type name="TypeClass" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">type ID of a classed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_class_peek_static" c:identifier="g_type_class_peek_static" moved-to="TypeClass.peek_static" version="2.4">
      <doc xml:space="preserve">A more efficient version of g_type_class_peek() which works only for
static types.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GTypeClass
    structure for the given type ID or %NULL if the class does not
    currently exist or is dynamically loaded</doc>
        <type name="TypeClass" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">type ID of a classed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_class_ref" c:identifier="g_type_class_ref" moved-to="TypeClass.ref">
      <doc xml:space="preserve">Increments the reference count of the class structure belonging to
@type. This function will demand-create the class if it doesn't
exist already.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GTypeClass
    structure for the given type ID</doc>
        <type name="TypeClass" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">type ID of a classed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_create_instance" c:identifier="g_type_create_instance" introspectable="0">
      <doc xml:space="preserve">Creates and initializes an instance of @type if @type is valid and
can be instantiated. The type system only performs basic allocation
and structure setups for instances: actual instance creation should
happen through functions supplied by the type's fundamental type
implementation.  So use of g_type_create_instance() is reserved for
implementers of fundamental types only. E.g. instances of the
#GObject hierarchy should be created via g_object_new() and never
directly through g_type_create_instance() which doesn't handle things
like singleton objects or object construction.

The extended members of the returned instance are guaranteed to be filled
with zeros.

Note: Do not use this function, unless you're implementing a
fundamental type. Also language bindings should not use this
function, but g_object_new() instead.</doc>
      <return-value>
        <doc xml:space="preserve">an allocated and initialized instance, subject to further
    treatment by the fundamental type implementation</doc>
        <type name="TypeInstance" c:type="GTypeInstance*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">an instantiatable type to create an instance for</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_default_interface_peek" c:identifier="g_type_default_interface_peek" version="2.4">
      <doc xml:space="preserve">If the interface type @g_type is currently in use, returns its
default interface vtable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the default
    vtable for the interface, or %NULL if the type is not currently
    in use</doc>
        <type name="TypeInterface" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="g_type" transfer-ownership="none">
          <doc xml:space="preserve">an interface type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_default_interface_ref" c:identifier="g_type_default_interface_ref" version="2.4">
      <doc xml:space="preserve">Increments the reference count for the interface type @g_type,
and returns the default interface vtable for the type.

If the type is not currently in use, then the default vtable
for the type will be created and initialized by calling
the base interface init and default vtable init functions for
the type (the @base_init and @class_init members of #GTypeInfo).
Calling g_type_default_interface_ref() is useful when you
want to make sure that signals and properties for an interface
have been installed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the default
    vtable for the interface; call g_type_default_interface_unref()
    when you are done using the interface.</doc>
        <type name="TypeInterface" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="g_type" transfer-ownership="none">
          <doc xml:space="preserve">an interface type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_default_interface_unref" c:identifier="g_type_default_interface_unref" version="2.4">
      <doc xml:space="preserve">Decrements the reference count for the type corresponding to the
interface default vtable @g_iface. If the type is dynamic, then
when no one is using the interface and all references have
been released, the finalize function for the interface's default
vtable (the @class_finalize member of #GTypeInfo) will be called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:space="preserve">the default vtable
    structure for an interface, as returned by g_type_default_interface_ref()</doc>
          <type name="TypeInterface" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_depth" c:identifier="g_type_depth">
      <doc xml:space="preserve">Returns the length of the ancestry of the passed in type. This
includes the type itself, so that e.g. a fundamental type has depth 1.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the depth of @type</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_ensure" c:identifier="g_type_ensure" version="2.34">
      <doc xml:space="preserve">Ensures that the indicated @type has been registered with the
type system, and its _class_init() method has been run.

In theory, simply calling the type's _get_type() method (or using
the corresponding macro) is supposed take care of this. However,
_get_type() methods are often marked %G_GNUC_CONST for performance
reasons, even though this is technically incorrect (since
%G_GNUC_CONST requires that the function not have side effects,
which _get_type() methods do on the first call). As a result, if
you write a bare call to a _get_type() macro, it may get optimized
out by the compiler. Using g_type_ensure() guarantees that the
type's _get_type() method is called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_free_instance" c:identifier="g_type_free_instance">
      <doc xml:space="preserve">Frees an instance of a type, returning it to the instance pool for
the type, if there is one.

Like g_type_create_instance(), this function is reserved for
implementors of fundamental types.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:space="preserve">an instance of a type</doc>
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_from_name" c:identifier="g_type_from_name">
      <doc xml:space="preserve">Look up the type ID from a given type name, returning 0 if no type
has been registered under this name (this is the preferred method
to find out by name whether a specific type has been registered
yet).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">corresponding type ID or 0</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">type name to look up</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_fundamental" c:identifier="g_type_fundamental">
      <doc xml:space="preserve">Internal function, used to extract the fundamental type ID portion.
Use G_TYPE_FUNDAMENTAL() instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">fundamental type ID</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="type_id" transfer-ownership="none">
          <doc xml:space="preserve">valid type ID</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_fundamental_next" c:identifier="g_type_fundamental_next">
      <doc xml:space="preserve">Returns the next free fundamental type id which can be used to
register a new fundamental type with g_type_register_fundamental().
The returned type ID represents the highest currently registered
fundamental type identifier.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the next available fundamental type ID to be registered,
    or 0 if the type system ran out of fundamental type IDs</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="type_get_instance_count" c:identifier="g_type_get_instance_count" version="2.44">
      <doc xml:space="preserve">Returns the number of instances allocated of the particular type;
this is only available if GLib is built with debugging support and
the `instance-count` debug flag is set (by setting the `GOBJECT_DEBUG`
variable to include `instance-count`).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of instances allocated of the given type;
  if instance counts are not available, returns 0.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_get_plugin" c:identifier="g_type_get_plugin">
      <doc xml:space="preserve">Returns the #GTypePlugin structure for @type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the corresponding plugin
    if @type is a dynamic type, %NULL otherwise</doc>
        <type name="TypePlugin" c:type="GTypePlugin*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">#GType to retrieve the plugin for</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_get_qdata" c:identifier="g_type_get_qdata">
      <doc xml:space="preserve">Obtains data which has previously been attached to @type
with g_type_set_qdata().

Note that this does not take subtyping into account; data
attached to one type with g_type_set_qdata() cannot
be retrieved from a subtype using g_type_get_qdata().</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the data, or %NULL if no data was found</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="quark" transfer-ownership="none">
          <doc xml:space="preserve">a #GQuark id to identify the data</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_get_type_registration_serial" c:identifier="g_type_get_type_registration_serial" version="2.36">
      <doc xml:space="preserve">Returns an opaque serial number that represents the state of the set
of registered types. Any time a type is registered this serial changes,
which means you can cache information based on type lookups (such as
g_type_from_name()) and know if the cache is still valid at a later
time by comparing the current serial with the one at the type lookup.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">An unsigned int, representing the state of type registrations</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
    </function>
    <function name="type_init" c:identifier="g_type_init" deprecated="1" deprecated-version="2.36">
      <doc xml:space="preserve">This function used to initialise the type system.  Since GLib 2.36,
the type system is initialised automatically and this function does
nothing.</doc>
      <doc-deprecated xml:space="preserve">the type system is now initialised automatically</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="type_init_with_debug_flags" c:identifier="g_type_init_with_debug_flags" deprecated="1" deprecated-version="2.36">
      <doc xml:space="preserve">This function used to initialise the type system with debugging
flags.  Since GLib 2.36, the type system is initialised automatically
and this function does nothing.

If you need to enable debugging features, use the `GOBJECT_DEBUG`
environment variable.</doc>
      <doc-deprecated xml:space="preserve">the type system is now initialised automatically</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="debug_flags" transfer-ownership="none">
          <doc xml:space="preserve">bitwise combination of #GTypeDebugFlags values for
    debugging purposes</doc>
          <type name="TypeDebugFlags" c:type="GTypeDebugFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interface_add_prerequisite" c:identifier="g_type_interface_add_prerequisite" moved-to="TypeInterface.add_prerequisite">
      <doc xml:space="preserve">Adds @prerequisite_type to the list of prerequisites of @interface_type.
This means that any type implementing @interface_type must also implement
@prerequisite_type. Prerequisites can be thought of as an alternative to
interface derivation (which GType doesn't support). An interface can have
at most one instantiatable prerequisite type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:space="preserve">#GType value of an interface type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="prerequisite_type" transfer-ownership="none">
          <doc xml:space="preserve">#GType value of an interface or instantiatable type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interface_get_plugin" c:identifier="g_type_interface_get_plugin" moved-to="TypeInterface.get_plugin">
      <doc xml:space="preserve">Returns the #GTypePlugin structure for the dynamic interface
@interface_type which has been added to @instance_type, or %NULL
if @interface_type has not been added to @instance_type or does
not have a #GTypePlugin structure. See g_type_add_interface_dynamic().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GTypePlugin for the dynamic
    interface @interface_type of @instance_type</doc>
        <type name="TypePlugin" c:type="GTypePlugin*"/>
      </return-value>
      <parameters>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:space="preserve">#GType of an instantiatable type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:space="preserve">#GType of an interface type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interface_instantiatable_prerequisite" c:identifier="g_type_interface_instantiatable_prerequisite" moved-to="TypeInterface.instantiatable_prerequisite" version="2.68">
      <doc xml:space="preserve">Returns the most specific instantiatable prerequisite of an
interface type. If the interface type has no instantiatable
prerequisite, %G_TYPE_INVALID is returned.

See g_type_interface_add_prerequisite() for more information
about prerequisites.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the instantiatable prerequisite type or %G_TYPE_INVALID if none</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:space="preserve">an interface type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interface_peek" c:identifier="g_type_interface_peek" moved-to="TypeInterface.peek">
      <doc xml:space="preserve">Returns the #GTypeInterface structure of an interface to which the
passed in class conforms.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GTypeInterface
    structure of @iface_type if implemented by @instance_class, %NULL
    otherwise</doc>
        <type name="TypeInterface" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="instance_class" transfer-ownership="none">
          <doc xml:space="preserve">a #GTypeClass structure</doc>
          <type name="TypeClass" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_type" transfer-ownership="none">
          <doc xml:space="preserve">an interface ID which this class conforms to</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interface_prerequisites" c:identifier="g_type_interface_prerequisites" moved-to="TypeInterface.prerequisites" version="2.2">
      <doc xml:space="preserve">Returns the prerequisites of an interfaces type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a
    newly-allocated zero-terminated array of #GType containing
    the prerequisites of @interface_type</doc>
        <array length="1" zero-terminated="0" c:type="GType*">
          <type name="GType" c:type="GType"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:space="preserve">an interface type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_prerequisites" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to return the number
    of prerequisites, or %NULL</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interfaces" c:identifier="g_type_interfaces">
      <doc xml:space="preserve">Return a newly allocated and 0-terminated array of type IDs, listing
the interface types that @type conforms to.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Newly allocated
    and 0-terminated array of interface types, free with g_free()</doc>
        <array length="1" zero-terminated="0" c:type="GType*">
          <type name="GType" c:type="GType"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type to list interface types for</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_interfaces" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">location to store the length of
    the returned array, or %NULL</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_is_a" c:identifier="g_type_is_a">
      <doc xml:space="preserve">If @is_a_type is a derivable type, check whether @type is a
descendant of @is_a_type. If @is_a_type is an interface, check
whether @type conforms to it.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @type is a @is_a_type</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">type to check ancestry for</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="is_a_type" transfer-ownership="none">
          <doc xml:space="preserve">possible ancestor of @type or interface that @type
    could conform to</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_name" c:identifier="g_type_name">
      <doc xml:space="preserve">Get the unique name that is assigned to a type ID.  Note that this
function (like all other GType API) cannot cope with invalid type
IDs. %G_TYPE_INVALID may be passed to this function, as may be any
other validly registered type ID, but randomized type IDs should
not be passed in and will most likely lead to a crash.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">static type name or %NULL</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">type to return name for</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_name_from_class" c:identifier="g_type_name_from_class">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <type name="TypeClass" c:type="GTypeClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_name_from_instance" c:identifier="g_type_name_from_instance">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_next_base" c:identifier="g_type_next_base">
      <doc xml:space="preserve">Given a @leaf_type and a @root_type which is contained in its
ancestry, return the type that @root_type is the immediate parent
of. In other words, this function determines the type that is
derived directly from @root_type which is also a base class of
@leaf_type.  Given a root type and a leaf type, this function can
be used to determine the types and order in which the leaf type is
descended from the root type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">immediate child of @root_type and ancestor of @leaf_type</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="leaf_type" transfer-ownership="none">
          <doc xml:space="preserve">descendant of @root_type and the type to be returned</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="root_type" transfer-ownership="none">
          <doc xml:space="preserve">immediate parent of the returned type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_parent" c:identifier="g_type_parent">
      <doc xml:space="preserve">Return the direct parent type of the passed in type. If the passed
in type has no parent, i.e. is a fundamental type, 0 is returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the parent type</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the derived type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_qname" c:identifier="g_type_qname">
      <doc xml:space="preserve">Get the corresponding quark of the type IDs name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the type names quark or 0</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">type to return quark of type name for</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_query" c:identifier="g_type_query">
      <doc xml:space="preserve">Queries the type system for information about a specific type.

This function will fill in a user-provided structure to hold
type-specific information. If an invalid #GType is passed in, the
@type member of the #GTypeQuery is 0. All members filled into the
#GTypeQuery structure should be considered constant and have to be
left untouched.

Since GLib 2.78, this function allows queries on dynamic types. Previously
it only supported static types.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">#GType of a static, classed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="query" direction="out" caller-allocates="1" transfer-ownership="none">
          <doc xml:space="preserve">a user provided structure that is
    filled in with constant values upon success</doc>
          <type name="TypeQuery" c:type="GTypeQuery*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_register_dynamic" c:identifier="g_type_register_dynamic">
      <doc xml:space="preserve">Registers @type_name as the name of a new dynamic type derived from
@parent_type.  The type system uses the information contained in the
#GTypePlugin structure pointed to by @plugin to manage the type and its
instances (if not abstract).  The value of @flags determines the nature
(e.g. abstract or not) of the type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the new type identifier or %G_TYPE_INVALID if registration failed</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="parent_type" transfer-ownership="none">
          <doc xml:space="preserve">type from which this type will be derived</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="type_name" transfer-ownership="none">
          <doc xml:space="preserve">0-terminated string used as the name of the new type</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:space="preserve">#GTypePlugin structure to retrieve the #GTypeInfo from</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">bitwise combination of #GTypeFlags values</doc>
          <type name="TypeFlags" c:type="GTypeFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_register_fundamental" c:identifier="g_type_register_fundamental">
      <doc xml:space="preserve">Registers @type_id as the predefined identifier and @type_name as the
name of a fundamental type. If @type_id is already registered, or a
type named @type_name is already registered, the behaviour is undefined.
The type system uses the information contained in the #GTypeInfo structure
pointed to by @info and the #GTypeFundamentalInfo structure pointed to by
@finfo to manage the type and its instances. The value of @flags determines
additional characteristics of the fundamental type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the predefined type identifier</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="type_id" transfer-ownership="none">
          <doc xml:space="preserve">a predefined type identifier</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="type_name" transfer-ownership="none">
          <doc xml:space="preserve">0-terminated string used as the name of the new type</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">#GTypeInfo structure for this type</doc>
          <type name="TypeInfo" c:type="const GTypeInfo*"/>
        </parameter>
        <parameter name="finfo" transfer-ownership="none">
          <doc xml:space="preserve">#GTypeFundamentalInfo structure for this type</doc>
          <type name="TypeFundamentalInfo" c:type="const GTypeFundamentalInfo*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">bitwise combination of #GTypeFlags values</doc>
          <type name="TypeFlags" c:type="GTypeFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_register_static" c:identifier="g_type_register_static">
      <doc xml:space="preserve">Registers @type_name as the name of a new static type derived from
@parent_type. The type system uses the information contained in the
#GTypeInfo structure pointed to by @info to manage the type and its
instances (if not abstract). The value of @flags determines the nature
(e.g. abstract or not) of the type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the new type identifier</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="parent_type" transfer-ownership="none">
          <doc xml:space="preserve">type from which this type will be derived</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="type_name" transfer-ownership="none">
          <doc xml:space="preserve">0-terminated string used as the name of the new type</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">#GTypeInfo structure for this type</doc>
          <type name="TypeInfo" c:type="const GTypeInfo*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">bitwise combination of #GTypeFlags values</doc>
          <type name="TypeFlags" c:type="GTypeFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_register_static_simple" c:identifier="g_type_register_static_simple" version="2.12" introspectable="0">
      <doc xml:space="preserve">Registers @type_name as the name of a new static type derived from
@parent_type.  The value of @flags determines the nature (e.g.
abstract or not) of the type. It works by filling a #GTypeInfo
struct and calling g_type_register_static().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the new type identifier</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="parent_type" transfer-ownership="none">
          <doc xml:space="preserve">type from which this type will be derived</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="type_name" transfer-ownership="none">
          <doc xml:space="preserve">0-terminated string used as the name of the new type</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="class_size" transfer-ownership="none">
          <doc xml:space="preserve">size of the class structure (see #GTypeInfo)</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="class_init" transfer-ownership="none">
          <doc xml:space="preserve">location of the class initialization function (see #GTypeInfo)</doc>
          <type name="ClassInitFunc" c:type="GClassInitFunc"/>
        </parameter>
        <parameter name="instance_size" transfer-ownership="none">
          <doc xml:space="preserve">size of the instance structure (see #GTypeInfo)</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="instance_init" transfer-ownership="none">
          <doc xml:space="preserve">location of the instance initialization function (see #GTypeInfo)</doc>
          <type name="InstanceInitFunc" c:type="GInstanceInitFunc"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">bitwise combination of #GTypeFlags values</doc>
          <type name="TypeFlags" c:type="GTypeFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_remove_class_cache_func" c:identifier="g_type_remove_class_cache_func" introspectable="0">
      <doc xml:space="preserve">Removes a previously installed #GTypeClassCacheFunc. The cache
maintained by @cache_func has to be empty when calling
g_type_remove_class_cache_func() to avoid leaks.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cache_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data that was given when adding @cache_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="cache_func" transfer-ownership="none">
          <doc xml:space="preserve">a #GTypeClassCacheFunc</doc>
          <type name="TypeClassCacheFunc" c:type="GTypeClassCacheFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_remove_interface_check" c:identifier="g_type_remove_interface_check" version="2.4" introspectable="0">
      <doc xml:space="preserve">Removes an interface check function added with
g_type_add_interface_check().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="check_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">callback data passed to g_type_add_interface_check()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="check_func" transfer-ownership="none">
          <doc xml:space="preserve">callback function passed to g_type_add_interface_check()</doc>
          <type name="TypeInterfaceCheckFunc" c:type="GTypeInterfaceCheckFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_set_qdata" c:identifier="g_type_set_qdata">
      <doc xml:space="preserve">Attaches arbitrary data to a type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="quark" transfer-ownership="none">
          <doc xml:space="preserve">a #GQuark id to identify the data</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_test_flags" c:identifier="g_type_test_flags">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_value_table_peek" c:identifier="g_type_value_table_peek" moved-to="TypeValueTable.peek" introspectable="0">
      <doc xml:space="preserve">Returns the location of the #GTypeValueTable associated with @type.

Note that this function should only be used from source code
that implements or has internal knowledge of the implementation of
@type.</doc>
      <return-value>
        <doc xml:space="preserve">location of the #GTypeValueTable associated with @type or
    %NULL if there is no #GTypeValueTable associated with @type</doc>
        <type name="TypeValueTable" c:type="GTypeValueTable*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_register_transform_func" c:identifier="g_value_register_transform_func" moved-to="Value.register_transform_func" introspectable="0">
      <doc xml:space="preserve">Registers a value transformation function for use in g_value_transform().
A previously registered transformation function for @src_type and @dest_type
will be replaced.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src_type" transfer-ownership="none">
          <doc xml:space="preserve">Source type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="dest_type" transfer-ownership="none">
          <doc xml:space="preserve">Target type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="transform_func" transfer-ownership="none">
          <doc xml:space="preserve">a function which transforms values of type @src_type
 into value of type @dest_type</doc>
          <type name="ValueTransform" c:type="GValueTransform"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_type_compatible" c:identifier="g_value_type_compatible" moved-to="Value.type_compatible">
      <doc xml:space="preserve">Returns whether a #GValue of type @src_type can be copied into
a #GValue of type @dest_type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if g_value_copy() is possible with @src_type and @dest_type.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="src_type" transfer-ownership="none">
          <doc xml:space="preserve">source type to be copied.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="dest_type" transfer-ownership="none">
          <doc xml:space="preserve">destination type for copying.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_type_transformable" c:identifier="g_value_type_transformable" moved-to="Value.type_transformable">
      <doc xml:space="preserve">Check whether g_value_transform() is able to transform values
of type @src_type into values of type @dest_type. Note that for
the types to be transformable, they must be compatible or a
transformation function must be registered.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the transformation is possible, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="src_type" transfer-ownership="none">
          <doc xml:space="preserve">Source type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="dest_type" transfer-ownership="none">
          <doc xml:space="preserve">Target type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="variant_get_gtype" c:identifier="g_variant_get_gtype">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
  </namespace>
</repository>
