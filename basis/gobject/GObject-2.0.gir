<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <package name="gobject-2.0"/>
  <c:include name="glib-object.h"/>
  <namespace name="GObject"
             version="2.0"
             shared-library="libgobject-2.0.so.0"
             c:identifier-prefixes="G"
             c:symbol-prefixes="g">
    <alias name="SignalCMarshaller" c:type="GSignalCMarshaller">
      <doc xml:whitespace="preserve">This is the signature of marshaller functions, required to marshall
arrays of parameter values to signal emissions into C language callback
invocations. It is merely an alias to #GClosureMarshal since the #GClosure
mechanism takes over responsibility of actual function invocation for the
signal system.</doc>
      <type name="ClosureMarshal" c:type="GClosureMarshal"/>
    </alias>
    <alias name="Strv" c:type="GStrv">
      <doc xml:whitespace="preserve">A C representable type name for #G_TYPE_STRV.</doc>
      <type name="gpointer" c:type="gpointer"/>
    </alias>
    <alias name="Type" c:type="GType">
      <doc xml:whitespace="preserve">A numerical value which represents the unique identifier of a registered
type.</doc>
      <type name="gulong" c:type="gsize"/>
    </alias>
    <glib:boxed glib:name="Array"
                c:symbol-prefix="array"
                glib:type-name="GArray"
                glib:get-type="g_array_get_type">
    </glib:boxed>
    <callback name="BaseFinalizeFunc" c:type="GBaseFinalizeFunc">
      <doc xml:whitespace="preserve">A callback function used by the type system to finalize those portions
of a derived types class structure that were setup from the corresponding
GBaseInitFunc() function. Class finalization basically works the inverse
way in which class intialization is performed.
See GClassInitFunc() for a discussion of the class intialization process.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypeClass structure to finalize.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseInitFunc" c:type="GBaseInitFunc">
      <doc xml:whitespace="preserve">A callback function used by the type system to do base initialization
of the class structures of derived types. It is called as part of the
initialization process of all derived classes and should reallocate
or reset all dynamic class members copied over from the parent class.
For example, class members (such as strings) that are not sufficiently
handled by a plain memory copy of the parent class into the derived class
have to be altered. See GClassInitFunc() for a discussion of the class
intialization process.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypeClass structure to initialize.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Binding"
           c:symbol-prefix="binding"
           c:type="GBinding"
           version="2.26"
           parent="Object"
           glib:type-name="GBinding"
           glib:get-type="g_binding_get_type">
      <doc xml:whitespace="preserve">&lt;structname&gt;GBinding&lt;/structname&gt; is an opaque structure whose members
cannot be accessed directly.</doc>
      <method name="get_flags"
              c:identifier="g_binding_get_flags"
              version="2.26">
        <doc xml:whitespace="preserve">Retrieves the flags passed when constructing the #GBinding</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GBindingFlags used by the #GBinding</doc>
          <type name="BindingFlags" c:type="GBindingFlags"/>
        </return-value>
      </method>
      <method name="get_source"
              c:identifier="g_binding_get_source"
              version="2.26">
        <doc xml:whitespace="preserve">Retrieves the #GObject instance used as the source of the binding</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the source #GObject</doc>
          <type name="Object" c:type="GObject*"/>
        </return-value>
      </method>
      <method name="get_source_property"
              c:identifier="g_binding_get_source_property"
              version="2.26">
        <doc xml:whitespace="preserve">Retrieves the name of the property of #GBinding:source used as the source
of the binding</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the source property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_target"
              c:identifier="g_binding_get_target"
              version="2.26">
        <doc xml:whitespace="preserve">Retrieves the #GObject instance used as the target of the binding</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the target #GObject</doc>
          <type name="Object" c:type="GObject*"/>
        </return-value>
      </method>
      <method name="get_target_property"
              c:identifier="g_binding_get_target_property"
              version="2.26">
        <doc xml:whitespace="preserve">Retrieves the name of the property of #GBinding:target used as the target
of the binding</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the target property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <property name="flags"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags to be used to control the #GBinding</doc>
        <type name="BindingFlags"/>
      </property>
      <property name="source"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GObject that should be used as the source of the binding</doc>
        <type name="Object"/>
      </property>
      <property name="source-property"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the property of #GBinding:source that should be used
as the source of the binding</doc>
        <type name="utf8"/>
      </property>
      <property name="target"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GObject that should be used as the target of the binding</doc>
        <type name="Object"/>
      </property>
      <property name="target-property"
                version="2.26"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the property of #GBinding:target that should be used
as the target of the binding</doc>
        <type name="utf8"/>
      </property>
    </class>
    <bitfield name="BindingFlags"
              version="2.26"
              glib:type-name="GBindingFlags"
              glib:get-type="g_binding_flags_get_type"
              c:type="GBindingFlags">
      <doc xml:whitespace="preserve">Flags to be passed to g_object_bind_property() or
g_object_bind_property_full().
This enumeration can be extended at later date.</doc>
      <member name="default"
              value="0"
              c:identifier="G_BINDING_DEFAULT"
              glib:nick="default"/>
      <member name="bidirectional"
              value="1"
              c:identifier="G_BINDING_BIDIRECTIONAL"
              glib:nick="bidirectional"/>
      <member name="sync_create"
              value="2"
              c:identifier="G_BINDING_SYNC_CREATE"
              glib:nick="sync-create"/>
      <member name="invert_boolean"
              value="4"
              c:identifier="G_BINDING_INVERT_BOOLEAN"
              glib:nick="invert-boolean"/>
    </bitfield>
    <callback name="BindingTransformFunc"
              c:type="GBindingTransformFunc"
              version="2.26">
      <doc xml:whitespace="preserve">A function to be called to transform the source property of @source
from @source_value into the target property of @target
using @target_value.
otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the transformation was successful, and %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="binding" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GBinding</doc>
          <type name="Binding" c:type="GBinding*"/>
        </parameter>
        <parameter name="source_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the source property</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="target_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the target property</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">data passed to the transform function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BoxedCopyFunc" c:type="GBoxedCopyFunc" introspectable="0">
      <doc xml:whitespace="preserve">This function is provided by the user and should produce a copy of the passed
in boxed structure.</doc>
      <return-value>
        <doc xml:whitespace="preserve">The newly created copy of the boxed structure.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="boxed" transfer-ownership="none">
          <doc xml:whitespace="preserve">The boxed structure to be copied.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BoxedFreeFunc" c:type="GBoxedFreeFunc">
      <doc xml:whitespace="preserve">This function is provided by the user and should free the boxed
structure passed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="boxed" transfer-ownership="none">
          <doc xml:whitespace="preserve">The boxed structure to be freed.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="ByteArray"
                c:symbol-prefix="byte_array"
                glib:type-name="GByteArray"
                glib:get-type="g_byte_array_get_type">
    </glib:boxed>
    <record name="CClosure" c:type="GCClosure">
      <doc xml:whitespace="preserve">A #GCClosure is a specialization of #GClosure for C function callbacks.</doc>
      <field name="closure" writable="1">
        <type name="Closure" c:type="GClosure"/>
      </field>
      <field name="callback" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <callback name="Callback" c:type="GCallback">
      <doc xml:whitespace="preserve">The type used for callback functions in structure definitions and function 
signatures. This doesn't mean that all callback functions must take no 
parameters and return void. The required signature of a callback function 
is determined by the context in which is used (e.g. the signal to which it 
is connected). Use G_CALLBACK() to cast the callback function to a #GCallback.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </callback>
    <callback name="ClassFinalizeFunc" c:type="GClassFinalizeFunc">
      <doc xml:whitespace="preserve">A callback function used by the type system to finalize a class.
This function is rarely needed, as dynamically allocated class resources
should be handled by GBaseInitFunc() and GBaseFinalizeFunc().
Also, specification of a GClassFinalizeFunc() in the #GTypeInfo
structure of a static type is invalid, because classes of static types
will never be finalized (they are artificially kept alive when their
reference count drops to zero).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypeClass structure to finalize.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="class_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The @class_data member supplied via the #GTypeInfo structure.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ClassInitFunc" c:type="GClassInitFunc">
      <doc xml:whitespace="preserve">A callback function used by the type system to initialize the class
of a specific type. This function should initialize all static class
members.
The initialization process of a class involves:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;
1 - Copying common members from the parent class over to the
derived class structure.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
2 -  Zero initialization of the remaining members not copied
over from the parent class.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
3 - Invocation of the GBaseInitFunc() initializers of all parent
types and the class' type.
&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;
4 - Invocation of the class' GClassInitFunc() initializer.
&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
Since derived classes are partially initialized through a memory copy
of the parent class, the general rule is that GBaseInitFunc() and
GBaseFinalizeFunc() should take care of necessary reinitialization
and release of those class members that were introduced by the type
that specified these GBaseInitFunc()/GBaseFinalizeFunc().
GClassInitFunc() should only care about initializing static
class members, while dynamic class members (such as allocated strings
or reference counted resources) are better handled by a GBaseInitFunc()
for this type, so proper initialization of the dynamic class members
is performed for class initialization of derived types as well.
An example may help to correspond the intend of the different class
initializers:
|[
typedef struct {
GObjectClass parent_class;
gint         static_integer;
gchar       *dynamic_string;
} TypeAClass;
static void
type_a_base_class_init (TypeAClass *class)
{
class-&gt;dynamic_string = g_strdup ("some string");
}
static void
type_a_base_class_finalize (TypeAClass *class)
{
g_free (class-&gt;dynamic_string);
}
static void
type_a_class_init (TypeAClass *class)
{
class-&gt;static_integer = 42;
}
typedef struct {
TypeAClass   parent_class;
gfloat       static_float;
GString     *dynamic_gstring;
} TypeBClass;
static void
type_b_base_class_init (TypeBClass *class)
{
class-&gt;dynamic_gstring = g_string_new ("some other string");
}
static void
type_b_base_class_finalize (TypeBClass *class)
{
g_string_free (class-&gt;dynamic_gstring);
}
static void
type_b_class_init (TypeBClass *class)
{
class-&gt;static_float = 3.14159265358979323846;
}
]|
Initialization of TypeBClass will first cause initialization of
TypeAClass (derived classes reference their parent classes, see
g_type_class_ref() on this).
Initialization of TypeAClass roughly involves zero-initializing its fields,
then calling its GBaseInitFunc() type_a_base_class_init() to allocate
its dynamic members (dynamic_string), and finally calling its GClassInitFunc()
type_a_class_init() to initialize its static members (static_integer).
The first step in the initialization process of TypeBClass is then
a plain memory copy of the contents of TypeAClass into TypeBClass and 
zero-initialization of the remaining fields in TypeBClass.
The dynamic members of TypeAClass within TypeBClass now need
reinitialization which is performed by calling type_a_base_class_init()
with an argument of TypeBClass.
After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()
is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),
is called to complete the initialization process with the static members
(static_float).
Corresponding finalization counter parts to the GBaseInitFunc() functions
have to be provided to release allocated resources at class finalization
time.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypeClass structure to initialize.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="class_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The @class_data member supplied via the #GTypeInfo structure.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Closure"
            c:type="GClosure"
            glib:type-name="GClosure"
            glib:get-type="g_closure_get_type"
            c:symbol-prefix="closure">
      <doc xml:whitespace="preserve">A #GClosure represents a callback supplied by the programmer.</doc>
      <field name="ref_count" writable="1" bits="15">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="meta_marshal" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="n_guards" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="n_fnotifiers" writable="1" bits="2">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="n_inotifiers" writable="1" bits="8">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="in_inotify" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="floating" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="derivative_flag" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="in_marshal" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="is_invalid" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="marshal">
        <callback name="marshal">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="closure" transfer-ownership="none">
              <type name="Closure" c:type="GClosure*"/>
            </parameter>
            <parameter name="return_value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="n_param_values" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="param_values" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="invocation_hint" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="marshal_data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="notifiers" writable="1">
        <type name="ClosureNotifyData" c:type="GClosureNotifyData*"/>
      </field>
      <constructor name="new_object" c:identifier="g_closure_new_object">
        <doc xml:whitespace="preserve">A variant of g_closure_new_simple() which stores @object in the
when implementing new types of closures.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GClosure</doc>
          <type name="Closure" c:type="GClosure*"/>
        </return-value>
        <parameters>
          <parameter name="sizeof_closure" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the structure to allocate, must be at least &lt;literal&gt;sizeof (GClosure)&lt;/literal&gt;</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject pointer to store in the @data field of the newly allocated #GClosure</doc>
            <type name="Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_simple" c:identifier="g_closure_new_simple">
        <doc xml:whitespace="preserve">Allocates a struct of the given size and initializes the initial
part as a #GClosure. This function is mainly useful when
implementing new types of closures.
|[
typedef struct _MyClosure MyClosure;
struct _MyClosure
{
GClosure closure;
// extra data goes here
};
static void
my_closure_finalize (gpointer  notify_data,
GClosure *closure)
{
MyClosure *my_closure = (MyClosure *)closure;
// free extra data here
}
MyClosure *my_closure_new (gpointer data)
{
GClosure *closure;
MyClosure *my_closure;
closure = g_closure_new_simple (sizeof (MyClosure), data);
my_closure = (MyClosure *) closure;
// initialize extra data here
g_closure_add_finalize_notifier (closure, notify_data,
my_closure_finalize);
return my_closure;
}
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GClosure</doc>
          <type name="Closure" c:type="GClosure*"/>
        </return-value>
        <parameters>
          <parameter name="sizeof_closure" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the structure to allocate, must be at least &lt;literal&gt;sizeof (GClosure)&lt;/literal&gt;</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to store in the @data field of the newly allocated #GClosure</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_finalize_notifier"
              c:identifier="g_closure_add_finalize_notifier"
              introspectable="0">
        <doc xml:whitespace="preserve">Registers a finalization notifier which will be called when the
reference count of @closure goes down to 0. Multiple finalization
notifiers on a single closure are invoked in unspecified order. If
a single call to g_closure_unref() results in the closure being
both invalidated and finalized, then the invalidate notifiers will
be run before the finalize notifiers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="notify_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @notify_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback function to register</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_invalidate_notifier"
              c:identifier="g_closure_add_invalidate_notifier"
              introspectable="0">
        <doc xml:whitespace="preserve">Registers an invalidation notifier which will be called when the
notifiers are invoked before finalization notifiers, in an
unspecified order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="notify_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @notify_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback function to register</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_marshal_guards"
              c:identifier="g_closure_add_marshal_guards"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds a pair of notifiers which get invoked before and after the
closure callback, respectively. This is typically used to protect
the extra arguments for the duration of the callback. See
g_object_watch_closure() for an example of marshal guards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pre_marshal_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @pre_marshal_notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="pre_marshal_notify"
                     transfer-ownership="none"
                     closure="2">
            <doc xml:whitespace="preserve">a function to call before the closure callback</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
          <parameter name="post_marshal_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @post_marshal_notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="post_marshal_notify" transfer-ownership="none">
            <doc xml:whitespace="preserve">a function to call after the closure callback</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="invalidate" c:identifier="g_closure_invalidate">
        <doc xml:whitespace="preserve">Sets a flag on the closure to indicate that its calling
environment has become invalid, and thus causes any future
invocations of g_closure_invoke() on this @closure to be
ignored. Also, invalidation notifiers installed on the closure will
be called at this point. Note that unless you are holding a
reference to the closure yourself, the invalidation notifiers may
unref the closure and cause it to be destroyed, so if you need to
access the closure after calling g_closure_invalidate(), make sure
that you've previously called g_closure_ref().
Note that g_closure_invalidate() will also be called when the
reference count of a closure drops to zero (unless it has already
been invalidated before).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="invoke" c:identifier="g_closure_invoke">
        <doc xml:whitespace="preserve">Invokes the closure, i.e. executes the callback represented by the @closure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="return_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue to store the return value. May be %NULL if the callback of @closure doesn't return a value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of the @param_values array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="param_values" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of #GValue&lt;!-- --&gt;s holding the arguments on which to invoke the callback of @closure</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none">
            <doc xml:whitespace="preserve">a context-dependent invocation hint</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_closure_ref">
        <doc xml:whitespace="preserve">Increments the reference count on a closure to force it staying
alive while the caller holds a pointer to it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The @closure passed in, for convenience</doc>
          <type name="Closure" c:type="GClosure*"/>
        </return-value>
      </method>
      <method name="remove_finalize_notifier"
              c:identifier="g_closure_remove_finalize_notifier"
              introspectable="0">
        <doc xml:whitespace="preserve">Removes a finalization notifier.
Notice that notifiers are automatically removed after they are run.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="notify_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data which was passed to g_closure_add_finalize_notifier() when registering @notify_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback function to remove</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_invalidate_notifier"
              c:identifier="g_closure_remove_invalidate_notifier"
              introspectable="0">
        <doc xml:whitespace="preserve">Removes an invalidation notifier.
Notice that notifiers are automatically removed after they are run.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="notify_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data which was passed to g_closure_add_invalidate_notifier() when registering @notify_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback function to remove</doc>
            <type name="ClosureNotify" c:type="GClosureNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_marshal"
              c:identifier="g_closure_set_marshal"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the marshaller of @closure. The &lt;literal&gt;marshal_data&lt;/literal&gt;
of @marshal provides a way for a meta marshaller to provide additional
information to the marshaller. (See g_closure_set_meta_marshal().) For
GObject's C predefined marshallers (the g_cclosure_marshal_*()
functions), what it provides is a callback function to use instead of</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="marshal" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GClosureMarshal function</doc>
            <type name="ClosureMarshal" c:type="GClosureMarshal"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_meta_marshal"
              c:identifier="g_closure_set_meta_marshal"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the meta marshaller of @closure.  A meta marshaller wraps
fashion. The most common use of this facility is for C callbacks.
The same marshallers (generated by &lt;link
linkend="glib-genmarshal"&gt;glib-genmarshal&lt;/link&gt;) are used
everywhere, but the way that we get the callback function
differs. In most cases we want to use @closure-&gt;callback, but in
other cases we want to use some different technique to retrieve the
callback function.
For example, class closures for signals (see
g_signal_type_cclosure_new()) retrieve the callback function from a
fixed offset in the class structure.  The meta marshaller retrieves
the right callback and passes it to the marshaller as the</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="marshal_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">context-dependent data to pass to @meta_marshal</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="meta_marshal" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GClosureMarshal function</doc>
            <type name="ClosureMarshal" c:type="GClosureMarshal"/>
          </parameter>
        </parameters>
      </method>
      <method name="sink" c:identifier="g_closure_sink">
        <doc xml:whitespace="preserve">Takes over the initial ownership of a closure.  Each closure is
initially created in a &lt;firstterm&gt;floating&lt;/firstterm&gt; state, which
means that the initial reference count is not owned by any caller.
g_closure_sink() checks to see if the object is still floating, and
if so, unsets the floating state and decreases the reference
count. If the closure is not floating, g_closure_sink() does
nothing. The reason for the existance of the floating state is to
prevent cumbersome code sequences like:
|[
closure = g_cclosure_new (cb_func, cb_data);
g_source_set_closure (source, closure);
g_closure_unref (closure); // XXX GObject doesn't really need this
]|
Because g_source_set_closure() (and similar functions) take ownership of the
initial reference count, if it is unowned, we instead can write:
|[
g_source_set_closure (source, g_cclosure_new (cb_func, cb_data));
]|
Generally, this function is used together with g_closure_ref(). Ane example
of storing a closure for later notification looks like:
|[
static GClosure *notify_closure = NULL;
void
foo_notify_set_closure (GClosure *closure)
{
if (notify_closure)
g_closure_unref (notify_closure);
notify_closure = closure;
if (notify_closure)
{
g_closure_ref (notify_closure);
g_closure_sink (notify_closure);
}
}
]|
Because g_closure_sink() may decrement the reference count of a closure
(if it hasn't been called on @closure yet) just like g_closure_unref(),
g_closure_ref() should be called prior to this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="unref" c:identifier="g_closure_unref">
        <doc xml:whitespace="preserve">Decrements the reference count of a closure after it was previously
incremented by the same caller. If no other callers are using the
closure, then the closure will be destroyed and freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <callback name="ClosureMarshal" c:type="GClosureMarshal">
      <doc xml:whitespace="preserve">The type used for marshaller functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue to store the return value. May be %NULL if the callback of @closure doesn't return a value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of the @param_values array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of #GValue&lt;!-- --&gt;s holding the arguments on which to invoke the callback of @closure</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller, see g_closure_set_marshal() and g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ClosureNotify" c:type="GClosureNotify">
      <doc xml:whitespace="preserve">The type used for the various notification callbacks which can be registered
on closures.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data specified when registering the notification callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure on which the notification is emitted</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ClosureNotifyData" c:type="GClosureNotifyData">
      <field name="data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="notify" writable="1">
        <type name="ClosureNotify" c:type="GClosureNotify"/>
      </field>
    </record>
    <bitfield name="ConnectFlags" c:type="GConnectFlags">
      <doc xml:whitespace="preserve">The connection flags are used to specify the behaviour of a signal's 
connection.</doc>
      <member name="after" value="1" c:identifier="G_CONNECT_AFTER"/>
      <member name="swapped" value="2" c:identifier="G_CONNECT_SWAPPED"/>
    </bitfield>
    <glib:boxed glib:name="Date"
                c:symbol-prefix="date"
                glib:type-name="GDate"
                glib:get-type="g_date_get_type">
    </glib:boxed>
    <glib:boxed glib:name="DateTime"
                c:symbol-prefix="date_time"
                glib:type-name="GDateTime"
                glib:get-type="g_date_time_get_type">
    </glib:boxed>
    <record name="EnumClass" c:type="GEnumClass">
      <doc xml:whitespace="preserve">The class of an enumeration type holds information about its 
possible values.</doc>
      <field name="g_type_class" writable="1">
        <type name="TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="minimum" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="maximum" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="n_values" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="values" writable="1">
        <type name="EnumValue" c:type="GEnumValue*"/>
      </field>
    </record>
    <record name="EnumValue" c:type="GEnumValue">
      <doc xml:whitespace="preserve">A structure which contains a single enum value, its name, and its
nickname.</doc>
      <field name="value" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="value_name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="value_nick" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
    </record>
    <glib:boxed glib:name="Error"
                c:symbol-prefix="error"
                glib:type-name="GError"
                glib:get-type="g_error_get_type">
    </glib:boxed>
    <record name="FlagsClass" c:type="GFlagsClass">
      <doc xml:whitespace="preserve">The class of a flags type holds information about its 
possible values.</doc>
      <field name="g_type_class" writable="1">
        <type name="TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="mask" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="n_values" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="values" writable="1">
        <type name="FlagsValue" c:type="GFlagsValue*"/>
      </field>
    </record>
    <record name="FlagsValue" c:type="GFlagsValue">
      <doc xml:whitespace="preserve">A structure which contains a single flags value, its name, and its
nickname.</doc>
      <field name="value" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="value_name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="value_nick" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
    </record>
    <glib:boxed glib:name="HashTable"
                c:symbol-prefix="hash_table"
                glib:type-name="GHashTable"
                glib:get-type="g_hash_table_get_type">
    </glib:boxed>
    <glib:boxed glib:name="IOChannel"
                c:symbol-prefix="io_channel"
                glib:type-name="GIOChannel"
                glib:get-type="g_io_channel_get_type">
    </glib:boxed>
    <bitfield name="IOCondition"
              glib:type-name="GIOCondition"
              glib:get-type="g_io_condition_get_type"
              c:type="GIOCondition">
      <member name="in" value="1" c:identifier="G_IO_IN" glib:nick="in"/>
      <member name="out" value="4" c:identifier="G_IO_OUT" glib:nick="out"/>
      <member name="pri" value="2" c:identifier="G_IO_PRI" glib:nick="pri"/>
      <member name="err" value="8" c:identifier="G_IO_ERR" glib:nick="err"/>
      <member name="hup" value="16" c:identifier="G_IO_HUP" glib:nick="hup"/>
      <member name="nval"
              value="32"
              c:identifier="G_IO_NVAL"
              glib:nick="nval"/>
    </bitfield>
    <class name="InitiallyUnowned"
           c:symbol-prefix="object"
           parent="Object"
           abstract="1"
           glib:type-name="GInitiallyUnowned"
           glib:get-type="g_initially_unowned_get_type"
           glib:type-struct="InitiallyUnownedClass">
      <doc xml:whitespace="preserve">All the fields in the &lt;structname&gt;GInitiallyUnowned&lt;/structname&gt; structure 
are private to the #GInitiallyUnowned implementation and should never be 
accessed directly.</doc>
      <function name="bind_property"
                c:identifier="g_object_bind_property"
                version="2.26">
        <doc xml:whitespace="preserve">Creates a binding between @source_property on @source and @target_property
on @target. Whenever the @source_property is changed the @target_property is
updated using the same value. For instance:
|[
g_object_bind_property (action, "active", widget, "sensitive", 0);
]|
Will result in the "sensitive" property of the widget #GObject instance to be
updated with the same value of the "active" property of the action #GObject
instance.
If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
if @target_property on @target changes then the @source_property on @source
will be updated as well.
The binding will automatically be removed when either the @source or the
#GBinding instance.
A #GObject can have multiple bindings.
binding between the two #GObject instances. The binding is released
whenever the #GBinding reference count reaches zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GBinding instance representing the</doc>
          <type name="Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="source_property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property on @source to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property on @target to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="bind_property_full"
                c:identifier="g_object_bind_property_full"
                shadowed-by="bind_property_with_closures"
                version="2.26">
        <doc xml:whitespace="preserve">Complete version of g_object_bind_property().
Creates a binding between @source_property on @source and @target_property
on @target, allowing you to set the transformation functions to be used by
the binding.
If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
if @target_property on @target changes then the @source_property on @source
will be updated as well. The @transform_from function is only used in case
of bidirectional bindings, otherwise it will be ignored
The binding will automatically be removed when either the @source or the
#GBinding instance.
A #GObject can have multiple bindings.
&lt;note&gt;The same @user_data parameter will be used for both @transform_to
and @transform_from transformation functions; the @notify function will
be called once, when the binding is removed. If you need different data
for each transformation function, please use
g_object_bind_property_with_closures() instead.&lt;/note&gt;
binding between the two #GObject instances. The binding is released
whenever the #GBinding reference count reaches zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GBinding instance representing the</doc>
          <type name="Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="source_property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property on @source to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property on @target to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags"/>
          </parameter>
          <parameter name="transform_to"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="notified">
            <doc xml:whitespace="preserve">the transformation function from the @source to the @target, or %NULL to use the default</doc>
            <type name="BindingTransformFunc" c:type="GBindingTransformFunc"/>
          </parameter>
          <parameter name="transform_from"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="notified"
                     closure="7"
                     destroy="8">
            <doc xml:whitespace="preserve">the transformation function from the @target to the @source, or %NULL to use the default</doc>
            <type name="BindingTransformFunc" c:type="GBindingTransformFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">custom data to be passed to the transformation functions, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">function to be called when disposing the binding, to free the resources used by the transformation functions</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <function name="bind_property_with_closures"
                c:identifier="g_object_bind_property_with_closures"
                shadows="bind_property_full"
                version="2.26">
        <doc xml:whitespace="preserve">Creates a binding between @source_property on @source and @target_property
on @target, allowing you to set the transformation functions to be used by
the binding.
This function is the language bindings friendly version of
g_object_bind_property_full(), using #GClosure&lt;!-- --&gt;s instead of
function pointers.
binding between the two #GObject instances. The binding is released
whenever the #GBinding reference count reaches zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GBinding instance representing the</doc>
          <type name="Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="source_property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property on @source to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property on @target to bind</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags"/>
          </parameter>
          <parameter name="transform_to" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GClosure wrapping the transformation function from the @source to the @target, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
          <parameter name="transform_from" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GClosure wrapping the transformation function from the @target to the @source, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
        </parameters>
      </function>
      <function name="compat_control" c:identifier="g_object_compat_control">
        <return-value transfer-ownership="none">
          <type name="gulong" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="what" transfer-ownership="none">
            <type name="gulong" c:type="gsize"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="connect"
                c:identifier="g_object_connect"
                introspectable="0">
        <doc xml:whitespace="preserve">A convenience function to connect multiple signals at once.
The signal specs expected by this function have the form
"modifier::signal_name", where modifier can be one of the following:
&lt;variablelist&gt;
&lt;varlistentry&gt;
&lt;term&gt;signal&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;
equivalent to &lt;literal&gt;g_signal_connect_data (..., NULL, 0)&lt;/literal&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;object_signal&lt;/term&gt;
&lt;term&gt;object-signal&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;
equivalent to &lt;literal&gt;g_signal_connect_object (..., 0)&lt;/literal&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;swapped_signal&lt;/term&gt;
&lt;term&gt;swapped-signal&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;
equivalent to &lt;literal&gt;g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED)&lt;/literal&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;swapped_object_signal&lt;/term&gt;
&lt;term&gt;swapped-object-signal&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;
equivalent to &lt;literal&gt;g_signal_connect_object (..., G_CONNECT_SWAPPED)&lt;/literal&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;signal_after&lt;/term&gt;
&lt;term&gt;signal-after&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;
equivalent to &lt;literal&gt;g_signal_connect_data (..., NULL, G_CONNECT_AFTER)&lt;/literal&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;object_signal_after&lt;/term&gt;
&lt;term&gt;object-signal-after&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;
equivalent to &lt;literal&gt;g_signal_connect_object (..., G_CONNECT_AFTER)&lt;/literal&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;swapped_signal_after&lt;/term&gt;
&lt;term&gt;swapped-signal-after&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;
equivalent to &lt;literal&gt;g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED | G_CONNECT_AFTER)&lt;/literal&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;swapped_object_signal_after&lt;/term&gt;
&lt;term&gt;swapped-object-signal-after&lt;/term&gt;
&lt;listitem&gt;&lt;para&gt;
equivalent to &lt;literal&gt;g_signal_connect_object (..., G_CONNECT_SWAPPED | G_CONNECT_AFTER)&lt;/literal&gt;
&lt;/para&gt;&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;/variablelist&gt;
|[
menu-&gt;toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,
"type", GTK_WINDOW_POPUP,
"child", menu,
NULL),
"signal::event", gtk_menu_window_event, menu,
"signal::size_request", gtk_menu_window_size_request, menu,
"signal::destroy", gtk_widget_destroyed, &amp;amp;menu-&amp;gt;toplevel,
NULL);
]|</doc>
        <return-value>
          <doc xml:whitespace="preserve">@object</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="signal_spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the spec for the first signal</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </function>
      <function name="disconnect"
                c:identifier="g_object_disconnect"
                introspectable="0">
        <doc xml:whitespace="preserve">A convenience function to disconnect multiple signals at once.
The signal specs expected by this function have the form
"any_signal", which means to disconnect any signal with matching
callback and data, or "any_signal::signal_name", which only
disconnects the signal named "signal_name".</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="signal_spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the spec for the first signal</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </function>
      <function name="get" c:identifier="g_object_get" introspectable="0">
        <doc xml:whitespace="preserve">Gets properties of an object.
In general, a copy is made of the property contents and the caller
is responsible for freeing the memory in the appropriate manner for
the type, for instance by calling g_free() or g_object_unref().
&lt;example&gt;
&lt;title&gt;Using g_object_get(&lt;!-- --&gt;)&lt;/title&gt;
An example of using g_object_get() to get the contents
of three properties - one of type #G_TYPE_INT,
one of type #G_TYPE_STRING, and one of type #G_TYPE_OBJECT:
&lt;programlisting&gt;
gint intval;
gchar *strval;
GObject *objval;
g_object_get (my_object,
"int-property", &amp;intval,
"str-property", &amp;strval,
"obj-property", &amp;objval,
NULL);
// Do something with intval, strval, objval
g_free (strval);
g_object_unref (objval);
&lt;/programlisting&gt;
&lt;/example&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the first property to get</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </function>
      <function name="interface_find_property"
                c:identifier="g_object_interface_find_property"
                version="2.4"
                introspectable="0">
        <doc xml:whitespace="preserve">Find the #GParamSpec with the given name for an
interface. Generally, the interface vtable passed in as @g_iface
will be the default vtable from g_type_default_interface_ref(), or,
if you know the interface has already been loaded,
g_type_default_interface_peek().
name @property_name, or %NULL if no such property exists.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the #GParamSpec for the property of the interface with the</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">any interface vtable for the interface, or the default vtable for the interface</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of a property to lookup.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="interface_install_property"
                c:identifier="g_object_interface_install_property"
                version="2.4">
        <doc xml:whitespace="preserve">Add a property to an interface; this is only useful for interfaces
that are added to GObject-derived types. Adding a property to an
interface forces all objects classes with that interface to have a
compatible property. The compatible property could be a newly
created #GParamSpec, but normally
g_object_class_override_property() will be used so that the object
class only needs to provide an implementation and inherits the
property description, default value, bounds, and so forth from the
interface property.
This function is meant to be called from the interface's default
vtable initialization function (the @class_init member of
#GTypeInfo.) It must not be called after after @class_init has
been called for any object types implementing this interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">any interface vtable for the interface, or the default vtable for the interface.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="interface_list_properties"
                c:identifier="g_object_interface_list_properties"
                version="2.4"
                introspectable="0">
        <doc xml:whitespace="preserve">Lists the properties of an interface.Generally, the interface
vtable passed in as @g_iface will be the default vtable from
g_type_default_interface_ref(), or, if you know the interface has
already been loaded, g_type_default_interface_peek().
structures. The paramspecs are owned by GLib, but the
array should be freed with g_free() when you are done with
it.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a pointer to an array of pointers to #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec**"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">any interface vtable for the interface, or the default vtable for the interface</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="n_properties_p" transfer-ownership="none">
            <doc xml:whitespace="preserve">location to store number of properties returned.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_floating"
                c:identifier="g_object_is_floating"
                version="2.10">
        <doc xml:whitespace="preserve">Checks wether @object has a &lt;link linkend="floating-ref"&gt;floating&lt;/link&gt;
reference.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @object has a floating reference</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="g_object_new" introspectable="0">
        <doc xml:whitespace="preserve">Creates a new instance of a #GObject subtype and sets its properties.
Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
which are not explicitly specified are set to their default values.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new instance of @object_type</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type id of the #GObject subtype to instantiate</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the first property</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </function>
      <function name="new_valist"
                c:identifier="g_object_new_valist"
                introspectable="0">
        <doc xml:whitespace="preserve">Creates a new instance of a #GObject subtype and sets its properties.
Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
which are not explicitly specified are set to their default values.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new instance of @object_type</doc>
          <type name="Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type id of the #GObject subtype to instantiate</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the first property</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the first property, followed optionally by more name/value pairs, followed by %NULL</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </function>
      <function name="newv" c:identifier="g_object_newv" introspectable="0">
        <doc xml:whitespace="preserve">Creates a new instance of a #GObject subtype and sets its properties.
Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
which are not explicitly specified are set to their default values.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new instance of @object_type</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type id of the #GObject subtype to instantiate</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of the @parameters array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of #GParameter</doc>
            <type name="Parameter" c:type="GParameter*"/>
          </parameter>
        </parameters>
      </function>
      <function name="ref" c:identifier="g_object_ref" introspectable="0">
        <doc xml:whitespace="preserve">Increases the reference count of @object.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the same @object</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="ref_sink"
                c:identifier="g_object_ref_sink"
                version="2.10"
                introspectable="0">
        <doc xml:whitespace="preserve">Increase the reference count of @object, and possibly remove the
&lt;link linkend="floating-ref"&gt;floating&lt;/link&gt; reference, if @object
has a floating reference.
In other words, if the object is floating, then this call "assumes
ownership" of the floating reference, converting it to a normal
reference by clearing the floating flag while leaving the reference
count unchanged.  If the object is not floating, then this call
adds a new normal reference increasing the reference count by one.</doc>
        <return-value>
          <doc xml:whitespace="preserve">@object</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="set" c:identifier="g_object_set" introspectable="0">
        <doc xml:whitespace="preserve">Sets properties on an object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the first property to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </function>
      <function name="type_init" c:identifier="g_object_type_init">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="unref" c:identifier="g_object_unref">
        <doc xml:whitespace="preserve">Decreases the reference count of @object. When its reference count
drops to 0, the object is finalized (i.e. its memory is freed).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <field name="g_type_instance" writable="1">
        <type name="TypeInstance" c:type="GTypeInstance"/>
      </field>
      <field name="ref_count" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="qdata" writable="1">
        <type name="GLib.Data" c:type="GData*"/>
      </field>
    </class>
    <record name="InitiallyUnownedClass"
            c:type="GInitiallyUnownedClass"
            disguised="1"
            glib:is-gtype-struct-for="InitiallyUnowned">
      <doc xml:whitespace="preserve">The class structure for the &lt;structname&gt;GInitiallyUnowned&lt;/structname&gt; type.</doc>
      <field name="g_type_class">
        <type name="TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="construct_properties">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="constructor" introspectable="0">
        <callback name="constructor" introspectable="0">
          <return-value>
            <type name="Object" c:type="GObject*"/>
          </return-value>
          <parameters>
            <parameter name="type" transfer-ownership="none">
              <type name="GType" c:type="GType"/>
            </parameter>
            <parameter name="n_construct_properties" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="construct_properties" transfer-ownership="none">
              <type name="ObjectConstructParam"
                    c:type="GObjectConstructParam*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_property">
        <callback name="set_property">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="property_id" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_property">
        <callback name="get_property">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="property_id" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dispose">
        <callback name="dispose">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finalize">
        <callback name="finalize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dispatch_properties_changed">
        <callback name="dispatch_properties_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="n_pspecs" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="pspecs" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="notify">
        <callback name="notify">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="constructed">
        <callback name="constructed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flags">
        <type name="gulong" c:type="gsize"/>
      </field>
      <field name="pdummy">
        <array zero-terminated="0" c:type="gpointer" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="InstanceInitFunc" c:type="GInstanceInitFunc">
      <doc xml:whitespace="preserve">A callback function used by the type system to initialize a new
instance of a type. This function initializes all instance members and
allocates any resources required by it.
Initialization of a derived instance involves calling all its parent
types instance initializers, so the class member of the instance
is altered during its initialization to always point to the class that
belongs to the type the current initializer was introduced for.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">The instance to initialize.</doc>
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of the type the instance is created for.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="InterfaceFinalizeFunc" c:type="GInterfaceFinalizeFunc">
      <doc xml:whitespace="preserve">A callback function used by the type system to finalize an interface.
This function should destroy any internal data and release any resources
allocated by the corresponding GInterfaceInitFunc() function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">The interface structure to finalize.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The @interface_data supplied via the #GInterfaceInfo structure.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="InterfaceInfo" c:type="GInterfaceInfo">
      <doc xml:whitespace="preserve">A structure that provides information to the type system which is
used specifically for managing interface types.</doc>
      <field name="interface_init" writable="1">
        <type name="InterfaceInitFunc" c:type="GInterfaceInitFunc"/>
      </field>
      <field name="interface_finalize" writable="1">
        <type name="InterfaceFinalizeFunc" c:type="GInterfaceFinalizeFunc"/>
      </field>
      <field name="interface_data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <callback name="InterfaceInitFunc" c:type="GInterfaceInitFunc">
      <doc xml:whitespace="preserve">A callback function used by the type system to initialize a new
interface.  This function should initialize all internal data and
allocate any resources required by the interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">The interface structure to initialize.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The @interface_data supplied via the #GInterfaceInfo structure.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Object"
           c:symbol-prefix="object"
           parent="Object"
           abstract="1"
           glib:type-name="GObject"
           glib:get-type="intern"
           glib:type-struct="ObjectClass">
      <doc xml:whitespace="preserve">All the fields in the &lt;structname&gt;GObject&lt;/structname&gt; structure are private 
to the #GObject implementation and should never be accessed directly.</doc>
      <virtual-method name="constructed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="dispatch_properties_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_pspecs" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="pspecs" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dispose">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="finalize">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_property">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="property_id" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="notify" invoker="notify">
        <doc xml:whitespace="preserve">Emits a "notify" signal for the property @property_name on @object.
When possible, eg. when signaling a property change from within the class
that registered the property, you should use g_object_notify_by_pspec()
instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_property">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="property_id" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="Value" c:type="GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_toggle_ref"
              c:identifier="g_object_add_toggle_ref"
              version="2.8"
              introspectable="0">
        <doc xml:whitespace="preserve">Increases the reference count of the object by one and sets a
callback to be called when all other references to the object are
dropped, or when this is already the last reference to the object
and another reference is established.
This functionality is intended for binding @object to a proxy
object managed by another memory manager. This is done with two
g_object_add_toggle_ref() and a reverse reference to the proxy
object which is either a strong reference or weak reference.
The setup is that when there are no other references to @object,
only a weak reference is held in the reverse direction from @object
to the proxy object, but when there are other references held to
when the reference from @object to the proxy object should be
&lt;firstterm&gt;toggled&lt;/firstterm&gt; from strong to weak (@is_last_ref
true) or weak to strong (@is_last_ref false).
Since a (normal) reference must be held to the object before
calling g_object_toggle_ref(), the initial state of the reverse
link is always strong.
Multiple toggle references may be added to the same gobject,
however if there are multiple toggle references to an object, none
of them will ever be notified until all but one are removed.  For
this reason, you should only ever use a toggle reference if there
is important state in the proxy object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="notify" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">a function to call when this reference is the last reference to the object, or is no longer the last reference.</doc>
            <type name="ToggleNotify" c:type="GToggleNotify"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_weak_pointer" c:identifier="g_object_add_weak_pointer">
        <doc xml:whitespace="preserve">Adds a weak reference from weak_pointer to @object to indicate that
the pointer located at @weak_pointer_location is only valid during
the lifetime of @object. When the @object is finalized,</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="weak_pointer_location"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">The memory address of a pointer.</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="force_floating"
              c:identifier="g_object_force_floating"
              version="2.10">
        <doc xml:whitespace="preserve">This function is intended for #GObject implementations to re-enforce a
&lt;link linkend="floating-ref"&gt;floating&lt;/link&gt; object reference.
Doing this is seldomly required, all
#GInitiallyUnowned&lt;!-- --&gt;s are created with a floating reference which
usually just needs to be sunken by calling g_object_ref_sink().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="freeze_notify" c:identifier="g_object_freeze_notify">
        <doc xml:whitespace="preserve">Increases the freeze count on @object. If the freeze count is
non-zero, the emission of "notify" signals on @object is
stopped. The signals are queued until the freeze count is decreased
to zero.
This is necessary for accessors that modify multiple properties to prevent
premature notification while the object is still being modified.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_data"
              c:identifier="g_object_get_data"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets a named field from the objects table of associations (see g_object_set_data()).</doc>
        <return-value>
          <doc xml:whitespace="preserve">the data if found, or %NULL if no such data exists.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the key for that association</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_property" c:identifier="g_object_get_property">
        <doc xml:whitespace="preserve">Gets a property of an object.
In general, a copy is made of the property contents and the caller is
responsible for freeing the memory by calling g_value_unset().
Note that g_object_get_property() is really intended for language
bindings, g_object_get() is much more convenient for C programming.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the property to get</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">return location for the property value</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_qdata"
              c:identifier="g_object_get_qdata"
              introspectable="0">
        <doc xml:whitespace="preserve">This function gets back user data pointers stored via
g_object_set_qdata().</doc>
        <return-value>
          <doc xml:whitespace="preserve">The user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valist"
              c:identifier="g_object_get_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets properties of an object.
In general, a copy is made of the property contents and the caller
is responsible for freeing the memory in the appropriate manner for
the type, for instance by calling g_free() or g_object_unref().
See g_object_get().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the first property to get</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">return location for the first property, followed optionally by more name/return location pairs, followed by %NULL</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="notify" c:identifier="g_object_notify">
        <doc xml:whitespace="preserve">Emits a "notify" signal for the property @property_name on @object.
When possible, eg. when signaling a property change from within the class
that registered the property, you should use g_object_notify_by_pspec()
instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a property installed on the class of @object.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="notify_by_pspec"
              c:identifier="g_object_notify_by_pspec"
              version="2.26">
        <doc xml:whitespace="preserve">Emits a "notify" signal for the property specified by @pspec on @object.
This function omits the property name lookup, hence it is faster than
g_object_notify().
One way to avoid using g_object_notify() from within the
class that registered the properties, and using g_object_notify_by_pspec()
instead, is to store the GParamSpec used with
g_object_class_install_property() inside a static array, e.g.:
|[
enum
{
PROP_0,
PROP_FOO,
PROP_LAST
};
static GParamSpec *properties[PROP_LAST];
static void
my_object_class_init (MyObjectClass *klass)
{
properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
0, 100,
50,
G_PARAM_READWRITE);
g_object_class_install_property (gobject_class,
PROP_FOO,
properties[PROP_FOO]);
}
]|
and then notify a change on the "foo" property with:
|[
g_object_notify_by_pspec (self, properties[PROP_FOO]);
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GParamSpec of a property installed on the class of @object.</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_toggle_ref"
              c:identifier="g_object_remove_toggle_ref"
              version="2.8"
              introspectable="0">
        <doc xml:whitespace="preserve">Removes a reference added with g_object_add_toggle_ref(). The
reference count of the object is decreased by one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="notify" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">a function to call when this reference is the last reference to the object, or is no longer the last reference.</doc>
            <type name="ToggleNotify" c:type="GToggleNotify"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_weak_pointer"
              c:identifier="g_object_remove_weak_pointer">
        <doc xml:whitespace="preserve">Removes a weak reference from @object that was previously added
using g_object_add_weak_pointer(). The @weak_pointer_location has
to match the one used with g_object_add_weak_pointer().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="weak_pointer_location"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">The memory address of a pointer.</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run_dispose" c:identifier="g_object_run_dispose">
        <doc xml:whitespace="preserve">Releases all references to other objects. This can be used to break
reference cycles.
This functions should only be called from object system implementations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_data" c:identifier="g_object_set_data">
        <doc xml:whitespace="preserve">Each object carries around a table of associations from
strings to pointers.  This function lets you set an association.
If the object already had an association with that name,
the old association will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the key</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to associate with that key</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data_full" c:identifier="g_object_set_data_full">
        <doc xml:whitespace="preserve">Like g_object_set_data() except it adds notification
for when the association is destroyed, either by setting it
to a different value or when the object is destroyed.
Note that the @destroy callback is not called if @data is %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the key</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to associate with that key</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">function to call when the association is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_property" c:identifier="g_object_set_property">
        <doc xml:whitespace="preserve">Sets a property on an object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the property to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qdata" c:identifier="g_object_set_qdata">
        <doc xml:whitespace="preserve">This sets an opaque, named pointer on an object.
The name is specified through a #GQuark (retrived e.g. via
g_quark_from_static_string()), and the pointer
can be gotten back from the @object with g_object_get_qdata()
until the @object is finalized.
Setting a previously set user data pointer, overrides (frees)
the old pointer set, using #NULL as pointer essentially
removes the data stored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qdata_full" c:identifier="g_object_set_qdata_full">
        <doc xml:whitespace="preserve">This function works like g_object_set_qdata(), but in addition,
a void (*destroy) (gpointer) function may be specified which is
called with @data as argument when the @object is finalized, or
the data is being overwritten by a call to g_object_set_qdata()
with the same @quark.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">Function to invoke with @data as argument, when @data needs to be freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_valist"
              c:identifier="g_object_set_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets properties on an object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the first property to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">value for the first property, followed optionally by more name/value pairs, followed by %NULL</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_data"
              c:identifier="g_object_steal_data"
              introspectable="0">
        <doc xml:whitespace="preserve">Remove a specified datum from the object's data associations,
without invoking the association's destroy handler.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the data if found, or %NULL if no such data exists.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the key</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_qdata"
              c:identifier="g_object_steal_qdata"
              introspectable="0">
        <doc xml:whitespace="preserve">This function gets back user data pointers stored via
g_object_set_qdata() and removes the @data from object
without invoking its destroy() function (if any was
set).
Usually, calling this function is only required to update
user data pointers with a destroy notifier, for example:
|[
void
object_add_to_user_list (GObject     *object,
const gchar *new_string)
{
// the quark, naming the object data
GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
// retrive the old string list
GList *list = g_object_steal_qdata (object, quark_string_list);
// prepend new string
list = g_list_prepend (list, g_strdup (new_string));
// this changed 'list', so we need to set it again
g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
}
static void
free_string_list (gpointer data)
{
GList *node, *list = data;
for (node = list; node; node = node-&gt;next)
g_free (node-&gt;data);
g_list_free (list);
}
]|
Using g_object_get_qdata() in the above example, instead of
g_object_steal_qdata() would have left the destroy function set,
and thus the partial string list would have been freed upon
g_object_set_qdata_full().</doc>
        <return-value>
          <doc xml:whitespace="preserve">The user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="thaw_notify" c:identifier="g_object_thaw_notify">
        <doc xml:whitespace="preserve">Reverts the effect of a previous call to
g_object_freeze_notify(). The freeze count is decreased on @object
and when it reaches zero, all queued "notify" signals are emitted.
It is an error to call this function when the freeze count is zero.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="watch_closure" c:identifier="g_object_watch_closure">
        <doc xml:whitespace="preserve">This function essentially limits the life time of the @closure to
the life time of the object. That is, when the object is finalized,
the @closure is invalidated by calling g_closure_invalidate() on
it, in order to prevent invocations of the closure with a finalized
(nonexisting) object. Also, g_object_ref() and g_object_unref() are
added as marshal guards to the @closure, to ensure that an extra
reference count is held on @object during invocation of the
use this @object as closure data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:whitespace="preserve">GClosure to watch</doc>
            <type name="Closure" c:type="GClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="weak_ref"
              c:identifier="g_object_weak_ref"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds a weak reference callback to an object. Weak references are
used for notification when an object is finalized. They are called
"weak references" because they allow you to safely hold a pointer
to an object without calling g_object_ref() (g_object_ref() adds a
strong reference, that is, forces the object to stay alive).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="notify" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">callback to invoke before the object is freed</doc>
            <type name="WeakNotify" c:type="GWeakNotify"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">extra data to pass to notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="weak_unref"
              c:identifier="g_object_weak_unref"
              introspectable="0">
        <doc xml:whitespace="preserve">Removes a weak reference callback to an object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="notify" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">callback to search for</doc>
            <type name="WeakNotify" c:type="GWeakNotify"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to search for</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="g_type_instance" writable="1">
        <type name="TypeInstance" c:type="GTypeInstance"/>
      </field>
      <field name="ref_count" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="qdata" writable="1">
        <type name="GLib.Data" c:type="GData*"/>
      </field>
    </class>
    <record name="ObjectClass"
            c:type="GObjectClass"
            glib:is-gtype-struct-for="Object">
      <doc xml:whitespace="preserve">The class structure for the &lt;structname&gt;GObject&lt;/structname&gt; type.
&lt;example&gt;
&lt;title&gt;Implementing singletons using a constructor&lt;/title&gt;
&lt;programlisting&gt;
static MySingleton *the_singleton = NULL;
static GObject*
my_singleton_constructor (GType                  type,
guint                  n_construct_params,
GObjectConstructParam *construct_params)
{
GObject *object;
if (!the_singleton)
{
object = G_OBJECT_CLASS (parent_class)-&gt;constructor (type,
n_construct_params,
construct_params);
the_singleton = MY_SINGLETON (object);
}
else
object = g_object_ref (G_OBJECT (the_singleton));
return object;
}
&lt;/programlisting&gt;&lt;/example&gt;</doc>
      <field name="g_type_class">
        <type name="TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="construct_properties">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="constructor" introspectable="0">
        <callback name="constructor" introspectable="0">
          <return-value>
            <type name="Object" c:type="GObject*"/>
          </return-value>
          <parameters>
            <parameter name="type" transfer-ownership="none">
              <type name="GType" c:type="GType"/>
            </parameter>
            <parameter name="n_construct_properties" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="construct_properties" transfer-ownership="none">
              <type name="ObjectConstructParam"
                    c:type="GObjectConstructParam*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_property">
        <callback name="set_property">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="property_id" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_property">
        <callback name="get_property">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="property_id" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dispose">
        <callback name="dispose">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finalize">
        <callback name="finalize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dispatch_properties_changed">
        <callback name="dispatch_properties_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="n_pspecs" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="pspecs" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="notify">
        <callback name="notify">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="constructed">
        <callback name="constructed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flags">
        <type name="gulong" c:type="gsize"/>
      </field>
      <field name="pdummy">
        <array zero-terminated="0" c:type="gpointer" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="find_property"
              c:identifier="g_object_class_find_property"
              introspectable="0">
        <doc xml:whitespace="preserve">Looks up the #GParamSpec for a property of a class.
doesn't have a property of that name</doc>
        <return-value>
          <doc xml:whitespace="preserve">the #GParamSpec for the property, or %NULL if the class</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the property to look up</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="install_properties"
              c:identifier="g_object_class_install_properties"
              version="2.26">
        <doc xml:whitespace="preserve">Installs new properties from an array of #GParamSpec&lt;!-- --&gt;s. This is
usually done in the class initializer.
The property id of each property is the index of each #GParamSpec in
the @pspecs array.
The property id of 0 is treated specially by #GObject and it should not
be used to store a #GParamSpec.
This function should be used if you plan to use a static array of
#GParamSpec&lt;!-- --&gt;s and g_object_notify_pspec(). For instance, this
class initialization:
|[
enum {
PROP_0, PROP_FOO, PROP_BAR, N_PROPERTIES
};
static GParamSpec *obj_properties[N_PROPERTIES] = { NULL, };
static void
my_object_class_init (MyObjectClass *klass)
{
GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
obj_properties[PROP_FOO] =
g_param_spec_int ("foo", "Foo", "Foo",
-1, G_MAXINT,
0,
G_PARAM_READWRITE);
obj_properties[PROP_BAR] =
g_param_spec_string ("bar", "Bar", "Bar",
NULL,
G_PARAM_READWRITE);
gobject_class-&gt;set_property = my_object_set_property;
gobject_class-&gt;get_property = my_object_get_property;
g_object_class_install_properties (gobject_class,
N_PROPERTIES,
obj_properties);
}
]|
allows calling g_object_notify_by_pspec() to notify of property changes:
|[
void
my_object_set_foo (MyObject *self, gint foo)
{
if (self-&gt;foo != foo)
{
self-&gt;foo = foo;
g_object_notify_by_pspec (G_OBJECT (self), obj_properties[PROP_FOO]);
}
}
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_pspecs" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of the #GParamSpec&lt;!-- --&gt;s array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="pspecs" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GParamSpec&lt;!-- --&gt;s array defining the new properties</doc>
            <array length="0" c:type="GParamSpec**">
              <type name="ParamSpec"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="install_property"
              c:identifier="g_object_class_install_property">
        <doc xml:whitespace="preserve">Installs a new property. This is usually done in the class initializer.
Note that it is possible to redefine a property in a derived class,
by installing a property with the same name. This can be useful at times,
e.g. to change the range of allowed values or the default value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="property_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id for the new property</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_properties"
              c:identifier="g_object_class_list_properties">
        <doc xml:whitespace="preserve">Get an array of #GParamSpec* for all properties of a class.
#GParamSpec* which should be freed after use</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">an array of</doc>
          <array length="0" c:type="GParamSpec**">
            <type name="ParamSpec"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="n_properties"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the length of the returned array</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="override_property"
              c:identifier="g_object_class_override_property"
              version="2.4">
        <doc xml:whitespace="preserve">Registers @property_id as referring to a property with the
name @name in a parent class or in an interface implemented
by @oclass. This allows this class to &lt;firstterm&gt;override&lt;/firstterm&gt;
a property implementation in a parent class or to provide
the implementation of a property from an interface.
&lt;note&gt;
Internally, overriding is implemented by creating a property of type
#GParamSpecOverride; generally operations that query the properties of
the object class, such as g_object_class_find_property() or
g_object_class_list_properties() will return the overridden
property. However, in one case, the @construct_properties argument of
the @constructor virtual function, the #GParamSpecOverride is passed
instead, so that the @param_id field of the #GParamSpec will be
correct.  For virtually all uses, this makes no difference. If you
need to get the overridden property, you can call
g_param_spec_get_redirect_target().
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="property_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new property ID</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a property registered in a parent class or in an interface of this class.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ObjectConstructParam" c:type="GObjectConstructParam">
      <doc xml:whitespace="preserve">The &lt;structname&gt;GObjectConstructParam&lt;/structname&gt; struct is an auxiliary 
structure used to hand #GParamSpec/#GValue pairs to the @constructor of
a #GObjectClass.</doc>
      <field name="pspec" writable="1">
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </field>
      <field name="value" writable="1">
        <type name="Value" c:type="GValue*"/>
      </field>
    </record>
    <callback name="ObjectFinalizeFunc" c:type="GObjectFinalizeFunc">
      <doc xml:whitespace="preserve">The type of the @finalize function of #GObjectClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GObject being finalized</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ObjectGetPropertyFunc" c:type="GObjectGetPropertyFunc">
      <doc xml:whitespace="preserve">The type of the @get_property function of #GObjectClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GObject</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
        <parameter name="property_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numeric id under which the property was registered with g_object_class_install_property().</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue to return the property value in</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GParamSpec describing the property</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ObjectSetPropertyFunc" c:type="GObjectSetPropertyFunc">
      <doc xml:whitespace="preserve">The type of the @set_property function of #GObjectClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GObject</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
        <parameter name="property_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numeric id under which the property was registered with g_object_class_install_property().</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new value for the property</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GParamSpec describing the property</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="PARAM_MASK" value="255">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_READWRITE" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_STATIC_STRINGS" value="0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_USER_SHIFT" value="8">
      <type name="gint" c:type="gint"/>
    </constant>
    <bitfield name="ParamFlags" c:type="GParamFlags">
      <doc xml:whitespace="preserve">Through the #GParamFlags flag values, certain aspects of parameters
can be configured.</doc>
      <member name="readable" value="1" c:identifier="G_PARAM_READABLE"/>
      <member name="writable" value="2" c:identifier="G_PARAM_WRITABLE"/>
      <member name="construct" value="4" c:identifier="G_PARAM_CONSTRUCT"/>
      <member name="construct_only"
              value="8"
              c:identifier="G_PARAM_CONSTRUCT_ONLY"/>
      <member name="lax_validation"
              value="16"
              c:identifier="G_PARAM_LAX_VALIDATION"/>
      <member name="static_name"
              value="32"
              c:identifier="G_PARAM_STATIC_NAME"/>
      <member name="private" value="32" c:identifier="G_PARAM_PRIVATE"/>
      <member name="static_nick"
              value="64"
              c:identifier="G_PARAM_STATIC_NICK"/>
      <member name="static_blurb"
              value="128"
              c:identifier="G_PARAM_STATIC_BLURB"/>
      <member name="deprecated"
              value="-2147483648"
              c:identifier="G_PARAM_DEPRECATED"/>
    </bitfield>
    <record name="ParamSpec" c:type="GParamSpec">
      <doc xml:whitespace="preserve">All other fields of the &lt;structname&gt;GParamSpec&lt;/structname&gt; struct are private and
should not be used directly.</doc>
      <field name="g_type_instance" writable="1">
        <type name="TypeInstance" c:type="GTypeInstance"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="flags" writable="1">
        <type name="ParamFlags" c:type="GParamFlags"/>
      </field>
      <field name="value_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="owner_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="_nick" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="_blurb" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="qdata" writable="1">
        <type name="GLib.Data" c:type="GData*"/>
      </field>
      <field name="ref_count" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="param_id" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="get_blurb" c:identifier="g_param_spec_get_blurb">
        <doc xml:whitespace="preserve">Get the short description of a #GParamSpec.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the short description of @pspec.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_name" c:identifier="g_param_spec_get_name">
        <doc xml:whitespace="preserve">Get the name of a #GParamSpec.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of @pspec.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_nick" c:identifier="g_param_spec_get_nick">
        <doc xml:whitespace="preserve">Get the nickname of a #GParamSpec.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the nickname of @pspec.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_qdata"
              c:identifier="g_param_spec_get_qdata"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets back user data pointers stored via g_param_spec_set_qdata().</doc>
        <return-value>
          <doc xml:whitespace="preserve">the user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_redirect_target"
              c:identifier="g_param_spec_get_redirect_target"
              version="2.4"
              introspectable="0">
        <doc xml:whitespace="preserve">If the paramspec redirects operations to another paramspec,
returns that paramspec. Redirect is used typically for
providing a new implementation of a property in a derived
type while preserving all the properties from the parent
type. Redirection is established by creating a property
of type #GParamSpecOverride. See g_object_class_override_property()
for an example of the use of this capability.
be redirected, or %NULL if none.</doc>
        <return-value>
          <doc xml:whitespace="preserve">paramspec to which requests on this paramspec should</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="g_param_spec_ref" introspectable="0">
        <doc xml:whitespace="preserve">Increments the reference count of @pspec.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the #GParamSpec that was passed into this function</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
      </method>
      <method name="ref_sink"
              c:identifier="g_param_spec_ref_sink"
              version="2.10"
              introspectable="0">
        <doc xml:whitespace="preserve">Convenience function to ref and sink a #GParamSpec.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the #GParamSpec that was passed into this function</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
      </method>
      <method name="set_qdata" c:identifier="g_param_spec_set_qdata">
        <doc xml:whitespace="preserve">Sets an opaque, named pointer on a #GParamSpec. The name is
specified through a #GQuark (retrieved e.g. via
g_quark_from_static_string()), and the pointer can be gotten back
from the @pspec with g_param_spec_get_qdata().  Setting a
previously set user data pointer, overrides (frees) the old pointer
set, using %NULL as pointer essentially removes the data stored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">an opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qdata_full" c:identifier="g_param_spec_set_qdata_full">
        <doc xml:whitespace="preserve">This function works like g_param_spec_set_qdata(), but in addition,
a &lt;literal&gt;void (*destroy) (gpointer)&lt;/literal&gt; function may be
specified which is called with @data as argument when the @pspec is
finalized, or the data is being overwritten by a call to
g_param_spec_set_qdata() with the same @quark.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">an opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">function to invoke with @data as argument, when @data needs to be freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="sink" c:identifier="g_param_spec_sink">
        <doc xml:whitespace="preserve">The initial reference count of a newly created #GParamSpec is 1,
even though no one has explicitly called g_param_spec_ref() on it
yet. So the initial reference count is flagged as "floating", until
someone calls &lt;literal&gt;g_param_spec_ref (pspec); g_param_spec_sink
(pspec);&lt;/literal&gt; in sequence on it, taking over the initial
reference count (thus ending up with a @pspec that has a reference
count of 1 still, but is not flagged "floating" anymore).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="steal_qdata"
              c:identifier="g_param_spec_steal_qdata"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets back user data pointers stored via g_param_spec_set_qdata()
and removes the @data from @pspec without invoking its destroy()
function (if any was set).  Usually, calling this function is only
required to update user data pointers with a destroy notifier.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_param_spec_unref">
        <doc xml:whitespace="preserve">Decrements the reference count of a @pspec.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="ParamSpecBoolean" c:type="GParamSpecBoolean">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for boolean properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="default_value" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </record>
    <record name="ParamSpecBoxed" c:type="GParamSpecBoxed">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for boxed properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
    </record>
    <record name="ParamSpecChar" c:type="GParamSpecChar">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for character properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum" writable="1">
        <type name="gint8" c:type="gint8"/>
      </field>
      <field name="maximum" writable="1">
        <type name="gint8" c:type="gint8"/>
      </field>
      <field name="default_value" writable="1">
        <type name="gint8" c:type="gint8"/>
      </field>
    </record>
    <record name="ParamSpecClass" c:type="GParamSpecClass">
      <doc xml:whitespace="preserve">The class structure for the &lt;structname&gt;GParamSpec&lt;/structname&gt; type.
Normally, &lt;structname&gt;GParamSpec&lt;/structname&gt; classes are filled by
g_param_type_register_static().</doc>
      <field name="g_type_class" writable="1">
        <type name="TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="value_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="finalize">
        <callback name="finalize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_set_default">
        <callback name="value_set_default">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_validate">
        <callback name="value_validate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="values_cmp">
        <callback name="values_cmp">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value1" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="value2" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dummy" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ParamSpecDouble" c:type="GParamSpecDouble">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for double properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="maximum" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="default_value" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="epsilon" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
    </record>
    <record name="ParamSpecEnum" c:type="GParamSpecEnum">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for enum 
properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="enum_class" writable="1">
        <type name="EnumClass" c:type="GEnumClass*"/>
      </field>
      <field name="default_value" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
    </record>
    <record name="ParamSpecFlags" c:type="GParamSpecFlags">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for flags
properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="flags_class" writable="1">
        <type name="FlagsClass" c:type="GFlagsClass*"/>
      </field>
      <field name="default_value" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="ParamSpecFloat" c:type="GParamSpecFloat">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for float properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum" writable="1">
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <field name="maximum" writable="1">
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <field name="default_value" writable="1">
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <field name="epsilon" writable="1">
        <type name="gfloat" c:type="gfloat"/>
      </field>
    </record>
    <record name="ParamSpecGType" c:type="GParamSpecGType" version="2.10">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for #GType properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="is_a_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
    </record>
    <record name="ParamSpecInt" c:type="GParamSpecInt">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for integer properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="maximum" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="default_value" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
    </record>
    <record name="ParamSpecInt64" c:type="GParamSpecInt64">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for 64bit integer properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="maximum" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="default_value" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
    </record>
    <record name="ParamSpecLong" c:type="GParamSpecLong">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for long integer properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum" writable="1">
        <type name="glong" c:type="glong"/>
      </field>
      <field name="maximum" writable="1">
        <type name="glong" c:type="glong"/>
      </field>
      <field name="default_value" writable="1">
        <type name="glong" c:type="glong"/>
      </field>
    </record>
    <record name="ParamSpecObject" c:type="GParamSpecObject">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for object properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
    </record>
    <record name="ParamSpecOverride" c:type="GParamSpecOverride" version="2.4">
      <doc xml:whitespace="preserve">This is a type of #GParamSpec type that simply redirects operations to
another paramspec.  All operations other than getting or
setting the value are redirected, including accessing the nick and
blurb, validating a value, and so forth. See
g_param_spec_get_redirect_target() for retrieving the overidden
property. #GParamSpecOverride is used in implementing
g_object_class_override_property(), and will not be directly useful
unless you are implementing a new base type similar to GObject.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="overridden" writable="1">
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </field>
    </record>
    <record name="ParamSpecParam" c:type="GParamSpecParam">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM
properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
    </record>
    <record name="ParamSpecPointer" c:type="GParamSpecPointer">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for pointer properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
    </record>
    <record name="ParamSpecPool" c:type="GParamSpecPool" disguised="1">
      <doc xml:whitespace="preserve">A #GParamSpecPool maintains a collection of #GParamSpec&lt;!-- --&gt;s which can be
quickly accessed by owner and name. The implementation of the #GObject property
system uses such a pool to store the #GParamSpecs of the properties all object
types.</doc>
      <method name="insert" c:identifier="g_param_spec_pool_insert">
        <doc xml:whitespace="preserve">Inserts a #GParamSpec in the pool.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GParamSpec to insert</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="owner_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GType identifying the owner of @pspec</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="list"
              c:identifier="g_param_spec_pool_list"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets an array of all #GParamSpec&lt;!-- --&gt;s owned by @owner_type in
the pool.
#GParamSpec&lt;!-- --&gt;s owned by @owner_type in the pool</doc>
        <return-value>
          <doc xml:whitespace="preserve">a newly allocated array containing pointers to all</doc>
          <type name="ParamSpec" c:type="GParamSpec**"/>
        </return-value>
        <parameters>
          <parameter name="owner_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the owner to look for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_pspecs_p" transfer-ownership="none">
            <doc xml:whitespace="preserve">return location for the length of the returned array</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_owned"
              c:identifier="g_param_spec_pool_list_owned"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets an #GList of all #GParamSpec&lt;!-- --&gt;s owned by @owner_type in
the pool.
in the pool#GParamSpec&lt;!-- --&gt;s.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a #GList of all #GParamSpec&lt;!-- --&gt;s owned by @owner_type</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="owner_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the owner to look for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup"
              c:identifier="g_param_spec_pool_lookup"
              introspectable="0">
        <doc xml:whitespace="preserve">Looks up a #GParamSpec in the pool.</doc>
        <return-value>
          <doc xml:whitespace="preserve">The found #GParamSpec, or %NULL if no matching #GParamSpec was found.</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <parameter name="param_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name to look for</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="owner_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the owner to look for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="walk_ancestors" transfer-ownership="none">
            <doc xml:whitespace="preserve">If %TRUE, also try to find a #GParamSpec with @param_name owned by an ancestor of @owner_type.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_param_spec_pool_remove">
        <doc xml:whitespace="preserve">Removes a #GParamSpec from the pool.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GParamSpec to remove</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ParamSpecString" c:type="GParamSpecString">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for string
properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="default_value" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="cset_first" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="cset_nth" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="substitutor" writable="1">
        <type name="gchar" c:type="gchar"/>
      </field>
      <field name="null_fold_if_empty" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="ensure_non_null" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="ParamSpecTypeInfo" c:type="GParamSpecTypeInfo">
      <doc xml:whitespace="preserve">This structure is used to provide the type system with the information
required to initialize and destruct (finalize) a parameter's class and
instances thereof.
The initialized structure is passed to the g_param_type_register_static() 
The type system will perform a deep copy of this structure, so its memory 
does not need to be persistent across invocation of 
g_param_type_register_static().</doc>
      <field name="instance_size" writable="1">
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="n_preallocs" writable="1">
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="instance_init">
        <callback name="instance_init">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="finalize">
        <callback name="finalize">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_set_default">
        <callback name="value_set_default">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_validate">
        <callback name="value_validate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="values_cmp">
        <callback name="values_cmp">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none">
              <type name="ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="value1" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="value2" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="ParamSpecUChar" c:type="GParamSpecUChar">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for unsigned character properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="maximum" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="default_value" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
    </record>
    <record name="ParamSpecUInt" c:type="GParamSpecUInt">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for unsigned integer properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="maximum" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="default_value" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="ParamSpecUInt64" c:type="GParamSpecUInt64">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="maximum" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="default_value" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
    </record>
    <record name="ParamSpecULong" c:type="GParamSpecULong">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for unsigned long integer properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="minimum" writable="1">
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="maximum" writable="1">
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="default_value" writable="1">
        <type name="gulong" c:type="gulong"/>
      </field>
    </record>
    <record name="ParamSpecUnichar" c:type="GParamSpecUnichar">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="default_value" introspectable="0" writable="1">
        <type name="gunichar" c:type="gunichar"/>
      </field>
    </record>
    <record name="ParamSpecValueArray" c:type="GParamSpecValueArray">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for #GValueArray properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="element_spec" writable="1">
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </field>
      <field name="fixed_n_elements" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="ParamSpecVariant" c:type="GParamSpecVariant" version="2.26">
      <doc xml:whitespace="preserve">A #GParamSpec derived structure that contains the meta data for #GVariant properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="type" writable="1">
        <type name="GLib.VariantType" c:type="GVariantType*"/>
      </field>
      <field name="default_value" writable="1">
        <type name="GLib.Variant" c:type="GVariant*"/>
      </field>
      <field name="padding" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="Parameter" c:type="GParameter">
      <doc xml:whitespace="preserve">The &lt;structname&gt;GParameter&lt;/structname&gt; struct is an auxiliary structure used
to hand parameter name/value pairs to g_object_newv().</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="value" writable="1">
        <type name="Value" c:type="GValue"/>
      </field>
    </record>
    <glib:boxed glib:name="PtrArray"
                c:symbol-prefix="ptr_array"
                glib:type-name="GPtrArray"
                glib:get-type="g_ptr_array_get_type">
    </glib:boxed>
    <glib:boxed glib:name="Regex"
                c:symbol-prefix="regex"
                glib:type-name="GRegex"
                glib:get-type="g_regex_get_type">
    </glib:boxed>
    <constant name="SIGNAL_FLAGS_MASK" value="127">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SIGNAL_MATCH_MASK" value="63">
      <type name="gint" c:type="gint"/>
    </constant>
    <callback name="SignalAccumulator" c:type="GSignalAccumulator">
      <doc xml:whitespace="preserve">The signal accumulator is a special callback function that can be used
to collect return values of the various callbacks that are called
during a signal emission. The signal accumulator is specified at signal
creation time, if it is left %NULL, no accumulation of callback return
values is performed. The return value of signal emissions is then the
value returned by the last callback.
should be aborted. Returning %FALSE means to abort the
current emission and %TRUE is returned for continuation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The accumulator function returns whether the signal emission</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ihint" transfer-ownership="none">
          <doc xml:whitespace="preserve">Signal invocation hint, see #GSignalInvocationHint.</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*"/>
        </parameter>
        <parameter name="return_accu" transfer-ownership="none">
          <doc xml:whitespace="preserve">Accumulator to collect callback return values in, this is the return value of the current signal emission.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="handler_return" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GValue holding the return value of the signal handler.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Callback data that was specified when creating the signal.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SignalEmissionHook" c:type="GSignalEmissionHook">
      <doc xml:whitespace="preserve">A simple function pointer to get invoked when the signal is emitted. This 
allows you to tie a hook to the signal type, so that it will trap all 
emissions of that signal, from any object.
You may not attach these to signals created with the #G_SIGNAL_NO_HOOKS flag.
hook is disconnected (and destroyed).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">whether it wants to stay connected. If it returns %FALSE, the signal</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ihint" transfer-ownership="none">
          <doc xml:whitespace="preserve">Signal invocation hint, see #GSignalInvocationHint.</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of parameters to the function, including the instance on which the signal was emitted.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance on which the signal was emitted, followed by the parameters of the emission.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data associated with the hook.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="SignalFlags" c:type="GSignalFlags">
      <doc xml:whitespace="preserve">The signal flags are used to specify a signal's behaviour, the overall
signal description outlines how especially the RUN flags control the
stages of a signal emission.</doc>
      <member name="run_first" value="1" c:identifier="G_SIGNAL_RUN_FIRST"/>
      <member name="run_last" value="2" c:identifier="G_SIGNAL_RUN_LAST"/>
      <member name="run_cleanup"
              value="4"
              c:identifier="G_SIGNAL_RUN_CLEANUP"/>
      <member name="no_recurse" value="8" c:identifier="G_SIGNAL_NO_RECURSE"/>
      <member name="detailed" value="16" c:identifier="G_SIGNAL_DETAILED"/>
      <member name="action" value="32" c:identifier="G_SIGNAL_ACTION"/>
      <member name="no_hooks" value="64" c:identifier="G_SIGNAL_NO_HOOKS"/>
    </bitfield>
    <record name="SignalInvocationHint" c:type="GSignalInvocationHint">
      <doc xml:whitespace="preserve">The #GSignalInvocationHint structure is used to pass on additional information
to callbacks during a signal emission.</doc>
      <field name="signal_id" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="detail" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="run_type" writable="1">
        <type name="SignalFlags" c:type="GSignalFlags"/>
      </field>
    </record>
    <bitfield name="SignalMatchType" c:type="GSignalMatchType">
      <doc xml:whitespace="preserve">The match types specify what g_signal_handlers_block_matched(),
g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
match signals by.</doc>
      <member name="id" value="1" c:identifier="G_SIGNAL_MATCH_ID"/>
      <member name="detail" value="2" c:identifier="G_SIGNAL_MATCH_DETAIL"/>
      <member name="closure" value="4" c:identifier="G_SIGNAL_MATCH_CLOSURE"/>
      <member name="func" value="8" c:identifier="G_SIGNAL_MATCH_FUNC"/>
      <member name="data" value="16" c:identifier="G_SIGNAL_MATCH_DATA"/>
      <member name="unblocked"
              value="32"
              c:identifier="G_SIGNAL_MATCH_UNBLOCKED"/>
    </bitfield>
    <record name="SignalQuery" c:type="GSignalQuery">
      <doc xml:whitespace="preserve">A structure holding in-depth information for a specific signal. It is
filled in by the g_signal_query() function.</doc>
      <field name="signal_id" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="signal_name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="itype" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="signal_flags" writable="1">
        <type name="SignalFlags" c:type="GSignalFlags"/>
      </field>
      <field name="return_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="n_params" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="param_types" writable="1">
        <type name="GType" c:type="GType*"/>
      </field>
    </record>
    <glib:boxed glib:name="String"
                c:symbol-prefix="gstring"
                glib:type-name="GString"
                glib:get-type="g_gstring_get_type">
    </glib:boxed>
    <constant name="TYPE_FUNDAMENTAL_MAX" value="255">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TYPE_FUNDAMENTAL_SHIFT" value="2">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TYPE_RESERVED_BSE_FIRST" value="32">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TYPE_RESERVED_BSE_LAST" value="48">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TYPE_RESERVED_GLIB_FIRST" value="22">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TYPE_RESERVED_GLIB_LAST" value="31">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TYPE_RESERVED_USER_FIRST" value="49">
      <type name="gint" c:type="gint"/>
    </constant>
    <callback name="ToggleNotify" c:type="GToggleNotify">
      <doc xml:whitespace="preserve">A callback function used for notification when the state
of a toggle reference changes. See g_object_add_toggle_ref().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Callback data passed to g_object_add_toggle_ref()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The object on which g_object_add_toggle_ref() was called.</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
        <parameter name="is_last_ref" transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the toggle reference is now the last reference to the object. %FALSE if the toggle reference was the last reference and there are now other references.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </callback>
    <union name="TypeCValue" c:type="GTypeCValue">
      <doc xml:whitespace="preserve">A union holding one collected value.</doc>
      <field name="v_int" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="v_long" writable="1">
        <type name="glong" c:type="glong"/>
      </field>
      <field name="v_int64" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="v_double" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="v_pointer" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </union>
    <record name="TypeClass" c:type="GTypeClass">
      <doc xml:whitespace="preserve">An opaque structure used as the base of all classes.</doc>
      <field name="g_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <method name="get_private"
              c:identifier="g_type_class_get_private"
              introspectable="0">
        <return-value>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="private_type" transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="TypeClassCacheFunc" c:type="GTypeClassCacheFunc">
      <doc xml:whitespace="preserve">A callback function which is called when the reference count of a class 
drops to zero. It may use g_type_class_ref() to prevent the class from
being freed. You should not call g_type_class_unref() from a 
#GTypeClassCacheFunc function to prevent infinite recursion, use 
g_type_class_unref_uncached() instead.
The functions have to check the class id passed in to figure 
whether they actually want to cache the class of this type, since all
classes are routed through the same #GTypeClassCacheFunc chain.
called, %FALSE to continue.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE to stop further #GTypeClassCacheFunc&lt;!-- --&gt;s from being</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="cache_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data that was given to the g_type_add_class_cache_func() call</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypeClass structure which is unreferenced</doc>
          <type name="TypeClass" c:type="GTypeClass*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="TypeDebugFlags" c:type="GTypeDebugFlags">
      <doc xml:whitespace="preserve">The &lt;type&gt;GTypeDebugFlags&lt;/type&gt; enumeration values can be passed to
g_type_init_with_debug_flags() to trigger debugging messages during runtime.
Note that the messages can also be triggered by setting the
&lt;envar&gt;GOBJECT_DEBUG&lt;/envar&gt; environment variable to a ':'-separated list of 
"objects" and "signals".</doc>
      <member name="none" value="0" c:identifier="G_TYPE_DEBUG_NONE"/>
      <member name="objects" value="1" c:identifier="G_TYPE_DEBUG_OBJECTS"/>
      <member name="signals" value="2" c:identifier="G_TYPE_DEBUG_SIGNALS"/>
      <member name="mask" value="3" c:identifier="G_TYPE_DEBUG_MASK"/>
    </bitfield>
    <bitfield name="TypeFlags" c:type="GTypeFlags">
      <doc xml:whitespace="preserve">Bit masks used to check or determine characteristics of a type.</doc>
      <member name="abstract" value="16" c:identifier="G_TYPE_FLAG_ABSTRACT"/>
      <member name="value_abstract"
              value="32"
              c:identifier="G_TYPE_FLAG_VALUE_ABSTRACT"/>
    </bitfield>
    <bitfield name="TypeFundamentalFlags" c:type="GTypeFundamentalFlags">
      <doc xml:whitespace="preserve">Bit masks used to check or determine specific characteristics of a
fundamental type.</doc>
      <member name="classed" value="1" c:identifier="G_TYPE_FLAG_CLASSED"/>
      <member name="instantiatable"
              value="2"
              c:identifier="G_TYPE_FLAG_INSTANTIATABLE"/>
      <member name="derivable" value="4" c:identifier="G_TYPE_FLAG_DERIVABLE"/>
      <member name="deep_derivable"
              value="8"
              c:identifier="G_TYPE_FLAG_DEEP_DERIVABLE"/>
    </bitfield>
    <record name="TypeFundamentalInfo" c:type="GTypeFundamentalInfo">
      <doc xml:whitespace="preserve">A structure that provides information to the type system which is
used specifically for managing fundamental types.</doc>
      <field name="type_flags" writable="1">
        <type name="TypeFundamentalFlags" c:type="GTypeFundamentalFlags"/>
      </field>
    </record>
    <record name="TypeInfo" c:type="GTypeInfo">
      <doc xml:whitespace="preserve">This structure is used to provide the type system with the information
required to initialize and destruct (finalize) a type's class and
its instances.
The initialized structure is passed to the g_type_register_static() function
(or is copied into the provided #GTypeInfo structure in the
g_type_plugin_complete_type_info()). The type system will perform a deep
copy of this structure, so its memory does not need to be persistent
across invocation of g_type_register_static().</doc>
      <field name="class_size" writable="1">
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="base_init" writable="1">
        <type name="BaseInitFunc" c:type="GBaseInitFunc"/>
      </field>
      <field name="base_finalize" writable="1">
        <type name="BaseFinalizeFunc" c:type="GBaseFinalizeFunc"/>
      </field>
      <field name="class_init" writable="1">
        <type name="ClassInitFunc" c:type="GClassInitFunc"/>
      </field>
      <field name="class_finalize" writable="1">
        <type name="ClassFinalizeFunc" c:type="GClassFinalizeFunc"/>
      </field>
      <field name="class_data" writable="1">
        <type name="gpointer" c:type="gconstpointer"/>
      </field>
      <field name="instance_size" writable="1">
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="n_preallocs" writable="1">
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="instance_init" writable="1">
        <type name="InstanceInitFunc" c:type="GInstanceInitFunc"/>
      </field>
      <field name="value_table" writable="1">
        <type name="TypeValueTable" c:type="GTypeValueTable*"/>
      </field>
    </record>
    <record name="TypeInstance" c:type="GTypeInstance">
      <doc xml:whitespace="preserve">An opaque structure used as the base of all type instances.</doc>
      <field name="g_class" writable="1">
        <type name="TypeClass" c:type="GTypeClass*"/>
      </field>
      <method name="get_private"
              c:identifier="g_type_instance_get_private"
              introspectable="0">
        <return-value>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="private_type" transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="TypeInterface" c:type="GTypeInterface">
      <doc xml:whitespace="preserve">An opaque structure used as the base of all interface types.</doc>
      <field name="g_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="g_instance_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
    </record>
    <callback name="TypeInterfaceCheckFunc"
              c:type="GTypeInterfaceCheckFunc"
              version="2.4">
      <doc xml:whitespace="preserve">A callback called after an interface vtable is initialized.
See g_type_add_interface_check().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="check_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data passed to g_type_add_interface_check().</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface that has been initialized</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="TypeModule"
           c:symbol-prefix="type_module"
           c:type="GTypeModule"
           parent="Object"
           abstract="1"
           glib:type-name="GTypeModule"
           glib:get-type="g_type_module_get_type"
           glib:type-struct="TypeModuleClass">
      <doc xml:whitespace="preserve">The members of the &lt;structname&gt;GTypeModule&lt;/structname&gt; structure should not 
be accessed directly, except for the @name field.</doc>
      <implements name="TypePlugin"/>
      <virtual-method name="load">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unload">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <method name="add_interface" c:identifier="g_type_module_add_interface">
        <doc xml:whitespace="preserve">Registers an additional interface for a type, whose interface lives
in the given type plugin. If the interface was already registered
for the type in this plugin, nothing will be done.
As long as any instances of the type exist, the type plugin will
not be unloaded.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="instance_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">type to which to add the interface.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="interface_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">interface type to add</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="interface_info" transfer-ownership="none">
            <doc xml:whitespace="preserve">type information structure</doc>
            <type name="InterfaceInfo" c:type="GInterfaceInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_enum"
              c:identifier="g_type_module_register_enum"
              version="2.6">
        <doc xml:whitespace="preserve">Looks up or registers an enumeration that is implemented with a particular
type plugin. If a type with name @type_name was previously registered,
the #GType identifier for the type is returned, otherwise the type
is newly registered, and the resulting #GType identifier returned.
As long as any instances of the type exist, the type plugin will
not be unloaded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the new or existing type ID</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name for the type</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="const_static_values" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of #GEnumValue structs for the possible enumeration values. The array is terminated by a struct with all members being 0.</doc>
            <type name="EnumValue" c:type="GEnumValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_flags"
              c:identifier="g_type_module_register_flags"
              version="2.6">
        <doc xml:whitespace="preserve">Looks up or registers a flags type that is implemented with a particular
type plugin. If a type with name @type_name was previously registered,
the #GType identifier for the type is returned, otherwise the type
is newly registered, and the resulting #GType identifier returned.
As long as any instances of the type exist, the type plugin will
not be unloaded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the new or existing type ID</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name for the type</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="const_static_values" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of #GFlagsValue structs for the possible flags values. The array is terminated by a struct with all members being 0.</doc>
            <type name="FlagsValue" c:type="GFlagsValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_type" c:identifier="g_type_module_register_type">
        <doc xml:whitespace="preserve">Looks up or registers a type that is implemented with a particular
type plugin. If a type with name @type_name was previously registered,
the #GType identifier for the type is returned, otherwise the type
is newly registered, and the resulting #GType identifier returned.
When reregistering a type (typically because a module is unloaded
then reloaded, and reinitialized), @module and @parent_type must
be the same as they were previously.
As long as any instances of the type exist, the type plugin will
not be unloaded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the new or existing type ID</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="parent_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type for the parent class</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="type_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name for the type</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="type_info" transfer-ownership="none">
            <doc xml:whitespace="preserve">type information structure</doc>
            <type name="TypeInfo" c:type="GTypeInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags field providing details about the type</doc>
            <type name="TypeFlags" c:type="GTypeFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="g_type_module_set_name">
        <doc xml:whitespace="preserve">Sets the name for a #GTypeModule</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a human-readable name to use in error messages.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unuse" c:identifier="g_type_module_unuse">
        <doc xml:whitespace="preserve">Decreases the use count of a #GTypeModule by one. If the
result is zero, the module will be unloaded. (However, the
#GTypeModule will not be freed, and types associated with the
#GTypeModule are not unregistered. Once a #GTypeModule is
initialized, it must exist forever.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="use" c:identifier="g_type_module_use">
        <doc xml:whitespace="preserve">Increases the use count of a #GTypeModule by one. If the
use count was zero before, the plugin will be loaded.
If loading the plugin fails, the use count is reset to
its prior value.
loading the plugin failed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE if the plugin needed to be loaded and</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <field name="parent_instance">
        <type name="Object" c:type="GObject"/>
      </field>
      <field name="use_count">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="type_infos">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="interface_infos">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="name">
        <type name="utf8" c:type="gchar*"/>
      </field>
    </class>
    <record name="TypeModuleClass"
            c:type="GTypeModuleClass"
            glib:is-gtype-struct-for="TypeModule">
      <doc xml:whitespace="preserve">In order to implement dynamic loading of types based on #GTypeModule, 
the @load and @unload functions in #GTypeModuleClass must be implemented.</doc>
      <field name="parent_class">
        <type name="ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="load">
        <callback name="load">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="module" transfer-ownership="none">
              <type name="TypeModule" c:type="GTypeModule*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unload">
        <callback name="unload">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="module" transfer-ownership="none">
              <type name="TypeModule" c:type="GTypeModule*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved1">
        <callback name="reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="reserved2">
        <callback name="reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="reserved3">
        <callback name="reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="reserved4">
        <callback name="reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <interface name="TypePlugin"
               c:symbol-prefix="type_plugin"
               c:type="GTypePlugin"
               glib:type-name="GTypePlugin"
               glib:get-type="g_type_plugin_get_type">
      <doc xml:whitespace="preserve">The &lt;structname&gt;GTypePlugin&lt;/structname&gt; typedef is used as a placeholder 
for objects that implement the &lt;structname&gt;GTypePlugin&lt;/structname&gt; 
interface.</doc>
      <method name="complete_interface_info"
              c:identifier="g_type_plugin_complete_interface_info">
        <doc xml:whitespace="preserve">Calls the @complete_interface_info function from the
#GTypePluginClass of @plugin. There should be no need to use this
function outside of the GObject type system itself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="instance_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType of an instantiable type to which the interface is added</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="interface_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType of the interface whose info is completed</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GInterfaceInfo to fill in</doc>
            <type name="InterfaceInfo" c:type="GInterfaceInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="complete_type_info"
              c:identifier="g_type_plugin_complete_type_info">
        <doc xml:whitespace="preserve">Calls the @complete_type_info function from the #GTypePluginClass of @plugin.
There should be no need to use this function outside of the GObject
type system itself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType whose info is completed</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GTypeInfo struct to fill in</doc>
            <type name="TypeInfo" c:type="GTypeInfo*"/>
          </parameter>
          <parameter name="value_table" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GTypeValueTable to fill in</doc>
            <type name="TypeValueTable" c:type="GTypeValueTable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unuse" c:identifier="g_type_plugin_unuse">
        <doc xml:whitespace="preserve">Calls the @unuse_plugin function from the #GTypePluginClass of
the GObject type system itself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="use" c:identifier="g_type_plugin_use">
        <doc xml:whitespace="preserve">Calls the @use_plugin function from the #GTypePluginClass of
the GObject type system itself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </interface>
    <record name="TypePluginClass" c:type="GTypePluginClass">
      <doc xml:whitespace="preserve">The #GTypePlugin interface is used by the type system in order to handle
the lifecycle of dynamically loaded types.</doc>
      <field name="base_iface" writable="1">
        <type name="TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="use_plugin" writable="1">
        <type name="TypePluginUse" c:type="GTypePluginUse"/>
      </field>
      <field name="unuse_plugin" writable="1">
        <type name="TypePluginUnuse" c:type="GTypePluginUnuse"/>
      </field>
      <field name="complete_type_info" writable="1">
        <type name="TypePluginCompleteTypeInfo"
              c:type="GTypePluginCompleteTypeInfo"/>
      </field>
      <field name="complete_interface_info" writable="1">
        <type name="TypePluginCompleteInterfaceInfo"
              c:type="GTypePluginCompleteInterfaceInfo"/>
      </field>
    </record>
    <callback name="TypePluginCompleteInterfaceInfo"
              c:type="GTypePluginCompleteInterfaceInfo">
      <doc xml:whitespace="preserve">The type of the @complete_interface_info function of #GTypePluginClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType of an instantiable type to which the interface is added</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType of the interface whose info is completed</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GInterfaceInfo to fill in</doc>
          <type name="InterfaceInfo" c:type="GInterfaceInfo*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypePluginCompleteTypeInfo"
              c:type="GTypePluginCompleteTypeInfo">
      <doc xml:whitespace="preserve">The type of the @complete_type_info function of #GTypePluginClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
        <parameter name="g_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType whose info is completed</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GTypeInfo struct to fill in</doc>
          <type name="TypeInfo" c:type="GTypeInfo*"/>
        </parameter>
        <parameter name="value_table" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GTypeValueTable to fill in</doc>
          <type name="TypeValueTable" c:type="GTypeValueTable*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypePluginUnuse" c:type="GTypePluginUnuse">
      <doc xml:whitespace="preserve">The type of the @unuse_plugin function of #GTypePluginClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GTypePlugin whose use count should be decreased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypePluginUse" c:type="GTypePluginUse">
      <doc xml:whitespace="preserve">The type of the @use_plugin function of #GTypePluginClass, which gets called
to increase the use count of @plugin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GTypePlugin whose use count should be increased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TypeQuery" c:type="GTypeQuery">
      <doc xml:whitespace="preserve">A structure holding information for a specific type. It is
filled in by the g_type_query() function.</doc>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="type_name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="class_size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="instance_size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="TypeValueTable" c:type="GTypeValueTable">
      <doc xml:whitespace="preserve">The #GTypeValueTable provides the functions required by the #GValue implementation,
to serve as a container for values of a type.</doc>
      <field name="value_init">
        <callback name="value_init">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_free">
        <callback name="value_free">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_copy">
        <callback name="value_copy">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src_value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="dest_value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="value_peek_pointer" introspectable="0">
        <callback name="value_peek_pointer" introspectable="0">
          <return-value>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="collect_format" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="collect_value">
        <callback name="collect_value">
          <return-value transfer-ownership="full">
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="n_collect_values" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="collect_values" transfer-ownership="none">
              <type name="TypeCValue" c:type="GTypeCValue*"/>
            </parameter>
            <parameter name="collect_flags" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lcopy_format" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="lcopy_value">
        <callback name="lcopy_value">
          <return-value transfer-ownership="full">
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="GValue*"/>
            </parameter>
            <parameter name="n_collect_values" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="collect_values" transfer-ownership="none">
              <type name="TypeCValue" c:type="GTypeCValue*"/>
            </parameter>
            <parameter name="collect_flags" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <constant name="VALUE_COLLECT_FORMAT_MAX_LENGTH" value="8">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VALUE_NOCOPY_CONTENTS" value="134217728">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Value"
            c:type="GValue"
            glib:type-name="GValue"
            glib:get-type="g_value_get_type"
            c:symbol-prefix="value">
      <doc xml:whitespace="preserve">An opaque structure used to hold different types of values.
to functions within a #GTypeValueTable structure, or implementations of
the g_value_*() API. That is, code portions which implement new fundamental
types.
#GValue users can not make any assumptions about how data is stored
within the 2 element @data union, and the @g_type member should
only be accessed through the G_VALUE_TYPE() macro.</doc>
      <field name="g_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="data" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="copy" c:identifier="g_value_copy">
        <doc xml:whitespace="preserve">Copies the value of @src_value into @dest_value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">An initialized #GValue structure of the same type as @src_value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_boxed"
              c:identifier="g_value_dup_boxed"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_BOXED derived #GValue.  Upon getting,
the boxed value is duplicated and needs to be later freed with
return_value);</doc>
        <return-value>
          <doc xml:whitespace="preserve">boxed contents of @value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="dup_object"
              c:identifier="g_value_dup_object"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_OBJECT derived #GValue, increasing
its reference count.
longer needed.</doc>
        <return-value>
          <doc xml:whitespace="preserve">object content of @value, should be unreferenced when no</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="dup_param"
              c:identifier="g_value_dup_param"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_PARAM #GValue, increasing its
reference count.
no longer needed.</doc>
        <return-value>
          <doc xml:whitespace="preserve">#GParamSpec content of @value, should be unreferenced when</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
      </method>
      <method name="dup_string" c:identifier="g_value_dup_string">
        <doc xml:whitespace="preserve">Get a copy the contents of a %G_TYPE_STRING #GValue.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated copy of the string content of @value</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="dup_variant"
              c:identifier="g_value_dup_variant"
              version="2.26">
        <doc xml:whitespace="preserve">Get the contents of a variant #GValue, increasing its refcount.
g_variant_unref() when no longer needed</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">variant contents of @value, should be unrefed using</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="fits_pointer" c:identifier="g_value_fits_pointer">
        <doc xml:whitespace="preserve">Determines if @value will fit inside the size of a pointer value.
This is an internal function introduced mainly for C marshallers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @value will fit inside a pointer value.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_boolean" c:identifier="g_value_get_boolean">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_BOOLEAN #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">boolean contents of @value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_boxed"
              c:identifier="g_value_get_boxed"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_BOXED derived #GValue.</doc>
        <return-value>
          <doc xml:whitespace="preserve">boxed contents of @value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="get_char" c:identifier="g_value_get_char">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_CHAR #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">character contents of @value</doc>
          <type name="gchar" c:type="gchar"/>
        </return-value>
      </method>
      <method name="get_double" c:identifier="g_value_get_double">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_DOUBLE #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">double contents of @value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
      </method>
      <method name="get_enum" c:identifier="g_value_get_enum">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_ENUM #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">enum contents of @value</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_flags" c:identifier="g_value_get_flags">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_FLAGS #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">flags contents of @value</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_float" c:identifier="g_value_get_float">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_FLOAT #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">float contents of @value</doc>
          <type name="gfloat" c:type="gfloat"/>
        </return-value>
      </method>
      <method name="get_gtype" c:identifier="g_value_get_gtype" version="2.12">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_GTYPE #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType stored in @value</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
      </method>
      <method name="get_int" c:identifier="g_value_get_int">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_INT #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">integer contents of @value</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_int64" c:identifier="g_value_get_int64">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_INT64 #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">64bit integer contents of @value</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_long" c:identifier="g_value_get_long">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_LONG #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">long integer contents of @value</doc>
          <type name="glong" c:type="glong"/>
        </return-value>
      </method>
      <method name="get_object"
              c:identifier="g_value_get_object"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_OBJECT derived #GValue.</doc>
        <return-value>
          <doc xml:whitespace="preserve">object contents of @value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="get_param"
              c:identifier="g_value_get_param"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_PARAM #GValue.</doc>
        <return-value>
          <doc xml:whitespace="preserve">#GParamSpec content of @value</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </return-value>
      </method>
      <method name="get_pointer"
              c:identifier="g_value_get_pointer"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the contents of a pointer #GValue.</doc>
        <return-value>
          <doc xml:whitespace="preserve">pointer contents of @value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="get_string" c:identifier="g_value_get_string">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_STRING #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">string content of @value</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_uchar" c:identifier="g_value_get_uchar">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_UCHAR #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">unsigned character contents of @value</doc>
          <type name="guint8" c:type="guchar"/>
        </return-value>
      </method>
      <method name="get_uint" c:identifier="g_value_get_uint">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_UINT #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">unsigned integer contents of @value</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_uint64" c:identifier="g_value_get_uint64">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_UINT64 #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">unsigned 64bit integer contents of @value</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="get_ulong" c:identifier="g_value_get_ulong">
        <doc xml:whitespace="preserve">Get the contents of a %G_TYPE_ULONG #GValue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">unsigned long integer contents of @value</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
      </method>
      <method name="get_variant"
              c:identifier="g_value_get_variant"
              version="2.26">
        <doc xml:whitespace="preserve">Get the contents of a variant #GValue.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">variant contents of @value</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
      </method>
      <method name="init" c:identifier="g_value_init">
        <doc xml:whitespace="preserve">Initializes @value with the default value of @type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GValue structure that has been passed in</doc>
          <type name="Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <parameter name="g_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">Type the #GValue should hold values of.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_pointer"
              c:identifier="g_value_peek_pointer"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the value contents as pointer. This function asserts that
g_value_fits_pointer() returned %TRUE for the passed in value.
This is an internal function introduced mainly for C marshallers.</doc>
        <return-value>
          <doc xml:whitespace="preserve">%TRUE if @value will fit inside a pointer value.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="reset" c:identifier="g_value_reset">
        <doc xml:whitespace="preserve">Clears the current value in @value and resets it to the default value
(as if the value had just been initialized).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GValue structure that has been passed in</doc>
          <type name="Value" c:type="GValue*"/>
        </return-value>
      </method>
      <method name="set_boolean" c:identifier="g_value_set_boolean">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_BOOLEAN #GValue to @v_boolean.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_boolean" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean value to be set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boxed" c:identifier="g_value_set_boxed">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_boxed" transfer-ownership="none">
            <doc xml:whitespace="preserve">boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boxed_take_ownership"
              c:identifier="g_value_set_boxed_take_ownership"
              deprecated="Use g_value_take_boxed() instead."
              deprecated-version="2.4">
        <doc xml:whitespace="preserve">This is an internal function introduced mainly for C marshallers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_boxed" transfer-ownership="none">
            <doc xml:whitespace="preserve">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_char" c:identifier="g_value_set_char">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_CHAR #GValue to @v_char.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_char" transfer-ownership="none">
            <doc xml:whitespace="preserve">character value to be set</doc>
            <type name="gchar" c:type="gchar"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double" c:identifier="g_value_set_double">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_DOUBLE #GValue to @v_double.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_double" transfer-ownership="none">
            <doc xml:whitespace="preserve">double value to be set</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enum" c:identifier="g_value_set_enum">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_ENUM #GValue to @v_enum.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_enum" transfer-ownership="none">
            <doc xml:whitespace="preserve">enum value to be set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="g_value_set_flags">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_FLAGS #GValue to @v_flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags value to be set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_float" c:identifier="g_value_set_float">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_FLOAT #GValue to @v_float.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_float" transfer-ownership="none">
            <doc xml:whitespace="preserve">float value to be set</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_gtype" c:identifier="g_value_set_gtype" version="2.12">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_GTYPE #GValue to @v_gtype.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_gtype" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GType to be set</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_instance" c:identifier="g_value_set_instance">
        <doc xml:whitespace="preserve">Sets @value from an instantiatable type via the
value_table's collect_value() function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none">
            <doc xml:whitespace="preserve">the instance</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="g_value_set_int">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_INT #GValue to @v_int.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_int" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer value to be set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int64" c:identifier="g_value_set_int64">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_INT64 #GValue to @v_int64.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_int64" transfer-ownership="none">
            <doc xml:whitespace="preserve">64bit integer value to be set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_long" c:identifier="g_value_set_long">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_LONG #GValue to @v_long.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_long" transfer-ownership="none">
            <doc xml:whitespace="preserve">long integer value to be set</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_object" c:identifier="g_value_set_object">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_OBJECT derived #GValue to @v_object.
g_value_set_object() increases the reference count of @v_object
(the #GValue holds a reference to @v_object).  If you do not wish
to increase the reference count of the object (i.e. you wish to
pass your current reference to the #GValue because you no longer
need it), use g_value_take_object() instead.
It is important that your #GValue holds a reference to @v_object (either its
own, or one it has taken) to ensure that the object won't be destroyed while
the #GValue still exists).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">object value to be set</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_object_take_ownership"
              c:identifier="g_value_set_object_take_ownership"
              deprecated="Use g_value_take_object() instead."
              deprecated-version="2.4">
        <doc xml:whitespace="preserve">This is an internal function introduced mainly for C marshallers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">object value to be set</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_param" c:identifier="g_value_set_param">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_PARAM #GValue to @param.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GParamSpec to be set</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_param_take_ownership"
              c:identifier="g_value_set_param_take_ownership"
              deprecated="Use g_value_take_param() instead."
              deprecated-version="2.4">
        <doc xml:whitespace="preserve">This is an internal function introduced mainly for C marshallers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GParamSpec to be set</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pointer" c:identifier="g_value_set_pointer">
        <doc xml:whitespace="preserve">Set the contents of a pointer #GValue to @v_pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_pointer" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer value to be set</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_static_boxed" c:identifier="g_value_set_static_boxed">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed.
The boxed value is assumed to be static, and is thus not duplicated
when setting the #GValue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_boxed" transfer-ownership="none">
            <doc xml:whitespace="preserve">static boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_static_string"
              c:identifier="g_value_set_static_string">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_STRING #GValue to @v_string.
The string is assumed to be static, and is thus not duplicated
when setting the #GValue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_string" transfer-ownership="none">
            <doc xml:whitespace="preserve">static string to be set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="g_value_set_string">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_STRING #GValue to @v_string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_string" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-owned string to be duplicated for the #GValue</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string_take_ownership"
              c:identifier="g_value_set_string_take_ownership"
              deprecated="Use g_value_take_string() instead."
              deprecated-version="2.4">
        <doc xml:whitespace="preserve">This is an internal function introduced mainly for C marshallers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_string" transfer-ownership="none">
            <doc xml:whitespace="preserve">duplicated unowned string to be set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uchar" c:identifier="g_value_set_uchar">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_UCHAR #GValue to @v_uchar.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_uchar" transfer-ownership="none">
            <doc xml:whitespace="preserve">unsigned character value to be set</doc>
            <type name="guint8" c:type="guchar"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint" c:identifier="g_value_set_uint">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_UINT #GValue to @v_uint.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_uint" transfer-ownership="none">
            <doc xml:whitespace="preserve">unsigned integer value to be set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint64" c:identifier="g_value_set_uint64">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_UINT64 #GValue to @v_uint64.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_uint64" transfer-ownership="none">
            <doc xml:whitespace="preserve">unsigned 64bit integer value to be set</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ulong" c:identifier="g_value_set_ulong">
        <doc xml:whitespace="preserve">Set the contents of a %G_TYPE_ULONG #GValue to @v_ulong.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_ulong" transfer-ownership="none">
            <doc xml:whitespace="preserve">unsigned long integer value to be set</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_variant"
              c:identifier="g_value_set_variant"
              version="2.26">
        <doc xml:whitespace="preserve">Set the contents of a variant #GValue to @variant.
If the variant is floating, it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="variant" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_boxed"
              c:identifier="g_value_take_boxed"
              version="2.4">
        <doc xml:whitespace="preserve">Sets the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed
and takes over the ownership of the callers reference to @v_boxed;
the caller doesn't have to unref it any more.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_boxed" transfer-ownership="none">
            <doc xml:whitespace="preserve">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_object"
              c:identifier="g_value_take_object"
              version="2.4">
        <doc xml:whitespace="preserve">Sets the contents of a %G_TYPE_OBJECT derived #GValue to @v_object
and takes over the ownership of the callers reference to @v_object;
the caller doesn't have to unref it any more (i.e. the reference
count of the object is not increased).
If you want the #GValue to hold its own reference to @v_object, use
g_value_set_object() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">object value to be set</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_param"
              c:identifier="g_value_take_param"
              version="2.4">
        <doc xml:whitespace="preserve">Sets the contents of a %G_TYPE_PARAM #GValue to @param and takes
over the ownership of the callers reference to @param; the caller
doesn't have to unref it any more.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GParamSpec to be set</doc>
            <type name="ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_string"
              c:identifier="g_value_take_string"
              version="2.4">
        <doc xml:whitespace="preserve">Sets the contents of a %G_TYPE_STRING #GValue to @v_string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="v_string" transfer-ownership="none">
            <doc xml:whitespace="preserve">string to take ownership of</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_variant"
              c:identifier="g_value_take_variant"
              version="2.26">
        <doc xml:whitespace="preserve">Set the contents of a variant #GValue to @variant, and takes over
the ownership of the caller's reference to @variant;
the caller doesn't have to unref it any more (i.e. the reference
count of the variant is not increased).
It is a programmer error to pass a floating variant to this function.
In particular this means that callbacks in closures, and signal handlers
for signals of return type %G_TYPE_VARIANT, must never return floating
variants.
If you want the #GValue to hold its own reference to @variant, use
g_value_set_variant() instead.
This is an internal function introduced mainly for C marshallers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="variant" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform" c:identifier="g_value_transform">
        <doc xml:whitespace="preserve">Tries to cast the contents of @src_value into a type appropriate
to store in @dest_value, e.g. to transform a %G_TYPE_INT value
into a %G_TYPE_FLOAT value. Performing transformations between
value types might incur precision lossage. Especially
transformations into strings might reveal seemingly arbitrary
results and shouldn't be relied upon for production code (such
as rcfile value or object property serialization).
Upon failing transformations, @dest_value is left untouched.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether a transformation rule was found and could be applied.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dest_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">Target value.</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unset" c:identifier="g_value_unset">
        <doc xml:whitespace="preserve">Clears the current value in @value and "unsets" the type,
this releases all resources associated with this GValue.
An unset value is the same as an uninitialized (zero-filled)
#GValue structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="ValueArray"
            c:type="GValueArray"
            glib:type-name="GValueArray"
            glib:get-type="g_value_array_get_type"
            c:symbol-prefix="value_array">
      <doc xml:whitespace="preserve">A #GValueArray contains an array of #GValue elements.</doc>
      <field name="n_values" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="values" writable="1">
        <type name="Value" c:type="GValue*"/>
      </field>
      <field name="n_prealloced" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <constructor name="new" c:identifier="g_value_array_new">
        <doc xml:whitespace="preserve">Allocate and initialize a new #GValueArray, optionally preserve space
for @n_prealloced elements. New arrays always contain 0 elements,
regardless of the value of @n_prealloced.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GValueArray with 0 values</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <parameter name="n_prealloced" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of values to preallocate space for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="g_value_array_append">
        <doc xml:whitespace="preserve">Insert a copy of @value as last element of @value_array. If @value is
%NULL, an uninitialized value is appended.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GValue to copy into #GValueArray, or %NULL</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="g_value_array_copy">
        <doc xml:whitespace="preserve">Construct an exact copy of a #GValueArray by duplicating all its
contents.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">Newly allocated copy of #GValueArray</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="g_value_array_free">
        <doc xml:whitespace="preserve">Free a #GValueArray including its contents.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_nth" c:identifier="g_value_array_get_nth">
        <doc xml:whitespace="preserve">Return a pointer to the value at @index_ containd in @value_array.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a value at @index_ in @value_array</doc>
          <type name="Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:whitespace="preserve">index of the value of interest</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="g_value_array_insert">
        <doc xml:whitespace="preserve">Insert a copy of @value at specified position into @value_array. If @value
is %NULL, an uninitialized value is inserted.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:whitespace="preserve">insertion position, must be &amp;lt;= value_array-&amp;gt;n_values</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GValue to copy into #GValueArray, or %NULL</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend" c:identifier="g_value_array_prepend">
        <doc xml:whitespace="preserve">Insert a copy of @value as first element of @value_array. If @value is
%NULL, an uninitialized value is prepended.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GValue to copy into #GValueArray, or %NULL</doc>
            <type name="Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="g_value_array_remove">
        <doc xml:whitespace="preserve">Remove the value at position @index_ from @value_array.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <parameter name="index_" transfer-ownership="none">
            <doc xml:whitespace="preserve">position of value to remove, must be &amp;lt; value_array-&gt;n_values</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="sort" c:identifier="g_value_array_sort" introspectable="0">
        <doc xml:whitespace="preserve">Sort @value_array using @compare_func to compare the elements accoring to
the semantics of #GCompareFunc.
The current implementation uses Quick-Sort as sorting algorithm.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <parameter name="compare_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">function to compare elements</doc>
            <type name="GLib.CompareFunc" c:type="GCompareFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="sort_with_data"
              c:identifier="g_value_array_sort_with_data"
              introspectable="0">
        <doc xml:whitespace="preserve">Sort @value_array using @compare_func to compare the elements accoring
to the semantics of #GCompareDataFunc.
The current implementation uses Quick-Sort as sorting algorithm.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GValueArray passed in as @value_array</doc>
          <type name="ValueArray" c:type="GValueArray*"/>
        </return-value>
        <parameters>
          <parameter name="compare_func" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">function to compare elements</doc>
            <type name="GLib.CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">extra data argument provided for @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="ValueTransform" c:type="GValueTransform">
      <doc xml:whitespace="preserve">The type of value transformation functions which can be registered with
g_value_register_transform_func().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">Source value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="dest_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">Target value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="WeakNotify" c:type="GWeakNotify">
      <doc xml:whitespace="preserve">A #GWeakNotify function can be added to an object as a callback that gets
triggered when the object is finalized. Since the object is already being
finalized when the #GWeakNotify is called, there's not much you could do 
with the object, apart from e.g. using its adress as hash-index or the like.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data that was provided when the weak reference was established</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="where_the_object_was" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object being finalized</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <function name="boxed_copy" c:identifier="g_boxed_copy" introspectable="0">
      <doc xml:whitespace="preserve">Provide a copy of a boxed structure @src_boxed which is of type @boxed_type.</doc>
      <return-value>
        <doc xml:whitespace="preserve">The newly created copy of the boxed structure.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="boxed_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type of @src_boxed.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="src_boxed" transfer-ownership="none">
          <doc xml:whitespace="preserve">The boxed structure to be copied.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="boxed_free" c:identifier="g_boxed_free">
      <doc xml:whitespace="preserve">Free the boxed structure @boxed which is of type @boxed_type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="boxed_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type of @boxed.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="boxed" transfer-ownership="none">
          <doc xml:whitespace="preserve">The boxed structure to be freed.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="boxed_type_init" c:identifier="g_boxed_type_init">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="boxed_type_register_static"
              c:identifier="g_boxed_type_register_static"
              introspectable="0">
      <doc xml:whitespace="preserve">This function creates a new %G_TYPE_BOXED derived type id for a new
boxed type with name @name. Boxed type handling functions have to be
provided to copy and free opaque boxed structures of this type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">New %G_TYPE_BOXED derived type id for @name.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">Name of the new boxed type.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="boxed_copy" transfer-ownership="none">
          <doc xml:whitespace="preserve">Boxed structure copy function.</doc>
          <type name="BoxedCopyFunc" c:type="GBoxedCopyFunc"/>
        </parameter>
        <parameter name="boxed_free" transfer-ownership="none">
          <doc xml:whitespace="preserve">Boxed structure free function.</doc>
          <type name="BoxedFreeFunc" c:type="GBoxedFreeFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_BOOLEAN__BOXED_BOXED"
              c:identifier="g_cclosure_marshal_BOOLEAN__BOXED_BOXED">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_BOOLEAN__FLAGS"
              c:identifier="g_cclosure_marshal_BOOLEAN__FLAGS">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;gboolean (*callback) (gpointer instance, gint arg1, gpointer user_data)&lt;/literal&gt; where the #gint parameter
denotes a flags type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue which can store the returned #gboolean</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding instance and arg1</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_STRING__OBJECT_POINTER"
              c:identifier="g_cclosure_marshal_STRING__OBJECT_POINTER">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;gchar* (*callback) (gpointer instance, GObject *arg1, gpointer arg2, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue, which can store the returned string</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">3</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding instance, arg1 and arg2</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__BOOLEAN"
              c:identifier="g_cclosure_marshal_VOID__BOOLEAN">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, gboolean arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #gboolean parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__BOXED"
              c:identifier="g_cclosure_marshal_VOID__BOXED">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, GBoxed *arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #GBoxed* parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__CHAR"
              c:identifier="g_cclosure_marshal_VOID__CHAR">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, gchar arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #gchar parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__DOUBLE"
              c:identifier="g_cclosure_marshal_VOID__DOUBLE">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, gdouble arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #gdouble parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__ENUM"
              c:identifier="g_cclosure_marshal_VOID__ENUM">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, gint arg1, gpointer user_data)&lt;/literal&gt; where the #gint parameter denotes an enumeration type..</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the enumeration parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__FLAGS"
              c:identifier="g_cclosure_marshal_VOID__FLAGS">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, gint arg1, gpointer user_data)&lt;/literal&gt; where the #gint parameter denotes a flags type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the flags parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__FLOAT"
              c:identifier="g_cclosure_marshal_VOID__FLOAT">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, gfloat arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #gfloat parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__INT"
              c:identifier="g_cclosure_marshal_VOID__INT">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, gint arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #gint parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__LONG"
              c:identifier="g_cclosure_marshal_VOID__LONG">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, glong arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #glong parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__OBJECT"
              c:identifier="g_cclosure_marshal_VOID__OBJECT">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, GObject *arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #GObject* parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__PARAM"
              c:identifier="g_cclosure_marshal_VOID__PARAM">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, GParamSpec *arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #GParamSpec* parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__POINTER"
              c:identifier="g_cclosure_marshal_VOID__POINTER">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, gpointer arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #gpointer parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__STRING"
              c:identifier="g_cclosure_marshal_VOID__STRING">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, const gchar *arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #gchar* parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__UCHAR"
              c:identifier="g_cclosure_marshal_VOID__UCHAR">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, guchar arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #guchar parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__UINT"
              c:identifier="g_cclosure_marshal_VOID__UINT">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, guint arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #guint parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__UINT_POINTER"
              c:identifier="g_cclosure_marshal_VOID__UINT_POINTER">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, guint arg1, gpointer arg2, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">3</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding instance, arg1 and arg2</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__ULONG"
              c:identifier="g_cclosure_marshal_VOID__ULONG">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, gulong arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #gulong parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__VARIANT"
              c:identifier="g_cclosure_marshal_VOID__VARIANT"
              version="2.26">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, GVariant *arg1, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">2</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding the instance and the #GVariant* parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_marshal_VOID__VOID"
              c:identifier="g_cclosure_marshal_VOID__VOID">
      <doc xml:whitespace="preserve">A marshaller for a #GCClosure with a callback of type
&lt;literal&gt;void (*callback) (gpointer instance, gpointer user_data)&lt;/literal&gt;.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">1</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue array holding only the instance</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none">
          <doc xml:whitespace="preserve">the invocation hint given as the last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">additional data specified when registering the marshaller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_new"
              c:identifier="g_cclosure_new"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new closure which invokes @callback_func with @user_data as
the last parameter.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GCClosure</doc>
        <type name="Closure" c:type="GClosure*"/>
      </return-value>
      <parameters>
        <parameter name="callback_func" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">the function to invoke</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data to pass to @callback_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">destroy notify to be called when @user_data is no longer used</doc>
          <type name="ClosureNotify" c:type="GClosureNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_new_object"
              c:identifier="g_cclosure_new_object"
              introspectable="0">
      <doc xml:whitespace="preserve">A variant of g_cclosure_new() which uses @object as @user_data and
calls g_object_watch_closure() on @object and the created
closure. This function is useful when you have a callback closely
associated with a #GObject, and want the callback to no longer run
after the object is is freed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GCClosure</doc>
        <type name="Closure" c:type="GClosure*"/>
      </return-value>
      <parameters>
        <parameter name="callback_func" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function to invoke</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GObject pointer to pass to @callback_func</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_new_object_swap"
              c:identifier="g_cclosure_new_object_swap"
              introspectable="0">
      <doc xml:whitespace="preserve">A variant of g_cclosure_new_swap() which uses @object as @user_data
and calls g_object_watch_closure() on @object and the created
closure. This function is useful when you have a callback closely
associated with a #GObject, and want the callback to no longer run
after the object is is freed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GCClosure</doc>
        <type name="Closure" c:type="GClosure*"/>
      </return-value>
      <parameters>
        <parameter name="callback_func" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function to invoke</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GObject pointer to pass to @callback_func</doc>
          <type name="Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cclosure_new_swap"
              c:identifier="g_cclosure_new_swap"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new closure which invokes @callback_func with @user_data as
the first parameter.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GCClosure</doc>
        <type name="Closure" c:type="GClosure*"/>
      </return-value>
      <parameters>
        <parameter name="callback_func" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">the function to invoke</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data to pass to @callback_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">destroy notify to be called when @user_data is no longer used</doc>
          <type name="ClosureNotify" c:type="GClosureNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_complete_type_info"
              c:identifier="g_enum_complete_type_info">
      <doc xml:whitespace="preserve">This function is meant to be called from the complete_type_info()
function of a #GTypePlugin implementation, as in the following
example:
|[
static void
my_enum_complete_type_info (GTypePlugin     *plugin,
GType            g_type,
GTypeInfo       *info,
GTypeValueTable *value_table)
{
static const GEnumValue values[] = {
{ MY_ENUM_FOO, "MY_ENUM_FOO", "foo" },
{ MY_ENUM_BAR, "MY_ENUM_BAR", "bar" },
{ 0, NULL, NULL }
};
g_enum_complete_type_info (type, info, values);
}
]|</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_enum_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type identifier of the type being completed</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GTypeInfo struct to be filled in</doc>
          <type name="TypeInfo" c:type="GTypeInfo*"/>
        </parameter>
        <parameter name="const_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #GEnumValue structs for the possible enumeration values. The array is terminated by a struct with all members being 0.</doc>
          <type name="EnumValue" c:type="GEnumValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_get_value"
              c:identifier="g_enum_get_value"
              introspectable="0">
      <doc xml:whitespace="preserve">Returns the #GEnumValue for a value.
member of the enumeration</doc>
      <return-value>
        <doc xml:whitespace="preserve">the #GEnumValue for @value, or %NULL if @value is not a</doc>
        <type name="EnumValue" c:type="GEnumValue*"/>
      </return-value>
      <parameters>
        <parameter name="enum_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GEnumClass</doc>
          <type name="EnumClass" c:type="GEnumClass*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to look up</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_get_value_by_name"
              c:identifier="g_enum_get_value_by_name"
              introspectable="0">
      <doc xml:whitespace="preserve">Looks up a #GEnumValue by name.
enumeration doesn't have a member with that name</doc>
      <return-value>
        <doc xml:whitespace="preserve">the #GEnumValue with name @name, or %NULL if the</doc>
        <type name="EnumValue" c:type="GEnumValue*"/>
      </return-value>
      <parameters>
        <parameter name="enum_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GEnumClass</doc>
          <type name="EnumClass" c:type="GEnumClass*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_get_value_by_nick"
              c:identifier="g_enum_get_value_by_nick"
              introspectable="0">
      <doc xml:whitespace="preserve">Looks up a #GEnumValue by nickname.
enumeration doesn't have a member with that nickname</doc>
      <return-value>
        <doc xml:whitespace="preserve">the #GEnumValue with nickname @nick, or %NULL if the</doc>
        <type name="EnumValue" c:type="GEnumValue*"/>
      </return-value>
      <parameters>
        <parameter name="enum_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GEnumClass</doc>
          <type name="EnumClass" c:type="GEnumClass*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">the nickname to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_register_static"
              c:identifier="g_enum_register_static">
      <doc xml:whitespace="preserve">Registers a new static enumeration type with the name @name.
It is normally more convenient to let &lt;link
linkend="glib-mkenums"&gt;glib-mkenums&lt;/link&gt; generate a
my_enum_get_type() function from a usual C enumeration definition
than to write one yourself using g_enum_register_static().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The new type identifier.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A nul-terminated string used as the name of the new type.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="const_static_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #GEnumValue structs for the possible enumeration values. The array is terminated by a struct with all members being 0. GObject keeps a reference to the data, so it cannot be stack-allocated.</doc>
          <type name="EnumValue" c:type="GEnumValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_types_init" c:identifier="g_enum_types_init">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="flags_complete_type_info"
              c:identifier="g_flags_complete_type_info">
      <doc xml:whitespace="preserve">This function is meant to be called from the complete_type_info()
function of a #GTypePlugin implementation, see the example for
g_enum_complete_type_info() above.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_flags_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type identifier of the type being completed</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GTypeInfo struct to be filled in</doc>
          <type name="TypeInfo" c:type="GTypeInfo*"/>
        </parameter>
        <parameter name="const_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #GFlagsValue structs for the possible enumeration values. The array is terminated by a struct with all members being 0.</doc>
          <type name="FlagsValue" c:type="GFlagsValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="flags_get_first_value"
              c:identifier="g_flags_get_first_value"
              introspectable="0">
      <doc xml:whitespace="preserve">Returns the first #GFlagsValue which is set in @value.
none is set</doc>
      <return-value>
        <doc xml:whitespace="preserve">the first #GFlagsValue which is set in @value, or %NULL if</doc>
        <type name="FlagsValue" c:type="GFlagsValue*"/>
      </return-value>
      <parameters>
        <parameter name="flags_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GFlagsClass</doc>
          <type name="FlagsClass" c:type="GFlagsClass*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="flags_get_value_by_name"
              c:identifier="g_flags_get_value_by_name"
              introspectable="0">
      <doc xml:whitespace="preserve">Looks up a #GFlagsValue by name.
flag with that name</doc>
      <return-value>
        <doc xml:whitespace="preserve">the #GFlagsValue with name @name, or %NULL if there is no</doc>
        <type name="FlagsValue" c:type="GFlagsValue*"/>
      </return-value>
      <parameters>
        <parameter name="flags_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GFlagsClass</doc>
          <type name="FlagsClass" c:type="GFlagsClass*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="flags_get_value_by_nick"
              c:identifier="g_flags_get_value_by_nick"
              introspectable="0">
      <doc xml:whitespace="preserve">Looks up a #GFlagsValue by nickname.
no flag with that nickname</doc>
      <return-value>
        <doc xml:whitespace="preserve">the #GFlagsValue with nickname @nick, or %NULL if there is</doc>
        <type name="FlagsValue" c:type="GFlagsValue*"/>
      </return-value>
      <parameters>
        <parameter name="flags_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GFlagsClass</doc>
          <type name="FlagsClass" c:type="GFlagsClass*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">the nickname to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="flags_register_static"
              c:identifier="g_flags_register_static">
      <doc xml:whitespace="preserve">Registers a new static flags type with the name @name.
It is normally more convenient to let &lt;link
linkend="glib-mkenums"&gt;glib-mkenums&lt;/link&gt; generate a
my_flags_get_type() function from a usual C enumeration definition
than to write one yourself using g_flags_register_static().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The new type identifier.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A nul-terminated string used as the name of the new type.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="const_static_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #GFlagsValue structs for the possible flags values. The array is terminated by a struct with all members being 0. GObject keeps a reference to the data, so it cannot be stack-allocated.</doc>
          <type name="FlagsValue" c:type="GFlagsValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gtype_get_type" c:identifier="g_gtype_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="object_get_type" c:identifier="g_object_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="param_spec_boolean"
              c:identifier="g_param_spec_boolean"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecBoolean instance specifying a %G_TYPE_BOOLEAN
property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_boxed"
              c:identifier="g_param_spec_boxed"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_BOXED
derived property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="boxed_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">%G_TYPE_BOXED derived type of this property</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_char"
              c:identifier="g_param_spec_char"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecChar instance specifying a %G_TYPE_CHAR property.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value for the property specified</doc>
          <type name="gint8" c:type="gint8"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value for the property specified</doc>
          <type name="gint8" c:type="gint8"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="gint8" c:type="gint8"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_double"
              c:identifier="g_param_spec_double"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecDouble instance specifying a %G_TYPE_DOUBLE
property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_enum"
              c:identifier="g_param_spec_enum"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecEnum instance specifying a %G_TYPE_ENUM
property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="enum_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType derived from %G_TYPE_ENUM</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_flags"
              c:identifier="g_param_spec_flags"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecFlags instance specifying a %G_TYPE_FLAGS
property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType derived from %G_TYPE_FLAGS</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_float"
              c:identifier="g_param_spec_float"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecFloat instance specifying a %G_TYPE_FLOAT property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value for the property specified</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value for the property specified</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_gtype"
              c:identifier="g_param_spec_gtype"
              version="2.10"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecGType instance specifying a
%G_TYPE_GTYPE property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="is_a_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType whose subtypes are allowed as values of the property (use %G_TYPE_NONE for any type)</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_int"
              c:identifier="g_param_spec_int"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecInt instance specifying a %G_TYPE_INT property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_int64"
              c:identifier="g_param_spec_int64"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecInt64 instance specifying a %G_TYPE_INT64 property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value for the property specified</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value for the property specified</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_internal"
              c:identifier="g_param_spec_internal"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpec instance.
A property name consists of segments consisting of ASCII letters and
digits, separated by either the '-' or '_' character. The first
character of a property name must be a letter. Names which violate these
rules lead to undefined behaviour.
When creating and looking up a #GParamSpec, either separator can be
used, but they cannot be mixed. Using '-' is considerably more
efficient and in fact required when using property names as detail
strings for signals.
Beyond the name, #GParamSpec&lt;!-- --&gt;s have two more descriptive
strings associated with them, the @nick, which should be suitable
for use as a label for the property in a property editor, and the
e.g. a tooltip. The @nick and @blurb should ideally be localized.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly allocated #GParamSpec instance</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="param_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType for the property; must be derived from #G_TYPE_PARAM</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the canonical name of the property</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">the nickname of the property</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">a short description of the property</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">a combination of #GParamFlags</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_long"
              c:identifier="g_param_spec_long"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecLong instance specifying a %G_TYPE_LONG property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value for the property specified</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value for the property specified</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_object"
              c:identifier="g_param_spec_object"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_OBJECT
derived property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="object_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">%G_TYPE_OBJECT derived type of this property</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_override"
              c:identifier="g_param_spec_override"
              version="2.4"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new property of type #GParamSpecOverride. This is used
to direct operations to another paramspec, and will not be directly
useful unless you are implementing a new base type similar to GObject.</doc>
      <return-value>
        <doc xml:whitespace="preserve">the newly created #GParamSpec</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the property.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="overridden" transfer-ownership="none">
          <doc xml:whitespace="preserve">The property that is being overridden</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_param"
              c:identifier="g_param_spec_param"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecParam instance specifying a %G_TYPE_PARAM
property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="param_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType derived from %G_TYPE_PARAM</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_pointer"
              c:identifier="g_param_spec_pointer"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecPoiner instance specifying a pointer property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_pool_new"
              c:identifier="g_param_spec_pool_new"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecPool.
If @type_prefixing is %TRUE, lookups in the newly created pool will
allow to specify the owner as a colon-separated prefix of the
property name, like "GtkContainer:border-width". This feature is
deprecated, so you should always set @type_prefixing to %FALSE.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly allocated #GParamSpecPool.</doc>
        <type name="ParamSpecPool" c:type="GParamSpecPool*"/>
      </return-value>
      <parameters>
        <parameter name="type_prefixing" transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether the pool will support type-prefixed property names.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_string"
              c:identifier="g_param_spec_string"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecString instance.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_types_init"
              c:identifier="g_param_spec_types_init">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="param_spec_uchar"
              c:identifier="g_param_spec_uchar"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecUChar instance specifying a %G_TYPE_UCHAR property.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value for the property specified</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value for the property specified</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_uint"
              c:identifier="g_param_spec_uint"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecUInt instance specifying a %G_TYPE_UINT property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value for the property specified</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value for the property specified</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_uint64"
              c:identifier="g_param_spec_uint64"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecUInt64 instance specifying a %G_TYPE_UINT64
property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value for the property specified</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value for the property specified</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_ulong"
              c:identifier="g_param_spec_ulong"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecULong instance specifying a %G_TYPE_ULONG
property.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value for the property specified</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value for the property specified</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_unichar"
              c:identifier="g_param_spec_unichar"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecUnichar instance specifying a %G_TYPE_UINT
property. #GValue structures for this property can be accessed with
g_value_set_uint() and g_value_get_uint().
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value for the property specified</doc>
          <type name="gunichar" c:type="gunichar"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_value_array"
              c:identifier="g_param_spec_value_array"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecValueArray instance specifying a
%G_TYPE_VALUE_ARRAY property. %G_TYPE_VALUE_ARRAY is a
%G_TYPE_BOXED type, as such, #GValue structures for this property
can be accessed with g_value_set_boxed() and g_value_get_boxed().
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="element_spec" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GParamSpec describing the elements contained in arrays of this property, may be %NULL</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_variant"
              c:identifier="g_param_spec_variant"
              version="2.26"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GParamSpecVariant instance specifying a #GVariant
property.
If @default_value is floating, it is consumed.
See g_param_spec_internal() for details on property names.</doc>
      <return-value>
        <doc xml:whitespace="preserve">the newly created #GParamSpec</doc>
        <type name="ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GVariantType</doc>
          <type name="GLib.VariantType" c:type="GVariantType*"/>
        </parameter>
        <parameter name="default_value"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">a #GVariant of type @type to use as the default value, or %NULL</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_type_init" c:identifier="g_param_type_init">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="param_type_register_static"
              c:identifier="g_param_type_register_static">
      <doc xml:whitespace="preserve">Registers @name as the name of a new static type derived from
#G_TYPE_PARAM. The type system uses the information contained in
the #GParamSpecTypeInfo structure pointed to by @info to manage the
#GParamSpec type and its instances.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The new type identifier.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">0-terminated string used as the name of the new #GParamSpec type.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="pspec_info" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GParamSpecTypeInfo for this #GParamSpec type.</doc>
          <type name="ParamSpecTypeInfo" c:type="GParamSpecTypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_value_convert" c:identifier="g_param_value_convert">
      <doc xml:whitespace="preserve">Transforms @src_value into @dest_value if possible, and then
validates @dest_value, in order for it to conform to @pspec.  If
transformed @dest_value complied to @pspec without modifications.
See also g_value_type_transformable(), g_value_transform() and
g_param_value_validate().
%FALSE otherwise and @dest_value is left untouched.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if transformation and validation were successful,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:whitespace="preserve">a valid #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="src_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">souce #GValue</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="dest_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">destination #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="strict_validation" transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE requires @dest_value to conform to @pspec without modifications</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_value_defaults"
              c:identifier="g_param_value_defaults">
      <doc xml:whitespace="preserve">Checks whether @value contains the default value as specified in @pspec.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">whether @value contains the canonical default for this @pspec</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:whitespace="preserve">a valid #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_value_set_default"
              c:identifier="g_param_value_set_default">
      <doc xml:whitespace="preserve">Sets @value to its default value as specified in @pspec.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:whitespace="preserve">a valid #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_value_validate"
              c:identifier="g_param_value_validate">
      <doc xml:whitespace="preserve">Ensures that the contents of @value comply with the specifications
set out by @pspec. For example, a #GParamSpecInt might require
that integers stored in @value may not be smaller than -42 and not be
greater than +42. If @value contains an integer outside of this range,
it is modified accordingly, so the resulting value will fit into the
range -42 .. +42.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">whether modifying @value was necessary to ensure validity</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:whitespace="preserve">a valid #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_values_cmp" c:identifier="g_param_values_cmp">
      <doc xml:whitespace="preserve">Compares @value1 with @value2 according to @pspec, and return -1, 0 or +1,
if @value1 is found to be less than, equal to or greater than @value2,
respectively.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">-1, 0 or +1, for a less than, equal to or greater than result</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:whitespace="preserve">a valid #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue of correct type for @pspec</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pointer_type_register_static"
              c:identifier="g_pointer_type_register_static">
      <doc xml:whitespace="preserve">Creates a new %G_TYPE_POINTER derived type id for a new
pointer type with name @name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a new %G_TYPE_POINTER derived type id for @name.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the new pointer type.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_accumulator_true_handled"
              c:identifier="g_signal_accumulator_true_handled"
              version="2.4">
      <doc xml:whitespace="preserve">A predefined #GSignalAccumulator for signals that return a
boolean values. The behavior that this accumulator gives is
callbacks will be invoked, while a return of %FALSE allows
the emission to coninue. The idea here is that a %TRUE return
indicates that the callback &lt;emphasis&gt;handled&lt;/emphasis&gt; the signal,
and no further handling is needed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">standard #GSignalAccumulator result</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ihint" transfer-ownership="none">
          <doc xml:whitespace="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*"/>
        </parameter>
        <parameter name="return_accu" transfer-ownership="none">
          <doc xml:whitespace="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="handler_return" transfer-ownership="none">
          <doc xml:whitespace="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="dummy" transfer-ownership="none">
          <doc xml:whitespace="preserve">standard #GSignalAccumulator parameter</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_add_emission_hook"
              c:identifier="g_signal_add_emission_hook">
      <doc xml:whitespace="preserve">Adds an emission hook for a signal, which will get called for any emission
of that signal, independent of the instance. This is possible only
for signals which don't have #G_SIGNAL_NO_HOOKS flag set.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the hook id, for later use with g_signal_remove_emission_hook().</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal identifier, as returned by g_signal_lookup().</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:whitespace="preserve">the detail on which to call the hook.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="hook_func"
                   transfer-ownership="none"
                   scope="notified"
                   closure="3"
                   destroy="4">
          <doc xml:whitespace="preserve">a #GSignalEmissionHook function.</doc>
          <type name="SignalEmissionHook" c:type="GSignalEmissionHook"/>
        </parameter>
        <parameter name="hook_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data for @hook_func.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data_destroy" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">a #GDestroyNotify for @hook_data.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_chain_from_overridden"
              c:identifier="g_signal_chain_from_overridden">
      <doc xml:whitespace="preserve">Calls the original class closure of a signal. This function should only
be called from an overridden class closure; see
g_signal_override_class_closure() and
g_signal_override_class_handler().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance_and_params" transfer-ownership="none">
          <doc xml:whitespace="preserve">the argument list of the signal emission. The first element in the array is a #GValue for the instance the signal is being emitted on. The rest are any arguments to be passed to the signal.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location for the return value.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_chain_from_overridden_handler"
              c:identifier="g_signal_chain_from_overridden_handler"
              version="2.18"
              introspectable="0">
      <doc xml:whitespace="preserve">Calls the original class closure of a signal. This function should
only be called from an overridden class closure; see
g_signal_override_class_closure() and
g_signal_override_class_handler().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance the signal is being emitted on.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="signal_connect_closure"
              c:identifier="g_signal_connect_closure">
      <doc xml:whitespace="preserve">Connects a closure to a signal for a particular object.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the handler id</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance to connect to.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the closure to connect.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="after" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the handler should be called before or after the default handler of the signal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_connect_closure_by_id"
              c:identifier="g_signal_connect_closure_by_id">
      <doc xml:whitespace="preserve">Connects a closure to a signal for a particular object.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the handler id</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance to connect to.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the id of the signal.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:whitespace="preserve">the detail.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the closure to connect.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="after" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the handler should be called before or after the default handler of the signal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_connect_data"
              c:identifier="g_signal_connect_data"
              introspectable="0">
      <doc xml:whitespace="preserve">Connects a #GCallback function to a signal for a particular object. Similar
to g_signal_connect(), but allows to provide a #GClosureNotify for the data
which will be called when the signal handler is disconnected and no longer
used. Specify @connect_flags if you need &lt;literal&gt;..._after()&lt;/literal&gt; or
&lt;literal&gt;..._swapped()&lt;/literal&gt; variants of this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the handler id</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance to connect to.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="c_handler" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">the #GCallback to connect.</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data to pass to @c_handler calls.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GClosureNotify for @data.</doc>
          <type name="ClosureNotify" c:type="GClosureNotify"/>
        </parameter>
        <parameter name="connect_flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">a combination of #GConnectFlags.</doc>
          <type name="ConnectFlags" c:type="GConnectFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_connect_object"
              c:identifier="g_signal_connect_object"
              introspectable="0">
      <doc xml:whitespace="preserve">This is similar to g_signal_connect_data(), but uses a closure which
ensures that the @gobject stays alive during the call to @c_handler
by temporarily adding a reference count to @gobject.
Note that there is a bug in GObject that makes this function
much less useful than it might seem otherwise. Once @gobject is
disposed, the callback will no longer be called, but, the signal
handler is &lt;emphasis&gt;not&lt;/emphasis&gt; currently disconnected. If the
matter, since the signal will automatically be removed, but
if @instance persists, then the signal handler will leak. You
should not remove the signal yourself because in a future versions of
GObject, the handler &lt;emphasis&gt;will&lt;/emphasis&gt; automatically
be disconnected.
It's possible to work around this problem in a way that will
continue to work with future versions of GObject by checking
that the signal handler is still connected before disconnected it:
&lt;informalexample&gt;&lt;programlisting&gt;
if (g_signal_handler_is_connected (instance, id))
g_signal_handler_disconnect (instance, id);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the handler id.</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance to connect to.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="c_handler" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GCallback to connect.</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="gobject" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object to pass as data to @c_handler.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="connect_flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">a combination of #GConnnectFlags.</doc>
          <type name="ConnectFlags" c:type="GConnectFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_emit"
              c:identifier="g_signal_emit"
              introspectable="0">
      <doc xml:whitespace="preserve">Emits a signal.
Note that g_signal_emit() resets the return value to the default
if no handlers are connected, in contrast to g_signal_emitv().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance the signal is being emitted on.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal id</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:whitespace="preserve">the detail</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="signal_emit_by_name"
              c:identifier="g_signal_emit_by_name"
              introspectable="0">
      <doc xml:whitespace="preserve">Emits a signal.
Note that g_signal_emit_by_name() resets the return value to the default
if no handlers are connected, in contrast to g_signal_emitv().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance the signal is being emitted on.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="signal_emit_valist"
              c:identifier="g_signal_emit_valist"
              introspectable="0">
      <doc xml:whitespace="preserve">Emits a signal.
Note that g_signal_emit_valist() resets the return value to the default
if no handlers are connected, in contrast to g_signal_emitv().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance the signal is being emitted on.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal id</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:whitespace="preserve">the detail</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:whitespace="preserve">a list of parameters to be passed to the signal, followed by a location for the return value. If the return type of the signal is #G_TYPE_NONE, the return value location can be omitted.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_emitv" c:identifier="g_signal_emitv">
      <doc xml:whitespace="preserve">Emits a signal.
Note that g_signal_emitv() doesn't change @return_value if no handlers are
connected, in contrast to g_signal_emit() and g_signal_emit_valist().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance_and_params" transfer-ownership="none">
          <doc xml:whitespace="preserve">argument list for the signal emission. The first element in the array is a #GValue for the instance the signal is being emitted on. The rest are any arguments to be passed to the signal.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal id</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:whitespace="preserve">the detail</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location to store the return value of the signal emission.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_get_invocation_hint"
              c:identifier="g_signal_get_invocation_hint"
              introspectable="0">
      <doc xml:whitespace="preserve">Returns the invocation hint of the innermost signal emission of instance.</doc>
      <return-value>
        <doc xml:whitespace="preserve">the invocation hint of the innermost signal emission.</doc>
        <type name="SignalInvocationHint" c:type="GSignalInvocationHint*"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance to query</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handler_block"
              c:identifier="g_signal_handler_block">
      <doc xml:whitespace="preserve">Blocks a handler of an instance so it will not be called during any
signal emissions unless it is unblocked again. Thus "blocking" a
signal handler means to temporarily deactive it, a signal handler
has to be unblocked exactly the same amount of times it has been
blocked before to become active again.
The @handler_id has to be a valid signal handler id, connected to a
signal of @instance.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">The instance to block the signal handler of.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="handler_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Handler id of the handler to be blocked.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handler_disconnect"
              c:identifier="g_signal_handler_disconnect">
      <doc xml:whitespace="preserve">Disconnects a handler from an instance so it will not be called during
any future or currently ongoing emissions of the signal it has been
connected to. The @handler_id becomes invalid and may be reused.
The @handler_id has to be a valid signal handler id, connected to a
signal of @instance.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">The instance to remove the signal handler from.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="handler_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Handler id of the handler to be disconnected.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handler_find" c:identifier="g_signal_handler_find">
      <doc xml:whitespace="preserve">Finds the first signal handler that matches certain selection criteria.
The criteria mask is passed as an OR-ed combination of #GSignalMatchType
flags, and the criteria values are passed as arguments.
The match @mask has to be non-0 for successful matches.
If no handler was found, 0 is returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">A valid non-0 signal handler id for a successful match.</doc>
        <type name="gulong" c:type="gulong"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">The instance owning the signal handler to be found.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:whitespace="preserve">Mask indicating which of @signal_id, @detail, @closure, @func and/or @data the handler has to match.</doc>
          <type name="SignalMatchType" c:type="GSignalMatchType"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Signal the handler has to be connected to.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:whitespace="preserve">Signal detail the handler has to be connected to.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">The closure the handler will invoke.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">The C closure callback of the handler (useless for non-C closures).</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The closure data of the handler's closure.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handler_is_connected"
              c:identifier="g_signal_handler_is_connected">
      <doc xml:whitespace="preserve">Returns whether @handler_id is the id of a handler connected to @instance.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">whether @handler_id identifies a handler connected to @instance.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">The instance where a signal handler is sought.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="handler_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the handler id.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handler_unblock"
              c:identifier="g_signal_handler_unblock">
      <doc xml:whitespace="preserve">Undoes the effect of a previous g_signal_handler_block() call.  A
blocked handler is skipped during signal emissions and will not be
invoked, unblocking it (for exactly the amount of times it has been
blocked before) reverts its "blocked" state, so the handler will be
recognized by the signal system and is called upon future or
currently ongoing signal emissions (since the order in which
handlers are called during signal emissions is deterministic,
whether the unblocked handler in question is called as part of a
currently ongoing emission depends on how far that emission has
proceeded yet).
The @handler_id has to be a valid id of a signal handler that is
connected to a signal of @instance and is currently blocked.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">The instance to unblock the signal handler of.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="handler_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Handler id of the handler to be unblocked.</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handlers_block_matched"
              c:identifier="g_signal_handlers_block_matched">
      <doc xml:whitespace="preserve">Blocks all handlers on an instance that match a certain selection criteria.
The criteria mask is passed as an OR-ed combination of #GSignalMatchType
flags, and the criteria values are passed as arguments.
Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
If no handlers were found, 0 is returned, the number of blocked handlers
otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The number of handlers that matched.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">The instance to block handlers from.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:whitespace="preserve">Mask indicating which of @signal_id, @detail, @closure, @func and/or @data the handlers have to match.</doc>
          <type name="SignalMatchType" c:type="GSignalMatchType"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Signal the handlers have to be connected to.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:whitespace="preserve">Signal detail the handlers have to be connected to.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">The closure the handlers will invoke.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">The C closure callback of the handlers (useless for non-C closures).</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The closure data of the handlers' closures.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handlers_destroy"
              c:identifier="g_signal_handlers_destroy">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handlers_disconnect_matched"
              c:identifier="g_signal_handlers_disconnect_matched">
      <doc xml:whitespace="preserve">Disconnects all handlers on an instance that match a certain
selection criteria. The criteria mask is passed as an OR-ed
combination of #GSignalMatchType flags, and the criteria values are
passed as arguments.  Passing at least one of the
%G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC or
%G_SIGNAL_MATCH_DATA match flags is required for successful
matches.  If no handlers were found, 0 is returned, the number of
disconnected handlers otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The number of handlers that matched.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">The instance to remove handlers from.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:whitespace="preserve">Mask indicating which of @signal_id, @detail, @closure, @func and/or @data the handlers have to match.</doc>
          <type name="SignalMatchType" c:type="GSignalMatchType"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Signal the handlers have to be connected to.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:whitespace="preserve">Signal detail the handlers have to be connected to.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">The closure the handlers will invoke.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">The C closure callback of the handlers (useless for non-C closures).</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The closure data of the handlers' closures.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_handlers_unblock_matched"
              c:identifier="g_signal_handlers_unblock_matched">
      <doc xml:whitespace="preserve">Unblocks all handlers on an instance that match a certain selection
criteria. The criteria mask is passed as an OR-ed combination of
#GSignalMatchType flags, and the criteria values are passed as arguments.
Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
If no handlers were found, 0 is returned, the number of unblocked handlers
otherwise. The match criteria should not apply to any handlers that are
not currently blocked.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The number of handlers that matched.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">The instance to unblock handlers from.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:whitespace="preserve">Mask indicating which of @signal_id, @detail, @closure, @func and/or @data the handlers have to match.</doc>
          <type name="SignalMatchType" c:type="GSignalMatchType"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Signal the handlers have to be connected to.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:whitespace="preserve">Signal detail the handlers have to be connected to.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">The closure the handlers will invoke.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">The C closure callback of the handlers (useless for non-C closures).</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The closure data of the handlers' closures.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_has_handler_pending"
              c:identifier="g_signal_has_handler_pending">
      <doc xml:whitespace="preserve">Returns whether there are any handlers connected to @instance for the
given signal id and detail.
One example of when you might use this is when the arguments to the
signal are difficult to compute. A class implementor may opt to not
emit the signal if no one is attached anyway, thus saving the cost
of building the arguments.
otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if a handler is connected to the signal, %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object whose signal handlers are sought.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal id.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:whitespace="preserve">the detail.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="may_be_blocked" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether blocked handlers should count as match.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_init" c:identifier="g_signal_init">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="signal_list_ids" c:identifier="g_signal_list_ids">
      <doc xml:whitespace="preserve">Lists the signals by id that a certain instance or interface type
created. Further information about the signals can be acquired through
g_signal_query().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">Newly allocated array of signal IDs.</doc>
        <type name="guint" c:type="guint*"/>
      </return-value>
      <parameters>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:whitespace="preserve">Instance or interface type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_ids" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location to store the number of signal ids for @itype.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_lookup" c:identifier="g_signal_lookup">
      <doc xml:whitespace="preserve">Given the name of the signal and the type of object it connects to, gets
the signal's identifying integer. Emitting the signal by number is
somewhat faster than using the name each time.
Also tries the ancestors of the given type.
See g_signal_new() for details on allowed signal names.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the signal's identifying number, or 0 if no signal was found.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal's name.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type that the signal operates on.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_name" c:identifier="g_signal_name">
      <doc xml:whitespace="preserve">Given the signal's identifier, finds its name.
Two different signals may have the same name, if they have differing types.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the signal name, or %NULL if the signal number was invalid.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal's identifying number.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_new" c:identifier="g_signal_new" introspectable="0">
      <doc xml:whitespace="preserve">Creates a new signal. (This is usually done in the class initializer.)
A signal name consists of segments consisting of ASCII letters and
digits, separated by either the '-' or '_' character. The first
character of a signal name must be a letter. Names which violate these
rules lead to undefined behaviour of the GSignal system.
When registering a signal and looking up a signal, either separator can
be used, but they cannot be mixed.
If 0 is used for @class_offset subclasses cannot override the class handler
in their &lt;code&gt;class_init&lt;/code&gt; method by doing
&lt;code&gt;super_class-&gt;signal_handler = my_signal_handler&lt;/code&gt;. Instead they
will have to use g_signal_override_class_handler().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the signal id</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name for the signal</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type this signal pertains to. It will also pertain to types which are derived from this type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="signal_flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">a combination of #GSignalFlags specifying detail of when the default handler is to be invoked. You should at least specify %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.</doc>
          <type name="SignalFlags" c:type="GSignalFlags"/>
        </parameter>
        <parameter name="class_offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The offset of the function pointer in the class structure for this type. Used to invoke a class method generically. Pass 0 to not associate a class method slot with this signal.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="accumulator" transfer-ownership="none" closure="5">
          <doc xml:whitespace="preserve">the accumulator for this signal; may be %NULL.</doc>
          <type name="SignalAccumulator" c:type="GSignalAccumulator"/>
        </parameter>
        <parameter name="accu_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data for the @accumulator.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="c_marshaller" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function to translate arrays of parameter values to signal emissions into C language callback invocations.</doc>
          <type name="SignalCMarshaller" c:type="GSignalCMarshaller"/>
        </parameter>
        <parameter name="return_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of return value, or #G_TYPE_NONE for a signal without a return value.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_params" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of parameter types to follow.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="signal_new_class_handler"
              c:identifier="g_signal_new_class_handler"
              version="2.18"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new signal. (This is usually done in the class initializer.)
This is a variant of g_signal_new() that takes a C callback instead
off a class offset for the signal's class handler. This function
doesn't need a function pointer exposed in the class structure of
an object definition, instead the function pointer is passed
directly and can be overriden by derived classes with
g_signal_override_class_closure() or
g_signal_override_class_handler()and chained to with
g_signal_chain_from_overridden() or
g_signal_chain_from_overridden_handler().
See g_signal_new() for information about signal names.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the signal id</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name for the signal</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type this signal pertains to. It will also pertain to types which are derived from this type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="signal_flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">a combination of #GSignalFlags specifying detail of when the default handler is to be invoked. You should at least specify %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.</doc>
          <type name="SignalFlags" c:type="GSignalFlags"/>
        </parameter>
        <parameter name="class_handler" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GCallback which acts as class implementation of this signal. Used to invoke a class method generically. Pass %NULL to not associate a class method with this signal.</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
        <parameter name="accumulator" transfer-ownership="none" closure="5">
          <doc xml:whitespace="preserve">the accumulator for this signal; may be %NULL.</doc>
          <type name="SignalAccumulator" c:type="GSignalAccumulator"/>
        </parameter>
        <parameter name="accu_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data for the @accumulator.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="c_marshaller" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function to translate arrays of parameter values to signal emissions into C language callback invocations.</doc>
          <type name="SignalCMarshaller" c:type="GSignalCMarshaller"/>
        </parameter>
        <parameter name="return_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of return value, or #G_TYPE_NONE for a signal without a return value.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_params" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of parameter types to follow.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="signal_new_valist"
              c:identifier="g_signal_new_valist"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new signal. (This is usually done in the class initializer.)
See g_signal_new() for details on allowed signal names.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the signal id</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name for the signal</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type this signal pertains to. It will also pertain to types which are derived from this type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="signal_flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">a combination of #GSignalFlags specifying detail of when the default handler is to be invoked. You should at least specify %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.</doc>
          <type name="SignalFlags" c:type="GSignalFlags"/>
        </parameter>
        <parameter name="class_closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">The closure to invoke on signal emission; may be %NULL.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="accumulator" transfer-ownership="none" closure="5">
          <doc xml:whitespace="preserve">the accumulator for this signal; may be %NULL.</doc>
          <type name="SignalAccumulator" c:type="GSignalAccumulator"/>
        </parameter>
        <parameter name="accu_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data for the @accumulator.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="c_marshaller" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function to translate arrays of parameter values to signal emissions into C language callback invocations.</doc>
          <type name="SignalCMarshaller" c:type="GSignalCMarshaller"/>
        </parameter>
        <parameter name="return_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of return value, or #G_TYPE_NONE for a signal without a return value.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_params" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of parameter types in @args.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:whitespace="preserve">va_list of #GType, one for each parameter.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_newv"
              c:identifier="g_signal_newv"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new signal. (This is usually done in the class initializer.)
See g_signal_new() for details on allowed signal names.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the signal id</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name for the signal</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type this signal pertains to. It will also pertain to types which are derived from this type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="signal_flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">a combination of #GSignalFlags specifying detail of when the default handler is to be invoked. You should at least specify %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST</doc>
          <type name="SignalFlags" c:type="GSignalFlags"/>
        </parameter>
        <parameter name="class_closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">The closure to invoke on signal emission; may be %NULL</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="accumulator" transfer-ownership="none" closure="5">
          <doc xml:whitespace="preserve">the accumulator for this signal; may be %NULL</doc>
          <type name="SignalAccumulator" c:type="GSignalAccumulator"/>
        </parameter>
        <parameter name="accu_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data for the @accumulator</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="c_marshaller" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function to translate arrays of parameter values to signal emissions into C language callback invocations</doc>
          <type name="SignalCMarshaller" c:type="GSignalCMarshaller"/>
        </parameter>
        <parameter name="return_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of return value, or #G_TYPE_NONE for a signal without a return value</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_params" transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of @param_types</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="param_types" transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of types, one for each parameter</doc>
          <type name="GType" c:type="GType*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_override_class_closure"
              c:identifier="g_signal_override_class_closure">
      <doc xml:whitespace="preserve">Overrides the class closure (i.e. the default handler) for the given signal
for emissions on instances of @instance_type. @instance_type must be derived
from the type to which the signal belongs.
See g_signal_chain_from_overridden() and
g_signal_chain_from_overridden_handler() for how to chain up to the
parent class closure from inside the overridden one.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal id</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance type on which to override the class closure for the signal.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="class_closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the closure.</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_override_class_handler"
              c:identifier="g_signal_override_class_handler"
              version="2.18"
              introspectable="0">
      <doc xml:whitespace="preserve">Overrides the class closure (i.e. the default handler) for the
given signal for emissions on instances of @instance_type with
callabck @class_handler. @instance_type must be derived from the
type to which the signal belongs.
See g_signal_chain_from_overridden() and
g_signal_chain_from_overridden_handler() for how to chain up to the
parent class closure from inside the overridden one.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="signal_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name for the signal</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the instance type on which to override the class handler for the signal.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="class_handler" transfer-ownership="none">
          <doc xml:whitespace="preserve">the handler.</doc>
          <type name="Callback" c:type="GCallback"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_parse_name" c:identifier="g_signal_parse_name">
      <doc xml:whitespace="preserve">Internal function to parse a signal name into its @signal_id
and @detail quark.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the signal name could successfully be parsed and @signal_id_p and @detail_p contain valid return values.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:whitespace="preserve">The interface/instance type that introduced "signal-name".</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="signal_id_p" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location to store the signal id.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="detail_p" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location to store the detail quark.</doc>
          <type name="GLib.Quark" c:type="GQuark*"/>
        </parameter>
        <parameter name="force_detail_quark" transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE forces creation of a #GQuark for the detail.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_query" c:identifier="g_signal_query">
      <doc xml:whitespace="preserve">Queries the signal system for in-depth information about a
specific signal. This function will fill in a user-provided
structure to hold signal-specific information. If an invalid
signal id is passed in, the @signal_id member of the #GSignalQuery
is 0. All members filled into the #GSignalQuery structure should
be considered constant and have to be left untouched.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">The signal id of the signal to query information for.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="query" transfer-ownership="none">
          <doc xml:whitespace="preserve">A user provided structure that is filled in with constant values upon success.</doc>
          <type name="SignalQuery" c:type="GSignalQuery*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_remove_emission_hook"
              c:identifier="g_signal_remove_emission_hook">
      <doc xml:whitespace="preserve">Deletes an emission hook.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the id of the signal</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="hook_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the id of the emission hook, as returned by g_signal_add_emission_hook()</doc>
          <type name="gulong" c:type="gulong"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_stop_emission"
              c:identifier="g_signal_stop_emission">
      <doc xml:whitespace="preserve">Stops a signal's current emission.
This will prevent the default method from running, if the signal was
%G_SIGNAL_RUN_LAST and you connected normally (i.e. without the "after"
flag).
Prints a warning if used on a signal which isn't being emitted.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object whose signal handlers you wish to stop.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="signal_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal identifier, as returned by g_signal_lookup().</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="detail" transfer-ownership="none">
          <doc xml:whitespace="preserve">the detail which the signal was emitted with.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_stop_emission_by_name"
              c:identifier="g_signal_stop_emission_by_name">
      <doc xml:whitespace="preserve">Stops a signal's current emission.
This is just like g_signal_stop_emission() except it will look up the
signal id for you.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object whose signal handlers you wish to stop.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="detailed_signal" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string of the form "signal-name::detail".</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_type_cclosure_new"
              c:identifier="g_signal_type_cclosure_new">
      <doc xml:whitespace="preserve">Creates a new closure which invokes the function found at the offset
identified by @itype.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GCClosure</doc>
        <type name="Closure" c:type="GClosure*"/>
      </return-value>
      <parameters>
        <parameter name="itype" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType identifier of an interface or classed type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="struct_offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset of the member function of @itype's class structure which is to be invoked by the new closure</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="source_set_closure" c:identifier="g_source_set_closure">
      <doc xml:whitespace="preserve">Set the callback for a source as a #GClosure.
If the source is not one of the standard GLib types, the @closure_callback
and @closure_marshal fields of the #GSourceFuncs structure must have been
filled in with pointers to appropriate functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </parameter>
        <parameter name="closure" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GClosure</doc>
          <type name="Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strdup_value_contents"
              c:identifier="g_strdup_value_contents">
      <doc xml:whitespace="preserve">Return a newly allocated string, which describes the contents of a
#GValue.  The main purpose of this function is to describe #GValue
contents for debugging output, the way in which the contents are
described may change between different GLib versions.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">Newly allocated string.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GValue which contents are to be described.</doc>
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strv_get_type" c:identifier="g_strv_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="type_add_class_cache_func"
              c:identifier="g_type_add_class_cache_func"
              introspectable="0">
      <doc xml:whitespace="preserve">Adds a #GTypeClassCacheFunc to be called before the reference count of a
class goes from one to zero. This can be used to prevent premature class
destruction. All installed #GTypeClassCacheFunc functions will be chained
until one of them returns %TRUE. The functions have to check the class id
passed in to figure whether they actually want to cache the class of this
type, since all classes are routed through the same #GTypeClassCacheFunc
chain.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cache_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data to be passed to @cache_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="cache_func" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GTypeClassCacheFunc</doc>
          <type name="TypeClassCacheFunc" c:type="GTypeClassCacheFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_add_class_private"
              c:identifier="g_type_add_class_private"
              version="2.24">
      <doc xml:whitespace="preserve">Registers a private class structure for a classed type;
when the class is allocated, the private structures for
the class and all of its parent types are allocated
sequentially in the same memory block as the public
structures. This function should be called in the
type's get_type() function after the type is registered.
The private structure can be retrieved using the
G_TYPE_CLASS_GET_PRIVATE() macro.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="class_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">GType of an classed type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="private_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">size of private structure.</doc>
          <type name="gulong" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_add_interface_check"
              c:identifier="g_type_add_interface_check"
              version="2.4"
              introspectable="0">
      <doc xml:whitespace="preserve">Adds a function to be called after an interface vtable is
initialized for any class (i.e. after the @interface_init member of
#GInterfaceInfo has been called).
This function is useful when you want to check an invariant that
depends on the interfaces of a class. For instance, the
implementation of #GObject uses this facility to check that an
object implements all of the properties that are defined on its
interfaces.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="check_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data to pass to @check_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="check_func" transfer-ownership="none">
          <doc xml:whitespace="preserve">function to be called after each interface is initialized.</doc>
          <type name="TypeInterfaceCheckFunc"
                c:type="GTypeInterfaceCheckFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_add_interface_dynamic"
              c:identifier="g_type_add_interface_dynamic">
      <doc xml:whitespace="preserve">Adds the dynamic @interface_type to @instantiable_type. The information
contained in the #GTypePlugin structure pointed to by @plugin
is used to manage the relationship.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType value of an instantiable type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType value of an interface type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GTypePlugin structure to retrieve the #GInterfaceInfo from.</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_add_interface_static"
              c:identifier="g_type_add_interface_static">
      <doc xml:whitespace="preserve">Adds the static @interface_type to @instantiable_type.  The information
contained in the #GTypeInterfaceInfo structure pointed to by @info
is used to manage the relationship.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GType value of an instantiable type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GType value of an interface type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GInterfaceInfo structure for this (@instance_type, @interface_type) combination.</doc>
          <type name="InterfaceInfo" c:type="GInterfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_class_cast"
              c:identifier="g_type_check_class_cast"
              introspectable="0">
      <return-value>
        <type name="TypeClass" c:type="GTypeClass*"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <type name="TypeClass" c:type="GTypeClass*"/>
        </parameter>
        <parameter name="is_a_type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_class_is_a"
              c:identifier="g_type_check_class_is_a">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <type name="TypeClass" c:type="GTypeClass*"/>
        </parameter>
        <parameter name="is_a_type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_instance" c:identifier="g_type_check_instance">
      <doc xml:whitespace="preserve">Private helper function to aid implementation of the G_TYPE_CHECK_INSTANCE()
macro.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">A valid #GTypeInstance structure.</doc>
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_instance_cast"
              c:identifier="g_type_check_instance_cast"
              introspectable="0">
      <return-value>
        <type name="TypeInstance" c:type="GTypeInstance*"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
        <parameter name="iface_type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_instance_is_a"
              c:identifier="g_type_check_instance_is_a">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
        <parameter name="iface_type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_is_value_type"
              c:identifier="g_type_check_is_value_type">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_value" c:identifier="g_type_check_value">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_check_value_holds"
              c:identifier="g_type_check_value_holds">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="Value" c:type="GValue*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_children" c:identifier="g_type_children">
      <doc xml:whitespace="preserve">Return a newly allocated and 0-terminated array of type IDs, listing the
child types of @type. The return value has to be g_free()ed after use.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">Newly allocated and 0-terminated array of child types.</doc>
        <type name="GType" c:type="GType*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The parent type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_children" transfer-ownership="none">
          <doc xml:whitespace="preserve">Optional #guint pointer to contain the number of child types.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_class_add_private"
              c:identifier="g_type_class_add_private"
              version="2.4">
      <doc xml:whitespace="preserve">Registers a private structure for an instantiatable type.
When an object is allocated, the private structures for
the type and all of its parent types are allocated
sequentially in the same memory block as the public
structures.
Note that the accumulated size of the private structures of
a type and all its parent types cannot excced 64kB.
This function should be called in the type's class_init() function.
The private structure can be retrieved using the
G_TYPE_INSTANCE_GET_PRIVATE() macro.
The following example shows attaching a private structure
&lt;structname&gt;MyObjectPrivate&lt;/structname&gt; to an object
&lt;structname&gt;MyObject&lt;/structname&gt; defined in the standard GObject
fashion.
type's class_init() function.
|[
typedef struct _MyObject        MyObject;
typedef struct _MyObjectPrivate MyObjectPrivate;
struct _MyObject {
GObject parent;
MyObjectPrivate *priv;
};
struct _MyObjectPrivate {
int some_field;
};
static void
my_object_class_init (MyObjectClass *klass)
{
g_type_class_add_private (klass, sizeof (MyObjectPrivate));
}
static void
my_object_init (MyObject *my_object)
{
my_object-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (my_object,
MY_TYPE_OBJECT,
MyObjectPrivate);
}
static int
my_object_get_some_field (MyObject *my_object)
{
MyObjectPrivate *priv = my_object-&gt;priv;
return priv-&gt;some_field;
}
]|</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">class structure for an instantiatable type</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="private_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">size of private structure.</doc>
          <type name="gulong" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_class_peek"
              c:identifier="g_type_class_peek"
              introspectable="0">
      <doc xml:whitespace="preserve">This function is essentially the same as g_type_class_ref(), except that
the classes reference count isn't incremented. As a consequence, this function
may return %NULL if the class of the type passed in does not currently
exist (hasn't been referenced before).
if the class does not currently exist.</doc>
      <return-value>
        <doc xml:whitespace="preserve">The #GTypeClass structure for the given type ID or %NULL</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Type ID of a classed type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_class_peek_parent"
              c:identifier="g_type_class_peek_parent"
              introspectable="0">
      <doc xml:whitespace="preserve">This is a convenience function often needed in class initializers.
It returns the class structure of the immediate parent type of the
class passed in.  Since derived classes hold a reference count on
their parent classes as long as they are instantiated, the returned
class will always exist. This function is essentially equivalent
to:
&lt;programlisting&gt;
g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)));
&lt;/programlisting&gt;</doc>
      <return-value>
        <doc xml:whitespace="preserve">The parent class of @g_class.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypeClass structure to retrieve the parent class for.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_class_peek_static"
              c:identifier="g_type_class_peek_static"
              version="2.4"
              introspectable="0">
      <doc xml:whitespace="preserve">A more efficient version of g_type_class_peek() which works only for
static types.
if the class does not currently exist or is dynamically loaded.</doc>
      <return-value>
        <doc xml:whitespace="preserve">The #GTypeClass structure for the given type ID or %NULL</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Type ID of a classed type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_class_ref"
              c:identifier="g_type_class_ref"
              introspectable="0">
      <doc xml:whitespace="preserve">Increments the reference count of the class structure belonging to
exist already.</doc>
      <return-value>
        <doc xml:whitespace="preserve">The #GTypeClass structure for the given type ID.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Type ID of a classed type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_class_unref" c:identifier="g_type_class_unref">
      <doc xml:whitespace="preserve">Decrements the reference count of the class structure being passed in.
Once the last reference count of a class has been released, classes
may be finalized by the type system, so further dereferencing of a
class pointer after g_type_class_unref() are invalid.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypeClass structure to unreference.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_class_unref_uncached"
              c:identifier="g_type_class_unref_uncached">
      <doc xml:whitespace="preserve">A variant of g_type_class_unref() for use in #GTypeClassCacheFunc
implementations. It unreferences a class without consulting the chain
of #GTypeClassCacheFunc&lt;!-- --&gt;s, avoiding the recursion which would occur
otherwise.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypeClass structure to unreference.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_create_instance"
              c:identifier="g_type_create_instance"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates and initializes an instance of @type if @type is valid and
can be instantiated. The type system only performs basic allocation
happen through functions supplied by the type's fundamental type
implementation.  So use of g_type_create_instance() is reserved for
implementators of fundamental types only. E.g. instances of the
#GObject hierarchy should be created via g_object_new() and
&lt;emphasis&gt;never&lt;/emphasis&gt; directly through
g_type_create_instance() which doesn't handle things like singleton
use this function, unless you're implementing a fundamental
type. Also language bindings should &lt;emphasis&gt;not&lt;/emphasis&gt; use
this function but g_object_new() instead.
treatment by the fundamental type implementation.</doc>
      <return-value>
        <doc xml:whitespace="preserve">An allocated and initialized instance, subject to further</doc>
        <type name="TypeInstance" c:type="GTypeInstance*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instantiatable type to create an instance for.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_default_interface_peek"
              c:identifier="g_type_default_interface_peek"
              version="2.4"
              introspectable="0">
      <doc xml:whitespace="preserve">If the interface type @g_type is currently in use, returns its
default interface vtable.
if the type is not currently in use.</doc>
      <return-value>
        <doc xml:whitespace="preserve">the default vtable for the interface, or %NULL</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="g_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">an interface type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_default_interface_ref"
              c:identifier="g_type_default_interface_ref"
              version="2.4"
              introspectable="0">
      <doc xml:whitespace="preserve">Increments the reference count for the interface type @g_type,
and returns the default interface vtable for the type.
If the type is not currently in use, then the default vtable
for the type will be created and initalized by calling
the base interface init and default vtable init functions for
the type (the @&lt;structfield&gt;base_init&lt;/structfield&gt;
and &lt;structfield&gt;class_init&lt;/structfield&gt; members of #GTypeInfo).
Calling g_type_default_interface_ref() is useful when you
want to make sure that signals and properties for an interface
have been installed.
g_type_default_interface_unref() when you are done using
the interface.</doc>
      <return-value>
        <doc xml:whitespace="preserve">the default vtable for the interface; call</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="g_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">an interface type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_default_interface_unref"
              c:identifier="g_type_default_interface_unref"
              version="2.4">
      <doc xml:whitespace="preserve">Decrements the reference count for the type corresponding to the
interface default vtable @g_iface. If the type is dynamic, then
when no one is using the interface and all references have
been released, the finalize function for the interface's default
vtable (the &lt;structfield&gt;class_finalize&lt;/structfield&gt; member of
#GTypeInfo) will be called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">the default vtable structure for a interface, as returned by g_type_default_interface_ref()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_depth" c:identifier="g_type_depth">
      <doc xml:whitespace="preserve">Returns the length of the ancestry of the passed in type. This
includes the type itself, so that e.g. a fundamental type has depth 1.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The depth of @type.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GType value.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_free_instance" c:identifier="g_type_free_instance">
      <doc xml:whitespace="preserve">Frees an instance of a type, returning it to the instance pool for
the type, if there is one.
Like g_type_create_instance(), this function is reserved for
implementors of fundamental types.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <doc xml:whitespace="preserve">an instance of a type.</doc>
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_from_name" c:identifier="g_type_from_name">
      <doc xml:whitespace="preserve">Lookup the type ID from a given type name, returning 0 if no type
has been registered under this name (this is the preferred method
to find out by name whether a specific type has been registered
yet).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">Corresponding type ID or 0.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">Type name to lookup.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_fundamental" c:identifier="g_type_fundamental">
      <doc xml:whitespace="preserve">Internal function, used to extract the fundamental type ID portion.
use G_TYPE_FUNDAMENTAL() instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">fundamental type ID</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="type_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">valid type ID</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_fundamental_next"
              c:identifier="g_type_fundamental_next">
      <doc xml:whitespace="preserve">Returns the next free fundamental type id which can be used to
register a new fundamental type with g_type_register_fundamental().
The returned type ID represents the highest currently registered
fundamental type identifier.
or 0 if the type system ran out of fundamental type IDs.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The nextmost fundamental type ID to be registered,</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="type_get_plugin"
              c:identifier="g_type_get_plugin"
              introspectable="0">
      <doc xml:whitespace="preserve">Returns the #GTypePlugin structure for @type or
%NULL if @type does not have a #GTypePlugin structure.
%NULL otherwise.</doc>
      <return-value>
        <doc xml:whitespace="preserve">The corresponding plugin if @type is a dynamic type,</doc>
        <type name="TypePlugin" c:type="GTypePlugin*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GType to retrieve the plugin for.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_get_qdata"
              c:identifier="g_type_get_qdata"
              introspectable="0">
      <doc xml:whitespace="preserve">Obtains data which has previously been attached to @type
with g_type_set_qdata().</doc>
      <return-value>
        <doc xml:whitespace="preserve">the data, or %NULL if no data was found</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="quark" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GQuark id to identify the data</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_init" c:identifier="g_type_init">
      <doc xml:whitespace="preserve">Prior to any use of the type system, g_type_init() has to be called
to initialize the type system and assorted other code portions
(such as the various fundamental type implementations or the signal
system).
Since version 2.24 this also initializes the thread system</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="type_init_with_debug_flags"
              c:identifier="g_type_init_with_debug_flags">
      <doc xml:whitespace="preserve">Similar to g_type_init(), but additionally sets debug flags.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="debug_flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">Bitwise combination of #GTypeDebugFlags values for debugging purposes.</doc>
          <type name="TypeDebugFlags" c:type="GTypeDebugFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interface_add_prerequisite"
              c:identifier="g_type_interface_add_prerequisite">
      <doc xml:whitespace="preserve">Adds @prerequisite_type to the list of prerequisites of @interface_type.
This means that any type implementing @interface_type must also implement
interface derivation (which GType doesn't support). An interface can have
at most one instantiatable prerequisite type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GType value of an interface type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="prerequisite_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GType value of an interface or instantiatable type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interface_get_plugin"
              c:identifier="g_type_interface_get_plugin"
              introspectable="0">
      <doc xml:whitespace="preserve">Returns the #GTypePlugin structure for the dynamic interface
have a #GTypePlugin structure. See g_type_add_interface_dynamic().
of @instance_type.</doc>
      <return-value>
        <doc xml:whitespace="preserve">the #GTypePlugin for the dynamic interface @interface_type</doc>
        <type name="TypePlugin" c:type="GTypePlugin*"/>
      </return-value>
      <parameters>
        <parameter name="instance_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType value of an instantiatable type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType value of an interface type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interface_peek"
              c:identifier="g_type_interface_peek"
              introspectable="0">
      <doc xml:whitespace="preserve">Returns the #GTypeInterface structure of an interface to which the
passed in class conforms.
by @instance_class, %NULL otherwise</doc>
      <return-value>
        <doc xml:whitespace="preserve">The GTypeInterface structure of iface_type if implemented</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="instance_class" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GTypeClass structure.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">An interface ID which this class conforms to.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interface_peek_parent"
              c:identifier="g_type_interface_peek_parent"
              introspectable="0">
      <doc xml:whitespace="preserve">Returns the corresponding #GTypeInterface structure of the parent type
of the instance type to which @g_iface belongs. This is useful when
deriving the implementation of an interface from the parent type and
then possibly overriding some methods.
type of the instance type to which @g_iface belongs, or
%NULL if the parent type doesn't conform to the interface.</doc>
      <return-value>
        <doc xml:whitespace="preserve">The corresponding #GTypeInterface structure of the parent</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GTypeInterface structure.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interface_prerequisites"
              c:identifier="g_type_interface_prerequisites"
              version="2.2">
      <doc xml:whitespace="preserve">Returns the prerequisites of an interfaces type.
the prerequisites of @interface_type</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a newly-allocated zero-terminated array of #GType containing</doc>
        <type name="GType" c:type="GType*"/>
      </return-value>
      <parameters>
        <parameter name="interface_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">an interface type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_prerequisites" transfer-ownership="none">
          <doc xml:whitespace="preserve">location to return the number of prerequisites, or %NULL</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_interfaces" c:identifier="g_type_interfaces">
      <doc xml:whitespace="preserve">Return a newly allocated and 0-terminated array of type IDs, listing the
interface types that @type conforms to. The return value has to be
g_free()ed after use.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">Newly allocated and 0-terminated array of interface types.</doc>
        <type name="GType" c:type="GType*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type to list interface types for.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="n_interfaces" transfer-ownership="none">
          <doc xml:whitespace="preserve">Optional #guint pointer to contain the number of interface types.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_is_a" c:identifier="g_type_is_a">
      <doc xml:whitespace="preserve">If @is_a_type is a derivable type, check whether @type is a
descendant of @is_a_type.  If @is_a_type is an interface, check
whether @type conforms to it.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @type is_a @is_a_type holds true.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Type to check anchestry for.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="is_a_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Possible anchestor of @type or interface @type could conform to.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_name" c:identifier="g_type_name">
      <doc xml:whitespace="preserve">Get the unique name that is assigned to a type ID.  Note that this
function (like all other GType API) cannot cope with invalid type
IDs. %G_TYPE_INVALID may be passed to this function, as may be any
other validly registered type ID, but randomized type IDs should
not be passed in and will most likely lead to a crash.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">Static type name or %NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Type to return name for.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_name_from_class"
              c:identifier="g_type_name_from_class">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none">
          <type name="TypeClass" c:type="GTypeClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_name_from_instance"
              c:identifier="g_type_name_from_instance">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none">
          <type name="TypeInstance" c:type="GTypeInstance*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_next_base" c:identifier="g_type_next_base">
      <doc xml:whitespace="preserve">Given a @leaf_type and a @root_type which is contained in its
anchestry, return the type that @root_type is the immediate parent
of.  In other words, this function determines the type that is
derived directly from @root_type which is also a base class of
be used to determine the types and order in which the leaf type is
descended from the root type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">Immediate child of @root_type and anchestor of @leaf_type.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="leaf_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Descendant of @root_type and the type to be returned.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="root_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Immediate parent of the returned type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_parent" c:identifier="g_type_parent">
      <doc xml:whitespace="preserve">Return the direct parent type of the passed in type.  If the passed
in type has no parent, i.e. is a fundamental type, 0 is returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The parent type.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The derived type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_qname" c:identifier="g_type_qname">
      <doc xml:whitespace="preserve">Get the corresponding quark of the type IDs name.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The type names quark or 0.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Type to return quark of type name for.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_query" c:identifier="g_type_query">
      <doc xml:whitespace="preserve">Queries the type system for information about a specific type.
This function will fill in a user-provided structure to hold
type-specific information. If an invalid #GType is passed in, the
#GTypeQuery structure should be considered constant and have to be
left untouched.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType value of a static, classed type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="query" transfer-ownership="none">
          <doc xml:whitespace="preserve">A user provided structure that is filled in with constant values upon success.</doc>
          <type name="TypeQuery" c:type="GTypeQuery*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_register_dynamic"
              c:identifier="g_type_register_dynamic">
      <doc xml:whitespace="preserve">Registers @type_name as the name of a new dynamic type derived from
#GTypePlugin structure pointed to by @plugin to manage the type and its
instances (if not abstract).  The value of @flags determines the nature
(e.g. abstract or not) of the type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The new type identifier or #G_TYPE_INVALID if registration failed.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="parent_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Type from which this type will be derived.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="type_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">0-terminated string used as the name of the new type.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypePlugin structure to retrieve the #GTypeInfo from.</doc>
          <type name="TypePlugin" c:type="GTypePlugin*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">Bitwise combination of #GTypeFlags values.</doc>
          <type name="TypeFlags" c:type="GTypeFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_register_fundamental"
              c:identifier="g_type_register_fundamental">
      <doc xml:whitespace="preserve">Registers @type_id as the predefined identifier and @type_name as the
name of a fundamental type.  The type system uses the information
contained in the #GTypeInfo structure pointed to by @info and the
#GTypeFundamentalInfo structure pointed to by @finfo to manage the
type and its instances.  The value of @flags determines additional
characteristics of the fundamental type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The predefined type identifier.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="type_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">A predefined type identifier.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="type_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">0-terminated string used as the name of the new type.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypeInfo structure for this type.</doc>
          <type name="TypeInfo" c:type="GTypeInfo*"/>
        </parameter>
        <parameter name="finfo" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypeFundamentalInfo structure for this type.</doc>
          <type name="TypeFundamentalInfo" c:type="GTypeFundamentalInfo*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">Bitwise combination of #GTypeFlags values.</doc>
          <type name="TypeFlags" c:type="GTypeFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_register_static"
              c:identifier="g_type_register_static">
      <doc xml:whitespace="preserve">Registers @type_name as the name of a new static type derived from
#GTypeInfo structure pointed to by @info to manage the type and its
instances (if not abstract).  The value of @flags determines the nature
(e.g. abstract or not) of the type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The new type identifier.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="parent_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Type from which this type will be derived.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="type_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">0-terminated string used as the name of the new type.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GTypeInfo structure for this type.</doc>
          <type name="TypeInfo" c:type="GTypeInfo*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">Bitwise combination of #GTypeFlags values.</doc>
          <type name="TypeFlags" c:type="GTypeFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_register_static_simple"
              c:identifier="g_type_register_static_simple"
              version="2.12"
              introspectable="0">
      <doc xml:whitespace="preserve">Registers @type_name as the name of a new static type derived from
abstract or not) of the type. It works by filling a #GTypeInfo
struct and calling g_type_register_static().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The new type identifier.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="parent_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Type from which this type will be derived.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="type_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">0-terminated string used as the name of the new type.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="class_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of the class structure (see #GTypeInfo)</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="class_init" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location of the class initialization function (see #GTypeInfo)</doc>
          <type name="ClassInitFunc" c:type="GClassInitFunc"/>
        </parameter>
        <parameter name="instance_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of the instance structure (see #GTypeInfo)</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="instance_init" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location of the instance initialization function (see #GTypeInfo)</doc>
          <type name="InstanceInitFunc" c:type="GInstanceInitFunc"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">Bitwise combination of #GTypeFlags values.</doc>
          <type name="TypeFlags" c:type="GTypeFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_remove_class_cache_func"
              c:identifier="g_type_remove_class_cache_func"
              introspectable="0">
      <doc xml:whitespace="preserve">Removes a previously installed #GTypeClassCacheFunc. The cache
maintained by @cache_func has to be empty when calling
g_type_remove_class_cache_func() to avoid leaks.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cache_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data that was given when adding @cache_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="cache_func" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GTypeClassCacheFunc</doc>
          <type name="TypeClassCacheFunc" c:type="GTypeClassCacheFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_remove_interface_check"
              c:identifier="g_type_remove_interface_check"
              version="2.4"
              introspectable="0">
      <doc xml:whitespace="preserve">Removes an interface check function added with
g_type_add_interface_check().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="check_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">callback data passed to g_type_add_interface_check()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="check_func" transfer-ownership="none">
          <doc xml:whitespace="preserve">callback function passed to g_type_add_interface_check()</doc>
          <type name="TypeInterfaceCheckFunc"
                c:type="GTypeInterfaceCheckFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_set_qdata" c:identifier="g_type_set_qdata">
      <doc xml:whitespace="preserve">Attaches arbitrary data to a type.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="quark" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GQuark id to identify the data</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">the data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_test_flags" c:identifier="g_type_test_flags">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_value_table_peek"
              c:identifier="g_type_value_table_peek"
              introspectable="0">
      <doc xml:whitespace="preserve">Returns the location of the #GTypeValueTable associated with @type.
&lt;emphasis&gt;Note that this function should only be used from source code
that implements or has internal knowledge of the implementation of
%NULL if there is no #GTypeValueTable associated with @type.</doc>
      <return-value>
        <doc xml:whitespace="preserve">Location of the #GTypeValueTable associated with @type or</doc>
        <type name="TypeValueTable" c:type="GTypeValueTable*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GType value.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_c_init" c:identifier="g_value_c_init">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="value_register_transform_func"
              c:identifier="g_value_register_transform_func"
              introspectable="0">
      <doc xml:whitespace="preserve">Registers a value transformation function for use in g_value_transform().
A previously registered transformation function for @src_type and @dest_type
will be replaced.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Source type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="dest_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Target type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="transform_func" transfer-ownership="none">
          <doc xml:whitespace="preserve">a function which transforms values of type @src_type into value of type @dest_type</doc>
          <type name="ValueTransform" c:type="GValueTransform"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_transforms_init"
              c:identifier="g_value_transforms_init">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="value_type_compatible"
              c:identifier="g_value_type_compatible">
      <doc xml:whitespace="preserve">Returns whether a #GValue of type @src_type can be copied into
a #GValue of type @dest_type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if g_value_copy() is possible with @src_type and @dest_type.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="src_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">source type to be copied.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="dest_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">destination type for copying.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_type_transformable"
              c:identifier="g_value_type_transformable">
      <doc xml:whitespace="preserve">Check whether g_value_transform() is able to transform values
of type @src_type into values of type @dest_type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the transformation is possible, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="src_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Source type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="dest_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Target type.</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_types_init" c:identifier="g_value_types_init">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="variant_get_gtype"
              c:identifier="g_variant_get_gtype"
              version="2.24"
              deprecated="2.26">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="variant_type_get_gtype"
              c:identifier="g_variant_type_get_gtype">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
  </namespace>
</repository>
