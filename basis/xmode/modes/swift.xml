<?xml version="1.0"?>
<!-- Transplanted from Scala mode by Daniel Spiewak, see https://github.com/djspiewak/jedit-modes/blob/master/scala.xml -->
<!-- By Wayne Zhang, wayne.zhang.au@gmail.com -->

<!-- Please put the following line in catalog ${JEditInstallDir}/modes -->
<!-- 
	<MODE NAME="swift" FILE="swift.xml"	FILE_NAME_GLOB="*.swift"/>	
-->

<!DOCTYPE MODE SYSTEM "xmode.dtd">

<MODE>
  <PROPS>
    <PROPERTY NAME="indentOpenBrackets" VALUE="{" />
    <PROPERTY NAME="indentCloseBrackets" VALUE="}" />
    <PROPERTY NAME="lineUpClosingBracket" VALUE="true" />
	<PROPERTY NAME="indentNextLine"
		VALUE="(.*((if|while|else\s+if|for)\s*\().*\)|\s*else|\s*case.*:|.*(let|var|typealias).*=)\s*$"/>
    <!-- set this to 'true' if you want to use GNU coding style -->
    <PROPERTY NAME="doubleBracketIndent" VALUE="false" />
    <PROPERTY NAME="commentStart" VALUE="/*" />
    <PROPERTY NAME="commentEnd" VALUE="*/" />
    <PROPERTY NAME="lineComment" VALUE="//" />
    <PROPERTY NAME="noTabs" VALUE="true" />
    <PROPERTY NAME="tabSize" VALUE="4" />
    <PROPERTY NAME="indentSize" VALUE="4" />
    <PROPERTY NAME="wordBreakChars" VALUE=",+-=&lt;&gt;/?^&amp;*" />
  </PROPS>

  <RULES IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"
      DIGIT_RE="(0[lL]?|[1-9]\d{0,9}(\d{0,9}[lL])?|0[xX]\p{XDigit}{1,8}(\p{XDigit}{0,8}[lL])?|0[0-7]{1,11}([0-7]{0,11}[lL])?|([0-9]+\.[0-9]*|\.[0-9]+)([eE][+-]?[0-9]+)?[fFdD]?|[0-9]+([eE][+-]?[0-9]+[fFdD]?|([eE][+-]?[0-9]+)?[fFdD]))">

	<MARK_FOLLOWING TYPE="LABEL">@</MARK_FOLLOWING>

	<IMPORT DELEGATE="PRIMARY"/>
  </RULES>

  <RULES SET="PRIMARY">
    <!-- Silly comment -->
    <SEQ TYPE="COMMENT1">/**/</SEQ>

    <EOL_SPAN TYPE="COMMENT2">//</EOL_SPAN>

    <!-- Scaladoc comment -->
    <SPAN TYPE="COMMENT3" DELEGATE="SCALADOC">
      <BEGIN>/**</BEGIN>
      <END>*/</END>
    </SPAN>

    <!-- Scala comment (Java style) -->
    <SPAN TYPE="COMMENT1" DELEGATE="COMMENT_BLOCK">
      <BEGIN>/*</BEGIN>
      <END>*/</END>
    </SPAN>

    <SPAN MATCH_TYPE="NULL" DELEGATE="MAIN">
      <BEGIN>{</BEGIN>
      <END>}</END>
    </SPAN>

    <!-- string and character literals -->
    <SPAN TYPE="LITERAL1" NO_LINE_BREAK="TRUE" ESCAPE="\" DELEGATE="EXP_IN_STRING">
      <BEGIN>"</BEGIN>
      <END>"</END>
    </SPAN>

    <SPAN MATCH_TYPE="LITERAL3" DELEGATE="TYPE_PARAMS" NO_LINE_BREAK="TRUE">
	  <BEGIN>&lt;</BEGIN>
	  <END>&gt;</END>
	</SPAN>

	<SEQ TYPE="OPERATOR">~</SEQ>
	<SEQ TYPE="OPERATOR">!</SEQ>
	<SEQ TYPE="OPERATOR">%</SEQ>
	<SEQ TYPE="OPERATOR">^</SEQ>
	<SEQ TYPE="OPERATOR">*</SEQ>
	<SEQ TYPE="OPERATOR">-</SEQ>
	<SEQ TYPE="OPERATOR">+</SEQ>
	<SEQ TYPE="OPERATOR">=</SEQ>
	<SEQ TYPE="OPERATOR">|</SEQ>
	<SEQ TYPE="OPERATOR">/</SEQ>
	<SEQ TYPE="OPERATOR">.</SEQ>
	<SEQ TYPE="OPERATOR">??</SEQ>
	<SEQ TYPE="OPERATOR">&amp;</SEQ>
	<SEQ TYPE="OPERATOR">&gt;</SEQ>
	<SEQ TYPE="OPERATOR">&lt;</SEQ>

    <!-- Function calls -->
    <MARK_PREVIOUS TYPE="FUNCTION" MATCH_TYPE="OPERATOR">(</MARK_PREVIOUS>

    <EOL_SPAN MATCH_TYPE="KEYWORD1" DELEGATE="TYPE">import </EOL_SPAN>

	<!-- Function declarations (overloaded for different spacing styles)-->
	<MARK_FOLLOWING TYPE="FUNCTION" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">func       </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="FUNCTION" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">func      </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="FUNCTION" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">func     </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="FUNCTION" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">func    </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="FUNCTION" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">func   </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="FUNCTION" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">func  </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="FUNCTION" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">func </MARK_FOLLOWING>

	<!-- class declarations (overloaded for different spacing styles)-->
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">class       </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">class      </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">class     </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">class    </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">class   </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">class  </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">class </MARK_FOLLOWING>

	<!-- struct declarations (overloaded for different spacing styles)-->
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">struct       </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">struct      </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">struct     </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">struct    </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">struct   </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">struct  </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">struct </MARK_FOLLOWING>
	
	<!-- enum declarations (overloaded for different spacing styles)-->
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">enum       </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">enum      </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">enum     </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">enum    </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">enum   </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">enum  </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">enum </MARK_FOLLOWING>	
	
	<!-- protocol declarations (overloaded for different spacing styles)-->
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">protocol       </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">protocol      </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">protocol     </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">protocol    </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">protocol   </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">protocol  </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD3" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE">protocol </MARK_FOLLOWING>		

	<!-- extends (overloaded for different spacing styles)-->
	<MARK_FOLLOWING TYPE="KEYWORD4" MATCH_TYPE="KEYWORD1" AT_WORD_START="FALSE">:       </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD4" MATCH_TYPE="KEYWORD1" AT_WORD_START="FALSE">:      </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD4" MATCH_TYPE="KEYWORD1" AT_WORD_START="FALSE">:     </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD4" MATCH_TYPE="KEYWORD1" AT_WORD_START="FALSE">:    </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD4" MATCH_TYPE="KEYWORD1" AT_WORD_START="FALSE">:   </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD4" MATCH_TYPE="KEYWORD1" AT_WORD_START="FALSE">:  </MARK_FOLLOWING>
	<MARK_FOLLOWING TYPE="KEYWORD4" MATCH_TYPE="KEYWORD1" AT_WORD_START="FALSE">: </MARK_FOLLOWING>


	<SPAN DELEGATE="PATTERN" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE" NO_LINE_BREAK="FALSE">
		<BEGIN>case </BEGIN>
		<END>:</END>
	</SPAN>

	<SPAN DELEGATE="PATTERN" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE" NO_LINE_BREAK="TRUE">
		<BEGIN>let </BEGIN>
		<END>=</END>
	</SPAN>
	
	<!-- collections -->
	<SPAN DELEGATE="PATTERN" MATCH_TYPE="KEYWORD1" AT_WORD_START="TRUE" NO_LINE_BREAK="FALSE">
		<BEGIN>[</BEGIN>
		<END>]</END>
	</SPAN>
		
	<!-- variables and function parameters types -->
	<SPAN_REGEXP HASH_CHAR=":" TYPE="LABEL" NO_LINE_BREAK="TRUE">
		<BEGIN>:\s+</BEGIN>
		<END>\b</END>
	</SPAN_REGEXP>	
	
    <KEYWORDS>
      <KEYWORD1>associatedtype</KEYWORD1>
      <KEYWORD1>atexit</KEYWORD1>
      <KEYWORD1>break</KEYWORD1>
      <KEYWORD1>case</KEYWORD1>
      <KEYWORD1>catch</KEYWORD1>
      <KEYWORD1>class</KEYWORD1>
      <KEYWORD1>continue</KEYWORD1>
      <KEYWORD1>convenience</KEYWORD1>
      <KEYWORD1>default</KEYWORD1>
      <KEYWORD1>defer</KEYWORD1>
      <KEYWORD1>deinit</KEYWORD1>
      <KEYWORD1>didSet</KEYWORD1>
      <KEYWORD1>do</KEYWORD1>
      <KEYWORD1>dynamic</KEYWORD1>
      <KEYWORD1>else</KEYWORD1>
      <KEYWORD1>enum</KEYWORD1>
      <KEYWORD1>extension</KEYWORD1>
      <KEYWORD1>fallthrough</KEYWORD1>
      <KEYWORD1>final</KEYWORD1>
      <KEYWORD1>for</KEYWORD1>
      <KEYWORD1>func</KEYWORD1>
      <KEYWORD1>get</KEYWORD1>
      <KEYWORD1>guard</KEYWORD1>
      <KEYWORD1>if</KEYWORD1>
      <KEYWORD1>import</KEYWORD1>
      <KEYWORD1>in</KEYWORD1>
      <KEYWORD1>infix</KEYWORD1>
      <KEYWORD1>init</KEYWORD1>
      <KEYWORD1>inout</KEYWORD1>
      <KEYWORD1>internal</KEYWORD1>
      <KEYWORD1>lazy</KEYWORD1>
      <KEYWORD1>let</KEYWORD1>
      <KEYWORD1>mutating</KEYWORD1>
      <KEYWORD1>nil</KEYWORD1>
      <KEYWORD1>nonmutating</KEYWORD1>
      <KEYWORD1>operator</KEYWORD1>
      <KEYWORD1>optional</KEYWORD1>
      <KEYWORD1>override</KEYWORD1>
      <KEYWORD1>postfix</KEYWORD1>
      <KEYWORD1>prefix</KEYWORD1>
      <KEYWORD1>private</KEYWORD1>
      <KEYWORD1>protocol</KEYWORD1>
      <KEYWORD1>public</KEYWORD1>
      <KEYWORD1>repeat</KEYWORD1>
      <KEYWORD1>required</KEYWORD1>
      <KEYWORD1>rethrows</KEYWORD1>
      <KEYWORD1>return</KEYWORD1>
      <KEYWORD1>self</KEYWORD1>
      <KEYWORD1>set</KEYWORD1>
      <KEYWORD1>static</KEYWORD1>
      <KEYWORD1>struct</KEYWORD1>
      <KEYWORD1>subscript</KEYWORD1>
      <KEYWORD1>super</KEYWORD1>
      <KEYWORD1>switch</KEYWORD1>
      <KEYWORD1>throw</KEYWORD1>
      <KEYWORD1>throws</KEYWORD1>
      <KEYWORD1>try</KEYWORD1>
      <KEYWORD1>typealias</KEYWORD1>
      <KEYWORD1>unowned</KEYWORD1>
      <KEYWORD1>var</KEYWORD1>
      <KEYWORD1>weak</KEYWORD1>
      <KEYWORD1>where</KEYWORD1>
      <KEYWORD1>while</KEYWORD1>
      <KEYWORD1>willSet</KEYWORD1>

      <KEYWORD2>Character</KEYWORD2>
      <KEYWORD2>String</KEYWORD2>
      <KEYWORD2>Bool</KEYWORD2>
      <KEYWORD2>Double</KEYWORD2>
      <KEYWORD2>Float</KEYWORD2>
      <KEYWORD2>Int</KEYWORD2>

      <KEYWORD3>Arry</KEYWORD3>
      <KEYWORD3>Set</KEYWORD3>
      <KEYWORD3>Dictionary</KEYWORD3>

	  <LITERAL2>false</LITERAL2>
	  <LITERAL2>nil</LITERAL2>
	  <LITERAL2>super</LITERAL2>
	  <LITERAL2>self</LITERAL2>
	  <LITERAL2>true</LITERAL2>
    </KEYWORDS>
  </RULES>

  <RULES SET="TYPE_PARAMS" DEFAULT="LITERAL3">
    <SPAN MATCH_TYPE="LITERAL3" DELEGATE="TYPE_PARAMS">
      <BEGIN>&lt;</BEGIN>
      <END>&gt;</END>
    </SPAN>
  </RULES>

  <RULES SET="PATTERN" DEFAULT="NULL" IGNORE_CASE="FALSE"
    DIGIT_RE="(0[lL]?|[1-9]\d{0,9}(\d{0,9}[lL])?|0[xX]\p{XDigit}{1,8}(\p{XDigit}{0,8}[lL])?|0[0-7]{1,11}([0-7]{0,11}[lL])?|([0-9]+\.[0-9]*|\.[0-9]+)([eE][+-]?[0-9]+)?[fFdD]?|[0-9]+([eE][+-]?[0-9]+[fFdD]?|([eE][+-]?[0-9]+)?[fFdD]))">

    <IMPORT DELEGATE="PRIMARY"/>

    <SEQ TYPE="OPERATOR">@</SEQ>

    <SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD4">[A-Z][^(\s:@)&lt;&gt;]*</SEQ_REGEXP>
  </RULES>

  <RULES SET="COMMENT_BLOCK" DEFAULT="COMMENT1">
    <SPAN TYPE="COMMENT1" DELEGATE="COMMENT_BLOCK">
      <BEGIN>/*</BEGIN>
      <END>*/</END>
    </SPAN>
  </RULES>

  <RULES SET="TYPE" DEFAULT="KEYWORD4">
    <IMPORT DELEGATE="MAIN"/>
  </RULES>
  
  <RULES SET="EXP_IN_STRING" DEFAULT="LITERAL1">
	<SPAN TYPE="LABEL" MATCH_TYPE="KEYWORD4">
      <BEGIN>\(</BEGIN>
      <END>)</END>
    </SPAN>  
  </RULES>
</MODE>
