<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gst" version="0.10"/>
  <include name="GstBase" version="0.10"/>
  <include name="libxml2" version="2.0"/>
  <package name="gstreamer-app-0.10"/>
  <c:include name="gst/app/gstappbuffer.h"/>
  <c:include name="gst/app/gstappsink.h"/>
  <c:include name="gst/app/gstappsrc.h"/>
  <namespace name="GstApp"
             version="0.10"
             shared-library="libgstapp-0.10.so.0"
             c:identifier-prefixes="Gst"
             c:symbol-prefixes="gst">
    <class name="AppBuffer"
           c:symbol-prefix="app_buffer"
           c:type="GstAppBuffer"
           parent="Gst.Buffer"
           glib:type-name="GstAppBuffer"
           glib:get-type="gst_app_buffer_get_type"
           glib:type-struct="AppBufferClass"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="gst_app_buffer_new"
                   introspectable="0">
        <return-value transfer-ownership="full">
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="finalize" transfer-ownership="none">
            <type name="AppBufferFinalizeFunc"
                  c:type="GstAppBufferFinalizeFunc"/>
          </parameter>
          <parameter name="priv" transfer-ownership="none">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="buffer">
        <type name="Gst.Buffer" c:type="GstBuffer"/>
      </field>
      <field name="finalize">
        <type name="AppBufferFinalizeFunc" c:type="GstAppBufferFinalizeFunc"/>
      </field>
      <field name="priv">
        <type name="gpointer" c:type="void*"/>
      </field>
    </class>
    <record name="AppBufferClass"
            c:type="GstAppBufferClass"
            glib:is-gtype-struct-for="AppBuffer">
      <field name="buffer_class">
        <type name="Gst.BufferClass" c:type="GstBufferClass"/>
      </field>
    </record>
    <callback name="AppBufferFinalizeFunc" c:type="GstAppBufferFinalizeFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="priv" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="AppSink"
           c:symbol-prefix="app_sink"
           c:type="GstAppSink"
           parent="GstBase.BaseSink"
           glib:type-name="GstAppSink"
           glib:get-type="gst_app_sink_get_type"
           glib:type-struct="AppSinkClass">
      <implements name="Gst.URIHandler"/>
      <method name="get_caps"
              c:identifier="gst_app_sink_get_caps"
              version="0.10.22">
        <doc xml:whitespace="preserve">Get the configured caps on @appsink.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstCaps accepted by the sink. gst_caps_unref() after usage.</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_drop"
              c:identifier="gst_app_sink_get_drop"
              version="0.10.22">
        <doc xml:whitespace="preserve">Check if @appsink will drop old buffers when the maximum amount of queued
buffers is reached.
filled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @appsink is dropping old buffers when the queue is</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_emit_signals"
              c:identifier="gst_app_sink_get_emit_signals"
              version="0.10.22">
        <doc xml:whitespace="preserve">Check if appsink will emit the "new-preroll" and "new-buffer" signals.
signals.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @appsink is emiting the "new-preroll" and "new-buffer"</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_max_buffers"
              c:identifier="gst_app_sink_get_max_buffers"
              version="0.10.22">
        <doc xml:whitespace="preserve">Get the maximum amount of buffers that can be queued in @appsink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The maximum amount of buffers that can be queued.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="is_eos"
              c:identifier="gst_app_sink_is_eos"
              version="0.10.22">
        <doc xml:whitespace="preserve">Check if @appsink is EOS, which is when no more buffers can be pulled because
an EOS event was received.
This function also returns %TRUE when the appsink is not in the PAUSED or
PLAYING state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if no more buffers can be pulled and the appsink is EOS.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="pull_buffer"
              c:identifier="gst_app_sink_pull_buffer"
              version="0.10.22"
              introspectable="0">
        <doc xml:whitespace="preserve">This function blocks until a buffer or EOS becomes available or the appsink
element is set to the READY/NULL state. 
This function will only return buffers when the appsink is in the PLAYING
state. All rendered buffers will be put in a queue so that the application
can pull buffers at its own rate. Note that when the application does not
pull buffers fast enough, the queued buffers could consume a lot of memory,
especially when dealing with raw video frames.
If an EOS event was received before any buffers, this function returns
%NULL. Use gst_app_sink_is_eos () to check for the EOS condition.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a #GstBuffer or NULL when the appsink is stopped or EOS.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="pull_buffer_list"
              c:identifier="gst_app_sink_pull_buffer_list"
              introspectable="0">
        <doc xml:whitespace="preserve">This function blocks until a buffer list or EOS becomes available or the
appsink element is set to the READY/NULL state. 
This function will only return buffer lists when the appsink is in the
PLAYING state. All rendered buffer lists will be put in a queue so that
the application can pull buffer lists at its own rate. Note that when
the application does not pull buffer lists fast enough, the queued buffer
lists could consume a lot of memory, especially when dealing with raw
video frames.
If an EOS event was received before any buffer lists, this function returns
%NULL. Use gst_app_sink_is_eos () to check for the EOS condition.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a #GstBufferList or NULL when the appsink is stopped or EOS.</doc>
          <type name="Gst.BufferList" c:type="GstBufferList*"/>
        </return-value>
      </method>
      <method name="pull_preroll"
              c:identifier="gst_app_sink_pull_preroll"
              version="0.10.22"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the last preroll buffer in @appsink. This was the buffer that caused the
appsink to preroll in the PAUSED state. This buffer can be pulled many times
and remains available to the application even after EOS.
This function is typically used when dealing with a pipeline in the PAUSED
state. Calling this function after doing a seek will give the buffer right
after the seek position.
Note that the preroll buffer will also be returned as the first buffer
when calling gst_app_sink_pull_buffer().
If an EOS event was received before any buffers, this function returns
%NULL. Use gst_app_sink_is_eos () to check for the EOS condition. 
This function blocks until a preroll buffer or EOS is received or the appsink
element is set to the READY/NULL state.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a #GstBuffer or NULL when the appsink is stopped or EOS.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="set_callbacks"
              c:identifier="gst_app_sink_set_callbacks"
              version="0.10.23">
        <doc xml:whitespace="preserve">Set callbacks which will be executed for each new preroll, new buffer and eos.
This is an alternative to using the signals, it has lower overhead and is thus
less expensive, but also less flexible.
If callbacks are installed, no signals will be emited for performance
reasons.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callbacks" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callbacks</doc>
            <type name="AppSinkCallbacks" c:type="GstAppSinkCallbacks*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a user_data argument for the callbacks</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">a destroy notify function</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_caps"
              c:identifier="gst_app_sink_set_caps"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the capabilities on the appsink element.  This function takes
a copy of the caps structure. After calling this method, the sink will only
accept caps that match @caps. If @caps is non-fixed, you must check the caps
on the buffers to get the actual used caps.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">caps to set</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drop"
              c:identifier="gst_app_sink_set_drop"
              version="0.10.22">
        <doc xml:whitespace="preserve">Instruct @appsink to drop old buffers when the maximum amount of queued
buffers is reached.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="drop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_emit_signals"
              c:identifier="gst_app_sink_set_emit_signals"
              version="0.10.22">
        <doc xml:whitespace="preserve">Make appsink emit the "new-preroll" and "new-buffer" signals. This option is
by default disabled because signal emission is expensive and unneeded when
the application prefers to operate in pull mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="emit" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_buffers"
              c:identifier="gst_app_sink_set_max_buffers"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the maximum amount of buffers that can be queued in @appsink. After this
amount of buffers are queued in appsink, any more buffers will block upstream
elements until a buffer is pulled from @appsink.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="max" transfer-ownership="none">
            <doc xml:whitespace="preserve">the maximum number of buffers to queue</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <property name="caps" writable="1" transfer-ownership="none">
        <type name="Gst.Caps"/>
      </property>
      <property name="drop" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="emit-signals" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="eos" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="max-buffers" writable="1" transfer-ownership="none">
        <type name="guint"/>
      </property>
      <field name="basesink">
        <type name="GstBase.BaseSink" c:type="GstBaseSink"/>
      </field>
      <field name="priv">
        <type name="AppSinkPrivate" c:type="GstAppSinkPrivate*"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="eos">
        <doc xml:whitespace="preserve">Signal that the end-of-stream has been reached. This signal is emited from
the steaming thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="new-buffer">
        <doc xml:whitespace="preserve">Signal that a new buffer is available.
This signal is emited from the steaming thread and only when the
"emit-signals" property is %TRUE. 
The new buffer can be retrieved with the "pull-buffer" action
signal or gst_app_sink_pull_buffer() either from this signal callback
or from any other thread.
Note that this signal is only emited when the "emit-signals" property is
set to %TRUE, which it is not by default for performance reasons.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="new-buffer-list">
        <doc xml:whitespace="preserve">Signal that a new bufferlist is available.
This signal is emited from the steaming thread and only when the
"emit-signals" property is %TRUE. 
The new buffer can be retrieved with the "pull-buffer-list" action
signal or gst_app_sink_pull_buffer_list() either from this signal callback
or from any other thread.
Note that this signal is only emited when the "emit-signals" property is
set to %TRUE, which it is not by default for performance reasons.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="new-preroll">
        <doc xml:whitespace="preserve">Signal that a new preroll buffer is available. 
This signal is emited from the steaming thread and only when the
"emit-signals" property is %TRUE. 
The new preroll buffer can be retrieved with the "pull-preroll" action
signal or gst_app_sink_pull_preroll() either from this signal callback
or from any other thread.
Note that this signal is only emited when the "emit-signals" property is
set to %TRUE, which it is not by default for performance reasons.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="pull-buffer" introspectable="0">
        <doc xml:whitespace="preserve">This function blocks until a buffer or EOS becomes available or the appsink
element is set to the READY/NULL state. 
This function will only return buffers when the appsink is in the PLAYING
state. All rendered buffers will be put in a queue so that the application
can pull buffers at its own rate. 
Note that when the application does not pull buffers fast enough, the
queued buffers could consume a lot of memory, especially when dealing with
raw video frames. It's possible to control the behaviour of the queue with
the "drop" and "max-buffers" properties.
If an EOS event was received before any buffers, this function returns
%NULL. Use gst_app_sink_is_eos () to check for the EOS condition.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a #GstBuffer or NULL when the appsink is stopped or EOS.</doc>
          <type name="Gst.Buffer"/>
        </return-value>
      </glib:signal>
      <glib:signal name="pull-buffer-list" introspectable="0">
        <doc xml:whitespace="preserve">This function blocks until a buffer list or EOS becomes available or the appsink
element is set to the READY/NULL state. 
This function will only return bufferlists when the appsink is in the PLAYING
state. All rendered bufferlists will be put in a queue so that the application
can pull bufferlists at its own rate. 
Note that when the application does not pull bufferlists fast enough, the
queued bufferlists could consume a lot of memory, especially when dealing with
raw video frames. It's possible to control the behaviour of the queue with
the "drop" and "max-buffers" properties.
If an EOS event was received before any buffers, this function returns
%NULL. Use gst_app_sink_is_eos () to check for the EOS condition.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a #GstBufferList or NULL when the appsink is stopped or EOS.</doc>
          <type name="Gst.BufferList"/>
        </return-value>
      </glib:signal>
      <glib:signal name="pull-preroll" introspectable="0">
        <doc xml:whitespace="preserve">Get the last preroll buffer in @appsink. This was the buffer that caused the
appsink to preroll in the PAUSED state. This buffer can be pulled many times
and remains available to the application even after EOS.
This function is typically used when dealing with a pipeline in the PAUSED
state. Calling this function after doing a seek will give the buffer right
after the seek position.
Note that the preroll buffer will also be returned as the first buffer
when calling gst_app_sink_pull_buffer() or the "pull-buffer" action signal.
If an EOS event was received before any buffers, this function returns
%NULL. Use gst_app_sink_is_eos () to check for the EOS condition. 
This function blocks until a preroll buffer or EOS is received or the appsink
element is set to the READY/NULL state.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a #GstBuffer or NULL when the appsink is stopped or EOS.</doc>
          <type name="Gst.Buffer"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="AppSinkCallbacks"
            c:type="GstAppSinkCallbacks"
            version="0.10.23">
      <doc xml:whitespace="preserve">A set of callbacks that can be installed on the appsink with
gst_app_sink_set_callbacks().</doc>
      <field name="eos">
        <callback name="eos">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AppSink" c:type="GstAppSink*"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_preroll">
        <callback name="new_preroll">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AppSink" c:type="GstAppSink*"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_buffer">
        <callback name="new_buffer">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AppSink" c:type="GstAppSink*"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_buffer_list">
        <callback name="new_buffer_list">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AppSink" c:type="GstAppSink*"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AppSinkClass"
            c:type="GstAppSinkClass"
            glib:is-gtype-struct-for="AppSink">
      <field name="basesink_class">
        <type name="GstBase.BaseSinkClass" c:type="GstBaseSinkClass"/>
      </field>
      <field name="eos">
        <callback name="eos">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AppSink" c:type="GstAppSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_preroll">
        <callback name="new_preroll">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AppSink" c:type="GstAppSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_buffer">
        <callback name="new_buffer">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AppSink" c:type="GstAppSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pull_preroll" introspectable="0">
        <callback name="pull_preroll" introspectable="0">
          <return-value>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AppSink" c:type="GstAppSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pull_buffer" introspectable="0">
        <callback name="pull_buffer" introspectable="0">
          <return-value>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AppSink" c:type="GstAppSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_buffer_list" introspectable="0">
        <callback name="new_buffer_list" introspectable="0">
          <return-value>
            <type name="Gst.BufferList" c:type="GstBufferList*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AppSink" c:type="GstAppSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pull_buffer_list" introspectable="0">
        <callback name="pull_buffer_list" introspectable="0">
          <return-value>
            <type name="Gst.BufferList" c:type="GstBufferList*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AppSink" c:type="GstAppSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AppSinkPrivate" c:type="GstAppSinkPrivate" disguised="1">
    </record>
    <class name="AppSrc"
           c:symbol-prefix="app_src"
           c:type="GstAppSrc"
           parent="GstBase.BaseSrc"
           glib:type-name="GstAppSrc"
           glib:get-type="gst_app_src_get_type"
           glib:type-struct="AppSrcClass">
      <implements name="Gst.URIHandler"/>
      <method name="end_of_stream"
              c:identifier="gst_app_src_end_of_stream"
              version="0.10.22">
        <doc xml:whitespace="preserve">Indicates to the appsrc element that the last buffer queued in the
element is the last buffer of the stream.
#GST_FLOW_WRONG_STATE when @appsrc is not PAUSED or PLAYING.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GST_FLOW_OK when the EOS was successfuly queued.</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
      </method>
      <method name="get_caps"
              c:identifier="gst_app_src_get_caps"
              version="0.10.22">
        <doc xml:whitespace="preserve">Get the configured caps on @appsrc.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstCaps produced by the source. gst_caps_unref() after usage.</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_emit_signals"
              c:identifier="gst_app_src_get_emit_signals"
              version="0.10.23">
        <doc xml:whitespace="preserve">Check if appsrc will emit the "new-preroll" and "new-buffer" signals.
signals.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @appsrc is emiting the "new-preroll" and "new-buffer"</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_latency"
              c:identifier="gst_app_src_get_latency"
              version="0.10.22">
        <doc xml:whitespace="preserve">Retrieve the min and max latencies in @min and @max respectively.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="min" transfer-ownership="none">
            <doc xml:whitespace="preserve">the min latency</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:whitespace="preserve">the min latency</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_max_bytes"
              c:identifier="gst_app_src_get_max_bytes"
              version="0.10.22">
        <doc xml:whitespace="preserve">Get the maximum amount of bytes that can be queued in @appsrc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The maximum amount of bytes that can be queued.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="get_size"
              c:identifier="gst_app_src_get_size"
              version="0.10.22">
        <doc xml:whitespace="preserve">Get the size of the stream in bytes. A value of -1 means that the size is
not known.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the stream previously set with gst_app_src_set_size();</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_stream_type"
              c:identifier="gst_app_src_get_stream_type"
              version="0.10.22">
        <doc xml:whitespace="preserve">Get the stream type. Control the stream type of @appsrc
with gst_app_src_set_stream_type().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the stream type.</doc>
          <type name="AppStreamType" c:type="GstAppStreamType"/>
        </return-value>
      </method>
      <method name="push_buffer"
              c:identifier="gst_app_src_push_buffer"
              version="0.10.22">
        <doc xml:whitespace="preserve">Adds a buffer to the queue of buffers that the appsrc element will
push to its source pad.  This function takes ownership of the buffer.
When the block property is TRUE, this function can block until free
space becomes available in the queue.
#GST_FLOW_WRONG_STATE when @appsrc is not PAUSED or PLAYING.
#GST_FLOW_UNEXPECTED when EOS occured.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GST_FLOW_OK when the buffer was successfuly queued.</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstBuffer to push</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_callbacks"
              c:identifier="gst_app_src_set_callbacks"
              version="0.10.23">
        <doc xml:whitespace="preserve">Set callbacks which will be executed when data is needed, enough data has
been collected or when a seek should be performed.
This is an alternative to using the signals, it has lower overhead and is thus
less expensive, but also less flexible.
If callbacks are installed, no signals will be emited for performance
reasons.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callbacks" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callbacks</doc>
            <type name="AppSrcCallbacks" c:type="GstAppSrcCallbacks*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a user_data argument for the callbacks</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">a destroy notify function</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_caps"
              c:identifier="gst_app_src_set_caps"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the capabilities on the appsrc element.  This function takes
a copy of the caps structure. After calling this method, the source will
only produce caps that match @caps. @caps must be fixed and the caps on the
buffers must match the caps or left NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">caps to set</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_emit_signals"
              c:identifier="gst_app_src_set_emit_signals"
              version="0.10.23">
        <doc xml:whitespace="preserve">Make appsrc emit the "new-preroll" and "new-buffer" signals. This option is
by default disabled because signal emission is expensive and unneeded when
the application prefers to operate in pull mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="emit" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_latency"
              c:identifier="gst_app_src_set_latency"
              version="0.10.22">
        <doc xml:whitespace="preserve">Configure the @min and @max latency in @src. If @min is set to -1, the
default latency calculations for pseudo-live sources will be used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="min" transfer-ownership="none">
            <doc xml:whitespace="preserve">the min latency</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:whitespace="preserve">the min latency</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_bytes"
              c:identifier="gst_app_src_set_max_bytes"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the maximum amount of bytes that can be queued in @appsrc.
After the maximum amount of bytes are queued, @appsrc will emit the
"enough-data" signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="max" transfer-ownership="none">
            <doc xml:whitespace="preserve">the maximum number of bytes to queue</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_size"
              c:identifier="gst_app_src_set_size"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the size of the stream in bytes. A value of -1 means that the size is
not known.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stream_type"
              c:identifier="gst_app_src_set_stream_type"
              version="0.10.22">
        <doc xml:whitespace="preserve">Set the stream type on @appsrc. For seekable streams, the "seek" signal must
be connected to.
A stream_type stream</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new state</doc>
            <type name="AppStreamType" c:type="GstAppStreamType"/>
          </parameter>
        </parameters>
      </method>
      <property name="block" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="caps" writable="1" transfer-ownership="none">
        <type name="Gst.Caps"/>
      </property>
      <property name="emit-signals" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="format"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="is-live" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="max-bytes" writable="1" transfer-ownership="none">
        <type name="guint64"/>
      </property>
      <property name="max-latency" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="min-latency" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="min-percent" writable="1" transfer-ownership="none">
        <type name="guint"/>
      </property>
      <property name="size" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="stream-type" writable="1" transfer-ownership="none">
        <type name="AppStreamType"/>
      </property>
      <field name="basesrc">
        <type name="GstBase.BaseSrc" c:type="GstBaseSrc"/>
      </field>
      <field name="priv">
        <type name="AppSrcPrivate" c:type="GstAppSrcPrivate*"/>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="end-of-stream" introspectable="0">
        <doc xml:whitespace="preserve">Notify @appsrc that no more buffer are available.</doc>
        <return-value>
          <type/>
        </return-value>
      </glib:signal>
      <glib:signal name="enough-data">
        <doc xml:whitespace="preserve">Signal that the source has enough data. It is recommended that the
application stops calling push-buffer until the need-data signal is
emited again to avoid excessive buffer queueing.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="need-data">
        <doc xml:whitespace="preserve">Signal that the source needs more data. In the callback or from another
thread you should call push-buffer or end-of-stream.
pushed into @appsrc.
You can call push-buffer multiple times until the enough-data signal is
fired.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the amount of bytes needed.</doc>
            <type name="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="push-buffer" introspectable="0">
        <doc xml:whitespace="preserve">Adds a buffer to the queue of buffers that the appsrc element will
push to its source pad. This function does not take ownership of the
buffer so the buffer needs to be unreffed after calling this function.
When the block property is TRUE, this function can block until free space
becomes available in the queue.</doc>
        <return-value>
          <type/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffer to push</doc>
            <type name="Gst.Buffer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="seek-data">
        <doc xml:whitespace="preserve">Seek to the given offset. The next push-buffer should produce buffers from
the new @offset.
This callback is only called for seekable stream types.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the seek succeeded.</doc>
          <type name="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset to seek to</doc>
            <type name="guint64"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AppSrcCallbacks"
            c:type="GstAppSrcCallbacks"
            version="0.10.23">
      <doc xml:whitespace="preserve">A set of callbacks that can be installed on the appsrc with
gst_app_src_set_callbacks().</doc>
      <field name="need_data">
        <callback name="need_data">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AppSrc" c:type="GstAppSrc*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="2">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enough_data">
        <callback name="enough_data">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AppSrc" c:type="GstAppSrc*"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek_data">
        <callback name="seek_data">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AppSrc" c:type="GstAppSrc*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="2">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AppSrcClass"
            c:type="GstAppSrcClass"
            glib:is-gtype-struct-for="AppSrc">
      <field name="basesrc_class">
        <type name="GstBase.BaseSrcClass" c:type="GstBaseSrcClass"/>
      </field>
      <field name="need_data">
        <callback name="need_data">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AppSrc" c:type="GstAppSrc*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="enough_data">
        <callback name="enough_data">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AppSrc" c:type="GstAppSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="seek_data">
        <callback name="seek_data">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AppSrc" c:type="GstAppSrc*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="push_buffer">
        <callback name="push_buffer">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AppSrc" c:type="GstAppSrc*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="end_of_stream">
        <callback name="end_of_stream">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AppSrc" c:type="GstAppSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AppSrcPrivate" c:type="GstAppSrcPrivate" disguised="1">
    </record>
    <enumeration name="AppStreamType"
                 glib:type-name="GstAppStreamType"
                 glib:get-type="gst_app_stream_type_get_type"
                 c:type="GstAppStreamType">
      <doc xml:whitespace="preserve">The stream type.</doc>
      <member name="stream"
              value="0"
              c:identifier="GST_APP_STREAM_TYPE_STREAM"
              glib:nick="stream"/>
      <member name="seekable"
              value="1"
              c:identifier="GST_APP_STREAM_TYPE_SEEKABLE"
              glib:nick="seekable"/>
      <member name="random_access"
              value="2"
              c:identifier="GST_APP_STREAM_TYPE_RANDOM_ACCESS"
              glib:nick="random-access"/>
    </enumeration>
  </namespace>
</repository>
